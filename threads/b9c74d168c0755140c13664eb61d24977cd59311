<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>October 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Introduction<br></p><p>This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br></p><p>New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br></p><p> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br></p><p>This proposal address two problems:<br></p><p>The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br></p><p>var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br></p><p>Swift coders normally test key membership using nil checks or underscored optional bindings:<br></p><p>if dict[&quot;one&quot;] != nil {<br>    // ...<br>}<br>if let _ = dict[&quot;one&quot;] {<br>    // ...<br>}<br>These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br></p><p>if dict.keys.contains(&quot;one&quot;) {<br>    // ...<br>}<br>A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br></p><p> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br></p><p>Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br></p><p>// Direct re-assignment<br>dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br></p><p>// Optional chaining<br>dict[&quot;one&quot;]?.append(1)<br>Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br></p><p>Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br></p><p> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br></p><p>This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br></p><p>These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br></p><p>// Performant<br>if dict.keys.contains(&quot;one&quot;) {<br>    // ...<br>}<br>As a mutable collection, values enables modification without copies or clumsy code:<br></p><p>if let i = dict.index(forKey: &quot;one&quot;) {<br>    dict.values[i].append(1)  // no copy here<br>} else {<br>    dict[&quot;one&quot;] = [1]<br>}<br>Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br></p><p>// Using `dict.keys.index(of:)`<br>if let i = dict.keys.index(of: &quot;one&quot;) {<br>    dict.values[i].append(1)<br>} else {<br>    dict[&quot;one&quot;] = [1]<br>}<br> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br></p><p>The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>    var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>    var values: DictionaryValues&lt;Key, Value&gt; { get set }<br></p><p>    // Remaining declarations<br>}<br></p><p>/// A collection view of a dictionary&#39;s keys.<br>struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>    typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>    subscript(i: Index) -&gt; Key { get }<br></p><p>    // Other `Collection` requirements<br>}<br></p><p>/// A mutable collection view of a dictionary&#39;s values.<br>struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>    typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>    subscript(i: Index) -&gt; Value { get set }<br></p><p>    // Other `Collection` requirements<br>}<br>A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br></p><p> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br></p><p>The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br></p><p>Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br></p><p> &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br></p><p>The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br></p><p>Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br></p><p>It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/b9c79311/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Very elegant solution. Strong +1; no other feedback comes to mind atm.<br></p><p><br>On Tue, Oct 11, 2016 at 4:28 PM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Introduction<br>&gt;<br>&gt; This proposal addresses significant unexpected performance gaps when using<br>&gt; dictionaries. It introduces type-specific collections for a Dictionary<br>&gt;  instance&#39;s keys and values properties.<br>&gt;<br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key<br>&gt; lookup and mutable access to dictionary values, enabling updates to be<br>&gt; performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This proposal address two problems:<br>&gt;<br>&gt;    - The Dictionary type keys implementation is inefficient, because<br>&gt;    LazyMapCollection doesn&#39;t know how to forward lookups to the<br>&gt;    underlying dictionary storage.<br>&gt;    - Dictionaries do not offer value-mutating APIs. The mutating<br>&gt;    key-based subscript wraps values in an Optional. This prevents types<br>&gt;    with copy-on-write optimizations from recognizing they are singly<br>&gt;    referenced.<br>&gt;<br>&gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt; demonstrate these problems:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;<br>&gt; Inefficient dict.keys Search<br>&gt;<br>&gt; Swift coders normally test key membership using nil checks or underscored<br>&gt; optional bindings:<br>&gt;<br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; These approaches provide the expected performance of a dictionary lookup<br>&gt; but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>&gt; but introduces a serious performance penalty: this approach requires a<br>&gt; linear search through a dictionary&#39;s keys to find a match.<br>&gt;<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>&gt; dict.keys.index(of:).<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient<br>&gt; Value Mutation<br>&gt;<br>&gt; Dictionary values can be modified through the keyed subscript by direct<br>&gt; reassignment or by using optional chaining. Both of these statements append<br>&gt; 1 to the array stored by the key &quot;one&quot;:<br>&gt;<br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;<br>&gt; Both approaches present problems. The first is complex and hard to read.<br>&gt; The second ignores the case where &quot;one&quot; is not a key in the dictionary.<br>&gt; It forces its check into a higher branch and encourages forced unwrapping.<br>&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt; introduce an unnecessary copy of the array&#39;s contents even though dict is<br>&gt; the sole holder of its storage.<br>&gt;<br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible.<br>&gt; Changing a key stored at a particular index would almost certainly modify<br>&gt; its hash value, rendering the index incorrect. This violates the<br>&gt; requirements of the MutableCollection protocol.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; This proposal adds a custom collection for the keys and values dictionary<br>&gt; properties. This follows the example set by String, which presents<br>&gt; multiple views of its contents. A new DictionaryKeys collection<br>&gt; introduces efficient key lookup, while a new DictionaryValues collection<br>&gt; provides a mutable collection interface to dictionary values.<br>&gt;<br>&gt; These changes introduce a simple and efficient way of checking whether a<br>&gt; dictionary includes a key:<br>&gt;<br>&gt; // Performantif dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; As a mutable collection, values enables modification without copies or<br>&gt; clumsy code:<br>&gt;<br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt;    - The standard library introduces two new collection types:<br>&gt;    DictionaryKeys and DictionaryValues.<br>&gt;    - A Dictionary&#39;s keys and values property types change from<br>&gt;    LazyMapCollection to these new types.<br>&gt;    - The new collection types are not directly constructable. They are<br>&gt;    presented only as views into a dictionary.<br>&gt;<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;<br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; /// A collection view of a dictionary&#39;s keys.struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; /// A mutable collection view of a dictionary&#39;s values.struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt;<br>&gt; A sample implementation of this proposal can be found in this branch<br>&gt; &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The performance improvements of using the new DictionaryKeys type and the<br>&gt; mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;<br>&gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt; proposal should not produce a major impact on existing code. The only<br>&gt; impact on existing code exists where a program explicitly specifies the<br>&gt; type of a dictionary&#39;s keysor values property. The fix is to change the<br>&gt; specified type.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The Generics Manifesto<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists<br>&gt; nested generics as a goal. This could impact the naming and structure of<br>&gt; these new collection types.<br>&gt;<br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>&gt; these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>&gt; Value&gt;.Values. However, because many types in the standard library may be<br>&gt; revisited once such a feature is available (indices, iterators, etc.), the<br>&gt; current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; It could be possible to add additional compiler features that manage<br>&gt; mutation through existing key-based subscripting without the copy-on-write<br>&gt; problems of the current implementation. I don&#39;t know enough about how that<br>&gt; would be implemented to speak to its feasibility or level of effort. Such a<br>&gt; feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/02ec3144/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Awesome; +1.  Does this address the lack of .init(keys:values:)?  Would it make that addition easier?<br></p><p>&gt; On Oct 11, 2016, at 3:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Very elegant solution. Strong +1; no other feedback comes to mind atm.<br>&gt; <br>&gt; <br>&gt; On Tue, Oct 11, 2016 at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/e8ea2113/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>October 11, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 5:06 PM, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Awesome; +1.  Does this address the lack of .init(keys:values:)?  Would it make that addition easier?<br></p><p>No, I don&#39;t think this has any bearing on that question. There&#39;s a separate proposal for that sort of initializer that was deferred from the Swift 3 evolution process (probably until stage 2 of Swift 4 since it&#39;s additive):<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0100-add-sequence-based-init-and-merge-to-dictionary.md<br></p><p>Nate<br></p><p>&gt;&gt; On Oct 11, 2016, at 3:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Very elegant solution. Strong +1; no other feedback comes to mind atm.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Oct 11, 2016 at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt;&gt; <br>&gt;&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This proposal address two problems:<br>&gt;&gt; <br>&gt;&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt;&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt;&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt;&gt; <br>&gt;&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt;&gt; <br>&gt;&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt;&gt; <br>&gt;&gt; if dict[&quot;one&quot;] != nil {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt;&gt; <br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt;&gt; <br>&gt;&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt;&gt; <br>&gt;&gt; // Direct re-assignment<br>&gt;&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;&gt; <br>&gt;&gt; // Optional chaining<br>&gt;&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt;&gt; <br>&gt;&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt;&gt; <br>&gt;&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt;&gt; <br>&gt;&gt; // Performant<br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt;&gt; <br>&gt;&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)  // no copy here<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt; <br>&gt;&gt; // Using `dict.keys.index(of:)`<br>&gt;&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt;&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt;&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt;&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;&gt; <br>&gt;&gt;     // Remaining declarations<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt;&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt;&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;&gt; <br>&gt;&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt;&gt; <br>&gt;&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt;&gt; <br>&gt;&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/bc92c833/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 11, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree. I like this proposal.<br></p><p>-- E<br></p><p>&gt; On Oct 11, 2016, at 3:38 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Very elegant solution. Strong +1; no other feedback comes to mind atm.<br>&gt; <br>&gt; <br>&gt; On Tue, Oct 11, 2016 at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/2ee5db7e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Looks very nice.  +1 here as well.<br></p><p>&gt; On Oct 11, 2016, at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/2e018b07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>October 11, 2016 at 10:00:00pm</p></header><div class="content"><p>As someone who&#39;s hit this performance issue myself, a big +1 from me. The<br>solution looks like it fits perfectly into Swift.<br></p><p><br>On Tue, Oct 11, 2016 at 3:01 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Looks very nice.  +1 here as well.<br>&gt;<br>&gt; On Oct 11, 2016, at 4:28 PM, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal addresses significant unexpected performance gaps when using<br>&gt; dictionaries. It introduces type-specific collections for a Dictionary<br>&gt;  instance&#39;s keys and values properties.<br>&gt;<br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key<br>&gt; lookup and mutable access to dictionary values, enabling updates to be<br>&gt; performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This proposal address two problems:<br>&gt;<br>&gt;    - The Dictionary type keys implementation is inefficient, because<br>&gt;    LazyMapCollection doesn&#39;t know how to forward lookups to the<br>&gt;    underlying dictionary storage.<br>&gt;    - Dictionaries do not offer value-mutating APIs. The mutating<br>&gt;    key-based subscript wraps values in an Optional. This prevents types<br>&gt;    with copy-on-write optimizations from recognizing they are singly<br>&gt;    referenced.<br>&gt;<br>&gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt; demonstrate these problems:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;<br>&gt; Inefficient dict.keys Search<br>&gt;<br>&gt; Swift coders normally test key membership using nil checks or underscored<br>&gt; optional bindings:<br>&gt;<br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; These approaches provide the expected performance of a dictionary lookup<br>&gt; but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>&gt; but introduces a serious performance penalty: this approach requires a<br>&gt; linear search through a dictionary&#39;s keys to find a match.<br>&gt;<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>&gt; dict.keys.index(of:).<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient<br>&gt; Value Mutation<br>&gt;<br>&gt; Dictionary values can be modified through the keyed subscript by direct<br>&gt; reassignment or by using optional chaining. Both of these statements append<br>&gt; 1 to the array stored by the key &quot;one&quot;:<br>&gt;<br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;<br>&gt; Both approaches present problems. The first is complex and hard to read.<br>&gt; The second ignores the case where &quot;one&quot; is not a key in the dictionary.<br>&gt; It forces its check into a higher branch and encourages forced unwrapping.<br>&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt; introduce an unnecessary copy of the array&#39;s contents even though dict is<br>&gt; the sole holder of its storage.<br>&gt;<br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible.<br>&gt; Changing a key stored at a particular index would almost certainly modify<br>&gt; its hash value, rendering the index incorrect. This violates the<br>&gt; requirements of the MutableCollection protocol.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; This proposal adds a custom collection for the keys and values dictionary<br>&gt; properties. This follows the example set by String, which presents<br>&gt; multiple views of its contents. A new DictionaryKeys collection<br>&gt; introduces efficient key lookup, while a new DictionaryValues collection<br>&gt; provides a mutable collection interface to dictionary values.<br>&gt;<br>&gt; These changes introduce a simple and efficient way of checking whether a<br>&gt; dictionary includes a key:<br>&gt;<br>&gt; // Performantif dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; As a mutable collection, values enables modification without copies or<br>&gt; clumsy code:<br>&gt;<br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt;    - The standard library introduces two new collection types:<br>&gt;    DictionaryKeys and DictionaryValues.<br>&gt;    - A Dictionary&#39;s keys and values property types change from<br>&gt;    LazyMapCollection to these new types.<br>&gt;    - The new collection types are not directly constructable. They are<br>&gt;    presented only as views into a dictionary.<br>&gt;<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;<br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; /// A collection view of a dictionary&#39;s keys.struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; /// A mutable collection view of a dictionary&#39;s values.struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt;<br>&gt; A sample implementation of this proposal can be found in this branch<br>&gt; &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The performance improvements of using the new DictionaryKeys type and the<br>&gt; mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;<br>&gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt; proposal should not produce a major impact on existing code. The only<br>&gt; impact on existing code exists where a program explicitly specifies the<br>&gt; type of a dictionary&#39;s keysor values property. The fix is to change the<br>&gt; specified type.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The Generics Manifesto<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists<br>&gt; nested generics as a goal. This could impact the naming and structure of<br>&gt; these new collection types.<br>&gt;<br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>&gt; these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>&gt; Value&gt;.Values. However, because many types in the standard library may be<br>&gt; revisited once such a feature is available (indices, iterators, etc.), the<br>&gt; current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; It could be possible to add additional compiler features that manage<br>&gt; mutation through existing key-based subscripting without the copy-on-write<br>&gt; problems of the current implementation. I don&#39;t know enough about how that<br>&gt; would be implemented to speak to its feasibility or level of effort. Such a<br>&gt; feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/e3c9db14/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>October 11, 2016 at 09:00:00pm</p></header><div class="content"><p>+1. Haven&#39;t hit this issue personally, but I agree it&#39;s important and the<br>proposed solution seems like the right fix.<br></p><p>On Tue, Oct 11, 2016 at 2:28 PM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Introduction<br>&gt;<br>&gt; This proposal addresses significant unexpected performance gaps when using<br>&gt; dictionaries. It introduces type-specific collections for a Dictionary<br>&gt;  instance&#39;s keys and values properties.<br>&gt;<br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key<br>&gt; lookup and mutable access to dictionary values, enabling updates to be<br>&gt; performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This proposal address two problems:<br>&gt;<br>&gt;    - The Dictionary type keys implementation is inefficient, because<br>&gt;    LazyMapCollection doesn&#39;t know how to forward lookups to the<br>&gt;    underlying dictionary storage.<br>&gt;    - Dictionaries do not offer value-mutating APIs. The mutating<br>&gt;    key-based subscript wraps values in an Optional. This prevents types<br>&gt;    with copy-on-write optimizations from recognizing they are singly<br>&gt;    referenced.<br>&gt;<br>&gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt; demonstrate these problems:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;<br>&gt; Inefficient dict.keys Search<br>&gt;<br>&gt; Swift coders normally test key membership using nil checks or underscored<br>&gt; optional bindings:<br>&gt;<br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; These approaches provide the expected performance of a dictionary lookup<br>&gt; but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>&gt; but introduces a serious performance penalty: this approach requires a<br>&gt; linear search through a dictionary&#39;s keys to find a match.<br>&gt;<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>&gt; dict.keys.index(of:).<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient<br>&gt; Value Mutation<br>&gt;<br>&gt; Dictionary values can be modified through the keyed subscript by direct<br>&gt; reassignment or by using optional chaining. Both of these statements append<br>&gt; 1 to the array stored by the key &quot;one&quot;:<br>&gt;<br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;<br>&gt; Both approaches present problems. The first is complex and hard to read.<br>&gt; The second ignores the case where &quot;one&quot; is not a key in the dictionary.<br>&gt; It forces its check into a higher branch and encourages forced unwrapping.<br>&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt; introduce an unnecessary copy of the array&#39;s contents even though dict is<br>&gt; the sole holder of its storage.<br>&gt;<br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible.<br>&gt; Changing a key stored at a particular index would almost certainly modify<br>&gt; its hash value, rendering the index incorrect. This violates the<br>&gt; requirements of the MutableCollection protocol.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; This proposal adds a custom collection for the keys and values dictionary<br>&gt; properties. This follows the example set by String, which presents<br>&gt; multiple views of its contents. A new DictionaryKeys collection<br>&gt; introduces efficient key lookup, while a new DictionaryValues collection<br>&gt; provides a mutable collection interface to dictionary values.<br>&gt;<br>&gt; These changes introduce a simple and efficient way of checking whether a<br>&gt; dictionary includes a key:<br>&gt;<br>&gt; // Performantif dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt;<br>&gt; As a mutable collection, values enables modification without copies or<br>&gt; clumsy code:<br>&gt;<br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt;    - The standard library introduces two new collection types:<br>&gt;    DictionaryKeys and DictionaryValues.<br>&gt;    - A Dictionary&#39;s keys and values property types change from<br>&gt;    LazyMapCollection to these new types.<br>&gt;    - The new collection types are not directly constructable. They are<br>&gt;    presented only as views into a dictionary.<br>&gt;<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;<br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; /// A collection view of a dictionary&#39;s keys.struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; /// A mutable collection view of a dictionary&#39;s values.struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;<br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt;<br>&gt; A sample implementation of this proposal can be found in this branch<br>&gt; &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The performance improvements of using the new DictionaryKeys type and the<br>&gt; mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;<br>&gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt; proposal should not produce a major impact on existing code. The only<br>&gt; impact on existing code exists where a program explicitly specifies the<br>&gt; type of a dictionary&#39;s keysor values property. The fix is to change the<br>&gt; specified type.<br>&gt;<br>&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; The Generics Manifesto<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists<br>&gt; nested generics as a goal. This could impact the naming and structure of<br>&gt; these new collection types.<br>&gt;<br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>&gt; these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>&gt; Value&gt;.Values. However, because many types in the standard library may be<br>&gt; revisited once such a feature is available (indices, iterators, etc.), the<br>&gt; current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; It could be possible to add additional compiler features that manage<br>&gt; mutation through existing key-based subscripting without the copy-on-write<br>&gt; problems of the current implementation. I don&#39;t know enough about how that<br>&gt; would be implemented to speak to its feasibility or level of effort. Such a<br>&gt; feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/108b099d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 12, 2016 at 07:00:00am</p></header><div class="content"><p>+1 from me. Seems like a solid change.<br></p><p>On Wed, Oct 12, 2016 at 12:39 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1. Haven&#39;t hit this issue personally, but I agree it&#39;s important and the<br>&gt; proposed solution seems like the right fix.<br>&gt;<br>&gt; On Tue, Oct 11, 2016 at 2:28 PM, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal addresses significant unexpected performance gaps when<br>&gt;&gt; using dictionaries. It introduces type-specific collections for a<br>&gt;&gt; Dictionary instance&#39;s keys and values properties.<br>&gt;&gt;<br>&gt;&gt; New DictionaryKeys and DictionaryValues collections provide efficient<br>&gt;&gt; key lookup and mutable access to dictionary values, enabling updates to be<br>&gt;&gt; performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; This proposal address two problems:<br>&gt;&gt;<br>&gt;&gt;    - The Dictionary type keys implementation is inefficient, because<br>&gt;&gt;    LazyMapCollection doesn&#39;t know how to forward lookups to the<br>&gt;&gt;    underlying dictionary storage.<br>&gt;&gt;    - Dictionaries do not offer value-mutating APIs. The mutating<br>&gt;&gt;    key-based subscript wraps values in an Optional. This prevents types<br>&gt;&gt;    with copy-on-write optimizations from recognizing they are singly<br>&gt;&gt;    referenced.<br>&gt;&gt;<br>&gt;&gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt;&gt; demonstrate these problems:<br>&gt;&gt;<br>&gt;&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;<br>&gt;&gt; Inefficient dict.keys Search<br>&gt;&gt;<br>&gt;&gt; Swift coders normally test key membership using nil checks or<br>&gt;&gt; underscored optional bindings:<br>&gt;&gt;<br>&gt;&gt; if dict[&quot;one&quot;] != nil {<br>&gt;&gt;     // ...<br>&gt;&gt; }if let _ = dict[&quot;one&quot;] {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; These approaches provide the expected performance of a dictionary lookup<br>&gt;&gt; but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>&gt;&gt; but introduces a serious performance penalty: this approach requires a<br>&gt;&gt; linear search through a dictionary&#39;s keys to find a match.<br>&gt;&gt;<br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>&gt;&gt; dict.keys.index(of:).<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient<br>&gt;&gt; Value Mutation<br>&gt;&gt;<br>&gt;&gt; Dictionary values can be modified through the keyed subscript by direct<br>&gt;&gt; reassignment or by using optional chaining. Both of these statements append<br>&gt;&gt; 1 to the array stored by the key &quot;one&quot;:<br>&gt;&gt;<br>&gt;&gt; // Direct re-assignment<br>&gt;&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;&gt; // Optional chaining<br>&gt;&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;&gt;<br>&gt;&gt; Both approaches present problems. The first is complex and hard to read.<br>&gt;&gt; The second ignores the case where &quot;one&quot; is not a key in the dictionary.<br>&gt;&gt; It forces its check into a higher branch and encourages forced unwrapping.<br>&gt;&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt;&gt; introduce an unnecessary copy of the array&#39;s contents even though dict is<br>&gt;&gt; the sole holder of its storage.<br>&gt;&gt;<br>&gt;&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t<br>&gt;&gt; possible. Changing a key stored at a particular index would almost<br>&gt;&gt; certainly modify its hash value, rendering the index incorrect. This<br>&gt;&gt; violates the requirements of the MutableCollection protocol.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed<br>&gt;&gt; Solution<br>&gt;&gt;<br>&gt;&gt; This proposal adds a custom collection for the keys and values dictionary<br>&gt;&gt; properties. This follows the example set by String, which presents<br>&gt;&gt; multiple views of its contents. A new DictionaryKeys collection<br>&gt;&gt; introduces efficient key lookup, while a new DictionaryValues collection<br>&gt;&gt; provides a mutable collection interface to dictionary values.<br>&gt;&gt;<br>&gt;&gt; These changes introduce a simple and efficient way of checking whether a<br>&gt;&gt; dictionary includes a key:<br>&gt;&gt;<br>&gt;&gt; // Performantif dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; As a mutable collection, values enables modification without copies or<br>&gt;&gt; clumsy code:<br>&gt;&gt;<br>&gt;&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)  // no copy here<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Both the keys and values collections share the same index type as<br>&gt;&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt;<br>&gt;&gt; // Using `dict.keys.index(of:)`if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt;    - The standard library introduces two new collection types:<br>&gt;&gt;    DictionaryKeys and DictionaryValues.<br>&gt;&gt;    - A Dictionary&#39;s keys and values property types change from<br>&gt;&gt;    LazyMapCollection to these new types.<br>&gt;&gt;    - The new collection types are not directly constructable. They are<br>&gt;&gt;    presented only as views into a dictionary.<br>&gt;&gt;<br>&gt;&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;&gt;<br>&gt;&gt;     // Remaining declarations<br>&gt;&gt; }<br>&gt;&gt; /// A collection view of a dictionary&#39;s keys.struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;&gt;<br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; /// A mutable collection view of a dictionary&#39;s values.struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;&gt;<br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; A sample implementation of this proposal can be found in this branch<br>&gt;&gt; &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; The performance improvements of using the new DictionaryKeys type and<br>&gt;&gt; the mutability of the DictionaryValuescollection are both additive in<br>&gt;&gt; nature.<br>&gt;&gt;<br>&gt;&gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt;&gt; proposal should not produce a major impact on existing code. The only<br>&gt;&gt; impact on existing code exists where a program explicitly specifies the<br>&gt;&gt; type of a dictionary&#39;s keysor values property. The fix is to change the<br>&gt;&gt; specified type.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; The Generics Manifesto<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists<br>&gt;&gt; nested generics as a goal. This could impact the naming and structure of<br>&gt;&gt; these new collection types.<br>&gt;&gt;<br>&gt;&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>&gt;&gt; these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>&gt;&gt; Value&gt;.Values. However, because many types in the standard library may<br>&gt;&gt; be revisited once such a feature is available (indices, iterators, etc.),<br>&gt;&gt; the current lack of nesting shouldn&#39;t prevent consideration of this<br>&gt;&gt; proposal.<br>&gt;&gt; It could be possible to add additional compiler features that manage<br>&gt;&gt; mutation through existing key-based subscripting without the copy-on-write<br>&gt;&gt; problems of the current implementation. I don&#39;t know enough about how that<br>&gt;&gt; would be implemented to speak to its feasibility or level of effort. Such a<br>&gt;&gt; feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/44ad4638/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 12, 2016 at 08:00:00am</p></header><div class="content"><p>Beautiful, +1<br></p><p>Rien<br></p><p>&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; 	 The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; 	 Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt; Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil<br>&gt;  {<br>&gt;     <br>&gt; // ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; if let _ = dict[&quot;one&quot;<br>&gt; ] {<br>&gt;     <br>&gt; // ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; <br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt; Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; <br>&gt; dict[<br>&gt; &quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1<br>&gt; ]<br>&gt; <br>&gt; <br>&gt; // Optional chaining<br>&gt; <br>&gt; dict[<br>&gt; &quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt; Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;<br>&gt; ) {<br>&gt;     <br>&gt; // ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;<br>&gt; ) {<br>&gt;     dict<br>&gt; .values[i].append(1)  // no copy here<br>&gt; <br>&gt; } <br>&gt; else<br>&gt;  {<br>&gt;     dict[<br>&gt; &quot;one&quot;] = [1<br>&gt; ]<br>&gt; }<br>&gt; <br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;<br>&gt; ) {<br>&gt;     dict<br>&gt; .values[i].append(1<br>&gt; )<br>&gt; } <br>&gt; else<br>&gt;  {<br>&gt;     dict[<br>&gt; &quot;one&quot;] = [1<br>&gt; ]<br>&gt; }<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; 	 The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; 	 A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; 	 The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ...<br>&gt;  {<br>&gt;     <br>&gt; var keys: DictionaryKeys&lt;Key, Value&gt; { get<br>&gt;  }<br>&gt;     <br>&gt; var values: DictionaryValues&lt;Key, Value&gt; { get set<br>&gt;  }<br>&gt; <br>&gt;     <br>&gt; // Remaining declarations<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;<br>&gt; : Collection {<br>&gt;     <br>&gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt; <br>&gt;     <br>&gt; subscript(i: Index) -&gt; Key { get<br>&gt;  }<br>&gt; <br>&gt;     <br>&gt; // Other `Collection` requirements<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;<br>&gt; : MutableCollection {<br>&gt;     <br>&gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt; <br>&gt;     <br>&gt; subscript(i: Index) -&gt; Value { get set<br>&gt;  }<br>&gt; <br>&gt;     <br>&gt; // Other `Collection` requirements<br>&gt; <br>&gt; }<br>&gt; <br>&gt; A sample implementation of this proposal can be found in this branch.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8eeb9ac8c83f684a210d9a2f8f1eb14?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Said Sikira</string> &lt;saidsikira at gmail.com&gt;<p>October 12, 2016 at 12:00:00am</p></header><div class="content"><p>+1<br></p><p><br>On October 12, 2016 at 8:54:45 AM, Rien via swift-evolution (<br>swift-evolution at swift.org) wrote:<br></p><p>Beautiful, +1<br></p><p>Rien<br></p><p>&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal addresses significant unexpected performance gaps when<br>using dictionaries. It introduces type-specific collections for a<br>Dictionary instance&#39;s keys and values properties.<br>&gt;<br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key<br>lookup and mutable access to dictionary values, enabling updates to be<br>performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This proposal address two problems:<br>&gt;<br>&gt;  The Dictionary type keys implementation is inefficient, because<br>LazyMapCollection doesn&#39;t know how to forward lookups to the underlying<br>dictionary storage.<br>&gt;  Dictionaries do not offer value-mutating APIs. The mutating key-based<br>subscript wraps values in an Optional. This prevents types with<br>copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to<br>demonstrate these problems:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt; Inefficient dict.keys Search<br>&gt;<br>&gt; Swift coders normally test key membership using nil checks or underscored<br>optional bindings:<br>&gt;<br>&gt; if dict[&quot;one&quot;] != nil<br>&gt; {<br>&gt;<br>&gt; // ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; if let _ = dict[&quot;one&quot;<br>&gt; ] {<br>&gt;<br>&gt; // ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; These approaches provide the expected performance of a dictionary lookup<br>but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>but introduces a serious performance penalty: this approach requires a<br>linear search through a dictionary&#39;s keys to find a match.<br>&gt;<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>dict.keys.index(of:).<br>&gt;<br>&gt; Inefficient Value Mutation<br>&gt;<br>&gt; Dictionary values can be modified through the keyed subscript by direct<br>reassignment or by using optional chaining. Both of these statements append<br>1 to the array stored by the key &quot;one&quot;:<br>&gt;<br>&gt; // Direct re-assignment<br>&gt;<br>&gt; dict[<br>&gt; &quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1<br>&gt; ]<br>&gt;<br>&gt;<br>&gt; // Optional chaining<br>&gt;<br>&gt; dict[<br>&gt; &quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read.<br>The second ignores the case where &quot;one&quot; is not a key in the dictionary. It<br>forces its check into a higher branch and encourages forced unwrapping.<br>Furthermore, neither approach allows the array to grow in place. They<br>introduce an unnecessary copy of the array&#39;s contents even though dict is<br>the sole holder of its storage.<br>&gt;<br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t<br>possible. Changing a key stored at a particular index would almost<br>certainly modify its hash value, rendering the index incorrect. This<br>violates the requirements of the MutableCollection protocol.<br>&gt;<br>&gt; Proposed Solution<br>&gt;<br>&gt; This proposal adds a custom collection for the keys and values dictionary<br>properties. This follows the example set by String, which presents multiple<br>views of its contents. A new DictionaryKeys collection introduces efficient<br>key lookup, while a new DictionaryValues collection provides a mutable<br>collection interface to dictionary values.<br>&gt;<br>&gt; These changes introduce a simple and efficient way of checking whether a<br>dictionary includes a key:<br>&gt;<br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;<br>&gt; ) {<br>&gt;<br>&gt; // ...<br>&gt;<br>&gt; }<br>&gt;<br>&gt; As a mutable collection, values enables modification without copies or<br>clumsy code:<br>&gt;<br>&gt; if let i = dict.index(forKey: &quot;one&quot;<br>&gt; ) {<br>&gt; dict<br>&gt; .values[i].append(1) // no copy here<br>&gt;<br>&gt; }<br>&gt; else<br>&gt; {<br>&gt; dict[<br>&gt; &quot;one&quot;] = [1<br>&gt; ]<br>&gt; }<br>&gt;<br>&gt; Both the keys and values collections share the same index type as<br>Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;<br>&gt; ) {<br>&gt; dict<br>&gt; .values[i].append(1<br>&gt; )<br>&gt; }<br>&gt; else<br>&gt; {<br>&gt; dict[<br>&gt; &quot;one&quot;] = [1<br>&gt; ]<br>&gt; }<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt;  The standard library introduces two new collection types:<br>DictionaryKeys and DictionaryValues.<br>&gt;  A Dictionary&#39;s keys and values property types change from<br>LazyMapCollection to these new types.<br>&gt;  The new collection types are not directly constructable. They are<br>presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ...<br>&gt; {<br>&gt;<br>&gt; var keys: DictionaryKeys&lt;Key, Value&gt; { get<br>&gt; }<br>&gt;<br>&gt; var values: DictionaryValues&lt;Key, Value&gt; { get set<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // Remaining declarations<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;<br>&gt; : Collection {<br>&gt;<br>&gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;<br>&gt;<br>&gt; subscript(i: Index) -&gt; Key { get<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // Other `Collection` requirements<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;<br>&gt; : MutableCollection {<br>&gt;<br>&gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;<br>&gt;<br>&gt; subscript(i: Index) -&gt; Value { get set<br>&gt; }<br>&gt;<br>&gt;<br>&gt; // Other `Collection` requirements<br>&gt;<br>&gt; }<br>&gt;<br>&gt; A sample implementation of this proposal can be found in this branch.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; The performance improvements of using the new DictionaryKeys type and the<br>mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;<br>&gt; Most uses of these properties are transitory in nature. Adopting this<br>proposal should not produce a major impact on existing code. The only<br>impact on existing code exists where a program explicitly specifies the<br>type of a dictionary&#39;s keysor values property. The fix is to change the<br>specified type.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; The Generics Manifesto lists nested generics as a goal. This could impact<br>the naming and structure of these new collection types.<br>&gt;<br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>Value&gt;.Values. However, because many types in the standard library may be<br>revisited once such a feature is available (indices, iterators, etc.), the<br>current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt;<br>&gt; It could be possible to add additional compiler features that manage<br>mutation through existing key-based subscripting without the copy-on-write<br>problems of the current implementation. I don&#39;t know enough about how that<br>would be implemented to speak to its feasibility or level of effort. Such a<br>feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/6c026834/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/55de99118e0083e19447f63c9ebacc42?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Stephan Knitelius</string> &lt;stephan at knitelius.com&gt;<p>October 12, 2016 at 07:00:00am</p></header><div class="content"><p>+1<br></p><p>On Wed, 12 Oct 2016 at 09:09 Said Sikira via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt;<br>&gt; On October 12, 2016 at 8:54:45 AM, Rien via swift-evolution (<br>&gt; swift-evolution at swift.org) wrote:<br>&gt;<br>&gt; Beautiful, +1<br>&gt;<br>&gt; Rien<br>&gt;<br>&gt; &gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; This proposal addresses significant unexpected performance gaps when<br>&gt; using dictionaries. It introduces type-specific collections for a<br>&gt; Dictionary instance&#39;s keys and values properties.<br>&gt; &gt;<br>&gt; &gt; New DictionaryKeys and DictionaryValues collections provide efficient<br>&gt; key lookup and mutable access to dictionary values, enabling updates to be<br>&gt; performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; This proposal address two problems:<br>&gt; &gt;<br>&gt; &gt;  The Dictionary type keys implementation is inefficient, because<br>&gt; LazyMapCollection doesn&#39;t know how to forward lookups to the underlying<br>&gt; dictionary storage.<br>&gt; &gt;  Dictionaries do not offer value-mutating APIs. The mutating key-based<br>&gt; subscript wraps values in an Optional. This prevents types with<br>&gt; copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; &gt; This proposal uses the following [String: [Int]] dictionary to<br>&gt; demonstrate these problems:<br>&gt; &gt;<br>&gt; &gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt; &gt; Inefficient dict.keys Search<br>&gt; &gt;<br>&gt; &gt; Swift coders normally test key membership using nil checks or<br>&gt; underscored optional bindings:<br>&gt; &gt;<br>&gt; &gt; if dict[&quot;one&quot;] != nil<br>&gt; &gt; {<br>&gt; &gt;<br>&gt; &gt; // ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; if let _ = dict[&quot;one&quot;<br>&gt; &gt; ] {<br>&gt; &gt;<br>&gt; &gt; // ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; These approaches provide the expected performance of a dictionary lookup<br>&gt; but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better<br>&gt; but introduces a serious performance penalty: this approach requires a<br>&gt; linear search through a dictionary&#39;s keys to find a match.<br>&gt; &gt;<br>&gt; &gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt; &gt; // ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; A similar dynamic plays out when comparing dict.index(forKey:) and<br>&gt; dict.keys.index(of:).<br>&gt; &gt;<br>&gt; &gt; Inefficient Value Mutation<br>&gt; &gt;<br>&gt; &gt; Dictionary values can be modified through the keyed subscript by direct<br>&gt; reassignment or by using optional chaining. Both of these statements append<br>&gt; 1 to the array stored by the key &quot;one&quot;:<br>&gt; &gt;<br>&gt; &gt; // Direct re-assignment<br>&gt; &gt;<br>&gt; &gt; dict[<br>&gt; &gt; &quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1<br>&gt; &gt; ]<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Optional chaining<br>&gt; &gt;<br>&gt; &gt; dict[<br>&gt; &gt; &quot;one&quot;]?.append(1)<br>&gt; &gt; Both approaches present problems. The first is complex and hard to read.<br>&gt; The second ignores the case where &quot;one&quot; is not a key in the dictionary. It<br>&gt; forces its check into a higher branch and encourages forced unwrapping.<br>&gt; Furthermore, neither approach allows the array to grow in place. They<br>&gt; introduce an unnecessary copy of the array&#39;s contents even though dict is<br>&gt; the sole holder of its storage.<br>&gt; &gt;<br>&gt; &gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t<br>&gt; possible. Changing a key stored at a particular index would almost<br>&gt; certainly modify its hash value, rendering the index incorrect. This<br>&gt; violates the requirements of the MutableCollection protocol.<br>&gt; &gt;<br>&gt; &gt; Proposed Solution<br>&gt; &gt;<br>&gt; &gt; This proposal adds a custom collection for the keys and values<br>&gt; dictionary properties. This follows the example set by String, which<br>&gt; presents multiple views of its contents. A new DictionaryKeys collection<br>&gt; introduces efficient key lookup, while a new DictionaryValues collection<br>&gt; provides a mutable collection interface to dictionary values.<br>&gt; &gt;<br>&gt; &gt; These changes introduce a simple and efficient way of checking whether a<br>&gt; dictionary includes a key:<br>&gt; &gt;<br>&gt; &gt; // Performant<br>&gt; &gt; if dict.keys.contains(&quot;one&quot;<br>&gt; &gt; ) {<br>&gt; &gt;<br>&gt; &gt; // ...<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; As a mutable collection, values enables modification without copies or<br>&gt; clumsy code:<br>&gt; &gt;<br>&gt; &gt; if let i = dict.index(forKey: &quot;one&quot;<br>&gt; &gt; ) {<br>&gt; &gt; dict<br>&gt; &gt; .values[i].append(1) // no copy here<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt; else<br>&gt; &gt; {<br>&gt; &gt; dict[<br>&gt; &gt; &quot;one&quot;] = [1<br>&gt; &gt; ]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt; &gt;<br>&gt; &gt; // Using `dict.keys.index(of:)`<br>&gt; &gt; if let i = dict.keys.index(of: &quot;one&quot;<br>&gt; &gt; ) {<br>&gt; &gt; dict<br>&gt; &gt; .values[i].append(1<br>&gt; &gt; )<br>&gt; &gt; }<br>&gt; &gt; else<br>&gt; &gt; {<br>&gt; &gt; dict[<br>&gt; &gt; &quot;one&quot;] = [1<br>&gt; &gt; ]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Detailed design<br>&gt; &gt;<br>&gt; &gt;  The standard library introduces two new collection types:<br>&gt; DictionaryKeys and DictionaryValues.<br>&gt; &gt;  A Dictionary&#39;s keys and values property types change from<br>&gt; LazyMapCollection to these new types.<br>&gt; &gt;  The new collection types are not directly constructable. They are<br>&gt; presented only as views into a dictionary.<br>&gt; &gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ...<br>&gt; &gt; {<br>&gt; &gt;<br>&gt; &gt; var keys: DictionaryKeys&lt;Key, Value&gt; { get<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; var values: DictionaryValues&lt;Key, Value&gt; { get set<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Remaining declarations<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; &gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;<br>&gt; &gt; : Collection {<br>&gt; &gt;<br>&gt; &gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; subscript(i: Index) -&gt; Key { get<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Other `Collection` requirements<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; &gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;<br>&gt; &gt; : MutableCollection {<br>&gt; &gt;<br>&gt; &gt; typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; subscript(i: Index) -&gt; Value { get set<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; // Other `Collection` requirements<br>&gt; &gt;<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; A sample implementation of this proposal can be found in this branch.<br>&gt; &gt;<br>&gt; &gt; Impact on existing code<br>&gt; &gt;<br>&gt; &gt; The performance improvements of using the new DictionaryKeys type and<br>&gt; the mutability of the DictionaryValuescollection are both additive in<br>&gt; nature.<br>&gt; &gt;<br>&gt; &gt; Most uses of these properties are transitory in nature. Adopting this<br>&gt; proposal should not produce a major impact on existing code. The only<br>&gt; impact on existing code exists where a program explicitly specifies the<br>&gt; type of a dictionary&#39;s keysor values property. The fix is to change the<br>&gt; specified type.<br>&gt; &gt;<br>&gt; &gt; Alternatives considered<br>&gt; &gt;<br>&gt; &gt; The Generics Manifesto lists nested generics as a goal. This could<br>&gt; impact the naming and structure of these new collection types.<br>&gt; &gt;<br>&gt; &gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;,<br>&gt; these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key,<br>&gt; Value&gt;.Values. However, because many types in the standard library may be<br>&gt; revisited once such a feature is available (indices, iterators, etc.), the<br>&gt; current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; &gt;<br>&gt; &gt; It could be possible to add additional compiler features that manage<br>&gt; mutation through existing key-based subscripting without the copy-on-write<br>&gt; problems of the current implementation. I don&#39;t know enough about how that<br>&gt; would be implemented to speak to its feasibility or level of effort. Such a<br>&gt; feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/f237e0a5/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>October 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I very much think the points mentioned in the motivation are worth addressing (and IMO this is not an area where maybe the optimizer can be made smarter can cut it; I want performance guarantees, not hopes).<br></p><p>&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>[snip]<br></p><p>On a shallow read I like presented approach, except for<br></p><p>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br></p><p>The asymmetry between the if / else branches seems ugly to me. That is once obtaining the value directly from dict, and once through the values-view. I dont have a great solution here, but is is possible to subscript the dict by its `Index` as well as its `Key`?<br></p><p>```<br>// Using `dict.keys.index(of:)`<br>if let i = dict.keys.index(of: &quot;one&quot;) {<br>    dict[i].append(1)<br>} else {<br>    dict[&quot;one&quot;] = [1]<br>}<br>```<br></p><p>On another note, Im not sure whether there is a way (or whether its even worth trying) to avoid hashing the key twice when the `else` branch is taken.<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>October 12, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks for your feedback! Response below.<br></p><p>&gt; On Oct 12, 2016, at 5:40 AM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I very much think the points mentioned in the motivation are worth addressing (and IMO this is not an area where maybe the optimizer can be made smarter can cut it; I want performance guarantees, not hopes).<br>&gt; <br>&gt;&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [snip]<br>&gt; <br>&gt; On a shallow read I like presented approach, except for<br>&gt; <br>&gt;&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt; <br>&gt;&gt; // Using `dict.keys.index(of:)`<br>&gt;&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;    dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;    dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt; <br>&gt; The asymmetry between the if / else branches seems ugly to me. That is once obtaining the value directly from dict, and once through the values-view. I dont have a great solution here, but is is possible to subscript the dict by its `Index` as well as its `Key`?<br>&gt; <br>&gt; ```<br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;    dict[i].append(1)<br>&gt; } else {<br>&gt;    dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; ```<br></p><p>I share your concern with this, and there is an approach that would make this kind of interface possible. Basically, what you&#39;re describing here would necessitate changing Dictionary to act like a mutable collection of values, and instead of presenting `keys` and `values` views, we would probably offer `keys` and `keysAndValues` (or something) views. With that new model, we&#39;d have code like the following:<br></p><p>var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br></p><p>// Iterating the dictionary itself would be like we now iterate the values collection<br>for val in dict {<br>	print(val)<br>}<br>// Output is just the values (unordered as usual)<br>// [1]<br>// [3, 3, 3]<br>// [2, 2]<br></p><p>// Iterating a new view would act like the dictionary currently does<br>for (key, val) in dict.keysAndValues {<br>	print(key, val)<br>}<br>// &quot;one&quot;, [1]<br>// &quot;three&quot;, [3, 3, 3]<br>// &quot;two&quot;, [2, 2]<br></p><p>Any sequence or collections operations on the dictionary itself would only interact with values:<br></p><p>print(dict.first)<br>// Optional([1])<br>print(dict.first(where: { $0.count &gt; 2 }))<br>// Optional([3, 3, 3])<br></p><p>I&#39;m not strictly opposed to this approach, but I do prefer the way the current dictionary implementation presents its elements as key-value pairs. When you iterate a dictionary you&#39;re seeing all of its contents, which I like, but there are clear tradeoffs between the two. Making Dictionary a collection of values is also a much more significant change than the one proposedwe&#39;d need to do some research into the ways dictionaries are used to know how much larger an effect that would be.<br></p><p>What do others think of this as an alternative solution for the motivating issues? Does anyone actually use indices right now to work with dictionaries, or is key-based read/write pretty much the only interface?<br></p><p>&gt; On another note, Im not sure whether there is a way (or whether its even worth trying) to avoid hashing the key twice when the `else` branch is taken.<br></p><p>This is outside the scope of the proposal, but as far as I can see I don&#39;t think there&#39;s a solution for this that wouldn&#39;t overly expose the internal workings of the dictionary.<br></p><p>Thanks again,<br>Nate<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/fe58cf07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 12, 2016 at 10:31 AM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks for your feedback! Response below.<br>&gt;<br>&gt; On Oct 12, 2016, at 5:40 AM, Daniel Vollmer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I very much think the points mentioned in the motivation are worth<br>&gt; addressing (and IMO this is not an area where maybe the optimizer can be<br>&gt; made smarter can cut it; I want performance guarantees, not hopes).<br>&gt;<br>&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; [snip]<br>&gt;<br>&gt; On a shallow read I like presented approach, except for<br>&gt;<br>&gt; Both the keys and values collections share the same index type as<br>&gt; Dictionary. This allows the above sample to be rewritten as:<br>&gt;<br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;    dict.values[i].append(1)<br>&gt; } else {<br>&gt;    dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The asymmetry between the if / else branches seems ugly to me. That is<br>&gt; once obtaining the value directly from dict, and once through the<br>&gt; values-view. I dont have a great solution here, but is is possible to<br>&gt; subscript the dict by its `Index` as well as its `Key`?<br>&gt;<br>&gt; ```<br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;    dict[i].append(1)<br>&gt; } else {<br>&gt;    dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; I share your concern with this, and there is an approach that would make<br>&gt; this kind of interface possible. Basically, what you&#39;re describing here<br>&gt; would necessitate changing Dictionary to act like a mutable collection of<br>&gt; values, and instead of presenting `keys` and `values` views, we would<br>&gt; probably offer `keys` and `keysAndValues` (or something) views. With that<br>&gt; new model, we&#39;d have code like the following:<br>&gt;<br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;<br>&gt; // Iterating the dictionary itself would be like we now iterate the values<br>&gt; collection<br>&gt; for val in dict {<br>&gt; print(val)<br>&gt; }<br>&gt; // Output is just the values (unordered as usual)<br>&gt; // [1]<br>&gt; // [3, 3, 3]<br>&gt; // [2, 2]<br>&gt;<br>&gt; // Iterating a new view would act like the dictionary currently does<br>&gt; for (key, val) in dict.keysAndValues {<br>&gt; print(key, val)<br>&gt; }<br>&gt; // &quot;one&quot;, [1]<br>&gt; // &quot;three&quot;, [3, 3, 3]<br>&gt; // &quot;two&quot;, [2, 2]<br>&gt;<br>&gt;<br>&gt; Any sequence or collections operations on the dictionary itself would only<br>&gt; interact with values:<br>&gt;<br>&gt; print(dict.first)<br>&gt; // Optional([1])<br>&gt; print(dict.first(where: { $0.count &gt; 2 }))<br>&gt; // Optional([3, 3, 3])<br>&gt;<br>&gt;<br>&gt; I&#39;m not strictly opposed to this approach, but I do prefer the way the<br>&gt; current dictionary implementation presents its elements as key-value pairs.<br>&gt; When you iterate a dictionary you&#39;re seeing *all* of its contents, which<br>&gt; I like, but there are clear tradeoffs between the two. Making Dictionary a<br>&gt; collection of values is also a much more significant change than the one<br>&gt; proposedwe&#39;d need to do some research into the ways dictionaries are used<br>&gt; to know how much larger an effect that would be.<br>&gt;<br>&gt; What do others think of this as an alternative solution for the motivating<br>&gt; issues? Does anyone actually use indices right now to work with<br>&gt; dictionaries, or is key-based read/write pretty much the only interface?<br>&gt;<br></p><p>I much, much prefer your proposed solution to this alternative. Most of it<br>is just a gut reaction, I have to admit. However, let me try to verbalize<br>some reasons:<br></p><p>For one, the performance issues are the motivating problem, and they are<br>solved with minimal disruption to the current Dictionary API in your<br>currently proposed solution. Second, I think the asymmetry identified<br>(while aesthetically less than perfectly pleasing) is in the nature of<br>opaque indices and is consistent with precedent in String. Finally, I think<br>it&#39;s ideal that we can introduce collection types to learners by pointing<br>out that arrays are notionally index-based and dictionaries are key-based<br>(however these types are actually implemented behind the scenes);<br>permitting direct subscripting by dictionary indices muddies that<br>distinction.<br></p><p>On another note, Im not sure whether there is a way (or whether its even<br>&gt; worth trying) to avoid hashing the key twice when the `else` branch is<br>&gt; taken.<br>&gt;<br>&gt;<br>&gt; This is outside the scope of the proposal, but as far as I can see I don&#39;t<br>&gt; think there&#39;s a solution for this that wouldn&#39;t overly expose the internal<br>&gt; workings of the dictionary.<br>&gt;<br>&gt; Thanks again,<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/1654ae84/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 12, 2016 at 01:00:00pm</p></header><div class="content"><p>A clear win for me. +1<br></p><p><br>&gt; On 11 Oct 2016, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/56efe385/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>October 12, 2016 at 09:00:00am</p></header><div class="content"><p>The issue addressed is real; Im not sure this is the best approach. <br></p><p>In particular, unless Im missing something obvious, the ownership strategy here would have to be:<br></p><p>- `DictionaryKeys` and `DictionaryValues` would each induce the expected +1 retain on the underlying storage<br>- `DictionaryValues`s mutations avoid triggering COW on the underlying storage by skipping the usual ownership check<br></p><p>as otherwise its unclear how youd do those in-place mutations (and this seems to be how the implementation works...is that correct?).<br></p><p>With that design, it seems like youd wind up allowing things like the below:<br></p><p>  // example A<br>  let foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>  let bar = foo // shared storage, no COW<br>  foo.values[foo.index(of: abc)!].append(789) // update shared storage, no COW<br></p><p>  // shared storage mutated,<br>  // despite (a) both being `let` and (b) only foo.values getting touched<br>  foo[abc] // [1, 2, 3, 789]<br>  bar[abc] // [1, 2, 3, 789]<br></p><p>  // example B<br>  var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>  var bar = foo // shared storage, no COW<br>  foo.values[foo.index(of: abc)!].append(789)<br></p><p>  // shared storage mutated only foo.values getting touched<br>  foo[abc] // [1, 2, 3, 789]<br>  bar[abc] // [1, 2, 3, 789]<br></p><p>  // example C<br>  var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>  var bar = foo <br>  bar[abc] = [1, 2, 3, 4] // COW triggered here, no shared storage<br>  foo.values[foo.index(of: abc)!].append(789)<br></p><p>  // only `foo`s storage mutated, b/c change to `bar` triggered COW<br>  foo[abc] // [1, 2, 3, 789]<br>  bar[abc] // [1, 2, 3, 4]<br></p><p>where both A (by itself) and the B/C contrast seem very unwelcome.<br></p><p>Also, even if we assume we only ever make *responsible* use, having the stdlib include such directly-mutating views would seem likely to complicate any future concurrency plans.<br></p><p>To reiterate, I think the issue being addressed here is extremely importantI just dont think I can get behind this type of solution (unless Im grossly misunderstanding its mechanics).<br></p><p>&gt; On Oct 11, 2016, at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/e4ff621c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>October 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 9:32 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The issue addressed is real; Im not sure this is the best approach. <br>&gt; <br>&gt; In particular, unless Im missing something obvious, the ownership strategy here would have to be:<br>&gt; <br>&gt; - `DictionaryKeys` and `DictionaryValues` would each induce the expected +1 retain on the underlying storage<br>&gt; - `DictionaryValues`s mutations avoid triggering COW on the underlying storage by skipping the usual ownership check<br>&gt; <br>&gt; as otherwise its unclear how youd do those in-place mutations (and this seems to be how the implementation works...is that correct?).<br></p><p>That&#39;s not quite rightwhen you access these views through the dictionary, they do not increment the storage retain count. This is the way slicing and views currently work on other mutable types. For example, when you reverse a slice of an array in-place, the slice doesn&#39;t get its own duplicate storage:<br></p><p>var a = Array(1...10)<br>a[0..&lt;5].reverse()<br>a == [5, 4, 3, 2, 1, 6, 7, 8, 9, 10]<br></p><p>However, if you create a new variable out of the slice and reverse that, the slice does get its own storage:<br></p><p>var b = Array(1...10)<br>var bSlice = b[0..&lt;5]<br>bSlice.reverse()<br>bSlice == [5, 4, 3, 2, 1]<br>b == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br></p><p>Strings and their views work the same way:<br></p><p>var s = &quot;abcdefg&quot;<br>s.characters.append(&quot;H&quot;)   // storage updated in place<br>s == &quot;abcdefgH&quot;<br></p><p>var sChars = s.characters  // no copy yet<br>sChars.removeLast()     // sChars gets its own copy before the mutation<br>s == &quot;abcdefgH&quot;<br>String(sChars) == &quot;abcdefg&quot;<br></p><p>var t = s   // no copy yet<br>t.characters.removeLast()  // t gets a new copy here<br>s == &quot;abcdefgH&quot;<br>t == &quot;abcdefg&quot;<br></p><p>I don&#39;t know the name of the compiler feature that enables this, but it&#39;s a critical part of the way views and slices work.<br></p><p>&gt; With that design, it seems like youd wind up allowing things like the below:<br>&gt; <br>&gt;   // example A<br>&gt;   let foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;   let bar = foo // shared storage, no COW<br>&gt;   foo.values[foo.index(of: abc)!].append(789) // update shared storage, no COW<br>&gt; <br>&gt;   // shared storage mutated,<br>&gt;   // despite (a) both being `let` and (b) only foo.values getting touched<br>&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;   bar[abc] // [1, 2, 3, 789]<br></p><p>Example A isn&#39;t allowedif foo and bar are both immutable, both of their `values` collections are also immutable, so there&#39;s no way to modify their shared storage.<br></p><p>&gt;   // example B<br>&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;   var bar = foo // shared storage, no COW<br>&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt; <br>&gt;   // shared storage mutated only foo.values getting touched<br>&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;   bar[abc] // [1, 2, 3, 789]<br></p><p>Example B is incorrectthe mutation at `foo.values[...].append(789)` triggers a copy of the entire dictionary&#39;s underlying storage before allowing the mutation, since it knows that storage isn&#39;t uniquely referenced.<br></p><p>&gt;   // example C<br>&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;   var bar = foo <br>&gt;   bar[abc] = [1, 2, 3, 4] // COW triggered here, no shared storage<br>&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt; <br>&gt;   // only `foo`s storage mutated, b/c change to `bar` triggered COW<br>&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;   bar[abc] // [1, 2, 3, 4]<br></p><p>This is the current behavior and would remain the same after the proposed the changes.<br></p><p>&gt; where both A (by itself) and the B/C contrast seem very unwelcome.<br>&gt; <br>&gt; Also, even if we assume we only ever make *responsible* use, having the stdlib include such directly-mutating views would seem likely to complicate any future concurrency plans.<br>&gt; <br>&gt; To reiterate, I think the issue being addressed here is extremely importantI just dont think I can get behind this type of solution (unless Im grossly misunderstanding its mechanics).<br></p><p>Nate<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/41c65f81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>October 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for the quick reply; given that Im quite wrong about the important mechanics I rescind my criticisms.<br></p><p>I will say I care about this enough to reply because the inability to do in-place mutation of dictionary values has been an incredibly frustrating limitation and Id just assumed the situation with slices/views would necessarily have similar issues for similar reasonsbut glad to learn its not what I thought!<br></p><p>That said, I think efficient in-place mutation is too important to only expose so implicitly (seemingly due to the compiler eliding the otherwise-expected retain increments when the view is sufficiently transientwhich seems like you perhaps cant have an &quot;in-place capable&quot; view thats implemented as a class, Id think).<br></p><p>But none of this impacts my change to being in support for the proposal.<br></p><p>&gt; On Oct 12, 2016, at 10:07 AM, Nate Cook &lt;natecook at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 9:32 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The issue addressed is real; Im not sure this is the best approach. <br>&gt;&gt; <br>&gt;&gt; In particular, unless Im missing something obvious, the ownership strategy here would have to be:<br>&gt;&gt; <br>&gt;&gt; - `DictionaryKeys` and `DictionaryValues` would each induce the expected +1 retain on the underlying storage<br>&gt;&gt; - `DictionaryValues`s mutations avoid triggering COW on the underlying storage by skipping the usual ownership check<br>&gt;&gt; <br>&gt;&gt; as otherwise its unclear how youd do those in-place mutations (and this seems to be how the implementation works...is that correct?).<br>&gt; <br>&gt; That&#39;s not quite rightwhen you access these views through the dictionary, they do not increment the storage retain count. This is the way slicing and views currently work on other mutable types. For example, when you reverse a slice of an array in-place, the slice doesn&#39;t get its own duplicate storage:<br>&gt; <br>&gt; var a = Array(1...10)<br>&gt; a[0..&lt;5].reverse()<br>&gt; a == [5, 4, 3, 2, 1, 6, 7, 8, 9, 10]<br>&gt; <br>&gt; However, if you create a new variable out of the slice and reverse that, the slice does get its own storage:<br>&gt; <br>&gt; var b = Array(1...10)<br>&gt; var bSlice = b[0..&lt;5]<br>&gt; bSlice.reverse()<br>&gt; bSlice == [5, 4, 3, 2, 1]<br>&gt; b == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt; <br>&gt; Strings and their views work the same way:<br>&gt; <br>&gt; var s = &quot;abcdefg&quot;<br>&gt; s.characters.append(&quot;H&quot;)   // storage updated in place<br>&gt; s == &quot;abcdefgH&quot;<br>&gt; <br>&gt; var sChars = s.characters  // no copy yet<br>&gt; sChars.removeLast()     // sChars gets its own copy before the mutation<br>&gt; s == &quot;abcdefgH&quot;<br>&gt; String(sChars) == &quot;abcdefg&quot;<br>&gt; <br>&gt; var t = s   // no copy yet<br>&gt; t.characters.removeLast()  // t gets a new copy here<br>&gt; s == &quot;abcdefgH&quot;<br>&gt; t == &quot;abcdefg&quot;<br>&gt; <br>&gt; I don&#39;t know the name of the compiler feature that enables this, but it&#39;s a critical part of the way views and slices work.<br>&gt; <br>&gt;&gt; With that design, it seems like youd wind up allowing things like the below:<br>&gt;&gt; <br>&gt;&gt;   // example A<br>&gt;&gt;   let foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;   let bar = foo // shared storage, no COW<br>&gt;&gt;   foo.values[foo.index(of: abc)!].append(789) // update shared storage, no COW<br>&gt;&gt; <br>&gt;&gt;   // shared storage mutated,<br>&gt;&gt;   // despite (a) both being `let` and (b) only foo.values getting touched<br>&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt; <br>&gt; Example A isn&#39;t allowedif foo and bar are both immutable, both of their `values` collections are also immutable, so there&#39;s no way to modify their shared storage.<br>&gt; <br>&gt;&gt;   // example B<br>&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;   var bar = foo // shared storage, no COW<br>&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt; <br>&gt;&gt;   // shared storage mutated only foo.values getting touched<br>&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt; <br>&gt; Example B is incorrectthe mutation at `foo.values[...].append(789)` triggers a copy of the entire dictionary&#39;s underlying storage before allowing the mutation, since it knows that storage isn&#39;t uniquely referenced.<br>&gt; <br>&gt;&gt;   // example C<br>&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;   var bar = foo <br>&gt;&gt;   bar[abc] = [1, 2, 3, 4] // COW triggered here, no shared storage<br>&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt; <br>&gt;&gt;   // only `foo`s storage mutated, b/c change to `bar` triggered COW<br>&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;   bar[abc] // [1, 2, 3, 4]<br>&gt; <br>&gt; This is the current behavior and would remain the same after the proposed the changes.<br>&gt; <br>&gt;&gt; where both A (by itself) and the B/C contrast seem very unwelcome.<br>&gt;&gt; <br>&gt;&gt; Also, even if we assume we only ever make *responsible* use, having the stdlib include such directly-mutating views would seem likely to complicate any future concurrency plans.<br>&gt;&gt; <br>&gt;&gt; To reiterate, I think the issue being addressed here is extremely importantI just dont think I can get behind this type of solution (unless Im grossly misunderstanding its mechanics).<br>&gt; <br>&gt; Nate<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/c38c7383/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Kroly Lrentey</string> &lt;karoly at lorentey.hu&gt;<p>October 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I believe the implementation of efficient in-place mutation is very explicit in the code -- it is done by implementing DictionaryValues subscript using a special mutableAddressWithNativeOwner addressor instead of a normal setter. <br></p><p>https://github.com/natecook1000/swift/blob/ed95aec4a20589a3b9c131f43444aa33705343cc/stdlib/public/core/HashedCollections.swift.gyb#L2169-L2173 &lt;https://github.com/natecook1000/swift/blob/ed95aec4a20589a3b9c131f43444aa33705343cc/stdlib/public/core/HashedCollections.swift.gyb#L2169-L2173&gt;<br></p><p>AFAICU this would also work if DictionaryValue was a reference type. <br></p><p>Unfortunately, as far as I know, these addressors arent available outside stdlib, so custom collections cannot currently implement such mutable views (including mutable ranges) in a similarly efficient way. <br></p><p>We can, however, approximate a similar effect outside of stdlib by designing closure-based APIs like `mydict.withValues { values in values[i] = 42 }`, in which the collection moves its storage to the view while the closure is executing (temporarily making its own contents disappear / appear invalid). The syntax and underlying mental model is perhaps not as nice, but (assuming the compiler is able to optimize away the nonescaping closure) we can achieve some of the performance benefits. <br></p><p>&gt; On 2016-10-12, at 19:17, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the quick reply; given that Im quite wrong about the important mechanics I rescind my criticisms.<br>&gt; <br>&gt; I will say I care about this enough to reply because the inability to do in-place mutation of dictionary values has been an incredibly frustrating limitation and Id just assumed the situation with slices/views would necessarily have similar issues for similar reasonsbut glad to learn its not what I thought!<br>&gt; <br>&gt; That said, I think efficient in-place mutation is too important to only expose so implicitly (seemingly due to the compiler eliding the otherwise-expected retain increments when the view is sufficiently transientwhich seems like you perhaps cant have an &quot;in-place capable&quot; view thats implemented as a class, Id think).<br>&gt; <br>&gt; But none of this impacts my change to being in support for the proposal.<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 10:07 AM, Nate Cook &lt;natecook at gmail.com &lt;mailto:natecook at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 9:32 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The issue addressed is real; Im not sure this is the best approach. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, unless Im missing something obvious, the ownership strategy here would have to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - `DictionaryKeys` and `DictionaryValues` would each induce the expected +1 retain on the underlying storage<br>&gt;&gt;&gt; - `DictionaryValues`s mutations avoid triggering COW on the underlying storage by skipping the usual ownership check<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; as otherwise its unclear how youd do those in-place mutations (and this seems to be how the implementation works...is that correct?).<br>&gt;&gt; <br>&gt;&gt; That&#39;s not quite rightwhen you access these views through the dictionary, they do not increment the storage retain count. This is the way slicing and views currently work on other mutable types. For example, when you reverse a slice of an array in-place, the slice doesn&#39;t get its own duplicate storage:<br>&gt;&gt; <br>&gt;&gt; var a = Array(1...10)<br>&gt;&gt; a[0..&lt;5].reverse()<br>&gt;&gt; a == [5, 4, 3, 2, 1, 6, 7, 8, 9, 10]<br>&gt;&gt; <br>&gt;&gt; However, if you create a new variable out of the slice and reverse that, the slice does get its own storage:<br>&gt;&gt; <br>&gt;&gt; var b = Array(1...10)<br>&gt;&gt; var bSlice = b[0..&lt;5]<br>&gt;&gt; bSlice.reverse()<br>&gt;&gt; bSlice == [5, 4, 3, 2, 1]<br>&gt;&gt; b == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt; <br>&gt;&gt; Strings and their views work the same way:<br>&gt;&gt; <br>&gt;&gt; var s = &quot;abcdefg&quot;<br>&gt;&gt; s.characters.append(&quot;H&quot;)   // storage updated in place<br>&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt; <br>&gt;&gt; var sChars = s.characters  // no copy yet<br>&gt;&gt; sChars.removeLast()     // sChars gets its own copy before the mutation<br>&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt; String(sChars) == &quot;abcdefg&quot;<br>&gt;&gt; <br>&gt;&gt; var t = s   // no copy yet<br>&gt;&gt; t.characters.removeLast()  // t gets a new copy here<br>&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt; t == &quot;abcdefg&quot;<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know the name of the compiler feature that enables this, but it&#39;s a critical part of the way views and slices work.<br>&gt;&gt; <br>&gt;&gt;&gt; With that design, it seems like youd wind up allowing things like the below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // example A<br>&gt;&gt;&gt;   let foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;   let bar = foo // shared storage, no COW<br>&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789) // update shared storage, no COW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // shared storage mutated,<br>&gt;&gt;&gt;   // despite (a) both being `let` and (b) only foo.values getting touched<br>&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt;&gt; <br>&gt;&gt; Example A isn&#39;t allowedif foo and bar are both immutable, both of their `values` collections are also immutable, so there&#39;s no way to modify their shared storage.<br>&gt;&gt; <br>&gt;&gt;&gt;   // example B<br>&gt;&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;   var bar = foo // shared storage, no COW<br>&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // shared storage mutated only foo.values getting touched<br>&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt;&gt; <br>&gt;&gt; Example B is incorrectthe mutation at `foo.values[...].append(789)` triggers a copy of the entire dictionary&#39;s underlying storage before allowing the mutation, since it knows that storage isn&#39;t uniquely referenced.<br>&gt;&gt; <br>&gt;&gt;&gt;   // example C<br>&gt;&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;   var bar = foo <br>&gt;&gt;&gt;   bar[abc] = [1, 2, 3, 4] // COW triggered here, no shared storage<br>&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // only `foo`s storage mutated, b/c change to `bar` triggered COW<br>&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 4]<br>&gt;&gt; <br>&gt;&gt; This is the current behavior and would remain the same after the proposed the changes.<br>&gt;&gt; <br>&gt;&gt;&gt; where both A (by itself) and the B/C contrast seem very unwelcome.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, even if we assume we only ever make *responsible* use, having the stdlib include such directly-mutating views would seem likely to complicate any future concurrency plans.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To reiterate, I think the issue being addressed here is extremely importantI just dont think I can get behind this type of solution (unless Im grossly misunderstanding its mechanics).<br>&gt;&gt; <br>&gt;&gt; Nate<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/4aed7aa7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>October 12, 2016 at 06:00:00pm</p></header><div class="content"><p>I agree that at least for stdlib purposes theres something that looks like an explicit choice to make in-place mutation *available*. <br></p><p>What I was trying to explain is whether or not in-place mutation *happens* is a bit implicit. Its one thing to say that the difference here is just an idiom to know:<br></p><p>  var foo = [0, 1, 2, 3, 4, 5]<br> <br>  // not in place:<br>  var slice = foo[13]<br>  slice.reverse() // `foo` not mutated<br></p><p>  // in place:<br>  foo[13].reverse() // `foo` mutated <br></p><p>but whether or not this function triggers an in-place mutation:<br></p><p>  func reverse&lt;T&gt;(_ slice: inout ArraySlice&lt;T&gt;) { <br>   slice.reverse() <br>  }<br></p><p>depends on how its being called:<br> <br>  var slice = foo[13]<br>  reverse(&amp;slice) // `foo` unchanged<br>  <br>  reverse(&amp;foo[13]) // `foo` mutated in-place<br></p><p>This seems consistent with the in-placeor not? behavior being largely just the usual COW, + the compiler eliding the typical retain/release on any sufficiently-transient slices; e.g. as if:<br></p><p>  // in place:<br>  foo[13].reverse() // `foo` mutated <br></p><p>  // is treated as the equivalent of:<br>  @noretain var slice = foo[13]<br>  slice.reverse()<br></p><p>where the @noretain is some (fictional) attribute suppressing the retain/release youd otherwise trigger when `foo[13]` is stored into `slice`.<br></p><p>Thats the mental model it suggests, at leastand it just seemed unlikely that the compiler would be able to propagate something like `@noretain` onto a specific instance variable in a specific instance of a class-based view that captured a reference to the viewed collections underlying storagewhence the comment about class-based views. But Ive been very wrong already today and probably am here as well.<br></p><p>As this is getting off-topic for something that seems like itll get postponed until later anyways Id just like to say thanks again for taking the time to propose this, for correcting my misunderstandingsand that Im eagerly looking forward to any improvements into COW visibility and any steps towards having more-explicit control over the COW mechanism.<br></p><p>&gt; On Oct 12, 2016, at 1:11 PM, Kroly Lrentey &lt;karoly at lorentey.hu&gt; wrote:<br>&gt; <br>&gt; I believe the implementation of efficient in-place mutation is very explicit in the code -- it is done by implementing DictionaryValues subscript using a special mutableAddressWithNativeOwner addressor instead of a normal setter. <br>&gt; <br>&gt; https://github.com/natecook1000/swift/blob/ed95aec4a20589a3b9c131f43444aa33705343cc/stdlib/public/core/HashedCollections.swift.gyb#L2169-L2173 &lt;https://github.com/natecook1000/swift/blob/ed95aec4a20589a3b9c131f43444aa33705343cc/stdlib/public/core/HashedCollections.swift.gyb#L2169-L2173&gt;<br>&gt; <br>&gt; AFAICU this would also work if DictionaryValue was a reference type. <br>&gt; <br>&gt; Unfortunately, as far as I know, these addressors arent available outside stdlib, so custom collections cannot currently implement such mutable views (including mutable ranges) in a similarly efficient way. <br>&gt; <br>&gt; We can, however, approximate a similar effect outside of stdlib by designing closure-based APIs like `mydict.withValues { values in values[i] = 42 }`, in which the collection moves its storage to the view while the closure is executing (temporarily making its own contents disappear / appear invalid). The syntax and underlying mental model is perhaps not as nice, but (assuming the compiler is able to optimize away the nonescaping closure) we can achieve some of the performance benefits. <br>&gt; <br>&gt;&gt; On 2016-10-12, at 19:17, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the quick reply; given that Im quite wrong about the important mechanics I rescind my criticisms.<br>&gt;&gt; <br>&gt;&gt; I will say I care about this enough to reply because the inability to do in-place mutation of dictionary values has been an incredibly frustrating limitation and Id just assumed the situation with slices/views would necessarily have similar issues for similar reasonsbut glad to learn its not what I thought!<br>&gt;&gt; <br>&gt;&gt; That said, I think efficient in-place mutation is too important to only expose so implicitly (seemingly due to the compiler eliding the otherwise-expected retain increments when the view is sufficiently transientwhich seems like you perhaps cant have an &quot;in-place capable&quot; view thats implemented as a class, Id think).<br>&gt;&gt; <br>&gt;&gt; But none of this impacts my change to being in support for the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 10:07 AM, Nate Cook &lt;natecook at gmail.com &lt;mailto:natecook at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 12, 2016, at 9:32 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The issue addressed is real; Im not sure this is the best approach. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, unless Im missing something obvious, the ownership strategy here would have to be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - `DictionaryKeys` and `DictionaryValues` would each induce the expected +1 retain on the underlying storage<br>&gt;&gt;&gt;&gt; - `DictionaryValues`s mutations avoid triggering COW on the underlying storage by skipping the usual ownership check<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; as otherwise its unclear how youd do those in-place mutations (and this seems to be how the implementation works...is that correct?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s not quite rightwhen you access these views through the dictionary, they do not increment the storage retain count. This is the way slicing and views currently work on other mutable types. For example, when you reverse a slice of an array in-place, the slice doesn&#39;t get its own duplicate storage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var a = Array(1...10)<br>&gt;&gt;&gt; a[0..&lt;5].reverse()<br>&gt;&gt;&gt; a == [5, 4, 3, 2, 1, 6, 7, 8, 9, 10]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, if you create a new variable out of the slice and reverse that, the slice does get its own storage:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var b = Array(1...10)<br>&gt;&gt;&gt; var bSlice = b[0..&lt;5]<br>&gt;&gt;&gt; bSlice.reverse()<br>&gt;&gt;&gt; bSlice == [5, 4, 3, 2, 1]<br>&gt;&gt;&gt; b == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Strings and their views work the same way:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var s = &quot;abcdefg&quot;<br>&gt;&gt;&gt; s.characters.append(&quot;H&quot;)   // storage updated in place<br>&gt;&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var sChars = s.characters  // no copy yet<br>&gt;&gt;&gt; sChars.removeLast()     // sChars gets its own copy before the mutation<br>&gt;&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt;&gt; String(sChars) == &quot;abcdefg&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var t = s   // no copy yet<br>&gt;&gt;&gt; t.characters.removeLast()  // t gets a new copy here<br>&gt;&gt;&gt; s == &quot;abcdefgH&quot;<br>&gt;&gt;&gt; t == &quot;abcdefg&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know the name of the compiler feature that enables this, but it&#39;s a critical part of the way views and slices work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With that design, it seems like youd wind up allowing things like the below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // example A<br>&gt;&gt;&gt;&gt;   let foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;&gt;   let bar = foo // shared storage, no COW<br>&gt;&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789) // update shared storage, no COW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // shared storage mutated,<br>&gt;&gt;&gt;&gt;   // despite (a) both being `let` and (b) only foo.values getting touched<br>&gt;&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example A isn&#39;t allowedif foo and bar are both immutable, both of their `values` collections are also immutable, so there&#39;s no way to modify their shared storage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // example B<br>&gt;&gt;&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;&gt;   var bar = foo // shared storage, no COW<br>&gt;&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // shared storage mutated only foo.values getting touched<br>&gt;&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example B is incorrectthe mutation at `foo.values[...].append(789)` triggers a copy of the entire dictionary&#39;s underlying storage before allowing the mutation, since it knows that storage isn&#39;t uniquely referenced.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // example C<br>&gt;&gt;&gt;&gt;   var foo = [ abc: [1,2,3], efg: [4,5,6] ]<br>&gt;&gt;&gt;&gt;   var bar = foo <br>&gt;&gt;&gt;&gt;   bar[abc] = [1, 2, 3, 4] // COW triggered here, no shared storage<br>&gt;&gt;&gt;&gt;   foo.values[foo.index(of: abc)!].append(789)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // only `foo`s storage mutated, b/c change to `bar` triggered COW<br>&gt;&gt;&gt;&gt;   foo[abc] // [1, 2, 3, 789]<br>&gt;&gt;&gt;&gt;   bar[abc] // [1, 2, 3, 4]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the current behavior and would remain the same after the proposed the changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where both A (by itself) and the B/C contrast seem very unwelcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, even if we assume we only ever make *responsible* use, having the stdlib include such directly-mutating views would seem likely to complicate any future concurrency plans.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To reiterate, I think the issue being addressed here is extremely importantI just dont think I can get behind this type of solution (unless Im grossly misunderstanding its mechanics).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nate<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/a7d6fef2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Kroly Lrentey</string> &lt;karoly at lorentey.hu&gt;<p>October 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I think this is a lovely approach to solving this API design problem.<br></p><p>One thing I dont quite understand yet is how these kinds of mutable views interact with copy on write semantics. COW rules can be subtle, and these views seem to put an extra twist on top that seems hard to understand/explain.<br></p><p>I would expect DictionaryValues to behave like a separate copy of the dictionary:<br></p><p>   var dict = [foo: 1, bar: 2]<br>   let i = dict.keys.index(of: foo)!<br>   var values = dict.values<br>   values[i] = 42         // COW copy<br>   print(dict[foo])     // =&gt; 1<br>   dict.values = values   // Original storage is released<br>   print(dict[foo])     // =&gt; 42<br></p><p>Given that `values` contains a strong reference to the storage, I was curious to find out how this copy is elided when we write `dict.values[i] = 42`. So I tried building your branch, and I found that mutating `values` has an immediate effect on the dictionary as well:<br></p><p>   let dict = [foo: 1, bar: 2]     // Note let, not var<br>   let copy = dict<br>   let i = dict.keys.index(of: foo)!<br>   var values = dict.values<br>   values[i] = 42         <br>   print(dict[foo])     // =&gt; 42 (?!)<br>   print(copy[foo])     // =&gt; 42 (?!?!)<br></p><p>This is not the intended behavior, right?<br></p><p>Kroly<br></p><p>&gt; On 2016-10-11, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/070a3a7e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Kroly Lrentey</string> &lt;karoly at lorentey.hu&gt;<p>October 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Ah, I see plx has already brought this up. So this is a bug in the implementation, and (presumably) DictionaryValues mutable subscript addressor is supposed to take care of COW semantics without introducing needless copying.<br></p><p>(Its too bad we arent supposed to use these magical addressors outside stdlib; the same issues tend to come up in custom collections, too.) :-(<br></p><p><br>&gt; On 2016-10-12, at 17:58, Kroly Lrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a lovely approach to solving this API design problem.<br>&gt; <br>&gt; One thing I dont quite understand yet is how these kinds of mutable views interact with copy on write semantics. COW rules can be subtle, and these views seem to put an extra twist on top that seems hard to understand/explain.<br>&gt; <br>&gt; I would expect DictionaryValues to behave like a separate copy of the dictionary:<br>&gt; <br>&gt;    var dict = [foo: 1, bar: 2]<br>&gt;    let i = dict.keys.index(of: foo)!<br>&gt;    var values = dict.values<br>&gt;    values[i] = 42         // COW copy<br>&gt;    print(dict[foo])     // =&gt; 1<br>&gt;    dict.values = values   // Original storage is released<br>&gt;    print(dict[foo])     // =&gt; 42<br>&gt; <br>&gt; Given that `values` contains a strong reference to the storage, I was curious to find out how this copy is elided when we write `dict.values[i] = 42`. So I tried building your branch, and I found that mutating `values` has an immediate effect on the dictionary as well:<br>&gt; <br>&gt;    let dict = [foo: 1, bar: 2]     // Note let, not var<br>&gt;    let copy = dict<br>&gt;    let i = dict.keys.index(of: foo)!<br>&gt;    var values = dict.values<br>&gt;    values[i] = 42         <br>&gt;    print(dict[foo])     // =&gt; 42 (?!)<br>&gt;    print(copy[foo])     // =&gt; 42 (?!?!)<br>&gt; <br>&gt; This is not the intended behavior, right?<br>&gt; <br>&gt; Kroly<br>&gt; <br>&gt;&gt; On 2016-10-11, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt;&gt; <br>&gt;&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This proposal address two problems:<br>&gt;&gt; <br>&gt;&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt;&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt;&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt;&gt; <br>&gt;&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt;&gt; <br>&gt;&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt;&gt; <br>&gt;&gt; if dict[&quot;one&quot;] != nil {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt;&gt; <br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt;&gt; <br>&gt;&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt;&gt; <br>&gt;&gt; // Direct re-assignment<br>&gt;&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;&gt; <br>&gt;&gt; // Optional chaining<br>&gt;&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt;&gt; <br>&gt;&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt;&gt; <br>&gt;&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt;&gt; <br>&gt;&gt; // Performant<br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt;&gt; <br>&gt;&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)  // no copy here<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt; <br>&gt;&gt; // Using `dict.keys.index(of:)`<br>&gt;&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt;&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt;&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt;&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;&gt; <br>&gt;&gt;     // Remaining declarations<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt;&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt;&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;&gt; <br>&gt;&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt;&gt; <br>&gt;&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt;&gt; <br>&gt;&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/e26495ef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>October 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 10:58 AM, Kroly Lrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a lovely approach to solving this API design problem.<br>&gt; <br>&gt; One thing I dont quite understand yet is how these kinds of mutable views interact with copy on write semantics. COW rules can be subtle, and these views seem to put an extra twist on top that seems hard to understand/explain.<br>&gt; <br>&gt; I would expect DictionaryValues to behave like a separate copy of the dictionary:<br>&gt; <br>&gt;    var dict = [foo: 1, bar: 2]<br>&gt;    let i = dict.keys.index(of: foo)!<br>&gt;    var values = dict.values<br>&gt;    values[i] = 42         // COW copy<br>&gt;    print(dict[foo])     // =&gt; 1<br>&gt;    dict.values = values   // Original storage is released<br>&gt;    print(dict[foo])     // =&gt; 42<br>&gt; <br>&gt; Given that `values` contains a strong reference to the storage, I was curious to find out how this copy is elided when we write `dict.values[i] = 42`. So I tried building your branch, and I found that mutating `values` has an immediate effect on the dictionary as well:<br>&gt; <br>&gt;    let dict = [foo: 1, bar: 2]     // Note let, not var<br>&gt;    let copy = dict<br>&gt;    let i = dict.keys.index(of: foo)!<br>&gt;    var values = dict.values<br>&gt;    values[i] = 42         <br>&gt;    print(dict[foo])     // =&gt; 42 (?!)<br>&gt;    print(copy[foo])     // =&gt; 42 (?!?!)<br>&gt; <br>&gt; This is not the intended behavior, right?<br></p><p>Ha, no! Thanks for the bug report. :)<br></p><p>See my response here for more about COW: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161010/027866.html<br></p><p>Nate<br></p><p><br>&gt;&gt; On 2016-10-11, at 23:28, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt;&gt; <br>&gt;&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; This proposal address two problems:<br>&gt;&gt; <br>&gt;&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt;&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt;&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt;&gt; <br>&gt;&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;&gt; Inefficient dict.keys Search<br>&gt;&gt; <br>&gt;&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt;&gt; <br>&gt;&gt; if dict[&quot;one&quot;] != nil {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt;&gt; <br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt;&gt; <br>&gt;&gt; Inefficient Value Mutation<br>&gt;&gt; <br>&gt;&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt;&gt; <br>&gt;&gt; // Direct re-assignment<br>&gt;&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt;&gt; <br>&gt;&gt; // Optional chaining<br>&gt;&gt; dict[&quot;one&quot;]?.append(1)<br>&gt;&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt;&gt; <br>&gt;&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt;&gt; <br>&gt;&gt; Proposed Solution<br>&gt;&gt; <br>&gt;&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt;&gt; <br>&gt;&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt;&gt; <br>&gt;&gt; // Performant<br>&gt;&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt;&gt; <br>&gt;&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)  // no copy here<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt;&gt; <br>&gt;&gt; // Using `dict.keys.index(of:)`<br>&gt;&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;&gt;     dict.values[i].append(1)<br>&gt;&gt; } else {<br>&gt;&gt;     dict[&quot;one&quot;] = [1]<br>&gt;&gt; }<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt;&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt;&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt;&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt;&gt; <br>&gt;&gt;     // Remaining declarations<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt;&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt;&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt;&gt; <br>&gt;&gt;     // Other `Collection` requirements<br>&gt;&gt; }<br>&gt;&gt; A sample implementation of this proposal can be found in this branch.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt;&gt; <br>&gt;&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The Generics Manifesto lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt;&gt; <br>&gt;&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt;&gt; <br>&gt;&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/31c4d013/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>Just to clarify: It seems like the only ABI-affecting change here is the type of keys/values. As you note at the end of your proposal, this should just be Dictionary.Keys/Dictionary.Values regardless of whether we implement this proposal or not, in which case this can be punted for Swift 4. It should be fine to keep .Keys/.Values resilient so that we can change their implementation details later if we want.<br></p><p>On the actual proposal: this is a pretty reasonable given Swifts current design and constraints. That said, I expect pushing forward on this kind of thing right now is premature given the goals of Swift 4. A major aspect of Swift 4 is reworking the way CoW semantics function internally, which could drastically affect the way we approach this problem.<br></p><p>Id really like if we could eliminate the double search/hash in the no-existing-key case. There are ways to do this really cleanly, but they probably involve more advanced CoW-safety propagation. In particular, you want some way for the collection to return its search state to the caller so that they can hand it back to insertion to just resume from there.<br></p><p>For instance:<br></p><p>map.entries[key]           // An enum like Found(Value) | NotFound(SearchState)<br>   .withDefault(value: []) // Unwrap the enum by completing the NotFound(SearchState)<br>   .append(1)              // Now we have a value in both cases, we can append!<br></p><p><br></p><p>Or more complex:<br></p><p>map.entries[key] <br>   .withDefault { /* logic that computes value */ }<br>   .append(1)<br></p><p>I think this can be made to work in the current system if withDefault is actually `[withDefault:]`, which is fine but a bit weird from a users perspective.<br></p><p>In an ideal world the user could actually pattern match on the result of `entries[key]`. In this way they could match on it and perform special logic in both cases for really complex situations. This would make withDefault just a convenience, so we arent pressured to add more methods like it every time someone has a new Even More Complex use-case. e.g.:<br></p><p>switch map.entries[key] {<br>case .Found(entry):<br>  if entry.value == 10 { <br>    entry.remove()<br>    print(Found a value too many times! Moving key to fast-path auxiliary structure) <br>  } else {<br>    entry.value += 1<br>  }<br>case .NotFound(entry):<br>  entry.insert(1)<br>  print(Found a value for the first time! Registering a bunch of extra stuff) <br>}<br></p><p><br>But again, this is all dependent on a much more powerful SIL/ARC, and we just dont know what were going to get at this stage.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/a209a100/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 2:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>Im not commenting on this proposal directly but shouldnt this optimization be something the compiler can resolve? I suppose it requires something akin to the Rust borrow checker to determine that ownership passes from a local to the Optional and then to the setter, or in the case of write-back that references dont escape the current scope except through the setter. <br></p><p>In other words this is a significant problem in many places and it would be a huge win to solve it in the compiler. Im not sure changing types here and there to work around it is worth the trouble (though some of the issues you point out with Dictionary apply regardless).<br></p><p><br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/c355727f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal Draft] Provide Custom Collections for Dictionary Keys and Values</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 14, 2016 at 07:00:00pm</p></header><div class="content"><p>A late-arriving strong +1 for me. The index-related stuff is elegant and much needed. Im surprised to learn that dict.keys and dict.values are copies and not already views! Clearly they should be.<br></p><p>Question: I hit a closely related performance wall just last week, doing something like this:<br></p><p>    for k in dict.keys {<br>        dict.values[k].append(1)<br>    }<br></p><p>I assume / hope the proposal would also support this?<br></p><p>    for i in dict.indices {<br>        dict.values[i].append(1)<br>    }<br></p><p>or would it be this?<br></p><p>    for i in dict.keys.indices {<br>        dict.values[i].append(1)<br>    }<br></p><p>or either?<br></p><p>Cheers, P<br></p><p><br></p><p>&gt; On Oct 11, 2016, at 4:28 PM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a Dictionary instance&#39;s keys and values properties.<br>&gt; <br>&gt; New DictionaryKeys and DictionaryValues collections provide efficient key lookup and mutable access to dictionary values, enabling updates to be performed in-place and allowing copy-on-write optimization of stored values.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#motivation&gt;Motivation<br>&gt; <br>&gt; This proposal address two problems:<br>&gt; <br>&gt; The Dictionary type keys implementation is inefficient, because LazyMapCollection doesn&#39;t know how to forward lookups to the underlying dictionary storage.<br>&gt; Dictionaries do not offer value-mutating APIs. The mutating key-based subscript wraps values in an Optional. This prevents types with copy-on-write optimizations from recognizing they are singly referenced.<br>&gt; This proposal uses the following [String: [Int]] dictionary to demonstrate these problems:<br>&gt; <br>&gt; var dict = [&quot;one&quot;: [1], &quot;two&quot;: [2, 2], &quot;three&quot;: [3, 3, 3]]<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-dictkeys-search&gt;Inefficient dict.keys Search<br>&gt; <br>&gt; Swift coders normally test key membership using nil checks or underscored optional bindings:<br>&gt; <br>&gt; if dict[&quot;one&quot;] != nil {<br>&gt;     // ...<br>&gt; }<br>&gt; if let _ = dict[&quot;one&quot;] {<br>&gt;     // ...<br>&gt; }<br>&gt; These approaches provide the expected performance of a dictionary lookup but they read neither well nor &quot;Swifty&quot;. Checking keys reads much better but introduces a serious performance penalty: this approach requires a linear search through a dictionary&#39;s keys to find a match.<br>&gt; <br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; A similar dynamic plays out when comparing dict.index(forKey:) and dict.keys.index(of:).<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#inefficient-value-mutation&gt;Inefficient Value Mutation<br>&gt; <br>&gt; Dictionary values can be modified through the keyed subscript by direct reassignment or by using optional chaining. Both of these statements append 1 to the array stored by the key &quot;one&quot;:<br>&gt; <br>&gt; // Direct re-assignment<br>&gt; dict[&quot;one&quot;] = (dict[&quot;one&quot;] ?? []) + [1]<br>&gt; <br>&gt; // Optional chaining<br>&gt; dict[&quot;one&quot;]?.append(1)<br>&gt; Both approaches present problems. The first is complex and hard to read. The second ignores the case where &quot;one&quot; is not a key in the dictionary. It forces its check into a higher branch and encourages forced unwrapping. Furthermore, neither approach allows the array to grow in place. They introduce an unnecessary copy of the array&#39;s contents even though dict is the sole holder of its storage.<br>&gt; <br>&gt; Adding mutation to a dictionary&#39;s index-based subscripting isn&#39;t possible. Changing a key stored at a particular index would almost certainly modify its hash value, rendering the index incorrect. This violates the requirements of the MutableCollection protocol.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; This proposal adds a custom collection for the keys and values dictionary properties. This follows the example set by String, which presents multiple views of its contents. A new DictionaryKeys collection introduces efficient key lookup, while a new DictionaryValues collection provides a mutable collection interface to dictionary values.<br>&gt; <br>&gt; These changes introduce a simple and efficient way of checking whether a dictionary includes a key:<br>&gt; <br>&gt; // Performant<br>&gt; if dict.keys.contains(&quot;one&quot;) {<br>&gt;     // ...<br>&gt; }<br>&gt; As a mutable collection, values enables modification without copies or clumsy code:<br>&gt; <br>&gt; if let i = dict.index(forKey: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)  // no copy here<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt; Both the keys and values collections share the same index type as Dictionary. This allows the above sample to be rewritten as:<br>&gt; <br>&gt; // Using `dict.keys.index(of:)`<br>&gt; if let i = dict.keys.index(of: &quot;one&quot;) {<br>&gt;     dict.values[i].append(1)<br>&gt; } else {<br>&gt;     dict[&quot;one&quot;] = [1]<br>&gt; }<br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The standard library introduces two new collection types: DictionaryKeys and DictionaryValues.<br>&gt; A Dictionary&#39;s keys and values property types change from LazyMapCollection to these new types. <br>&gt; The new collection types are not directly constructable. They are presented only as views into a dictionary.<br>&gt; struct Dictionary&lt;Key: Hashable, Value&gt;: ... {<br>&gt;     var keys: DictionaryKeys&lt;Key, Value&gt; { get }<br>&gt;     var values: DictionaryValues&lt;Key, Value&gt; { get set }<br>&gt; <br>&gt;     // Remaining declarations<br>&gt; }<br>&gt; <br>&gt; /// A collection view of a dictionary&#39;s keys.<br>&gt; struct DictionaryKeys&lt;Key: Hashable, Value&gt;: Collection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Key { get }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; <br>&gt; /// A mutable collection view of a dictionary&#39;s values.<br>&gt; struct DictionaryValues&lt;Key: Hashable, Value&gt;: MutableCollection {<br>&gt;     typealias Index = DictionaryIndex&lt;Key, Value&gt;<br>&gt;     subscript(i: Index) -&gt; Value { get set }<br>&gt; <br>&gt;     // Other `Collection` requirements<br>&gt; }<br>&gt; A sample implementation of this proposal can be found in this branch &lt;https://github.com/natecook1000/swift/tree/nc-dictionary&gt;.<br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The performance improvements of using the new DictionaryKeys type and the mutability of the DictionaryValuescollection are both additive in nature.<br>&gt; <br>&gt; Most uses of these properties are transitory in nature. Adopting this proposal should not produce a major impact on existing code. The only impact on existing code exists where a program explicitly specifies the type of a dictionary&#39;s keysor values property. The fix is to change the specified type. <br>&gt; <br>&gt;  &lt;https://gist.github.com/natecook1000/473720ba072fa5a0cd5e6c913de75fe1#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; The Generics Manifesto &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt; lists nested generics as a goal. This could impact the naming and structure of these new collection types. <br>&gt; <br>&gt; Instead of DictionaryKeys&lt;Key, Value&gt; and DictionaryValues&lt;Key, Value&gt;, these types could be Dictionary&lt;Key, Value&gt;.Keys and Dictionary&lt;Key, Value&gt;.Values. However, because many types in the standard library may be revisited once such a feature is available (indices, iterators, etc.), the current lack of nesting shouldn&#39;t prevent consideration of this proposal.<br>&gt; <br>&gt; It could be possible to add additional compiler features that manage mutation through existing key-based subscripting without the copy-on-write problems of the current implementation. I don&#39;t know enough about how that would be implemented to speak to its feasibility or level of effort. Such a feature would reduce the need for a mutable DictionaryValues collection.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161014/2311b6ed/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
