<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br></p><p>Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class). It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br></p><p>Some of these problems could be solved with a convention like putting _ in front of protected and __ in front of private methods, and Cocoa uses a similar approach today. But this “solution” is in the same category as using prefixes to determine types. If Swift aims to have a strong type system, and it’s described as one of advantages of Swift over ObjC, it should help enforce this at the language level.<br></p><p>.NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br></p><p>I think that a similar approach would work much better in Swift.<br></p><p>—<br>Ilya Belenkiy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>access control</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br>&gt; <br>&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class).<br></p><p>I think the file based approach for `private` has advantages because it allows putting several things that have to know each other deeply into the same file (C++ would use friend access for that).<br></p><p><br>&gt; It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br></p><p>Here I agree. What I am really missing is the ability to declare something „protected“ in a protocol (or class) which is not part of the public API but which I then can use in its default implementation but which has to be provided by implementors of the protocol. <br></p><p>Example (shortened and simplified to just show the relevant parts):<br></p><p>public protocol StandardGraphTraversal {<br>	// push() and pop() are implementation details and not part of the API<br>	protected func push(vertex: Vertex)<br>	protected func pop() -&gt; Vertex?<br></p><p>	public func next() -&gt; Vertex?<br>}<br></p><p>public extension StandardGraphTraversal {<br></p><p>	// leaving out things like visitor callbacks and coloring the visited vertices<br>	public func next() -&gt; Vertex? {<br>		guard let source = pop() else {		// using pop() here<br>			return nil<br>		}<br>		for target in graph.neighborsOf(source) {<br>			if shouldFollowVertex(target) {<br>				push(vertex)		// using push() here<br>			}<br>		}<br>	}<br>}<br></p><p>// supplying the implementation detail: using a queue results in breadth first traversal<br>public struct BreadthFirstTraversal : StandardGraphTraversal {<br>	var queue: Queue&lt;Vertex&gt; = Queue()<br></p><p>	protected func push(vertex: Vertex) { return queue.push(vertex) }<br>	protected func pop() -&gt; Vertex? { return queue.pop() }<br>}<br></p><p>// supplying the implementation detail: using a stack results in depth first traversal<br>public struct DepthFirstTraversal : StandardGraphTraversal {<br>	var stack: Stack&lt;Vertex&gt; = Stack()<br></p><p>	protected func push(vertex: Vertex) { return stack.push(vertex) }<br>	protected func pop() -&gt; Vertex? { return stack.pop() }<br>}<br>	<br></p><p>Currently I cannot express that in Swift and have to make push() and pop() public :-(<br></p><p>(Allowing `internal` in public protocols would be sufficient in my example but would not help in more general cases where the implementors would have to be provided in another module by the framework user).<br></p><p><br>&gt; .NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br></p><p>`public` and `internal` seem to be quite the same as in Swift.<br>`private` is based on the type instead of the file. I think Swift’s file based `private` is better because it allows to express the same by putting a type into its file alone and allows to create strongly interdependent types by putting them together into the same file.<br>`protected` is what I’m missing as well<br>`protected internal` seems to be the union of `protected` and `internal`. I think that is not needed and is probably there to allow testing for which Swift has a nicer solution with @testable imports.<br></p><p>In short the only thing which is missing IMO is `protected`.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/c652eeef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 24, 2016 at 06:00:00am</p></header><div class="content"><p>I am not suggesting to replace the meaning of private. I think that “file internal” or something similar would be a much more precise name for what is now called private in Swift. My suggestion is to add a scope based access level that would signal the author’s intent and make it enforceable by the compiler.<br></p><p>&gt; On Jan 24, 2016, at 3:44 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; 	<br>&gt;&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt; <br>&gt;&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class). <br>&gt; <br>&gt; I think the file based approach for `private` has advantages because it allows putting several things that have to know each other deeply into the same file (C++ would use friend access for that).<br>&gt; <br>&gt; <br>&gt;&gt; It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br>&gt; <br>&gt; Here I agree. What I am really missing is the ability to declare something „protected“ in a protocol (or class) which is not part of the public API but which I then can use in its default implementation but which has to be provided by implementors of the protocol. <br>&gt; <br>&gt; Example (shortened and simplified to just show the relevant parts):<br>&gt; <br>&gt; public protocol StandardGraphTraversal {<br>&gt; 	// push() and pop() are implementation details and not part of the API<br>&gt; 	protected func push(vertex: Vertex)<br>&gt; 	protected func pop() -&gt; Vertex?<br>&gt; <br>&gt; 	public func next() -&gt; Vertex?<br>&gt; }<br>&gt; <br>&gt; public extension StandardGraphTraversal {<br>&gt; <br>&gt; 	// leaving out things like visitor callbacks and coloring the visited vertices<br>&gt; 	public func next() -&gt; Vertex? {<br>&gt; 		guard let source = pop() else {		// using pop() here<br>&gt; 			return nil<br>&gt; 		}<br>&gt; 		for target in graph.neighborsOf(source) {<br>&gt; 			if shouldFollowVertex(target) {<br>&gt; 				push(vertex)		// using push() here<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; // supplying the implementation detail: using a queue results in breadth first traversal<br>&gt; public struct BreadthFirstTraversal : StandardGraphTraversal {<br>&gt; 	var queue: Queue&lt;Vertex&gt; = Queue()<br>&gt; <br>&gt; 	protected func push(vertex: Vertex) { return queue.push(vertex) }<br>&gt; 	protected func pop() -&gt; Vertex? { return queue.pop() }<br>&gt; }<br>&gt; <br>&gt; // supplying the implementation detail: using a stack results in depth first traversal<br>&gt; public struct DepthFirstTraversal : StandardGraphTraversal {<br>&gt; 	var stack: Stack&lt;Vertex&gt; = Stack()<br>&gt; <br>&gt; 	protected func push(vertex: Vertex) { return stack.push(vertex) }<br>&gt; 	protected func pop() -&gt; Vertex? { return stack.pop() }<br>&gt; }<br>&gt; 	<br>&gt; <br>&gt; Currently I cannot express that in Swift and have to make push() and pop() public :-(<br>&gt; <br>&gt; (Allowing `internal` in public protocols would be sufficient in my example but would not help in more general cases where the implementors would have to be provided in another module by the framework user).<br>&gt; <br>&gt; <br>&gt;&gt; .NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx &lt;https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx&gt;<br>&gt; `public` and `internal` seem to be quite the same as in Swift.<br>&gt; `private` is based on the type instead of the file. I think Swift’s file based `private` is better because it allows to express the same by putting a type into its file alone and allows to create strongly interdependent types by putting them together into the same file.<br>&gt; `protected` is what I’m missing as well<br>&gt; `protected internal` seems to be the union of `protected` and `internal`. I think that is not needed and is probably there to allow testing for which Swift has a nicer solution with @testable imports.<br>&gt; <br>&gt; In short the only thing which is missing IMO is `protected`.<br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/e5df31ec/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>access control</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>January 25, 2016 at 02:00:00pm</p></header><div class="content"><p>I disagree with Ilya on his stance on ‘private’. I do understand the argumentation, but the reasoning seems overly formal to me and the classical solution (private visible only within the class) also comes with a number of drawbacks that result in things like friends declarations in C++. It is nice to have relationships between entities explicit, but one can go overboard with the rigidity. <br></p><p>However, I also strongly agree with Thorsten that a subclass (but not public) visible modifier has a lot of uses. I would prefer to have four levels of access:<br></p><p>private (file scope)<br>internal (module scope)<br>protected (subclass scope)<br>public<br></p><p>Best,<br></p><p> Taras<br></p><p><br>&gt; On 24 Jan 2016, at 09:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	<br>&gt;&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt; <br>&gt;&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class).<br>&gt; <br>&gt; I think the file based approach for `private` has advantages because it allows putting several things that have to know each other deeply into the same file (C++ would use friend access for that).<br>&gt; <br>&gt; <br>&gt;&gt; It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br>&gt; <br>&gt; Here I agree. What I am really missing is the ability to declare something „protected“ in a protocol (or class) which is not part of the public API but which I then can use in its default implementation but which has to be provided by implementors of the protocol. <br>&gt; <br>&gt; Example (shortened and simplified to just show the relevant parts):<br>&gt; <br>&gt; public protocol StandardGraphTraversal {<br>&gt; 	// push() and pop() are implementation details and not part of the API<br>&gt; 	protected func push(vertex: Vertex)<br>&gt; 	protected func pop() -&gt; Vertex?<br>&gt; <br>&gt; 	public func next() -&gt; Vertex?<br>&gt; }<br>&gt; <br>&gt; public extension StandardGraphTraversal {<br>&gt; <br>&gt; 	// leaving out things like visitor callbacks and coloring the visited vertices<br>&gt; 	public func next() -&gt; Vertex? {<br>&gt; 		guard let source = pop() else {		// using pop() here<br>&gt; 			return nil<br>&gt; 		}<br>&gt; 		for target in graph.neighborsOf(source) {<br>&gt; 			if shouldFollowVertex(target) {<br>&gt; 				push(vertex)		// using push() here<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; // supplying the implementation detail: using a queue results in breadth first traversal<br>&gt; public struct BreadthFirstTraversal : StandardGraphTraversal {<br>&gt; 	var queue: Queue&lt;Vertex&gt; = Queue()<br>&gt; <br>&gt; 	protected func push(vertex: Vertex) { return queue.push(vertex) }<br>&gt; 	protected func pop() -&gt; Vertex? { return queue.pop() }<br>&gt; }<br>&gt; <br>&gt; // supplying the implementation detail: using a stack results in depth first traversal<br>&gt; public struct DepthFirstTraversal : StandardGraphTraversal {<br>&gt; 	var stack: Stack&lt;Vertex&gt; = Stack()<br>&gt; <br>&gt; 	protected func push(vertex: Vertex) { return stack.push(vertex) }<br>&gt; 	protected func pop() -&gt; Vertex? { return stack.pop() }<br>&gt; }<br>&gt; 	<br>&gt; <br>&gt; Currently I cannot express that in Swift and have to make push() and pop() public :-(<br>&gt; <br>&gt; (Allowing `internal` in public protocols would be sufficient in my example but would not help in more general cases where the implementors would have to be provided in another module by the framework user).<br>&gt; <br>&gt; <br>&gt;&gt; .NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx &lt;https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx&gt;<br>&gt; `public` and `internal` seem to be quite the same as in Swift.<br>&gt; `private` is based on the type instead of the file. I think Swift’s file based `private` is better because it allows to express the same by putting a type into its file alone and allows to create strongly interdependent types by putting them together into the same file.<br>&gt; `protected` is what I’m missing as well<br>&gt; `protected internal` seems to be the union of `protected` and `internal`. I think that is not needed and is probably there to allow testing for which Swift has a nicer solution with @testable imports.<br>&gt; <br>&gt; In short the only thing which is missing IMO is `protected`.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/5a309a47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 01:00:00pm</p></header><div class="content"><p>Formal means enforceable by the compiler. File based access control is<br>useful as well but not as a substitute for real data encapsulation.<br></p><p>On Mon, Jan 25, 2016 at 8:13 AM Taras Zakharko &lt;<br>taras.zakharko at googlemail.com&gt; wrote:<br></p><p>&gt; I disagree with Ilya on his stance on ‘private’. I do understand the<br>&gt; argumentation, but the reasoning seems overly formal to me and the<br>&gt; classical solution (private visible only within the class) also comes with<br>&gt; a number of drawbacks that result in things like friends declarations in<br>&gt; C++. It is nice to have relationships between entities explicit, but one<br>&gt; can go overboard with the rigidity.<br>&gt;<br>&gt; However, I also strongly agree with Thorsten that a subclass (but not<br>&gt; public) visible modifier has a lot of uses. I would prefer to have four<br>&gt; levels of access:<br>&gt;<br>&gt; private (file scope)<br>&gt; internal (module scope)<br>&gt; protected (subclass scope)<br>&gt; public<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt;<br>&gt; On 24 Jan 2016, at 09:44, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I hope that access control can be revisited. It is the number one<br>&gt; complaint about Swift that I hear from experienced developers. The current<br>&gt; solution came as a complete surprise to every ObjC developer I&#39;ve talked<br>&gt; to. The natural expectation was that a strong access control system would<br>&gt; be part of a strong type system. I already submitted a pull request with a<br>&gt; proposal for this after a lengthy discussion here, but so far it was<br>&gt; ignored. I hope that this can be revisited. Even if most people who<br>&gt; responded earlier in this list decided that they were happy with the<br>&gt; current state, it represents a tiny fraction of people using the language,<br>&gt; and at least all the people I talked to strongly disagree but just aren’t<br>&gt; on the list.<br>&gt;<br>&gt; Right now access control is file based and not API based. This is much<br>&gt; easier to implement but useless to express that certain elements of a class<br>&gt; are implementation details that are not meant to be used anywhere else<br>&gt; (someone can add more code to the same file and get access to the<br>&gt; implementation details without modifying the class).<br>&gt;<br>&gt;<br>&gt; I think the file based approach for `private` has advantages because it<br>&gt; allows putting several things that have to know each other deeply into the<br>&gt; same file (C++ would use friend access for that).<br>&gt;<br>&gt;<br>&gt; It’s also impossible to hide APIs that are meant only for customization<br>&gt; points of subclasses.<br>&gt;<br>&gt;<br>&gt; Here I agree. What I am really missing is the ability to declare something<br>&gt; „protected“ in a protocol (or class) which is not part of the public API<br>&gt; but which I then can use in its default implementation but which has to be<br>&gt; provided by implementors of the protocol.<br>&gt;<br>&gt; Example (shortened and simplified to just show the relevant parts):<br>&gt;<br>&gt; public protocol StandardGraphTraversal {<br>&gt; // push() and pop() are implementation details and not part of the API<br>&gt; protected func push(vertex: Vertex)<br>&gt; protected func pop() -&gt; Vertex?<br>&gt;<br>&gt; public func next() -&gt; Vertex?<br>&gt; }<br>&gt;<br>&gt; public extension StandardGraphTraversal {<br>&gt;<br>&gt; // leaving out things like visitor callbacks and coloring the visited<br>&gt; vertices<br>&gt; public func next() -&gt; Vertex? {<br>&gt; guard let source = pop() else { // using pop() here<br>&gt; return nil<br>&gt; }<br>&gt; for target in graph.neighborsOf(source) {<br>&gt; if shouldFollowVertex(target) {<br>&gt; push(vertex) // using push() here<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; // supplying the implementation detail: using a queue results in breadth<br>&gt; first traversal<br>&gt; public struct BreadthFirstTraversal : StandardGraphTraversal {<br>&gt; var queue: Queue&lt;Vertex&gt; = Queue()<br>&gt;<br>&gt; protected func push(vertex: Vertex) { return queue.push(vertex) }<br>&gt; protected func pop() -&gt; Vertex? { return queue.pop() }<br>&gt; }<br>&gt;<br>&gt; // supplying the implementation detail: using a stack results in depth<br>&gt; first traversal<br>&gt; public struct DepthFirstTraversal : StandardGraphTraversal {<br>&gt; var stack: Stack&lt;Vertex&gt; = Stack()<br>&gt;<br>&gt; protected func push(vertex: Vertex) { return stack.push(vertex) }<br>&gt; protected func pop() -&gt; Vertex? { return stack.pop() }<br>&gt; }<br>&gt;<br>&gt; Currently I cannot express that in Swift and have to make push() and pop()<br>&gt; public :-(<br>&gt;<br>&gt; (Allowing `internal` in public protocols would be sufficient in my example<br>&gt; but would not help in more general cases where the implementors would have<br>&gt; to be provided in another module by the framework user).<br>&gt;<br>&gt;<br>&gt; .NET has a good solution that respects the OOP terminology and deals with<br>&gt; accessibility in modules and at the API level:<br>&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx<br>&gt;<br>&gt;<br>&gt; `public` and `internal` seem to be quite the same as in Swift.<br>&gt; `private` is based on the type instead of the file. I think Swift’s file<br>&gt; based `private` is better because it allows to express the same by putting<br>&gt; a type into its file alone and allows to create strongly interdependent<br>&gt; types by putting them together into the same file.<br>&gt; `protected` is what I’m missing as well<br>&gt; `protected internal` seems to be the union of `protected` and `internal`.<br>&gt; I think that is not needed and is probably there to allow testing for which<br>&gt; Swift has a nicer solution with @testable imports.<br>&gt;<br>&gt; In short the only thing which is missing IMO is `protected`.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/e8c8f42d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>access control</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 25, 2016 at 03:00:00pm</p></header><div class="content"><p>That is true of course, but explicitly modelling complex dependency relationships between scopes can be tedious. If you make private truly private, then you also need concepts such a friends and many some others in order to write efficient code. File- and module-based access offers a decent compromise by allowing you to put interdependent implementations into a single file. Personally, I think that this is an elegant and reasonable solution. Yes, it does trade formalism for convenience, but I believe that the tradeoff is reasonable. You already need to maintain some degree of discipline when writing code (you can’t make the compiler to enforce all conventions for you), and I don’t think that its such a big deal to ask people to be careful when modifying a file with a pre-existing type implementation. In the end, your argumentation mainly applies to the case when you have multiple type implementation in the same file. Which is bad style in the first place. Once you embrace idea that all declarations in a single file are closely interdependent (this way or another), file-based access control stops being an issue as you present it. <br></p><p>Best, <br></p><p> Taras <br></p><p>&gt; On 25 Jan 2016, at 14:45, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; Formal means enforceable by the compiler. File based access control is useful as well but not as a substitute for real data encapsulation.<br>&gt; <br>&gt; On Mon, Jan 25, 2016 at 8:13 AM Taras Zakharko &lt;taras.zakharko at googlemail.com &lt;mailto:taras.zakharko at googlemail.com&gt;&gt; wrote:<br>&gt; I disagree with Ilya on his stance on ‘private’. I do understand the argumentation, but the reasoning seems overly formal to me and the classical solution (private visible only within the class) also comes with a number of drawbacks that result in things like friends declarations in C++. It is nice to have relationships between entities explicit, but one can go overboard with the rigidity. <br>&gt; <br>&gt; However, I also strongly agree with Thorsten that a subclass (but not public) visible modifier has a lot of uses. I would prefer to have four levels of access:<br>&gt; <br>&gt; private (file scope)<br>&gt; internal (module scope)<br>&gt; protected (subclass scope)<br>&gt; public<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; <br>&gt;&gt; On 24 Jan 2016, at 09:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	<br>&gt; <br>&gt;&gt;&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class).<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I think the file based approach for `private` has advantages because it allows putting several things that have to know each other deeply into the same file (C++ would use friend access for that).<br>&gt;&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Here I agree. What I am really missing is the ability to declare something „protected“ in a protocol (or class) which is not part of the public API but which I then can use in its default implementation but which has to be provided by implementors of the protocol. <br>&gt;&gt; <br>&gt;&gt; Example (shortened and simplified to just show the relevant parts):<br>&gt;&gt; <br>&gt;&gt; public protocol StandardGraphTraversal {<br>&gt;&gt; 	// push() and pop() are implementation details and not part of the API<br>&gt;&gt; 	protected func push(vertex: Vertex)<br>&gt;&gt; 	protected func pop() -&gt; Vertex?<br>&gt;&gt; <br>&gt;&gt; 	public func next() -&gt; Vertex?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension StandardGraphTraversal {<br>&gt;&gt; <br>&gt;&gt; 	// leaving out things like visitor callbacks and coloring the visited vertices<br>&gt;&gt; 	public func next() -&gt; Vertex? {<br>&gt;&gt; 		guard let source = pop() else {		// using pop() here<br>&gt;&gt; 			return nil<br>&gt;&gt; 		}<br>&gt;&gt; 		for target in graph.neighborsOf(source) {<br>&gt;&gt; 			if shouldFollowVertex(target) {<br>&gt;&gt; 				push(vertex)		// using push() here<br>&gt;&gt; 			}<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // supplying the implementation detail: using a queue results in breadth first traversal<br>&gt;&gt; public struct BreadthFirstTraversal : StandardGraphTraversal {<br>&gt;&gt; 	var queue: Queue&lt;Vertex&gt; = Queue()<br>&gt;&gt; <br>&gt;&gt; 	protected func push(vertex: Vertex) { return queue.push(vertex) }<br>&gt;&gt; 	protected func pop() -&gt; Vertex? { return queue.pop() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // supplying the implementation detail: using a stack results in depth first traversal<br>&gt;&gt; public struct DepthFirstTraversal : StandardGraphTraversal {<br>&gt;&gt; 	var stack: Stack&lt;Vertex&gt; = Stack()<br>&gt;&gt; <br>&gt;&gt; 	protected func push(vertex: Vertex) { return stack.push(vertex) }<br>&gt;&gt; 	protected func pop() -&gt; Vertex? { return stack.pop() }<br>&gt;&gt; }<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt; Currently I cannot express that in Swift and have to make push() and pop() public :-(<br>&gt;&gt; <br>&gt;&gt; (Allowing `internal` in public protocols would be sufficient in my example but would not help in more general cases where the implementors would have to be provided in another module by the framework user).<br>&gt;&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; .NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>&gt;&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx &lt;https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx&gt;<br>&gt; <br>&gt;&gt; `public` and `internal` seem to be quite the same as in Swift.<br>&gt;&gt; `private` is based on the type instead of the file. I think Swift’s file based `private` is better because it allows to express the same by putting a type into its file alone and allows to create strongly interdependent types by putting them together into the same file.<br>&gt;&gt; `protected` is what I’m missing as well<br>&gt;&gt; `protected internal` seems to be the union of `protected` and `internal`. I think that is not needed and is probably there to allow testing for which Swift has a nicer solution with @testable imports.<br>&gt;&gt; <br>&gt;&gt; In short the only thing which is missing IMO is `protected`.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/4f04830f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 10:00:00am</p></header><div class="content"><p>I didn’t propose to remove or repurpose the existing “private” access modifier. Instead, I proposed an additional “local” modifier for real data encapsulation. I think that the current “private” modifier is misnamed. It would be much more concise to call it “file internal” or something similar, but it looks like it’s too late to change this now. Both “private” and “local” are useful. One doesn’t have to exclude the other.<br></p><p>&gt; Yes, it does trade formalism for convenience, but I believe that the tradeoff is reasonable. <br></p><p>Both can and should exist in the language. No need for tradeoffs.<br></p><p>&gt; You already need to maintain some degree of discipline when writing code (you can’t make the compiler to enforce all conventions for you)<br></p><p>In every other respect, Swift compiler tries to help, except this one. The strong type system and type inference are a big deal. This is a big deal for the same reason.<br></p><p>&gt; I don’t think that its such a big deal to ask people to be careful when modifying a file with a pre-existing type implementation.<br></p><p>An intent, clearly spelled out in the property or function declaration, that is enforceable by the compiler will eliminate human errors much more reliably than convention and attempts to be careful. We have ARC and destructors that are automatically called for the same reason.<br></p><p>&gt; In the end, your argumentation mainly applies to the case when you have multiple type implementation in the same file. Which is bad style in the first place. <br></p><p>This is a matter or opinion. Earlier:<br></p><p>&gt; If one class and one extension per file become a requirement,<br>&gt; then private will have the same semantics as in C++. It will also<br>&gt; become very inconvenient to write code because even a small extension<br>&gt; with 1 method that can fit on one line will require a separate file.<br></p><p>Which is why this rule “one class per file” is not there.<br></p><p>&gt; Once you embrace idea that all declarations in a single file are closely interdependent (this way or another), file-based access control stops being an issue as you present it. <br></p><p>It will still be an issue because there is no way to express the author’s intent on whether something is truly private or can be safely shared with closely related code.<br></p><p>&gt; On Jan 25, 2016, at 9:04 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; That is true of course, but explicitly modelling complex dependency relationships between scopes can be tedious. If you make private truly private, then you also need concepts such a friends and many some others in order to write efficient code. File- and module-based access offers a decent compromise by allowing you to put interdependent implementations into a single file. Personally, I think that this is an elegant and reasonable solution. Yes, it does trade formalism for convenience, but I believe that the tradeoff is reasonable. You already need to maintain some degree of discipline when writing code (you can’t make the compiler to enforce all conventions for you), and I don’t think that its such a big deal to ask people to be careful when modifying a file with a pre-existing type implementation. In the end, your argumentation mainly applies to the case when you have multiple type implementation in the same file. Which is bad style in the first place. Once you embrace idea that all declarations in a single file are closely interdependent (this way or another), file-based access control stops being an issue as you present it. <br>&gt; <br>&gt; Best, <br>&gt; <br>&gt;  Taras <br>&gt; <br>&gt;&gt; On 25 Jan 2016, at 14:45, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com &lt;mailto:ilya.belenkiy at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Formal means enforceable by the compiler. File based access control is useful as well but not as a substitute for real data encapsulation.<br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 25, 2016 at 8:13 AM Taras Zakharko &lt;taras.zakharko at googlemail.com &lt;mailto:taras.zakharko at googlemail.com&gt;&gt; wrote:<br>&gt;&gt; I disagree with Ilya on his stance on ‘private’. I do understand the argumentation, but the reasoning seems overly formal to me and the classical solution (private visible only within the class) also comes with a number of drawbacks that result in things like friends declarations in C++. It is nice to have relationships between entities explicit, but one can go overboard with the rigidity. <br>&gt;&gt; <br>&gt;&gt; However, I also strongly agree with Thorsten that a subclass (but not public) visible modifier has a lot of uses. I would prefer to have four levels of access:<br>&gt;&gt; <br>&gt;&gt; private (file scope)<br>&gt;&gt; internal (module scope)<br>&gt;&gt; protected (subclass scope)<br>&gt;&gt; public<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; <br>&gt;&gt;  Taras<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 24 Jan 2016, at 09:44, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 23.01.2016 um 16:56 schrieb Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope that access control can be revisited. It is the number one complaint about Swift that I hear from experienced developers. The current solution came as a complete surprise to every ObjC developer I&#39;ve talked to. The natural expectation was that a strong access control system would be part of a strong type system. I already submitted a pull request with a proposal for this after a lengthy discussion here, but so far it was ignored. I hope that this can be revisited. Even if most people who responded earlier in this list decided that they were happy with the current state, it represents a tiny fraction of people using the language, and at least all the people I talked to strongly disagree but just aren’t on the list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I think the file based approach for `private` has advantages because it allows putting several things that have to know each other deeply into the same file (C++ would use friend access for that).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Here I agree. What I am really missing is the ability to declare something „protected“ in a protocol (or class) which is not part of the public API but which I then can use in its default implementation but which has to be provided by implementors of the protocol. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example (shortened and simplified to just show the relevant parts):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol StandardGraphTraversal {<br>&gt;&gt;&gt; 	// push() and pop() are implementation details and not part of the API<br>&gt;&gt;&gt; 	protected func push(vertex: Vertex)<br>&gt;&gt;&gt; 	protected func pop() -&gt; Vertex?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	public func next() -&gt; Vertex?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public extension StandardGraphTraversal {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// leaving out things like visitor callbacks and coloring the visited vertices<br>&gt;&gt;&gt; 	public func next() -&gt; Vertex? {<br>&gt;&gt;&gt; 		guard let source = pop() else {		// using pop() here<br>&gt;&gt;&gt; 			return nil<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 		for target in graph.neighborsOf(source) {<br>&gt;&gt;&gt; 			if shouldFollowVertex(target) {<br>&gt;&gt;&gt; 				push(vertex)		// using push() here<br>&gt;&gt;&gt; 			}<br>&gt;&gt;&gt; 		}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // supplying the implementation detail: using a queue results in breadth first traversal<br>&gt;&gt;&gt; public struct BreadthFirstTraversal : StandardGraphTraversal {<br>&gt;&gt;&gt; 	var queue: Queue&lt;Vertex&gt; = Queue()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protected func push(vertex: Vertex) { return queue.push(vertex) }<br>&gt;&gt;&gt; 	protected func pop() -&gt; Vertex? { return queue.pop() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // supplying the implementation detail: using a stack results in depth first traversal<br>&gt;&gt;&gt; public struct DepthFirstTraversal : StandardGraphTraversal {<br>&gt;&gt;&gt; 	var stack: Stack&lt;Vertex&gt; = Stack()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protected func push(vertex: Vertex) { return stack.push(vertex) }<br>&gt;&gt;&gt; 	protected func pop() -&gt; Vertex? { return stack.pop() }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently I cannot express that in Swift and have to make push() and pop() public :-(<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Allowing `internal` in public protocols would be sufficient in my example but would not help in more general cases where the implementors would have to be provided in another module by the framework user).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .NET has a good solution that respects the OOP terminology and deals with accessibility in modules and at the API level:<br>&gt;&gt;&gt;&gt; https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx &lt;https://msdn.microsoft.com/en-us/library/wxh6fsc7.aspx&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; `public` and `internal` seem to be quite the same as in Swift.<br>&gt;&gt;&gt; `private` is based on the type instead of the file. I think Swift’s file based `private` is better because it allows to express the same by putting a type into its file alone and allows to create strongly interdependent types by putting them together into the same file.<br>&gt;&gt;&gt; `protected` is what I’m missing as well<br>&gt;&gt;&gt; `protected internal` seems to be the union of `protected` and `internal`. I think that is not needed and is probably there to allow testing for which Swift has a nicer solution with @testable imports.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short the only thing which is missing IMO is `protected`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/b9ee0c19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>access control</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 25 Jan 2016, at 16:12, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; I didn’t propose to remove or repurpose the existing “private” access modifier. Instead, I proposed an additional “local” modifier for real data encapsulation. I think that the current “private” modifier is misnamed. It would be much more concise to call it “file internal” or something similar, but it looks like it’s too late to change this now. Both “private” and “local” are useful. One doesn’t have to exclude the other.<br></p><p>Oh, then I apologise. I got the wrong impression and/or was inattentive. In principle, I see no issue with adding a new access modifier as you suggest. I don’t think that I personally will use it, but some people could find it useful. <br></p><p>— Taras<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>access control</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 25.01.2016 um 16:12 schrieb Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;:<br>&gt; <br>&gt; I didn’t propose to remove or repurpose the existing “private” access modifier. Instead, I proposed an additional “local” modifier for real data encapsulation. I think that the current “private” modifier is misnamed. It would be much more concise to call it “file internal” or something similar, but it looks like it’s too late to change this now. Both “private” and “local” are useful. One doesn’t have to exclude the other.<br>&gt; <br>&gt;&gt; Yes, it does trade formalism for convenience, but I believe that the tradeoff is reasonable. <br>&gt; <br>&gt; Both can and should exist in the language. No need for tradeoffs.<br></p><p>I don’t see much of a tradeoff: if you want class private just put nothing else in the file.<br></p><p><br>&gt;&gt; You already need to maintain some degree of discipline when writing code (you can’t make the compiler to enforce all conventions for you)<br>&gt; <br>&gt; In every other respect, Swift compiler tries to help, except this one. The strong type system and type inference are a big deal. This is a big deal for the same reason.<br></p><p>I don’t understand: the compiler checks whether you have access to a member, so it certainly does help, doesn’t it?<br></p><p><br>&gt;&gt; Once you embrace idea that all declarations in a single file are closely interdependent (this way or another), file-based access control stops being an issue as you present it. <br>&gt; <br>&gt; <br>&gt; It will still be an issue because there is no way to express the author’s intent on whether something is truly private or can be safely shared with closely related code.<br></p><p>If you edit the same file you are in effect the class’s author and therefore should know the intent (or be able to derive it). When I’m editing a Java class (possibly written by someone else) I also have to check whether I can safely use a private method or whether I’m breaking the inner workings of the class by my changes. No real difference there.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I don’t see much of a tradeoff: if you want class private just put nothing else in the file.<br></p><p>It’s a convention that is not enforced by the compiler. Anyone can break it, accidentally or deliberately.<br></p><p>&gt; I don’t understand: the compiler checks whether you have access to a member, so it certainly does help, doesn’t it?<br></p><p>Not if you are in the same file. If you are, you can access anything.<br></p><p>&gt; If you edit the same file you are in effect the class’s author<br></p><p>Not necessarily.<br></p><p>&gt; and therefore should know the intent (or be able to derive it).<br></p><p>but if the API is marked properly, you don’t need derive anything — just look at the declaration. Also, with “local” the compiler catches a mistake while with “private” it is possible to make it. Why do this manually with a huge potential for human error when the compiler can enforce it for you?<br></p><p>&gt; When I’m editing a Java class (possibly written by someone else) I also have to check whether I can safely use a private method or whether I’m breaking the inner workings of the class by my changes. No real difference there.<br></p><p>Because in Java, the compiler enforces one class per file. So you in Java you *are* changing the class itself. If Swift enforced one class per file and one extension per file, there would be no difference, but nobody wants that because it would be very inconvenient.<br></p><p>&gt; On Jan 25, 2016, at 4:32 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.01.2016 um 16:12 schrieb Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; I didn’t propose to remove or repurpose the existing “private” access modifier. Instead, I proposed an additional “local” modifier for real data encapsulation. I think that the current “private” modifier is misnamed. It would be much more concise to call it “file internal” or something similar, but it looks like it’s too late to change this now. Both “private” and “local” are useful. One doesn’t have to exclude the other.<br>&gt;&gt; <br>&gt;&gt;&gt; Yes, it does trade formalism for convenience, but I believe that the tradeoff is reasonable. <br>&gt;&gt; <br>&gt;&gt; Both can and should exist in the language. No need for tradeoffs.<br>&gt; <br>&gt; I don’t see much of a tradeoff: if you want class private just put nothing else in the file.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; You already need to maintain some degree of discipline when writing code (you can’t make the compiler to enforce all conventions for you)<br>&gt;&gt; <br>&gt;&gt; In every other respect, Swift compiler tries to help, except this one. The strong type system and type inference are a big deal. This is a big deal for the same reason.<br>&gt; <br>&gt; I don’t understand: the compiler checks whether you have access to a member, so it certainly does help, doesn’t it?<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Once you embrace idea that all declarations in a single file are closely interdependent (this way or another), file-based access control stops being an issue as you present it. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It will still be an issue because there is no way to express the author’s intent on whether something is truly private or can be safely shared with closely related code.<br>&gt; <br>&gt; If you edit the same file you are in effect the class’s author and therefore should know the intent (or be able to derive it). When I’m editing a Java class (possibly written by someone else) I also have to check whether I can safely use a private method or whether I’m breaking the inner workings of the class by my changes. No real difference there.<br>&gt; <br>&gt; -Thorsten<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>access control</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 28, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Right now access control is file based and not API based. This is much easier to implement but useless to express that certain elements of a class are implementation details that are not meant to be used anywhere else (someone can add more code to the same file and get access to the implementation details without modifying the class). It’s also impossible to hide APIs that are meant only for customization points of subclasses.<br></p><p>I am strongly opposed to `local`. But frankly, I&#39;m so sick of discussing it at this point that I think we should just go ahead and propose it. Everyone can write their reviews, the core team can make a decision, and whatever they decide, we can move on from this topic to more interesting things.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>&quot;Local&quot; addresses an important problem in the current access control,<br>should be easy to implement and support,, and doesn&#39;t break any existing<br>code. If you are not going to use it, that&#39;s ok, but plenty of people will.<br>It&#39;s the number one complaint that I hear about Swift from anybody I asked<br>about the language. So I understand &quot;I won&#39;t use it&quot;, but I don&#39;t<br>understand &quot;I am strongly against&quot;.<br></p><p>I also think that 2 rounds of discussion are more than enough to schedule a<br>review and asked about this. It looks like my question was ignored. I will<br>definitely keep trying one way or another until it goes through a formal<br>review. Even if it gets rejected, at least there will be an official<br>statement about why real data encapsulation is not important enough or<br>needed for Swift. And if it&#39;s accepted, a lot of people who are not on this<br>list will be very happy.<br>On Thu, Jan 28, 2016 at 5:56 AM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Right now access control is file based and not API based. This is much<br>&gt; easier to implement but useless to express that certain elements of a class<br>&gt; are implementation details that are not meant to be used anywhere else<br>&gt; (someone can add more code to the same file and get access to the<br>&gt; implementation details without modifying the class). It’s also impossible<br>&gt; to hide APIs that are meant only for customization points of subclasses.<br>&gt;<br>&gt; I am strongly opposed to `local`. But frankly, I&#39;m so sick of discussing<br>&gt; it at this point that I think we should just go ahead and propose it.<br>&gt; Everyone can write their reviews, the core team can make a decision, and<br>&gt; whatever they decide, we can move on from this topic to more interesting<br>&gt; things.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/55122472/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
