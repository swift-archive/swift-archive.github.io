<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Dispatch + Blocking Calls</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>October 31, 2016 at 01:00:00am</p></header><div class="content"><p>Something to keep in mind… once SR-2905 &lt;https://bugs.swift.org/browse/SR-2905&gt; is resolved, it will be feasible to write Linux server applications in a synchronous manner.<br></p><p>How does this work? Dispatch work items are scheduled onto a pool of kernel threads. If a work item makes a blocking system call, the kernel thread will be blocked. Ideally, the work item scheduler will start a new kernel thread to take the place of the blocked thread. This is only possible if the scheduler can be triggered at the moment the blocking system call is made. A Linux kernel module is required for this to work in Swift.<br></p><p>This ideal threading model is the main selling point of Go. Go developers can write their code in a synchronous manner without any performance tradeoff. (You might be wondering why Go does not need a kernel module. The reason is all the system calls go through the Go runtime before reaching the kernel.)<br></p><p>Personally, I am very excited for the day that this kernel module is released. Swift will truly be the best programming language in nearly every regard.<br></p><p>Darren<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161031/19891e27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>Dispatch + Blocking Calls</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>October 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 31 oct. 2016 à 09:21, Darren Mo via swift-server-dev &lt;swift-server-dev at swift.org&gt; a écrit :<br>&gt; <br>&gt; Something to keep in mind… once SR-2905 &lt;https://bugs.swift.org/browse/SR-2905&gt; is resolved, it will be feasible to write Linux server applications in a synchronous manner.<br>&gt; <br>&gt; How does this work? Dispatch work items are scheduled onto a pool of kernel threads. If a work item makes a blocking system call, the kernel thread will be blocked. Ideally, the work item scheduler will start a new kernel thread to take the place of the blocked thread. This is only possible if the scheduler can be triggered at the moment the blocking system call is made. A Linux kernel module is required for this to work in Swift.<br>&gt; <br>&gt; This ideal threading model is the main selling point of Go. Go developers can write their code in a synchronous manner without any performance tradeoff. (You might be wondering why Go does not need a kernel module. The reason is all the system calls go through the Go runtime before reaching the kernel.)<br></p><p>The main benefit of GCD and worker threads is that as the threads are managed by the kernel, it can accommodate thread allocation and io scheduling by considering the system load as a whole, and not only the process load.<br>I’m not familiar with go enough to know how the runtime cope with this, but from the description it look like it don&#39;t care about other processes when it managed goroutines.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161031/9091c27e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c155243169db74a7787bab9d57a1c3d6?s=50"></div><header><strong>Dispatch + Blocking Calls</strong> from <string>Darren Mo</string> &lt;darren.mo at me.com&gt;<p>October 31, 2016 at 09:00:00pm</p></header><div class="content"><p>You are right that the Go runtime does not care about system load. I suppose it was designed for server applications running in Docker containers or virtual machines. In this world, system load does not matter because a chunk of system resources will be allocated exclusively to the application.<br></p><p>&gt; On Oct 31, 2016, at 2:25 PM, Jean-Daniel &lt;dev at xenonium.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 31 oct. 2016 à 09:21, Darren Mo via swift-server-dev &lt;swift-server-dev at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Something to keep in mind… once SR-2905 is resolved, it will be feasible to write Linux server applications in a synchronous manner.<br>&gt;&gt; <br>&gt;&gt; How does this work? Dispatch work items are scheduled onto a pool of kernel threads. If a work item makes a blocking system call, the kernel thread will be blocked. Ideally, the work item scheduler will start a new kernel thread to take the place of the blocked thread. This is only possible if the scheduler can be triggered at the moment the blocking system call is made. A Linux kernel module is required for this to work in Swift.<br>&gt;&gt; <br>&gt;&gt; This ideal threading model is the main selling point of Go. Go developers can write their code in a synchronous manner without any performance tradeoff. (You might be wondering why Go does not need a kernel module. The reason is all the system calls go through the Go runtime before reaching the kernel.)<br>&gt; <br>&gt; The main benefit of GCD and worker threads is that as the threads are managed by the kernel, it can accommodate thread allocation and io scheduling by considering the system load as a whole, and not only the process load.<br>&gt; I’m not familiar with go enough to know how the runtime cope with this, but from the description it look like it don&#39;t care about other processes when it managed goroutines.<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161031/c8887906/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
