<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  1, 2016 at 02:00:00pm</p></header><div class="content"><p>For some particular arrays of strings, creating a<br>Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>strings).<br></p><p>I&#39;ve put together a tiny program to demonstrate the problem here:<br>http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br></p><p>Is this due to a bug / performance problem in Set or can it be explained<br>(and solved) in some way?<br></p><p>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160301/0b7b9244/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>March  1, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Jens,<br></p><p>Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look. <br></p><p>I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress. <br></p><p>Thanks,<br>Nadav <br></p><p>&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt; <br>&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html &lt;http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html&gt;<br>&gt; <br>&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160301/b097e064/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  2, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks, but I&#39;ll have to invite anyone with more time and experience to do<br>that.<br></p><p>One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB<br>text file for the particular arrayOfStrings that makes Set(arrayOfStrings)<br>slow. It seems a bit unnecessary/bloating to put it in the code base.<br></p><p>/Jens<br></p><p>On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br></p><p>&gt; Hi Jens,<br>&gt;<br>&gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll<br>&gt; take a look.<br>&gt;<br>&gt; I think it would be great if you could add this program as a benchmark<br>&gt; under swift/benchmarks/.  This will allow us to track the performance of<br>&gt; this test and ensure that we don’t regress.<br>&gt;<br>&gt; Thanks,<br>&gt; Nadav<br>&gt;<br>&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; For some particular arrays of strings, creating a<br>&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt; strings).<br>&gt;<br>&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;<br>&gt; Is this due to a bug / performance problem in Set or can it be explained<br>&gt; (and solved) in some way?<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160302/332bed2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  2, 2016 at 09:00:00am</p></header><div class="content"><p>I guess it would be possible to isolate the problem by analyzing my<br>example, and thereby making it possible to write a smaller benchmark which<br>doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>my question about the problem here.<br>/Jens<br></p><p>On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do<br>&gt; that.<br>&gt;<br>&gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB<br>&gt; text file for the particular arrayOfStrings that makes Set(arrayOfStrings)<br>&gt; slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Jens,<br>&gt;&gt;<br>&gt;&gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll<br>&gt;&gt; take a look.<br>&gt;&gt;<br>&gt;&gt; I think it would be great if you could add this program as a benchmark<br>&gt;&gt; under swift/benchmarks/.  This will allow us to track the performance of<br>&gt;&gt; this test and ensure that we don’t regress.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Nadav<br>&gt;&gt;<br>&gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; For some particular arrays of strings, creating a<br>&gt;&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt;&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt;&gt; strings).<br>&gt;&gt;<br>&gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;<br>&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;<br>&gt;&gt; Is this due to a bug / performance problem in Set or can it be explained<br>&gt;&gt; (and solved) in some way?<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160302/aa6b46f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March  2, 2016 at 09:00:00am</p></header><div class="content"><p>That is the difference between a “String” type instance that can use the ascii fast path and NSString backed “String” type instances.<br></p><p>When the code translates the string (the map function that calls upper case) it becomes a natively backed “String” that isASCII.<br></p><p>// The strings in strings.txt are not strange in any way, they all match ^[a-zA-Z ]+$.<br></p><p>Set the isASCII bit and things are blazing fast.<br></p><p>The other path is that componentsSeparatedByString(separator: String) -&gt; [String] returns an “[String]” where every “String” is backed by “NSString”. When it comes to do comparison we call a NSString function on the NSString and this is where the difference in performance comes from.<br></p><p><br></p><p><br>&gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I guess it would be possible to isolate the problem by analyzing my example, and thereby making it possible to write a smaller benchmark which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence my question about the problem here.<br>&gt; /Jens<br>&gt; <br>&gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do that.<br>&gt; <br>&gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB text file for the particular arrayOfStrings that makes Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt; Hi Jens,<br>&gt; <br>&gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look. <br>&gt; <br>&gt; I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress. <br>&gt; <br>&gt; Thanks,<br>&gt; Nadav <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt;&gt; <br>&gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt; <br>&gt;&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  3, 2016 at 03:00:00am</p></header><div class="content"><p>Just thought I should mention that I tried another thing:<br></p><p>Using my original example:<br>http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>Keeping the code as it is but adding a space to the end of every line in<br>the actual text file (strings.txt).<br></p><p>This actually makes the slow test(strings) run almost as fast as the fast<br>test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster<br>just because the text file has an extra space at the end of each line.<br></p><p>I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ... An<br>added space character at the end of each line of that text file is just one<br>more ASCII character, how can that make test(strings) so much faster?<br></p><p>And other operations on the text file makes the slow test faster too, like<br>eg:<br>Inserting a space as the first char of each line, 0.9 seconds.<br>Removing all spaces, 0.9 seconds.<br>Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it<br>slow again), 0.9 seconds.<br>Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>Swapping case (now in the actual file instead of programmatically), 2.3<br>seconds.<br>(I only tried operations that kept the resulting strings unique and their<br>characters plain ASCII.)<br></p><p>/Jens<br></p><p>On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com<br>&gt; wrote:<br></p><p>&gt; That is the difference between a “String” type instance that can use the<br>&gt; ascii fast path and NSString backed “String” type instances.<br>&gt;<br>&gt; When the code translates the string (the map function that calls upper<br>&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt;<br>&gt; // The strings in strings.txt are not strange in any way, they all match<br>&gt; ^[a-zA-Z ]+$.<br>&gt;<br>&gt; Set the isASCII bit and things are blazing fast.<br>&gt;<br>&gt; The other path is that componentsSeparatedByString(separator: String) -&gt;<br>&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt; the NSString and this is where the difference in performance comes from.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt; my question about the problem here.<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to<br>&gt; do that.<br>&gt; &gt;<br>&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB<br>&gt; text file for the particular arrayOfStrings that makes Set(arrayOfStrings)<br>&gt; slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt; &gt;<br>&gt; &gt; /Jens<br>&gt; &gt;<br>&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt; &gt; Hi Jens,<br>&gt; &gt;<br>&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll<br>&gt; take a look.<br>&gt; &gt;<br>&gt; &gt; I think it would be great if you could add this program as a benchmark<br>&gt; under swift/benchmarks/.  This will allow us to track the performance of<br>&gt; this test and ensure that we don’t regress.<br>&gt; &gt;<br>&gt; &gt; Thanks,<br>&gt; &gt; Nadav<br>&gt; &gt;<br>&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt; strings).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt; &gt;&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt; explained (and solved) in some way?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt;&gt; swift-dev at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160303/e932c2da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes this does not explain what you are seeing. (I could repeat this on my end)<br></p><p>If you look at the two runs under instruments: one run with the slow strings file and one with the fast strings file (I tested with space appended to each line); you will notice that we spend a lot more time in the Set&#39;s find function doing NSString comparisons. The only explanation I have for this is hash collisions leading to more comparisons as we are probing non empty buckets. Why one of the files would trigger this and the other not makes no sense to me.<br>This will need looking at.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Just thought I should mention that I tried another thing:<br>&gt; <br>&gt; Using my original example:<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; Keeping the code as it is but adding a space to the end of every line in the actual text file (strings.txt).<br>&gt; <br>&gt; This actually makes the slow test(strings) run almost as fast as the fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster just because the text file has an extra space at the end of each line.<br>&gt; <br>&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ... An added space character at the end of each line of that text file is just one more ASCII character, how can that make test(strings) so much faster?<br>&gt; <br>&gt; And other operations on the text file makes the slow test faster too, like eg:<br>&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt; Removing all spaces, 0.9 seconds.<br>&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it slow again), 0.9 seconds.<br>&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt; Swapping case (now in the actual file instead of programmatically), 2.3 seconds.<br>&gt; (I only tried operations that kept the resulting strings unique and their characters plain ASCII.)<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; That is the difference between a “String” type instance that can use the ascii fast path and NSString backed “String” type instances.<br>&gt;&gt; <br>&gt;&gt; When the code translates the string (the map function that calls upper case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt; <br>&gt;&gt; // The strings in strings.txt are not strange in any way, they all match ^[a-zA-Z ]+$.<br>&gt;&gt; <br>&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt; <br>&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt; [String] returns an “[String]” where every “String” is backed by “NSString”. When it comes to do comparison we call a NSString function on the NSString and this is where the difference in performance comes from.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my example, and thereby making it possible to write a smaller benchmark which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence my question about the problem here.<br>&gt;&gt; &gt; /Jens<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do that.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB text file for the particular arrayOfStrings that makes Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; /Jens<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt; &gt; Hi Jens,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks,<br>&gt;&gt; &gt; Nadav<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt; &gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160302/993dbdba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>Are you already tracking/looking into this in someway or should I file a<br>bug?<br>/Jens<br></p><p>On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br></p><p>&gt; Yes this does not explain what you are seeing. (I could repeat this on my<br>&gt; end)<br>&gt;<br>&gt; If you look at the two runs under instruments: one run with the slow<br>&gt; strings file and one with the fast strings file (I tested with space<br>&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt; other not makes no sense to me.<br>&gt; This will need looking at.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt; Just thought I should mention that I tried another thing:<br>&gt;<br>&gt; Using my original example:<br>&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; Keeping the code as it is but adding a space to the end of every line in<br>&gt; the actual text file (strings.txt).<br>&gt;<br>&gt; This actually makes the slow test(strings) run almost as fast as the fast<br>&gt; test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster<br>&gt; just because the text file has an extra space at the end of each line.<br>&gt;<br>&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ...<br>&gt; An added space character at the end of each line of that text file is just<br>&gt; one more ASCII character, how can that make test(strings) so much faster?<br>&gt;<br>&gt; And other operations on the text file makes the slow test faster too, like<br>&gt; eg:<br>&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt; Removing all spaces, 0.9 seconds.<br>&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it<br>&gt; slow again), 0.9 seconds.<br>&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt; Swapping case (now in the actual file instead of programmatically), 2.3<br>&gt; seconds.<br>&gt; (I only tried operations that kept the resulting strings unique and their<br>&gt; characters plain ASCII.)<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt; aschwaighofer at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; That is the difference between a “String” type instance that can use the<br>&gt;&gt; ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;<br>&gt;&gt; When the code translates the string (the map function that calls upper<br>&gt;&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;<br>&gt;&gt; // The strings in strings.txt are not strange in any way, they all match<br>&gt;&gt; ^[a-zA-Z ]+$.<br>&gt;&gt;<br>&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;<br>&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt;<br>&gt;&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt;&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt;&gt; the NSString and this is where the difference in performance comes from.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt;&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt;&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt;&gt; my question about the problem here.<br>&gt;&gt; &gt; /Jens<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to<br>&gt;&gt; do that.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB<br>&gt;&gt; text file for the particular arrayOfStrings that makes Set(arrayOfStrings)<br>&gt;&gt; slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; /Jens<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt; &gt; Hi Jens,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll<br>&gt;&gt; take a look.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark<br>&gt;&gt; under swift/benchmarks/.  This will allow us to track the performance of<br>&gt;&gt; this test and ensure that we don’t regress.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks,<br>&gt;&gt; &gt; Nadav<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt;&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt;&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt;&gt; strings).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt;&gt; explained (and solved) in some way?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/13dd6a66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a<br>Set&lt;String&gt;) is fast ...<br></p><p>That is (for those same particular strings) this is fast (0.7 s):<br>let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br></p><p>while this is slow (9.5 s):<br>let setOfNSStrings = Set&lt;String&gt;(strings)<br></p><p>/Jens<br></p><p><br>On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Are you already tracking/looking into this in someway or should I file a<br>&gt; bug?<br>&gt; /Jens<br>&gt;<br>&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on my<br>&gt;&gt; end)<br>&gt;&gt;<br>&gt;&gt; If you look at the two runs under instruments: one run with the slow<br>&gt;&gt; strings file and one with the fast strings file (I tested with space<br>&gt;&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt;&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt;&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt;&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt;&gt; other not makes no sense to me.<br>&gt;&gt; This will need looking at.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt;&gt;<br>&gt;&gt; Using my original example:<br>&gt;&gt;<br>&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt; Keeping the code as it is but adding a space to the end of every line in<br>&gt;&gt; the actual text file (strings.txt).<br>&gt;&gt;<br>&gt;&gt; This actually makes the slow test(strings) run almost as fast as the fast<br>&gt;&gt; test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster<br>&gt;&gt; just because the text file has an extra space at the end of each line.<br>&gt;&gt;<br>&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ...<br>&gt;&gt; An added space character at the end of each line of that text file is just<br>&gt;&gt; one more ASCII character, how can that make test(strings) so much faster?<br>&gt;&gt;<br>&gt;&gt; And other operations on the text file makes the slow test faster too,<br>&gt;&gt; like eg:<br>&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made<br>&gt;&gt; it slow again), 0.9 seconds.<br>&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3<br>&gt;&gt; seconds.<br>&gt;&gt; (I only tried operations that kept the resulting strings unique and their<br>&gt;&gt; characters plain ASCII.)<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt;&gt; aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; That is the difference between a “String” type instance that can use the<br>&gt;&gt;&gt; ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When the code translates the string (the map function that calls upper<br>&gt;&gt;&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all match<br>&gt;&gt;&gt; ^[a-zA-Z ]+$.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt;<br>&gt;&gt;&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt;&gt;&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt;&gt;&gt; the NSString and this is where the difference in performance comes from.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt;&gt;&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt;&gt;&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt;&gt;&gt; my question about the problem here.<br>&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience<br>&gt;&gt;&gt; to do that.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3<br>&gt;&gt;&gt; MB text file for the particular arrayOfStrings that makes<br>&gt;&gt;&gt; Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in<br>&gt;&gt;&gt; the code base.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; Hi Jens,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but<br>&gt;&gt;&gt; we’ll take a look.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark<br>&gt;&gt;&gt; under swift/benchmarks/.  This will allow us to track the performance of<br>&gt;&gt;&gt; this test and ensure that we don’t regress.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks,<br>&gt;&gt;&gt; &gt; Nadav<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt;&gt;&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt;&gt;&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt;&gt;&gt; strings).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt;&gt;&gt; explained (and solved) in some way?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/96963eac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  4, 2016 at 11:00:00am</p></header><div class="content"><p>(Correction: 0.07 seconds, not 0.7 seconds.)<br></p><p>On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a<br>&gt; Set&lt;String&gt;) is fast ...<br>&gt;<br>&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt;<br>&gt; while this is slow (9.5 s):<br>&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; Are you already tracking/looking into this in someway or should I file a<br>&gt;&gt; bug?<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on<br>&gt;&gt;&gt; my end)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you look at the two runs under instruments: one run with the slow<br>&gt;&gt;&gt; strings file and one with the fast strings file (I tested with space<br>&gt;&gt;&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt;&gt;&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt;&gt;&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt;&gt;&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt;&gt;&gt; other not makes no sense to me.<br>&gt;&gt;&gt; This will need looking at.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using my original example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line in<br>&gt;&gt;&gt; the actual text file (strings.txt).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the<br>&gt;&gt;&gt; fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times<br>&gt;&gt;&gt; faster just because the text file has an extra space at the end of each<br>&gt;&gt;&gt; line.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ...<br>&gt;&gt;&gt; An added space character at the end of each line of that text file is just<br>&gt;&gt;&gt; one more ASCII character, how can that make test(strings) so much faster?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And other operations on the text file makes the slow test faster too,<br>&gt;&gt;&gt; like eg:<br>&gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made<br>&gt;&gt;&gt; it slow again), 0.9 seconds.<br>&gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3<br>&gt;&gt;&gt; seconds.<br>&gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and<br>&gt;&gt;&gt; their characters plain ASCII.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt;&gt;&gt; aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That is the difference between a “String” type instance that can use<br>&gt;&gt;&gt;&gt; the ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When the code translates the string (the map function that calls upper<br>&gt;&gt;&gt;&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all<br>&gt;&gt;&gt;&gt; match ^[a-zA-Z ]+$.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String)<br>&gt;&gt;&gt;&gt; -&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt;&gt;&gt;&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt;&gt;&gt;&gt; the NSString and this is where the difference in performance comes from.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt;&gt;&gt;&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt;&gt;&gt;&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt;&gt;&gt;&gt; my question about the problem here.<br>&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience<br>&gt;&gt;&gt;&gt; to do that.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3<br>&gt;&gt;&gt;&gt; MB text file for the particular arrayOfStrings that makes<br>&gt;&gt;&gt;&gt; Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in<br>&gt;&gt;&gt;&gt; the code base.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Hi Jens,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but<br>&gt;&gt;&gt;&gt; we’ll take a look.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think it would be great if you could add this program as a<br>&gt;&gt;&gt;&gt; benchmark under swift/benchmarks/.  This will allow us to track the<br>&gt;&gt;&gt;&gt; performance of this test and ensure that we don’t regress.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thanks,<br>&gt;&gt;&gt;&gt; &gt; Nadav<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt;&gt;&gt;&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt;&gt;&gt;&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt;&gt;&gt;&gt; strings).<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt;&gt;&gt;&gt; explained (and solved) in some way?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/b86d8171/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  4, 2016 at 02:00:00pm</p></header><div class="content"><p>If you make a WrappedString type where you can choose to use .hash instead<br>of .hashValue, then the below test(wrappedStrings) will be fast if .hash is<br>used, and slow if .hashValue is used. Demo-program:<br></p><p>import QuartzCore<br>struct WrappedString : Hashable {<br>    let wrapped : String<br>    init(_ s: String) { wrapped = s }<br>    var hashValue: Int {<br>        return wrapped.hash // &lt;-- NOTE: Will make test(wrappedStrings)<br>fast.<br>        // return wrapped.hashValue // &lt;-- NOTE: Will make<br>test(wrappedStrings) slow.<br>    }<br>}<br>func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return<br>lhs.wrapped == rhs.wrapped }<br>func test&lt;T: Hashable&gt;(array: [T]) {<br>    let t0 = CACurrentMediaTime()<br>    let set = Set(array)<br>    let t1 = CACurrentMediaTime()<br>    print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0, &quot;seconds.&quot;)<br>}<br>// Download http://sloppyfocus.com/strings.zip, unzip and set the correct<br>path here:<br>let path = &quot;/Users/jens/strings.txt&quot;<br>do {<br>    let strings = try String.init(contentsOfFile:<br>path).componentsSeparatedByString(&quot;\n&quot;)<br>    print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded 88379<br>strings.<br>    let wrappedStrings = strings.map { WrappedString($0) }<br>    test(wrappedStrings) // Prints: Created set of 88379 strings in<br>0.0923392080003396 seconds.<br>    test(strings)        // Prints: Created set of 88379 strings in<br>9.25633556599496 seconds.<br>}<br>catch let e { fatalError(String(e)) }<br></p><p>/Jens<br></p><p><br>On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt;<br>&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a<br>&gt;&gt; Set&lt;String&gt;) is fast ...<br>&gt;&gt;<br>&gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt;&gt;<br>&gt;&gt; while this is slow (9.5 s):<br>&gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Are you already tracking/looking into this in someway or should I file a<br>&gt;&gt;&gt; bug?<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on<br>&gt;&gt;&gt;&gt; my end)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you look at the two runs under instruments: one run with the slow<br>&gt;&gt;&gt;&gt; strings file and one with the fast strings file (I tested with space<br>&gt;&gt;&gt;&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt;&gt;&gt;&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt;&gt;&gt;&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt;&gt;&gt;&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt;&gt;&gt;&gt; other not makes no sense to me.<br>&gt;&gt;&gt;&gt; This will need looking at.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Using my original example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line<br>&gt;&gt;&gt;&gt; in the actual text file (strings.txt).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the<br>&gt;&gt;&gt;&gt; fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times<br>&gt;&gt;&gt;&gt; faster just because the text file has an extra space at the end of each<br>&gt;&gt;&gt;&gt; line.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that<br>&gt;&gt;&gt;&gt; ... An added space character at the end of each line of that text file is<br>&gt;&gt;&gt;&gt; just one more ASCII character, how can that make test(strings) so much<br>&gt;&gt;&gt;&gt; faster?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And other operations on the text file makes the slow test faster too,<br>&gt;&gt;&gt;&gt; like eg:<br>&gt;&gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt;&gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt;&gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made<br>&gt;&gt;&gt;&gt; it slow again), 0.9 seconds.<br>&gt;&gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt;&gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3<br>&gt;&gt;&gt;&gt; seconds.<br>&gt;&gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and<br>&gt;&gt;&gt;&gt; their characters plain ASCII.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt;&gt;&gt;&gt; aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That is the difference between a “String” type instance that can use<br>&gt;&gt;&gt;&gt;&gt; the ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When the code translates the string (the map function that calls upper<br>&gt;&gt;&gt;&gt;&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all<br>&gt;&gt;&gt;&gt;&gt; match ^[a-zA-Z ]+$.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String)<br>&gt;&gt;&gt;&gt;&gt; -&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt;&gt;&gt;&gt;&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt;&gt;&gt;&gt;&gt; the NSString and this is where the difference in performance comes from.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt;&gt;&gt;&gt;&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt;&gt;&gt;&gt;&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt;&gt;&gt;&gt;&gt; my question about the problem here.<br>&gt;&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience<br>&gt;&gt;&gt;&gt;&gt; to do that.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3<br>&gt;&gt;&gt;&gt;&gt; MB text file for the particular arrayOfStrings that makes<br>&gt;&gt;&gt;&gt;&gt; Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in<br>&gt;&gt;&gt;&gt;&gt; the code base.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; Hi Jens,<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but<br>&gt;&gt;&gt;&gt;&gt; we’ll take a look.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I think it would be great if you could add this program as a<br>&gt;&gt;&gt;&gt;&gt; benchmark under swift/benchmarks/.  This will allow us to track the<br>&gt;&gt;&gt;&gt;&gt; performance of this test and ensure that we don’t regress.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; &gt; Nadav<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt;&gt;&gt;&gt;&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt;&gt;&gt;&gt;&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt;&gt;&gt;&gt;&gt; strings).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt;&gt;&gt;&gt;&gt; explained (and solved) in some way?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/18f1a006/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March  4, 2016 at 06:00:00am</p></header><div class="content"><p>Yes. NSString&#39;s hash is not the same function as String&#39;s hashValue. To make matters more confusing when you call hashValue  on NSString type you actually get<br>NSStrings hash.<br></p><p>I have confirmed that we are indeed getting a lot more collisions with the bad Strings  and I will be looking into this.<br></p><p><br>Sent from my iPhone<br></p><p>&gt; On Mar 4, 2016, at 5:18 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; If you make a WrappedString type where you can choose to use .hash instead of .hashValue, then the below test(wrappedStrings) will be fast if .hash is used, and slow if .hashValue is used. Demo-program:<br>&gt; <br>&gt; import QuartzCore<br>&gt; struct WrappedString : Hashable {<br>&gt;     let wrapped : String<br>&gt;     init(_ s: String) { wrapped = s }<br>&gt;     var hashValue: Int {<br>&gt;         return wrapped.hash // &lt;-- NOTE: Will make test(wrappedStrings) fast.<br>&gt;         // return wrapped.hashValue // &lt;-- NOTE: Will make test(wrappedStrings) slow.<br>&gt;     }<br>&gt; }<br>&gt; func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return lhs.wrapped == rhs.wrapped }<br>&gt; func test&lt;T: Hashable&gt;(array: [T]) {<br>&gt;     let t0 = CACurrentMediaTime()<br>&gt;     let set = Set(array)<br>&gt;     let t1 = CACurrentMediaTime()<br>&gt;     print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0, &quot;seconds.&quot;)<br>&gt; }<br>&gt; // Download http://sloppyfocus.com/strings.zip, unzip and set the correct path here:<br>&gt; let path = &quot;/Users/jens/strings.txt&quot;<br>&gt; do {<br>&gt;     let strings = try String.init(contentsOfFile: path).componentsSeparatedByString(&quot;\n&quot;)<br>&gt;     print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded 88379 strings.<br>&gt;     let wrappedStrings = strings.map { WrappedString($0) }<br>&gt;     test(wrappedStrings) // Prints: Created set of 88379 strings in 0.0923392080003396 seconds.<br>&gt;     test(strings)        // Prints: Created set of 88379 strings in 9.25633556599496 seconds.<br>&gt; }<br>&gt; catch let e { fatalError(String(e)) }<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt;&gt; On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a Set&lt;String&gt;) is fast ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt;&gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; while this is slow (9.5 s):<br>&gt;&gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Are you already tracking/looking into this in someway or should I file a bug?<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on my end)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you look at the two runs under instruments: one run with the slow strings file and one with the fast strings file (I tested with space appended to each line); you will notice that we spend a lot more time in the Set&#39;s find function doing NSString comparisons. The only explanation I have for this is hash collisions leading to more comparisons as we are probing non empty buckets. Why one of the files would trigger this and the other not makes no sense to me.<br>&gt;&gt;&gt;&gt;&gt; This will need looking at.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Using my original example:<br>&gt;&gt;&gt;&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt;&gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line in the actual text file (strings.txt).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster just because the text file has an extra space at the end of each line.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ... An added space character at the end of each line of that text file is just one more ASCII character, how can that make test(strings) so much faster?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And other operations on the text file makes the slow test faster too, like eg:<br>&gt;&gt;&gt;&gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt;&gt;&gt;&gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt;&gt;&gt;&gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it slow again), 0.9 seconds.<br>&gt;&gt;&gt;&gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt;&gt;&gt;&gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3 seconds.<br>&gt;&gt;&gt;&gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and their characters plain ASCII.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That is the difference between a “String” type instance that can use the ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; When the code translates the string (the map function that calls upper case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all match ^[a-zA-Z ]+$.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt; [String] returns an “[String]” where every “String” is backed by “NSString”. When it comes to do comparison we call a NSString function on the NSString and this is where the difference in performance comes from.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my example, and thereby making it possible to write a smaller benchmark which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence my question about the problem here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB text file for the particular arrayOfStrings that makes Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Hi Jens,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Nadav<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/535f5595/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March  4, 2016 at 07:00:00am</p></header><div class="content"><p>Tracked by: https://bugs.swift.org/browse/SR-877<br></p><p><br>&gt; On Mar 4, 2016, at 6:10 AM, Arnold via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes. NSString&#39;s hash is not the same function as String&#39;s hashValue. To make matters more confusing when you call hashValue  on NSString type you actually get<br>&gt; NSStrings hash.<br>&gt; <br>&gt; I have confirmed that we are indeed getting a lot more collisions with the bad Strings  and I will be looking into this.<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Mar 4, 2016, at 5:18 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt;&gt; If you make a WrappedString type where you can choose to use .hash instead of .hashValue, then the below test(wrappedStrings) will be fast if .hash is used, and slow if .hashValue is used. Demo-program:<br>&gt;&gt; <br>&gt;&gt; import QuartzCore<br>&gt;&gt; struct WrappedString : Hashable {<br>&gt;&gt;     let wrapped : String<br>&gt;&gt;     init(_ s: String) { wrapped = s }<br>&gt;&gt;     var hashValue: Int {<br>&gt;&gt;         return wrapped.hash // &lt;-- NOTE: Will make test(wrappedStrings) fast.<br>&gt;&gt;         // return wrapped.hashValue // &lt;-- NOTE: Will make test(wrappedStrings) slow.<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return lhs.wrapped == rhs.wrapped }<br>&gt;&gt; func test&lt;T: Hashable&gt;(array: [T]) {<br>&gt;&gt;     let t0 = CACurrentMediaTime()<br>&gt;&gt;     let set = Set(array)<br>&gt;&gt;     let t1 = CACurrentMediaTime()<br>&gt;&gt;     print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0, &quot;seconds.&quot;)<br>&gt;&gt; }<br>&gt;&gt; // Download http://sloppyfocus.com/strings.zip, unzip and set the correct path here:<br>&gt;&gt; let path = &quot;/Users/jens/strings.txt&quot;<br>&gt;&gt; do {<br>&gt;&gt;     let strings = try String.init(contentsOfFile: path).componentsSeparatedByString(&quot;\n&quot;)<br>&gt;&gt;     print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded 88379 strings.<br>&gt;&gt;     let wrappedStrings = strings.map { WrappedString($0) }<br>&gt;&gt;     test(wrappedStrings) // Prints: Created set of 88379 strings in 0.0923392080003396 seconds.<br>&gt;&gt;     test(strings)        // Prints: Created set of 88379 strings in 9.25633556599496 seconds.<br>&gt;&gt; }<br>&gt;&gt; catch let e { fatalError(String(e)) }<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt;&gt; <br>&gt;&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a Set&lt;String&gt;) is fast ...<br>&gt;&gt; <br>&gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt;&gt; <br>&gt;&gt; while this is slow (9.5 s):<br>&gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; Are you already tracking/looking into this in someway or should I file a bug?<br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on my end)<br>&gt;&gt; <br>&gt;&gt; If you look at the two runs under instruments: one run with the slow strings file and one with the fast strings file (I tested with space appended to each line); you will notice that we spend a lot more time in the Set&#39;s find function doing NSString comparisons. The only explanation I have for this is hash collisions leading to more comparisons as we are probing non empty buckets. Why one of the files would trigger this and the other not makes no sense to me.<br>&gt;&gt; This will need looking at.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using my original example:<br>&gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line in the actual text file (strings.txt).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster just because the text file has an extra space at the end of each line.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ... An added space character at the end of each line of that text file is just one more ASCII character, how can that make test(strings) so much faster?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And other operations on the text file makes the slow test faster too, like eg:<br>&gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it slow again), 0.9 seconds.<br>&gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3 seconds.<br>&gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and their characters plain ASCII.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt;&gt;&gt; That is the difference between a “String” type instance that can use the ascii fast path and NSString backed “String” type instances.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When the code translates the string (the map function that calls upper case) it becomes a natively backed “String” that isASCII.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all match ^[a-zA-Z ]+$.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt; [String] returns an “[String]” where every “String” is backed by “NSString”. When it comes to do comparison we call a NSString function on the NSString and this is where the difference in performance comes from.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my example, and thereby making it possible to write a smaller benchmark which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence my question about the problem here.<br>&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do that.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB text file for the particular arrayOfStrings that makes Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; /Jens<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt; Hi Jens,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks,<br>&gt;&gt;&gt; &gt; Nadav<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt;&gt;&gt; &gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; /Jens<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  4, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks!<br></p><p>On Fri, Mar 4, 2016 at 4:25 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com<br>&gt; wrote:<br></p><p>&gt; Tracked by: https://bugs.swift.org/browse/SR-877<br>&gt;<br>&gt;<br>&gt; &gt; On Mar 4, 2016, at 6:10 AM, Arnold via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes. NSString&#39;s hash is not the same function as String&#39;s hashValue. To<br>&gt; make matters more confusing when you call hashValue  on NSString type you<br>&gt; actually get<br>&gt; &gt; NSStrings hash.<br>&gt; &gt;<br>&gt; &gt; I have confirmed that we are indeed getting a lot more collisions with<br>&gt; the bad Strings  and I will be looking into this.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt; On Mar 4, 2016, at 5:18 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; If you make a WrappedString type where you can choose to use .hash<br>&gt; instead of .hashValue, then the below test(wrappedStrings) will be fast if<br>&gt; .hash is used, and slow if .hashValue is used. Demo-program:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; import QuartzCore<br>&gt; &gt;&gt; struct WrappedString : Hashable {<br>&gt; &gt;&gt;     let wrapped : String<br>&gt; &gt;&gt;     init(_ s: String) { wrapped = s }<br>&gt; &gt;&gt;     var hashValue: Int {<br>&gt; &gt;&gt;         return wrapped.hash // &lt;-- NOTE: Will make test(wrappedStrings)<br>&gt; fast.<br>&gt; &gt;&gt;         // return wrapped.hashValue // &lt;-- NOTE: Will make<br>&gt; test(wrappedStrings) slow.<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return<br>&gt; lhs.wrapped == rhs.wrapped }<br>&gt; &gt;&gt; func test&lt;T: Hashable&gt;(array: [T]) {<br>&gt; &gt;&gt;     let t0 = CACurrentMediaTime()<br>&gt; &gt;&gt;     let set = Set(array)<br>&gt; &gt;&gt;     let t1 = CACurrentMediaTime()<br>&gt; &gt;&gt;     print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0,<br>&gt; &quot;seconds.&quot;)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; // Download http://sloppyfocus.com/strings.zip, unzip and set the<br>&gt; correct path here:<br>&gt; &gt;&gt; let path = &quot;/Users/jens/strings.txt&quot;<br>&gt; &gt;&gt; do {<br>&gt; &gt;&gt;     let strings = try String.init(contentsOfFile:<br>&gt; path).componentsSeparatedByString(&quot;\n&quot;)<br>&gt; &gt;&gt;     print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded 88379<br>&gt; strings.<br>&gt; &gt;&gt;     let wrappedStrings = strings.map { WrappedString($0) }<br>&gt; &gt;&gt;     test(wrappedStrings) // Prints: Created set of 88379 strings in<br>&gt; 0.0923392080003396 seconds.<br>&gt; &gt;&gt;     test(strings)        // Prints: Created set of 88379 strings in<br>&gt; 9.25633556599496 seconds.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; catch let e { fatalError(String(e)) }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a<br>&gt; Set&lt;String&gt;) is fast ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt; &gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; while this is slow (9.5 s):<br>&gt; &gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt; Are you already tracking/looking into this in someway or should I file<br>&gt; a bug?<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; &gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on<br>&gt; my end)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you look at the two runs under instruments: one run with the slow<br>&gt; strings file and one with the fast strings file (I tested with space<br>&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt; other not makes no sense to me.<br>&gt; &gt;&gt; This will need looking at.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Using my original example:<br>&gt; &gt;&gt;&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line<br>&gt; in the actual text file (strings.txt).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the<br>&gt; fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times<br>&gt; faster just because the text file has an extra space at the end of each<br>&gt; line.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that<br>&gt; ... An added space character at the end of each line of that text file is<br>&gt; just one more ASCII character, how can that make test(strings) so much<br>&gt; faster?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; And other operations on the text file makes the slow test faster too,<br>&gt; like eg:<br>&gt; &gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces<br>&gt; made it slow again), 0.9 seconds.<br>&gt; &gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically),<br>&gt; 2.3 seconds.<br>&gt; &gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and<br>&gt; their characters plain ASCII.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; /Jens<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt; aschwaighofer at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; That is the difference between a “String” type instance that can use<br>&gt; the ascii fast path and NSString backed “String” type instances.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; When the code translates the string (the map function that calls upper<br>&gt; case) it becomes a natively backed “String” that isASCII.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all<br>&gt; match ^[a-zA-Z ]+$.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String)<br>&gt; -&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt; the NSString and this is where the difference in performance comes from.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my<br>&gt; example, and thereby making it possible to write a smaller benchmark which<br>&gt; doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence<br>&gt; my question about the problem here.<br>&gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience<br>&gt; to do that.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3<br>&gt; MB text file for the particular arrayOfStrings that makes<br>&gt; Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in<br>&gt; the code base.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt; Hi Jens,<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but<br>&gt; we’ll take a look.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; I think it would be great if you could add this program as a<br>&gt; benchmark under swift/benchmarks/.  This will allow us to track the<br>&gt; performance of this test and ensure that we don’t regress.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Thanks,<br>&gt; &gt;&gt;&gt; &gt; Nadav<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt; strings).<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt; explained (and solved) in some way?<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt; &gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160304/7076e659/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Fixed in https://github.com/apple/swift/commit/ab5defc1248d0703215a810f705da4e717d10600.<br></p><p>The original test case runs now as:<br></p><p>./TestStrings <br>Loaded 88380 strings into an array of strings.<br>Created set of 88380 strings in 0.0794822110037785 seconds.<br>Created set of 88380 strings in 0.110139190001064 seconds<br></p><p><br>&gt; On Mar 4, 2016, at 8:57 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; On Fri, Mar 4, 2016 at 4:25 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; Tracked by: https://bugs.swift.org/browse/SR-877<br>&gt; <br>&gt; <br>&gt; &gt; On Mar 4, 2016, at 6:10 AM, Arnold via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Yes. NSString&#39;s hash is not the same function as String&#39;s hashValue. To make matters more confusing when you call hashValue  on NSString type you actually get<br>&gt; &gt; NSStrings hash.<br>&gt; &gt;<br>&gt; &gt; I have confirmed that we are indeed getting a lot more collisions with the bad Strings  and I will be looking into this.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt; On Mar 4, 2016, at 5:18 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; If you make a WrappedString type where you can choose to use .hash instead of .hashValue, then the below test(wrappedStrings) will be fast if .hash is used, and slow if .hashValue is used. Demo-program:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; import QuartzCore<br>&gt; &gt;&gt; struct WrappedString : Hashable {<br>&gt; &gt;&gt;     let wrapped : String<br>&gt; &gt;&gt;     init(_ s: String) { wrapped = s }<br>&gt; &gt;&gt;     var hashValue: Int {<br>&gt; &gt;&gt;         return wrapped.hash // &lt;-- NOTE: Will make test(wrappedStrings) fast.<br>&gt; &gt;&gt;         // return wrapped.hashValue // &lt;-- NOTE: Will make test(wrappedStrings) slow.<br>&gt; &gt;&gt;     }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return lhs.wrapped == rhs.wrapped }<br>&gt; &gt;&gt; func test&lt;T: Hashable&gt;(array: [T]) {<br>&gt; &gt;&gt;     let t0 = CACurrentMediaTime()<br>&gt; &gt;&gt;     let set = Set(array)<br>&gt; &gt;&gt;     let t1 = CACurrentMediaTime()<br>&gt; &gt;&gt;     print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0, &quot;seconds.&quot;)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; // Download http://sloppyfocus.com/strings.zip, unzip and set the correct path here:<br>&gt; &gt;&gt; let path = &quot;/Users/jens/strings.txt&quot;<br>&gt; &gt;&gt; do {<br>&gt; &gt;&gt;     let strings = try String.init(contentsOfFile: path).componentsSeparatedByString(&quot;\n&quot;)<br>&gt; &gt;&gt;     print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded 88379 strings.<br>&gt; &gt;&gt;     let wrappedStrings = strings.map { WrappedString($0) }<br>&gt; &gt;&gt;     test(wrappedStrings) // Prints: Created set of 88379 strings in 0.0923392080003396 seconds.<br>&gt; &gt;&gt;     test(strings)        // Prints: Created set of 88379 strings in 9.25633556599496 seconds.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; catch let e { fatalError(String(e)) }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a Set&lt;String&gt;) is fast ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt; &gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; while this is slow (9.5 s):<br>&gt; &gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt; Are you already tracking/looking into this in someway or should I file a bug?<br>&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; &gt;&gt; Yes this does not explain what you are seeing. (I could repeat this on my end)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you look at the two runs under instruments: one run with the slow strings file and one with the fast strings file (I tested with space appended to each line); you will notice that we spend a lot more time in the Set&#39;s find function doing NSString comparisons. The only explanation I have for this is hash collisions leading to more comparisons as we are probing non empty buckets. Why one of the files would trigger this and the other not makes no sense to me.<br>&gt; &gt;&gt; This will need looking at.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Using my original example:<br>&gt; &gt;&gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every line in the actual text file (strings.txt).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times faster just because the text file has an extra space at the end of each line.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that ... An added space character at the end of each line of that text file is just one more ASCII character, how can that make test(strings) so much faster?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; And other operations on the text file makes the slow test faster too, like eg:<br>&gt; &gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces made it slow again), 0.9 seconds.<br>&gt; &gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt; &gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically), 2.3 seconds.<br>&gt; &gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and their characters plain ASCII.)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; /Jens<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; That is the difference between a “String” type instance that can use the ascii fast path and NSString backed “String” type instances.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; When the code translates the string (the map function that calls upper case) it becomes a natively backed “String” that isASCII.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all match ^[a-zA-Z ]+$.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The other path is that componentsSeparatedByString(separator: String) -&gt; [String] returns an “[String]” where every “String” is backed by “NSString”. When it comes to do comparison we call a NSString function on the NSString and this is where the difference in performance comes from.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing my example, and thereby making it possible to write a smaller benchmark which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however, hence my question about the problem here.<br>&gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and experience to do that.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the 1.3 MB text file for the particular arrayOfStrings that makes Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in the code base.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt; Hi Jens,<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but we’ll take a look.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; I think it would be great if you could add this program as a benchmark under swift/benchmarks/.  This will allow us to track the performance of this test and ensure that we don’t regress.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Thanks,<br>&gt; &gt;&gt;&gt; &gt; Nadav<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for other very similar arrays of strings (equally many unique simple [a-zA-Z ]+ strings).<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt; &gt;&gt;&gt; &gt;&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be explained (and solved) in some way?<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; /Jens<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-dev at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt; &gt;&gt;&gt; &gt; swift-dev at swift.org<br>&gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt;&gt; E-mail: jens at bitcycle.com<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Very slow Set&lt;String&gt;(arrayOfStrings) for some arrayOfStrings</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>March  5, 2016 at 09:00:00am</p></header><div class="content"><p>Ah, great!<br></p><p>On Saturday, March 5, 2016, Arnold Schwaighofer &lt;aschwaighofer at apple.com&gt;<br>wrote:<br></p><p>&gt; Fixed in<br>&gt; https://github.com/apple/swift/commit/ab5defc1248d0703215a810f705da4e717d10600<br>&gt; .<br>&gt;<br>&gt; The original test case runs now as:<br>&gt;<br>&gt; ./TestStrings<br>&gt; Loaded 88380 strings into an array of strings.<br>&gt; Created set of 88380 strings in 0.0794822110037785 seconds.<br>&gt; Created set of 88380 strings in 0.110139190001064 seconds<br>&gt;<br>&gt;<br>&gt; &gt; On Mar 4, 2016, at 8:57 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Thanks!<br>&gt; &gt;<br>&gt; &gt; On Fri, Mar 4, 2016 at 4:25 PM, Arnold Schwaighofer &lt;<br>&gt; aschwaighofer at apple.com &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; Tracked by: https://bugs.swift.org/browse/SR-877<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt; On Mar 4, 2016, at 6:10 AM, Arnold via swift-dev &lt;swift-dev at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Yes. NSString&#39;s hash is not the same function as String&#39;s hashValue.<br>&gt; To make matters more confusing when you call hashValue  on NSString type<br>&gt; you actually get<br>&gt; &gt; &gt; NSStrings hash.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I have confirmed that we are indeed getting a lot more collisions with<br>&gt; the bad Strings  and I will be looking into this.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Sent from my iPhone<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Mar 4, 2016, at 5:18 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;&gt; If you make a WrappedString type where you can choose to use .hash<br>&gt; instead of .hashValue, then the below test(wrappedStrings) will be fast if<br>&gt; .hash is used, and slow if .hashValue is used. Demo-program:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; import QuartzCore<br>&gt; &gt; &gt;&gt; struct WrappedString : Hashable {<br>&gt; &gt; &gt;&gt;     let wrapped : String<br>&gt; &gt; &gt;&gt;     init(_ s: String) { wrapped = s }<br>&gt; &gt; &gt;&gt;     var hashValue: Int {<br>&gt; &gt; &gt;&gt;         return wrapped.hash // &lt;-- NOTE: Will make<br>&gt; test(wrappedStrings) fast.<br>&gt; &gt; &gt;&gt;         // return wrapped.hashValue // &lt;-- NOTE: Will make<br>&gt; test(wrappedStrings) slow.<br>&gt; &gt; &gt;&gt;     }<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt; func ==(lhs: WrappedString, rhs: WrappedString) -&gt; Bool { return<br>&gt; lhs.wrapped == rhs.wrapped }<br>&gt; &gt; &gt;&gt; func test&lt;T: Hashable&gt;(array: [T]) {<br>&gt; &gt; &gt;&gt;     let t0 = CACurrentMediaTime()<br>&gt; &gt; &gt;&gt;     let set = Set(array)<br>&gt; &gt; &gt;&gt;     let t1 = CACurrentMediaTime()<br>&gt; &gt; &gt;&gt;     print(&quot;Created set of&quot;, set.count, &quot; elements in&quot;, t1 - t0,<br>&gt; &quot;seconds.&quot;)<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt; // Download http://sloppyfocus.com/strings.zip, unzip and set the<br>&gt; correct path here:<br>&gt; &gt; &gt;&gt; let path = &quot;/Users/jens/strings.txt&quot;<br>&gt; &gt; &gt;&gt; do {<br>&gt; &gt; &gt;&gt;     let strings = try String.init(contentsOfFile:<br>&gt; path).componentsSeparatedByString(&quot;\n&quot;)<br>&gt; &gt; &gt;&gt;     print(&quot;Loaded&quot;, strings.count, &quot;strings.&quot;) // Prints: Loaded<br>&gt; 88379 strings.<br>&gt; &gt; &gt;&gt;     let wrappedStrings = strings.map { WrappedString($0) }<br>&gt; &gt; &gt;&gt;     test(wrappedStrings) // Prints: Created set of 88379 strings in<br>&gt; 0.0923392080003396 seconds.<br>&gt; &gt; &gt;&gt;     test(strings)        // Prints: Created set of 88379 strings in<br>&gt; 9.25633556599496 seconds.<br>&gt; &gt; &gt;&gt; }<br>&gt; &gt; &gt;&gt; catch let e { fatalError(String(e)) }<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Fri, Mar 4, 2016 at 11:13 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt; (Correction: 0.07 seconds, not 0.7 seconds.)<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Fri, Mar 4, 2016 at 10:33 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt; Another thing I noticed is that making a Set&lt;NSString&gt; (rather than a<br>&gt; Set&lt;String&gt;) is fast ...<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; That is (for those same particular strings) this is fast (0.7 s):<br>&gt; &gt; &gt;&gt; let setOfNSStrings = Set&lt;NSString&gt;(strings.map { $0 as NSString })<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; while this is slow (9.5 s):<br>&gt; &gt; &gt;&gt; let setOfNSStrings = Set&lt;String&gt;(strings)<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Fri, Mar 4, 2016 at 9:48 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt; Are you already tracking/looking into this in someway or should I<br>&gt; file a bug?<br>&gt; &gt; &gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Thu, Mar 3, 2016 at 5:55 AM, Arnold &lt;aschwaighofer at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt; Yes this does not explain what you are seeing. (I could repeat this<br>&gt; on my end)<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; If you look at the two runs under instruments: one run with the slow<br>&gt; strings file and one with the fast strings file (I tested with space<br>&gt; appended to each line); you will notice that we spend a lot more time in<br>&gt; the Set&#39;s find function doing NSString comparisons. The only explanation I<br>&gt; have for this is hash collisions leading to more comparisons as we are<br>&gt; probing non empty buckets. Why one of the files would trigger this and the<br>&gt; other not makes no sense to me.<br>&gt; &gt; &gt;&gt; This will need looking at.<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; On Mar 2, 2016, at 6:43 PM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Just thought I should mention that I tried another thing:<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Using my original example:<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt; &gt;&gt;&gt; Keeping the code as it is but adding a space to the end of every<br>&gt; line in the actual text file (strings.txt).<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; This actually makes the slow test(strings) run almost as fast as the<br>&gt; fast test(caseSwappedStrings), 0.09 seconds, so about a hundred times<br>&gt; faster just because the text file has an extra space at the end of each<br>&gt; line.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; I just can&#39;t see how Arnold Schwaighofer&#39;s explanation explains that<br>&gt; ... An added space character at the end of each line of that text file is<br>&gt; just one more ASCII character, how can that make test(strings) so much<br>&gt; faster?<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; And other operations on the text file makes the slow test faster<br>&gt; too, like eg:<br>&gt; &gt; &gt;&gt;&gt; Inserting a space as the first char of each line, 0.9 seconds.<br>&gt; &gt; &gt;&gt;&gt; Removing all spaces, 0.9 seconds.<br>&gt; &gt; &gt;&gt;&gt; Replacing all spaces with &quot;-&quot; (replacing the dashes back to spaces<br>&gt; made it slow again), 0.9 seconds.<br>&gt; &gt; &gt;&gt;&gt; Replacing all &quot;a&quot; with &quot;*&quot;, 0.9 seconds.<br>&gt; &gt; &gt;&gt;&gt; Swapping case (now in the actual file instead of programmatically),<br>&gt; 2.3 seconds.<br>&gt; &gt; &gt;&gt;&gt; (I only tried operations that kept the resulting strings unique and<br>&gt; their characters plain ASCII.)<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; On Wed, Mar 2, 2016 at 6:28 PM, Arnold Schwaighofer &lt;<br>&gt; aschwaighofer at apple.com &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; That is the difference between a “String” type instance that can use<br>&gt; the ascii fast path and NSString backed “String” type instances.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; When the code translates the string (the map function that calls<br>&gt; upper case) it becomes a natively backed “String” that isASCII.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; // The strings in strings.txt are not strange in any way, they all<br>&gt; match ^[a-zA-Z ]+$.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; Set the isASCII bit and things are blazing fast.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; The other path is that componentsSeparatedByString(separator:<br>&gt; String) -&gt; [String] returns an “[String]” where every “String” is backed by<br>&gt; “NSString”. When it comes to do comparison we call a NSString function on<br>&gt; the NSString and this is where the difference in performance comes from.<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; On Mar 2, 2016, at 12:15 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; I guess it would be possible to isolate the problem by analyzing<br>&gt; my example, and thereby making it possible to write a smaller benchmark<br>&gt; which doesn&#39;t need that big textfile. I didn&#39;t manage to do that however,<br>&gt; hence my question about the problem here.<br>&gt; &gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; On Wed, Mar 2, 2016 at 9:11 AM, Jens Persson &lt;jens at bitcycle.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; &gt; Thanks, but I&#39;ll have to invite anyone with more time and<br>&gt; experience to do that.<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; One (of many) thing(s) I wouldn&#39;t know how include/handle is the<br>&gt; 1.3 MB text file for the particular arrayOfStrings that makes<br>&gt; Set(arrayOfStrings) slow. It seems a bit unnecessary/bloating to put it in<br>&gt; the code base.<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; /Jens<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; On Tue, Mar 1, 2016 at 11:58 PM, Nadav Rotem &lt;nrotem at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; &gt; Hi Jens,<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; Thanks for reporting this issue. I don’t know what’s going on but<br>&gt; we’ll take a look.<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; I think it would be great if you could add this program as a<br>&gt; benchmark under swift/benchmarks/.  This will allow us to track the<br>&gt; performance of this test and ensure that we don’t regress.<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; Thanks,<br>&gt; &gt; &gt;&gt;&gt; &gt; Nadav<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; On Mar 1, 2016, at 5:01 AM, Jens Persson via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; For some particular arrays of strings, creating a<br>&gt; Set&lt;String&gt;(arrayOfStrings) takes about 100 to 200 times longer than for<br>&gt; other very similar arrays of strings (equally many unique simple [a-zA-Z ]+<br>&gt; strings).<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; I&#39;ve put together a tiny program to demonstrate the problem here:<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; http://sloppyfocus.com/slowSetFromParticularButSeeminglyNormalArrayOfStrings.html<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; Is this due to a bug / performance problem in Set or can it be<br>&gt; explained (and solved) in some way?<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; /Jens<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; swift-dev mailing list<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; swift-dev at swift.org &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt; &gt;&gt;&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt;&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt;&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt;&gt; &gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt; &gt; &gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt; &gt; &gt;&gt;&gt; &gt; swift-dev at swift.org &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;&gt; --<br>&gt; &gt; &gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt;&gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt;&gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; --<br>&gt; &gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; --<br>&gt; &gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; --<br>&gt; &gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt;&gt; --<br>&gt; &gt; &gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; &gt;&gt; http://www.bitcycle.com/<br>&gt; &gt; &gt;&gt; Phone: +46-73-753 24 62<br>&gt; &gt; &gt;&gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-dev mailing list<br>&gt; &gt; &gt; swift-dev at swift.org &lt;javascript:;&gt;<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; &gt; http://www.bitcycle.com/<br>&gt; &gt; Phone: +46-73-753 24 62<br>&gt; &gt; E-mail: jens at bitcycle.com &lt;javascript:;&gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160305/e84701a4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
