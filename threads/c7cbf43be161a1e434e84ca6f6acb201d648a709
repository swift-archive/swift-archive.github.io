<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>on Fri Mar 25 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dave,<br>&gt;<br>&gt; I&#39;ve been giving this approach a lot of thought (and have read everything<br>&gt; I&#39;ve been able to find that you&#39;ve written on the matter several times) and<br>&gt; am not convinced it will work. Implementing a lowerBound function is<br>&gt; trivial with a unary operator. However, implementing an upperBound or<br>&gt; binarySearch function is, at least in my mind, a bit more difficult. <br></p><p>upperBound is just lowerBound with an inverted predicate.  You can prove<br>this to yourself by looking at the implementation of any C++ standard<br>library.<br></p><p>&gt; The reason is because with the unary predicate we only know if an<br>&gt; element is strictly less than the search value or greater than or<br>&gt; equal to the search value, whereas in the standard approach we can<br>&gt; determine strictly greater than as well as equivalence by swapping the<br>&gt; inputs to the comp function.<br>&gt;<br>&gt; For example, consider the set [2, 1, 5, 4]. If we want to search the set<br>&gt; using a unary predicate for 3, we would pass in the closure { $0 &lt; 3  }. I<br>&gt; don&#39;t see how we can test for equivalence when all we know is &quot;&lt;&quot; or &quot;&gt;=&quot;.<br>&gt; With the standard approach using a binary predicate of `{ $0 &lt; $1 }` we can<br>&gt; use `{ $0 &lt; 3 }` to get the lower bound and then `!{ 3 &lt; $0 }` to get us to<br>&gt; equivalence (or in this case, to return `false`).<br>&gt;<br>&gt; Of course, an easy solution around this is to change the definition of the<br>&gt; unary predicate to return a triple of values less/equal/greater. However,<br>&gt; this would either require an additional datatype to the library (which I<br>&gt; don&#39;t think is appropriate) OR require the user to increase the complexity<br>&gt; of their predicate function to return -1/0/1. I don&#39;t think either of these<br>&gt; are ideal or necessarily better than the standard approach of a value and a<br>&gt; binary predicate.<br>&gt;<br>&gt; I really like the idea of the unary predicate approach, I just can&#39;t seem<br>&gt; to understand how it will work in practice. What am I missing here?<br>&gt; (hopefully not something completely obvious!)<br></p><p>This works; when I get some more time I might code it up for you, if<br>nobody has done it by then.<br></p><p>&gt; Thanks!<br>&gt; Jeff<br>&gt;<br>&gt; On Thu, Mar 24, 2016 at 4:52 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Tue Mar 15 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Mar 15, 2016, at 6:49 PM, Haravikk<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at haravikk.me<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at haravikk.me&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it<br>&gt;&gt; &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I already knew the impossibility of applying such a predicate as “$0<br>&gt;&gt; == 3” and I actually couldn’t quite figure out a solution.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I thought so, and I don’t think there is a way to do it, my point<br>&gt;&gt; &gt;&gt;&gt; was really just that your swift doc comments weren’t clear on that<br>&gt;&gt; &gt;&gt;&gt; point, then I went off at a bit of a tangent ;)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt; No problem! What I am trying to figure out here is how we should<br>&gt;&gt; &gt;&gt; implement the lowerBound and upperBound functions. Should they<br>&gt;&gt; &gt;&gt; exactly reflect their C++ counterparts?<br>&gt;&gt; &gt;&gt; Anyway, it seems all of our implementations have the same problem,<br>&gt;&gt; &gt;&gt; that they cannot be univocally called with any predicate whatsoever,<br>&gt;&gt; &gt;&gt; (or at least it seemed to me during some tests with the<br>&gt;&gt; &gt;&gt; implementations :) ), so I don’t really know how we should act. I am<br>&gt;&gt; &gt;&gt; a little blocked.<br>&gt;&gt; &gt;&gt; Does anyone have ideas on how that could work no matter what predicate<br>&gt;&gt; is given? Especially, an upperBound() function, which is a little trickier.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The key is to use a binary predicate (as used in sort and partition)<br>&gt;&gt; &gt; instead of a unary predicate. Then you can use the predicate as is for<br>&gt;&gt; &gt; lowerBound or with the arguments &quot;reversed&quot; for upperBound. The<br>&gt;&gt; &gt; methods would have a similar signature to indexOf—one that just takes<br>&gt;&gt; &gt; a value for comparable collections and one that takes a value and a<br>&gt;&gt; &gt; predicate.<br>&gt;&gt;<br>&gt;&gt; Having an overload that accepts a binary predicate is certainly a nice<br>&gt;&gt; convenience, but the most general formulation takes a unary predicate<br>&gt;&gt; that “partitions” the collection, i.e. returns false for the first N<br>&gt;&gt; elements of the collection and returns true for the rest.<br>&gt;&gt;<br>&gt;&gt; IMO it&#39;s important to expose the unary predicate version.  Lots of<br>&gt;&gt; times, the thing you want to compare against doesn&#39;t have the same type<br>&gt;&gt; as the elements of the collection.  For example, you might have a<br>&gt;&gt; collection of key-value pairs where you just want to compare against the<br>&gt;&gt; keys, and you may not even be able to create an instance of the whole<br>&gt;&gt; element.  For more on this, see<br>&gt;&gt; http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>March 29, 2016 at 06:00:00am</p></header><div class="content"><p>Dave,<br></p><p>I&#39;ve responded below, but just for the sake of being explicit, this is<br>roughly<br>the signature for lowerBound, upperBound, and binarySearch I have in<br>mind based on your comments of a unary predicate:<br></p><p>lowerBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>upperBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>binarySearch(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Bool<br></p><p>That&#39;s the general structure - the key is that the exact same predicate is<br>used in all signatures. The predicate would be defined along the lines of<br>a binary predicate where one of the parameters is fixed as the search value.<br>The unary predicate could be formed along the lines of:<br></p><p>let binaryPred = { $0 &lt; $1 }<br>let unnaryPred = binaryPred($0, value)<br></p><p>where value is the search value. The main point of illustrating that is that<br>once the unary predicate is defined, we can&#39;t change the position of the<br>search value within the predicate like they do in the C++ implementation.<br></p><p>Additional comments below..<br></p><p>Thanks for your input on this! It is greatly appreciated!<br>Jeff<br></p><p>On Mon, Mar 28, 2016 at 3:39 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Mar 25 2016, Jeff Hajewski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Dave,<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been giving this approach a lot of thought (and have read everything<br>&gt; &gt; I&#39;ve been able to find that you&#39;ve written on the matter several times)<br>&gt; and<br>&gt; &gt; am not convinced it will work. Implementing a lowerBound function is<br>&gt; &gt; trivial with a unary operator. However, implementing an upperBound or<br>&gt; &gt; binarySearch function is, at least in my mind, a bit more difficult.<br>&gt;<br>&gt; upperBound is just lowerBound with an inverted predicate.  You can prove<br>&gt; this to yourself by looking at the implementation of any C++ standard<br>&gt; library.<br>&gt;<br></p><p>I&#39;ve spent a decent amount of time looking at the implementation in C++, but<br>the caveat is that the operator is binary, and that is used in the<br>upperBound<br>implementation. For upperBound we need the position of the first element<br>that is strictly great than the partition point, and we can&#39;t get this by<br>simply<br>taking the complement of the unary predicate. In C++ they swap the order<br>of the parameters in the comp method to achieve this, but this isn&#39;t<br>possible<br>in the unary case or, if it is, no one I have spoken with (including the<br>four<br>of us discussing and working on this fix) can figure out how.<br></p><p>It occurs to me that this could be a communication issue. What I presume<br>you are suggesting is using a unary predicate such that the same predicate<br>is interchangeable amongst lowerBound, upperBound, and binarySearch.<br>Of course, if lowerBound and upperBound take different partition predicates<br>then the problem is trivial, but it also doesn&#39;t help you in implementing a<br>binary search.<br></p><p><br>&gt;<br>&gt; &gt; The reason is because with the unary predicate we only know if an<br>&gt; &gt; element is strictly less than the search value or greater than or<br>&gt; &gt; equal to the search value, whereas in the standard approach we can<br>&gt; &gt; determine strictly greater than as well as equivalence by swapping the<br>&gt; &gt; inputs to the comp function.<br>&gt; &gt;<br>&gt; &gt; For example, consider the set [2, 1, 5, 4]. If we want to search the set<br>&gt; &gt; using a unary predicate for 3, we would pass in the closure { $0 &lt; 3  }.<br>&gt; I<br>&gt; &gt; don&#39;t see how we can test for equivalence when all we know is &quot;&lt;&quot; or<br>&gt; &quot;&gt;=&quot;.<br>&gt; &gt; With the standard approach using a binary predicate of `{ $0 &lt; $1 }` we<br>&gt; can<br>&gt; &gt; use `{ $0 &lt; 3 }` to get the lower bound and then `!{ 3 &lt; $0 }` to get us<br>&gt; to<br>&gt; &gt; equivalence (or in this case, to return `false`).<br>&gt; &gt;<br>&gt; &gt; Of course, an easy solution around this is to change the definition of<br>&gt; the<br>&gt; &gt; unary predicate to return a triple of values less/equal/greater. However,<br>&gt; &gt; this would either require an additional datatype to the library (which I<br>&gt; &gt; don&#39;t think is appropriate) OR require the user to increase the<br>&gt; complexity<br>&gt; &gt; of their predicate function to return -1/0/1. I don&#39;t think either of<br>&gt; these<br>&gt; &gt; are ideal or necessarily better than the standard approach of a value<br>&gt; and a<br>&gt; &gt; binary predicate.<br>&gt; &gt;<br>&gt; &gt; I really like the idea of the unary predicate approach, I just can&#39;t seem<br>&gt; &gt; to understand how it will work in practice. What am I missing here?<br>&gt; &gt; (hopefully not something completely obvious!)<br>&gt;<br>&gt; This works; when I get some more time I might code it up for you, if<br>&gt; nobody has done it by then.<br>&gt;<br></p><p>Even just the logic for upperBound would be an immense help to us. As<br>I stated above, our issue is that the complement of the unary predicate<br>function gives us the equivalent of &quot;greater than or equal&quot;.<br></p><p><br>&gt;<br>&gt; &gt; Thanks!<br>&gt; &gt; Jeff<br>&gt; &gt;<br>&gt; &gt; On Thu, Mar 24, 2016 at 4:52 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Tue Mar 15 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; On Mar 15, 2016, at 6:49 PM, Haravikk<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at haravikk.me<br>&gt; &gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at haravikk.me&gt;&gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it<br>&gt; &gt;&gt; &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt;&gt; I already knew the impossibility of applying such a predicate as<br>&gt; “$0<br>&gt; &gt;&gt; == 3” and I actually couldn’t quite figure out a solution.<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; I thought so, and I don’t think there is a way to do it, my point<br>&gt; &gt;&gt; &gt;&gt;&gt; was really just that your swift doc comments weren’t clear on that<br>&gt; &gt;&gt; &gt;&gt;&gt; point, then I went off at a bit of a tangent ;)<br>&gt; &gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; No problem! What I am trying to figure out here is how we should<br>&gt; &gt;&gt; &gt;&gt; implement the lowerBound and upperBound functions. Should they<br>&gt; &gt;&gt; &gt;&gt; exactly reflect their C++ counterparts?<br>&gt; &gt;&gt; &gt;&gt; Anyway, it seems all of our implementations have the same problem,<br>&gt; &gt;&gt; &gt;&gt; that they cannot be univocally called with any predicate whatsoever,<br>&gt; &gt;&gt; &gt;&gt; (or at least it seemed to me during some tests with the<br>&gt; &gt;&gt; &gt;&gt; implementations :) ), so I don’t really know how we should act. I am<br>&gt; &gt;&gt; &gt;&gt; a little blocked.<br>&gt; &gt;&gt; &gt;&gt; Does anyone have ideas on how that could work no matter what<br>&gt; predicate<br>&gt; &gt;&gt; is given? Especially, an upperBound() function, which is a little<br>&gt; trickier.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; The key is to use a binary predicate (as used in sort and partition)<br>&gt; &gt;&gt; &gt; instead of a unary predicate. Then you can use the predicate as is for<br>&gt; &gt;&gt; &gt; lowerBound or with the arguments &quot;reversed&quot; for upperBound. The<br>&gt; &gt;&gt; &gt; methods would have a similar signature to indexOf—one that just takes<br>&gt; &gt;&gt; &gt; a value for comparable collections and one that takes a value and a<br>&gt; &gt;&gt; &gt; predicate.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Having an overload that accepts a binary predicate is certainly a nice<br>&gt; &gt;&gt; convenience, but the most general formulation takes a unary predicate<br>&gt; &gt;&gt; that “partitions” the collection, i.e. returns false for the first N<br>&gt; &gt;&gt; elements of the collection and returns true for the rest.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; IMO it&#39;s important to expose the unary predicate version.  Lots of<br>&gt; &gt;&gt; times, the thing you want to compare against doesn&#39;t have the same type<br>&gt; &gt;&gt; as the elements of the collection.  For example, you might have a<br>&gt; &gt;&gt; collection of key-value pairs where you just want to compare against the<br>&gt; &gt;&gt; keys, and you may not even be able to create an instance of the whole<br>&gt; &gt;&gt; element.  For more on this, see<br>&gt; &gt;&gt; http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/68cfdaad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Bringing up this topic because it became relevant with Brent Royal-Gordon&#39;s &quot;[Idea] Bringing the partial/total ordering distinction into Comparable &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15180&gt;&quot;.<br></p><p>If the `&lt;=&gt;` operator with a return type of a three-case `enum Order`, you can fully define the most generic versions of binary searches as:<br></p><p>    lowerBound(compare: Self.Collection.Element -&gt; Order) -&gt; Index<br></p><p>etc.<br></p><p>&gt; On 29 Mar 2016, at 13:43, Jeff Hajewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve responded below, but just for the sake of being explicit, this is roughly <br>&gt; the signature for lowerBound, upperBound, and binarySearch I have in <br>&gt; mind based on your comments of a unary predicate:<br>&gt; <br>&gt; lowerBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt; upperBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt; binarySearch(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Bool<br>&gt; <br>&gt; That&#39;s the general structure - the key is that the exact same predicate is<br>&gt; used in all signatures. The predicate would be defined along the lines of<br>&gt; a binary predicate where one of the parameters is fixed as the search value.<br>&gt; The unary predicate could be formed along the lines of:<br>&gt; <br>&gt; let binaryPred = { $0 &lt; $1 }<br>&gt; let unnaryPred = binaryPred($0, value)<br>&gt; <br>&gt; where value is the search value. The main point of illustrating that is that<br>&gt; once the unary predicate is defined, we can&#39;t change the position of the<br>&gt; search value within the predicate like they do in the C++ implementation.<br></p><p>You&#39;re right, there&#39;s no way a Bool-returning unary comparator could allow you to implement anything but lowerBound. With a three-value result, however, you&#39;ve got all you need.<br></p><p>I&#39;ve shamelessly plugged before but for the sake of proving a point, I&#39;ll do it once more: I think this little library we did works as a good starting point for a stdlib binary search API: https://github.com/knomi/Allsorts/blob/master/Allsorts/BinarySearch.swift &lt;https://github.com/knomi/Allsorts/blob/master/Allsorts/BinarySearch.swift&gt;<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/cfa59dd3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>April 28, 2016 at 08:00:00am</p></header><div class="content"><p>Thanks for bringing this back into the spotlight Pyry. A few of us have<br>been working on this issue here:<br></p><p>https://github.com/lorenzoracca/Swift-binary-search<br></p><p>However we have sort of stalled as we have been unable to come up with a<br>unary approach that Dave suggested using just Bool return values. And of<br>course, as you say, the three case order enum would make this a trivial<br>problem.<br></p><p>I guess the question is, do we move forward without a unary implementation<br>and update if/when we get a three case Order enum or do we wait on a three<br>case Order enum and implement a fully generic version once?<br></p><p> Jeff<br></p><p>On Thu, Apr 28, 2016 at 7:36 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p>&gt; Bringing up this topic because it became relevant with Brent<br>&gt; Royal-Gordon&#39;s &quot;[Idea] Bringing the partial/total ordering distinction<br>&gt; into Comparable<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15180&gt;&quot;.<br>&gt;<br>&gt; If the `&lt;=&gt;` operator with a return type of a three-case `*enum* Order`,<br>&gt; you can fully define the most generic versions of binary searches as:<br>&gt;<br>&gt;     lowerBound(compare: Self.Collection.Element -&gt; Order) -&gt; Index<br>&gt;<br>&gt; etc.<br>&gt;<br>&gt; On 29 Mar 2016, at 13:43, Jeff Hajewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve responded below, but just for the sake of being explicit, this is<br>&gt; roughly<br>&gt; the signature for lowerBound, upperBound, and binarySearch I have in<br>&gt; mind based on your comments of a unary predicate:<br>&gt;<br>&gt; lowerBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt; upperBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt; binarySearch(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Bool<br>&gt;<br>&gt; That&#39;s the general structure - the key is that the exact same predicate is<br>&gt; used in all signatures. The predicate would be defined along the lines of<br>&gt; a binary predicate where one of the parameters is fixed as the search<br>&gt; value.<br>&gt; The unary predicate could be formed along the lines of:<br>&gt;<br>&gt; let binaryPred = { $0 &lt; $1 }<br>&gt; let unnaryPred = binaryPred($0, value)<br>&gt;<br>&gt; where value is the search value. The main point of illustrating that is<br>&gt; that<br>&gt; once the unary predicate is defined, we can&#39;t change the position of the<br>&gt; search value within the predicate like they do in the C++ implementation.<br>&gt;<br>&gt;<br>&gt; You&#39;re right, there&#39;s no way a Bool-returning unary comparator could<br>&gt; allow you to implement anything but lowerBound. With a three-value result,<br>&gt; however, you&#39;ve got all you need.<br>&gt;<br>&gt; I&#39;ve shamelessly plugged before but for the sake of proving a point, I&#39;ll<br>&gt; do it once more: I think this little library we did works as a good<br>&gt; starting point for a stdlib binary search API:<br>&gt; https://github.com/knomi/Allsorts/blob/master/Allsorts/BinarySearch.swift<br>&gt;<br>&gt; — Pyry<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/dda083b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>Actually, the binary search proposal settled on a definition of a partition point method (and probably a partition method as well) that provides the real implementation details anyway, so these could go ahead as-is. You’re right that the search methods themselves may prefer to wait, since .sort() will likely change to reflect the new strict ordering operator, in which case it makes sense to delay those to be consistent, but partitioning should be unaffected.<br></p><p>&gt; On 28 Apr 2016, at 13:03, Jeff Hajewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for bringing this back into the spotlight Pyry. A few of us have been working on this issue here:<br>&gt; <br>&gt; https://github.com/lorenzoracca/Swift-binary-search &lt;https://github.com/lorenzoracca/Swift-binary-search&gt;<br>&gt; <br>&gt; However we have sort of stalled as we have been unable to come up with a unary approach that Dave suggested using just Bool return values. And of course, as you say, the three case order enum would make this a trivial problem.<br>&gt; <br>&gt; I guess the question is, do we move forward without a unary implementation and update if/when we get a three case Order enum or do we wait on a three case Order enum and implement a fully generic version once?<br>&gt; <br>&gt;  Jeff<br>&gt; <br>&gt; On Thu, Apr 28, 2016 at 7:36 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi &lt;mailto:pyry.jahkola at iki.fi&gt;&gt; wrote:<br>&gt; Bringing up this topic because it became relevant with Brent Royal-Gordon&#39;s &quot;[Idea] Bringing the partial/total ordering distinction into Comparable &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15180&gt;&quot;.<br>&gt; <br>&gt; If the `&lt;=&gt;` operator with a return type of a three-case `enum Order`, you can fully define the most generic versions of binary searches as:<br>&gt; <br>&gt;     lowerBound(compare: Self.Collection.Element -&gt; Order) -&gt; Index<br>&gt; <br>&gt; etc.<br>&gt; <br>&gt;&gt; On 29 Mar 2016, at 13:43, Jeff Hajewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve responded below, but just for the sake of being explicit, this is roughly <br>&gt;&gt; the signature for lowerBound, upperBound, and binarySearch I have in <br>&gt;&gt; mind based on your comments of a unary predicate:<br>&gt;&gt; <br>&gt;&gt; lowerBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt;&gt; upperBound(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Index<br>&gt;&gt; binarySearch(isOrderedBelow: Self.Collection.Element -&gt; Bool) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; That&#39;s the general structure - the key is that the exact same predicate is<br>&gt;&gt; used in all signatures. The predicate would be defined along the lines of<br>&gt;&gt; a binary predicate where one of the parameters is fixed as the search value.<br>&gt;&gt; The unary predicate could be formed along the lines of:<br>&gt;&gt; <br>&gt;&gt; let binaryPred = { $0 &lt; $1 }<br>&gt;&gt; let unnaryPred = binaryPred($0, value)<br>&gt;&gt; <br>&gt;&gt; where value is the search value. The main point of illustrating that is that<br>&gt;&gt; once the unary predicate is defined, we can&#39;t change the position of the<br>&gt;&gt; search value within the predicate like they do in the C++ implementation.<br>&gt; <br>&gt; You&#39;re right, there&#39;s no way a Bool-returning unary comparator could allow you to implement anything but lowerBound. With a three-value result, however, you&#39;ve got all you need.<br>&gt; <br>&gt; I&#39;ve shamelessly plugged before but for the sake of proving a point, I&#39;ll do it once more: I think this little library we did works as a good starting point for a stdlib binary search API: https://github.com/knomi/Allsorts/blob/master/Allsorts/BinarySearch.swift &lt;https://github.com/knomi/Allsorts/blob/master/Allsorts/BinarySearch.swift&gt;<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/7032a37a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
