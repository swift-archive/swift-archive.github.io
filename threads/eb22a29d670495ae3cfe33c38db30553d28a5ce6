<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1d54deb32312ab6a282cde8637bc7077?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>James Lee</string> &lt;james at jelee.co.uk&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Been playing around with NSAttributedString and cannot decide on the best way to implement the (attributesAtIndex: effectiveRange) and other methods with similar functionality.<br></p><p>In the ObjC world I would expect an empty NSDictionary even in cases where the location is greater than the length of the string.<br></p><p>In the swift world, I am of the leaning that the functions should return optionals and in the aforementioned scenario &#39;nil&#39; would be returned.<br></p><p>Wanted to get other people&#39;s thoughts on this.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  8, 2015 at 06:00:00am</p></header><div class="content"><p>&gt; Been playing around with NSAttributedString and cannot decide on the best way to implement the (attributesAtIndex: effectiveRange) and other methods with similar functionality.<br>&gt; <br>&gt; In the ObjC world I would expect an empty NSDictionary even in cases where the location is greater than the length of the string.<br></p><p>Personally, if I indexed past the end of an attributed string, I would expect a precondition to fail and (since Swift can&#39;t catch assertion failures) my app to crash. (And from what I can tell, the Apple Foundation versions of these APIs do not return an optional.)<br></p><p>(Sorry about the duplicate, James—didn’t hit Reply All when I should have.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1d54deb32312ab6a282cde8637bc7077?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>James Lee</string> &lt;james at jelee.co.uk&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Personally, if I indexed past the end of an attributed string, I would expect a precondition to fail and (since Swift can&#39;t catch assertion failures) my app to crash. (And from what I can tell, the Apple Foundation versions of these APIs do not return an optional.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>It is worth noting that the current OSX documentation does raise an NSRangeException in the case discussed above. With the throw capabilities in Swift 2 this makes sense.<br></p><p>As you have said, it seems a lot of Foundation API&#39;s do not return Optionals. I feel this a hangover from ObjC where an empty object (in this case an NSDictionary) would be returned. To me this is what Optionals are there to replace.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December  8, 2015 at 07:00:00am</p></header><div class="content"><p>NSException != throw in swift…<br>NSExceptions should be treated as assert, fatalError, or precondition (precondition in this case is probably preferred)<br></p><p><br>&gt; On Dec 8, 2015, at 7:31 AM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Personally, if I indexed past the end of an attributed string, I would expect a precondition to fail and (since Swift can&#39;t catch assertion failures) my app to crash. (And from what I can tell, the Apple Foundation versions of these APIs do not return an optional.)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; It is worth noting that the current OSX documentation does raise an NSRangeException in the case discussed above. With the throw capabilities in Swift 2 this makes sense.<br>&gt; <br>&gt; As you have said, it seems a lot of Foundation API&#39;s do not return Optionals. I feel this a hangover from ObjC where an empty object (in this case an NSDictionary) would be returned. To me this is what Optionals are there to replace. <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>I agree that precondition is appropriate here. Swift has Optionals and<br>throws, yes, but Swift also uses preconditions to do things like range<br>checks on subscripting. I believe the general rule is that if something<br>is a programmer error, it should be a hard failure (i.e. a<br>precondition/assert/fatalError), and throws should only be used for<br>&quot;soft&quot; errors. So subscripting past the end of a collection is a<br>programmer error, but e.g. trying to decode a non-JSON string as JSON<br>with NSJSONSerialization is a &quot;soft&quot; error.<br></p><p>Also, as an aside, when an API returns a type that already has a notion<br>of an empty value (e.g. a Dictionary has [:]), then you should only wrap<br>it in an Optional if there&#39;s a specific reason to differentiate between<br>an empty value and no value at all. In the case of attributesAtIndex,<br>I&#39;d expect it to return a non-optional Dictionary, because every valid<br>index does have a notion of attributes, even if the attribute set is<br>empty at that location. And passing an invalid index is a programmer<br>error and should use precondition.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 8, 2015, at 07:59 AM, Philippe Hausler via<br>swift-corelibs-dev wrote:<br>&gt; NSException != throw in swift…<br>&gt; NSExceptions should be treated as assert, fatalError, or precondition<br>&gt; (precondition in this case is probably preferred)<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 8, 2015, at 7:31 AM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Personally, if I indexed past the end of an attributed string, I would expect a precondition to fail and (since Swift can&#39;t catch assertion failures) my app to crash. (And from what I can tell, the Apple Foundation versions of these APIs do not return an optional.)<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; -- <br>&gt; &gt;&gt; Brent Royal-Gordon<br>&gt; &gt;&gt; Architechies<br>&gt; &gt;&gt; <br>&gt; &gt; <br>&gt; &gt; It is worth noting that the current OSX documentation does raise an NSRangeException in the case discussed above. With the throw capabilities in Swift 2 this makes sense.<br>&gt; &gt; <br>&gt; &gt; As you have said, it seems a lot of Foundation API&#39;s do not return Optionals. I feel this a hangover from ObjC where an empty object (in this case an NSDictionary) would be returned. To me this is what Optionals are there to replace. <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-corelibs-dev mailing list<br>&gt; &gt; swift-corelibs-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dfccbb938d651c6b84973a3ebfc7ef84?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>Ross Kimes</string> &lt;ross.kimes at me.com&gt;<p>December  8, 2015 at 05:00:00pm</p></header><div class="content"><p>This may be better for the swift-evolution list, but I really do not like the fact that subscripting is a &quot;hard&quot; error. I think the language should have as little hard errors as possible to improve on how much the compiler can check for you. It seems like a holdover from C to me. Having those be crashing errors makes it difficult to scan for code that is handling errors poorly (you can&#39;t just look for try! or !). There is nothing that looks like it could be dangerous in subscripting.<br></p><p>I would much prefer these types of things throw errors. Since straight subscripting also seems like a last resort in other parts of the language, having an &#39;throws&#39; version would encourage usage of APIs that don&#39;t involve straight subscripting.<br></p><p>So in this particular case I would prefer retuning a non-optional dictionary (because empty dictionaries are a valid set of attributes) and throw an error for going out of bounds.<br></p><p>(Sorry for the double email Kevin. Forgot to switch the recipient before replying.)<br></p><p>Ross<br></p><p>&gt; On Dec 8, 2015, at 2:05 PM, Kevin Ballard via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that precondition is appropriate here. Swift has Optionals and<br>&gt; throws, yes, but Swift also uses preconditions to do things like range<br>&gt; checks on subscripting. I believe the general rule is that if something<br>&gt; is a programmer error, it should be a hard failure (i.e. a<br>&gt; precondition/assert/fatalError), and throws should only be used for<br>&gt; &quot;soft&quot; errors. So subscripting past the end of a collection is a<br>&gt; programmer error, but e.g. trying to decode a non-JSON string as JSON<br>&gt; with NSJSONSerialization is a &quot;soft&quot; error.<br>&gt; <br>&gt; Also, as an aside, when an API returns a type that already has a notion<br>&gt; of an empty value (e.g. a Dictionary has [:]), then you should only wrap<br>&gt; it in an Optional if there&#39;s a specific reason to differentiate between<br>&gt; an empty value and no value at all. In the case of attributesAtIndex,<br>&gt; I&#39;d expect it to return a non-optional Dictionary, because every valid<br>&gt; index does have a notion of attributes, even if the attribute set is<br>&gt; empty at that location. And passing an invalid index is a programmer<br>&gt; error and should use precondition.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Dec 8, 2015, at 07:59 AM, Philippe Hausler via<br>&gt; swift-corelibs-dev wrote:<br>&gt;&gt; NSException != throw in swift…<br>&gt;&gt; NSExceptions should be treated as assert, fatalError, or precondition<br>&gt;&gt; (precondition in this case is probably preferred)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 7:31 AM, James Lee via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally, if I indexed past the end of an attributed string, I would expect a precondition to fail and (since Swift can&#39;t catch assertion failures) my app to crash. (And from what I can tell, the Apple Foundation versions of these APIs do not return an optional.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is worth noting that the current OSX documentation does raise an NSRangeException in the case discussed above. With the throw capabilities in Swift 2 this makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you have said, it seems a lot of Foundation API&#39;s do not return Optionals. I feel this a hangover from ObjC where an empty object (in this case an NSDictionary) would be returned. To me this is what Optionals are there to replace. <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>NSAttributedString attributesAtIndex return an optional.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; This may be better for the swift-evolution list, but I really do not like the fact that subscripting is a &quot;hard&quot; error. I think the language should have as little hard errors as possible to improve on how much the compiler can check for you.<br></p><p>I think the idea is that, if you’re subscripting incorrectly, chances are you didn’t anticipate the possibility that your subscript might fail and probably didn’t write code that’s prepared to handle that error. If you did anticipate that possibility, you would have made sure there was a range check in the first place.<br></p><p>Ultimately, since Swift.org Foundation is meant to present the same interface as Apple Foundation, I don’t think we have much of a choice about this anyway. Apple Foundation’s version of this method is non-optional and non-throwing. If we deviate from that, we lose compatibility.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
