<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br></p><p>Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure ‚Äúshould&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br></p><p>The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which doesn‚Äôt make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;‚Äù.<br></p><p>These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br></p><p>----8&lt;----<br></p><p>The specific revision requested by the core team to SE-0111 is that all ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For example, this would not be allowed:<br></p><p>   var op : (lhs : Int, rhs : Int) -&gt; Int<br></p><p>instead, it should be spelled as:<br></p><p>   var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br></p><p>With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.  <br></p><p>----8&lt;----<br></p><p>Here is a sketch of how that would work, in two steps:<br></p><p><br>First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br></p><p>   var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>   x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br></p><p>   // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>   func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>     x = op(lhs: 1, rhs: 2)     // use of the parameter<br>   }<br>   foo(opToUse: +)             // call of the function<br></p><p>This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br></p><p><br>Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br></p><p>   var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>   x = op(lhs: 1, rhs: 2)                  // Same as above<br></p><p>   // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>   func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>     x = op(lhs: 1, rhs: 2)     // Same as above.<br>   }<br>   foo(opToUse: +)              // Same as above.<br></p><p><br>These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br></p><p>-Chris &amp; the Core Team<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160713/0c1a72fc/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 14, 2016 at 08:00:00am</p></header><div class="content"><p>üëè<br></p><p>&gt; On 14 Jul 2016, at 06:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure ‚Äúshould&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br>&gt; <br>&gt; The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which doesn‚Äôt make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;‚Äù.<br>&gt; <br>&gt; These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; The specific revision requested by the core team to SE-0111 is that all ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For example, this would not be allowed:<br>&gt; <br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt; <br>&gt; instead, it should be spelled as:<br>&gt; <br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt; <br>&gt; With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.  <br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt; <br>&gt; <br>&gt; First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br>&gt; <br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt; <br>&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br>&gt; <br>&gt; <br>&gt; Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br>&gt; <br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt; <br>&gt; <br>&gt; These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br>&gt; <br>&gt; -Chris &amp; the Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/e77a8f6b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 14, 2016 at 10:00:00am</p></header><div class="content"><p>Great!<br></p><p>This cleanly separates between the type and the name/signature! Simple and consistent. Thank you!<br></p><p>A clarification question: do i understand correctly that steps 2 and 3 will not be included in Swift 3 due time constraints?<br></p><p>‚Äî T<br></p><p><br>&gt; On 14 Jul 2016, at 06:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure ‚Äúshould&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br>&gt; <br>&gt; The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which doesn‚Äôt make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;‚Äù.<br>&gt; <br>&gt; These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; The specific revision requested by the core team to SE-0111 is that all ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For example, this would not be allowed:<br>&gt; <br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt; <br>&gt; instead, it should be spelled as:<br>&gt; <br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt; <br>&gt; With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.  <br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt; <br>&gt; <br>&gt; First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br>&gt; <br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt; <br>&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br>&gt; <br>&gt; <br>&gt; Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br>&gt; <br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt; <br>&gt; <br>&gt; These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br>&gt; <br>&gt; -Chris &amp; the Core Team<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/f5920834/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 1:20 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; Great!<br>&gt; <br>&gt; This cleanly separates between the type and the name/signature! Simple and consistent. Thank you!<br>&gt; <br>&gt; A clarification question: do i understand correctly that steps 2 and 3 will not be included in Swift 3 due time constraints?<br></p><p>Yes, we are sadly really almost out of time for Swift 3 and need to remain as hyper-focused as possible.  There is always another release.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 1:20 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Great!<br>&gt;&gt; <br>&gt;&gt; This cleanly separates between the type and the name/signature! Simple and consistent. Thank you!<br>&gt;&gt; <br>&gt;&gt; A clarification question: do i understand correctly that steps 2 and 3 will not be included in Swift 3 due time constraints?<br>&gt; <br>&gt; Yes, we are sadly really almost out of time for Swift 3 and need to remain as hyper-focused as possible.  There is always another release.<br>&gt; <br>&gt; -Chris<br></p><p>I was under the impression that Swift 2.3 was going to go gold in September for App Store submissions and Swift 3 in December. Is my timeline wrong?<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 9:27 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 1:20 AM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This cleanly separates between the type and the name/signature! Simple and consistent. Thank you!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A clarification question: do i understand correctly that steps 2 and 3 will not be included in Swift 3 due time constraints?<br>&gt;&gt; <br>&gt;&gt; Yes, we are sadly really almost out of time for Swift 3 and need to remain as hyper-focused as possible.  There is always another release.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; I was under the impression that Swift 2.3 was going to go gold in September for App Store submissions and Swift 3 in December. Is my timeline wrong?<br></p><p>Both Swift 2.3 and Swift 3 will GM along with Xcode 8 and iOS 10, whenever that ends up being.  Did I say something to contradict that?  I don‚Äôt know what Swift 2.3 has to do with this thread.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Just +100. One more wise decision from the core team. Thank you for all of <br>your work.<br></p><p>On 14.07.2016 7:47, Chris Lattner via swift-evolution wrote:<br>&gt; Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed<br>&gt; the proposal and started a discussion about how it appears to be a<br>&gt; regression for closure parameters (e.g. callbacks) that could formerly<br>&gt; carry labels, but are now not allowed to.  These folks observed that it<br>&gt; would be more expressive (and consistent with the rest of Swift) to allow<br>&gt; parameter labels in function types, because the invocation site of a<br>&gt; closure ‚Äúshould&quot; be required to provide those labels.  The core team has<br>&gt; been following the discussion, agrees that this is a concern, and wants to<br>&gt; update the community with a path forward.<br>&gt;<br>&gt; The reality of the situation is that the current implementation of<br>&gt; parameter labels in function types is inherently broken.  Specifically, as<br>&gt; one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to<br>&gt; ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int)<br>&gt; -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently<br>&gt; allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which<br>&gt; doesn‚Äôt make sense, introduces surprising behavior, introduces complexity<br>&gt; into the compiler implementation, and is generally a problem.  We do have<br>&gt; one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt;<br>&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific<br>&gt; cases.  There are other more complex cases as well, e.g. when using<br>&gt; generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b :<br>&gt; Int)-&gt;Int&gt;‚Äù.<br>&gt;<br>&gt; These problems are what initially motivated SE-0111.  However, given the<br>&gt; feedback, the core team went back to the drawing board to determine<br>&gt; whether: a) SE-0111 by itself is the right long term answer, b) whether<br>&gt; there were alternate models that could solve the same problems in a<br>&gt; different way, or c) whether SE-0111 was the right first step to &quot;ultimate<br>&gt; glory&quot; in the field of closure parameter labels.  After a long discussion,<br>&gt; and many alternatives considered, the core team believes in c), that<br>&gt; SE-0111 (with a minor modification) is the right step for Swift 3, because<br>&gt; it paves the way for the right model over the long term.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; The specific revision requested by the core team to SE-0111 is that all<br>&gt; ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For<br>&gt; example, this would not be allowed:<br>&gt;<br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt;<br>&gt; instead, it should be spelled as:<br>&gt;<br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt;<br>&gt; With this change, we believe that we have paved the way for a purely<br>&gt; additive proposal (and thus, post-Swift 3) that will restore the expressive<br>&gt; capability of closures with parameter labels.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt;<br>&gt;<br>&gt; First, we extend declaration names for variables, properties, and<br>&gt; parameters to allow *parameter names* as part of their declaration name.<br>&gt;  For example:<br>&gt;<br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt;<br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt;<br>&gt; This will restore the ability to express the idea of a closure parameter<br>&gt; that carries labels as part of its declaration, without requiring parameter<br>&gt; labels to be part of the type system (allowing, e.g. the operator + to be<br>&gt; passed into something that requires parameter labels).<br>&gt;<br>&gt;<br>&gt; Second, extend the rules for function types to allow parameter API labels<br>&gt; *if and only if* they are used as the type of a declaration that allows<br>&gt; parameter labels, and interpret them as a sugar form for providing those<br>&gt; labels on the underlying declaration.  This means that the example above<br>&gt; could be spelled as:<br>&gt;<br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt;<br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt;<br>&gt;<br>&gt; These two steps will provide the simple and expressive design approach that<br>&gt; we have now, without all of the problems that representing parameter labels<br>&gt; in the type system introduces.  The core team believes that the temporary<br>&gt; regression in expressiveness is an acceptable loss for Swift 3,<br>&gt; particularly given that this will have no impact on Cocoa or the standard<br>&gt; library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have<br>&gt; parameter labels on their corresponding concepts (Blocks and C function<br>&gt; pointers), and the higher order functions in the standard library should<br>&gt; not require parameter labels either.<br>&gt;<br>&gt; -Chris &amp; the Core Team<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 14.07.2016 um 16:46 schrieb Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Just +100. One more wise decision from the core team. Thank you for all of your work.<br></p><p>Indeed! Thank you!<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt;&gt; On 14.07.2016 7:47, Chris Lattner via swift-evolution wrote:<br>&gt;&gt; Proposal:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; <br>&gt;&gt; Shortly after SE-0111 was accepted last week, several people newly noticed<br>&gt;&gt; the proposal and started a discussion about how it appears to be a<br>&gt;&gt; regression for closure parameters (e.g. callbacks) that could formerly<br>&gt;&gt; carry labels, but are now not allowed to.  These folks observed that it<br>&gt;&gt; would be more expressive (and consistent with the rest of Swift) to allow<br>&gt;&gt; parameter labels in function types, because the invocation site of a<br>&gt;&gt; closure ‚Äúshould&quot; be required to provide those labels.  The core team has<br>&gt;&gt; been following the discussion, agrees that this is a concern, and wants to<br>&gt;&gt; update the community with a path forward.<br>&gt;&gt; <br>&gt;&gt; The reality of the situation is that the current implementation of<br>&gt;&gt; parameter labels in function types is inherently broken.  Specifically, as<br>&gt;&gt; one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to<br>&gt;&gt; ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int)<br>&gt;&gt; -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently<br>&gt;&gt; allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which<br>&gt;&gt; doesn‚Äôt make sense, introduces surprising behavior, introduces complexity<br>&gt;&gt; into the compiler implementation, and is generally a problem.  We do have<br>&gt;&gt; one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt;<br>&gt;&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific<br>&gt;&gt; cases.  There are other more complex cases as well, e.g. when using<br>&gt;&gt; generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b :<br>&gt;&gt; Int)-&gt;Int&gt;‚Äù.<br>&gt;&gt; <br>&gt;&gt; These problems are what initially motivated SE-0111.  However, given the<br>&gt;&gt; feedback, the core team went back to the drawing board to determine<br>&gt;&gt; whether: a) SE-0111 by itself is the right long term answer, b) whether<br>&gt;&gt; there were alternate models that could solve the same problems in a<br>&gt;&gt; different way, or c) whether SE-0111 was the right first step to &quot;ultimate<br>&gt;&gt; glory&quot; in the field of closure parameter labels.  After a long discussion,<br>&gt;&gt; and many alternatives considered, the core team believes in c), that<br>&gt;&gt; SE-0111 (with a minor modification) is the right step for Swift 3, because<br>&gt;&gt; it paves the way for the right model over the long term.<br>&gt;&gt; <br>&gt;&gt; ----8&lt;----<br>&gt;&gt; <br>&gt;&gt; The specific revision requested by the core team to SE-0111 is that all<br>&gt;&gt; ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For<br>&gt;&gt; example, this would not be allowed:<br>&gt;&gt; <br>&gt;&gt;   var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; instead, it should be spelled as:<br>&gt;&gt; <br>&gt;&gt;   var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; With this change, we believe that we have paved the way for a purely<br>&gt;&gt; additive proposal (and thus, post-Swift 3) that will restore the expressive<br>&gt;&gt; capability of closures with parameter labels.<br>&gt;&gt; <br>&gt;&gt; ----8&lt;----<br>&gt;&gt; <br>&gt;&gt; Here is a sketch of how that would work, in two steps:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; First, we extend declaration names for variables, properties, and<br>&gt;&gt; parameters to allow *parameter names* as part of their declaration name.<br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt;   var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;&gt;   x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt;&gt; <br>&gt;&gt;   // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;&gt;   func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;&gt;     x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;&gt;   }<br>&gt;&gt;   foo(opToUse: +)             // call of the function<br>&gt;&gt; <br>&gt;&gt; This will restore the ability to express the idea of a closure parameter<br>&gt;&gt; that carries labels as part of its declaration, without requiring parameter<br>&gt;&gt; labels to be part of the type system (allowing, e.g. the operator + to be<br>&gt;&gt; passed into something that requires parameter labels).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Second, extend the rules for function types to allow parameter API labels<br>&gt;&gt; *if and only if* they are used as the type of a declaration that allows<br>&gt;&gt; parameter labels, and interpret them as a sugar form for providing those<br>&gt;&gt; labels on the underlying declaration.  This means that the example above<br>&gt;&gt; could be spelled as:<br>&gt;&gt; <br>&gt;&gt;   var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;&gt;   x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt;&gt; <br>&gt;&gt;   // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;&gt;   func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;&gt;     x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;&gt;   }<br>&gt;&gt;   foo(opToUse: +)              // Same as above.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These two steps will provide the simple and expressive design approach that<br>&gt;&gt; we have now, without all of the problems that representing parameter labels<br>&gt;&gt; in the type system introduces.  The core team believes that the temporary<br>&gt;&gt; regression in expressiveness is an acceptable loss for Swift 3,<br>&gt;&gt; particularly given that this will have no impact on Cocoa or the standard<br>&gt;&gt; library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have<br>&gt;&gt; parameter labels on their corresponding concepts (Blocks and C function<br>&gt;&gt; pointers), and the higher order functions in the standard library should<br>&gt;&gt; not require parameter labels either.<br>&gt;&gt; <br>&gt;&gt; -Chris &amp; the Core Team<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 14 Jul 2016, at 05:47, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed the proposal and started a discussion about how it appears to be a regression for closure parameters (e.g. callbacks) that could formerly carry labels, but are now not allowed to.  These folks observed that it would be more expressive (and consistent with the rest of Swift) to allow parameter labels in function types, because the invocation site of a closure ‚Äúshould&quot; be required to provide those labels.  The core team has been following the discussion, agrees that this is a concern, and wants to update the community with a path forward.<br>&gt; <br>&gt; The reality of the situation is that the current implementation of parameter labels in function types is inherently broken.  Specifically, as one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to ‚Äú(Int) -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int‚Äù to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently allows converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which doesn‚Äôt make sense, introduces surprising behavior, introduces complexity into the compiler implementation, and is generally a problem.  We do have one specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt; Void‚Äù to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific cases.  There are other more complex cases as well, e.g. when using generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b : Int)-&gt;Int&gt;‚Äù.<br>&gt; <br>&gt; These problems are what initially motivated SE-0111.  However, given the feedback, the core team went back to the drawing board to determine whether: a) SE-0111 by itself is the right long term answer, b) whether there were alternate models that could solve the same problems in a different way, or c) whether SE-0111 was the right first step to &quot;ultimate glory&quot; in the field of closure parameter labels.  After a long discussion, and many alternatives considered, the core team believes in c), that SE-0111 (with a minor modification) is the right step for Swift 3, because it paves the way for the right model over the long term.<br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; The specific revision requested by the core team to SE-0111 is that all ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For example, this would not be allowed:<br>&gt; <br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt; <br>&gt; instead, it should be spelled as:<br>&gt; <br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt; <br>&gt; With this change, we believe that we have paved the way for a purely additive proposal (and thus, post-Swift 3) that will restore the expressive capability of closures with parameter labels.  <br>&gt; <br>&gt; ----8&lt;----<br>&gt; <br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt; <br>&gt; <br>&gt; First, we extend declaration names for variables, properties, and parameters to allow *parameter names* as part of their declaration name.  For example:<br>&gt; <br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt; <br>&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br></p><p>During the review, Michael Ilseman suggested using SE-0021 for declaration names.<br></p><p>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22488/focus=22580&gt;<br></p><p>Your example &quot;op(lhs:,rhs:)&quot; would be &quot;op(lhs:rhs:)&quot; instead (i.e. without the comma).<br></p><p>-- Ben<br></p><p>&gt; Second, extend the rules for function types to allow parameter API labels *if and only if* they are used as the type of a declaration that allows parameter labels, and interpret them as a sugar form for providing those labels on the underlying declaration.  This means that the example above could be spelled as:<br>&gt; <br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt; <br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt; <br>&gt; <br>&gt; These two steps will provide the simple and expressive design approach that we have now, without all of the problems that representing parameter labels in the type system introduces.  The core team believes that the temporary regression in expressiveness is an acceptable loss for Swift 3, particularly given that this will have no impact on Cocoa or the standard library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have parameter labels on their corresponding concepts (Blocks and C function pointers), and the higher order functions in the standard library should not require parameter labels either.<br>&gt; <br>&gt; -Chris &amp; the Core Team<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/db7f304f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Update + Commentary] SE-0111: Remove type system significance of function argument labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jul 14, 2016, at 9:33 AM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This will restore the ability to express the idea of a closure parameter that carries labels as part of its declaration, without requiring parameter labels to be part of the type system (allowing, e.g. the operator + to be passed into something that requires parameter labels).<br>&gt; <br>&gt; During the review, Michael Ilseman suggested using SE-0021 for declaration names.<br>&gt; <br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22488/focus=22580 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22488/focus=22580&gt;&gt;<br>&gt; <br>&gt; Your example &quot;op(lhs:,rhs:)&quot; would be &quot;op(lhs:rhs:)&quot; instead (i.e. without the comma).<br></p><p>Ok, sure.  I just trying to outline what the proposal would look like,<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/f7f9370f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/175ad9e0827a836bfb3d1d06fe3182ec?s=50"></div><header><strong>[Accepted] SE-0111: Remove type system significance of function argument labels</strong> from <string>Diego S√°nchez</string> &lt;diego.sanchezr at gmail.com&gt;<p>July 15, 2016 at 01:00:00am</p></header><div class="content"><p>This is great news! Thank you!!<br></p><p>On Thursday, 14 July 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;<br>&gt; Shortly after SE-0111 was accepted last week, several people newly noticed<br>&gt; the proposal and started a discussion about how it appears to be a<br>&gt; regression for closure parameters (e.g. callbacks) that could formerly<br>&gt; carry labels, but are now not allowed to.  These folks observed that it<br>&gt; would be more expressive (and consistent with the rest of Swift) to allow<br>&gt; parameter labels in function types, because the invocation site of a<br>&gt; closure ‚Äúshould&quot; be required to provide those labels.  The core team has<br>&gt; been following the discussion, agrees that this is a concern, and wants to<br>&gt; update the community with a path forward.<br>&gt;<br>&gt; The reality of the situation is that the current implementation of<br>&gt; parameter labels in function types is inherently broken.  Specifically, as<br>&gt; one example, there is an implicit conversion from &quot;(a: Int) -&gt; Int‚Äù to ‚Äú(Int)<br>&gt; -&gt; Int‚Äù.  However, there is also an implicit conversion from &quot;(Int) -&gt; Int‚Äù<br>&gt; to ‚Äú(b : Int) -&gt; Int‚Äù.  This means that the compiler currently allows<br>&gt; converting from ‚Äú(a: Int) -&gt; Int‚Äù to ‚Äú(b: Int) -&gt; Int‚Äù, which doesn‚Äôt<br>&gt; make sense, introduces surprising behavior, introduces complexity into the<br>&gt; compiler implementation, and is generally a problem.  We do have one<br>&gt; specific hack to prevent conversion of (e.g.) ‚Äú(a : Int, b : Int) -&gt; Void‚Äù<br>&gt; to ‚Äú(b : Int, a : Int) -&gt; Void‚Äù, but this only triggers in specific<br>&gt; cases.  There are other more complex cases as well, e.g. when using<br>&gt; generics &quot;T&lt;(a : Int)-&gt;Int&gt;‚Äù cannot be considered compatible with &quot;T&lt;(b :<br>&gt; Int)-&gt;Int&gt;‚Äù.<br>&gt;<br>&gt; These problems are what initially motivated SE-0111.  However, given the<br>&gt; feedback, the core team went back to the drawing board to determine<br>&gt; whether: a) SE-0111 by itself is the right long term answer, b) whether<br>&gt; there were alternate models that could solve the same problems in a<br>&gt; different way, or c) whether SE-0111 was the right first step to &quot;ultimate<br>&gt; glory&quot; in the field of closure parameter labels.  After a long discussion,<br>&gt; and many alternatives considered, the core team believes in c), that<br>&gt; SE-0111 (with a minor modification) is the right step for Swift 3, because<br>&gt; it paves the way for the right model over the long term.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; The specific revision requested by the core team to SE-0111 is that all<br>&gt; ‚Äúcosmetic‚Äù labels should be required to include an API name of _.  For<br>&gt; example, this would not be allowed:<br>&gt;<br>&gt;    var op : (lhs : Int, rhs : Int) -&gt; Int<br>&gt;<br>&gt; instead, it should be spelled as:<br>&gt;<br>&gt;    var op : (_ lhs : Int, _ rhs : Int) -&gt; Int<br>&gt;<br>&gt; With this change, we believe that we have paved the way for a purely<br>&gt; additive proposal (and thus, post-Swift 3) that will restore the expressive<br>&gt; capability of closures with parameter labels.<br>&gt;<br>&gt; ----8&lt;----<br>&gt;<br>&gt; Here is a sketch of how that would work, in two steps:<br>&gt;<br>&gt;<br>&gt; First, we extend declaration names for variables, properties, and<br>&gt; parameters to allow *parameter names* as part of their declaration name.<br>&gt; For example:<br>&gt;<br>&gt;    var op(lhs:,rhs:) : (Int, Int) -&gt; Int    // variable or property.<br>&gt;    x = op(lhs: 1, rhs: 2)       // use of the variable or property.<br>&gt;<br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse  op(lhs:,rhs:) : (Int, Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // use of the parameter<br>&gt;    }<br>&gt;    foo(opToUse: +)             // call of the function<br>&gt;<br>&gt; This will restore the ability to express the idea of a closure parameter<br>&gt; that carries labels as part of its declaration, without requiring parameter<br>&gt; labels to be part of the type system (allowing, e.g. the operator + to be<br>&gt; passed into something that requires parameter labels).<br>&gt;<br>&gt;<br>&gt; Second, extend the rules for function types to allow parameter API labels<br>&gt; *if and only if* they are used as the type of a declaration that allows<br>&gt; parameter labels, and interpret them as a sugar form for providing those<br>&gt; labels on the underlying declaration.  This means that the example above<br>&gt; could be spelled as:<br>&gt;<br>&gt;    var op : (lhs: Int, rhs: Int) -&gt; Int    // Nice declaration syntax<br>&gt;    x = op(lhs: 1, rhs: 2)                  // Same as above<br>&gt;<br>&gt;    // API name of parameter is ‚ÄúopToUse‚Äù, internal name is &quot;op(lhs:,rhs:)‚Äù.<br>&gt;    func foo(opToUse op : (lhs: Int, rhs: Int) -&gt; Int) {<br>&gt;      x = op(lhs: 1, rhs: 2)     // Same as above.<br>&gt;    }<br>&gt;    foo(opToUse: +)              // Same as above.<br>&gt;<br>&gt;<br>&gt; These two steps will provide the simple and expressive design approach<br>&gt; that we have now, without all of the problems that representing parameter<br>&gt; labels in the type system introduces.  The core team believes that the<br>&gt; temporary regression in expressiveness is an acceptable loss for Swift 3,<br>&gt; particularly given that this will have no impact on Cocoa or the standard<br>&gt; library.  In the case of Cocoa, recall that C and Objective-C don‚Äôt have<br>&gt; parameter labels on their corresponding concepts (Blocks and C function<br>&gt; pointers), and the higher order functions in the standard library should<br>&gt; not require parameter labels either.<br>&gt;<br>&gt; -Chris &amp; the Core Team<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/a7c6cad7/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
