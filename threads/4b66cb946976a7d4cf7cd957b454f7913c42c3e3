<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  6, 2016 at 10:00:00am</p></header><div class="content"><p>NSError encapsulates runtime error condition information. It uses an historic, time-tested object<br>built to communicate information to users and provide a basis for workarounds. <br>Swift&#39;s redesigned error mechanism differs significantly from NSError in that its primary consumer<br>are API calls, via the try-catch mechanism and not end-users.<br></p><p>I would not like Swift to be tied down to an archaic construct for the sake of consistency. NSError&#39;s<br>core domain/code/userInfo attributes are architected to archaic use-cases. It domains of<br>Mach/POSIX/Carbon/Cocoa are subsumed by Swift modules. The integer-based codes <br>can be better represented by plain-text strings, the dictionary keys model usage that <br>poorly integrates into Swift&#39;s throw-try ecosystem.<br></p><p>To me, an error should answer the following questions:<br></p><p>* What went wrong?<br>* Where did it go wrong?<br>* What other information am I passing along about the circumstances of the error?<br></p><p>A universal standard library error could be as simple as <br></p><p>struct Error: ErrorType {<br>  let reason: String<br>}<br></p><p>although, I&#39;d far prefer to add a context, using the newly updated debug literals to describe<br>exactly where the error sourced from. An ideal context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt; would include:<br></p><p>* A source location including a fully qualified module, file name and line number, shared <br>  object (dsohandle), symbol, e.g. FooType.methodName(label1: _, label2: _) (with an optional <br>  mangled name component), and column number (although I sincerely do not understand <br>   the point of column number)<br>* An indicator of release or debug build<br>* Pre-crafted strings that combine these data into printable forms suitable for release and <br>  debug output using brief, long, and exhaustive context forms.<br>* Decomposable elements, offering both the full context story while retaining an option<br>  to access and query individual components as needed.<br></p><p>struct Error: ErrorType {<br>  let reason: String<br>  let context: ContextType<br>}<br></p><p>further, I&#39;d want to implement some kind of generalizable dictionary, an infoDictionary<br>rather than a userDictionary, that describes error circumstances and possible recovery<br>selectors, without being tied to the notion that the ultimate consumer &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html#//apple_ref/doc/uid/TP40001806-CH202-CJBGAIBJ&gt; is an NSAlert<br>presented to a user.<br></p><p>struct Error: ErrorType {<br>  let reason: String<br>  let context: ContextType<br>  let infoDictionary: Dictionary&lt;String: Any&gt;<br>}<br></p><p>-- Erica<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/4b66c3e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>March  6, 2016 at 11:00:00am</p></header><div class="content"><p>NSError&#39; domains and code create a universal mechanism to filter errors from logs by semantic grouping. Your new proposed type lacks this fairly important quality. <br></p><p>Is the intent that the reason string to be presented to the user? If so, that&#39;s not a great story for localization.<br></p><p>As for context, release vs debug is not a sufficient breakdown. A lot of software is built with much more granularity that just those two options. Such information included build numbers, branching, flags to light up experimental features, etc... <br></p><p>As for column number, you&#39;ll be happy to have it for the cases you have two throwing calls on the same line. <br></p><p>-David<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 6, 2016, at 9:17 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; NSError encapsulates runtime error condition information. It uses an historic, time-tested object<br>&gt; built to communicate information to users and provide a basis for workarounds. <br>&gt; Swift&#39;s redesigned error mechanism differs significantly from NSError in that its primary consumer<br>&gt; are API calls, via the try-catch mechanism and not end-users.<br>&gt; <br>&gt; I would not like Swift to be tied down to an archaic construct for the sake of consistency. NSError&#39;s<br>&gt; core domain/code/userInfo attributes are architected to archaic use-cases. It domains of<br>&gt; Mach/POSIX/Carbon/Cocoa are subsumed by Swift modules. The integer-based codes <br>&gt; can be better represented by plain-text strings, the dictionary keys model usage that <br>&gt; poorly integrates into Swift&#39;s throw-try ecosystem.<br>&gt; <br>&gt; To me, an error should answer the following questions:<br>&gt; <br>&gt; * What went wrong?<br>&gt; * Where did it go wrong?<br>&gt; * What other information am I passing along about the circumstances of the error?<br>&gt; <br>&gt; A universal standard library error could be as simple as <br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt; }<br>&gt; <br>&gt; although, I&#39;d far prefer to add a context, using the newly updated debug literals to describe<br>&gt; exactly where the error sourced from. An ideal context would include:<br>&gt; <br>&gt; * A source location including a fully qualified module, file name and line number, shared <br>&gt;   object (dsohandle), symbol, e.g. FooType.methodName(label1: _, label2: _) (with an optional <br>&gt;   mangled name component), and column number (although I sincerely do not understand <br>&gt;    the point of column number)<br>&gt; * An indicator of release or debug build<br>&gt; * Pre-crafted strings that combine these data into printable forms suitable for release and <br>&gt;   debug output using brief, long, and exhaustive context forms.<br>&gt; * Decomposable elements, offering both the full context story while retaining an option<br>&gt;   to access and query individual components as needed.<br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt;   let context: ContextType<br>&gt; }<br>&gt; <br>&gt; further, I&#39;d want to implement some kind of generalizable dictionary, an infoDictionary<br>&gt; rather than a userDictionary, that describes error circumstances and possible recovery<br>&gt; selectors, without being tied to the notion that the ultimate consumer is an NSAlert<br>&gt; presented to a user.<br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt;   let context: ContextType<br>&gt;   let infoDictionary: Dictionary&lt;String: Any&gt;<br>&gt; }<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/335176b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  6, 2016 at 02:00:00pm</p></header><div class="content"><p>My primary consumer is the developer and does not exclude use of NSError or traditional Cocoa pathways.<br></p><p>-- E<br></p><p>&gt; On Mar 6, 2016, at 12:32 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; NSError&#39; domains and code create a universal mechanism to filter errors from logs by semantic grouping. Your new proposed type lacks this fairly important quality. <br>&gt; <br>&gt; Is the intent that the reason string to be presented to the user? If so, that&#39;s not a great story for localization.<br>&gt; <br>&gt; As for context, release vs debug is not a sufficient breakdown. A lot of software is built with much more granularity that just those two options. Such information included build numbers, branching, flags to light up experimental features, etc... <br>&gt; <br>&gt; As for column number, you&#39;ll be happy to have it for the cases you have two throwing calls on the same line. <br>&gt; <br>&gt; -David<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Mar 6, 2016, at 9:17 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; NSError encapsulates runtime error condition information. It uses an historic, time-tested object<br>&gt;&gt; built to communicate information to users and provide a basis for workarounds. <br>&gt;&gt; Swift&#39;s redesigned error mechanism differs significantly from NSError in that its primary consumer<br>&gt;&gt; are API calls, via the try-catch mechanism and not end-users.<br>&gt;&gt; <br>&gt;&gt; I would not like Swift to be tied down to an archaic construct for the sake of consistency. NSError&#39;s<br>&gt;&gt; core domain/code/userInfo attributes are architected to archaic use-cases. It domains of<br>&gt;&gt; Mach/POSIX/Carbon/Cocoa are subsumed by Swift modules. The integer-based codes <br>&gt;&gt; can be better represented by plain-text strings, the dictionary keys model usage that <br>&gt;&gt; poorly integrates into Swift&#39;s throw-try ecosystem.<br>&gt;&gt; <br>&gt;&gt; To me, an error should answer the following questions:<br>&gt;&gt; <br>&gt;&gt; * What went wrong?<br>&gt;&gt; * Where did it go wrong?<br>&gt;&gt; * What other information am I passing along about the circumstances of the error?<br>&gt;&gt; <br>&gt;&gt; A universal standard library error could be as simple as <br>&gt;&gt; <br>&gt;&gt; struct Error: ErrorType {<br>&gt;&gt;   let reason: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; although, I&#39;d far prefer to add a context, using the newly updated debug literals to describe<br>&gt;&gt; exactly where the error sourced from. An ideal context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt; would include:<br>&gt;&gt; <br>&gt;&gt; * A source location including a fully qualified module, file name and line number, shared <br>&gt;&gt;   object (dsohandle), symbol, e.g. FooType.methodName(label1: _, label2: _) (with an optional <br>&gt;&gt;   mangled name component), and column number (although I sincerely do not understand <br>&gt;&gt;    the point of column number)<br>&gt;&gt; * An indicator of release or debug build<br>&gt;&gt; * Pre-crafted strings that combine these data into printable forms suitable for release and <br>&gt;&gt;   debug output using brief, long, and exhaustive context forms.<br>&gt;&gt; * Decomposable elements, offering both the full context story while retaining an option<br>&gt;&gt;   to access and query individual components as needed.<br>&gt;&gt; <br>&gt;&gt; struct Error: ErrorType {<br>&gt;&gt;   let reason: String<br>&gt;&gt;   let context: ContextType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; further, I&#39;d want to implement some kind of generalizable dictionary, an infoDictionary<br>&gt;&gt; rather than a userDictionary, that describes error circumstances and possible recovery<br>&gt;&gt; selectors, without being tied to the notion that the ultimate consumer &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html#//apple_ref/doc/uid/TP40001806-CH202-CJBGAIBJ&gt; is an NSAlert<br>&gt;&gt; presented to a user.<br>&gt;&gt; <br>&gt;&gt; struct Error: ErrorType {<br>&gt;&gt;   let reason: String<br>&gt;&gt;   let context: ContextType<br>&gt;&gt;   let infoDictionary: Dictionary&lt;String: Any&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/623f635a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/006afe1f7d5e4f18190f2093dd2c5cac?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Adam Sharp</string> &lt;adsharp at me.com&gt;<p>March  7, 2016 at 08:00:00am</p></header><div class="content"><p>On 7 Mar 2016, at 4:17 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A source location including a fully qualified module, ..., and column number (although I sincerely do not understand the point of column number)<br></p><p>On 7 Mar 2016, at 6:32 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As for column number, you&#39;ll be happy to have it for the cases you have two throwing calls on the same line.<br></p><p>A column number could also potentially be useful in an editor to jump directly to the location of a fatal error.<br></p><p>–Adam<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 9:17 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; NSError encapsulates runtime error condition information. It uses an historic, time-tested object<br>&gt; built to communicate information to users and provide a basis for workarounds. <br>&gt; Swift&#39;s redesigned error mechanism differs significantly from NSError in that its primary consumer<br>&gt; are API calls, via the try-catch mechanism and not end-users.<br>&gt; <br>&gt; I would not like Swift to be tied down to an archaic construct for the sake of consistency. NSError&#39;s<br>&gt; core domain/code/userInfo attributes are architected to archaic use-cases. It domains of<br>&gt; Mach/POSIX/Carbon/Cocoa are subsumed by Swift modules. The integer-based codes <br>&gt; can be better represented by plain-text strings, the dictionary keys model usage that <br>&gt; poorly integrates into Swift&#39;s throw-try ecosystem.<br>&gt; <br>&gt; To me, an error should answer the following questions:<br>&gt; <br>&gt; * What went wrong?<br>&gt; * Where did it go wrong?<br>&gt; * What other information am I passing along about the circumstances of the error?<br>&gt; <br>&gt; A universal standard library error could be as simple as <br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt; }<br></p><p>Erica,<br></p><p>I wouldn’t want a single, universal error type for the standard library. I would want to be able to selectively catch errors based on their type rather than having to look into the “reason” string to determine what happened. (In other words, the reason should be encoded in the error type.)<br></p><p>Would your idea work better as a “StandardErrorProtocol” with a default implementation for “context” that provides the source location, etc.? (I have no idea how much compiler magic that might require.)<br></p><p>—CK<br></p><p>&gt; although, I&#39;d far prefer to add a context, using the newly updated debug literals to describe<br>&gt; exactly where the error sourced from. An ideal context &lt;http://ericasadun.com/2015/08/27/capturing-context-swiftlang/&gt; would include:<br>&gt; <br>&gt; * A source location including a fully qualified module, file name and line number, shared <br>&gt;   object (dsohandle), symbol, e.g. FooType.methodName(label1: _, label2: _) (with an optional <br>&gt;   mangled name component), and column number (although I sincerely do not understand <br>&gt;    the point of column number)<br>&gt; * An indicator of release or debug build<br>&gt; * Pre-crafted strings that combine these data into printable forms suitable for release and <br>&gt;   debug output using brief, long, and exhaustive context forms.<br>&gt; * Decomposable elements, offering both the full context story while retaining an option<br>&gt;   to access and query individual components as needed.<br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt;   let context: ContextType<br>&gt; }<br>&gt; <br>&gt; further, I&#39;d want to implement some kind of generalizable dictionary, an infoDictionary<br>&gt; rather than a userDictionary, that describes error circumstances and possible recovery<br>&gt; selectors, without being tied to the notion that the ultimate consumer &lt;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html#//apple_ref/doc/uid/TP40001806-CH202-CJBGAIBJ&gt; is an NSAlert<br>&gt; presented to a user.<br>&gt; <br>&gt; struct Error: ErrorType {<br>&gt;   let reason: String<br>&gt;   let context: ContextType<br>&gt;   let infoDictionary: Dictionary&lt;String: Any&gt;<br>&gt; }<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/5fe5c692/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I wouldn’t want a single, universal error type for the standard library. I would want to be able to selectively catch errors based on their type rather than having to look into the “reason” string to determine what happened. (In other words, the reason should be encoded in the error type.)<br></p><p>I agree. A single concrete error type with stringly-typed data inside it is the precise *opposite* of how the error mechanism should be used.<br></p><p>Swift errors use types and cases to clearly categorize errors and make them easy to programmatically match; they then use associated values to explicitly model the details of each type of error, and pattern matching to allow `catch` clauses to easily zero in on specific errors they can handle, no matter how finicky the requirements. When you start throwing around concrete `Error` structs with `reason` strings and unstructured bags of data called `infoDictionary`, you severely handicap every one of those features.<br></p><p>In general, I think this is tackling the wrong problem. Each error type can manage its own storage containing whatever that type happens to need. Swift will automatically copy or move that information around as appropriate. Simply put, there&#39;s nothing we need to do there.<br></p><p>There are, however, two broad categories of things I *do* think should be modeled better:<br></p><p>- The mapping between a Swift Error and an NSError.<br>- The way errors are presented to the user.<br></p><p>So here&#39;s what I suggest we do to Error in Swift 3.<br></p><p>Clarify and Formalize NSError Bridging<br>----------------------------------------------------<br></p><p>Currently, the only requirements of `Error` are the hidden `_domain` and `_code` types. Let&#39;s formalize those. We&#39;ll also add support for `userInfo`, and include a constructor so we can unpack `userInfo` in the other direction.<br></p><p>	public protocol Error {<br>		var domain: String { get }<br>		@_numbered var code: Int { get }<br>		var userInfo: [String: AnyObject] { get }<br>		<br>		init(code: Int, userInfo: [String: AnyObject])<br>	}<br></p><p>	extension Error {<br>		public var domain: String {<br>			return String(reflecting: self)<br>		}<br>		<br>		public var userInfo: [String: AnyObject] {<br>			return [:]<br>		}<br>		<br>		@_numbered init(code: Int, userInfo: [String: AnyObject]) {<br>			self.init(_numbered: code)<br>		}<br>	}<br>	<br>	public extension Any&lt;Error&gt; {<br>		public init(_: NSError) { ...omitted... }<br>	}<br>	<br>	public extension NSError {<br>		public init(_: Error) { ...omitted... }<br>	}<br></p><p>`code` is still magically synthesized, as indicated by the imaginary `@_numbered` attribute. I don&#39;t like that very much, but I don&#39;t see a good alternative to it, either—RawRepresentable synthesis *almost* works, except that cases with associated values wouldn&#39;t be supported.<br></p><p>CustomStringConvertible for Simple Error Messages<br>----------------------------------------------------------------------<br></p><p>I think that we should encourage developers to conform errors with user-readable error messages to CustomStringConvertible and implement `description` to return that error. To that end, when a CustomStringConvertible Swift error is bridged to NSError, its `description` should become the NSError&#39;s `localizedDescription`. That ends up looking like this:<br></p><p>	enum HollywoodCarError: Error, CustomStringConvertible {<br>		case exploded<br>		case engineFellOut<br>		<br>		var description: String {<br>			switch self {<br>			case .exploded:<br>				return localized(&quot;The car has exploded in a fireball.&quot;)<br>			case .engineFellOut:<br>				return localized(&quot;The car&#39;s engine has fallen out.&quot;)<br>			}<br>		}<br>	}<br></p><p>(The `CustomStringConvertible` documentation is not entirely clear on whether `description` should be user-readable and localized. I interpret it to be &quot;yes&quot;, but if not, we can provide a `LocalizedStringConvertible` protocol along the same lines. In either case, the point is that this is *not* a feature limited to errors; there really ought to be a protocol for anything which can be shown to users in a plain-text form.)<br></p><p>PresentableError<br>-----------------------<br></p><p>There are two other parts of NSError that I think we should widely model because they&#39;d be useful on all platforms.<br></p><p>One is the ability to provide a more detailed error message. NSError calls this the `localizedRecoverySuggestion`; I recommend we just call it `suggestion` or perhaps `details`.<br></p><p>The other is the ability to retrieve a terse sentence fragment explaining the error&#39;s cause, which can be inserted into a larger paragraph. NSError calls this `localizedFailureReason`; I suggest simply using `reason`.<br></p><p>Both of these fields should be bridged into their NSError equivalents, and conforming to their protocol would also imply conformance to `CustomStringConvertible`.<br></p><p>So here is what I would suggest:<br></p><p>	protocol PresentableError: Error, CustomStringConvertible {<br>		var suggestion: String { get }<br>		var reason: String { get }<br>	}<br></p><p>Note that you can declare merely `PresentableError` in your error type, since it implies conformance to `Error`:<br></p><p>	enum HollywoodCarError: PresentableError {<br>		...as before...<br>		<br>		var reason: String {<br>			switch self {<br>			case .exploded:<br>				return localized(&quot;It gently tapped something.&quot;)<br>			case .engineFellOut:<br>				return localized(&quot;The writers want you to get into some wacky hijinks.&quot;)<br>		}<br>		<br>		var suggestion: String {<br>			switch self {<br>			case .exploded:<br>				return localized(&quot;Put on sunglasses and walk away from the explosion at a measured pace.&quot;)<br>			case .engineFellOut:<br>				return localized(&quot;Hike to the nearest town and check into the only motel.&quot;)<br>			}<br>		}<br>	}<br>		<br>RecoverableError<br>-----------------------<br></p><p>Lower-priority because it&#39;s not used *that* often, but I think it&#39;s worth modeling in the long run. It may make sense to put this in Foundation instead of stdlib, though.<br></p><p>The idea behind Cocoa&#39;s `recoveryAttempter` is good, but I think the design is a problem, especially in Corelibs Foundation where we won&#39;t be able to perform selectors. So I suggest an alternative design. I believe it can be bridged to NSError&#39;s approach, although it would not quite be a *trivial* bridging process.<br></p><p>First, the RecoveryAttempting protocol, which models one particular approach to recovering from the error:<br></p><p>	// This is class-constrained in case `recover(from:completion:)` needs to be mutating.<br>	public protocol RecoveryAttempting: class, CustomStringConvertible {<br>		// The CustomStringConvertible name should be suitable for buttons.<br>		<br>		var destructive: Bool<br>		<br>		/// Attempt to recover from the error using this attempter. Calls `completion` when finished.<br>		func recover(from error: Error, completion: (Bool, ErrorType?) -&gt; Void)<br>	}<br>	extension RecoveryAttempting {<br>		public var destructive: Bool { return false }<br>	}<br></p><p>Second, the RecoverableError protocol:<br></p><p>	public protocol RecoverableError: Error {<br>		var recoveryAttempters: [Any&lt;RecoveryAttempting&gt;] { get }<br>	}<br></p><p>We should document that you should only provide non-trivial recovery attempters (i.e. no Cancel options). Higher-level error presentation code can always do that.<br></p><p>Aside: What We Leave Behind<br>----------------------------------------<br></p><p>`helpAnchor` is not modeled because it is *extremely* platform-specific. (It might make sense for AppKit to provide a protocol to represent it, though.)<br></p><p>Programmatically useful data about the error, like `NSURLErrorKey` or even `NSUnderlyingErrorKey`, are not modeled because that information is only available from particular error types or even individual errors. Without knowing at least *something* about the error you&#39;re handling, it&#39;s hard to do anything useful with random pieces of information like this.<br></p><p>Concrete Convenience Types<br>----------------------------------------<br></p><p>Although so far I&#39;ve only talked about providing protocols, I think there are some concrete types we should provide as well. For these I will provide only interfaces; the implementations should be reasonably straightforward.<br></p><p>The first is a concrete type conforming to `RecoveryAttempting` which takes a closure:<br></p><p>	public final class RecoveryAttempter: RecoveryAttempting {<br>		typealias Attempter =  (ErrorType, (Bool, ErrorType?) -&gt; Void) -&gt; Void<br>		public init(description: String, destructive: Bool = false, attempter: Attempter)<br>	}<br></p><p>I would also like to offer wrapper types which allow you to easily change various aspects of error presentation, along these lines:<br></p><p>	struct CustomizedError&lt;ErrorType: Error&gt;: Error, CustomStringConvertible {<br>		init(_ original: ErrorType, description: String)<br>	}<br>	extension CustomizedError: PresentableError where ErrorType: PresentableError {}<br>	extension CustomizedError: PresentableError where ErrorType: PresentableError {}<br>	<br>	struct CustomizedPresentableError&lt;ErrorType: Error&gt;: PresentableError {<br>		init(_ original: ErrorType, description: String, reason: String, suggestion: String)<br>	}<br>	extension CustomizedPresentableError where ErrorType: PresentableError {<br>		init(_ original: ErrorType, description: String? = nil, reason: String? = nil, suggestion: String? = nil)<br>	}<br>	extension CustomizedPresentableError: RecoverableError where ErrorType: RecoverableError {}<br>	<br>	struct AdditionalRecoveryError&lt;ErrorType: Error&gt;: RecoverableError {<br>		init(_ original: ErrorType, recoveryAttempters: [RecoveryAttempter])<br>	}<br>	extension AdditionalRecoveryError where ErrorType: RecoverableError {<br>		init(_ original: ErrorType, additionalRecoveryAttempters: [RecoveryAttempter])<br>	}<br>	extension AdditionalRecoveryError: CustomStringConvertible where ErrorType: CustomStringConvertible {}<br>	extension AdditionalRecoveryError: PresentableError where ErrorType: PresentableError {}<br></p><p>However, these types present a significant challenge: They interfere with `catch` matching. One possible workaround would be to have `Error` itself include an `original` property and have `catch` match against that; most `Error` types would return `self`, but shallow, non-semantic wrappers like these would return the error they were wrapping. (Note that this is *not* the same as Foundation&#39;s `underlyingError`, which is why it&#39;s named differently.) This could make it a little tricky to rethrow errors, though—doing so might strip away the custom behavior wrapped around the error.<br></p><p>This could be interpreted as a sign that the problem needs to be factored differently by separating the *error* from the *error message*. But I don&#39;t see a clean way to do that; it would make implementing an `Error` type more cumbersome, it would still not solve the wrapping problem (unless the idea is that you should only tweak an error message once you&#39;re committed to presenting it), and it would create an impedance mismatch with `NSError`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 7:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I wouldn’t want a single, universal error type for the standard library. I would want to be able to selectively catch errors based on their type rather than having to look into the “reason” string to determine what happened. (In other words, the reason should be encoded in the error type.)<br>&gt; <br>&gt; I agree. A single concrete error type with stringly-typed data inside it is the precise *opposite* of how the error mechanism should be used.<br></p><p>Oh dear, because that is exactly *not* what I was proposing. I was suggesting something that was a standard fallback <br>error completely separate from any other modification to the error mechanism, just because it&#39;s extremely useful<br>to have something to throw without having to design a full error system for things like command-line utilities, etc.<br>In otherwords, a pre-constructed vanilla handy-error, ready for use that would have zero impact on any other error<br>system, implementation, or mechanism.<br></p><p>-- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I was suggesting something that was a standard fallback <br>&gt; error completely separate from any other modification to the error mechanism, just because it&#39;s extremely useful<br>&gt; to have something to throw without having to design a full error system for things like command-line utilities, etc.<br>&gt; In otherwords, a pre-constructed vanilla handy-error, ready for use that would have zero impact on any other error<br>&gt; system, implementation, or mechanism.<br></p><p>Ah.<br></p><p>If that&#39;s what you have in mind, I would give it a name like SimpleError, GenericError, or UnspecifiedError, and I would not have it carry any state other than an error message (if we introduce some standard mechanism to convey an error message, like using CustomStringConvertible). I think that, at the point where you need to pack a generic error full of random information or figure out where in the source code it came from, you probably need to start explicitly modeling the errors your code can generate.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  6, 2016 at 08:00:00pm</p></header><div class="content"><p>The source context is super-handy. (&quot;File &quot;foo.swift&quot;, line 23: &quot;Bad moon tonight&quot;&quot;).<br></p><p>I included all the other stuff more or less as a mental cut-and-paste from the discussion <br>about how the error constants still needed to evolve (https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md&gt;)<br></p><p>And I threw in a dictionary because who doesn&#39;t love a dictionary?<br></p><p>But yeah, GenericError, BasicError, SimpleError, anything like that. And you know half the time people are just going to &quot;guard try? blah else {fatalError(&quot;oops&quot;)}&quot;<br></p><p>-- E<br></p><p><br>&gt; On Mar 6, 2016, at 8:47 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I was suggesting something that was a standard fallback <br>&gt;&gt; error completely separate from any other modification to the error mechanism, just because it&#39;s extremely useful<br>&gt;&gt; to have something to throw without having to design a full error system for things like command-line utilities, etc.<br>&gt;&gt; In otherwords, a pre-constructed vanilla handy-error, ready for use that would have zero impact on any other error<br>&gt;&gt; system, implementation, or mechanism.<br>&gt; <br>&gt; Ah.<br>&gt; <br>&gt; If that&#39;s what you have in mind, I would give it a name like SimpleError, GenericError, or UnspecifiedError, and I would not have it carry any state other than an error message (if we introduce some standard mechanism to convey an error message, like using CustomStringConvertible). I think that, at the point where you need to pack a generic error full of random information or figure out where in the source code it came from, you probably need to start explicitly modeling the errors your code can generate.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/df242882/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>March  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 7:10 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 6, 2016, at 7:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I wouldn’t want a single, universal error type for the standard library. I would want to be able to selectively catch errors based on their type rather than having to look into the “reason” string to determine what happened. (In other words, the reason should be encoded in the error type.)<br>&gt;&gt; <br>&gt;&gt; I agree. A single concrete error type with stringly-typed data inside it is the precise *opposite* of how the error mechanism should be used.<br>&gt; <br>&gt; Oh dear, because that is exactly *not* what I was proposing. I was suggesting something that was a standard fallback error completely separate from any other modification to the error mechanism, just because it&#39;s extremely useful to have something to throw without having to design a full error system for things like command-line utilities, etc. In otherwords, a pre-constructed vanilla handy-error, ready for use that would have zero impact on any other error system, implementation, or mechanism.<br></p><p>I see. You don’t want the standard library to *use* that error type, just make it available. I still worry that including it in the standard library would be a de facto sanctioning of an error-handling anti-pattern, though (i.e., errors differentiated by string descriptions).<br></p><p>I certainly see the value of the context information you want to provide. It would be great if that could somehow be made available to any ErrorType.<br></p><p>—CK<br></p><p>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  6, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; I certainly see the value of the context information you want to provide. It would be great if that could somehow be made available to any ErrorType.<br>&gt; <br>&gt; —CK<br></p><p><br>The context information is a work in progress. First started discussion for this:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md&gt;<br></p><p>But it got deferred, and I never got around to bring that back up. I kind of glommed the two things together.<br>I should probably start a separate thread for &quot;what info should be gathered in debug identifiers&quot;.<br></p><p>And I would very much like to see a proposal gain momentum on another big bugaboo of mine, the <br>#if conditions for compilation. There was a great conversation going and it died.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/7a60e4ee/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  6, 2016 at 08:00:00pm</p></header><div class="content"><p>On Sun, Mar 6, 2016, at 06:38 PM, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; &gt; I wouldn’t want a single, universal error type for the standard library. I would want to be able to selectively catch errors based on their type rather than having to look into the “reason” string to determine what happened. (In other words, the reason should be encoded in the error type.)<br>&gt; <br>&gt; I agree. A single concrete error type with stringly-typed data inside it is the precise *opposite* of how the error mechanism should be used.<br>&gt; <br>&gt; Swift errors use types and cases to clearly categorize errors and make them easy to programmatically match; they then use associated values to explicitly model the details of each type of error, and pattern matching to allow `catch` clauses to easily zero in on specific errors they can handle, no matter how finicky the requirements. When you start throwing around concrete `Error` structs with `reason` strings and unstructured bags of data called `infoDictionary`, you severely handicap every one of those features.<br>&gt; <br>&gt; In general, I think this is tackling the wrong problem. Each error type can manage its own storage containing whatever that type happens to need. Swift will automatically copy or move that information around as appropriate. Simply put, there&#39;s nothing we need to do there.<br>&gt; <br>&gt; There are, however, two broad categories of things I *do* think should be modeled better:<br>&gt; <br>&gt; - The mapping between a Swift Error and an NSError.<br>&gt; - The way errors are presented to the user.<br>&gt; <br>&gt; So here&#39;s what I suggest we do to Error in Swift 3.<br>&gt; <br>&gt; Clarify and Formalize NSError Bridging<br>&gt; ----------------------------------------------------<br>&gt; <br>&gt; Currently, the only requirements of `Error` are the hidden `_domain` and `_code` types. Let&#39;s formalize those. We&#39;ll also add support for `userInfo`, and include a constructor so we can unpack `userInfo` in the other direction.<br>&gt; <br>&gt; 	public protocol Error {<br>&gt; 		var domain: String { get }<br>&gt; 		@_numbered var code: Int { get }<br>&gt; 		var userInfo: [String: AnyObject] { get }<br>&gt; 		<br>&gt; 		init(code: Int, userInfo: [String: AnyObject])<br>&gt; 	}<br>&gt; <br>&gt; 	extension Error {<br>&gt; 		public var domain: String {<br>&gt; 			return String(reflecting: self)<br>&gt; 		}<br>&gt; 		<br>&gt; 		public var userInfo: [String: AnyObject] {<br>&gt; 			return [:]<br>&gt; 		}<br>&gt; 		<br>&gt; 		@_numbered init(code: Int, userInfo: [String: AnyObject]) {<br>&gt; 			self.init(_numbered: code)<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	public extension Any&lt;Error&gt; {<br>&gt; 		public init(_: NSError) { ...omitted... }<br>&gt; 	}<br>&gt; 	<br>&gt; 	public extension NSError {<br>&gt; 		public init(_: Error) { ...omitted... }<br>&gt; 	}<br>&gt; <br>&gt; `code` is still magically synthesized, as indicated by the imaginary `@_numbered` attribute. I don&#39;t like that very much, but I don&#39;t see a good alternative to it, either—RawRepresentable synthesis *almost* works, except that cases with associated values wouldn&#39;t be supported.<br></p><p>I disagree that this should be part of Error. `domain` and `code` are both relics of NSError integration and have no purpose when not bridging to NSError. The `domain` is really just a string representation of the error type, and the `code` is just an integral representation of the enum variant, so they&#39;re just imperfect representations of information already contained by the error value itself. We do actually need to include them in order to bridge any arbitrary Error to NSError, but they should stay as hidden implementation details (e.g. `_domain` and `_code`) like they are today. Besides, the names `domain` and `code` might be names that the concrete Error implementation actually wants to use for its own purposes.<br></p><p>Also, there&#39;s no need to ever &quot;unpack&quot; userInfo. When you bridge a Swift error into NSError, it uses a private NSError subclass _SwiftNativeNSError, which boxes up the original error, and when that NSError is bridged back to ErrorType you get the original error value back automatically. Swift has an internal type _ObjectiveCBridgeableErrorType that has an init?(_bridgedNSError: NSError) method, but AIUI that is actually used to handle bridging of regular Cocoa NSErrors into the Swift ErrorType values that represent them (e.g. for all of the error enums found in the overlay module).<br></p><p>Really, the only thing we want to add to the current process is a way for an ErrorType to provide the .userInfo value of the bridged NSError, and I think we can do that just by adding a new protocol<br></p><p>public protocol BridgedNSError {<br>    var bridgedNSErrorUserInfo: [NSObject: AnyObject] { get }<br>}<br></p><p>(the property name is to avoid taking the generic term &quot;userInfo&quot;, which the ErrorType might want to use for its own purposes)<br></p><p>The machinery that bridges to NSError would simply test for conformance to this protocol and use it to provide the .userInfo if present.<br></p><p>And of course this protocol would live in the Foundation overlay instead of being part of the stdlib proper.<br></p><p>&gt; CustomStringConvertible for Simple Error Messages<br>&gt; ----------------------------------------------------------------------<br>&gt; <br>&gt; I think that we should encourage developers to conform errors with user-readable error messages to CustomStringConvertible and implement `description` to return that error. To that end, when a CustomStringConvertible Swift error is bridged to NSError, its `description` should become the NSError&#39;s `localizedDescription`. That ends up looking like this:<br>&gt; <br>&gt; 	enum HollywoodCarError: Error, CustomStringConvertible {<br>&gt; 		case exploded<br>&gt; 		case engineFellOut<br>&gt; 		<br>&gt; 		var description: String {<br>&gt; 			switch self {<br>&gt; 			case .exploded:<br>&gt; 				return localized(&quot;The car has exploded in a fireball.&quot;)<br>&gt; 			case .engineFellOut:<br>&gt; 				return localized(&quot;The car&#39;s engine has fallen out.&quot;)<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; (The `CustomStringConvertible` documentation is not entirely clear on whether `description` should be user-readable and localized. I interpret it to be &quot;yes&quot;, but if not, we can provide a `LocalizedStringConvertible` protocol along the same lines. In either case, the point is that this is *not* a feature limited to errors; there really ought to be a protocol for anything which can be shown to users in a plain-text form.)<br></p><p>I disagree here too. My CustomStringConvertible representation of my error may not be at all suitable for the localizedDescription of an NSError. The NSError&#39;s localizedDescription should be a string that is suitable for presenting to the user, but CustomStringConvertible isn&#39;t necessarily intended for showing to a user. For example, my enum&#39;s string representation may be &quot;IOError(code: 3, path: &quot;/tmp/foo&quot;)&quot;, which is certainly not what you want the user to see.<br></p><p>&gt; PresentableError<br>&gt; -----------------------<br>&gt; <br>&gt; There are two other parts of NSError that I think we should widely model because they&#39;d be useful on all platforms.<br>&gt; <br>&gt; One is the ability to provide a more detailed error message. NSError calls this the `localizedRecoverySuggestion`; I recommend we just call it `suggestion` or perhaps `details`.<br>&gt; <br>&gt; The other is the ability to retrieve a terse sentence fragment explaining the error&#39;s cause, which can be inserted into a larger paragraph. NSError calls this `localizedFailureReason`; I suggest simply using `reason`.<br>&gt; <br>&gt; Both of these fields should be bridged into their NSError equivalents, and conforming to their protocol would also imply conformance to `CustomStringConvertible`.<br></p><p>I disagree here as well. If we have a way to provide the userInfo dictionary for a bridged NSError, then we don&#39;t need these fields (and in fact these fields would become useless as the bridging machinery wouldn&#39;t even look at them, seeing as how the error provides its own userInfo dictionary already). And I don&#39;t think the stdlib should try to define the semantics for how errors should be represented in a UI, since the stdlib doesn&#39;t do anything UI-related. We should leave this space open for other libraries to investigate alternatives to NSError&#39;s handling of this.<br></p><p>And FWIW, I don&#39;t think I&#39;ve _ever_ seen anyone provide localizedRecoverySuggestion with NSError, and it&#39;s pretty rare to see a localizedFailureReason.<br></p><p>&gt; RecoverableError<br>&gt; -----------------------<br>&gt; <br>&gt; Lower-priority because it&#39;s not used *that* often, but I think it&#39;s worth modeling in the long run. It may make sense to put this in Foundation instead of stdlib, though.<br>&gt; <br>&gt; The idea behind Cocoa&#39;s `recoveryAttempter` is good, but I think the design is a problem, especially in Corelibs Foundation where we won&#39;t be able to perform selectors. So I suggest an alternative design. I believe it can be bridged to NSError&#39;s approach, although it would not quite be a *trivial* bridging process.<br>&gt; <br>&gt; First, the RecoveryAttempting protocol, which models one particular approach to recovering from the error:<br>&gt; <br>&gt; 	// This is class-constrained in case `recover(from:completion:)` needs to be mutating.<br>&gt; 	public protocol RecoveryAttempting: class, CustomStringConvertible {<br>&gt; 		// The CustomStringConvertible name should be suitable for buttons.<br>&gt; 		<br>&gt; 		var destructive: Bool<br>&gt; 		<br>&gt; 		/// Attempt to recover from the error using this attempter. Calls `completion` when finished.<br>&gt; 		func recover(from error: Error, completion: (Bool, ErrorType?) -&gt; Void)<br>&gt; 	}<br>&gt; 	extension RecoveryAttempting {<br>&gt; 		public var destructive: Bool { return false }<br>&gt; 	}<br>&gt; <br>&gt; Second, the RecoverableError protocol:<br>&gt; <br>&gt; 	public protocol RecoverableError: Error {<br>&gt; 		var recoveryAttempters: [Any&lt;RecoveryAttempting&gt;] { get }<br>&gt; 	}<br>&gt; <br>&gt; We should document that you should only provide non-trivial recovery attempters (i.e. no Cancel options). Higher-level error presentation code can always do that.<br></p><p>Just like PresentableError, I don&#39;t think this is appropriate for the Swift stdlib.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; `code` is still magically synthesized, as indicated by the imaginary `@_numbered` attribute. I don&#39;t like that very much, but I don&#39;t see a good alternative to it, either—RawRepresentable synthesis *almost* works, except that cases with associated values wouldn&#39;t be supported.<br>&gt; <br>&gt; I disagree that this should be part of Error. `domain` and `code` are both relics of NSError integration and have no purpose when not bridging to NSError. The `domain` is really just a string representation of the error type, and the `code` is just an integral representation of the enum variant, so they&#39;re just imperfect representations of information already contained by the error value itself. We do actually need to include them in order to bridge any arbitrary Error to NSError, but they should stay as hidden implementation details (e.g. `_domain` and `_code`) like they are today. Besides, the names `domain` and `code` might be names that the concrete Error implementation actually wants to use for its own purposes.<br></p><p>To tell the truth, the early drafts of that email said that Error&#39;s requirements should be platform-dependent, but that the Swift compiler should always be able to synthesize all of them automatically. But as I thought about it more, I decided that probably wasn&#39;t right.<br></p><p>The reason I think that is Corelibs Foundation. It appears to me that the long-term plan for Swift is to have Foundation available in all environments Swift supports, except perhaps embedded ones. That means NSError is here to stay and interoperation between NSError and Swift.Error is going to be a permanent requirement.<br></p><p>&gt; Also, there&#39;s no need to ever &quot;unpack&quot; userInfo. When you bridge a Swift error into NSError, it uses a private NSError subclass _SwiftNativeNSError, which boxes up the original error, and when that NSError is bridged back to ErrorType you get the original error value back automatically. Swift has an internal type _ObjectiveCBridgeableErrorType that has an init?(_bridgedNSError: NSError) method, but AIUI that is actually used to handle bridging of regular Cocoa NSErrors into the Swift ErrorType values that represent them (e.g. for all of the error enums found in the overlay module).<br></p><p>Yes, and I&#39;m suggesting we should handle bidirectional bridging with public APIs, not private magic, and in a way that can expose all of the details to both sides. If NSError is a permanent part of Swift, I think we should plan to do that sooner or later.<br></p><p>&gt; Really, the only thing we want to add to the current process is a way for an ErrorType to provide the .userInfo value of the bridged NSError, and I think we can do that just by adding a new protocol<br>&gt; <br>&gt; public protocol BridgedNSError {<br>&gt;    var bridgedNSErrorUserInfo: [NSObject: AnyObject] { get }<br>&gt; }<br>&gt; <br>&gt; (the property name is to avoid taking the generic term &quot;userInfo&quot;, which the ErrorType might want to use for its own purposes)<br>&gt; <br>&gt; The machinery that bridges to NSError would simply test for conformance to this protocol and use it to provide the .userInfo if present.<br></p><p>I did think about moving the userInfo stuff (both the property and the initializer) into a separate protocol, but that was late in the drafting process and the email was long enough already.<br></p><p>&gt;&gt; CustomStringConvertible for Simple Error Messages<br>&gt;&gt; ----------------------------------------------------------------------<br>&gt;&gt; <br>&gt;&gt; I think that we should encourage developers to conform errors with user-readable error messages to CustomStringConvertible and implement `description` to return that error. To that end, when a CustomStringConvertible Swift error is bridged to NSError, its `description` should become the NSError&#39;s `localizedDescription`. That ends up looking like this:<br>&gt; <br>&gt; I disagree here too. My CustomStringConvertible representation of my error may not be at all suitable for the localizedDescription of an NSError. The NSError&#39;s localizedDescription should be a string that is suitable for presenting to the user, but CustomStringConvertible isn&#39;t necessarily intended for showing to a user. For example, my enum&#39;s string representation may be &quot;IOError(code: 3, path: &quot;/tmp/foo&quot;)&quot;, which is certainly not what you want the user to see.<br></p><p>Primarily, I am suggesting that we should have *a standard protocol* for &quot;give me a textual version of this instance that I can show to a user&quot; and that we should, by convention, use that on `Error`s to convey error messages for errors that are suitable to present to users.<br></p><p>I am not sure if `CustomStringConvertible` is the right protocol for that purpose, but if it isn&#39;t—if `CustomStringConvertible` is meant to provide a programmer-readable representation—then frankly I&#39;m not sure what `CustomDebugStringConvertible` is for. But the exact protocol used is immaterial.<br></p><p>(To be honest, a lot of the decisions around `CustomStringConvertible` confuse me; for example, I don&#39;t understand why Swift allows you to interpolate any instance into a string rather than only `CustomStringConvertible` instances. So this might just be part of the same blind spot.)<br></p><p>&gt;&gt; PresentableError<br>&gt; <br>&gt; I disagree here as well. If we have a way to provide the userInfo dictionary for a bridged NSError, then we don&#39;t need these fields (and in fact these fields would become useless as the bridging machinery wouldn&#39;t even look at them, seeing as how the error provides its own userInfo dictionary already).<br></p><p>The userInfo dictionary isn&#39;t always the source of this information; that&#39;s why NSError includes methods to retrieve them. The methods allow subclasses to override the defaults and generate error messages when they&#39;re needed, and NSError user info providers let you do the same thing without subclassing. Having bridged Swift errors call into particular methods on the Swift side would not be out of place.<br></p><p>&gt; And I don&#39;t think the stdlib should try to define the semantics for how errors should be represented in a UI, since the stdlib doesn&#39;t do anything UI-related. We should leave this space open for other libraries to investigate alternatives to NSError&#39;s handling of this.<br></p><p>It may make sense to have the protocol for this be part of Foundation, but either way, I&#39;d *really* like to have a very easy, clean way to move this stuff between Swift.Error-land and NSError-land.<br></p><p>&gt; And FWIW, I don&#39;t think I&#39;ve _ever_ seen anyone provide localizedRecoverySuggestion with NSError, and it&#39;s pretty rare to see a localizedFailureReason.<br></p><p>I think this may be why we&#39;re disagreeing about this so much—I suspect you use a very shallow subset of NSError&#39;s features, whereas I use them very aggressively. So let me explain where I&#39;m coming from here.<br></p><p>In my current project, a mixed-language Mac app with about 30 errors, I have an NSError user info provider* that&#39;s about 300 lines long. Every error has a localizedDescription, most have a localizedRecoverySuggestion, and a perhaps a third to a half have a localizedFailureReason (mainly ones which end up getting wrapped in a generic &quot;Document X cannot be opened&quot; error; I append the localizedFailureReason to indicate what happened.) To support this, I of course have to pack a bunch of information into the `userInfo`; I have 14 keys I use for various purposes, and most of their values get inserted into error messages to make them more specific.<br></p><p>Structuring errors that thoroughly takes a lot of really boring code, but it pays off in really good error messages and diagnostics. I can usually pass an error straight into `-presentError:` with little to no modification.<br></p><p>(I don&#39;t know how you *wouldn&#39;t* use a `localizedRecoverySuggestion`, honestly; those provide the small text in an error dialog.)<br></p><p>* User info providers are a new feature not yet listed in the documentation, but there are doc comments for them. They basically let you specify a block that will fill in missing user info keys for a particular error domain, so you can centralize error message generation. See `-[NSError setUserInfoValueProviderForDomain:provider:]`.<br></p><p>&gt;&gt; RecoverableError<br>&gt; <br>&gt; Just like PresentableError, I don&#39;t think this is appropriate for the Swift stdlib.<br></p><p>I&#39;ve generally found the NSError equivalent to be a great feature marred by a fairly clumsy design. (If it had been built post-blocks it would be far better.) But you may be right that it&#39;s higher-level than what stdlib should model.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  7, 2016 at 12:00:00am</p></header><div class="content"><p>On Sun, Mar 6, 2016, at 11:10 PM, Brent Royal-Gordon wrote:<br>&gt; &gt;&gt; `code` is still magically synthesized, as indicated by the imaginary `@_numbered` attribute. I don&#39;t like that very much, but I don&#39;t see a good alternative to it, either—RawRepresentable synthesis *almost* works, except that cases with associated values wouldn&#39;t be supported.<br>&gt; &gt; <br>&gt; &gt; I disagree that this should be part of Error. `domain` and `code` are both relics of NSError integration and have no purpose when not bridging to NSError. The `domain` is really just a string representation of the error type, and the `code` is just an integral representation of the enum variant, so they&#39;re just imperfect representations of information already contained by the error value itself. We do actually need to include them in order to bridge any arbitrary Error to NSError, but they should stay as hidden implementation details (e.g. `_domain` and `_code`) like they are today. Besides, the names `domain` and `code` might be names that the concrete Error implementation actually wants to use for its own purposes.<br>&gt; <br>&gt; To tell the truth, the early drafts of that email said that Error&#39;s requirements should be platform-dependent, but that the Swift compiler should always be able to synthesize all of them automatically. But as I thought about it more, I decided that probably wasn&#39;t right.<br>&gt; <br>&gt; The reason I think that is Corelibs Foundation. It appears to me that the long-term plan for Swift is to have Foundation available in all environments Swift supports, except perhaps embedded ones. That means NSError is here to stay and interoperation between NSError and Swift.Error is going to be a permanent requirement.<br></p><p>The existence of Corelibs Foundation doesn&#39;t mean that Foundation will be something everyone is expected to use in the future. After all, it needs to be API-compatible with the real Foundation, but Foundation&#39;s API was designed for Obj-C, not Swift. A freshly-designed Foundation-free library that provides the same functionality would look rather different. Which is to say, the existence of Corelibs Foundation does not mean that the long-term plan is to keep using NSError.<br></p><p>&gt; &gt; Also, there&#39;s no need to ever &quot;unpack&quot; userInfo. When you bridge a Swift error into NSError, it uses a private NSError subclass _SwiftNativeNSError, which boxes up the original error, and when that NSError is bridged back to ErrorType you get the original error value back automatically. Swift has an internal type _ObjectiveCBridgeableErrorType that has an init?(_bridgedNSError: NSError) method, but AIUI that is actually used to handle bridging of regular Cocoa NSErrors into the Swift ErrorType values that represent them (e.g. for all of the error enums found in the overlay module).<br>&gt; <br>&gt; Yes, and I&#39;m suggesting we should handle bidirectional bridging with public APIs, not private magic, and in a way that can expose all of the details to both sides. If NSError is a permanent part of Swift, I think we should plan to do that sooner or later.<br></p><p>The point is that, for error types defined in Swift, you&#39;ll _never_ have to manually unpack an NSError into the Swift error, because every NSError that represents the Swift error will have been created from the Swift error in the first place and will therefore be a _SwiftNativeNSError. The only reason to have a public API here is if you want to add the ability to construct new NSError instances in Obj-C and then convert them into your Swift error type, but I don&#39;t think that&#39;s something the stdlib needs to support.<br></p><p>&gt; &gt;&gt; CustomStringConvertible for Simple Error Messages<br>&gt; &gt;&gt; ----------------------------------------------------------------------<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I think that we should encourage developers to conform errors with user-readable error messages to CustomStringConvertible and implement `description` to return that error. To that end, when a CustomStringConvertible Swift error is bridged to NSError, its `description` should become the NSError&#39;s `localizedDescription`. That ends up looking like this:<br>&gt; &gt; <br>&gt; &gt; I disagree here too. My CustomStringConvertible representation of my error may not be at all suitable for the localizedDescription of an NSError. The NSError&#39;s localizedDescription should be a string that is suitable for presenting to the user, but CustomStringConvertible isn&#39;t necessarily intended for showing to a user. For example, my enum&#39;s string representation may be &quot;IOError(code: 3, path: &quot;/tmp/foo&quot;)&quot;, which is certainly not what you want the user to see.<br>&gt; <br>&gt; Primarily, I am suggesting that we should have *a standard protocol* for &quot;give me a textual version of this instance that I can show to a user&quot; and that we should, by convention, use that on `Error`s to convey error messages for errors that are suitable to present to users.<br></p><p>You&#39;d want to invent a new protocol for this purpose, then, as there&#39;s no built-in protocol that is defined such that it produces values suitable for NSError.localizedDescription. CustomStringConvertible just provides some way to produce a String from a value. It doesn&#39;t say anything about what that String is meant for. And the types of strings that you want for NSError.localizedDescription are rather unlikely to be the strings that people choose to return from CustomStringConvertible.description. localizedDescription is typically a complete grammatical sentence, whereas CustomStringConvertible usually just provides a description of the value itself<br></p><p>&gt; I am not sure if `CustomStringConvertible` is the right protocol for that purpose, but if it isn&#39;t—if `CustomStringConvertible` is meant to provide a programmer-readable representation—then frankly I&#39;m not sure what `CustomDebugStringConvertible` is for. But the exact protocol used is immaterial.<br></p><p>CustomDebugStringConvertible is meant for printing even more verbose descriptions in the debugger or in debug logging. Many types choose to provide a reasonable amount of info in CustomStringConvertible and a much more verbose output for CustomDebugStringConvertible.<br></p><p>&gt; (To be honest, a lot of the decisions around `CustomStringConvertible` confuse me; for example, I don&#39;t understand why Swift allows you to interpolate any instance into a string rather than only `CustomStringConvertible` instances. So this might just be part of the same blind spot.)<br></p><p>Why shouldn&#39;t Swift allow you to interpolate other values? There&#39;s nothing about string interpolation that says the output is intended to be displayed in a UI, and interpolating arbitrary values is extremely useful for logging purposes.<br></p><p>&gt; &gt; And FWIW, I don&#39;t think I&#39;ve _ever_ seen anyone provide localizedRecoverySuggestion with NSError, and it&#39;s pretty rare to see a localizedFailureReason.<br>&gt; <br>&gt; I think this may be why we&#39;re disagreeing about this so much—I suspect you use a very shallow subset of NSError&#39;s features, whereas I use them very aggressively. So let me explain where I&#39;m coming from here.<br>&gt; <br>&gt; In my current project, a mixed-language Mac app with about 30 errors, I have an NSError user info provider* that&#39;s about 300 lines long. Every error has a localizedDescription, most have a localizedRecoverySuggestion, and a perhaps a third to a half have a localizedFailureReason (mainly ones which end up getting wrapped in a generic &quot;Document X cannot be opened&quot; error; I append the localizedFailureReason to indicate what happened.) To support this, I of course have to pack a bunch of information into the `userInfo`; I have 14 keys I use for various purposes, and most of their values get inserted into error messages to make them more specific.<br>&gt; <br>&gt; Structuring errors that thoroughly takes a lot of really boring code, but it pays off in really good error messages and diagnostics. I can usually pass an error straight into `-presentError:` with little to no modification.<br>&gt; <br>&gt; (I don&#39;t know how you *wouldn&#39;t* use a `localizedRecoverySuggestion`, honestly; those provide the small text in an error dialog.)<br></p><p>I think this is the difference between iOS and OS X. iOS has no equivalent to -presentError:, and nobody wants to cram a lot of text into an alert. So in iOS, nobody ever bothers with -localizedRecoverySuggestion and whatnot, and -localizedFailureReason use is pretty rare.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>March  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 7 Mar 2016, at 08:16, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; CustomStringConvertible for Simple Error Messages<br>&gt;&gt;&gt;&gt; ----------------------------------------------------------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that we should encourage developers to conform errors with user-readable error messages to CustomStringConvertible and implement `description` to return that error. To that end, when a CustomStringConvertible Swift error is bridged to NSError, its `description` should become the NSError&#39;s `localizedDescription`. That ends up looking like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree here too. My CustomStringConvertible representation of my error may not be at all suitable for the localizedDescription of an NSError. The NSError&#39;s localizedDescription should be a string that is suitable for presenting to the user, but CustomStringConvertible isn&#39;t necessarily intended for showing to a user. For example, my enum&#39;s string representation may be &quot;IOError(code: 3, path: &quot;/tmp/foo&quot;)&quot;, which is certainly not what you want the user to see.<br>&gt;&gt; <br>&gt;&gt; Primarily, I am suggesting that we should have *a standard protocol* for &quot;give me a textual version of this instance that I can show to a user&quot; and that we should, by convention, use that on `Error`s to convey error messages for errors that are suitable to present to users.<br>&gt; <br>&gt; You&#39;d want to invent a new protocol for this purpose, then, as there&#39;s no built-in protocol that is defined such that it produces values suitable for NSError.localizedDescription. CustomStringConvertible just provides some way to produce a String from a value. It doesn&#39;t say anything about what that String is meant for. And the types of strings that you want for NSError.localizedDescription are rather unlikely to be the strings that people choose to return from CustomStringConvertible.description. localizedDescription is typically a complete grammatical sentence, whereas CustomStringConvertible usually just provides a description of the value itself<br></p><p>CFError and NSError also support:<br></p><p>&gt; kCFErrorDescriptionKey<br>&gt; <br>&gt; Key to identify the description in the userInfo dictionary.<br>&gt; <br>&gt; When you create a CFError object, you can provide a value for this key if you do not have localizable error strings. The description should be a complete sentence if possible, and should not contain the domain name or error code.<br>&gt; <br>&gt; Available in OS X v10.5 and later.<br></p><p>&lt;https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFErrorRef/&gt;<br></p><p>The default localizedDescription becomes &quot;The operation couldn’t be completed. (&lt;domain&gt; error &lt;code&gt; - &lt;description&gt;)&quot;.<br></p><p>-- Ben<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Discussion] Adopting a new common error type outside the bounds of NSError</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March  6, 2016 at 09:00:00pm</p></header><div class="content"><p>I can see the benefit in having a basic error type for use with alerts<br>and such, but arguably that&#39;s what NSError is for (although NSError<br>doesn&#39;t pick up context info). A downside to the type you&#39;re proposing<br>is it doesn&#39;t provide any way to programmatically indicate what went<br>wrong (the strings are presumably for human consumption, not<br>programmatic introspection), which makes it largely useless for anything<br>except the point where you&#39;re about to hand off an error to the UI for<br>display (where it&#39;s too late to gather context info).<br></p><p>Also I disagree that the codes can be better represented as strings.<br>Strings are presumably for human consumption, but error codes are for<br>programmatic consumption. You don&#39;t want to do string comparisons to<br>figure out what type of error it is. And of course codes themselves are<br>obsoleted by having strong type information, which is what Swift already<br>has with concrete ErrorType implementations.<br></p><p>-Kevin Ballard<br></p><p>On Sun, Mar 6, 2016, at 09:17 AM, Erica Sadun via swift-evolution wrote:<br>&gt; NSError encapsulates runtime error condition information. It uses an<br>&gt; historic, time-tested object built to communicate information to users<br>&gt; and provide a basis for workarounds. Swift&#39;s redesigned error<br>&gt; mechanism differs significantly from NSError in that its primary<br>&gt; consumer are API calls, via the try-catch mechanism and not end-users.<br>&gt;<br>&gt; I would not like Swift to be tied down to an archaic construct for the<br>&gt; sake of consistency. NSError&#39;s core domain/code/userInfo attributes<br>&gt; are architected to archaic use-cases. It domains of<br>&gt; Mach/POSIX/Carbon/Cocoa are subsumed by Swift modules. The integer-<br>&gt; based codes can be better represented by plain-text strings, the<br>&gt; dictionary keys model usage that poorly integrates into Swift&#39;s throw-<br>&gt; try ecosystem.<br>&gt;<br>&gt; To me, an error should answer the following questions:<br>&gt;<br>&gt; * What went wrong?<br>&gt; * Where did it go wrong?<br>&gt; * What other information am I passing along about the circumstances of<br>&gt;   the error?<br>&gt;<br>&gt; A universal standard library error could be as simple as<br>&gt;<br>&gt; struct Error: ErrorType {  let reason: String }<br>&gt;<br>&gt; although, I&#39;d far prefer to add a context, using the newly updated<br>&gt; debug literals to describe exactly where the error sourced from. An<br>&gt; ideal context[1] would include:<br>&gt;<br>&gt; * A source location including a fully qualified module, file name and<br>&gt;   line number, shared  object (dsohandle), symbol, e.g.<br>&gt;   FooType.methodName(label1: _, label2: _) (with an optional  mangled<br>&gt;   name component), and column number (although I sincerely do not<br>&gt;   understand   the point of column number)<br>&gt; * An indicator of release or debug build<br>&gt; * Pre-crafted strings that combine these data into printable forms<br>&gt;   suitable for release and  debug output using brief, long, and<br>&gt;   exhaustive context forms.<br>&gt; * Decomposable elements, offering both the full context story while<br>&gt;   retaining an option  to access and query individual components as<br>&gt;   needed.<br>&gt;<br>&gt; struct Error: ErrorType {  let reason: String  let context:<br>&gt; ContextType }<br>&gt;<br>&gt; further, I&#39;d want to implement some kind of generalizable<br>&gt; dictionary, an infoDictionary rather than a userDictionary, that<br>&gt; describes error circumstances and possible recovery selectors,<br>&gt; without being tied to the notion that the ultimate consumer[2] is an<br>&gt; NSAlert presented to a user.<br>&gt;<br>&gt; struct Error: ErrorType {  let reason: String  let context:<br>&gt; ContextType  let infoDictionary: Dictionary&lt;String: Any&gt; }<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. http://ericasadun.com/2015/08/27/capturing-context-swiftlang/<br>  2. https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html#//apple_ref/doc/uid/TP40001806-CH202-CJBGAIBJ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160306/488dd633/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
