<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  2, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Feb 01 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 1, 2016, at 3:26 PM, Radosław Pietruszewski<br>&gt;&gt; &lt;radexpl at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s another observation:<br>&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I noticed that there’s another word commonly used to join words in<br>&gt;&gt;&gt;&gt; ObjC method names, very similarly to “with”, and that’s “using”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The vast majority of those is the phrase “usingBlock”:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsingBlock(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How will this be handled? If I understand correctly, “block” will<br>&gt;&gt;&gt;&gt; be dropped as it’s repeating type information, so we’d get:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjectsUsing(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But perhaps it would make more sense to split by “using” the same<br>&gt;&gt;&gt;&gt; way as “with”, yielding:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enumerateObjects(block:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s worth giving it a try. Here are the results:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/8<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/8&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They look generally consistent with the “use a first argument label<br>&gt;&gt;&gt; when the first parameter isn’t the direct object” guidelines being<br>&gt;&gt;&gt; discussed.<br>&gt;&gt; <br>&gt;&gt; Awesome, thank you. The result seems overwhelmingly positive to my eyes.<br>&gt;<br>&gt; I’m not quite as convinced. The function/block/selector cases work<br>&gt; extremely well, but cases like this:<br>&gt;<br>&gt;  -  func connectNodeUsingObstacles(node: GKGraphNode2D)<br>&gt;  +  func connectNode(obstacles node: GKGraphNode2D)<br>&gt;<br>&gt; don’t necessarily seem like a win: it’s completely fundamental to the<br>&gt; method’s operation that it’s avoiding those obstacles, and I think the<br>&gt; original is better than the update here.<br></p><p>I think this is arguable.  What if there was, in addition to obstacles,<br>a collection of swampy regions that can slow down progress?  These seem<br>like peer parameters to the general problem of path finding, the<br>receiving class&#39; name (GKObstacleGraph) notwithstanding.<br></p><p>&gt;&gt;&gt;&gt; Possibly dropping the label altogether (regardless of the<br>&gt;&gt;&gt;&gt; position?) since it’s also redundant? Not sure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    enumerateObjects(_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think I would drop the label. The first parameter is not<br>&gt;&gt;&gt; the direct object of the verb enumerate, nor is it described by<br>&gt;&gt;&gt; &quot;Objects”.<br>&gt;&gt; <br>&gt;&gt; OK, agree. FWIW, when the passed block is the only argument, many<br>&gt;&gt; people (me included) will generally use it using the trailing<br>&gt;&gt; closure syntax, and the label will be dropped this way anyway.<br>&gt;<br>&gt; Yes, and I think it’s better not to have the “block” or “using” in the<br>&gt; base name when you’re using trailing closure syntax. However, when<br>&gt; you’re providing a function (not as a trailing closure), that function<br>&gt; isn’t the direct object, so it should have a first argument label.<br>&gt;<br>&gt; 	- Doug<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I also see more cases that don’t involve blocks:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    dataUsingEncoding(_:)<br>&gt;&gt;&gt;&gt;    connectNodeUsingObstacles(_:)<br>&gt;&gt;&gt;&gt;    canMakePaymentsUsingNetworks(_:)<br>&gt;&gt;&gt;&gt;    awakeAfterUsingCoder(_:)<br>&gt;&gt;&gt;&gt;    filteredArrayUsingPredicate(_:)<br>&gt;&gt;&gt;&gt;    keysSortedByValueUsingComparator(_:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would become:<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;    data(encoding:)<br>&gt;&gt;&gt;&gt;    connectNode(obstacles:)<br>&gt;&gt;&gt;&gt;    canMakePayments(networks:)<br>&gt;&gt;&gt;&gt;    awakeAfter(coder:)<br>&gt;&gt;&gt;&gt;    filteredArray(predicate:)<br>&gt;&gt;&gt;&gt;    keysSortedByValue(comparator:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn’t dig through the results as much as I’d like, but this makes me *really* want to standardize the name of closure arguments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  -  func sortSubviewsUsing(compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt;  +  func sortSubviews(function compare: @convention(c) (NSView, NSView, UnsafeMutablePointer&lt;Void&gt;) -&gt; ComparisonResult, context: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  func enumerateAvailableRowViewsUsing(handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt;  +  func enumerateAvailableRowViews(block handler: (NSTableRowView, Int) -&gt; Void)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 27 Jan 2016, at 08:50, Douglas Gregor<br>&gt;&gt;&gt;&gt;&gt; &lt;dgregor at apple.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 25, 2016, at 6:55 AM, Radosław Pietruszewski<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;radexpl at gmail.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:radexpl at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m overwhelmingly *for* this proposal. I think removing<br>&gt;&gt;&gt;&gt;&gt;&gt; needless verbosity and keeping the signal-to-noise ratio high is<br>&gt;&gt;&gt;&gt;&gt;&gt; one of the most immediately appealing aspects of Swift, as well<br>&gt;&gt;&gt;&gt;&gt;&gt; as a great general improvement to the programming experience.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And so unswiftified (yes, it’s a word now) APIs from Objective-C<br>&gt;&gt;&gt;&gt;&gt;&gt; stick out like a sore thumb. Not only are they harder to read<br>&gt;&gt;&gt;&gt;&gt;&gt; and write, they visually overwhelm the less verbose,<br>&gt;&gt;&gt;&gt;&gt;&gt; information-dense Swift-first code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just like previous 1.0—2.0 attempts at bridging the gap (with<br>&gt;&gt;&gt;&gt;&gt;&gt; NSError params being translated to Swift errors, factory methods<br>&gt;&gt;&gt;&gt;&gt;&gt; translated to initializers, etc.), automating this will be an<br>&gt;&gt;&gt;&gt;&gt;&gt; error-prone process, and almost bound to be a bit annoying at<br>&gt;&gt;&gt;&gt;&gt;&gt; first, before all the glitches and poor translations are<br>&gt;&gt;&gt;&gt;&gt;&gt; smoothed out. And yet I feel like just like the previous<br>&gt;&gt;&gt;&gt;&gt;&gt; automated translations were overwhelmingly a great thing, so<br>&gt;&gt;&gt;&gt;&gt;&gt; will the result of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * * *<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    Add First Argument Labels<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - func enumerateObjectsWith(_: NSEnumerationOptions = [],<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    + func enumerateObjects(options _: NSEnumerationOptions =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [], using: (AnyObject, UnsafeMutablePointer) -&gt; Void)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Good! The Guidelines recommend an explicit first parameter label<br>&gt;&gt;&gt;&gt;&gt;&gt; for arguments with a default value, but this is a good change<br>&gt;&gt;&gt;&gt;&gt;&gt; also for another reason, a use case not included in the<br>&gt;&gt;&gt;&gt;&gt;&gt; Guidelines (I have more to say about this in the SE-0023<br>&gt;&gt;&gt;&gt;&gt;&gt; thread):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “Options” is the description of the parameter, not the method<br>&gt;&gt;&gt;&gt;&gt;&gt; itself. Even if (for whatever reason!) `options` didn’t have a<br>&gt;&gt;&gt;&gt;&gt;&gt; default value and the word “Options” wasn’t omitted in the<br>&gt;&gt;&gt;&gt;&gt;&gt; translation,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjects(options: …)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would be clearer than<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    enumerateObjectsWithOptions(…)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s not even about the extra word, about the four useless<br>&gt;&gt;&gt;&gt;&gt;&gt; characters, it’s simply that “WithOptions” doesn’t describe the<br>&gt;&gt;&gt;&gt;&gt;&gt; operation at all. It’s a word that conveys no information<br>&gt;&gt;&gt;&gt;&gt;&gt; (“with”), and “options”, which describes the first parameter. In<br>&gt;&gt;&gt;&gt;&gt;&gt; Objective-C, there’s no such thing as parameter labels, it’s all<br>&gt;&gt;&gt;&gt;&gt;&gt; one name, so “With” is used as a separator. But in Swift, making<br>&gt;&gt;&gt;&gt;&gt;&gt; the first parameter’s label explicit just makes more sense.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s an interesting thought! If “with” is truly used as a<br>&gt;&gt;&gt;&gt;&gt; convention for separating the description of the operation from<br>&gt;&gt;&gt;&gt;&gt; the description of the first parameter, that’s something that can<br>&gt;&gt;&gt;&gt;&gt; be codified in the Clang importer. I was curious, so I hacked it<br>&gt;&gt;&gt;&gt;&gt; up. Here’s a diff of the Cocoa APIs that shows what things would<br>&gt;&gt;&gt;&gt;&gt; look like if we treated “with” as a separator:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5/files<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5/files&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s a diff against SE-0005, and it introduces a significant<br>&gt;&gt;&gt;&gt;&gt; number of first argument labels. Indeed, you’ll need to grab the<br>&gt;&gt;&gt;&gt;&gt; patch to see them all:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-3-api-guidelines-review/pull/5.patch&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A brief survey shows that some cases seem to be lining up with<br>&gt;&gt;&gt;&gt;&gt; the guideline proposals that have been under discussion. For<br>&gt;&gt;&gt;&gt;&gt; example, the patch includes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func fillWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; -  func strokeWith(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func fill(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; +  func stroke(blendMode blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func encodeWith(aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; +  func encode(coder aCoder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which you might recognize, because it’s the example you used:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And with that in mind, I object to these translations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fillWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func strokeWith(_: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encodeWith(_: Coder)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Even though these don’t have default values, I believe this<br>&gt;&gt;&gt;&gt;&gt;&gt; version to be clearer and make more sense, even if slightly more<br>&gt;&gt;&gt;&gt;&gt;&gt; verbose:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    func fill(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func stroke(blendMode: CGBlendMode, alpha: CGFloat)<br>&gt;&gt;&gt;&gt;&gt;&gt;    func encode(coder: Coder)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another random interesting example I encountered:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func addArcWithCenter(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; +  func addArc(center center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which seems to match the idea behind Erica’s &quot;semantic relationship between the parameters is stronger than their relation to the operation” (or Paul Cantrell’s similar notion of &quot;the direct object is several args taken together”, which feels more in line with the way the API guidelines are written).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s also this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaType(mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaType mediaType: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -  func tracksWithMediaCharacteristic(mediaCharacteristic: String) -&gt;<br>&gt;&gt;&gt;&gt;&gt; +  func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt; [AVMovieTrack]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which feels reminiscent of Paul’s “resource” example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     service.resource(&quot;/foo&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;)<br>&gt;&gt;&gt;&gt;&gt;     service.resource(absoluteURL: NSURL(string: &quot;http://bar.com &lt;http://bar.com/&gt;&quot;))<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; where (I think) the argument is that the various methods should all have the same base name because they’re all returning “tracks” or a “resource”, respectively.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a ton of data in that patch. I’d be interested to hear whether the resulting Cocoa APIs feel better in Swift—are they following the evolving set of guidelines for first argument labels that are under discussion, and are the resulting APIs clearer/more Swifty? What specific APIs work well and where does this “with-as-separator” heuristic break down?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
