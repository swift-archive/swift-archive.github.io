<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Johannes WeiÃŸ</string> &lt;johannesweiss at apple.com&gt;<p>November  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey swift-evolution,<br></p><p>First of all apologies, this is not a full proposal yet, it&#39;s meant to kick off a discussion on how to resolve the issue.<br></p><p># Make `errno`-setting functions more usable from Swift<br></p><p>## Introduction<br></p><p>This is a pitch to make [`errno`][1]-setting functions properly usable, as in having a guarantee to get the correct `errno` value on failure of a [system call][2]. Currently, functions which set `errno` are just exported in the Darwin/Glibc modules with (as far as I understand) no guaranteed correct way of handling errors as the correct `errno` value can&#39;t be retrieved.<br>This means that much of the Swift code which uses Darwin/Glibc out there relies on behaviour that isn&#39;t guaranteed.<br></p><p><br>## Motivation<br></p><p>In many Swift libraries that use the Darwin/Glibc modules there is code similar to:<br></p><p>```<br>/* import Darwin/Glibc */<br></p><p>let rv = some_system_call(some, parameters)<br>if rv &lt; 0 {<br>   throw SomeError(errorCode: errno) /* &lt;-- errno use */<br>}<br>```<br></p><p>That looks very innocent but please note that `errno` is used here. And `errno` is an interesting one as it&#39;s a thread-local variable which is written to by many functions. A thread-local variable is like a global variable except that setting it in one thread does not affect its value in any other thread. Pretty much all system calls and many library functions set `errno` if something went wrong.<br></p><p>The problem is that as far as I see (and Swift developers have confirmed), there is no guarantee that in between the call of `some_system_call` and the reading of `errno`, `errno` hasn&#39;t been overwritten by some other system call that has been call on the same thread.<br></p><p>To illustrate this further, let&#39;s consider this example<br></p><p>```<br>/* import Darwin/Glibc */<br>public class SomeClass {<br>  public let someValue: Int = 1<br>  deinit {<br>      /* call some failing syscall, for example */<br>      write(-1, nil, 0) /* should set errno to EBADF */<br>  }<br>}<br></p><p>public func foo() {<br>   let x = SomeClass()<br>   let rv = write(x.someValue, nil, 0)<br>   let errnoSave = errno<br>   if rv != 0 {<br>      throw SomeError(errorCode: errnoSave)<br>   }<br>}<br>```<br></p><p>as you see in function `foo`, the instance `x` of `SomeClass` isn&#39;t needed anymore as soon as `write` has been called. So (as far as I understand) there&#39;s no guarantee that ARC doesn&#39;t turn the above code into<br></p><p>```<br>let x = SomeClass()<br>let rv = write(x.someValue, nil, 42) /* should set errno to EFAULT */<br>/* ARC generated */ x.release()<br>let errnoSave = errno /* wrong errno value :( */<br>if rv != 0 {<br>  throw SomeError(errorCode: errnoSave)<br>}<br>```<br></p><p>And the ARC generated `x.release()` will cause `x` to be deallocated which will call the failing `write` in the `deinit` of `SomeClass`. So `errnoSave` might be `EBADF` instead of `EFAULT` depending on where ARC put the `x.release()` call.<br></p><p>What `errno` value we read will depend on the optimisation settings and the Swift compiler version. That&#39;s IMHO a big issue as it might make the lowest layers unstable with hard-to-debug issues.<br></p><p><br>## Proposed solution<br></p><p>I don&#39;t have a full story on how to actually resolve the issue but I see a few options:<br></p><p>### Option 1: always return errno<br></p><p>clang importer could be changed to make all `errno`-setting functions return a tuple of the actual return value and the `errno` value.<br></p><p>For example, currently write(2) is imported as:<br></p><p>```<br>public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; Int<br>```<br></p><p>which could be changed to<br></p><p>```<br> public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; (Int, Int32 /* for errno */)<br>```<br></p><p>Correct code to use write would then look like this:<br></p><p>```<br>let (bytesWritten, writeErrno) = write(fd, buf, len)<br>if bytesWritten &gt;= 0 {<br>   /* everything&#39;s fine */<br>} else {<br>   throw POSIXError(code: writeErrno)<br>}<br>```<br></p><p><br>### Option 2: make them throw<br></p><p>The second option is to teach clang importer to make the functions throwing. So write(2) would be imported as<br></p><p>```<br>public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) throws /* POSIXError */ -&gt; Int<br>```<br></p><p>That would make these functions quite easy to use and would feel natural in Swift:<br></p><p>```<br>do {<br>   let bytesWritten = write(fd, buf, len)<br>} catch let e as POSIXError {<br>   /* handle error */<br>} catch {<br>   ...<br>}<br>```<br></p><p><br>### Discussion<br></p><p>The beauty of option 1 is simplicity. Clang importer would not need to know what exact values a system call returns on failure. Also very little additional code needs to be emitted for calling a system call. That seems to be the [way Go is going][3].<br></p><p>The downside of option 1 is that the API doesn&#39;t feel like idiomatic Swift. The returned `errno` value is only useful if the system call failed and is arbitrary in the case when it worked. (There is no guarantee that `errno` is set to `0` when a system call succeeds.)<br>Also there is a slight overhead in reading `errno` which would be paid for every `errno`-setting function, even if successful. Hence, option 2 looks nice as it brings these functions more in like with other Swift functions. However, as mentioned before, clang importer would need to learn what values are returned on success/failure for _every_ `errno`-setting function (and there&#39;s _many_ of them).<br></p><p><br>## Proposed Approach<br></p><p>Let&#39;s discuss what is a good solution and then I will volunteer to put together a full proposal.<br></p><p><br>## Source compatibility<br></p><p>it depends.<br></p><p>To retain source compatibility the Darwin/Glibc modules could also be left as is. The safe `errno` handling could then be implemented only in a new, unified module for Darwin/Glibc. There&#39;s already ongoing discussions/proposals about that on the list anyway. That new module could then be implemented in the spirit of options 1, 2, or some other solution. The benefits are guaranteed source compatibility for legacy applications and `errno` safety plus easier imports for new applications - win/win ðŸ™‚.<br></p><p><br>## Effect on ABI stability<br></p><p>Will most likely be additive, so probably none.<br></p><p><br>## Effect on API resilience<br></p><p>see source compatibility.<br></p><p><br>## Alternatives considered<br></p><p>Do nothing and workaround `errno` capturing being very hard. I discussed this previously elsewhere and Joe Groff came up with the code below which should convince the optimiser not to insert any release calls at the wrong place or inline the function:<br></p><p>```<br>@inline(never)<br>func callWithErrno(_ fn: () -&gt; Int) -&gt; (result: Int, errno: Int) {<br>   var result: Int<br>   var savedErrno: Int<br>   withExtendedLifetime(fn) {<br>       result = fn()<br>       savedErrno = errno<br>   }<br>   return (result, savedErrno)<br>}<br>```<br></p><p>An example use of that is<br></p><p>```<br>let (rv, writeErrno) = callWithErrno {<br>   write(-1, nil, 0)<br>}<br></p><p>if rv &lt; 0 {<br>   throw SomeError(errorCode: writeErrno)<br>}<br>```<br></p><p>This makes it possible to retrieve the correct `errno` value in Swift but I think there remain too many ways to do it wrongly. First and foremost that the compiler doesn&#39;t complain if the programmer forgets to use `callWithErrno`.<br></p><p>===<br></p><p>Let me know what you think!<br></p><p>[1]: https://en.wikipedia.org/wiki/Errno.h<br>[2]: https://en.wikipedia.org/wiki/System_call<br>[3]: https://golang.org/pkg/syscall/#Write<br></p><p>Many thanks,<br> Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>I could see the &quot;swift_error&quot; Clang attribute being extended with an<br>&quot;errno&quot; case (in the same vein as &quot;nonzero_result&quot; and &quot;zero_result&quot;),<br>which is then reflected into Swift via the importer. Although, having an<br>attribute for methods set errno seems like it would be useful for the<br>Clang Analyzer overall.<br></p><p>Cheers!<br>Â  Zach<br></p><p>On Wed, Nov 2, 2016, at 09:12 AM, Johannes WeiÃŸ via swift-evolution<br>wrote:<br>&gt; Hey swift-evolution,<br>&gt; <br>&gt; First of all apologies, this is not a full proposal yet, it&#39;s meant to<br>&gt; kick off a discussion on how to resolve the issue.<br>&gt; <br>&gt; # Make `errno`-setting functions more usable from Swift<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This is a pitch to make [`errno`][1]-setting functions properly usable,<br>&gt; as in having a guarantee to get the correct `errno` value on failure of a<br>&gt; [system call][2]. Currently, functions which set `errno` are just<br>&gt; exported in the Darwin/Glibc modules with (as far as I understand) no<br>&gt; guaranteed correct way of handling errors as the correct `errno` value<br>&gt; can&#39;t be retrieved.<br>&gt; This means that much of the Swift code which uses Darwin/Glibc out there<br>&gt; relies on behaviour that isn&#39;t guaranteed.<br>&gt; <br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; In many Swift libraries that use the Darwin/Glibc modules there is code<br>&gt; similar to:<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; <br>&gt; let rv = some_system_call(some, parameters)<br>&gt; if rv &lt; 0 {<br>&gt;    throw SomeError(errorCode: errno) /* &lt;-- errno use */<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; That looks very innocent but please note that `errno` is used here. And<br>&gt; `errno` is an interesting one as it&#39;s a thread-local variable which is<br>&gt; written to by many functions. A thread-local variable is like a global<br>&gt; variable except that setting it in one thread does not affect its value<br>&gt; in any other thread. Pretty much all system calls and many library<br>&gt; functions set `errno` if something went wrong.<br>&gt; <br>&gt; The problem is that as far as I see (and Swift developers have<br>&gt; confirmed), there is no guarantee that in between the call of<br>&gt; `some_system_call` and the reading of `errno`, `errno` hasn&#39;t been<br>&gt; overwritten by some other system call that has been call on the same<br>&gt; thread.<br>&gt; <br>&gt; To illustrate this further, let&#39;s consider this example<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; public class SomeClass {<br>&gt;   public let someValue: Int = 1<br>&gt;   deinit {<br>&gt;       /* call some failing syscall, for example */<br>&gt;       write(-1, nil, 0) /* should set errno to EBADF */<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public func foo() {<br>&gt;    let x = SomeClass()<br>&gt;    let rv = write(x.someValue, nil, 0)<br>&gt;    let errnoSave = errno<br>&gt;    if rv != 0 {<br>&gt;       throw SomeError(errorCode: errnoSave)<br>&gt;    }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; as you see in function `foo`, the instance `x` of `SomeClass` isn&#39;t<br>&gt; needed anymore as soon as `write` has been called. So (as far as I<br>&gt; understand) there&#39;s no guarantee that ARC doesn&#39;t turn the above code<br>&gt; into<br>&gt; <br>&gt; ```<br>&gt; let x = SomeClass()<br>&gt; let rv = write(x.someValue, nil, 42) /* should set errno to EFAULT */<br>&gt; /* ARC generated */ x.release()<br>&gt; let errnoSave = errno /* wrong errno value :( */<br>&gt; if rv != 0 {<br>&gt;   throw SomeError(errorCode: errnoSave)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; And the ARC generated `x.release()` will cause `x` to be deallocated<br>&gt; which will call the failing `write` in the `deinit` of `SomeClass`. So<br>&gt; `errnoSave` might be `EBADF` instead of `EFAULT` depending on where ARC<br>&gt; put the `x.release()` call.<br>&gt; <br>&gt; What `errno` value we read will depend on the optimisation settings and<br>&gt; the Swift compiler version. That&#39;s IMHO a big issue as it might make the<br>&gt; lowest layers unstable with hard-to-debug issues.<br>&gt; <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I don&#39;t have a full story on how to actually resolve the issue but I see<br>&gt; a few options:<br>&gt; <br>&gt; ### Option 1: always return errno<br>&gt; <br>&gt; clang importer could be changed to make all `errno`-setting functions<br>&gt; return a tuple of the actual return value and the `errno` value.<br>&gt; <br>&gt; For example, currently write(2) is imported as:<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte:<br>&gt; Int) -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; which could be changed to<br>&gt; <br>&gt; ```<br>&gt;  public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte:<br>&gt;  Int) -&gt; (Int, Int32 /* for errno */)<br>&gt; ```<br>&gt; <br>&gt; Correct code to use write would then look like this:<br>&gt; <br>&gt; ```<br>&gt; let (bytesWritten, writeErrno) = write(fd, buf, len)<br>&gt; if bytesWritten &gt;= 0 {<br>&gt;    /* everything&#39;s fine */<br>&gt; } else {<br>&gt;    throw POSIXError(code: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Option 2: make them throw<br>&gt; <br>&gt; The second option is to teach clang importer to make the functions<br>&gt; throwing. So write(2) would be imported as<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte:<br>&gt; Int) throws /* POSIXError */ -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; That would make these functions quite easy to use and would feel natural<br>&gt; in Swift:<br>&gt; <br>&gt; ```<br>&gt; do {<br>&gt;    let bytesWritten = write(fd, buf, len)<br>&gt; } catch let e as POSIXError {<br>&gt;    /* handle error */<br>&gt; } catch {<br>&gt;    ...<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Discussion<br>&gt; <br>&gt; The beauty of option 1 is simplicity. Clang importer would not need to<br>&gt; know what exact values a system call returns on failure. Also very little<br>&gt; additional code needs to be emitted for calling a system call. That seems<br>&gt; to be the [way Go is going][3].<br>&gt; <br>&gt; The downside of option 1 is that the API doesn&#39;t feel like idiomatic<br>&gt; Swift. The returned `errno` value is only useful if the system call<br>&gt; failed and is arbitrary in the case when it worked. (There is no<br>&gt; guarantee that `errno` is set to `0` when a system call succeeds.)<br>&gt; Also there is a slight overhead in reading `errno` which would be paid<br>&gt; for every `errno`-setting function, even if successful. Hence, option 2<br>&gt; looks nice as it brings these functions more in like with other Swift<br>&gt; functions. However, as mentioned before, clang importer would need to<br>&gt; learn what values are returned on success/failure for _every_<br>&gt; `errno`-setting function (and there&#39;s _many_ of them).<br>&gt; <br>&gt; <br>&gt; ## Proposed Approach<br>&gt; <br>&gt; Let&#39;s discuss what is a good solution and then I will volunteer to put<br>&gt; together a full proposal.<br>&gt; <br>&gt; <br>&gt; ## Source compatibility<br>&gt; <br>&gt; it depends.<br>&gt; <br>&gt; To retain source compatibility the Darwin/Glibc modules could also be<br>&gt; left as is. The safe `errno` handling could then be implemented only in a<br>&gt; new, unified module for Darwin/Glibc. There&#39;s already ongoing<br>&gt; discussions/proposals about that on the list anyway. That new module<br>&gt; could then be implemented in the spirit of options 1, 2, or some other<br>&gt; solution. The benefits are guaranteed source compatibility for legacy<br>&gt; applications and `errno` safety plus easier imports for new applications<br>&gt; - win/win ðŸ™‚.<br>&gt; <br>&gt; <br>&gt; ## Effect on ABI stability<br>&gt; <br>&gt; Will most likely be additive, so probably none.<br>&gt; <br>&gt; <br>&gt; ## Effect on API resilience<br>&gt; <br>&gt; see source compatibility.<br>&gt; <br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Do nothing and workaround `errno` capturing being very hard. I discussed<br>&gt; this previously elsewhere and Joe Groff came up with the code below which<br>&gt; should convince the optimiser not to insert any release calls at the<br>&gt; wrong place or inline the function:<br>&gt; <br>&gt; ```<br>&gt; @inline(never)<br>&gt; func callWithErrno(_ fn: () -&gt; Int) -&gt; (result: Int, errno: Int) {<br>&gt;    var result: Int<br>&gt;    var savedErrno: Int<br>&gt;    withExtendedLifetime(fn) {<br>&gt;        result = fn()<br>&gt;        savedErrno = errno<br>&gt;    }<br>&gt;    return (result, savedErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; An example use of that is<br>&gt; <br>&gt; ```<br>&gt; let (rv, writeErrno) = callWithErrno {<br>&gt;    write(-1, nil, 0)<br>&gt; }<br>&gt; <br>&gt; if rv &lt; 0 {<br>&gt;    throw SomeError(errorCode: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This makes it possible to retrieve the correct `errno` value in Swift but<br>&gt; I think there remain too many ways to do it wrongly. First and foremost<br>&gt; that the compiler doesn&#39;t complain if the programmer forgets to use<br>&gt; `callWithErrno`.<br>&gt; <br>&gt; ===<br>&gt; <br>&gt; Let me know what you think!<br>&gt; <br>&gt; [1]: https://en.wikipedia.org/wiki/Errno.h<br>&gt; [2]: https://en.wikipedia.org/wiki/System_call<br>&gt; [3]: https://golang.org/pkg/syscall/#Write<br>&gt; <br>&gt; Many thanks,<br>&gt;  Johannes<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 6:12 AM, Johannes WeiÃŸ via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hey swift-evolution,<br>&gt; <br>&gt; First of all apologies, this is not a full proposal yet, it&#39;s meant to kick off a discussion on how to resolve the issue.<br>&gt; <br>&gt; # Make `errno`-setting functions more usable from Swift<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This is a pitch to make [`errno`][1]-setting functions properly usable, as in having a guarantee to get the correct `errno` value on failure of a [system call][2]. Currently, functions which set `errno` are just exported in the Darwin/Glibc modules with (as far as I understand) no guaranteed correct way of handling errors as the correct `errno` value can&#39;t be retrieved.<br>&gt; This means that much of the Swift code which uses Darwin/Glibc out there relies on behaviour that isn&#39;t guaranteed.<br></p><p>Is this a general enough problem to be worth complicating the importer with vs., say, just manually wrapping the POSIX APIs to be throwing in an overlay?  POSIX uses a lot of different conventions for reporting that an error occurred, and there&#39;s only a finite set of POSIX APIs.  Are there &quot;user&quot; functions that wrap POSIX and carefully report errors with errno?<br></p><p>John.<br></p><p><br>&gt; <br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; In many Swift libraries that use the Darwin/Glibc modules there is code similar to:<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; <br>&gt; let rv = some_system_call(some, parameters)<br>&gt; if rv &lt; 0 {<br>&gt;   throw SomeError(errorCode: errno) /* &lt;-- errno use */<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; That looks very innocent but please note that `errno` is used here. And `errno` is an interesting one as it&#39;s a thread-local variable which is written to by many functions. A thread-local variable is like a global variable except that setting it in one thread does not affect its value in any other thread. Pretty much all system calls and many library functions set `errno` if something went wrong.<br>&gt; <br>&gt; The problem is that as far as I see (and Swift developers have confirmed), there is no guarantee that in between the call of `some_system_call` and the reading of `errno`, `errno` hasn&#39;t been overwritten by some other system call that has been call on the same thread.<br>&gt; <br>&gt; To illustrate this further, let&#39;s consider this example<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; public class SomeClass {<br>&gt;  public let someValue: Int = 1<br>&gt;  deinit {<br>&gt;      /* call some failing syscall, for example */<br>&gt;      write(-1, nil, 0) /* should set errno to EBADF */<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; public func foo() {<br>&gt;   let x = SomeClass()<br>&gt;   let rv = write(x.someValue, nil, 0)<br>&gt;   let errnoSave = errno<br>&gt;   if rv != 0 {<br>&gt;      throw SomeError(errorCode: errnoSave)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; as you see in function `foo`, the instance `x` of `SomeClass` isn&#39;t needed anymore as soon as `write` has been called. So (as far as I understand) there&#39;s no guarantee that ARC doesn&#39;t turn the above code into<br>&gt; <br>&gt; ```<br>&gt; let x = SomeClass()<br>&gt; let rv = write(x.someValue, nil, 42) /* should set errno to EFAULT */<br>&gt; /* ARC generated */ x.release()<br>&gt; let errnoSave = errno /* wrong errno value :( */<br>&gt; if rv != 0 {<br>&gt;  throw SomeError(errorCode: errnoSave)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; And the ARC generated `x.release()` will cause `x` to be deallocated which will call the failing `write` in the `deinit` of `SomeClass`. So `errnoSave` might be `EBADF` instead of `EFAULT` depending on where ARC put the `x.release()` call.<br>&gt; <br>&gt; What `errno` value we read will depend on the optimisation settings and the Swift compiler version. That&#39;s IMHO a big issue as it might make the lowest layers unstable with hard-to-debug issues.<br>&gt; <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I don&#39;t have a full story on how to actually resolve the issue but I see a few options:<br>&gt; <br>&gt; ### Option 1: always return errno<br>&gt; <br>&gt; clang importer could be changed to make all `errno`-setting functions return a tuple of the actual return value and the `errno` value.<br>&gt; <br>&gt; For example, currently write(2) is imported as:<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; which could be changed to<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; (Int, Int32 /* for errno */)<br>&gt; ```<br>&gt; <br>&gt; Correct code to use write would then look like this:<br>&gt; <br>&gt; ```<br>&gt; let (bytesWritten, writeErrno) = write(fd, buf, len)<br>&gt; if bytesWritten &gt;= 0 {<br>&gt;   /* everything&#39;s fine */<br>&gt; } else {<br>&gt;   throw POSIXError(code: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Option 2: make them throw<br>&gt; <br>&gt; The second option is to teach clang importer to make the functions throwing. So write(2) would be imported as<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) throws /* POSIXError */ -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; That would make these functions quite easy to use and would feel natural in Swift:<br>&gt; <br>&gt; ```<br>&gt; do {<br>&gt;   let bytesWritten = write(fd, buf, len)<br>&gt; } catch let e as POSIXError {<br>&gt;   /* handle error */<br>&gt; } catch {<br>&gt;   ...<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Discussion<br>&gt; <br>&gt; The beauty of option 1 is simplicity. Clang importer would not need to know what exact values a system call returns on failure. Also very little additional code needs to be emitted for calling a system call. That seems to be the [way Go is going][3].<br>&gt; <br>&gt; The downside of option 1 is that the API doesn&#39;t feel like idiomatic Swift. The returned `errno` value is only useful if the system call failed and is arbitrary in the case when it worked. (There is no guarantee that `errno` is set to `0` when a system call succeeds.)<br>&gt; Also there is a slight overhead in reading `errno` which would be paid for every `errno`-setting function, even if successful. Hence, option 2 looks nice as it brings these functions more in like with other Swift functions. However, as mentioned before, clang importer would need to learn what values are returned on success/failure for _every_ `errno`-setting function (and there&#39;s _many_ of them).<br>&gt; <br>&gt; <br>&gt; ## Proposed Approach<br>&gt; <br>&gt; Let&#39;s discuss what is a good solution and then I will volunteer to put together a full proposal.<br>&gt; <br>&gt; <br>&gt; ## Source compatibility<br>&gt; <br>&gt; it depends.<br>&gt; <br>&gt; To retain source compatibility the Darwin/Glibc modules could also be left as is. The safe `errno` handling could then be implemented only in a new, unified module for Darwin/Glibc. There&#39;s already ongoing discussions/proposals about that on the list anyway. That new module could then be implemented in the spirit of options 1, 2, or some other solution. The benefits are guaranteed source compatibility for legacy applications and `errno` safety plus easier imports for new applications - win/win ðŸ™‚.<br>&gt; <br>&gt; <br>&gt; ## Effect on ABI stability<br>&gt; <br>&gt; Will most likely be additive, so probably none.<br>&gt; <br>&gt; <br>&gt; ## Effect on API resilience<br>&gt; <br>&gt; see source compatibility.<br>&gt; <br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Do nothing and workaround `errno` capturing being very hard. I discussed this previously elsewhere and Joe Groff came up with the code below which should convince the optimiser not to insert any release calls at the wrong place or inline the function:<br>&gt; <br>&gt; ```<br>&gt; @inline(never)<br>&gt; func callWithErrno(_ fn: () -&gt; Int) -&gt; (result: Int, errno: Int) {<br>&gt;   var result: Int<br>&gt;   var savedErrno: Int<br>&gt;   withExtendedLifetime(fn) {<br>&gt;       result = fn()<br>&gt;       savedErrno = errno<br>&gt;   }<br>&gt;   return (result, savedErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; An example use of that is<br>&gt; <br>&gt; ```<br>&gt; let (rv, writeErrno) = callWithErrno {<br>&gt;   write(-1, nil, 0)<br>&gt; }<br>&gt; <br>&gt; if rv &lt; 0 {<br>&gt;   throw SomeError(errorCode: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This makes it possible to retrieve the correct `errno` value in Swift but I think there remain too many ways to do it wrongly. First and foremost that the compiler doesn&#39;t complain if the programmer forgets to use `callWithErrno`.<br>&gt; <br>&gt; ===<br>&gt; <br>&gt; Let me know what you think!<br>&gt; <br>&gt; [1]: https://en.wikipedia.org/wiki/Errno.h<br>&gt; [2]: https://en.wikipedia.org/wiki/System_call<br>&gt; [3]: https://golang.org/pkg/syscall/#Write<br>&gt; <br>&gt; Many thanks,<br>&gt; Johannes<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Johannes WeiÃŸ</string> &lt;johannesweiss at apple.com&gt;<p>November  3, 2016 at 10:00:00am</p></header><div class="content"><p>Hi John,<br></p><p>&gt; [...]<br>&gt;&gt; This is a pitch to make [`errno`][1]-setting functions properly usable, as in having a guarantee to get the correct `errno` value on failure of a [system call][2]. Currently, functions which set `errno` are just exported in the Darwin/Glibc modules with (as far as I understand) no guaranteed correct way of handling errors as the correct `errno` value can&#39;t be retrieved.<br>&gt;&gt; This means that much of the Swift code which uses Darwin/Glibc out there relies on behaviour that isn&#39;t guaranteed.<br>&gt; <br>&gt; Is this a general enough problem to be worth complicating the importer with vs., say, just manually wrapping the POSIX APIs to be throwing in an overlay?  POSIX uses a lot of different conventions for reporting that an error occurred, and there&#39;s only a finite set of POSIX APIs. Are there &quot;user&quot; functions that wrap POSIX and carefully report errors with errno?<br></p><p>That&#39;s a very good point. I&#39;m sure there are &quot;user libraries&quot; out there which set errno but I&#39;d hope that it&#39;s a fairly limited set. So I think an overlay that ships with Swift and makes the underlying module unavailable would be fine by me. Something like the Dispatch module (which uses the &quot;hidden&quot; CDispatch module internally) sounds reasonable to me.<br></p><p>The reason I proposed to include that into the clang importer is because the Darwin/Glibc modules contain hundreds (I haven&#39;t counted) of functions (syscall and library functions) that set errno. And I assumed that if it can be done automatically we could leverage that.<br></p><p><br>&gt; [...]<br></p><p>Thanks,<br>  Johannes<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Johannes WeiÃŸ</string> &lt;johannesweiss at apple.com&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I just realised, that the problem is slightly worse than I originally described. I believed that successful calls in between the actual call the programmer wanted to make and capturing `errno` are not a problem.<br></p><p>But POSIX seems to suggest [4] that &quot;The setting of errno after a successful call to a function is unspecified unless the description of that function specifies that errno shall not be modified.&quot; . The Linux man page [5] also mentions that &quot;a function that succeeds is allowed to change errno.&quot;<br></p><p>To me this means that the issue is wider than just ARC. I think the problem extends to memory allocations on the heap. Failed memory allocations aren&#39;t a problem because they are terminal in Swift. However, _successful_ memory allocations might be a problem because the malloc(3) that the Swift compiler will use is absolutely free to set errno to 0 (or any other value in fact) indicating success. (Said that at least malloc doesn&#39;t change `errno` on the macOS or Linux I tested today, we probably shouldn&#39;t rely on that though.)<br></p><p>This makes it even more unpredictable to the programmer what a use of `errno` in Swift will return. IMHO it shouldn&#39;t be exported to Swift as its value is undefined almost(?) everywhere.<br></p><p>[4]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html<br>[5]: http://man7.org/linux/man-pages/man3/errno.3.html<br></p><p>All the best,<br>  Johannes<br></p><p>&gt; On 2 Nov 2016, at 1:12 pm, Johannes WeiÃŸ via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey swift-evolution,<br>&gt; <br>&gt; First of all apologies, this is not a full proposal yet, it&#39;s meant to kick off a discussion on how to resolve the issue.<br>&gt; <br>&gt; # Make `errno`-setting functions more usable from Swift<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This is a pitch to make [`errno`][1]-setting functions properly usable, as in having a guarantee to get the correct `errno` value on failure of a [system call][2]. Currently, functions which set `errno` are just exported in the Darwin/Glibc modules with (as far as I understand) no guaranteed correct way of handling errors as the correct `errno` value can&#39;t be retrieved.<br>&gt; This means that much of the Swift code which uses Darwin/Glibc out there relies on behaviour that isn&#39;t guaranteed.<br>&gt; <br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; In many Swift libraries that use the Darwin/Glibc modules there is code similar to:<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; <br>&gt; let rv = some_system_call(some, parameters)<br>&gt; if rv &lt; 0 {<br>&gt;   throw SomeError(errorCode: errno) /* &lt;-- errno use */<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; That looks very innocent but please note that `errno` is used here. And `errno` is an interesting one as it&#39;s a thread-local variable which is written to by many functions. A thread-local variable is like a global variable except that setting it in one thread does not affect its value in any other thread. Pretty much all system calls and many library functions set `errno` if something went wrong.<br>&gt; <br>&gt; The problem is that as far as I see (and Swift developers have confirmed), there is no guarantee that in between the call of `some_system_call` and the reading of `errno`, `errno` hasn&#39;t been overwritten by some other system call that has been call on the same thread.<br>&gt; <br>&gt; To illustrate this further, let&#39;s consider this example<br>&gt; <br>&gt; ```<br>&gt; /* import Darwin/Glibc */<br>&gt; public class SomeClass {<br>&gt;  public let someValue: Int = 1<br>&gt;  deinit {<br>&gt;      /* call some failing syscall, for example */<br>&gt;      write(-1, nil, 0) /* should set errno to EBADF */<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; public func foo() {<br>&gt;   let x = SomeClass()<br>&gt;   let rv = write(x.someValue, nil, 0)<br>&gt;   let errnoSave = errno<br>&gt;   if rv != 0 {<br>&gt;      throw SomeError(errorCode: errnoSave)<br>&gt;   }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; as you see in function `foo`, the instance `x` of `SomeClass` isn&#39;t needed anymore as soon as `write` has been called. So (as far as I understand) there&#39;s no guarantee that ARC doesn&#39;t turn the above code into<br>&gt; <br>&gt; ```<br>&gt; let x = SomeClass()<br>&gt; let rv = write(x.someValue, nil, 42) /* should set errno to EFAULT */<br>&gt; /* ARC generated */ x.release()<br>&gt; let errnoSave = errno /* wrong errno value :( */<br>&gt; if rv != 0 {<br>&gt;  throw SomeError(errorCode: errnoSave)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; And the ARC generated `x.release()` will cause `x` to be deallocated which will call the failing `write` in the `deinit` of `SomeClass`. So `errnoSave` might be `EBADF` instead of `EFAULT` depending on where ARC put the `x.release()` call.<br>&gt; <br>&gt; What `errno` value we read will depend on the optimisation settings and the Swift compiler version. That&#39;s IMHO a big issue as it might make the lowest layers unstable with hard-to-debug issues.<br>&gt; <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; I don&#39;t have a full story on how to actually resolve the issue but I see a few options:<br>&gt; <br>&gt; ### Option 1: always return errno<br>&gt; <br>&gt; clang importer could be changed to make all `errno`-setting functions return a tuple of the actual return value and the `errno` value.<br>&gt; <br>&gt; For example, currently write(2) is imported as:<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; which could be changed to<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; (Int, Int32 /* for errno */)<br>&gt; ```<br>&gt; <br>&gt; Correct code to use write would then look like this:<br>&gt; <br>&gt; ```<br>&gt; let (bytesWritten, writeErrno) = write(fd, buf, len)<br>&gt; if bytesWritten &gt;= 0 {<br>&gt;   /* everything&#39;s fine */<br>&gt; } else {<br>&gt;   throw POSIXError(code: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Option 2: make them throw<br>&gt; <br>&gt; The second option is to teach clang importer to make the functions throwing. So write(2) would be imported as<br>&gt; <br>&gt; ```<br>&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) throws /* POSIXError */ -&gt; Int<br>&gt; ```<br>&gt; <br>&gt; That would make these functions quite easy to use and would feel natural in Swift:<br>&gt; <br>&gt; ```<br>&gt; do {<br>&gt;   let bytesWritten = write(fd, buf, len)<br>&gt; } catch let e as POSIXError {<br>&gt;   /* handle error */<br>&gt; } catch {<br>&gt;   ...<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; ### Discussion<br>&gt; <br>&gt; The beauty of option 1 is simplicity. Clang importer would not need to know what exact values a system call returns on failure. Also very little additional code needs to be emitted for calling a system call. That seems to be the [way Go is going][3].<br>&gt; <br>&gt; The downside of option 1 is that the API doesn&#39;t feel like idiomatic Swift. The returned `errno` value is only useful if the system call failed and is arbitrary in the case when it worked. (There is no guarantee that `errno` is set to `0` when a system call succeeds.)<br>&gt; Also there is a slight overhead in reading `errno` which would be paid for every `errno`-setting function, even if successful. Hence, option 2 looks nice as it brings these functions more in like with other Swift functions. However, as mentioned before, clang importer would need to learn what values are returned on success/failure for _every_ `errno`-setting function (and there&#39;s _many_ of them).<br>&gt; <br>&gt; <br>&gt; ## Proposed Approach<br>&gt; <br>&gt; Let&#39;s discuss what is a good solution and then I will volunteer to put together a full proposal.<br>&gt; <br>&gt; <br>&gt; ## Source compatibility<br>&gt; <br>&gt; it depends.<br>&gt; <br>&gt; To retain source compatibility the Darwin/Glibc modules could also be left as is. The safe `errno` handling could then be implemented only in a new, unified module for Darwin/Glibc. There&#39;s already ongoing discussions/proposals about that on the list anyway. That new module could then be implemented in the spirit of options 1, 2, or some other solution. The benefits are guaranteed source compatibility for legacy applications and `errno` safety plus easier imports for new applications - win/win ðŸ™‚.<br>&gt; <br>&gt; <br>&gt; ## Effect on ABI stability<br>&gt; <br>&gt; Will most likely be additive, so probably none.<br>&gt; <br>&gt; <br>&gt; ## Effect on API resilience<br>&gt; <br>&gt; see source compatibility.<br>&gt; <br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Do nothing and workaround `errno` capturing being very hard. I discussed this previously elsewhere and Joe Groff came up with the code below which should convince the optimiser not to insert any release calls at the wrong place or inline the function:<br>&gt; <br>&gt; ```<br>&gt; @inline(never)<br>&gt; func callWithErrno(_ fn: () -&gt; Int) -&gt; (result: Int, errno: Int) {<br>&gt;   var result: Int<br>&gt;   var savedErrno: Int<br>&gt;   withExtendedLifetime(fn) {<br>&gt;       result = fn()<br>&gt;       savedErrno = errno<br>&gt;   }<br>&gt;   return (result, savedErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; An example use of that is<br>&gt; <br>&gt; ```<br>&gt; let (rv, writeErrno) = callWithErrno {<br>&gt;   write(-1, nil, 0)<br>&gt; }<br>&gt; <br>&gt; if rv &lt; 0 {<br>&gt;   throw SomeError(errorCode: writeErrno)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This makes it possible to retrieve the correct `errno` value in Swift but I think there remain too many ways to do it wrongly. First and foremost that the compiler doesn&#39;t complain if the programmer forgets to use `callWithErrno`.<br>&gt; <br>&gt; ===<br>&gt; <br>&gt; Let me know what you think!<br>&gt; <br>&gt; [1]: https://en.wikipedia.org/wiki/Errno.h<br>&gt; [2]: https://en.wikipedia.org/wiki/System_call<br>&gt; [3]: https://golang.org/pkg/syscall/#Write<br>&gt; <br>&gt; Many thanks,<br>&gt; Johannes<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>I hope we get an answer from the core team as it seems something they must have considered already. Sounds serious.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 4 Nov 2016, at 08:12, Johannes WeiÃŸ via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I just realised, that the problem is slightly worse than I originally described. I believed that successful calls in between the actual call the programmer wanted to make and capturing `errno` are not a problem.<br>&gt; <br>&gt; But POSIX seems to suggest [4] that &quot;The setting of errno after a successful call to a function is unspecified unless the description of that function specifies that errno shall not be modified.&quot; . The Linux man page [5] also mentions that &quot;a function that succeeds is allowed to change errno.&quot;<br>&gt; <br>&gt; To me this means that the issue is wider than just ARC. I think the problem extends to memory allocations on the heap. Failed memory allocations aren&#39;t a problem because they are terminal in Swift. However, _successful_ memory allocations might be a problem because the malloc(3) that the Swift compiler will use is absolutely free to set errno to 0 (or any other value in fact) indicating success. (Said that at least malloc doesn&#39;t change `errno` on the macOS or Linux I tested today, we probably shouldn&#39;t rely on that though.)<br>&gt; <br>&gt; This makes it even more unpredictable to the programmer what a use of `errno` in Swift will return. IMHO it shouldn&#39;t be exported to Swift as its value is undefined almost(?) everywhere.<br>&gt; <br>&gt; [4]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html<br>&gt; [5]: http://man7.org/linux/man-pages/man3/errno.3.html<br>&gt; <br>&gt; All the best,<br>&gt;  Johannes<br>&gt; <br>&gt;&gt; On 2 Nov 2016, at 1:12 pm, Johannes WeiÃŸ via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey swift-evolution,<br>&gt;&gt; <br>&gt;&gt; First of all apologies, this is not a full proposal yet, it&#39;s meant to kick off a discussion on how to resolve the issue.<br>&gt;&gt; <br>&gt;&gt; # Make `errno`-setting functions more usable from Swift<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; This is a pitch to make [`errno`][1]-setting functions properly usable, as in having a guarantee to get the correct `errno` value on failure of a [system call][2]. Currently, functions which set `errno` are just exported in the Darwin/Glibc modules with (as far as I understand) no guaranteed correct way of handling errors as the correct `errno` value can&#39;t be retrieved.<br>&gt;&gt; This means that much of the Swift code which uses Darwin/Glibc out there relies on behaviour that isn&#39;t guaranteed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; In many Swift libraries that use the Darwin/Glibc modules there is code similar to:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; /* import Darwin/Glibc */<br>&gt;&gt; <br>&gt;&gt; let rv = some_system_call(some, parameters)<br>&gt;&gt; if rv &lt; 0 {<br>&gt;&gt;  throw SomeError(errorCode: errno) /* &lt;-- errno use */<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; That looks very innocent but please note that `errno` is used here. And `errno` is an interesting one as it&#39;s a thread-local variable which is written to by many functions. A thread-local variable is like a global variable except that setting it in one thread does not affect its value in any other thread. Pretty much all system calls and many library functions set `errno` if something went wrong.<br>&gt;&gt; <br>&gt;&gt; The problem is that as far as I see (and Swift developers have confirmed), there is no guarantee that in between the call of `some_system_call` and the reading of `errno`, `errno` hasn&#39;t been overwritten by some other system call that has been call on the same thread.<br>&gt;&gt; <br>&gt;&gt; To illustrate this further, let&#39;s consider this example<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; /* import Darwin/Glibc */<br>&gt;&gt; public class SomeClass {<br>&gt;&gt; public let someValue: Int = 1<br>&gt;&gt; deinit {<br>&gt;&gt;     /* call some failing syscall, for example */<br>&gt;&gt;     write(-1, nil, 0) /* should set errno to EBADF */<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func foo() {<br>&gt;&gt;  let x = SomeClass()<br>&gt;&gt;  let rv = write(x.someValue, nil, 0)<br>&gt;&gt;  let errnoSave = errno<br>&gt;&gt;  if rv != 0 {<br>&gt;&gt;     throw SomeError(errorCode: errnoSave)<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; as you see in function `foo`, the instance `x` of `SomeClass` isn&#39;t needed anymore as soon as `write` has been called. So (as far as I understand) there&#39;s no guarantee that ARC doesn&#39;t turn the above code into<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let x = SomeClass()<br>&gt;&gt; let rv = write(x.someValue, nil, 42) /* should set errno to EFAULT */<br>&gt;&gt; /* ARC generated */ x.release()<br>&gt;&gt; let errnoSave = errno /* wrong errno value :( */<br>&gt;&gt; if rv != 0 {<br>&gt;&gt; throw SomeError(errorCode: errnoSave)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; And the ARC generated `x.release()` will cause `x` to be deallocated which will call the failing `write` in the `deinit` of `SomeClass`. So `errnoSave` might be `EBADF` instead of `EFAULT` depending on where ARC put the `x.release()` call.<br>&gt;&gt; <br>&gt;&gt; What `errno` value we read will depend on the optimisation settings and the Swift compiler version. That&#39;s IMHO a big issue as it might make the lowest layers unstable with hard-to-debug issues.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; I don&#39;t have a full story on how to actually resolve the issue but I see a few options:<br>&gt;&gt; <br>&gt;&gt; ### Option 1: always return errno<br>&gt;&gt; <br>&gt;&gt; clang importer could be changed to make all `errno`-setting functions return a tuple of the actual return value and the `errno` value.<br>&gt;&gt; <br>&gt;&gt; For example, currently write(2) is imported as:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; Int<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; which could be changed to<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) -&gt; (Int, Int32 /* for errno */)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Correct code to use write would then look like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let (bytesWritten, writeErrno) = write(fd, buf, len)<br>&gt;&gt; if bytesWritten &gt;= 0 {<br>&gt;&gt;  /* everything&#39;s fine */<br>&gt;&gt; } else {<br>&gt;&gt;  throw POSIXError(code: writeErrno)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ### Option 2: make them throw<br>&gt;&gt; <br>&gt;&gt; The second option is to teach clang importer to make the functions throwing. So write(2) would be imported as<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public func write(_ __fd: Int32, _ __buf: UnsafeRawPointer!, _ __nbyte: Int) throws /* POSIXError */ -&gt; Int<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; That would make these functions quite easy to use and would feel natural in Swift:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; do {<br>&gt;&gt;  let bytesWritten = write(fd, buf, len)<br>&gt;&gt; } catch let e as POSIXError {<br>&gt;&gt;  /* handle error */<br>&gt;&gt; } catch {<br>&gt;&gt;  ...<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ### Discussion<br>&gt;&gt; <br>&gt;&gt; The beauty of option 1 is simplicity. Clang importer would not need to know what exact values a system call returns on failure. Also very little additional code needs to be emitted for calling a system call. That seems to be the [way Go is going][3].<br>&gt;&gt; <br>&gt;&gt; The downside of option 1 is that the API doesn&#39;t feel like idiomatic Swift. The returned `errno` value is only useful if the system call failed and is arbitrary in the case when it worked. (There is no guarantee that `errno` is set to `0` when a system call succeeds.)<br>&gt;&gt; Also there is a slight overhead in reading `errno` which would be paid for every `errno`-setting function, even if successful. Hence, option 2 looks nice as it brings these functions more in like with other Swift functions. However, as mentioned before, clang importer would need to learn what values are returned on success/failure for _every_ `errno`-setting function (and there&#39;s _many_ of them).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Proposed Approach<br>&gt;&gt; <br>&gt;&gt; Let&#39;s discuss what is a good solution and then I will volunteer to put together a full proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Source compatibility<br>&gt;&gt; <br>&gt;&gt; it depends.<br>&gt;&gt; <br>&gt;&gt; To retain source compatibility the Darwin/Glibc modules could also be left as is. The safe `errno` handling could then be implemented only in a new, unified module for Darwin/Glibc. There&#39;s already ongoing discussions/proposals about that on the list anyway. That new module could then be implemented in the spirit of options 1, 2, or some other solution. The benefits are guaranteed source compatibility for legacy applications and `errno` safety plus easier imports for new applications - win/win ðŸ™‚.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Effect on ABI stability<br>&gt;&gt; <br>&gt;&gt; Will most likely be additive, so probably none.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Effect on API resilience<br>&gt;&gt; <br>&gt;&gt; see source compatibility.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Do nothing and workaround `errno` capturing being very hard. I discussed this previously elsewhere and Joe Groff came up with the code below which should convince the optimiser not to insert any release calls at the wrong place or inline the function:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; @inline(never)<br>&gt;&gt; func callWithErrno(_ fn: () -&gt; Int) -&gt; (result: Int, errno: Int) {<br>&gt;&gt;  var result: Int<br>&gt;&gt;  var savedErrno: Int<br>&gt;&gt;  withExtendedLifetime(fn) {<br>&gt;&gt;      result = fn()<br>&gt;&gt;      savedErrno = errno<br>&gt;&gt;  }<br>&gt;&gt;  return (result, savedErrno)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; An example use of that is<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; let (rv, writeErrno) = callWithErrno {<br>&gt;&gt;  write(-1, nil, 0)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; if rv &lt; 0 {<br>&gt;&gt;  throw SomeError(errorCode: writeErrno)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This makes it possible to retrieve the correct `errno` value in Swift but I think there remain too many ways to do it wrongly. First and foremost that the compiler doesn&#39;t complain if the programmer forgets to use `callWithErrno`.<br>&gt;&gt; <br>&gt;&gt; ===<br>&gt;&gt; <br>&gt;&gt; Let me know what you think!<br>&gt;&gt; <br>&gt;&gt; [1]: https://en.wikipedia.org/wiki/Errno.h<br>&gt;&gt; [2]: https://en.wikipedia.org/wiki/System_call<br>&gt;&gt; [3]: https://golang.org/pkg/syscall/#Write<br>&gt;&gt; <br>&gt;&gt; Many thanks,<br>&gt;&gt; Johannes<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 1:12 AM, Johannes WeiÃŸ &lt;johannesweiss at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I just realised, that the problem is slightly worse than I originally described. I believed that successful calls in between the actual call the programmer wanted to make and capturing `errno` are not a problem.<br>&gt; <br>&gt; But POSIX seems to suggest [4] that &quot;The setting of errno after a successful call to a function is unspecified unless the description of that function specifies that errno shall not be modified.&quot; . The Linux man page [5] also mentions that &quot;a function that succeeds is allowed to change errno.&quot;<br>&gt; <br>&gt; To me this means that the issue is wider than just ARC. I think the problem extends to memory allocations on the heap. Failed memory allocations aren&#39;t a problem because they are terminal in Swift. However, _successful_ memory allocations might be a problem because the malloc(3) that the Swift compiler will use is absolutely free to set errno to 0 (or any other value in fact) indicating success. (Said that at least malloc doesn&#39;t change `errno` on the macOS or Linux I tested today, we probably shouldn&#39;t rely on that though.)<br>&gt; <br>&gt; This makes it even more unpredictable to the programmer what a use of `errno` in Swift will return. IMHO it shouldn&#39;t be exported to Swift as its value is undefined almost(?) everywhere.<br>&gt; <br>&gt; [4]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html<br>&gt; [5]: http://man7.org/linux/man-pages/man3/errno.3.html<br></p><p>Swift&#39;s implicit allocations don&#39;t directly use malloc/free. If there is a platform where a successful malloc dirties errno, we should avoid doing so in the Swift runtime&#39;s entry points.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/353d1c09444050fea4228317eaefafda?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Johannes WeiÃŸ</string> &lt;johannesweiss at apple.com&gt;<p>November  4, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Joe,<br></p><p>&gt;&gt; I just realised, that the problem is slightly worse than I originally described. I believed that successful calls in between the actual call the programmer wanted to make and capturing `errno` are not a problem.<br>&gt;&gt; <br>&gt;&gt; But POSIX seems to suggest [4] that &quot;The setting of errno after a successful call to a function is unspecified unless the description of that function specifies that errno shall not be modified.&quot; . The Linux man page [5] also mentions that &quot;a function that succeeds is allowed to change errno.&quot;<br>&gt;&gt; <br>&gt;&gt; To me this means that the issue is wider than just ARC. I think the problem extends to memory allocations on the heap. Failed memory allocations aren&#39;t a problem because they are terminal in Swift. However, _successful_ memory allocations might be a problem because the malloc(3) that the Swift compiler will use is absolutely free to set errno to 0 (or any other value in fact) indicating success. (Said that at least malloc doesn&#39;t change `errno` on the macOS or Linux I tested today, we probably shouldn&#39;t rely on that though.)<br>&gt;&gt; <br>&gt;&gt; This makes it even more unpredictable to the programmer what a use of `errno` in Swift will return. IMHO it shouldn&#39;t be exported to Swift as its value is undefined almost(?) everywhere.<br>&gt;&gt; <br>&gt;&gt; [4]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html<br>&gt;&gt; [5]: http://man7.org/linux/man-pages/man3/errno.3.html<br>&gt; <br>&gt; Swift&#39;s implicit allocations don&#39;t directly use malloc/free.<br></p><p>Ah right, that&#39;s good to know. But still, &quot;explicit&quot; allocation by creating an object does, right?<br></p><p>Like<br></p><p>class Foo {}<br>let x = Foo()<br></p><p>does allocate through _swift_allocObject_ -&gt; swift_slowAlloc -&gt; malloc .<br></p><p><br>&gt; If there is a platform where a successful malloc dirties errno, we should avoid doing so in the Swift runtime&#39;s entry points.<br></p><p>ok, agreed, should there be a platform where malloc that dirties `errno` it could be worked around by saving and restoring the `errno`.<br></p><p>Cheers,<br>  Johannes<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Make `errno`-setting functions more usable from Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 9:12 AM, Johannes WeiÃŸ &lt;johannesweiss at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe,<br>&gt; <br>&gt;&gt;&gt; I just realised, that the problem is slightly worse than I originally described. I believed that successful calls in between the actual call the programmer wanted to make and capturing `errno` are not a problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But POSIX seems to suggest [4] that &quot;The setting of errno after a successful call to a function is unspecified unless the description of that function specifies that errno shall not be modified.&quot; . The Linux man page [5] also mentions that &quot;a function that succeeds is allowed to change errno.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me this means that the issue is wider than just ARC. I think the problem extends to memory allocations on the heap. Failed memory allocations aren&#39;t a problem because they are terminal in Swift. However, _successful_ memory allocations might be a problem because the malloc(3) that the Swift compiler will use is absolutely free to set errno to 0 (or any other value in fact) indicating success. (Said that at least malloc doesn&#39;t change `errno` on the macOS or Linux I tested today, we probably shouldn&#39;t rely on that though.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes it even more unpredictable to the programmer what a use of `errno` in Swift will return. IMHO it shouldn&#39;t be exported to Swift as its value is undefined almost(?) everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [4]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/errno.html<br>&gt;&gt;&gt; [5]: http://man7.org/linux/man-pages/man3/errno.3.html<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s implicit allocations don&#39;t directly use malloc/free.<br>&gt; <br>&gt; Ah right, that&#39;s good to know. But still, &quot;explicit&quot; allocation by creating an object does, right?<br>&gt; <br>&gt; Like<br>&gt; <br>&gt; class Foo {}<br>&gt; let x = Foo()<br>&gt; <br>&gt; does allocate through _swift_allocObject_ -&gt; swift_slowAlloc -&gt; malloc .<br></p><p>swift_slowAlloc does not need to be implemented by calling malloc.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
