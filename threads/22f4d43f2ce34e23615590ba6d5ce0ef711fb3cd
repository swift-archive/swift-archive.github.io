<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution<br>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p><br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>March 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, the current-state leaves one unable to do certain things in pure Swift (e.g. tagged pointers) that are clearly useful on occasion.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I do think from the alternatives mentioned that the suggested approach is the cleanest. This sort of programming clearly belongs in the “unsafe” corner, but that doesn’t mean one shouldn’t be able to express these sorts of things in Swift.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have not used any aspiring system programming languages that didn’t allow manipulating pointers as integer values.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick read of the proposal.<br></p><p><br>	Daniel.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>March 23, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Mar 22, 2016, at 9:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br></p><p>I give the concept a +1. Swift should support dangerous actions but should make them clear and obvious. I do think that there is room to improve the argument label. There are two issues with &quot;bitPattern&quot; that concern me:<br>1) it should be clear that it will be the bitPattern of the pointer itself not whatever the pointer refers to.<br>2) it doesn&#39;t indicate the danger of using the results of this <br></p><p>I don&#39;t have a great alternative to bitPattern but maybe something like: &quot;rawMemoryAddress&quot;<br></p><p>I&#39;ve read the proposal and given it a little bit of thought but have not yet read preceding or recent comments. <br></p><p>Joseph<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/08e0e501c1b7f3d2ee6d0ed52f560702?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Richard Ross</string> &lt;richardross at fb.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>Just for note, an alternative that works right now (whether intentional or not) is this:<br></p><p>let rawAddress: Int = UnsafeMutablePointer&lt;UInt8&gt;(nil).distanceTo(myPointer)<br></p><p>This gives the distance in bytes (so on 95% of all platforms, the raw address). It currently isn&#39;t clear that this is how you can accomplish this in swift, so I&#39;m +1 on the proposal. <br>--<br>Richard<br></p><p>&gt; On Mar 22, 2016, at 8:24 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 22, 2016, at 9:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br>&gt; <br>&gt; I give the concept a +1. Swift should support dangerous actions but should make them clear and obvious. I do think that there is room to improve the argument label. There are two issues with &quot;bitPattern&quot; that concern me:<br>&gt; 1) it should be clear that it will be the bitPattern of the pointer itself not whatever the pointer refers to.<br>&gt; 2) it doesn&#39;t indicate the danger of using the results of this <br>&gt; <br>&gt; I don&#39;t have a great alternative to bitPattern but maybe something like: &quot;rawMemoryAddress&quot;<br>&gt; <br>&gt; I&#39;ve read the proposal and given it a little bit of thought but have not yet read preceding or recent comments. <br>&gt; <br>&gt; Joseph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://urldefense.proofpoint.com/v2/url?u=https-3A__lists.swift.org_mailman_listinfo_swift-2Devolution&amp;d=CwIGaQ&amp;c=5VD0RTtNlTh3ycd41b3MUw&amp;r=Ezje1IF3xGXfUMfsj4fBc7oM7BcJys1dhQ6psfXzLMU&amp;m=i019xuJ4IOUV9q48MCnS9R5K_9HDaAIqAAGCp9-HX_k&amp;s=W8720bY71AVSU3_XbLpWfFEh9Vmh9qMh1YTnodVcUHs&amp;e=<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>I support this. Currently this requires the use of unsafeBitCast, which works okay but is unwieldy.<br>I used unsafeBitCast to implement tagged pointers in a previous exploratory project, and I think this proposal would improve readability without being an inducement to recklessness.<br></p><p>“bitPattern” is a decent label, but that is also used for the lossy int-to-int conversions; pointer-to-int casting may be different enough to warrant a different label. “unsafeAddress” comes to mind, but may clash with the similarly-named function.<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p><br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p><br>&gt; * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Like uintptr_t, this requires an intentional step in order to do bit operations on pointers.<br></p><p><br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A careful read and some experience trying this in swift.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>March 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 22, 2016, at 2:35 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md&gt;<br></p><p>+1<br></p><p>I agree with all of the feedback so far, and I think bitPattern is a good label name.<br></p><p>The dangerous case is the UInt to UnsafePointer conversion that already exists. If we allow that, then adding symmetry is only natural.<br></p><p>I’ll add that I don’t particularly like the practice of using unsafeBitcast on pointer values. It does not sufficiently inform the compiler that the type system is being circumvented because no information is carried through to the point of access. UInt to UnsafePointer has the same problem, but I like the fact that a separate, explicit API is used when pointers are involved.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/ac058bd5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 27, 2016 at 10:00:00am</p></header><div class="content"><p>Thinking through this proposal, I really favor the operator approach rather than adding these conversions so my vote is -1. <br>(If you really know what you&#39;re doing you can already do an unsafeBitCast so this isn&#39;t a problem I&#39;ve had in the real world)<br></p><p>&gt;Because some of these operations are defined only on signed integers, and others on unsigned, it would have required splittingUnsafe[Mutable]Pointer into signed and unsigned variants, which would have complicated things for users who did not need to do pointer arithmetic<br></p><p>This proposal doesn&#39;t solve that problem; it relies on the user selecting the correct conversion and checking for invalid results. It leaves things just as error-prone as C. I think we /can/ do better and /should/ do better. <br></p><p>I&#39;d rather see arithmetic operators on UnsafePointer that trap on overflow/underflow, then some functions for checking common scenarios that people always get wrong (how many exploits begin with &quot;this check attempts to determine if size exceeds a bound or wraps but is completely incorrect...&quot;^). Something like &quot;add(Int, max: UnsafePointer = UnsafePointer.max) -&gt; UnsafePointer?&quot; Which returns nil if the value would exceed max or wrap around. <br></p><p>I guess my main problem is that pointers *are* unsigned. For silly implementation reasons we treat them as signed so we can check some overflow/underflow scenarios but why not just solve the real problem and let people express intent clearly instead of obtusely?**<br></p><p>I&#39;ve had a lot of experience doing rather unsafe things in Swift and my evaluation is based on that experience. <br></p><p>Russ<br></p><p>^ Seriously... This kind of failure has to be responsible for billions of dollars in damages by now. It&#39;s an extremely common error. <br></p><p>** I&#39;m aware that on many current CPUs the top N bits are either fixed or extended from the highest valid bit so the hardware doesn&#39;t actually need to handle a full 64-bit virtual address space. I&#39;m also aware that many architectures place the kernel address space in the upper range so user mode code never sees &quot;negative&quot; pointers. The address space restriction won&#39;t be true forever and Swift should be usable to write kernel mode code/drivers in the future. <br></p><p><br>&gt; On Mar 22, 2016, at 2:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/db44fbb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m not sure what you mean by &quot;the operator approach&quot;. Do you mean measuring the distance between a pointer and nil? That assumes that nil&#39;s representation is 0 (which admittedly it is on all our platforms, but which shouldn&#39;t really be in anyone&#39;s mental model of UnsafePointer).<br></p><p>I&#39;d like to note that (IIUC) one of our goals is to make unsafeBitCast unneccessary; if a conversion is a reasonable thing to do regularly, there should always be a more principled way to do it. Someone&#39;s &quot;intuitive&quot; understanding of unsafeBitCast may well be wrong.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 27, 2016, at 10:01, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thinking through this proposal, I really favor the operator approach rather than adding these conversions so my vote is -1. <br>&gt; (If you really know what you&#39;re doing you can already do an unsafeBitCast so this isn&#39;t a problem I&#39;ve had in the real world)<br>&gt; <br>&gt; &gt;Because some of these operations are defined only on signed integers, and others on unsigned, it would have required splittingUnsafe[Mutable]Pointer into signed and unsigned variants, which would have complicated things for users who did not need to do pointer arithmetic<br>&gt; <br>&gt; This proposal doesn&#39;t solve that problem; it relies on the user selecting the correct conversion and checking for invalid results. It leaves things just as error-prone as C. I think we /can/ do better and /should/ do better. <br>&gt; <br>&gt; I&#39;d rather see arithmetic operators on UnsafePointer that trap on overflow/underflow, then some functions for checking common scenarios that people always get wrong (how many exploits begin with &quot;this check attempts to determine if size exceeds a bound or wraps but is completely incorrect...&quot;^). Something like &quot;add(Int, max: UnsafePointer = UnsafePointer.max) -&gt; UnsafePointer?&quot; Which returns nil if the value would exceed max or wrap around. <br>&gt; <br>&gt; I guess my main problem is that pointers *are* unsigned. For silly implementation reasons we treat them as signed so we can check some overflow/underflow scenarios but why not just solve the real problem and let people express intent clearly instead of obtusely?**<br>&gt; <br>&gt; I&#39;ve had a lot of experience doing rather unsafe things in Swift and my evaluation is based on that experience. <br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; ^ Seriously... This kind of failure has to be responsible for billions of dollars in damages by now. It&#39;s an extremely common error. <br>&gt; <br>&gt; ** I&#39;m aware that on many current CPUs the top N bits are either fixed or extended from the highest valid bit so the hardware doesn&#39;t actually need to handle a full 64-bit virtual address space. I&#39;m also aware that many architectures place the kernel address space in the upper range so user mode code never sees &quot;negative&quot; pointers. The address space restriction won&#39;t be true forever and Swift should be usable to write kernel mode code/drivers in the future. <br>&gt; <br>&gt; <br>&gt; On Mar 22, 2016, at 2:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/5e2abb3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>One of the alternatives discussed in the proposal was adding mathematical operators to UnsafePointer so you can manipulate the pointers directly, such as XORing them, checking alignment, etc. I would very much prefer that we add operators and functions to UnsafePointer to express intent. <br></p><p>Converting to Int/UInt is first of all an opportunity for the programmer to screw it up royally (and create massive security holes in the process). I don’t believe supporting operators requires bifurcating into signed/unsigned pointers. Our existing math operators trap on overflow and you must explicitly opt-in to wrapping behavior. For obtaining a distance (which may be negative) we already have distanceTo.<br></p><p>UnsafePointer should have functions to perform various operations while clearly expressing intent, eg: `add(otherPointer: UnsafePointer&lt;T&gt;, limit: Int = Int.max) -&gt; T?` that returns `nil` if the pointer would overflow/underflow. Maybe that’s not the right shape of the API but I strongly feel that we should be discussing that rather than this proposal.<br></p><p><br>Russ<br></p><p><br>&gt; On Mar 28, 2016, at 10:53 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure what you mean by &quot;the operator approach&quot;. Do you mean measuring the distance between a pointer and nil? That assumes that nil&#39;s representation is 0 (which admittedly it is on all our platforms, but which shouldn&#39;t really be in anyone&#39;s mental model of UnsafePointer).<br>&gt; <br>&gt; I&#39;d like to note that (IIUC) one of our goals is to make unsafeBitCast unneccessary; if a conversion is a reasonable thing to do regularly, there should always be a more principled way to do it. Someone&#39;s &quot;intuitive&quot; understanding of unsafeBitCast may well be wrong.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 27, 2016, at 10:01, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thinking through this proposal, I really favor the operator approach rather than adding these conversions so my vote is -1. <br>&gt;&gt; (If you really know what you&#39;re doing you can already do an unsafeBitCast so this isn&#39;t a problem I&#39;ve had in the real world)<br>&gt;&gt; <br>&gt;&gt; &gt;Because some of these operations are defined only on signed integers, and others on unsigned, it would have required splittingUnsafe[Mutable]Pointer into signed and unsigned variants, which would have complicated things for users who did not need to do pointer arithmetic<br>&gt;&gt; <br>&gt;&gt; This proposal doesn&#39;t solve that problem; it relies on the user selecting the correct conversion and checking for invalid results. It leaves things just as error-prone as C. I think we /can/ do better and /should/ do better. <br>&gt;&gt; <br>&gt;&gt; I&#39;d rather see arithmetic operators on UnsafePointer that trap on overflow/underflow, then some functions for checking common scenarios that people always get wrong (how many exploits begin with &quot;this check attempts to determine if size exceeds a bound or wraps but is completely incorrect...&quot;^). Something like &quot;add(Int, max: UnsafePointer = UnsafePointer.max) -&gt; UnsafePointer?&quot; Which returns nil if the value would exceed max or wrap around. <br>&gt;&gt; <br>&gt;&gt; I guess my main problem is that pointers *are* unsigned. For silly implementation reasons we treat them as signed so we can check some overflow/underflow scenarios but why not just solve the real problem and let people express intent clearly instead of obtusely?**<br>&gt;&gt; <br>&gt;&gt; I&#39;ve had a lot of experience doing rather unsafe things in Swift and my evaluation is based on that experience. <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt;&gt; <br>&gt;&gt; ^ Seriously... This kind of failure has to be responsible for billions of dollars in damages by now. It&#39;s an extremely common error. <br>&gt;&gt; <br>&gt;&gt; ** I&#39;m aware that on many current CPUs the top N bits are either fixed or extended from the highest valid bit so the hardware doesn&#39;t actually need to handle a full 64-bit virtual address space. I&#39;m also aware that many architectures place the kernel address space in the upper range so user mode code never sees &quot;negative&quot; pointers. The address space restriction won&#39;t be true forever and Swift should be usable to write kernel mode code/drivers in the future. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 22, 2016, at 2:35 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;    * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/d182d3f4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bbea2d379c2fdc51fe02db1c3caa15de?s=50"></div><header><strong>[Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Dan Raviv</string> &lt;dan.raviv at gmail.com&gt;<p>March 28, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Mar 22, 2016 at 11:35 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;Adding initializers to Int and UInt to convert from<br>&gt; UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March<br>&gt; 25th. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at:<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br>-1. While it is tempting to have the full power of converting pointers to<br>ints, it&#39;s a recipe for security issues as already mentioned.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>No. Swift feels safer than doing raw pointer arithmetic.<br>I&#39;m for the alternative mentioned in the proposal (comments inline):<br></p><p>...The next alternative was to add functions to Unsafe[Mutable]Pointer which<br>covered the identified pointer arithmetic cases. This alternative was<br>rejected because it either would have required us to imagine every use-case<br>of pointer arithmetic [...] or it would have required adding a full suite<br>of arithmetic and bitwise operators to Unsafe[Mutable]Pointer.<br>I think the full suite is worth eliminating potential raw pointer<br>arithmetic bugs.<br></p><p>Because some of these operations are defined only on signed integers, and<br>others on unsigned, it would have required splitting<br>Unsafe[Mutable]Pointer into<br>signed and unsigned variants, which would have complicated things for users<br>who did not need to do pointer arithmetic.<br>What operations are defined only on signed/unsigned ints?<br></p><p>Additionally, the implementations of these operations would have probably<br>converted the pointers to integers, perform a single operation, and then<br>convert them back. When chaining operations, this would create a lot of<br>unnecessary conversions.<br>Isn&#39;t that for the optimizer to optimize?<br></p><p>        * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>A quick reading.<br></p><p>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/9097680a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0016 - Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>March 29, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Mar 22, 2016, at 02:35 PM, Chris Lattner wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Adding initializers to Int and UInt to convert from UnsafePointer and UnsafeMutablePointer&quot; begins now and runs through March 25th. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. It solves a legitimate problem, something that the only non-fragile way to accomplish today is with unsafeBitCast (using hashValue is fragile in that hashValue is not defined as returning the pointer as an integer). Personally, I&#39;ve wanted to convert pointers into integers so I could format them differently than the default formatting of UnsafePointer (usually so I can skip the leading zeroes), but there&#39;s other uses cases too.<br></p><p>Prior to reading the proposal I would have expected this to be solved by adding an .intValue or .uintValue property to UnsafePointer/UnsafeMutablePointer, but I think Int(bitPatern:) and UInt(bitPattern:) is actually a more elegant solution.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. It&#39;s rather unfortunate to have to resort to unsafeBitCast() simply to convert a pointer into an integer.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. Using initializers for type conversions is idiomatic, and the &quot;bitPattern:&quot; label makes sense and has precedent.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Other languages typically use whatever built-in type casting functionality there is. If we were to follow suite, that would actually suggest enabling `somePtr as UInt` for doing the conversion, but Swift doesn&#39;t use `as` for doing this kind of type conversion so the initializer approach is the most sensible.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
