<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May  4, 2016 at 10:00:00pm</p></header><div class="content"><p>This one have bothered me for days, since the idea came to my mind.<br></p><p>I don&#39;t want to be too futuristic so here are my first thoughts.<br></p><p>What if Swift 3 would have the ability to merge types and protocols together?<br></p><p>Sure we will see generic typealias in Swift 3 but it doesn&#39;t allow us merge value types which conforms to specific protocols (if there is a need).<br></p><p>protocol SomeProtocol {<br>		<br>	func boo()<br>}<br></p><p>// this use-case can be solved with generic typealias in Swift 3 (at least for classes), but it is not the only one usecase of type merging<br>func foo(mergedInstance: type&lt;UIView, SomeProtocol&gt;) {<br>		<br>	mergedInstance.removeFromSuperview() // just for the example<br>	mergedInstance.boo()<br>}<br></p><p>extension UIButton: SomeProtocol { /* implemnt boo() */ }<br></p><p>let button: SomeProtocol = UIButton() // decouple UIButton first<br></p><p>Ok now I want to use one instance as SomeProtocol and UIView.<br></p><p>// another possible use-case<br>if let mergedView = button as? type&lt;UIView, SomeProtocol&gt; {<br>		<br>	mergedView.removeFromSuperview() // just for the example<br>	mergedView.boo()<br>}<br></p><p>More detailed design:<br></p><p>- type&lt;&gt; can contain only one value or reference type and n protocols<br>- value or reference type should always be the first type<br>- type&lt;&gt; should always contain at least 2 types (one value or reference type and min. one protocol)<br>- reference types does represent one possible super/base type of the actuall type <br>     * class A {}<br>     * class B: A {}<br>     * class C: B {}<br>     * possible types for B and C: type&lt;B, AnyProtocolType, ...&gt; or type&lt;A, AnyProtocolType, ...&gt;<br>- the dynamicType/Self instance passed to type&lt;&gt; conforms to all protocols type&lt;&gt; contains<br></p><p>If there is more rules one would apply to this idea feel free to discuss them here.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/29c204b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Sorry for pushing this back, but I really would like to read any feedback for this idea of mine. ;)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 4. Mai 2016 bei 22:38:33, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>This one have bothered me for days, since the idea came to my mind.<br></p><p>I don&#39;t want to be too futuristic so here are my first thoughts.<br></p><p>What if Swift 3 would have the ability to merge types and protocols together?<br></p><p>Sure we will see generic typealias in Swift 3 but it doesn&#39;t allow us merge value types which conforms to specific protocols (if there is a need).<br></p><p>protocol SomeProtocol {<br>func boo()<br>}<br></p><p>// this use-case can be solved with generic typealias in Swift 3 (at least for classes), but it is not the only one usecase of type merging<br>func foo(mergedInstance: type&lt;UIView, SomeProtocol&gt;) {<br>mergedInstance.removeFromSuperview() // just for the example<br>mergedInstance.boo()<br>}<br></p><p>extension UIButton: SomeProtocol { /* implemnt boo() */ }<br></p><p>let button: SomeProtocol = UIButton() // decouple UIButton first<br></p><p>Ok now I want to use one instance as SomeProtocol and UIView.<br></p><p>// another possible use-case<br>if let mergedView = button as? type&lt;UIView, SomeProtocol&gt; {<br>mergedView.removeFromSuperview() // just for the example<br>mergedView.boo()<br>}<br></p><p>More detailed design:<br></p><p>- type&lt;&gt; can contain only one value or reference type and n protocols<br>- value or reference type should always be the first type<br>- type&lt;&gt; should always contain at least 2 types (one value or reference type and min. one protocol)<br>- reference types does represent one possible super/base type of the actuall type <br>     * class A {}<br>     * class B: A {}<br>     * class C: B {}<br>     * possible types for B and C: type&lt;B, AnyProtocolType, ...&gt; or type&lt;A, AnyProtocolType, ...&gt;<br>- the dynamicType/Self instance passed to type&lt;&gt; conforms to all protocols type&lt;&gt; contains<br></p><p>If there is more rules one would apply to this idea feel free to discuss them here.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/4b4d52a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 12, 2016 at 04:00:00pm</p></header><div class="content"><p>I feel like this could be a useful feature. We can right now couple protocols<br></p><p>protocol A { func a() }<br>protocol B { func b() }<br></p><p>func z(o: protocol&lt;A,B&gt;) {<br>     o.a()<br>     o.b()<br>}<br></p><p>let o = some as! protocol&lt;A, B&gt;<br>o.a()<br>o.b()<br></p><p>But how to be if we need to specify some class/struct in addition to protocol?<br>So, if this feature could be implemented, I&#39;m +1 on this `type&lt;&gt;` feature<br>Or probably we can allow class in protocol&lt;&gt;<br></p><p>On 11.05.2016 21:06, Adrian Zubarev via swift-evolution wrote:<br>&gt; Sorry for pushing this back, but I really would like to read any feedback<br>&gt; for this idea of mine. ;)<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 4. Mai 2016 bei 22:38:33, Adrian Zubarev<br>&gt; (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;)<br>&gt; schrieb:<br>&gt;<br>&gt;&gt; This one have bothered me for days, since the idea came to my mind.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t want to be too futuristic so here are my first thoughts.<br>&gt;&gt;<br>&gt;&gt; What if Swift 3 would have the ability to merge types and protocols together?<br>&gt;&gt;<br>&gt;&gt; Sure we will see generic typealias in Swift 3 but it doesn&#39;t allow us<br>&gt;&gt; merge value types which conforms to specific protocols (if there is a need).<br>&gt;&gt;<br>&gt;&gt; protocol SomeProtocol {<br>&gt;&gt; func boo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // this use-case can be solved with generic typealias in Swift 3 (at<br>&gt;&gt; least for classes), but it is not the only one usecase of type merging<br>&gt;&gt; func foo(mergedInstance: type&lt;UIView, SomeProtocol&gt;) {<br>&gt;&gt; mergedInstance.removeFromSuperview() // just for the example<br>&gt;&gt; mergedInstance.boo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension UIButton: SomeProtocol { /* implemnt boo() */ }<br>&gt;&gt;<br>&gt;&gt; let button: SomeProtocol = UIButton() // decouple UIButton first<br>&gt;&gt;<br>&gt;&gt; Ok now I want to use one instance as SomeProtocol and UIView.<br>&gt;&gt;<br>&gt;&gt; // another possible use-case<br>&gt;&gt; if let mergedView = button as? type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt; mergedView.removeFromSuperview() // just for the example<br>&gt;&gt; mergedView.boo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; More detailed design:<br>&gt;&gt;<br>&gt;&gt; - type&lt;&gt; can contain only one value or reference type and n protocols<br>&gt;&gt; - value or reference type should always be the first type<br>&gt;&gt; - type&lt;&gt; should always contain at least 2 types (one value or reference<br>&gt;&gt; type and min. one protocol)<br>&gt;&gt; - reference types does represent one possible super/base type of the<br>&gt;&gt; actuall type<br>&gt;&gt;      * class A {}<br>&gt;&gt;      * class B: A {}<br>&gt;&gt;      * class C: B {}<br>&gt;&gt;      * possible types for B and C: type&lt;B, AnyProtocolType, ...&gt; or<br>&gt;&gt; type&lt;A, AnyProtocolType, ...&gt;<br>&gt;&gt; - the dynamicType/Self instance passed to type&lt;&gt; conforms to all<br>&gt;&gt; protocols type&lt;&gt; contains<br>&gt;&gt;<br>&gt;&gt; If there is more rules one would apply to this idea feel free to discuss<br>&gt;&gt; them here.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 12, 2016 at 04:00:00pm</p></header><div class="content"><p>protocol&lt;SomeRealClass, SomeProtocol&gt; <br>protocol&lt;SomeRealStruct, SomeProtocol&gt; <br></p><p>This feels really odd to me. <br></p><p>`type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br></p><p>I think this would be a good addition to the type system and allow us to build more complex and type save code.<br></p><p>But still I’d love to discuss if there might be any disadvantages to this feature.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br></p><p>protocol&lt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/4be37746/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 12, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m +1 on this. It seems like it would solve the issue of Objective-C APIs<br>losing their protocol conformances on properties/arguments/return values<br>when they&#39;re added to a class, like UIView&lt;SomeProtocol&gt;. That always<br>seemed like a major hole in the cross-language support and when writing<br>ObjC libraries I&#39;ve had to explicitly use id&lt;Foo&gt; instead of a stronger<br>class-based type simply to ensure Swift interoperability.<br></p><p>The other option of course is to import those things as generic functions<br>with constraints, but (1) that doesn&#39;t solve it for properties, and (2) if<br>we already support composing protocols in this way, why not also allow it<br>for other types, where it can be used for properties and variables? This<br>approach feels like it would round out the type system nicely.<br></p><p><br>On Thu, May 12, 2016 at 7:09 AM Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; protocol&lt;SomeRealClass, SomeProtocol&gt;<br>&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt;<br>&gt;<br>&gt; This feels really odd to me.<br>&gt;<br>&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;<br>&gt; I think this would be a good addition to the type system and allow us to<br>&gt; build more complex and type save code.<br>&gt;<br>&gt; But still I’d love to discuss if there might be any disadvantages to this<br>&gt; feature.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt;<br>&gt; protocol&lt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/d141fb73/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 12, 2016 at 09:00:00pm</p></header><div class="content"><p>Ceylon uses „&amp;&quot; for intersection types, i.e.<br></p><p>	SomeRealClass &amp; SomeProtocol<br></p><p>and the bar („|“) for union types, i.e. <br></p><p>	String | Int<br></p><p>That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br></p><p><br>I agree with you that<br></p><p>	type&lt;SomeRealClass, SomeProtocol&gt; <br></p><p>is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br></p><p>	all&lt;SomeRealClass, SomeProtocol&gt;<br></p><p>This would allow<br></p><p>	any&lt;String, Int&gt;<br></p><p>to be used for union types.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt; <br>&gt; This feels really odd to me. <br>&gt; <br>&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt; <br>&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt; <br>&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; protocol&lt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/320f9461/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 12, 2016 at 10:00:00pm</p></header><div class="content"><p>I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br></p><p>From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br></p><p>Here is a little example where `any&lt;&gt;` gets strange:<br></p><p>func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br></p><p>    // how would one use value here?<br>    // what about its properties<br>    // what will foo return and how to use the result<br>}<br></p><p>One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br></p><p>I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br></p><p>This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br></p><p>func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br></p><p>    // use it as a UIView and SomeProtocol at the same type<br>    return value // return type works great<br>}<br></p><p>We can split the value just fine:<br></p><p>let mergedValue = foo(SomeViewThatWorks)<br>let view: UIView = mergedValue<br>let protocolValue: SomeProtocol = mergedValue<br></p><p>And merge it back together:<br></p><p>guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br></p><p>`all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com) schrieb:<br></p><p>Ceylon uses „&amp;&quot; for intersection types, i.e.<br></p><p>SomeRealClass &amp; SomeProtocol<br></p><p>and the bar („|“) for union types, i.e. <br></p><p>String | Int<br></p><p>That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br></p><p><br>I agree with you that<br></p><p>type&lt;SomeRealClass, SomeProtocol&gt; <br></p><p>is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br></p><p>all&lt;SomeRealClass, SomeProtocol&gt;<br></p><p>This would allow<br></p><p>any&lt;String, Int&gt;<br></p><p>to be used for union types.<br></p><p>-Thorsten<br></p><p><br>Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>protocol&lt;SomeRealClass, SomeProtocol&gt; <br>protocol&lt;SomeRealStruct, SomeProtocol&gt; <br></p><p>This feels really odd to me. <br></p><p>`type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br></p><p>I think this would be a good addition to the type system and allow us to build more complex and type save code.<br></p><p>But still I’d love to discuss if there might be any disadvantages to this feature.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br></p><p>protocol&lt;&gt; <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/6292dc4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 12, 2016 at 01:00:00pm</p></header><div class="content"><p>We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br></p><p>I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br></p><p>The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071 &lt;rdar://problem/15873071&gt;.<br></p><p>Jordan<br></p><p><br>&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt; <br>&gt; From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt; <br>&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt; <br>&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt; <br>&gt;     // how would one use value here?<br>&gt;     // what about its properties<br>&gt;     // what will foo return and how to use the result<br>&gt; }<br>&gt; <br>&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br>&gt; <br>&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br>&gt; <br>&gt; This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt; <br>&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt; <br>&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;     return value // return type works great<br>&gt; }<br>&gt; <br>&gt; We can split the value just fine:<br>&gt; <br>&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt; let view: UIView = mergedValue<br>&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt; <br>&gt; And merge it back together:<br>&gt; <br>&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br>&gt; <br>&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt; <br>&gt;&gt; SomeRealClass &amp; SomeProtocol<br>&gt;&gt; <br>&gt;&gt; and the bar („|“) for union types, i.e. <br>&gt;&gt; <br>&gt;&gt; String | Int<br>&gt;&gt; <br>&gt;&gt; That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree with you that<br>&gt;&gt; <br>&gt;&gt; type&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt; <br>&gt;&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br>&gt;&gt; <br>&gt;&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt; <br>&gt;&gt; This would allow<br>&gt;&gt; <br>&gt;&gt; any&lt;String, Int&gt;<br>&gt;&gt; <br>&gt;&gt; to be used for union types.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This feels really odd to me. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol&lt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/5feb4d2e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>I think there would be a certain elegance to allowing Boolean type<br>expressions wherever types are currently allowed, so `A &amp; B` being a<br>replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to<br>allow concrete types as well. Then, if Swift ever decided to support union<br>types, the `|` operator naturally fits there.<br></p><p>One concern though would be whether parsing would get more complicated with<br>deeply composed expressions. If we only supported `&amp;`, there&#39;s no real<br>nesting going on. But if we wanted to be forward thinking and leave the<br>door open for `|`, we might need to support things like `(String | Int) &amp;<br>SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that<br>would really complicate things (e.g., could the compiler decide easily<br>enough that those parentheses are part of a type expression and not a<br>function type?).<br></p><p>`all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door<br>open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br></p><p><br>On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; We&#39;ve been over this a few times before on the list. I personally like<br>&gt; naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and<br>&gt; &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for<br>&gt; calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt;<br>&gt; I will say that &quot;type&quot; is unlikely to see much traction simply because it<br>&gt; is an *incredibly* common name for both properties and locals. We went<br>&gt; through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot;<br>&gt; and decided that it would be too confusing, even if we could make the<br>&gt; parsing work.<br>&gt;<br>&gt; The feature itself has definitely been shown to be useful when working<br>&gt; with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet<br>&gt; but we have it internally tracked in Radar as rdar://problem/15873071.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain<br>&gt; that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;<br>&gt; From my point of view `any&lt;&gt;` is something different that I pitched here.<br>&gt; `any&lt;&gt;` could be proposed in its own thread, because it is way different<br>&gt; than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt;<br>&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;<br>&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;<br>&gt;     // how would one use value here?<br>&gt;     // what about its properties<br>&gt;     // what will foo return and how to use the result<br>&gt; }<br>&gt;<br>&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the<br>&gt; type part of the function.<br>&gt;<br>&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that<br>&gt; direction, before we’ll move forward with more complex scenarios (just like<br>&gt; Chris did with generic typealias).<br>&gt;<br>&gt; This function is clear that it only will work if you provide a subclass of<br>&gt; an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt;<br>&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt;<br>&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;     return value // return type works great<br>&gt; }<br>&gt;<br>&gt; We can split the value just fine:<br>&gt;<br>&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt; let view: UIView = mergedValue<br>&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt;<br>&gt; And merge it back together:<br>&gt;<br>&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /*<br>&gt; do something */ }<br>&gt;<br>&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its<br>&gt; not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like<br>&gt; `protocol&lt;&gt;`.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com)<br>&gt; schrieb:<br>&gt;<br>&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;<br>&gt; SomeRealClass &amp; SomeProtocol<br>&gt;<br>&gt; and the bar („|“) for union types, i.e.<br>&gt;<br>&gt; String | Int<br>&gt;<br>&gt; That has proven to be very lightweight and readable in Ceylon where it is<br>&gt; heavily used to good effect.<br>&gt;<br>&gt;<br>&gt; I agree with you that<br>&gt;<br>&gt; type&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;<br>&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door<br>&gt; open for union types, I would prefer<br>&gt;<br>&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;<br>&gt; This would allow<br>&gt;<br>&gt; any&lt;String, Int&gt;<br>&gt;<br>&gt; to be used for union types.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; protocol&lt;SomeRealClass, SomeProtocol&gt;<br>&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt;<br>&gt;<br>&gt; This feels really odd to me.<br>&gt;<br>&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;<br>&gt; I think this would be a good addition to the type system and allow us to<br>&gt; build more complex and type save code.<br>&gt;<br>&gt; But still I’d love to discuss if there might be any disadvantages to this<br>&gt; feature.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt;<br>&gt; protocol&lt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/65dd855e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 13, 2016, at 9:21 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br></p><p>+1<br></p><p>But maybe we should consider generalizing this to type operators.  The &#39;?&#39; For optional could then be a postfix type operator.  And we could define our own type operators for type composition.  <br></p><p>&gt; <br>&gt; One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br>&gt; <br>&gt; `all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br></p><p>This makes sense as an immediate step in the right direction.  I like that it is more concise than protocol&lt;&gt;<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt;&gt; <br>&gt;&gt; I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br>&gt;&gt; <br>&gt;&gt; The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // how would one use value here?<br>&gt;&gt;&gt;     // what about its properties<br>&gt;&gt;&gt;     // what will foo return and how to use the result<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;&gt;&gt;     return value // return type works great<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can split the value just fine:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt;&gt;&gt; let view: UIView = mergedValue<br>&gt;&gt;&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And merge it back together:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SomeRealClass &amp; SomeProtocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and the bar („|“) for union types, i.e. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; String | Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with you that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; type&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would allow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; any&lt;String, Int&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to be used for union types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This feels really odd to me. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/2e1db8b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 13, 2016 at 05:00:00pm</p></header><div class="content"><p>But maybe we should consider generalizing this to type operators.  The &#39;?&#39; For optional could then be a postfix type operator.  And we could define our own type operators for type composition.  <br>Would you mind to provide a more detailed design from your perspective? I mean, how do you imagine `type&lt;&gt;` aka. `all&lt;&gt;` to look like with operators?<br></p><p>Any feedback is welcome. :)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Mai 2016 bei 17:05:29, Matthew Johnson (matthew at anandabits.com) schrieb:<br></p><p><br></p><p>Sent from my iPad<br></p><p>On May 13, 2016, at 9:21 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br></p><p>+1<br></p><p>But maybe we should consider generalizing this to type operators.  The &#39;?&#39; For optional could then be a postfix type operator.  And we could define our own type operators for type composition.  <br></p><p><br>One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br></p><p>`all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br></p><p>This makes sense as an immediate step in the right direction.  I like that it is more concise than protocol&lt;&gt;<br></p><p><br>On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br></p><p>I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br></p><p>The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071.<br></p><p>Jordan<br></p><p><br>On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br></p><p>From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br></p><p>Here is a little example where `any&lt;&gt;` gets strange:<br></p><p>func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br></p><p>    // how would one use value here?<br>    // what about its properties<br>    // what will foo return and how to use the result<br>}<br></p><p>One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br></p><p>I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br></p><p>This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br></p><p>func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br></p><p>    // use it as a UIView and SomeProtocol at the same type<br>    return value // return type works great<br>}<br></p><p>We can split the value just fine:<br></p><p>let mergedValue = foo(SomeViewThatWorks)<br>let view: UIView = mergedValue<br>let protocolValue: SomeProtocol = mergedValue<br></p><p>And merge it back together:<br></p><p>guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br></p><p>`all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com) schrieb:<br></p><p>Ceylon uses „&amp;&quot; for intersection types, i.e.<br></p><p>SomeRealClass &amp; SomeProtocol<br></p><p>and the bar („|“) for union types, i.e. <br></p><p>String | Int<br></p><p>That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br></p><p><br>I agree with you that<br></p><p>type&lt;SomeRealClass, SomeProtocol&gt; <br></p><p>is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br></p><p>all&lt;SomeRealClass, SomeProtocol&gt;<br></p><p>This would allow<br></p><p>any&lt;String, Int&gt;<br></p><p>to be used for union types.<br></p><p>-Thorsten<br></p><p><br>Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>protocol&lt;SomeRealClass, SomeProtocol&gt; <br>protocol&lt;SomeRealStruct, SomeProtocol&gt; <br></p><p>This feels really odd to me. <br></p><p>`type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br></p><p>I think this would be a good addition to the type system and allow us to build more complex and type save code.<br></p><p>But still I’d love to discuss if there might be any disadvantages to this feature.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br></p><p>protocol&lt;&gt; <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/e0782d63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 13, 2016, at 10:33 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; But maybe we should consider generalizing this to type operators.  The &#39;?&#39; For optional could then be a postfix type operator.  And we could define our own type operators for type composition.  <br>&gt; <br>&gt; Would you mind to provide a more detailed design from your perspective? I mean, how do you imagine `type&lt;&gt;` aka. `all&lt;&gt;` to look like with operators?<br>&gt; <br>&gt; <br></p><p>The &amp; type operator would produce a “flattened&quot; all&lt;&gt; with its operands.  It could be overloaded to accept either a concrete type or a protocol on the lhs and would produce `type` for an lhs that is a type and `all` when lhs is a protocol.   &quot;Type operators” would be evaluated during compile time and would produce a type that is used where the expression was present in the code.  This is a long-term idea, not something that needs to be considered right now.  It would be way out of scope for Swift 3.  <br></p><p><br>&gt; Any feedback is welcome. :)<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 13. Mai 2016 bei 17:05:29, Matthew Johnson (matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 13, 2016, at 9:21 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; But maybe we should consider generalizing this to type operators.  The &#39;?&#39; For optional could then be a postfix type operator.  And we could define our own type operators for type composition.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br>&gt;&gt; <br>&gt;&gt; This makes sense as an immediate step in the right direction.  I like that it is more concise than protocol&lt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071 &lt;&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // how would one use value here?<br>&gt;&gt;&gt;&gt;     // what about its properties<br>&gt;&gt;&gt;&gt;     // what will foo return and how to use the result<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;&gt;&gt;&gt;     return value // return type works great<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can split the value just fine:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt;&gt;&gt;&gt; let view: UIView = mergedValue<br>&gt;&gt;&gt;&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And merge it back together:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; SomeRealClass &amp; SomeProtocol<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and the bar („|“) for union types, i.e. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; String | Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with you that<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; type&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would allow<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; any&lt;String, Int&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to be used for union types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This feels really odd to me. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/e2ecef20/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Lets sum things up before I try to write a draft proposal for this feature `type&lt;&gt;` aka `all&lt;&gt;`.<br></p><p>Is this feature out of scope for Swift 3?<br></p><p>From my point of view it’s definitely not. <br></p><p>Is the name `type&lt;&gt;` really that bad for the compiler?<br></p><p>Here I’m not sure, because that is out of my experience. From a readers perspective it’s more clear than `all&lt;&gt;`, I would say, even though this is a perfect explanation why it should be called `all&lt;&gt;`:<br></p><p>I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>Do we miss any rules here?<br></p><p>`type&lt;&gt;` can contain only one value-type or reference-type and n protocols<br>the value-type or reference-type should always be the first element between angle brackets<br>`type&lt;&gt;` should always contain at least 2 types (one value-type or a reference-type and at least one protocol)<br>reference-types do represent a possible super/base type/class<br>nesting `type&lt;&gt;` is not allowed, however `type&lt;&gt;` can contain `protocol&lt;&gt;`<br>protocols conformance of `type&lt;&gt;` is tested with the actual type `type&lt;&gt;` not with the first element of `type&lt;&gt;` (hard to describe this one, does this makes sense to you?)<br>Does this proposal need more than the base `type&lt;&gt;`?<br></p><p>Maybe, but I think we should start with `type&lt;&gt;` before we will introduce a type operator for this.<br></p><p>Did I missed anything out here? <br></p><p>PS: Feel free to help me with my English, because it’s not so well.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 13. Mai 2016 bei 16:21:41, Tony Allevato (allevato at google.com) schrieb:<br></p><p>I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br></p><p>One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br></p><p>`all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br></p><p><br>On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br></p><p>I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br></p><p>The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071.<br></p><p>Jordan<br></p><p><br>On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br></p><p>From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br></p><p>Here is a little example where `any&lt;&gt;` gets strange:<br></p><p>func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br></p><p>    // how would one use value here?<br>    // what about its properties<br>    // what will foo return and how to use the result<br>}<br></p><p>One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br></p><p>I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br></p><p>This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br></p><p>func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br></p><p>    // use it as a UIView and SomeProtocol at the same type<br>    return value // return type works great<br>}<br></p><p>We can split the value just fine:<br></p><p>let mergedValue = foo(SomeViewThatWorks)<br>let view: UIView = mergedValue<br>let protocolValue: SomeProtocol = mergedValue<br></p><p>And merge it back together:<br></p><p>guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br></p><p>`all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com) schrieb:<br></p><p>Ceylon uses „&amp;&quot; for intersection types, i.e.<br></p><p>SomeRealClass &amp; SomeProtocol<br></p><p>and the bar („|“) for union types, i.e. <br></p><p>String | Int<br></p><p>That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br></p><p><br>I agree with you that<br></p><p>type&lt;SomeRealClass, SomeProtocol&gt; <br></p><p>is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br></p><p>all&lt;SomeRealClass, SomeProtocol&gt;<br></p><p>This would allow<br></p><p>any&lt;String, Int&gt;<br></p><p>to be used for union types.<br></p><p>-Thorsten<br></p><p><br>Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>protocol&lt;SomeRealClass, SomeProtocol&gt; <br>protocol&lt;SomeRealStruct, SomeProtocol&gt; <br></p><p>This feels really odd to me. <br></p><p>`type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br></p><p>I think this would be a good addition to the type system and allow us to build more complex and type save code.<br></p><p>But still I’d love to discuss if there might be any disadvantages to this feature.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com) schrieb:<br></p><p>protocol&lt;&gt; <br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/0e04dc57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 13.05.2016 um 17:25 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Lets sum things up before I try to write a draft proposal for this feature `type&lt;&gt;` aka `all&lt;&gt;`.<br>&gt; <br>&gt; Is this feature out of scope for Swift 3?<br>&gt; <br>&gt; From my point of view it’s definitely not. <br>&gt; <br>&gt; Is the name `type&lt;&gt;` really that bad for the compiler?<br>&gt; <br>&gt; Here I’m not sure, because that is out of my experience. From a readers perspective it’s more clear than `all&lt;&gt;`, I would say, even though this is a perfect explanation why it should be called `all&lt;&gt;`:<br>&gt; <br>&gt;&gt; I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt; <br>&gt; Do we miss any rules here?<br>&gt; <br>&gt; `type&lt;&gt;` can contain only one value-type or reference-type and n protocols<br>&gt; the value-type or reference-type should always be the first element between angle brackets<br>&gt; `type&lt;&gt;` should always contain at least 2 types (one value-type or a reference-type and at least one protocol)<br>I think type&lt;&gt; (or all&lt;&gt;) should replace protocol&lt;&gt;, otherwise the idea of having all&lt;&gt; and any&lt;&gt; loses its charm.<br>Is there a reason why type&lt;&gt; should exist in parallel to protocol&lt;&gt;?<br>&gt; reference-types do represent a possible super/base type/class<br>&gt; nesting `type&lt;&gt;` is not allowed, however `type&lt;&gt;` can contain `protocol&lt;&gt;`<br>&gt; protocols conformance of `type&lt;&gt;` is tested with the actual type `type&lt;&gt;` not with the first element of `type&lt;&gt;` (hard to describe this one, does this makes sense to you?)<br>The components of type&lt;&gt; are unrelated and do not have to conform to each other. They are just a union type. Did you mean that?<br></p><p>-Thorsten<br></p><p>&gt; Does this proposal need more than the base `type&lt;&gt;`?<br>&gt; <br>&gt; Maybe, but I think we should start with `type&lt;&gt;` before we will introduce a type operator for this.<br>&gt; <br>&gt; Did I missed anything out here? <br>&gt; <br>&gt; PS: Feel free to help me with my English, because it’s not so well.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 13. Mai 2016 bei 16:21:41, Tony Allevato (allevato at google.com &lt;mailto:allevato at google.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br>&gt;&gt; <br>&gt;&gt; One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br>&gt;&gt; <br>&gt;&gt; `all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt;&gt; <br>&gt;&gt; I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br>&gt;&gt; <br>&gt;&gt; The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071 &lt;&gt;.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // how would one use value here?<br>&gt;&gt;&gt;     // what about its properties<br>&gt;&gt;&gt;     // what will foo return and how to use the result<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;&gt;&gt;     return value // return type works great<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can split the value just fine:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt;&gt;&gt; let view: UIView = mergedValue<br>&gt;&gt;&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And merge it back together:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SomeRealClass &amp; SomeProtocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and the bar („|“) for union types, i.e. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; String | Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with you that<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; type&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would allow<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; any&lt;String, Int&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to be used for union types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This feels really odd to me. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/39305931/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 14.05.2016 um 20:08 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; protocols conformance of `type&lt;&gt;` is tested with the actual type `type&lt;&gt;` not with the first element of `type&lt;&gt;` (hard to describe this one, does this makes sense to you?)<br>&gt; <br>&gt; The components of type&lt;&gt; are unrelated and do not have to conform to each other. They are just a union type. Did you mean that?<br></p><p>Ooops, I meant of course, the complete expression forms an *intersection* type (not a union type). <br></p><p>To recap:<br></p><p>In Ceylon A &amp; B is an intersection type which means a type that conforms to A *and* B. This could be written as all&lt;A, B&gt; in Swift.<br>In Ceylon A | B is a union type which means a type that conforms to A *or* B (maybe to both but at least to one of them). This could be written as any&lt;A, B&gt; in Swift.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;&gt; Does this proposal need more than the base `type&lt;&gt;`?<br>&gt;&gt; <br>&gt;&gt; Maybe, but I think we should start with `type&lt;&gt;` before we will introduce a type operator for this.<br>&gt;&gt; <br>&gt;&gt; Did I missed anything out here? <br>&gt;&gt; <br>&gt;&gt; PS: Feel free to help me with my English, because it’s not so well.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 13. Mai 2016 bei 16:21:41, Tony Allevato (allevato at google.com &lt;mailto:allevato at google.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I think there would be a certain elegance to allowing Boolean type expressions wherever types are currently allowed, so `A &amp; B` being a replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to allow concrete types as well. Then, if Swift ever decided to support union types, the `|` operator naturally fits there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern though would be whether parsing would get more complicated with deeply composed expressions. If we only supported `&amp;`, there&#39;s no real nesting going on. But if we wanted to be forward thinking and leave the door open for `|`, we might need to support things like `(String | Int) &amp; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that would really complicate things (e.g., could the compiler decide easily enough that those parentheses are part of a type expression and not a function type?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will say that &quot;type&quot; is unlikely to see much traction simply because it is an incredibly common name for both properties and locals. We went through that exercise when trying to name both &quot;static&quot; and &quot;dynamicType&quot; and decided that it would be too confusing, even if we could make the parsing work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The feature itself has definitely been shown to be useful when working with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA yet but we have it internally tracked in Radar as rdar://problem/15873071 &lt;&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From my point of view `any&lt;&gt;` is something different that I pitched here. `any&lt;&gt;` could be proposed in its own thread, because it is way different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to get to `any&lt;&gt;`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // how would one use value here?<br>&gt;&gt;&gt;&gt;     // what about its properties<br>&gt;&gt;&gt;&gt;     // what will foo return and how to use the result<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One benefit of `any&lt;&gt;` is the replacement of overloading, at least for the type part of the function.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to propose `type&lt;&gt;` as the base extension to the language in that direction, before we’ll move forward with more complex scenarios (just like Chris did with generic typealias).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This function is clear that it only will work if you provide a subclass of an UIView which conforms to SomeProtocol (nice addition for library design).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt; type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // use it as a UIView and SomeProtocol at the same type<br>&gt;&gt;&gt;&gt;     return value // return type works great<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We can split the value just fine:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let mergedValue = foo(SomeViewThatWorks)<br>&gt;&gt;&gt;&gt; let view: UIView = mergedValue<br>&gt;&gt;&gt;&gt; let protocolValue: SomeProtocol = mergedValue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And merge it back together:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else { /* do something */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like `protocol&lt;&gt;`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; SomeRealClass &amp; SomeProtocol<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and the bar („|“) for union types, i.e. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; String | Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That has proven to be very lightweight and readable in Ceylon where it is heavily used to good effect.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with you that<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; type&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is much nicer than protocol&lt;&gt; for intersection types but to keep the door open for union types, I would prefer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would allow<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; any&lt;String, Int&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to be used for union types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealClass, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;SomeRealStruct, SomeProtocol&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This feels really odd to me. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this would be a good addition to the type system and allow us to build more complex and type save code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But still I’d love to discuss if there might be any disadvantages to this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol&lt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/66cfe435/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 13, 2016 at 06:00:00pm</p></header><div class="content"><p>IMO it will be nice to have ability to write:<br></p><p>func f(obj: A&amp;B&amp;C) {..}<br>if obj is A&amp;B&amp;C {...}<br>obj2 = obj as! A&amp;B&amp;C<br></p><p>(but I still don&#39;t understand real use case of things like (String | Int))<br></p><p>Btw, as we have `protocol` keyword for this feature to couple protocols, <br>why we can&#39;t have `class` keyword to merge class&amp;protocols?<br>Like<br>func f(obj: class&lt;SomeClass,SomeProtocl&gt;) {..}<br>if obj is class&lt;SomeClass,SomeProtocl&gt; {..}<br>obj2 = obj as! class&lt;SomeClass,SomeProtocol&gt;<br></p><p>and yes, probably struct&lt;SomeStruct,SomeProtocol&gt;<br></p><p><br>On 13.05.2016 17:21, Tony Allevato via swift-evolution wrote:<br>&gt; I think there would be a certain elegance to allowing Boolean type<br>&gt; expressions wherever types are currently allowed, so `A &amp; B` being a<br>&gt; replacement for `protocol&lt;A, B&gt;` might look nice, and then extend that to<br>&gt; allow concrete types as well. Then, if Swift ever decided to support union<br>&gt; types, the `|` operator naturally fits there.<br>&gt;<br>&gt; One concern though would be whether parsing would get more complicated with<br>&gt; deeply composed expressions. If we only supported `&amp;`, there&#39;s no real<br>&gt; nesting going on. But if we wanted to be forward thinking and leave the<br>&gt; door open for `|`, we might need to support things like `(String | Int) &amp;<br>&gt; SomeProtocol`, and I&#39;m not enough of a parser expert to know whether that<br>&gt; would really complicate things (e.g., could the compiler decide easily<br>&gt; enough that those parentheses are part of a type expression and not a<br>&gt; function type?).<br>&gt;<br>&gt; `all&lt;A, B&gt;` would be a nice compromise in that case, and leave the door<br>&gt; open for `any&lt;A, B&gt;` in the future. So I&#39;d be supportive of either option.<br>&gt;<br>&gt;<br>&gt; On Thu, May 12, 2016 at 1:30 PM Jordan Rose via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     We&#39;ve been over this a few times before on the list. I personally like<br>&gt;     naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;,<br>&gt;     and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?)<br>&gt;     argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple<br>&gt;     constraints.<br>&gt;<br>&gt;     I will say that &quot;type&quot; is unlikely to see much traction simply because<br>&gt;     it is an /incredibly/ common name for both properties and locals. We<br>&gt;     went through that exercise when trying to name both &quot;static&quot; and<br>&gt;     &quot;dynamicType&quot; and decided that it would be too confusing, even if we<br>&gt;     could make the parsing work.<br>&gt;<br>&gt;     The feature itself has definitely been shown to be useful when working<br>&gt;     with the Cocoa frameworks, if not in general. I don&#39;t see it on JIRA<br>&gt;     yet but we have it internally tracked in Radar as rdar://problem/15873071.<br>&gt;<br>&gt;     Jordan<br>&gt;<br>&gt;<br>&gt;&gt;     On May 12, 2016, at 13:08, Adrian Zubarev via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     I don’t get the part how `all&lt;&gt;` should allow `any&lt;&gt;`. Could you<br>&gt;&gt;     explain that a little bit in detail (I’m not familiar with Ceylon)?<br>&gt;&gt;<br>&gt;&gt;     From my point of view `any&lt;&gt;` is something different that I pitched<br>&gt;&gt;     here. `any&lt;&gt;` could be proposed in its own thread, because it is way<br>&gt;&gt;     different than `type&lt;&gt;`. Or can we refine the rules of `type&lt;&gt;` to<br>&gt;&gt;     get to `any&lt;&gt;`?<br>&gt;&gt;<br>&gt;&gt;     Here is a little example where `any&lt;&gt;` gets strange:<br>&gt;&gt;<br>&gt;&gt;     func foo(value: any&lt;String, Int&gt;) -&gt; any&lt;String, Int&gt; {<br>&gt;&gt;<br>&gt;&gt;         // how would one use value here?<br>&gt;&gt;         // what about its properties<br>&gt;&gt;         // what will foo return and how to use the result<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     One benefit of `any&lt;&gt;` is the replacement of overloading, at least<br>&gt;&gt;     for the type part of the function.<br>&gt;&gt;<br>&gt;&gt;     I’d like to propose `type&lt;&gt;` as the base extension to the language in<br>&gt;&gt;     that direction, before we’ll move forward with more complex scenarios<br>&gt;&gt;     (just like Chris did with generic typealias).<br>&gt;&gt;<br>&gt;&gt;     This function is clear that it only will work if you provide a<br>&gt;&gt;     subclass of an UIView which conforms to SomeProtocol (nice addition<br>&gt;&gt;     for library design).<br>&gt;&gt;<br>&gt;&gt;     func foo(value: type&lt;UIView, SomeProtocol&gt;) -&gt;<br>&gt;&gt;     type&lt;UIView, SomeProtocol&gt; {<br>&gt;&gt;<br>&gt;&gt;         // use it as a UIView and SomeProtocol at the same type<br>&gt;&gt;         return value // return type works great<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     We can split the value just fine:<br>&gt;&gt;<br>&gt;&gt;     let mergedValue = foo(SomeViewThatWorks)<br>&gt;&gt;     let view: UIView = mergedValue<br>&gt;&gt;     let protocolValue: SomeProtocol = mergedValue<br>&gt;&gt;<br>&gt;&gt;     And merge it back together:<br>&gt;&gt;<br>&gt;&gt;     guard let newMergedValue = view as? type&lt;UIView, SomeProtocol&gt; else {<br>&gt;&gt;     /* do something */ }<br>&gt;&gt;<br>&gt;&gt;     `all&lt;&gt;` could be seen as an alternative name for `type&lt;&gt;`, but to me<br>&gt;&gt;     its not clear what `all&lt;&gt;` can do, whereas `type&lt;&gt;` is almost like<br>&gt;&gt;     `protocol&lt;&gt;`.<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Adrian Zubarev<br>&gt;&gt;     Sent with Airmail<br>&gt;&gt;<br>&gt;&gt;     Am 12. Mai 2016 bei 21:40:24, Thorsten Seitz (tseitz42 at icloud.com<br>&gt;&gt;     &lt;mailto:tseitz42 at icloud.com&gt;) schrieb:<br>&gt;&gt;<br>&gt;&gt;&gt;     Ceylon uses „&amp;&quot; for intersection types, i.e.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     SomeRealClass &amp; SomeProtocol<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     and the bar („|“) for union types, i.e.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     String | Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     That has proven to be very lightweight and readable in Ceylon where<br>&gt;&gt;&gt;     it is heavily used to good effect.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I agree with you that<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     type&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     is much nicer than protocol&lt;&gt; for intersection types but to keep the<br>&gt;&gt;&gt;     door open for union types, I would prefer<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     all&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This would allow<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     any&lt;String, Int&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     to be used for union types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Am 12.05.2016 um 16:09 schrieb Adrian Zubarev via swift-evolution<br>&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     protocol&lt;SomeRealClass, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;     protocol&lt;SomeRealStruct, SomeProtocol&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     This feels really odd to me.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     `type&lt;SomeRealClass, SomeProtocol&gt;` is more clear I’d say.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     I think this would be a good addition to the type system and allow<br>&gt;&gt;&gt;&gt;     us to build more complex and type save code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     But still I’d love to discuss if there might be<br>&gt;&gt;&gt;&gt;     any disadvantages to this feature.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     --<br>&gt;&gt;&gt;&gt;     Adrian Zubarev<br>&gt;&gt;&gt;&gt;     Sent with Airmail<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Am 12. Mai 2016 bei 15:11:00, Vladimir.S (svabox at gmail.com<br>&gt;&gt;&gt;&gt;     &lt;mailto:svabox at gmail.com&gt;) schrieb:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     protocol&lt;&gt;<br>&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; func f(obj: A&amp;B&amp;C) {..}<br>&gt; if obj is A&amp;B&amp;C {...}<br>&gt; obj2 = obj as! A&amp;B&amp;C<br>&gt; <br>&gt; (but I still don&#39;t understand real use case of things like (String | Int))<br>Ceylon has already been mentioned: It uses the concept for its optionals.<br>Swift uses enums, and those could be made obsolete by union types.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 14, 2016 at 11:00:00am</p></header><div class="content"><p>Union types are to enums as tuples are to structs. There&#39;s room for both in<br>the language. Sometimes it makes sense to have a more formalized construct<br>that has specific semantics (like an error type) and methods that operate<br>upon that type. Sometimes, you just want an int OR a string.<br></p><p>On Sat, May 14, 2016 at 10:58 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; func f(obj: A&amp;B&amp;C) {..}<br>&gt; &gt; if obj is A&amp;B&amp;C {...}<br>&gt; &gt; obj2 = obj as! A&amp;B&amp;C<br>&gt; &gt;<br>&gt; &gt; (but I still don&#39;t understand real use case of things like (String |<br>&gt; Int))<br>&gt; Ceylon has already been mentioned: It uses the concept for its optionals.<br>&gt; Swift uses enums, and those could be made obsolete by union types.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/380bfbf9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 16, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br></p><p>I have suggested `all&lt;&gt;` in the past, but I now favor `Any`, because that allows it to be unified with the universal supertype `Any`, `Any&lt;class&gt;`, and things like `Any&lt;Collection&gt;` to forge the One Existential Syntax to rule them all.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 17, 2016 at 07:00:00am</p></header><div class="content"><p>But don&#39;t you mean the union type of all possible Collection types when you write Any&lt;Collection&gt;?<br></p><p>I suggested `all&lt;&gt;` for the intersection type, and `any&lt;&gt;` for the union type, so that would be the same, wouldn&#39;t it?<br></p><p>-Thorsten <br></p><p>Am 17.05.2016 um 07:10 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt; <br>&gt; I have suggested `all&lt;&gt;` in the past, but I now favor `Any`, because that allows it to be unified with the universal supertype `Any`, `Any&lt;class&gt;`, and things like `Any&lt;Collection&gt;` to forge the One Existential Syntax to rule them all.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 16, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; But don&#39;t you mean the union type of all possible Collection types when you write Any&lt;Collection&gt;?<br></p><p>No, I mean &quot;an existential capable of holding any Collection&quot;.<br></p><p>If I write Any&lt;Equatable, Collection&gt;, I mean &quot;an existential capable of holding any Equatable Collection&quot;.<br></p><p>If I write Any&lt;UITableViewCell, CounterDisplaying&gt;, I mean &quot;an existential capable of holding any CounterDisplaying UITableViewCell&quot;.<br></p><p>If I write Any&lt;Collection where .Element: Equatable&gt;, I mean &quot;an existential capable of holding any Collection with an Equatable Element&quot;.<br></p><p>If I write Any&lt;class&gt;, I mean &quot;An existential capable of holding any class instance&quot;.<br></p><p>If I write Any, I mean &quot;An existential capable of holding anything&quot;.<br></p><p>Union types have nothing to do with it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 17, 2016 at 12:00:00am</p></header><div class="content"><p>This is the proposal I&#39;d like to see go before review, and the one I think is closest in spirit to the generics roadmap.<br></p><p>Things like adding union types, and rewriting Swift&#39;s type system to look like Scala&#39;s, have very little to do with better representations of existentials, and belong in a follow-up proposal.<br></p><p>Austin<br></p><p>&gt; On May 16, 2016, at 11:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; But don&#39;t you mean the union type of all possible Collection types when you write Any&lt;Collection&gt;?<br>&gt; <br>&gt; No, I mean &quot;an existential capable of holding any Collection&quot;.<br>&gt; <br>&gt; If I write Any&lt;Equatable, Collection&gt;, I mean &quot;an existential capable of holding any Equatable Collection&quot;.<br>&gt; <br>&gt; If I write Any&lt;UITableViewCell, CounterDisplaying&gt;, I mean &quot;an existential capable of holding any CounterDisplaying UITableViewCell&quot;.<br>&gt; <br>&gt; If I write Any&lt;Collection where .Element: Equatable&gt;, I mean &quot;an existential capable of holding any Collection with an Equatable Element&quot;.<br>&gt; <br>&gt; If I write Any&lt;class&gt;, I mean &quot;An existential capable of holding any class instance&quot;.<br>&gt; <br>&gt; If I write Any, I mean &quot;An existential capable of holding anything&quot;.<br>&gt; <br>&gt; Union types have nothing to do with it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 17, 2016 at 09:00:00am</p></header><div class="content"><p>What do you mean by &quot;go before review&quot;? <br></p><p>I moved the proposal to a new thread: [Proposal] New mechanism to combine Types with/or Protocols <br></p><p>Feel free to read the formatted document, provide me some feedback and point me to typos if you spot any. <br></p><p>I&#39;ll add the possibility to allow multiple reference/value types within the angle brackets as a considered alternative. <br></p><p>I finally understand what Thorsten meant with this example: <br></p><p>func intersect&lt;T, U&gt;(set1: Set&lt;T&gt;, set2: Set&lt;U&gt;) -&gt; Set&lt;All&lt;T, U&gt;&gt; <br></p><p>If T == U we&#39;ll get All&lt;T, T&gt; == T <br></p><p>Or simply: <br></p><p>func intersect&lt;T&gt;(set1: Set&lt;T&gt;, set2: Set&lt;T&gt;) -&gt; Set&lt;All&lt;T&gt;&gt; <br></p><p>This makes more sense to me. :)<br></p><p>-- <br>Adrian Zubarev <br></p><p>Am 17. Mai 2016 um 09:09:55, Austin Zheng via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) schrieb:<br></p><p>&gt; <br>&gt; This is the proposal I&#39;d like to see go before review, and the one I think is closest in spirit to the generics roadmap.<br>&gt; <br>&gt; Things like adding union types, and rewriting Swift&#39;s type system to look like Scala&#39;s, have very little to do with better representations of existentials, and belong in a follow-up proposal.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; &gt; On May 16, 2016, at 11:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; But don&#39;t you mean the union type of all possible Collection types when you write Any&lt;Collection&gt;?<br>&gt; &gt; <br>&gt; &gt; No, I mean &quot;an existential capable of holding any Collection&quot;.<br>&gt; &gt; <br>&gt; &gt; If I write Any&lt;Equatable, Collection&gt;, I mean &quot;an existential capable of holding any Equatable Collection&quot;.<br>&gt; &gt; <br>&gt; &gt; If I write Any&lt;UITableViewCell, CounterDisplaying&gt;, I mean &quot;an existential capable of holding any CounterDisplaying UITableViewCell&quot;.<br>&gt; &gt; <br>&gt; &gt; If I write Any&lt;Collection where .Element: Equatable&gt;, I mean &quot;an existential capable of holding any Collection with an Equatable Element&quot;.<br>&gt; &gt; <br>&gt; &gt; If I write Any&lt;class&gt;, I mean &quot;An existential capable of holding any class instance&quot;.<br>&gt; &gt; <br>&gt; &gt; If I write Any, I mean &quot;An existential capable of holding anything&quot;.<br>&gt; &gt; <br>&gt; &gt; Union types have nothing to do with it.<br>&gt; &gt; <br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/7e7d1f62/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] merge types and protocols back together with type&lt;Type, Protocol, ...&gt;</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 17, 2016 at 12:00:00pm</p></header><div class="content"><p>But don&#39;t you mean the union type of all possible Collection types when you write Any&lt;Collection&gt;?<br></p><p>I suggested `all&lt;&gt;` for the intersection type, and `any&lt;&gt;` for the union type, so that would be the same, wouldn&#39;t it?<br>Thats exactly how I understand out situation by now. I was confused by Thorsten&#39;s `intersection` first, but now I see that he meant the intersection between dynamic type and the whole set of constraints provided by `All&lt;…&gt;`. I thought about about the constraints union compared to the dynamic type, which is most likely the same thing.<br></p><p>In my proposal I reserved the name `Any&lt;&gt;` for future directions, but noted that we still might choose `Any&lt;…&gt;` for the proposed `All&lt;…&gt;` and then name `Any&lt;…&gt;` described by Thorsten as `Either&lt;…&gt;`.<br></p><p><br> &gt;&gt; We&#39;ve been over this a few times before on the list. I personally like naming this thing &quot;Any&lt;…&gt;&quot; in the same vein as &quot;AnyObject&quot;, &quot;AnyClass&quot;, and &quot;AnySequence&quot;. I also see Thorsten (and in the past Brent&#39;s?) argument for calling it &quot;all&quot; or &quot;All&quot;, because it&#39;s enforcing multiple constraints.<br>&gt; <br>&gt; I have suggested `all&lt;&gt;` in the past, but I now favor `Any`, because that allows it to be unified with the universal supertype `Any`, `Any&lt;class&gt;`, and things like `Any&lt;Collection&gt;` to forge the One Existential Syntax to rule them all.<br>I considered `Any&lt;&gt;` as an alternative and personally I don’t have anything against that little change. I still don’t like `AnyObject` because it uses `Object` instead of `Class`, where `AnyClass` is `AnyObject.Type`. This is way to confusing if you ask me. I’d rename both into `ClassInstance` == `AnyObject` and `ClassType` == `AnyClass`. If Swift one day might introduce `struct` and `enum` keywords that are generalized like `class` (could be) what name would you choose? Compared to `AnyClass` typealias `AnyStruct` would be `AnyXYZ.Type`. The only type I like which uses `Any` as its prefix is `Any` itself. <br></p><p>But I guess this is something the core team will decide.<br></p><p>If there is no feedback towards the document I wrote anymore, I’ll submit a pull request later this day. (Note: I’ll add some small changes in the alternatives section about dropping the restriction of a single reference/value type within the angle brackets).<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Mai 2016 bei 07:17:21, Thorsten Seitz via swift-evolution (swift-evolution at swift.org) schrieb:<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160517/40ba34e4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
