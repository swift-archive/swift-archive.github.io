<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 02:00:00am</p></header><div class="content"><p>Hello swift-evolution,<br></p><p>I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while, analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are analogous to NSArrays and NSDictionaries. A first-class container for binary data that is available to every Swift user, conforms to Swift semantics, and is safer and easier to work with than UnsafeBufferPointer seems like a natural fit for the standard library.<br></p><p>As such, I&#39;ve put together a very preliminary proposal, which can be found here: https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md &lt;https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md&gt;. I present it not as a way to impose a vision of what such a Data type should look like, but rather as a way to catalyze discussion (including discussion as to whether or not a Data type is even a good idea in the first place).<br></p><p>Some thoughts:<br></p><p>- It&#39;s not clear if the methods to convert to and from base-64 encoded data are necessary. The state flag that tries to mark whether or not a Data represents base-64-encoded string stored as a data may be unnecessary as well.<br></p><p>- I didn&#39;t really go into how NSData should be bridged. Special consideration needs to be given to how any native Data type would interact with the overlays described in https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;. It&#39;s possible (and only if a compelling technical reason exists) that the Foundation implementation of NSData can in the future be moved into Swift/supplanted by such a native data type, with API extensions to provide conformance to the Objective-C Foundation API. This proposal should not be seen as an attempt to usurp Foundation&#39;s job, though - there are plenty of to-be-value types in Foundation whose inclusion directly in the standard library makes little sense.<br></p><p>- Perhaps Data should be generic over various types of fixed-width integers (signed and unsigned, 8, 16, 32, 64, machine-width, etc). In that case it might also provide generic views (for example, to allow iteration over a Data&lt;UInt64&gt; as if it were a collection of UInt8 bytes). I&#39;m not yet sure if this is feasible or desirable.<br></p><p>Finally, it&#39;s possible that this is strictly Swift 4 territory, in which case I&#39;m happy to withdraw from discussion until the time is right later this year.<br></p><p>Best regards,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/4815f982/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Austin,<br></p><p>The proposal looks well fleshed out! Another alternative to consider is the ‘DispatchData’ struct from libdispatch currently being reviewed? Some of additions these could be added as an extension to that type? Or perhaps a protocol could be made ‘DataProtocol’, that has a base set of required methods and a further set of extensions using that base. Then NSData and DispatchData can conform and implement those base methods and each get the functionality. But personally I think it would be nice to make DispatchData the native Swift data type, whether the libdispatch team would accept extensions in the future like this I don’t know, but I think it would be interesting.<br></p><p>Patrick<br></p><p><br>&gt; On 11 May 2016, at 7:37 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while, analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are analogous to NSArrays and NSDictionaries. A first-class container for binary data that is available to every Swift user, conforms to Swift semantics, and is safer and easier to work with than UnsafeBufferPointer seems like a natural fit for the standard library.<br>&gt; <br>&gt; As such, I&#39;ve put together a very preliminary proposal, which can be found here: https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md &lt;https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md&gt;. I present it not as a way to impose a vision of what such a Data type should look like, but rather as a way to catalyze discussion (including discussion as to whether or not a Data type is even a good idea in the first place).<br>&gt; <br>&gt; Some thoughts:<br>&gt; <br>&gt; - It&#39;s not clear if the methods to convert to and from base-64 encoded data are necessary. The state flag that tries to mark whether or not a Data represents base-64-encoded string stored as a data may be unnecessary as well.<br>&gt; <br>&gt; - I didn&#39;t really go into how NSData should be bridged. Special consideration needs to be given to how any native Data type would interact with the overlays described in https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;. It&#39;s possible (and only if a compelling technical reason exists) that the Foundation implementation of NSData can in the future be moved into Swift/supplanted by such a native data type, with API extensions to provide conformance to the Objective-C Foundation API. This proposal should not be seen as an attempt to usurp Foundation&#39;s job, though - there are plenty of to-be-value types in Foundation whose inclusion directly in the standard library makes little sense.<br>&gt; <br>&gt; - Perhaps Data should be generic over various types of fixed-width integers (signed and unsigned, 8, 16, 32, 64, machine-width, etc). In that case it might also provide generic views (for example, to allow iteration over a Data&lt;UInt64&gt; as if it were a collection of UInt8 bytes). I&#39;m not yet sure if this is feasible or desirable.<br>&gt; <br>&gt; Finally, it&#39;s possible that this is strictly Swift 4 territory, in which case I&#39;m happy to withdraw from discussion until the time is right later this year.<br>&gt; <br>&gt; Best regards,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/530e3246/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Patrick,<br></p><p>Thanks for your feedback!<br></p><p>dispatch_data_t certainly is an intriguing alternative. I don&#39;t think it would be a good fit for a Swift standard library type verbatim, given that it&#39;s written in C and contains APIs that would not really be relevant within a Swift environment, but it should definitely be considered as a model.<br></p><p>One question that this brings up is whether supporting non-contiguous data regions in a native Swift data type is worth the complexity costs. There are good reasons for dispatch_data_t to be implemented the way it is, but NSData has always assumed that it is modeling a contiguous area in memory, and it provides users with raw access to the underlying buffer. A cursory examination of a few other languages (Java, Python, Haskell) show that these languages all model binary data as some sort of contiguous array-like construct containing bytes.<br></p><p>I do think, at the very least, overlays should exist to provide initializers that convert between dispatch_data_t in Swift&#39;s libdispatch, the native Data type, and NSData (if NSData is still to be a separate type after Data is implemented). If contiguity is not important (and there is no compelling reason for access to raw pointers to be exposed in a public interface), it makes a lot of sense to &#39;unify&#39; the various data types under a DataProtocol protocol that inherits from RandomAccessCollection.<br></p><p>Another question is how a Data type&#39;s API will interact with however Swift eventually decides to handle native serialization/deserialization, but that&#39;s almost certainly a &gt;= Swift 4 topic and I won&#39;t go into detail right now.<br></p><p>Austin<br></p><p><br>&gt; On May 11, 2016, at 3:57 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; The proposal looks well fleshed out! Another alternative to consider is the ‘DispatchData’ struct from libdispatch currently being reviewed? Some of additions these could be added as an extension to that type? Or perhaps a protocol could be made ‘DataProtocol’, that has a base set of required methods and a further set of extensions using that base. Then NSData and DispatchData can conform and implement those base methods and each get the functionality. But personally I think it would be nice to make DispatchData the native Swift data type, whether the libdispatch team would accept extensions in the future like this I don’t know, but I think it would be interesting.<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 7:37 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while, analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are analogous to NSArrays and NSDictionaries. A first-class container for binary data that is available to every Swift user, conforms to Swift semantics, and is safer and easier to work with than UnsafeBufferPointer seems like a natural fit for the standard library.<br>&gt;&gt; <br>&gt;&gt; As such, I&#39;ve put together a very preliminary proposal, which can be found here: https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md &lt;https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md&gt;. I present it not as a way to impose a vision of what such a Data type should look like, but rather as a way to catalyze discussion (including discussion as to whether or not a Data type is even a good idea in the first place).<br>&gt;&gt; <br>&gt;&gt; Some thoughts:<br>&gt;&gt; <br>&gt;&gt; - It&#39;s not clear if the methods to convert to and from base-64 encoded data are necessary. The state flag that tries to mark whether or not a Data represents base-64-encoded string stored as a data may be unnecessary as well.<br>&gt;&gt; <br>&gt;&gt; - I didn&#39;t really go into how NSData should be bridged. Special consideration needs to be given to how any native Data type would interact with the overlays described in https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;. It&#39;s possible (and only if a compelling technical reason exists) that the Foundation implementation of NSData can in the future be moved into Swift/supplanted by such a native data type, with API extensions to provide conformance to the Objective-C Foundation API. This proposal should not be seen as an attempt to usurp Foundation&#39;s job, though - there are plenty of to-be-value types in Foundation whose inclusion directly in the standard library makes little sense.<br>&gt;&gt; <br>&gt;&gt; - Perhaps Data should be generic over various types of fixed-width integers (signed and unsigned, 8, 16, 32, 64, machine-width, etc). In that case it might also provide generic views (for example, to allow iteration over a Data&lt;UInt64&gt; as if it were a collection of UInt8 bytes). I&#39;m not yet sure if this is feasible or desirable.<br>&gt;&gt; <br>&gt;&gt; Finally, it&#39;s possible that this is strictly Swift 4 territory, in which case I&#39;m happy to withdraw from discussion until the time is right later this year.<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/86cc23a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, May 11, 2016, at 11:38 AM, Austin Zheng via swift-evolution wrote:<br>&gt; One question that this brings up is whether supporting non-contiguous<br>&gt; data regions in a native Swift data type is worth the complexity<br>&gt; costs. There are good reasons for dispatch_data_t to be implemented<br>&gt; the way it is, but NSData has always assumed that it is modeling a<br>&gt; contiguous area in memory, and it provides users with raw access to<br>&gt; the underlying buffer. A cursory examination of a few other languages<br>&gt; (Java, Python, Haskell) show that these languages all model binary<br>&gt; data as some sort of contiguous array-like construct containing bytes.<br> <br>I do not find this convincing.<br> <br>NSData has not &quot;always assumed&quot; this; that it is transparently bridged<br>with dispatch_data_t on Darwin contradicts that directly.<br> <br>It would be prohibitive on efficiency to have to use the lowest-common-<br>denominator of contiguous bytes to be useful in Swift. XPC and<br>NSURLSession, among others, both use dispatch_data_t via NSData to<br>efficiently push large buffers across process boundaries.<br> <br>That there are complexities involved should not be reason to not address<br>them. It&#39;s 2016 and we don&#39;t always deal with buffers of a conveniently<br>small size, just like we don&#39;t deal with Strings that are conveniently<br>UTF-8. If sufficiently small buffers are the only thing being addressed<br>for ease, then I don&#39;t find the described API that much more valuable<br>than [UInt8] and UnsafeBufferPointer.<br> <br>Another language having represented it a certain way does not make it<br>foregone how Swift must do it. Other languages also lack value types,<br>Unicode-correct strings, or memory safety. Swift is living proof that<br>doing things the way C or Java did is not the automatic solution.<br> <br>Zachary Waldowski<br>zach at waldowski.me<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/04038d85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>This is good to know, thanks! I will look into dispatch_data_t&#39;s<br>implementation more closely; I didn&#39;t know it was bridged to NSData.<br></p><p>I completely agree that if there are no requirements for a contiguous<br>buffer, then there should be no requirement to implement a Data object as a<br>contiguous buffer. There is nothing about the Collection abstraction that<br>requires a contiguous buffer, anyways.<br></p><p>Austin<br></p><p>On Wed, May 11, 2016 at 10:33 AM, Zach Waldowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, May 11, 2016, at 11:38 AM, Austin Zheng via swift-evolution wrote:<br>&gt;<br>&gt; One question that this brings up is whether supporting non-contiguous data<br>&gt; regions in a native Swift data type is worth the complexity costs. There<br>&gt; are good reasons for dispatch_data_t to be implemented the way it is, but<br>&gt; NSData has always assumed that it is modeling a contiguous area in memory,<br>&gt; and it provides users with raw access to the underlying buffer. A cursory<br>&gt; examination of a few other languages (Java, Python, Haskell) show that<br>&gt; these languages all model binary data as some sort of contiguous array-like<br>&gt; construct containing bytes.<br>&gt;<br>&gt;<br>&gt; I do not find this convincing.<br>&gt;<br>&gt; NSData has not &quot;always assumed&quot; this; that it is transparently bridged<br>&gt; with dispatch_data_t on Darwin contradicts that directly.<br>&gt;<br>&gt; It would be prohibitive on efficiency to have to use the<br>&gt; lowest-common-denominator of contiguous bytes to be useful in Swift. XPC<br>&gt; and NSURLSession, among others, both use dispatch_data_t via NSData to<br>&gt; efficiently push large buffers across process boundaries.<br>&gt;<br>&gt; That there are complexities involved should not be reason to not address<br>&gt; them. It&#39;s 2016 and we don&#39;t always deal with buffers of a conveniently<br>&gt; small size, just like we don&#39;t deal with Strings that are conveniently<br>&gt; UTF-8. If sufficiently small buffers are the only thing being addressed for<br>&gt; ease, then I don&#39;t find the described API that much more valuable than<br>&gt; [UInt8] and UnsafeBufferPointer.<br>&gt;<br>&gt; Another language having represented it a certain way does not make it<br>&gt; foregone how Swift must do it. Other languages also lack value types,<br>&gt; Unicode-correct strings, or memory safety. Swift is living proof that doing<br>&gt; things the way C or Java did is not the automatic solution.<br>&gt;<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/f5dde866/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>(By the way, I re-read the quoted part of your message, and I realized the<br>question I posed sounded like a rhetorical question. That wasn&#39;t my intent.<br>I&#39;m sorry about that, and I appreciate you explaining why non-contiguous<br>data buffers have been important for certain use cases.)<br></p><p>Austin<br></p><p>On Wed, May 11, 2016 at 10:47 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>wrote:<br></p><p>&gt; This is good to know, thanks! I will look into dispatch_data_t&#39;s<br>&gt; implementation more closely; I didn&#39;t know it was bridged to NSData.<br>&gt;<br>&gt; I completely agree that if there are no requirements for a contiguous<br>&gt; buffer, then there should be no requirement to implement a Data object as a<br>&gt; contiguous buffer. There is nothing about the Collection abstraction that<br>&gt; requires a contiguous buffer, anyways.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Wed, May 11, 2016 at 10:33 AM, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, May 11, 2016, at 11:38 AM, Austin Zheng via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; One question that this brings up is whether supporting non-contiguous<br>&gt;&gt; data regions in a native Swift data type is worth the complexity costs.<br>&gt;&gt; There are good reasons for dispatch_data_t to be implemented the way it is,<br>&gt;&gt; but NSData has always assumed that it is modeling a contiguous area in<br>&gt;&gt; memory, and it provides users with raw access to the underlying buffer. A<br>&gt;&gt; cursory examination of a few other languages (Java, Python, Haskell) show<br>&gt;&gt; that these languages all model binary data as some sort of contiguous<br>&gt;&gt; array-like construct containing bytes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I do not find this convincing.<br>&gt;&gt;<br>&gt;&gt; NSData has not &quot;always assumed&quot; this; that it is transparently bridged<br>&gt;&gt; with dispatch_data_t on Darwin contradicts that directly.<br>&gt;&gt;<br>&gt;&gt; It would be prohibitive on efficiency to have to use the<br>&gt;&gt; lowest-common-denominator of contiguous bytes to be useful in Swift. XPC<br>&gt;&gt; and NSURLSession, among others, both use dispatch_data_t via NSData to<br>&gt;&gt; efficiently push large buffers across process boundaries.<br>&gt;&gt;<br>&gt;&gt; That there are complexities involved should not be reason to not address<br>&gt;&gt; them. It&#39;s 2016 and we don&#39;t always deal with buffers of a conveniently<br>&gt;&gt; small size, just like we don&#39;t deal with Strings that are conveniently<br>&gt;&gt; UTF-8. If sufficiently small buffers are the only thing being addressed for<br>&gt;&gt; ease, then I don&#39;t find the described API that much more valuable than<br>&gt;&gt; [UInt8] and UnsafeBufferPointer.<br>&gt;&gt;<br>&gt;&gt; Another language having represented it a certain way does not make it<br>&gt;&gt; foregone how Swift must do it. Other languages also lack value types,<br>&gt;&gt; Unicode-correct strings, or memory safety. Swift is living proof that doing<br>&gt;&gt; things the way C or Java did is not the automatic solution.<br>&gt;&gt;<br>&gt;&gt; Zachary Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/90f0424b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 11 May 2016, at 10:37, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; <br></p><p>...<br></p><p>&gt; Some thoughts:<br>&gt; <br>&gt; - It&#39;s not clear if the methods to convert to and from base-64 encoded data are necessary. The state flag that tries to mark whether or not a Data represents base-64-encoded string stored as a data may be unnecessary as well.<br>&gt; <br></p><p>I would definitely vote for having the base64 conversions in. The state flag would have less utility IMO. <br></p><p>I would also ask that you consider conversions to and from hex encoded strings. If nothing else, it would make it easier to convert git commit hashes to a readable form in my forthcoming git client vapourware.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>I think hex encoded string conversion is a important use case. Another idea - instead of making the Data type itself generic, there can be a generic Data.View&lt;T : IntegerType&gt; into the data, or the Data type can come with a number of Views for each of the fixed-width integer types.<br></p><p>Austin<br></p><p><br>&gt; On May 11, 2016, at 7:09 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 10:37, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; ...<br>&gt; <br>&gt;&gt; Some thoughts:<br>&gt;&gt; <br>&gt;&gt; - It&#39;s not clear if the methods to convert to and from base-64 encoded data are necessary. The state flag that tries to mark whether or not a Data represents base-64-encoded string stored as a data may be unnecessary as well.<br>&gt;&gt; <br>&gt; <br>&gt; I would definitely vote for having the base64 conversions in. The state flag would have less utility IMO. <br>&gt; <br>&gt; I would also ask that you consider conversions to and from hex encoded strings. If nothing else, it would make it easier to convert git commit hashes to a readable form in my forthcoming git client vapourware.<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, May 11, 2016 at 2:37 AM, Austin Zheng via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello swift-evolution,<br>&gt;<br>&gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while,<br>&gt; analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are<br>&gt; analogous to NSArrays and NSDictionaries. A first-class container for binary<br>&gt; data that is available to every Swift user, conforms to Swift semantics, and<br>&gt; is safer and easier to work with than UnsafeBufferPointer seems like a<br>&gt; natural fit for the standard library.<br></p><p>Hi Austin,<br></p><p>This is an interesting territory!<br></p><p>One thing that I would like to suggest for us to consider is<br>justifying why Data needs to be a separate type from Array&lt;Int8&gt; and<br>Array&lt;UInt8&gt;.  We can add conditional extensions to Array of Int8 and<br>UInt8 if we find that existing NSData/dispatch_data_t usecases need a<br>few special APIs that won&#39;t make sense on arrays in general.<br></p><p>For example, something that I would imagine people want to do with<br>&quot;data buffer&quot; types is being able to make an unaligned or type punned<br>load or store.  For example, in Java, this is one of the primary<br>usecases for a type similar in spirit, java.nio.ByteBuffer<br>(https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html).<br></p><p>Another usecase that is a crossover between Array and Data, allow<br>Array to (unsafely) adopt ownership of an existing initialized unsafe<br>buffer pointer.  We had quite a few requests for this.  Do you think<br>this is an interesting usecase?  Does it overlap with this discussion?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Dmitri,<br></p><p>Thanks for the feedback! I&#39;m glad that we could start a conversation on the<br>lists, and happy to see people offering their unvarnished opinions.<br></p><p>I think conditional conformances upon Array&lt;UInt8&gt; is definitely an avenue<br>worth exploring. I&#39;m not sure what the performance implications are - Zach<br>brought up use cases in which the ability for a data type to be backed by<br>non-contiguous storage was important. More generally, I wanted to open up<br>discussion as to what people wanted from a native Data type.<br></p><p>It seems like a DataProtocol-like protocol may be a good idea. Array&lt;UInt8&gt;<br>could conform through conditional conformances to provide an implementation<br>for people wanting a simple contiguous buffer that could be punned to an<br>array or other linear collection, while a more robust dispatch_data_t-like<br>conforming Swift stdlib type could be provided for more demanding use<br>cases. This actually seems to be a good fit - if you only care about a data<br>buffer as an arbitrary collection of bytes, the abstract protocol interface<br>gives you flexibility, while if you have requirements that require a<br>specific representation of data in memory you should use a concrete type.<br></p><p>Best,<br>Austin<br></p><p><br></p><p>On Wed, May 11, 2016 at 11:01 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Wed, May 11, 2016 at 2:37 AM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello swift-evolution,<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while,<br>&gt; &gt; analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are<br>&gt; &gt; analogous to NSArrays and NSDictionaries. A first-class container for<br>&gt; binary<br>&gt; &gt; data that is available to every Swift user, conforms to Swift semantics,<br>&gt; and<br>&gt; &gt; is safer and easier to work with than UnsafeBufferPointer seems like a<br>&gt; &gt; natural fit for the standard library.<br>&gt;<br>&gt; Hi Austin,<br>&gt;<br>&gt; This is an interesting territory!<br>&gt;<br>&gt; One thing that I would like to suggest for us to consider is<br>&gt; justifying why Data needs to be a separate type from Array&lt;Int8&gt; and<br>&gt; Array&lt;UInt8&gt;.  We can add conditional extensions to Array of Int8 and<br>&gt; UInt8 if we find that existing NSData/dispatch_data_t usecases need a<br>&gt; few special APIs that won&#39;t make sense on arrays in general.<br>&gt;<br>&gt; For example, something that I would imagine people want to do with<br>&gt; &quot;data buffer&quot; types is being able to make an unaligned or type punned<br>&gt; load or store.  For example, in Java, this is one of the primary<br>&gt; usecases for a type similar in spirit, java.nio.ByteBuffer<br>&gt; (https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html).<br>&gt;<br>&gt; Another usecase that is a crossover between Array and Data, allow<br>&gt; Array to (unsafely) adopt ownership of an existing initialized unsafe<br>&gt; buffer pointer.  We had quite a few requests for this.  Do you think<br>&gt; this is an interesting usecase?  Does it overlap with this discussion?<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/48ba33b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 12, 2016 at 03:00:00am</p></header><div class="content"><p>Hello developers,<br></p><p>After considering everyone&#39;s feedback, I decided to completely rewrite my trial balloon proposal (https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md &lt;https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md&gt;).<br></p><p>In short, much of the API interface has been extracted into a `Data` protocol; two concrete implementations (one exploiting Swift 3&#39;s conditional protocol conformances) can be used for different purposes. The API should properly model data objects using both contiguous and non-contiguous backing stores.<br></p><p>Further thoughts, opinions, criticism, or just ideas as to what a great `Data` type would be capable of doing are much appreciated. Thanks again!<br></p><p>Best,<br>Austin<br></p><p><br>&gt; On May 11, 2016, at 11:29 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Dmitri,<br>&gt; <br>&gt; Thanks for the feedback! I&#39;m glad that we could start a conversation on the lists, and happy to see people offering their unvarnished opinions.<br>&gt; <br>&gt; I think conditional conformances upon Array&lt;UInt8&gt; is definitely an avenue worth exploring. I&#39;m not sure what the performance implications are - Zach brought up use cases in which the ability for a data type to be backed by non-contiguous storage was important. More generally, I wanted to open up discussion as to what people wanted from a native Data type.<br>&gt; <br>&gt; It seems like a DataProtocol-like protocol may be a good idea. Array&lt;UInt8&gt; could conform through conditional conformances to provide an implementation for people wanting a simple contiguous buffer that could be punned to an array or other linear collection, while a more robust dispatch_data_t-like conforming Swift stdlib type could be provided for more demanding use cases. This actually seems to be a good fit - if you only care about a data buffer as an arbitrary collection of bytes, the abstract protocol interface gives you flexibility, while if you have requirements that require a specific representation of data in memory you should use a concrete type.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, May 11, 2016 at 11:01 AM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt; On Wed, May 11, 2016 at 2:37 AM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Hello swift-evolution,<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while,<br>&gt; &gt; analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are<br>&gt; &gt; analogous to NSArrays and NSDictionaries. A first-class container for binary<br>&gt; &gt; data that is available to every Swift user, conforms to Swift semantics, and<br>&gt; &gt; is safer and easier to work with than UnsafeBufferPointer seems like a<br>&gt; &gt; natural fit for the standard library.<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; This is an interesting territory!<br>&gt; <br>&gt; One thing that I would like to suggest for us to consider is<br>&gt; justifying why Data needs to be a separate type from Array&lt;Int8&gt; and<br>&gt; Array&lt;UInt8&gt;.  We can add conditional extensions to Array of Int8 and<br>&gt; UInt8 if we find that existing NSData/dispatch_data_t usecases need a<br>&gt; few special APIs that won&#39;t make sense on arrays in general.<br>&gt; <br>&gt; For example, something that I would imagine people want to do with<br>&gt; &quot;data buffer&quot; types is being able to make an unaligned or type punned<br>&gt; load or store.  For example, in Java, this is one of the primary<br>&gt; usecases for a type similar in spirit, java.nio.ByteBuffer<br>&gt; (https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html &lt;https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html&gt;).<br>&gt; <br>&gt; Another usecase that is a crossover between Array and Data, allow<br>&gt; Array to (unsafely) adopt ownership of an existing initialized unsafe<br>&gt; buffer pointer.  We had quite a few requests for this.  Do you think<br>&gt; this is an interesting usecase?  Does it overlap with this discussion?<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/16098c66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Standard library &#39;Data&#39; type pre-proposal</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 12, 2016 at 12:00:00pm</p></header><div class="content"><p>I think there is a typo on the initialiser from a hex tuple string. The external name of the first parameter should not be `base64EncodedString`. In fact, I’m not sure why base64String and hexTupleString aren’t OK for the external name of first parameter of those initialisers.<br></p><p><br></p><p>&gt; On 12 May 2016, at 11:42, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello developers,<br>&gt; <br>&gt; After considering everyone&#39;s feedback, I decided to completely rewrite my trial balloon proposal (https://github.com/austinzheng/swift-evolution/blob/d2/proposals/XXXX-stdlib-data.md).<br>&gt; <br>&gt; In short, much of the API interface has been extracted into a `Data` protocol; two concrete implementations (one exploiting Swift 3&#39;s conditional protocol conformances) can be used for different purposes. The API should properly model data objects using both contiguous and non-contiguous backing stores.<br>&gt; <br>&gt; Further thoughts, opinions, criticism, or just ideas as to what a great `Data` type would be capable of doing are much appreciated. Thanks again!<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 11:29 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dmitri,<br>&gt;&gt; <br>&gt;&gt; Thanks for the feedback! I&#39;m glad that we could start a conversation on the lists, and happy to see people offering their unvarnished opinions.<br>&gt;&gt; <br>&gt;&gt; I think conditional conformances upon Array&lt;UInt8&gt; is definitely an avenue worth exploring. I&#39;m not sure what the performance implications are - Zach brought up use cases in which the ability for a data type to be backed by non-contiguous storage was important. More generally, I wanted to open up discussion as to what people wanted from a native Data type.<br>&gt;&gt; <br>&gt;&gt; It seems like a DataProtocol-like protocol may be a good idea. Array&lt;UInt8&gt; could conform through conditional conformances to provide an implementation for people wanting a simple contiguous buffer that could be punned to an array or other linear collection, while a more robust dispatch_data_t-like conforming Swift stdlib type could be provided for more demanding use cases. This actually seems to be a good fit - if you only care about a data buffer as an arbitrary collection of bytes, the abstract protocol interface gives you flexibility, while if you have requirements that require a specific representation of data in memory you should use a concrete type.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, May 11, 2016 at 11:01 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; On Wed, May 11, 2016 at 2:37 AM, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Hello swift-evolution,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve been thinking about a standard library &#39;Data&#39; type for a while,<br>&gt;&gt; &gt; analogous to NSData in the same way Swift&#39;s Arrays and Dictionaries are<br>&gt;&gt; &gt; analogous to NSArrays and NSDictionaries. A first-class container for binary<br>&gt;&gt; &gt; data that is available to every Swift user, conforms to Swift semantics, and<br>&gt;&gt; &gt; is safer and easier to work with than UnsafeBufferPointer seems like a<br>&gt;&gt; &gt; natural fit for the standard library.<br>&gt;&gt; <br>&gt;&gt; Hi Austin,<br>&gt;&gt; <br>&gt;&gt; This is an interesting territory!<br>&gt;&gt; <br>&gt;&gt; One thing that I would like to suggest for us to consider is<br>&gt;&gt; justifying why Data needs to be a separate type from Array&lt;Int8&gt; and<br>&gt;&gt; Array&lt;UInt8&gt;.  We can add conditional extensions to Array of Int8 and<br>&gt;&gt; UInt8 if we find that existing NSData/dispatch_data_t usecases need a<br>&gt;&gt; few special APIs that won&#39;t make sense on arrays in general.<br>&gt;&gt; <br>&gt;&gt; For example, something that I would imagine people want to do with<br>&gt;&gt; &quot;data buffer&quot; types is being able to make an unaligned or type punned<br>&gt;&gt; load or store.  For example, in Java, this is one of the primary<br>&gt;&gt; usecases for a type similar in spirit, java.nio.ByteBuffer<br>&gt;&gt; (https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html).<br>&gt;&gt; <br>&gt;&gt; Another usecase that is a crossover between Array and Data, allow<br>&gt;&gt; Array to (unsafely) adopt ownership of an existing initialized unsafe<br>&gt;&gt; buffer pointer.  We had quite a few requests for this.  Do you think<br>&gt;&gt; this is an interesting usecase?  Does it overlap with this discussion?<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
