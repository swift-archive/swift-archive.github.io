<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 22, 2016 at 09:00:00pm</p></header><div class="content"><p>I’d like to throw an idea in the room and see where this will go.<br></p><p>What if Swift would allow us to create custom infix functions?<br>Does Swift need to ability of infix functions? <br>How powerful can such a feature be?<br>Pros and cons?<br></p><p>There is a discussion about the `with` statement which we could develop with infix functions like so:<br></p><p>infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br></p><p>	rhs(lhs)<br>}<br></p><p>class A {<br></p><p>	func foo() {}<br>}<br></p><p>let instance: A = A() with { <br></p><p>	$0.foo()<br>}<br></p><p>So what does the Swift community think about that idea?<br></p><p>-- <br>Adrian Zubarev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/2a951211/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 22, 2016 at 09:00:00pm</p></header><div class="content"><p>I must correct myself, I’m a bit sleepy.<br></p><p>infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) -&gt; T {<br></p><p>    rhs(lhs)<br>    return lhs<br>}<br></p><p>This one will do the trick.<br>-- <br>Adrian Zubarev<br></p><p>Am 22. April 2016 bei 21:07:00, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I’d like to throw an idea in the room and see where this will go.<br></p><p>What if Swift would allow us to create custom infix functions?<br>Does Swift need to ability of infix functions? <br>How powerful can such a feature be?<br>Pros and cons?<br></p><p>There is a discussion about the `with` statement which we could develop with infix functions like so:<br></p><p>infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br></p><p>rhs(lhs)<br>}<br></p><p>class A {<br></p><p>func foo() {}<br>}<br></p><p>let instance: A = A() with { <br></p><p>$0.foo()<br>}<br></p><p>So what does the Swift community think about that idea?<br></p><p>-- <br>Adrian Zubarev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/91956832/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 22, 2016 at 11:00:00pm</p></header><div class="content"><p>On 22.04.2016 22:06, Adrian Zubarev via swift-evolution wrote:<br>&gt; I’d like to throw an idea in the room and see where this will go.<br>&gt;<br>&gt; What if Swift would allow us to create custom infix functions?<br>&gt; Does Swift need to ability of infix functions?<br>&gt; How powerful can such a feature be?<br>&gt; Pros and cons?<br>&gt;<br>&gt; There is a discussion about the `with` statement which we could develop<br>&gt; with infix functions like so:<br></p><p>IMO Such construction will looks like a language construction and will <br>confuse.<br></p><p>And the function you suggest as replacement for &quot;with&quot; feature will *not* <br>correctly handle struct instances (Swift 3.0 mar 24):<br></p><p>struct B { var x = 10 }<br></p><p>func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {  rhs(lhs)  }<br></p><p>var b2 = B()<br>with(b2) { print($0.x) }<br></p><p>It will produce this error :<br>--------------<br>Error running code:<br>l-value expression does not have l-value access kind set<br>...<br>-------------<br></p><p>This is why I propose to introduce standard &quot;with&quot; feature(language feature <br>or built-in method(s)/free function(s)) in Swift out-of-box i.e. tested and <br>well-working solution in any situation. Not some hack/workaround that each <br>one will write for himself and that will not work in some situation.<br></p><p>I can implement &quot;with&quot; method in some way for struct that will work like this:<br></p><p>struct B {<br>	var x = 10<br></p><p>	mutating func withInPlace(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>		var copy = self<br>		user(&amp;copy)<br>		self = copy<br>		return self<br>	}<br></p><p>	func with(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>         	var copy = self<br>		user(&amp;copy)<br>		return copy<br>	}<br>}<br></p><p>var b1 = B().with {<br>     $0.x = 100<br>}<br></p><p>print(&quot;created b1.x = &quot;, b1.x)<br></p><p>b1.withInPlace { $0.x = 1000 }<br></p><p>let c1 = b1.with {<br>     print(&quot;b1.x = &quot;, $0.x)<br>     $0.x = 2000<br>}<br></p><p>print(&quot;b1.x = &quot;, b1.x)<br>print(&quot;c1.x = &quot;, c1.x)<br></p><p>But again, this is custom solution, we need standard and tested way to do this.<br></p><p><br>&gt;<br>&gt; infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br>&gt;<br>&gt; rhs(lhs)<br>&gt; }<br>&gt;<br>&gt; class A {<br>&gt;<br>&gt; func foo() {}<br>&gt; }<br>&gt;<br>&gt; let instance: A = A() with {<br>&gt;<br>&gt; $0.foo()<br>&gt; }<br>&gt;<br>&gt; So what does the Swift community think about that idea?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 22, 2016 at 10:00:00pm</p></header><div class="content"><p>I know that this might be a bit confusing but at least for a syntax highlighting editor this shouldn’t be a problem. Any custom function is displayed with a different color (at least Xcode do).<br></p><p>For structs one could use:<br></p><p>struct B { var x = 10 }<br></p><p>func with&lt;T&gt;(lhs: T, rhs: (inout T) -&gt; Void) -&gt; T {<br></p><p>   var mutableValue = lhs<br>   rhs(&amp;mutableValue)<br>   return mutableValue<br>}<br></p><p>let value = B() with {<br></p><p>   $0.x = 40<br>}<br></p><p>This does even supports Swifty mutation if needed.<br></p><p>`with` statement is just a single example we could create with infix functions.<br></p><p><br>-- <br>Adrian Zubarev<br></p><p>Am 22. April 2016 bei 22:05:11, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>On 22.04.2016 22:06, Adrian Zubarev via swift-evolution wrote:<br>&gt; I’d like to throw an idea in the room and see where this will go.<br>&gt;<br>&gt; What if Swift would allow us to create custom infix functions?<br>&gt; Does Swift need to ability of infix functions?<br>&gt; How powerful can such a feature be?<br>&gt; Pros and cons?<br>&gt;<br>&gt; There is a discussion about the `with` statement which we could develop<br>&gt; with infix functions like so:<br></p><p>IMO Such construction will looks like a language construction and will  <br>confuse.<br></p><p>And the function you suggest as replacement for &quot;with&quot; feature will *not*  <br>correctly handle struct instances (Swift 3.0 mar 24):<br></p><p>struct B { var x = 10 }<br></p><p>func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) { rhs(lhs) }<br></p><p>var b2 = B()<br>with(b2) { print($0.x) }<br></p><p>It will produce this error :<br>--------------<br>Error running code:<br>l-value expression does not have l-value access kind set<br>...<br>-------------<br></p><p>This is why I propose to introduce standard &quot;with&quot; feature(language feature  <br>or built-in method(s)/free function(s)) in Swift out-of-box i.e. tested and  <br>well-working solution in any situation. Not some hack/workaround that each  <br>one will write for himself and that will not work in some situation.<br></p><p>I can implement &quot;with&quot; method in some way for struct that will work like this:<br></p><p>struct B {<br>var x = 10<br></p><p>mutating func withInPlace(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>var copy = self<br>user(&amp;copy)<br>self = copy<br>return self<br>}<br></p><p>func with(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>var copy = self<br>user(&amp;copy)<br>return copy<br>}<br>}<br></p><p>var b1 = B().with {<br>$0.x = 100<br>}<br></p><p>print(&quot;created b1.x = &quot;, b1.x)<br></p><p>b1.withInPlace { $0.x = 1000 }<br></p><p>let c1 = b1.with {<br>print(&quot;b1.x = &quot;, $0.x)<br>$0.x = 2000<br>}<br></p><p>print(&quot;b1.x = &quot;, b1.x)<br>print(&quot;c1.x = &quot;, c1.x)<br></p><p>But again, this is custom solution, we need standard and tested way to do this.<br></p><p><br>&gt;<br>&gt; infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br>&gt;<br>&gt; rhs(lhs)<br>&gt; }<br>&gt;<br>&gt; class A {<br>&gt;<br>&gt; func foo() {}<br>&gt; }<br>&gt;<br>&gt; let instance: A = A() with {<br>&gt;<br>&gt; $0.foo()<br>&gt; }<br>&gt;<br>&gt; So what does the Swift community think about that idea?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/d7747fad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 22, 2016 at 10:00:00pm</p></header><div class="content"><p>Ooops, my bad, I didn’t scroll your reply to the very end and so I didn’t read your full answer.<br></p><p>The custom `with` statement with infix function was just an example that it might be possible to build.<br></p><p>It won’t look that &#39;hacky‘ if Swift would have an explicit protocol for all value types. Something like `AnyValueType`<br></p><p>Then we could easily overload such a custom infix function<br></p><p>infix func with&lt;T: AnyValueType&gt;(lhs: T, rhs: (inout T) -&gt; Void) -&gt; T {<br>		<br>	var mutableValue = lhs<br>	rhs(&amp;mutableValue)<br>	return mutableValue<br>}<br></p><p>infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: (T) -&gt; Void) -&gt; T {<br>		<br>	rhs(lhs)<br>	return lhs<br>}<br></p><p>There is also no chance of such usage, because the `with` function is marked as `infix`<br></p><p>struct B { var x = 10 }<br></p><p>let b = B()<br></p><p>with(b) { print($0.x) } // this won’t be possible at all, infix operators doesn’t allow that so why should infix functions?<br></p><p>As expected we will be able to do something like this:<br></p><p>let newImutableB = B() with {<br></p><p>   $0.x = 40 // mutation here is allowed, because we copy internally and path the new value back<br>}<br></p><p>Infix functions should forbid reserved functions names like `if`, `do`, `else` etc.<br></p><p><br>-- <br>Adrian Zubarev<br></p><p>Am 22. April 2016 bei 22:15:26, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I know that this might be a bit confusing but at least for a syntax highlighting editor this shouldn’t be a problem. Any custom function is displayed with a different color (at least Xcode do).<br></p><p>For structs one could use:<br></p><p>struct B { var x = 10 }<br></p><p>func with&lt;T&gt;(lhs: T, rhs: (inout T) -&gt; Void) -&gt; T {<br></p><p>   var mutableValue = lhs<br>   rhs(&amp;mutableValue)<br>   return mutableValue<br>}<br></p><p>let value = B() with {<br></p><p>   $0.x = 40<br>}<br></p><p>This does even supports Swifty mutation if needed.<br></p><p>`with` statement is just a single example we could create with infix functions.<br></p><p><br>-- <br>Adrian Zubarev<br></p><p>Am 22. April 2016 bei 22:05:11, Vladimir.S via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>On 22.04.2016 22:06, Adrian Zubarev via swift-evolution wrote:<br>&gt; I’d like to throw an idea in the room and see where this will go.<br>&gt;<br>&gt; What if Swift would allow us to create custom infix functions?<br>&gt; Does Swift need to ability of infix functions?<br>&gt; How powerful can such a feature be?<br>&gt; Pros and cons?<br>&gt;<br>&gt; There is a discussion about the `with` statement which we could develop<br>&gt; with infix functions like so:<br></p><p>IMO Such construction will looks like a language construction and will<br>confuse.<br></p><p>And the function you suggest as replacement for &quot;with&quot; feature will *not*<br>correctly handle struct instances (Swift 3.0 mar 24):<br></p><p>struct B { var x = 10 }<br></p><p>func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) { rhs(lhs) }<br></p><p>var b2 = B()<br>with(b2) { print($0.x) }<br></p><p>It will produce this error :<br>--------------<br>Error running code:<br>l-value expression does not have l-value access kind set<br>...<br>-------------<br></p><p>This is why I propose to introduce standard &quot;with&quot; feature(language feature<br>or built-in method(s)/free function(s)) in Swift out-of-box i.e. tested and<br>well-working solution in any situation. Not some hack/workaround that each<br>one will write for himself and that will not work in some situation.<br></p><p>I can implement &quot;with&quot; method in some way for struct that will work like this:<br></p><p>struct B {<br>var x = 10<br></p><p>mutating func withInPlace(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>var copy = self<br>user(&amp;copy)<br>self = copy<br>return self<br>}<br></p><p>func with(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>var copy = self<br>user(&amp;copy)<br>return copy<br>}<br>}<br></p><p>var b1 = B().with {<br>$0.x = 100<br>}<br></p><p>print(&quot;created b1.x = &quot;, b1.x)<br></p><p>b1.withInPlace { $0.x = 1000 }<br></p><p>let c1 = b1.with {<br>print(&quot;b1.x = &quot;, $0.x)<br>$0.x = 2000<br>}<br></p><p>print(&quot;b1.x = &quot;, b1.x)<br>print(&quot;c1.x = &quot;, c1.x)<br></p><p>But again, this is custom solution, we need standard and tested way to do this.<br></p><p><br>&gt;<br>&gt; infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br>&gt;<br>&gt; rhs(lhs)<br>&gt; }<br>&gt;<br>&gt; class A {<br>&gt;<br>&gt; func foo() {}<br>&gt; }<br>&gt;<br>&gt; let instance: A = A() with {<br>&gt;<br>&gt; $0.foo()<br>&gt; }<br>&gt;<br>&gt; So what does the Swift community think about that idea?<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/9bb43fd5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Idea] custom infix functions</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 22, 2016 at 11:00:00pm</p></header><div class="content"><p>I don&#39;t think we should rely only on XCode editor as Swift is open source <br>now and is used on other systems like Linux where we have no XCode. And IMO <br>language should not rely on any editor.<br>Just my opinion. Probably others will find this idea useful.<br></p><p>As for &quot;with&quot;. Yes, I understand that this is just an example. I just <br>wanted to point that &quot;with&quot; feature has some difficulties in implementation <br>and this is why I propose to have it out-of-box in language or in standard lib.<br></p><p>Btw, your code does not work. Please check. I replaced to<br>let value = with(B()) {<br>    $0.x = 40<br>}<br>and had the similar error message(Error running code: ...)<br></p><p>On 22.04.2016 23:15, Adrian Zubarev via swift-evolution wrote:<br>&gt; I know that this might be a bit confusing but at least for a syntax<br>&gt; highlighting editor this shouldn’t be a problem. Any custom function is<br>&gt; displayed with a different color (at least Xcode do).<br>&gt;<br>&gt; For structs one could use:<br>&gt;<br>&gt; struct B { var x = 10 }<br>&gt;<br>&gt; func with&lt;T&gt;(lhs: T, rhs: (inout T) -&gt; Void) -&gt; T {<br>&gt;<br>&gt;    var mutableValue = lhs<br>&gt;    rhs(&amp;mutableValue)<br>&gt;    return mutableValue<br>&gt; }<br>&gt;<br>&gt; let value = B() with {<br>&gt;<br>&gt;    $0.x = 40<br>&gt; }<br>&gt;<br>&gt; This does even supports Swifty mutation if needed.<br>&gt;<br>&gt; `with` statement is just a single example we could create with infix functions.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt;<br>&gt; Am 22. April 2016 bei 22:05:11, Vladimir.S via swift-evolution<br>&gt; (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;<br>&gt;&gt; On 22.04.2016 22:06, Adrian Zubarev via swift-evolution wrote:<br>&gt;&gt; &gt; I’d like to throw an idea in the room and see where this will go.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What if Swift would allow us to create custom infix functions?<br>&gt;&gt; &gt; Does Swift need to ability of infix functions?<br>&gt;&gt; &gt; How powerful can such a feature be?<br>&gt;&gt; &gt; Pros and cons?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There is a discussion about the `with` statement which we could develop<br>&gt;&gt; &gt; with infix functions like so:<br>&gt;&gt;<br>&gt;&gt; IMO Such construction will looks like a language construction and will<br>&gt;&gt; confuse.<br>&gt;&gt;<br>&gt;&gt; And the function you suggest as replacement for &quot;with&quot; feature will *not*<br>&gt;&gt; correctly handle struct instances (Swift 3.0 mar 24):<br>&gt;&gt;<br>&gt;&gt; struct B { var x = 10 }<br>&gt;&gt;<br>&gt;&gt; func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) { rhs(lhs) }<br>&gt;&gt;<br>&gt;&gt; var b2 = B()<br>&gt;&gt; with(b2) { print($0.x) }<br>&gt;&gt;<br>&gt;&gt; It will produce this error :<br>&gt;&gt; --------------<br>&gt;&gt; Error running code:<br>&gt;&gt; l-value expression does not have l-value access kind set<br>&gt;&gt; ...<br>&gt;&gt; -------------<br>&gt;&gt;<br>&gt;&gt; This is why I propose to introduce standard &quot;with&quot; feature(language feature<br>&gt;&gt; or built-in method(s)/free function(s)) in Swift out-of-box i.e. tested and<br>&gt;&gt; well-working solution in any situation. Not some hack/workaround that each<br>&gt;&gt; one will write for himself and that will not work in some situation.<br>&gt;&gt;<br>&gt;&gt; I can implement &quot;with&quot; method in some way for struct that will work like<br>&gt;&gt; this:<br>&gt;&gt;<br>&gt;&gt; struct B {<br>&gt;&gt; var x = 10<br>&gt;&gt;<br>&gt;&gt; mutating func withInPlace(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>&gt;&gt; var copy = self<br>&gt;&gt; user(&amp;copy)<br>&gt;&gt; self = copy<br>&gt;&gt; return self<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func with(user: @noescape (inout B)-&gt;Void) -&gt; B {<br>&gt;&gt; var copy = self<br>&gt;&gt; user(&amp;copy)<br>&gt;&gt; return copy<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var b1 = B().with {<br>&gt;&gt; $0.x = 100<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; print(&quot;created b1.x = &quot;, b1.x)<br>&gt;&gt;<br>&gt;&gt; b1.withInPlace { $0.x = 1000 }<br>&gt;&gt;<br>&gt;&gt; let c1 = b1.with {<br>&gt;&gt; print(&quot;b1.x = &quot;, $0.x)<br>&gt;&gt; $0.x = 2000<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; print(&quot;b1.x = &quot;, b1.x)<br>&gt;&gt; print(&quot;c1.x = &quot;, c1.x)<br>&gt;&gt;<br>&gt;&gt; But again, this is custom solution, we need standard and tested way to do<br>&gt;&gt; this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; infix func with&lt;T: AnyObject&gt;(lhs: T, rhs: @noescape (T) -&gt; Void) {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; rhs(lhs)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class A {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func foo() {}<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let instance: A = A() with {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; $0.foo()<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So what does the Swift community think about that idea?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Adrian Zubarev<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
