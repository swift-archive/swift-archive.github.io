<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 10:00:00pm</p></header><div class="content"><p>on Mon Jan 25 2016, Developer &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Because the shape is what matters to me most.  Whether the type is defined as <br>&gt;<br>&gt; enum Either&lt;L, R&gt; { //... }<br>&gt; enum Result&lt;T, E&gt; { //... }<br>&gt; enum Choice&lt;This, That&gt; { //... }<br>&gt; enum XOR&lt;L, R&gt; { //... }<br>&gt; enum V&lt;L, R&gt; { //... }<br>&gt; enum These&lt;L, R&gt; { //... }<br>&gt;<br>&gt; the point is that the standard library offers a sum type that doesn&#39;t<br>&gt; attempt to invade the space taken over by throws (as I say in the<br>&gt; proposal).  If we are to encourage that, then a type named Result that<br>&gt; has a lobe specifically dedicated to error handling, in some cases<br>&gt; even constrained by ErrorType, is an invasion indeed.  The type<br>&gt; needn&#39;t carry semantics already provided by the language, and in that<br>&gt; case it must carry the most general of semantics: those implied by<br>&gt; structure and reinforced by documentation.<br>&gt;<br>&gt; As for bias, I&#39;ll admit that it is insufficiently addressed in the<br>&gt; proposal (however I do acknowledge this very question would arise).<br>&gt; We chose a left bias because of Rust&#39;s success and a lack of<br>&gt; Haskell-style biased type application to deal with in type classes<br>&gt; (not that we have any now anyway).  From a less technical perspective,<br>&gt; the idea that an error should come first is counterintuitive.  It<br>&gt; makes more sense to emphasize the successful case by placing it<br>&gt; &quot;first&quot;.<br>&gt;<br>&gt; I believe we disagree at such a level, outside of naming and what all<br>&gt; that entails, because this seems like a Haskellism and Haskell&#39;s idea<br>&gt; about error handling is opinionated to some and is made even more so<br>&gt; by an implicit understanding required to interact with the rest of the<br>&gt; ecosystem.  Either is not a fundamentally meaningless type in Haskell,<br>&gt; or here, and it has a very precise interpretation computationally.<br>&gt; Trouble is, conveying that sentiment also inevitably leads to<br>&gt; incredibly technical arguments that leaves novices with a bitter taste<br>&gt; - who wants to learn about Profunctors to figure out why Either had a<br>&gt; right-bias anyhow?  The proposal is aimed towards the Swift community,<br>&gt; not the Haskell one.<br></p><p>I think there is a Haskell-ism problem here, but it&#39;s not about Either.<br>Haskell is very concerned with the shape of types and generalizing<br>computations over those shapes, in a way that makes it hard for many<br>people to grasp semantics.  As cool as that way of thinking about<br>computation is, we want to keep Swift accessible.  Therefore, IMO we<br>really want to avoid introducing type-shape-oriented programming into<br>the core of swift.  Abstractions in the core of Swift should remain tied<br>to understandable semantics; for example, CollectionType.  Even after we<br>have higher-kinded types in the language—as I hope one day we will—I&#39;m<br>skeptical that we&#39;ll want to define Monad or Arrow in the standard<br>library.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Either in the Swift Standard Library</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 10:59 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jan 25 2016, Developer &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Because the shape is what matters to me most.  Whether the type is defined as <br>&gt;&gt; <br>&gt;&gt; enum Either&lt;L, R&gt; { //... }<br>&gt;&gt; enum Result&lt;T, E&gt; { //... }<br>&gt;&gt; enum Choice&lt;This, That&gt; { //... }<br>&gt;&gt; enum XOR&lt;L, R&gt; { //... }<br>&gt;&gt; enum V&lt;L, R&gt; { //... }<br>&gt;&gt; enum These&lt;L, R&gt; { //... }<br>&gt;&gt; <br>&gt;&gt; the point is that the standard library offers a sum type that doesn&#39;t<br>&gt;&gt; attempt to invade the space taken over by throws (as I say in the<br>&gt;&gt; proposal).  If we are to encourage that, then a type named Result that<br>&gt;&gt; has a lobe specifically dedicated to error handling, in some cases<br>&gt;&gt; even constrained by ErrorType, is an invasion indeed.  The type<br>&gt;&gt; needn&#39;t carry semantics already provided by the language, and in that<br>&gt;&gt; case it must carry the most general of semantics: those implied by<br>&gt;&gt; structure and reinforced by documentation.<br>&gt;&gt; <br>&gt;&gt; As for bias, I&#39;ll admit that it is insufficiently addressed in the<br>&gt;&gt; proposal (however I do acknowledge this very question would arise).<br>&gt;&gt; We chose a left bias because of Rust&#39;s success and a lack of<br>&gt;&gt; Haskell-style biased type application to deal with in type classes<br>&gt;&gt; (not that we have any now anyway).  From a less technical perspective,<br>&gt;&gt; the idea that an error should come first is counterintuitive.  It<br>&gt;&gt; makes more sense to emphasize the successful case by placing it<br>&gt;&gt; &quot;first&quot;.<br>&gt;&gt; <br>&gt;&gt; I believe we disagree at such a level, outside of naming and what all<br>&gt;&gt; that entails, because this seems like a Haskellism and Haskell&#39;s idea<br>&gt;&gt; about error handling is opinionated to some and is made even more so<br>&gt;&gt; by an implicit understanding required to interact with the rest of the<br>&gt;&gt; ecosystem.  Either is not a fundamentally meaningless type in Haskell,<br>&gt;&gt; or here, and it has a very precise interpretation computationally.<br>&gt;&gt; Trouble is, conveying that sentiment also inevitably leads to<br>&gt;&gt; incredibly technical arguments that leaves novices with a bitter taste<br>&gt;&gt; - who wants to learn about Profunctors to figure out why Either had a<br>&gt;&gt; right-bias anyhow?  The proposal is aimed towards the Swift community,<br>&gt;&gt; not the Haskell one.<br>&gt; <br>&gt; I think there is a Haskell-ism problem here, but it&#39;s not about Either.<br>&gt; Haskell is very concerned with the shape of types and generalizing<br>&gt; computations over those shapes, in a way that makes it hard for many<br>&gt; people to grasp semantics.  As cool as that way of thinking about<br>&gt; computation is, we want to keep Swift accessible.  Therefore, IMO we<br>&gt; really want to avoid introducing type-shape-oriented programming into<br>&gt; the core of swift.  Abstractions in the core of Swift should remain tied<br>&gt; to understandable semantics; for example, CollectionType.  Even after we<br>&gt; have higher-kinded types in the language—as I hope one day we will—I&#39;m<br>&gt; skeptical that we&#39;ll want to define Monad or Arrow in the standard<br>&gt; library.<br></p><p>I agree. I also think that, if we ever do become interested in shape-generic programming, a more approachable way to expose it would be via D- or Clay-style metaprogramming type traits that provide generic access to the shape of types. Most users want to program in terms of concrete named types, and if they want to take advantage of generic frameworks, they aren&#39;t going to want to marshal back and forth between their concrete domain types and abstract Either&lt;Either&lt;...&gt;&gt; pyramids, or worse, write their code up-front in that style.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/edaccba7/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
