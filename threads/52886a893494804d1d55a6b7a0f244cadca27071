<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Comments inline<br>&gt; A “mutating” keyword on a protocol method is only useful if<br>&gt; you can reason about the mutation in generic code.  <br>&gt; <br>&gt;   protocol P {<br>&gt;     mutating func changeMe()<br>&gt;     func noChange() -&gt; Int<br>&gt;   }<br>&gt; <br>&gt; In other words, given x of some type conforming to P, it should be<br>&gt; meaningful that this is an error:<br>&gt; <br>&gt;   func f&lt;T: P&gt;(x: T) {<br>&gt;     immutable.changeMe() // can&#39;t mutate a &quot;let&quot; binding<br>&gt;   }<br></p><p>Agreed.<br></p><p><br>&gt; which means that you shouldn&#39;t be able to get around that meaning by<br>&gt; writing:<br>&gt; <br>&gt;   func g&lt;T: P&gt;(x: T) {<br>&gt;     var mutable = x<br>&gt;     mutable.changeMe() // OK<br>&gt;   }<br>Now I am confused.  Why should this be illegal?  Doesn’t this work with structs right now? (you are working on a mutable copy)<br></p><p><br>&gt; Also, you should be able to reason that both of the following print the same<br>&gt; thing twice, for types whose methods have no external side-effects:<br>&gt; <br>&gt;   func gg&lt;T: P&gt;(x: T) {<br>&gt;     print(x)<br>&gt;     x.noChange()<br>&gt;     print(x)<br>&gt;   }<br>&gt; <br>&gt;   func ggg&lt;T: P&gt;(x: T) {<br>&gt;     print(x)<br>&gt;     var y = x<br>&gt;     y.changeMe()<br>&gt;     print(x)<br>&gt;   }<br>I see the issue here.  Though, it seems to me it is just a more easily discoverable version of an entire class of problem with reference types in general. X could be changed on a different thread too, for example.  or in a nested function call.<br></p><p>You would also still have the same problem with &#39;let y = x&#39;.<br></p><p><br>&gt; When T is a class type, it can easily violate *all* of these<br>&gt; expectations.  In other words, classes naturally bypass the mutation<br>&gt; model.<br>&gt; <br>&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt; addressed, because of the “viral const” problem.<br>&gt; <br>&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt; methods should be constrained to applying to non-class types.  That<br>&gt; would be a step in the right direction, but, that still leaves cases<br>&gt; like gg able to easily violate expectations when the protocol in<br>&gt; question has no mutating methods.<br>I really *dislike* the approach of disallowing class types for protocols with mutating methods, unless an additional reference type is added.  I have several protocols which have conforming classes and structs and that that lets you choose reference vs value semantics.<br></p><p>I would much rather have us mark class methods as mutating when they change the class’s value, and just having the concept be separate from let/var in that case.<br></p><p>&gt; <br>&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt; apply to values.<br>I would like to have a way to require value semantics in a protocol (similar to how we can require ‘class&#39; now).  I still really want/need the ability to have a protocol which can be adhered to by both value and class types though...<br></p><p>&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt; and we actually can afford to postpone thinking about it until after<br>&gt; Swift 4.<br>&gt; <br>&gt; Thoughts?<br>I would vote to postpone to swift 4, and have it be part of a larger discussion involving the marking of side-effects and thread safe mutability.<br></p><p>If you need a stop-gap for Swift 3, I would be in favor of adding the ability to mark a particular protocol as needing to be a value type (not every protocol… just those that are marked as such).  That should give you the guarantees you need for particular projects.<br></p><p>Thanks,<br>Jon<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/52887071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt;&gt; methods should be constrained to applying to non-class types.  That<br>&gt;&gt; would be a step in the right direction, but, that still leaves cases<br>&gt;&gt; like gg able to easily violate expectations when the protocol in<br>&gt;&gt; question has no mutating methods.<br>&gt;&gt; <br>&gt; I really *dislike* the approach of disallowing class types for protocols with mutating methods, unless an additional reference type is added.  I have several protocols which have conforming classes and structs and that that lets you choose reference vs value semantics.<br>&gt; <br>&gt; I would much rather have us mark class methods as mutating when they change the class’s value, and just having the concept be separate from let/var in that case.<br></p><p>Agreed - I think it’d make more sense this way, too. In some ways, I’m not sure why we don’t just require all mutating methods - even in classes - be declared as such, but perhaps that’s a can of worms and/or boilerplate?<br></p><p><br>&gt;&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt;&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt;&gt; apply to values.<br>&gt;&gt; <br>&gt; I would like to have a way to require value semantics in a protocol (similar to how we can require ‘class&#39; now).  I still really want/need the ability to have a protocol which can be adhered to by both value and class types though...<br></p><p>+1<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Jul 05 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt; Comments inline<br>&gt;&gt; A “mutating” keyword on a protocol method is only useful if<br>&gt;&gt; you can reason about the mutation in generic code.  <br>&gt;&gt; <br>&gt;&gt;   protocol P {<br>&gt;&gt;     mutating func changeMe()<br>&gt;&gt;     func noChange() -&gt; Int<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; In other words, given x of some type conforming to P, it should be<br>&gt;&gt; meaningful that this is an error:<br>&gt;&gt; <br>&gt;&gt;   func f&lt;T: P&gt;(x: T) {<br>&gt;&gt;     immutable.changeMe() // can&#39;t mutate a &quot;let&quot; binding<br>&gt;&gt;   }<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt;&gt; which means that you shouldn&#39;t be able to get around that meaning by<br>&gt;&gt; writing:<br>&gt;&gt; <br>&gt;&gt;   func g&lt;T: P&gt;(x: T) {<br>&gt;&gt;     var mutable = x<br>&gt;&gt;     mutable.changeMe() // OK<br>&gt;&gt;   }<br>&gt; Now I am confused.  Why should this be illegal?  Doesn’t this work with structs right now? (you are working on a mutable copy)<br></p><p>What I meant by “you shouldn&#39;t be able get around that” was that the<br>code shouldn&#39;t change the value of x.<br></p><p>&gt;&gt; Also, you should be able to reason that both of the following print the same<br>&gt;&gt; thing twice, for types whose methods have no external side-effects:<br>&gt;&gt; <br>&gt;&gt;   func gg&lt;T: P&gt;(x: T) {<br>&gt;&gt;     print(x)<br>&gt;&gt;     x.noChange()<br>&gt;&gt;     print(x)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   func ggg&lt;T: P&gt;(x: T) {<br>&gt;&gt;     print(x)<br>&gt;&gt;     var y = x<br>&gt;&gt;     y.changeMe()<br>&gt;&gt;     print(x)<br>&gt;&gt;   }<br>&gt; I see the issue here.  Though, it seems to me it is just a more easily<br>&gt; discoverable version of an entire class of problem with reference<br>&gt; types in general. X could be changed on a different thread too, for<br>&gt; example.  or in a nested function call.<br>&gt;<br>&gt; You would also still have the same problem with &#39;let y = x&#39;.<br>&gt;<br>&gt;&gt; When T is a class type, it can easily violate *all* of these<br>&gt;&gt; expectations.  In other words, classes naturally bypass the mutation<br>&gt;&gt; model.<br>&gt;&gt; <br>&gt;&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt;&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt;&gt; addressed, because of the “viral const” problem.<br>&gt;&gt; <br>&gt;&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt;&gt; methods should be constrained to applying to non-class types.  That<br>&gt;&gt; would be a step in the right direction, but, that still leaves cases<br>&gt;&gt; like gg able to easily violate expectations when the protocol in<br>&gt;&gt; question has no mutating methods.<br>&gt;<br>&gt; I really *dislike* the approach of disallowing class types for<br>&gt; protocols with mutating methods, unless an additional reference type<br>&gt; is added.  I have several protocols which have conforming classes and<br>&gt; structs and that that lets you choose reference vs value semantics.<br></p><p>How do you write generic code that works on both reference and value<br>types conforming to such a protocol?<br></p><p>&gt; I would much rather have us mark class methods as mutating when they<br>&gt; change the class’s value, and just having the concept be separate from<br>&gt; let/var in that case.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt;&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt;&gt; apply to values.<br>&gt;<br>&gt; I would like to have a way to require value semantics in a protocol<br>&gt; (similar to how we can require ‘class&#39; now).  I still really want/need<br>&gt; the ability to have a protocol which can be adhered to by both value<br>&gt; and class types though...<br></p><p>I really want to see examples of generic code that isn&#39;t terribly tricky<br>to write correctly so it will work on both kinds of type.<br></p><p>&gt;&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt;&gt; and we actually can afford to postpone thinking about it until after<br>&gt;&gt; Swift 4.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;<br>&gt; I would vote to postpone to swift 4, and have it be part of a larger<br>&gt; discussion involving the marking of side-effects and thread safe<br>&gt; mutability.<br>&gt;<br>&gt; If you need a stop-gap for Swift 3, I would be in favor of adding the<br>&gt; ability to mark a particular protocol as needing to be a value type<br>&gt; (not every protocol… just those that are marked as such).  That should<br>&gt; give you the guarantees you need for particular projects.<br></p><p>That&#39;s a reasonable stopping point.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p><br>&gt; On Jul 5, 2016, at 2:11 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jul 05 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Comments inline<br>&gt;&gt;&gt; A “mutating” keyword on a protocol method is only useful if<br>&gt;&gt;&gt; you can reason about the mutation in generic code.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol P {<br>&gt;&gt;&gt;    mutating func changeMe()<br>&gt;&gt;&gt;    func noChange() -&gt; Int<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, given x of some type conforming to P, it should be<br>&gt;&gt;&gt; meaningful that this is an error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func f&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    immutable.changeMe() // can&#39;t mutate a &quot;let&quot; binding<br>&gt;&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; Agreed.<br>&gt;&gt; <br>&gt;&gt;&gt; which means that you shouldn&#39;t be able to get around that meaning by<br>&gt;&gt;&gt; writing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func g&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    var mutable = x<br>&gt;&gt;&gt;    mutable.changeMe() // OK<br>&gt;&gt;&gt;  }<br>&gt;&gt; Now I am confused.  Why should this be illegal?  Doesn’t this work with structs right now? (you are working on a mutable copy)<br>&gt; <br>&gt; What I meant by “you shouldn&#39;t be able get around that” was that the<br>&gt; code shouldn&#39;t change the value of x.<br></p><p>Ah.  Gotcha.<br></p><p>In that case, my same comments apply re: general issues of confusion around reference types.  If x is a reference type, then you should even be able to call changeMe() without creating a mutable copy, no?<br></p><p>It sounds like what you are really wanting here is some notion of purity. All of the same arguments from above could be made about side effects in general (of which mutation is one example).<br></p><p><br>&gt;&gt;&gt; Also, you should be able to reason that both of the following print the same<br>&gt;&gt;&gt; thing twice, for types whose methods have no external side-effects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func gg&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;    x.noChange()<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func ggg&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;    var y = x<br>&gt;&gt;&gt;    y.changeMe()<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;  }<br>&gt;&gt; I see the issue here.  Though, it seems to me it is just a more easily<br>&gt;&gt; discoverable version of an entire class of problem with reference<br>&gt;&gt; types in general. X could be changed on a different thread too, for<br>&gt;&gt; example.  or in a nested function call.<br>&gt;&gt; <br>&gt;&gt; You would also still have the same problem with &#39;let y = x&#39;.<br>&gt;&gt; <br>&gt;&gt;&gt; When T is a class type, it can easily violate *all* of these<br>&gt;&gt;&gt; expectations.  In other words, classes naturally bypass the mutation<br>&gt;&gt;&gt; model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt;&gt;&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt;&gt;&gt; addressed, because of the “viral const” problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt;&gt;&gt; methods should be constrained to applying to non-class types.  That<br>&gt;&gt;&gt; would be a step in the right direction, but, that still leaves cases<br>&gt;&gt;&gt; like gg able to easily violate expectations when the protocol in<br>&gt;&gt;&gt; question has no mutating methods.<br>&gt;&gt; <br>&gt;&gt; I really *dislike* the approach of disallowing class types for<br>&gt;&gt; protocols with mutating methods, unless an additional reference type<br>&gt;&gt; is added.  I have several protocols which have conforming classes and<br>&gt;&gt; structs and that that lets you choose reference vs value semantics.<br>&gt; <br>&gt; How do you write generic code that works on both reference and value<br>&gt; types conforming to such a protocol?<br></p><p>I don’t make those assumptions around mutability.  i.e. I know it *could* be a reference type and account for those cases.<br></p><p>I do like the idea of having a way to specify that a protocol can only apply to a value type for the cases where those guarantees around mutability are needed.<br></p><p><br>&gt;&gt; I would much rather have us mark class methods as mutating when they<br>&gt;&gt; change the class’s value, and just having the concept be separate from<br>&gt;&gt; let/var in that case.<br>&gt;&gt; <br>&gt;&gt;&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt;&gt;&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt;&gt;&gt; apply to values.<br>&gt;&gt; <br>&gt;&gt; I would like to have a way to require value semantics in a protocol<br>&gt;&gt; (similar to how we can require ‘class&#39; now).  I still really want/need<br>&gt;&gt; the ability to have a protocol which can be adhered to by both value<br>&gt;&gt; and class types though...<br>&gt; <br>&gt; I really want to see examples of generic code that isn&#39;t terribly tricky<br>&gt; to write correctly so it will work on both kinds of type.<br>&gt; <br>&gt;&gt;&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt;&gt;&gt; and we actually can afford to postpone thinking about it until after<br>&gt;&gt;&gt; Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; I would vote to postpone to swift 4, and have it be part of a larger<br>&gt;&gt; discussion involving the marking of side-effects and thread safe<br>&gt;&gt; mutability.<br>&gt;&gt; <br>&gt;&gt; If you need a stop-gap for Swift 3, I would be in favor of adding the<br>&gt;&gt; ability to mark a particular protocol as needing to be a value type<br>&gt;&gt; (not every protocol… just those that are marked as such).  That should<br>&gt;&gt; give you the guarantees you need for particular projects.<br>&gt; <br>&gt; That&#39;s a reasonable stopping point.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/ff260cd9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>I definitely see Dave’s point here.<br></p><p>It seems to me we can only get generic to the point at which the semantics change. So methods that don’t have any mutating consequences can be applied to any value such as Structs and Classes, but when the semantic relates to mutation, we can only apply that to “All structs” or “all classes” as the behaviour changes dramatically how we deal with it. I can’t see any way around that, but I’d love to see any ideas how we could avoid it.<br></p><p>I think this is definitely somewhere we need a way to declare a protocol can only be implemented on a value type, much like we can say that protocol is only available on classes today.<br></p><p>- Rod<br></p><p><br>&gt; On 6 Jul 2016, at 7:11 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jul 05 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Comments inline<br>&gt;&gt;&gt; A “mutating” keyword on a protocol method is only useful if<br>&gt;&gt;&gt; you can reason about the mutation in generic code.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol P {<br>&gt;&gt;&gt;    mutating func changeMe()<br>&gt;&gt;&gt;    func noChange() -&gt; Int<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, given x of some type conforming to P, it should be<br>&gt;&gt;&gt; meaningful that this is an error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func f&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    immutable.changeMe() // can&#39;t mutate a &quot;let&quot; binding<br>&gt;&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; Agreed.<br>&gt;&gt; <br>&gt;&gt;&gt; which means that you shouldn&#39;t be able to get around that meaning by<br>&gt;&gt;&gt; writing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func g&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    var mutable = x<br>&gt;&gt;&gt;    mutable.changeMe() // OK<br>&gt;&gt;&gt;  }<br>&gt;&gt; Now I am confused.  Why should this be illegal?  Doesn’t this work with structs right now? (you are working on a mutable copy)<br>&gt; <br>&gt; What I meant by “you shouldn&#39;t be able get around that” was that the<br>&gt; code shouldn&#39;t change the value of x.<br>&gt; <br>&gt;&gt;&gt; Also, you should be able to reason that both of the following print the same<br>&gt;&gt;&gt; thing twice, for types whose methods have no external side-effects:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func gg&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;    x.noChange()<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func ggg&lt;T: P&gt;(x: T) {<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;    var y = x<br>&gt;&gt;&gt;    y.changeMe()<br>&gt;&gt;&gt;    print(x)<br>&gt;&gt;&gt;  }<br>&gt;&gt; I see the issue here.  Though, it seems to me it is just a more easily<br>&gt;&gt; discoverable version of an entire class of problem with reference<br>&gt;&gt; types in general. X could be changed on a different thread too, for<br>&gt;&gt; example.  or in a nested function call.<br>&gt;&gt; <br>&gt;&gt; You would also still have the same problem with &#39;let y = x&#39;.<br>&gt;&gt; <br>&gt;&gt;&gt; When T is a class type, it can easily violate *all* of these<br>&gt;&gt;&gt; expectations.  In other words, classes naturally bypass the mutation<br>&gt;&gt;&gt; model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt;&gt;&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt;&gt;&gt; addressed, because of the “viral const” problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt;&gt;&gt; methods should be constrained to applying to non-class types.  That<br>&gt;&gt;&gt; would be a step in the right direction, but, that still leaves cases<br>&gt;&gt;&gt; like gg able to easily violate expectations when the protocol in<br>&gt;&gt;&gt; question has no mutating methods.<br>&gt;&gt; <br>&gt;&gt; I really *dislike* the approach of disallowing class types for<br>&gt;&gt; protocols with mutating methods, unless an additional reference type<br>&gt;&gt; is added.  I have several protocols which have conforming classes and<br>&gt;&gt; structs and that that lets you choose reference vs value semantics.<br>&gt; <br>&gt; How do you write generic code that works on both reference and value<br>&gt; types conforming to such a protocol?<br>&gt; <br>&gt;&gt; I would much rather have us mark class methods as mutating when they<br>&gt;&gt; change the class’s value, and just having the concept be separate from<br>&gt;&gt; let/var in that case.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt;&gt;&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt;&gt;&gt; apply to values.<br>&gt;&gt; <br>&gt;&gt; I would like to have a way to require value semantics in a protocol<br>&gt;&gt; (similar to how we can require ‘class&#39; now).  I still really want/need<br>&gt;&gt; the ability to have a protocol which can be adhered to by both value<br>&gt;&gt; and class types though...<br>&gt; <br>&gt; I really want to see examples of generic code that isn&#39;t terribly tricky<br>&gt; to write correctly so it will work on both kinds of type.<br>&gt; <br>&gt;&gt;&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt;&gt;&gt; and we actually can afford to postpone thinking about it until after<br>&gt;&gt;&gt; Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; I would vote to postpone to swift 4, and have it be part of a larger<br>&gt;&gt; discussion involving the marking of side-effects and thread safe<br>&gt;&gt; mutability.<br>&gt;&gt; <br>&gt;&gt; If you need a stop-gap for Swift 3, I would be in favor of adding the<br>&gt;&gt; ability to mark a particular protocol as needing to be a value type<br>&gt;&gt; (not every protocol… just those that are marked as such).  That should<br>&gt;&gt; give you the guarantees you need for particular projects.<br>&gt; <br>&gt; That&#39;s a reasonable stopping point.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/bd2a1f9c/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
