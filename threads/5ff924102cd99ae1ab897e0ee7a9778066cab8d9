<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt;From https://swift.org/about/: &quot;The most obvious way to write code should<br>also behave in a safe manner.&quot;<br></p><p>To this end I think that closures should capture references types weakly by<br>default. Pretty much the only way I know of to (easily) create memory<br>issues with pure swift is to capture a strong reference in a closure.<br></p><p>I think with consideration when designing asynchronous APIs this could be<br>quite painless.<br></p><p>Cases weak may be excluded:<br> * If the closure is @noescape<br> * If the object&#39;s lifetime is provably limited to the block<br> * If it&#39;s a value type<br></p><p>I think the upsides by far outweigh the downsides.<br></p><p>Upside:<br> * no more surprises<br> * safer code<br></p><p>Downsides:<br> * You may sometimes have to use optional chaining or similar to resolve a<br>weak reference.<br> * Beginners need to understand optionals, but they&#39;re likely to do so<br>before learning blocks.<br> * There&#39;s probably a few edge cases I haven&#39;t explored, and a few more<br>here:<br></p><p>class Test {<br>   func doSomething(v: Int) { ... }<br>   func async(callback: Int-&gt;Void) {<br>      doWork { value in<br>           callback?(value)<br>      }<br>   }<br>}<br></p><p>self.test = Test()<br>self.test.async(test.doSomething) // what is the lifetime<br>of test.doSomething?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/5ff9b8d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>I don&#39;t think this would satisfy the principle of &quot;working as expected&quot;,<br>e.g.:<br></p><p>class Computer {<br>    func compute() -&gt; Int { ... }<br>}<br></p><p>func test() {<br></p><p>    let c = Computer()<br></p><p>    // Expected: the closure executes in the background<br>    dispatch_async(...) {<br></p><p>        let computed = c.compute()<br>        print(computed)<br></p><p>        let computed2 = c.compute()<br>        print(computed2)<br>    }<br></p><p>}<br></p><p>Actual result if the proposal passes: the closure will not compile as c<br>will be optional.<br></p><p>Moreover, you&#39;ll have some beginners who will fix it with<br></p><p>    dispatch_async(...) {<br></p><p>        if let computed = c?.compute() {<br>            print(computed)<br>        }<br></p><p>        if let computed2 = c?.compute() {<br>            print(computed2)<br>        }<br>    }<br></p><p>which has entirely different logic, as now any of those situations is<br>possible:<br>(1) both computed and computed2 are printed<br>(2) none of those is printed<br>(3) only computed is printed<br></p><p>On Tue, Dec 8, 2015 at 14:15 Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From https://swift.org/about/: &quot;The most obvious way to write code should<br>&gt; also behave in a safe manner.&quot;<br>&gt;<br>&gt; To this end I think that closures should capture references types weakly<br>&gt; by default. Pretty much the only way I know of to (easily) create memory<br>&gt; issues with pure swift is to capture a strong reference in a closure.<br>&gt;<br>&gt; I think with consideration when designing asynchronous APIs this could be<br>&gt; quite painless.<br>&gt;<br>&gt; Cases weak may be excluded:<br>&gt;  * If the closure is @noescape<br>&gt;  * If the object&#39;s lifetime is provably limited to the block<br>&gt;  * If it&#39;s a value type<br>&gt;<br>&gt; I think the upsides by far outweigh the downsides.<br>&gt;<br>&gt; Upside:<br>&gt;  * no more surprises<br>&gt;  * safer code<br>&gt;<br>&gt; Downsides:<br>&gt;  * You may sometimes have to use optional chaining or similar to resolve a<br>&gt; weak reference.<br>&gt;  * Beginners need to understand optionals, but they&#39;re likely to do so<br>&gt; before learning blocks.<br>&gt;  * There&#39;s probably a few edge cases I haven&#39;t explored, and a few more<br>&gt; here:<br>&gt;<br>&gt; class Test {<br>&gt;    func doSomething(v: Int) { ... }<br>&gt;    func async(callback: Int-&gt;Void) {<br>&gt;       doWork { value in<br>&gt;            callback?(value)<br>&gt;       }<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; self.test = Test()<br>&gt; self.test.async(test.doSomething) // what is the lifetime<br>&gt; of test.doSomething?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c4a76f6e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>I would like to also note that referencing an object (whether self or<br>otherwise) does not necessarily create a permanent retain cycle. Only<br>long-lived closures will cause these issues. In many other cases, retaining<br>objects inside a closure is actually what you want, to ensure they&#39;re still<br>alive by the time the closure is called.<br>In general, no matter what the default is, my hunch is that this is one of<br>those &quot;hard problems&quot; (essential complexity:<br>https://en.m.wikipedia.org/wiki/No_Silver_Bullet), and one must think about<br>the lifetime semantics of the constructions in their code and the APIs<br>they&#39;re using to understand the implications of using weak or strong<br>captures, and whether they will cause retain cycles or premature<br>deallocations.<br>On Tue, Dec 8, 2015 at 4:08 AM ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t think this would satisfy the principle of &quot;working as expected&quot;,<br>&gt; e.g.:<br>&gt;<br>&gt; class Computer {<br>&gt;     func compute() -&gt; Int { ... }<br>&gt; }<br>&gt;<br>&gt; func test() {<br>&gt;<br>&gt;     let c = Computer()<br>&gt;<br>&gt;     // Expected: the closure executes in the background<br>&gt;     dispatch_async(...) {<br>&gt;<br>&gt;         let computed = c.compute()<br>&gt;         print(computed)<br>&gt;<br>&gt;         let computed2 = c.compute()<br>&gt;         print(computed2)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Actual result if the proposal passes: the closure will not compile as c<br>&gt; will be optional.<br>&gt;<br>&gt; Moreover, you&#39;ll have some beginners who will fix it with<br>&gt;<br>&gt;     dispatch_async(...) {<br>&gt;<br>&gt;         if let computed = c?.compute() {<br>&gt;             print(computed)<br>&gt;         }<br>&gt;<br>&gt;         if let computed2 = c?.compute() {<br>&gt;             print(computed2)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; which has entirely different logic, as now any of those situations is<br>&gt; possible:<br>&gt; (1) both computed and computed2 are printed<br>&gt; (2) none of those is printed<br>&gt; (3) only computed is printed<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 14:15 Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; From https://swift.org/about/: &quot;The most obvious way to write code<br>&gt;&gt; should also behave in a safe manner.&quot;<br>&gt;&gt;<br>&gt;&gt; To this end I think that closures should capture references types weakly<br>&gt;&gt; by default. Pretty much the only way I know of to (easily) create memory<br>&gt;&gt; issues with pure swift is to capture a strong reference in a closure.<br>&gt;&gt;<br>&gt;&gt; I think with consideration when designing asynchronous APIs this could be<br>&gt;&gt; quite painless.<br>&gt;&gt;<br>&gt;&gt; Cases weak may be excluded:<br>&gt;&gt;  * If the closure is @noescape<br>&gt;&gt;  * If the object&#39;s lifetime is provably limited to the block<br>&gt;&gt;  * If it&#39;s a value type<br>&gt;&gt;<br>&gt;&gt; I think the upsides by far outweigh the downsides.<br>&gt;&gt;<br>&gt;&gt; Upside:<br>&gt;&gt;  * no more surprises<br>&gt;&gt;  * safer code<br>&gt;&gt;<br>&gt;&gt; Downsides:<br>&gt;&gt;  * You may sometimes have to use optional chaining or similar to resolve<br>&gt;&gt; a weak reference.<br>&gt;&gt;  * Beginners need to understand optionals, but they&#39;re likely to do so<br>&gt;&gt; before learning blocks.<br>&gt;&gt;  * There&#39;s probably a few edge cases I haven&#39;t explored, and a few more<br>&gt;&gt; here:<br>&gt;&gt;<br>&gt;&gt; class Test {<br>&gt;&gt;    func doSomething(v: Int) { ... }<br>&gt;&gt;    func async(callback: Int-&gt;Void) {<br>&gt;&gt;       doWork { value in<br>&gt;&gt;            callback?(value)<br>&gt;&gt;       }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; self.test = Test()<br>&gt;&gt; self.test.async(test.doSomething) // what is the lifetime<br>&gt;&gt; of test.doSomething?<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c51bf124/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 07:00:00am</p></header><div class="content"><p>Capturing weak by default is not safe. ARC optimization will shrinkwrap the lifetimes of strong references to their last strong use, so capturing a local variable that references a fresh object would cause the object to immediately go away:<br></p><p>let x = NSObject()<br>dispatch_sync {[weak x] in x!.foo() } // x can already be gone by this point<br></p><p>There&#39;s no one right answer here.<br></p><p>-Joe<br></p><p>&gt; On Dec 8, 2015, at 3:15 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; From https://swift.org/about/ &lt;https://swift.org/about/&gt;: &quot;The most obvious way to write code should also behave in a safe manner.&quot;<br>&gt; <br>&gt; To this end I think that closures should capture references types weakly by default. Pretty much the only way I know of to (easily) create memory issues with pure swift is to capture a strong reference in a closure.<br>&gt; <br>&gt; I think with consideration when designing asynchronous APIs this could be quite painless.<br>&gt; <br>&gt; Cases weak may be excluded:<br>&gt;  * If the closure is @noescape<br>&gt;  * If the object&#39;s lifetime is provably limited to the block<br>&gt;  * If it&#39;s a value type<br>&gt; <br>&gt; I think the upsides by far outweigh the downsides.<br>&gt; <br>&gt; Upside:<br>&gt;  * no more surprises<br>&gt;  * safer code<br>&gt; <br>&gt; Downsides:<br>&gt;  * You may sometimes have to use optional chaining or similar to resolve a weak reference.<br>&gt;  * Beginners need to understand optionals, but they&#39;re likely to do so before learning blocks.<br>&gt;  * There&#39;s probably a few edge cases I haven&#39;t explored, and a few more here:<br>&gt; <br>&gt; class Test {<br>&gt;    func doSomething(v: Int) { ... }<br>&gt;    func async(callback: Int-&gt;Void) {<br>&gt;       doWork { value in<br>&gt;            callback?(value)<br>&gt;       }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; self.test = Test()<br>&gt; self.test.async(test.doSomething) // what is the lifetime of test.doSomething?<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/86111f45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 7:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Capturing weak by default is not safe. ARC optimization will shrinkwrap the lifetimes of strong references to their last strong use, so capturing a local variable that references a fresh object would cause the object to immediately go away:<br>&gt; <br>&gt; let x = NSObject()<br>&gt; dispatch_sync {[weak x] in x!.foo() } // x can already be gone by this point<br>&gt; <br>&gt; There&#39;s no one right answer here.<br></p><p>One reason cycles are so prevalent with closures is that it&#39;s easy to capture too much, since referencing &#39;self.foo&#39; always captures the entirety of &#39;self&#39;. If the properties of &#39;self&#39; you need are immutable, or you don&#39;t need to see their mutations, you can reduce the risk of cycles by capturing those properties explicitly, turning this:<br></p><p>self.setCallback { doStuffWith(self.zim, self.zang) }<br></p><p>into:<br></p><p>self.setCallback {[zim, zang] in doStuffWith(zim, zang) }<br></p><p>For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having closures capture the *property* directly by default in this way instead of capturing &#39;self&#39; (and possibly allowing referencing them without &#39;self.&#39;, since &#39;self&#39; wouldn&#39;t be involved in any cycle formed this way).<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/43745890/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>Joe, a very good idea to allow directly capturing a value bound to an<br>immutable name without self keyword!<br>On Tue, Dec 8, 2015 at 18:55 Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 8, 2015, at 7:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; Capturing weak by default is not safe. ARC optimization will shrinkwrap<br>&gt; the lifetimes of strong references to their last strong use, so capturing a<br>&gt; local variable that references a fresh object would cause the object to<br>&gt; immediately go away:<br>&gt;<br>&gt; let x = NSObject()<br>&gt; dispatch_sync {[weak x] in x!.foo() } // x can already be gone by this<br>&gt; point<br>&gt;<br>&gt; There&#39;s no one right answer here.<br>&gt;<br>&gt;<br>&gt; One reason cycles are so prevalent with closures is that it&#39;s easy to<br>&gt; capture too much, since referencing &#39;self.foo&#39; always captures the entirety<br>&gt; of &#39;self&#39;. If the properties of &#39;self&#39; you need are immutable, or you don&#39;t<br>&gt; need to see their mutations, you can reduce the risk of cycles by capturing<br>&gt; those properties explicitly, turning this:<br>&gt;<br>&gt; self.setCallback { doStuffWith(self.zim, self.zang) }<br>&gt;<br>&gt;<br>&gt; into:<br>&gt;<br>&gt; self.setCallback {[zim, zang] in doStuffWith(zim, zang) }<br>&gt;<br>&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having<br>&gt; closures capture the *property* directly by default in this way instead of<br>&gt; capturing &#39;self&#39; (and possibly allowing referencing them without &#39;self.&#39;,<br>&gt; since &#39;self&#39; wouldn&#39;t be involved in any cycle formed this way).<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/33cd5a04/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having closures capture the *property* directly by default in this way instead of capturing ‘self&#39;<br></p><p>That would be fantastic.<br></p><p>I’ve also wondered whether there’s a tidy way for a closure to be tied to the lifecycle of self, so that when self goes away, the closure goes away too. That’s often the desired behavior. On a casual thinking through, though, it seems like a can of worms — and the “guard let self = self else { return }” proposal on another thread gives most of the same benefit.<br></p><p>P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br></p><p>Three reasons:<br></p><p>REASON 1. When `self` is not mandatory, then adding self should have no impact whatsoever.<br></p><p>Why should one add a self that is not mandatory?<br></p><p>1. for symmetry (1):<br></p><p>	self.foo = other.foo<br>	let delta = self.x - other.x<br></p><p>2. for symmetry (2):<br>	<br>	init(a:String, index:Int) {<br>		self.name = name<br>		self.position = index+1	// keep 1-based value for implementation reasons<br>	}<br></p><p>3. add your own reasons to use an explicit self even when not required, and I’m sure you did.<br></p><p>So generally speaking, using self when not mandatory should have no impact on the program at all.<br></p><p><br>REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br></p><p>That’s not good at all.<br></p><p><br>REASON 3. It’s simply not clear. Clever, terse, smart, brilliant, but not clear.<br></p><p>Compare to:<br></p><p>	// Obviously only `foo` is captured, and not self:<br>	let foo = self.foo<br>	performClosure { foo }<br></p><p>My two cents.<br>Gwendal Roué<br></p><p><br>&gt; Le 8 déc. 2015 à 18:01, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having closures capture the *property* directly by default in this way instead of capturing ‘self&#39;<br>&gt; <br>&gt; That would be fantastic.<br>&gt; <br>&gt; I’ve also wondered whether there’s a tidy way for a closure to be tied to the lifecycle of self, so that when self goes away, the closure goes away too. That’s often the desired behavior. On a casual thinking through, though, it seems like a can of worms — and the “guard let self = self else { return }” proposal on another thread gives most of the same benefit.<br>&gt; <br>&gt; P<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December  8, 2015 at 06:00:00pm</p></header><div class="content"><p>Oh, and the concerned reader will have noticed another use of a non-mandatory self in the last sample code:<br></p><p>	// Obviously only `foo` is captured, and not self:<br>	let foo = self.foo<br>	performClosure { foo }<br></p><p>Gwendal Roué<br></p><p>&gt; Le 8 déc. 2015 à 18:28, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I’m really not found at all of having `let` properties captured by closures when used without explicit `self`.<br>&gt; <br>&gt; Three reasons:<br>&gt; <br>&gt; REASON 1. When `self` is not mandatory, then adding self should have no impact whatsoever.<br>&gt; <br>&gt; Why should one add a self that is not mandatory?<br>&gt; <br>&gt; 1. for symmetry (1):<br>&gt; <br>&gt; 	self.foo = other.foo<br>&gt; 	let delta = self.x - other.x<br>&gt; <br>&gt; 2. for symmetry (2):<br>&gt; 	<br>&gt; 	init(a:String, index:Int) {<br>&gt; 		self.name = name<br>&gt; 		self.position = index+1	// keep 1-based value for implementation reasons<br>&gt; 	}<br>&gt; <br>&gt; 3. add your own reasons to use an explicit self even when not required, and I’m sure you did.<br>&gt; <br>&gt; So generally speaking, using self when not mandatory should have no impact on the program at all.<br>&gt; <br>&gt; <br>&gt; REASON 2. What happens when a property starts its life as `let`, but turns `var` eventually? For example, the property eventually becomes lazy. OK now it’s is illegal to use the property without explicit `self` in closures, and you break a bunch of code. And you need to bump the major version of your package. Just because you turn a `let foo: String` into `lazy var foo: String = …`.<br>&gt; <br>&gt; That’s not good at all.<br>&gt; <br>&gt; <br>&gt; REASON 3. It’s simply not clear. Clever, terse, smart, brilliant, but not clear.<br>&gt; <br>&gt; Compare to:<br>&gt; <br>&gt; 	// Obviously only `foo` is captured, and not self:<br>&gt; 	let foo = self.foo<br>&gt; 	performClosure { foo }<br>&gt; <br>&gt; My two cents.<br>&gt; Gwendal Roué<br>&gt; <br>&gt; <br>&gt;&gt; Le 8 déc. 2015 à 18:01, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having closures capture the *property* directly by default in this way instead of capturing ‘self&#39;<br>&gt;&gt; <br>&gt;&gt; That would be fantastic.<br>&gt;&gt; <br>&gt;&gt; I’ve also wondered whether there’s a tidy way for a closure to be tied to the lifecycle of self, so that when self goes away, the closure goes away too. That’s often the desired behavior. On a casual thinking through, though, it seems like a can of worms — and the “guard let self = self else { return }” proposal on another thread gives most of the same benefit.<br>&gt;&gt; <br>&gt;&gt; P<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 08:00:00pm</p></header><div class="content"><p>As for 1, isn&#39;t the compiler allowed to optimize away self.foo call?<br></p><p>More generally. if we have<br></p><p>class X { let const = 4 }<br></p><p>let x = X()<br>let closure = {  print(x.const) }<br></p><p>is the compiler required to actually capture x? Can&#39;t it rewrite closure as<br>{ print(4) }? I feel like memory semantics is/should be an implementation<br>detail.<br></p><p>Ilya.<br></p><p>On Tue, Dec 8, 2015 at 8:28 PM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I’m really not found at all of having `let` properties captured by<br>&gt; closures when used without explicit `self`.<br>&gt;<br>&gt; Three reasons:<br>&gt;<br>&gt; REASON 1. When `self` is not mandatory, then adding self should have no<br>&gt; impact whatsoever.<br>&gt;<br>&gt; Why should one add a self that is not mandatory?<br>&gt;<br>&gt; 1. for symmetry (1):<br>&gt;<br>&gt;         self.foo = other.foo<br>&gt;         let delta = self.x - other.x<br>&gt;<br>&gt; 2. for symmetry (2):<br>&gt;<br>&gt;         init(a:String, index:Int) {<br>&gt;                 self.name = name<br>&gt;                 self.position = index+1 // keep 1-based value for<br>&gt; implementation reasons<br>&gt;         }<br>&gt;<br>&gt; 3. add your own reasons to use an explicit self even when not required,<br>&gt; and I’m sure you did.<br>&gt;<br>&gt; So generally speaking, using self when not mandatory should have no impact<br>&gt; on the program at all.<br>&gt;<br>&gt;<br>&gt; REASON 2. What happens when a property starts its life as `let`, but turns<br>&gt; `var` eventually? For example, the property eventually becomes lazy. OK now<br>&gt; it’s is illegal to use the property without explicit `self` in closures,<br>&gt; and you break a bunch of code. And you need to bump the major version of<br>&gt; your package. Just because you turn a `let foo: String` into `lazy var foo:<br>&gt; String = …`.<br>&gt;<br>&gt; That’s not good at all.<br>&gt;<br>&gt;<br>&gt; REASON 3. It’s simply not clear. Clever, terse, smart, brilliant, but not<br>&gt; clear.<br>&gt;<br>&gt; Compare to:<br>&gt;<br>&gt;         // Obviously only `foo` is captured, and not self:<br>&gt;         let foo = self.foo<br>&gt;         performClosure { foo }<br>&gt;<br>&gt; My two cents.<br>&gt; Gwendal Roué<br>&gt;<br>&gt;<br>&gt; &gt; Le 8 déc. 2015 à 18:01, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having<br>&gt; closures capture the *property* directly by default in this way instead of<br>&gt; capturing ‘self&#39;<br>&gt; &gt;<br>&gt; &gt; That would be fantastic.<br>&gt; &gt;<br>&gt; &gt; I’ve also wondered whether there’s a tidy way for a closure to be tied<br>&gt; to the lifecycle of self, so that when self goes away, the closure goes<br>&gt; away too. That’s often the desired behavior. On a casual thinking through,<br>&gt; though, it seems like a can of worms — and the “guard let self = self else<br>&gt; { return }” proposal on another thread gives most of the same benefit.<br>&gt; &gt;<br>&gt; &gt; P<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/b2f60007/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>On Tue, Dec 8, 2015, at 07:55 AM, Joe Groff via swift-evolution wrote:<br>&gt; One reason cycles are so prevalent with closures is that it&#39;s easy to capture too much, since referencing &#39;self.foo&#39; always captures the entirety of &#39;self&#39;. If the properties of &#39;self&#39; you need are immutable, or you don&#39;t need to see their mutations, you can reduce the risk of cycles by capturing those properties explicitly, turning this:<br>&gt;<br>&gt;&gt; self.setCallback { doStuffWith(self.zim, self.zang) }<br>&gt;<br>&gt; into:<br>&gt;<br>&gt;&gt; self.setCallback {[zim, zang] in doStuffWith(zim, zang) }<br>&gt;&gt;<br>&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having<br>&gt; closures capture the *property* directly by default in this way<br>&gt; instead of capturing &#39;self&#39; (and possibly allowing referencing them<br>&gt; without &#39;self.&#39;, since &#39;self&#39; wouldn&#39;t be involved in any cycle formed<br>&gt; this way).<br></p><p>Interesting idea, but I&#39;m concerned that this would be surprising and<br>open up a different class of bug, where properties of self<br>unexpectedly outlive self even though they were never referenced<br>without going through self. This can be a problem if self has a<br>deinit that does relevant work, or if the values of the properties<br>themselves depend on self somehow. As a trivial example, a property<br>of self might contain an unowned reference back to self, because it<br>knows it will never outlive self, at least until this rule is<br>introduced and causes a dispatch_async() to access the unowned<br>reference after self has deinited.<br></p><p>Personally, I&#39;m happy with just using an explicit capture list for my<br>properties if I don&#39;t want to capture self. Using this along with the<br>practice of always omitting the `self.` whenever possible means the<br>compiler yells at me if I accidentally capture self in an escaping<br>closure (e.g. when I try and use a method/property without the `self.`),<br>forcing me to make a decision there about whether I want to capture self<br>or add a capture list for the property.<br></p><p>Another alternative is to require an explicit capture list to capture<br>self in an escaping closure, so you have to say `[self]` or `[weak<br>self]`. This way you&#39;re forced to make a decision always. Potential<br>downsides I can think of:<br></p><p>1. It&#39;s verbose. Application code often has a lot of escaping closures,<br>   and most of them probably don&#39;t have capture lists, so that&#39;s a lot<br>   of capture lists to add.<br>2. It&#39;s still possible to accidentally capture self without realizing it<br>   by use of a local nested function that is itself captured. Of course,<br>   this is the same scenario that lets you capture self without even<br>   writing `self.` since local nested functions allow you to omit the<br>   `self.`, so it&#39;s already a known issue.<br>3. How does this interact with captures of self from enclosing closures?<br>   Right now, if I have `{ [weak self] in foo({ /* self is still weak<br>   here */ }) }`; does the inner closure need a capture list or not? How<br>   about if the outer capture is strong? `{ [self] in foo({ /* self is<br>   strong here */ }) }`? Of course, this rule would fix the current<br>   hazard of weakly capturing self at the wrong level, e.g. `{ foo({<br>   [weak self] in ... }) }` where self is strongly captured in the outer<br>   closure, which seems to surprise people. Although now that I think of<br>   it, I&#39;ll probably submit a proposal to change that, so the outer<br>   closure captures self weakly if it&#39;s only capturing it at all because<br>   of a weak capture in a nested closure.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/9a1d0eb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  9, 2015 at 09:00:00am</p></header><div class="content"><p>Thanks everyone for joining the discussion, I&#39;m glad that other people are<br>thinking about this too. I should have mentioned up-front, in case it was<br>unclear, I think this needs more discussion before it&#39;s ready as a formal<br>proposal.<br></p><p>I think most people here seem to agree that blocks capturing objects can be<br>a problem, and we don&#39;t want to have to type a bunch of new things to deal<br>with it. What we&#39;re unsure of is how to deal with it.<br></p><p>The only thing I explicitly didn&#39;t agree with was that { self!.foo } is a<br>problem because of self being weak. I think the problem here is the use of<br>force-unwrap.<br></p><p>Also, I think that the discussion about when properties are immutable, and<br>not necessarily being able to configure an immutable structure is a good<br>one. It is also perhaps off-topic, except where it affects the scope of<br>impact of this proposal. Do we agree that it&#39;s sufficient for this proposal<br>to say that some properties could be captured as value types, and as the<br>swift compiler gets smarter those cases will grow?<br></p><p>In Ilya&#39;s example:<br>if let computed = c?.compute() {<br>    print(computed)<br>}<br>I agree that this will change what the code does, but I think a programmer<br>using dispatch_async will be familiar with if-statements, and so should be<br>able to determine the implications. I think that in this case the IDE would<br>suggest two solutions &quot;add ? to c.compute()&quot; and &quot;strongly capture c &lt;a<br>warning about retain cycles&gt;&quot;. I think the important thing would be that<br>the &quot;default&quot; case is that you don&#39;t have memory issues, you can&#39;t compile<br>the code if you haven&#39;t acknowledged that with &#39;?&#39; or &#39;[strong c]&#39;.<br></p><p>Kevin, I think you should definitely propose that (weak in outer and inner<br>closure), it&#39;s one of the surprises that led me to this proposal. I also<br>really like your suggesting of requiring explicit weak/strong on self, I<br>think this could solve many cases. What I&#39;m not sure of is whether this<br>should be restricted to self, or the &quot;owners&quot; of the block calling method.<br>ie.<br></p><p>func doWork(something: Something) {<br>     something.calculateSomeStuff { (a,b) in<br>          return self.calculate(a,b)<br>     }<br>}<br></p><p>In this case I think that strong/weak should be made explicit on<br>&#39;something&#39; not on &#39;self&#39;.<br></p><p>I think that the main points at the moment are:<br> 1. The impact of requiring explicit strong/weak on self/something.<br> 2. How often requiring &#39;strong&#39; on *non-trivial* captures would happen.<br> 3. If you can mitigate most cases with small changes to APIs.<br></p><p>An example of an api change would be:<br></p><p>let data = 123<br>worker.doWork { [strong worker] (item: Item) in<br>    worker.work(data, withItem: item)<br>}<br></p><p>becomes:<br></p><p>let data = 123<br>worker.doWork { (worker: Worker, item: Item) in<br>    worker.work(data, withItem: item)<br>}<br></p><p><br>On Wed, Dec 9, 2015 at 6:28 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Dec 8, 2015, at 07:55 AM, Joe Groff via swift-evolution wrote:<br>&gt;<br>&gt; One reason cycles are so prevalent with closures is that it&#39;s easy to<br>&gt; capture too much, since referencing &#39;self.foo&#39; always captures the entirety<br>&gt; of &#39;self&#39;. If the properties of &#39;self&#39; you need are immutable, or you don&#39;t<br>&gt; need to see their mutations, you can reduce the risk of cycles by capturing<br>&gt; those properties explicitly, turning this:<br>&gt;<br>&gt;<br>&gt; self.setCallback { doStuffWith(self.zim, self.zang) }<br>&gt;<br>&gt;<br>&gt; into:<br>&gt;<br>&gt;<br>&gt; self.setCallback {[zim, zang] in doStuffWith(zim, zang) }<br>&gt;<br>&gt;<br>&gt; For &#39;let&#39; properties of classes, it&#39;d be reasonable to propose having<br>&gt; closures capture the *property* directly by default in this way instead of<br>&gt; capturing &#39;self&#39; (and possibly allowing referencing them without &#39;self.&#39;,<br>&gt; since &#39;self&#39; wouldn&#39;t be involved in any cycle formed this way).<br>&gt;<br>&gt;<br>&gt; Interesting idea, but I&#39;m concerned that this would be surprising and open<br>&gt; up a different class of bug, where properties of self unexpectedly outlive<br>&gt; self even though they were never referenced without going through self.<br>&gt; This can be a problem if self has a deinit that does relevant work, or if<br>&gt; the values of the properties themselves depend on self somehow. As a<br>&gt; trivial example, a property of self might contain an unowned reference back<br>&gt; to self, because it knows it will never outlive self, at least until this<br>&gt; rule is introduced and causes a dispatch_async() to access the unowned<br>&gt; reference after self has deinited.<br>&gt;<br>&gt; Personally, I&#39;m happy with just using an explicit capture list for my<br>&gt; properties if I don&#39;t want to capture self. Using this along with the<br>&gt; practice of always omitting the `self.` whenever possible means the<br>&gt; compiler yells at me if I accidentally capture self in an escaping closure<br>&gt; (e.g. when I try and use a method/property without the `self.`), forcing me<br>&gt; to make a decision there about whether I want to capture self or add a<br>&gt; capture list for the property.<br>&gt;<br>&gt; Another alternative is to require an explicit capture list to capture self<br>&gt; in an escaping closure, so you have to say `[self]` or `[weak self]`. This<br>&gt; way you&#39;re forced to make a decision always. Potential downsides I can<br>&gt; think of:<br>&gt;<br>&gt; 1. It&#39;s verbose. Application code often has a lot of escaping closures,<br>&gt; and most of them probably don&#39;t have capture lists, so that&#39;s a lot of<br>&gt; capture lists to add.<br>&gt; 2. It&#39;s still possible to accidentally capture self without realizing it<br>&gt; by use of a local nested function that is itself captured. Of course, this<br>&gt; is the same scenario that lets you capture self without even writing<br>&gt; `self.` since local nested functions allow you to omit the `self.`, so it&#39;s<br>&gt; already a known issue.<br>&gt; 3. How does this interact with captures of self from enclosing closures?<br>&gt; Right now, if I have `{ [weak self] in foo({ /* self is still weak here */<br>&gt; }) }`; does the inner closure need a capture list or not? How about if the<br>&gt; outer capture is strong? `{ [self] in foo({ /* self is strong here */ })<br>&gt; }`? Of course, this rule would fix the current hazard of weakly capturing<br>&gt; self at the wrong level, e.g. `{ foo({ [weak self] in ... }) }` where self<br>&gt; is strongly captured in the outer closure, which seems to surprise people.<br>&gt; Although now that I think of it, I&#39;ll probably submit a proposal to change<br>&gt; that, so the outer closure captures self weakly if it&#39;s only capturing it<br>&gt; at all because of a weak capture in a nested closure.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/37ff85f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>On Tue, Dec 8, 2015, at 02:57 PM, Andrew Bennett wrote:<br>&gt; Kevin, I think you should definitely propose that (weak in outer and<br>&gt; inner closure), it&#39;s one of the surprises that led me to this<br>&gt; proposal. I also really like your suggesting of requiring explicit<br>&gt; weak/strong on self, I think this could solve many cases.<br></p><p>I submitted the proposal as<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001134.html<br>(unfortunately it looks like the plain text version got garbled :/).<br></p><p>Regarding explicit weak/strong, my feeling is it would probably get too<br>annoying to have to type `[self] in` everywhere. But it may be worth<br>playing with.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/1111dba7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>Perhaps this is something where we could have a few compiler options to<br>handle different preferences.<br></p><p>You could have options like:<br> * -Wexplicit-owner-capture (for explicit self)<br> * -Wexplicit-capture (for explicit non-trivial references)<br></p><p><br>On Wed, Dec 9, 2015 at 10:15 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; On Tue, Dec 8, 2015, at 02:57 PM, Andrew Bennett wrote:<br>&gt;<br>&gt; Kevin, I think you should definitely propose that (weak in outer and inner<br>&gt; closure), it&#39;s one of the surprises that led me to this proposal. I also<br>&gt; really like your suggesting of requiring explicit weak/strong on self, I<br>&gt; think this could solve many cases.<br>&gt;<br>&gt;<br>&gt; I submitted the proposal as<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001134.html (unfortunately<br>&gt; it looks like the plain text version got garbled :/).<br>&gt;<br>&gt; Regarding explicit weak/strong, my feeling is it would probably get too<br>&gt; annoying to have to type `[self] in` everywhere. But it may be worth<br>&gt; playing with.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f1425a2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Closures capture weak by default</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>IMO, this has been one of many reasons why Swift doesn&#39;t have flags for its warnings yet: we do not want to fracture the language into dialects based on style, and we&#39;d rather not have one person&#39;s code spew warnings in another person&#39;s build. (Admittedly, the warnings could be controlled by package preferences, but still.)<br></p><p>Jordan<br></p><p>&gt; On Dec 8, 2015, at 15:26, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Perhaps this is something where we could have a few compiler options to handle different preferences.<br>&gt; <br>&gt; You could have options like:<br>&gt;  * -Wexplicit-owner-capture (for explicit self)<br>&gt;  * -Wexplicit-capture (for explicit non-trivial references)<br>&gt; <br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 10:15 AM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt; On Tue, Dec 8, 2015, at 02:57 PM, Andrew Bennett wrote:<br>&gt;&gt; Kevin, I think you should definitely propose that (weak in outer and inner closure), it&#39;s one of the surprises that led me to this proposal. I also really like your suggesting of requiring explicit weak/strong on self, I think this could solve many cases.<br>&gt;  <br>&gt; I submitted the proposal as https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001134.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001134.html&gt; (unfortunately it looks like the plain text version got garbled :/).<br>&gt;  <br>&gt; Regarding explicit weak/strong, my feeling is it would probably get too annoying to have to type `[self] in` everywhere. But it may be worth playing with.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/9daa5cab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
