<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br></p><p>In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br></p><p>NSDate *myDate = //…<br>NSTimeInterval someTimeInterval = //…<br></p><p>The “*” helps us see that myDate is a pointer to an instance of NSDate.<br></p><p>We see this in methods that return values as well<br></p><p>- (NSString *)aStrringReturningMethod // …<br>- (NSInteger)numberOfMistakesInThisEmail //...<br></p><p>I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br></p><p>However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br></p><p>I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br></p><p>Thank you,<br></p><p>Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c753185b2c9261f9da6bf4372036cd07?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Sean Kosanovich</string> &lt;sean7512 at me.com&gt;<p>December 17, 2015 at 07:00:00am</p></header><div class="content"><p>I can definitely see value in knowing if you’re dealing with a Value or Reference Type.  Of course, the easy answer is to just look at the documentation/definition, but that is slow.<br></p><p>Likewise, pointer notation feels old and looks messy.  I am not sure of a great way to show this, any suggestions?<br></p><p><br></p><p>&gt; On Dec 17, 2015, at 7:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt; <br>&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt; <br>&gt; NSDate *myDate = //…<br>&gt; NSTimeInterval someTimeInterval = //…<br>&gt; <br>&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt; <br>&gt; We see this in methods that return values as well<br>&gt; <br>&gt; - (NSString *)aStrringReturningMethod // …<br>&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt; <br>&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt; <br>&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt; <br>&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Daniel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc0180c1b9aff52f5d42a1ca6bd1f184?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Thomas Catterall</string> &lt;me at swizzlr.co&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>I would be interested in exploring more responsive IDEs that could reveal this information contextually, rather than embedding it within the source files. In the same way we can option click on a decl and see the type, being able to surface that information in a useful manner would be ideal.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 17 Dec 2015, at 07:52, Sean Kosanovich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can definitely see value in knowing if you’re dealing with a Value or Reference Type.  Of course, the easy answer is to just look at the documentation/definition, but that is slow.<br>&gt; <br>&gt; Likewise, pointer notation feels old and looks messy.  I am not sure of a great way to show this, any suggestions?<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 7:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt;&gt; <br>&gt;&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt;&gt; <br>&gt;&gt; NSDate *myDate = //…<br>&gt;&gt; NSTimeInterval someTimeInterval = //…<br>&gt;&gt; <br>&gt;&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt;&gt; <br>&gt;&gt; We see this in methods that return values as well<br>&gt;&gt; <br>&gt;&gt; - (NSString *)aStrringReturningMethod // …<br>&gt;&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt;&gt; <br>&gt;&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt;&gt; <br>&gt;&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt;&gt; <br>&gt;&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>This does not seem very practical as there is a whole continuum of<br>behaviors between pure value (like Int) and reference (like UIWindow)<br>types.<br></p><p>Consider for example<br></p><p>NSURL: an object, but immutable<br>Array: a struct, but doesn&#39;t take extra space if copied without mutation<br>Either&lt;T, U&gt;: an enum is similar to a struct, but may very well wrap a<br>mutable class instance<br></p><p><br>On Thu, Dec 17, 2015 at 3:23 PM, Daniel Steinberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The way in which we reason about instances of value types and instances of<br>&gt; reference types is significantly different and yet there is no way to<br>&gt; easily distinguish them in Swift.<br>&gt;<br>&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we<br>&gt; can tell that NSDate is a reference type and NSTimeInterval is a value type<br>&gt; by looking at how it is used in code<br>&gt;<br>&gt; NSDate *myDate = //…<br>&gt; NSTimeInterval someTimeInterval = //…<br>&gt;<br>&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt;<br>&gt; We see this in methods that return values as well<br>&gt;<br>&gt; - (NSString *)aStrringReturningMethod // …<br>&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt;<br>&gt; I realize that this is a result of Objective-C living in C’s world and we<br>&gt; don’t have that constraint in Swift.<br>&gt;<br>&gt; However, this means that when the semantics of variables, parameters,<br>&gt; properties, and return values from methods is not always clear in our code.<br>&gt; Because structs can have methods in Swift it is all to easy to confuse an<br>&gt; instance of a struct with an instance of a class.<br>&gt;<br>&gt; I may be alone here, but I think it would be less confusing if there were<br>&gt; some way to distinguish between value types and reference types in code.<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; Daniel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/1b8aeadf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 4:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt; <br>&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt; <br>&gt; NSDate *myDate = //…<br>&gt; NSTimeInterval someTimeInterval = //…<br>&gt; <br>&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt; <br>&gt; We see this in methods that return values as well<br>&gt; <br>&gt; - (NSString *)aStrringReturningMethod // …<br>&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt; <br>&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt; <br>&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt; <br>&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br></p><p>The real differences happen whenever you mutate them by part (assignment acts the same), which suggests that they should have different syntax for member access, e.g. someObject-&gt;mutatingMethod() vs. someValue.mutatingMethod().<br></p><p>Personally, I like that sort of thing.  Not to discourage you, but I think most people don’t recognize that types with value semantics are fundamentally different from those with reference semantics, e.g. avoiding a syntactic barrier between them was an explicit design goal of Swift 1.  Also I don’t think you’d find much support for even a 1-character penalty on method calls and property accesses to classes.  So, while I think we ought to do something in this direction, I expect it to be hard-won.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 17, 2015, at 3:33 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 4:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt;&gt; <br>&gt;&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt;&gt; <br>&gt;&gt; NSDate *myDate = //…<br>&gt;&gt; NSTimeInterval someTimeInterval = //…<br>&gt;&gt; <br>&gt;&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt;&gt; <br>&gt;&gt; We see this in methods that return values as well<br>&gt;&gt; <br>&gt;&gt; - (NSString *)aStrringReturningMethod // …<br>&gt;&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt;&gt; <br>&gt;&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt;&gt; <br>&gt;&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt;&gt; <br>&gt;&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br>&gt; <br>&gt; The real differences happen whenever you mutate them by part (assignment acts the same), which suggests that they should have different syntax for member access, e.g. someObject-&gt;mutatingMethod() vs. someValue.mutatingMethod().<br></p><p>Of course real differences also exist in the possibility that someone else could mutate a shared instance of a reference type behind your back.  Representing this difference syntactically requires a type annotation, not just a different syntax for member access.  It&#39;s also worth noting that value types and non-shared instances of reference types actually have pretty similar semantics.<br></p><p>I would like to think there is a good way to clearly represent these differences in a language as they are quite important.  The reality so far has been that attempting to do so introduces quite a bit of complexity.  Rust is a current example of this.<br></p><p>My understanding is that an important goal for Swift is to avoid this kind of complexity in the type system and in the syntax.  As noted in this thread doing so doesn&#39;t make it go away, it just sweeps it under the rug a bit.<br></p><p>If there were a way to surface the important semantic distinctions without making the language terribly complex and without sacrificing semantically valid generic code it would probably be embraced.  I think this is just a really hard problem for which we don&#39;t yet have a great solution. <br></p><p>&gt; <br>&gt; Personally, I like that sort of thing.  Not to discourage you, but I think most people don’t recognize that types with value semantics are fundamentally different from those with reference semantics, e.g. avoiding a syntactic barrier between them was an explicit design goal of Swift 1.  Also I don’t think you’d find much support for even a 1-character penalty on method calls and property accesses to classes.  So, while I think we ought to do something in this direction, I expect it to be hard-won.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/c9753b3a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15947d27758dc90df81fd42c4a387bbb?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>James Dempsey</string> &lt;dempsey at mac.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>Daniel,<br></p><p>It occurs to me that if there was such a thing in Swift, the distinction would be lost in any code that used protocols for typing since both value and reference types can implement the same protocol.<br></p><p>That doesn’t mean what you suggest would not be useful, just adding for consideration that there is a significant use case that potentially would not be covered.<br></p><p>James<br></p><p>&gt; On Dec 17, 2015, at 4:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt; <br>&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt; <br>&gt; NSDate *myDate = //…<br>&gt; NSTimeInterval someTimeInterval = //…<br>&gt; <br>&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt; <br>&gt; We see this in methods that return values as well<br>&gt; <br>&gt; - (NSString *)aStrringReturningMethod // …<br>&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt; <br>&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt; <br>&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt; <br>&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Daniel<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Pre proposal: Should there be a way to distinguish class instances from struct instances</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 17, 2015 at 06:00:00pm</p></header><div class="content"><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Dec 17, 2015, at 4:26 PM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Daniel,<br>&gt; <br>&gt; It occurs to me that if there was such a thing in Swift, the distinction would be lost in any code that used protocols for typing since both value and reference types can implement the same protocol.<br></p><p>In an ideal world, most protocols-at least those with mutating members- would be constrained to either value or reference-semantic types, as most generic components you can write inevitably make assumptions about the logical (in)dependence of a and b after you execute a = b. I&#39;m sure the world would break if you made a CollectionType whose Index was a class, for example. But we don&#39;t currently have a way in the language to represent &quot;has value semantics&quot; (since value types can hold references) or &quot;is constrained to have value semantics&quot;. <br></p><p>&gt; That doesn’t mean what you suggest would not be useful, just adding for consideration that there is a significant use case that potentially would not be covered.<br>&gt; <br>&gt; James<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 4:23 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The way in which we reason about instances of value types and instances of reference types is significantly different and yet there is no way to easily distinguish them in Swift.<br>&gt;&gt; <br>&gt;&gt; In Objective-C, for example, if we have an NSDate and an NSTimeInterval we can tell that NSDate is a reference type and NSTimeInterval is a value type by looking at how it is used in code<br>&gt;&gt; <br>&gt;&gt; NSDate *myDate = //…<br>&gt;&gt; NSTimeInterval someTimeInterval = //…<br>&gt;&gt; <br>&gt;&gt; The “*” helps us see that myDate is a pointer to an instance of NSDate.<br>&gt;&gt; <br>&gt;&gt; We see this in methods that return values as well<br>&gt;&gt; <br>&gt;&gt; - (NSString *)aStrringReturningMethod // …<br>&gt;&gt; - (NSInteger)numberOfMistakesInThisEmail //...<br>&gt;&gt; <br>&gt;&gt; I realize that this is a result of Objective-C living in C’s world and we don’t have that constraint in Swift.<br>&gt;&gt; <br>&gt;&gt; However, this means that when the semantics of variables, parameters, properties, and return values from methods is not always clear in our code. Because structs can have methods in Swift it is all to easy to confuse an instance of a struct with an instance of a class.<br>&gt;&gt; <br>&gt;&gt; I may be alone here, but I think it would be less confusing if there were some way to distinguish between value types and reference types in code.<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
