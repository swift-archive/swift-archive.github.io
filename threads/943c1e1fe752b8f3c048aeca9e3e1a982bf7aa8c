<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/698e94ec61aae18a4cae067ad645b3fb?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Jeremy W. Sherman</string> &lt;jeremyw.sherman at gmail.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>Ah bother, the list doesn&#39;t default reply-to to the list? (Or iOS mail doesn&#39;t respect the header.)<br>--<br>Jeremy W. Sherman<br>http://jeremywsherman.com/<br></p><p>Inicio del mensaje reenviado:<br></p><p>&gt; De: &quot;Jeremy W. Sherman&quot; &lt;jeremyw.sherman at gmail.com&gt;<br>&gt; Fecha: 1 de marzo de 2016, 10:30:05 GMT-5<br>&gt; Para: Kyle Sherman &lt;kyledsherman at gmail.com&gt;<br>&gt; Asunto: Re: [swift-evolution] [Discussion] Enforcing Calling Super<br>&gt; <br>&gt; Does this handle the case of required super only since a version?<br>&gt; <br>&gt; I recall NSView or something like that gaining an awakeFromNib implementation late, say 10.5 or so, so that one had to conditionalize calls to [super awakeFromNib] based on whether or not the superclass&#39;s instances responded to that selector. If your code was running on 10.4, calling super would crash with unrecognized selector; if on 10.5, you were always supposed to call super.<br>&gt; <br>&gt; This suggests some interaction between requiring calls to super and availability annotations at the least.<br>&gt; --<br>&gt; Jeremy W. Sherman<br>&gt; http://jeremywsherman.com/<br>&gt; <br>&gt;&gt; El 17-02-2016, a las 13:02, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt;&gt; <br>&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt; <br>&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt;&gt; <br>&gt;&gt; The subject was: “Replace the override keyword by ‘extend’ and ‘replace’ or add an annotation like @SuppressSuperCall”<br>&gt;&gt; <br>&gt;&gt; -Kyle<br>&gt;&gt; <br>&gt;&gt; # Enforcing Calling Super<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt; <br>&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt; <br>&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt; <br>&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; class MyClass {<br>&gt;&gt;     @requiredSuper func foo1() { }<br>&gt;&gt; <br>&gt;&gt;     @requiredSuper(start) func foo2() { }<br>&gt;&gt; <br>&gt;&gt;     @requiredSuper(end) func foo3() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt; Overridden method must call the superclass’s implementation<br>&gt;&gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt;&gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt; <br>&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public class MyClass {<br>&gt;&gt;     @requiredSuper func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The compiler should show an error, such as “A method using @requiredSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt; <br>&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/943caa8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>Great catch Jeremy. I&#39;m not sure how the availability API works with other annotations. Does anyone know if this is possible?<br></p><p>&gt; On Mar 1, 2016, at 7:31 AM, Jeremy W. Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ah bother, the list doesn&#39;t default reply-to to the list? (Or iOS mail doesn&#39;t respect the header.)<br>&gt; --<br>&gt; Jeremy W. Sherman<br>&gt; http://jeremywsherman.com/ &lt;http://jeremywsherman.com/&gt;<br>&gt; <br>&gt; Inicio del mensaje reenviado:<br>&gt; <br>&gt;&gt; De: &quot;Jeremy W. Sherman&quot; &lt;jeremyw.sherman at gmail.com &lt;mailto:jeremyw.sherman at gmail.com&gt;&gt;<br>&gt;&gt; Fecha: 1 de marzo de 2016, 10:30:05 GMT-5<br>&gt;&gt; Para: Kyle Sherman &lt;kyledsherman at gmail.com &lt;mailto:kyledsherman at gmail.com&gt;&gt;<br>&gt;&gt; Asunto: Re: [swift-evolution] [Discussion] Enforcing Calling Super<br>&gt;&gt; <br>&gt;&gt; Does this handle the case of required super only since a version?<br>&gt;&gt; <br>&gt;&gt; I recall NSView or something like that gaining an awakeFromNib implementation late, say 10.5 or so, so that one had to conditionalize calls to [super awakeFromNib] based on whether or not the superclass&#39;s instances responded to that selector. If your code was running on 10.4, calling super would crash with unrecognized selector; if on 10.5, you were always supposed to call super.<br>&gt;&gt; <br>&gt;&gt; This suggests some interaction between requiring calls to super and availability annotations at the least.<br>&gt;&gt; --<br>&gt;&gt; Jeremy W. Sherman<br>&gt;&gt; http://jeremywsherman.com/ &lt;http://jeremywsherman.com/&gt;<br>&gt;&gt; <br>&gt;&gt; El 17-02-2016, a las 13:02, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escribió:<br>&gt;&gt; <br>&gt;&gt;&gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The link to the original discussion is here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The subject was: “Replace the override keyword by ‘extend’ and ‘replace’ or add an annotation like @SuppressSuperCall”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kyle<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Enforcing Calling Super<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt;&gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt;&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt;&gt; * Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; class MyClass {<br>&gt;&gt;&gt;     @requiredSuper func foo1() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     @requiredSuper(start) func foo2() { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     @requiredSuper(end) func foo3() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to: <br>&gt;&gt;&gt; Overridden method must call the superclass’s implementation<br>&gt;&gt;&gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt;&gt;&gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt;&gt;&gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;     @requiredSuper func foo() { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler should show an error, such as “A method using @requiredSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/670635a6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
