<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b3b33f77a1215e7338bfea30585045c?s=50"></div><header><strong>Random ideas: goto, loop, multiple dispatch, explicit aliasing</strong> from <string>Daryle Walker</string> &lt;darylew at mac.com&gt;<p>July  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Rust and Ada (and probably others) have a iteration statement that specifically goes on forever, instead of using a convention of a “while”/“repeat-until”/“for&quot; with a never-exiting test.  It’s called “loop.”  Would that be a good idea to add instead of continuing to use convention?  (I don’t know if the compiler does infinite-loop optimization, or if it can detect it through a “while true” or similar convention.)  Maybe we can label a function “@noreturn” (or whatever) if it ends with a loop that doesn’t have a jump statement in it (or flag an error for such loops).<br></p><p>Although some consider it harmful, should we add a “goto” statement?  We would need to support labeling any statement, of course.  Besides needing the destination label to be in the same innermost function block as the goto, what other gotchas (skipping initialization and/or destruction) do we have to watch for?  How would it interact with “guard”?  I would also propose a “goto LABEL case EXPRESSION,” where the LABEL marks a “switch” statement that surrounds the goto statement and reevaluates the switch with the new value.  This would help with case jumping too complex for “fallthrough” to work (including jumping FROM a “default” case).<br></p><p>[I was going the ponder on generalizing the “zip2” stuff to more-than-two sources, but that requires variadic generics and other people have already got ideas for this.]<br></p><p>Should we have double (or multiple or predicate) dispatch added?  Or course, both preferring methods to free functions and defining methods within types (especially classes and protocols) bias for single dispatch.  We would have to switch back to preferring free functions or have some sort of “[object1, object2].myMethod” form of dispatch.  And it would go beyond what Objective-C does (I think).<br></p><p>[OK, I saw “predicate dispatch” on Wikipedia while looking up multiple dispatch, and I don’t quite understand it (yet).]<br></p><p>When I read an article at &lt;http://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html&gt;, I was surprised at Swift doesn’t make objects addressable by default.  The C family assumes being able to do this, and therefore forfeits any optimizations from non-addressable objects.  But I remembered that Ada also does this; you have to explicitly mark objects as addressable (with the “aliased” keyword).  Should we allow users to mark objects, including blocks of objects, as always-addressable?  Or keep addressability as automatic, via certain functions?<br></p><p>— <br>Daryle Walker<br>Mac, Internet, and Video Game Junkie<br>darylew AT mac DOT com <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/bba48660/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Random ideas: goto, loop, multiple dispatch, explicit aliasing</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July  3, 2016 at 03:00:00am</p></header><div class="content"><p>Swift already has a very useful goto operator that avoids the usual problems associated with arbitrary control flow. With labels and continue/break you can implement very complex control flow schemas, but still maintain structured code. I have used it at multiple occasions and this is something I absolutely adore about Swift. <br></p><p>— Taras<br></p><p>&gt; On 03 Jul 2016, at 03:27, Daryle Walker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Rust and Ada (and probably others) have a iteration statement that specifically goes on forever, instead of using a convention of a “while”/“repeat-until”/“for&quot; with a never-exiting test.  It’s called “loop.”  Would that be a good idea to add instead of continuing to use convention?  (I don’t know if the compiler does infinite-loop optimization, or if it can detect it through a “while true” or similar convention.)  Maybe we can label a function “@noreturn” (or whatever) if it ends with a loop that doesn’t have a jump statement in it (or flag an error for such loops).<br>&gt; <br>&gt; Although some consider it harmful, should we add a “goto” statement?  We would need to support labeling any statement, of course.  Besides needing the destination label to be in the same innermost function block as the goto, what other gotchas (skipping initialization and/or destruction) do we have to watch for?  How would it interact with “guard”?  I would also propose a “goto LABEL case EXPRESSION,” where the LABEL marks a “switch” statement that surrounds the goto statement and reevaluates the switch with the new value.  This would help with case jumping too complex for “fallthrough” to work (including jumping FROM a “default” case).<br>&gt; <br>&gt; [I was going the ponder on generalizing the “zip2” stuff to more-than-two sources, but that requires variadic generics and other people have already got ideas for this.]<br>&gt; <br>&gt; Should we have double (or multiple or predicate) dispatch added?  Or course, both preferring methods to free functions and defining methods within types (especially classes and protocols) bias for single dispatch.  We would have to switch back to preferring free functions or have some sort of “[object1, object2].myMethod” form of dispatch.  And it would go beyond what Objective-C does (I think).<br>&gt; <br>&gt; [OK, I saw “predicate dispatch” on Wikipedia while looking up multiple dispatch, and I don’t quite understand it (yet).]<br>&gt; <br>&gt; When I read an article at &lt;http://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html &lt;http://www.cocoawithlove.com/blog/2016/02/16/use_it_or_lose_it_why_safe_c_is_sometimes_unsafe_swift.html&gt;&gt;, I was surprised at Swift doesn’t make objects addressable by default.  The C family assumes being able to do this, and therefore forfeits any optimizations from non-addressable objects.  But I remembered that Ada also does this; you have to explicitly mark objects as addressable (with the “aliased” keyword).  Should we allow users to mark objects, including blocks of objects, as always-addressable?  Or keep addressability as automatic, via certain functions?<br>&gt; <br>&gt; — <br>&gt; Daryle Walker<br>&gt; Mac, Internet, and Video Game Junkie<br>&gt; darylew AT mac DOT com <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160703/ecc02af2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Random ideas: goto, loop, multiple dispatch, explicit aliasing</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  2, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 2, 2016, at 6:27 PM, Daryle Walker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would also propose a “goto LABEL case EXPRESSION,” where the LABEL marks a “switch” statement that surrounds the goto statement and reevaluates the switch with the new value.  This would help with case jumping too complex for “fallthrough” to work (including jumping FROM a “default” case).<br></p><p>Something like this was discussed at one point; I believe people referred to it as `reswitch`.<br></p><p>In general, you&#39;re not going to get very far by naming a bunch of features and asking if we should have them. Show us motivating examples. Help us understand what you want them for. (And if you don&#39;t know why you&#39;d want them, well, why are you proposing them?)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
