<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Upon accepting SE-0098, the core team renamed the proposed stdlib function from dynamicType() to type(of:).  They write, &quot;The core team recognizes that this means that we should probably resyntax the existing sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br></p><p>Follow on discussion started. Have at it.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 11:28 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Upon accepting SE-0098, the core team renamed the proposed stdlib function<br>&gt; from dynamicType() to type(of:).  They write, &quot;The core team recognizes<br>&gt; that this means that we should probably resyntax the existing<br>&gt; sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br>&gt;<br>&gt; Follow on discussion started. Have at it.<br>&gt;<br></p><p>See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/af1fbaf5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 10:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 1, 2016 at 11:28 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Upon accepting SE-0098, the core team renamed the proposed stdlib function from dynamicType() to type(of:).  They write, &quot;The core team recognizes that this means that we should probably resyntax the existing sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br>&gt; <br>&gt; Follow on discussion started. Have at it.<br>&gt; <br>&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830&gt;<br>&gt;  <br></p><p><br>And added alignof/alignofValue plus the original discussion thread<br></p><p>https://github.com/apple/swift-evolution/pull/350/files<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/2297b78e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>June  1, 2016 at 10:00:00pm</p></header><div class="content"><p>If it&#39;s worth continuing the discussion in this thread, I rather like the<br>MemoryLayout&lt;T&gt;.size idea. For discoverability, we might want to have<br>@availability(*, unavailable, message: &quot;use MemoryLayout&lt;T&gt;.size, etc.&quot;)<br>public init(){}.<br></p><p>Jacob<br></p><p>On Wed, Jun 1, 2016 at 9:55 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Jun 1, 2016 at 11:28 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Upon accepting SE-0098, the core team renamed the proposed stdlib<br>&gt;&gt; function from dynamicType() to type(of:).  They write, &quot;The core team<br>&gt;&gt; recognizes that this means that we should probably resyntax the existing<br>&gt;&gt; sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br>&gt;&gt;<br>&gt;&gt; Follow on discussion started. Have at it.<br>&gt;&gt;<br>&gt;<br>&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/d713d15e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 12:03 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; If it&#39;s worth continuing the discussion in this thread, I rather like the<br>&gt; MemoryLayout&lt;T&gt;.size idea. For discoverability, we might want to have<br>&gt; @availability(*, unavailable, message: &quot;use MemoryLayout&lt;T&gt;.size, etc.&quot;)<br>&gt; public init(){}.<br>&gt;<br></p><p>It&#39;s a nice syntax, but I&#39;m not fully comfortable with the suggestion that<br>sizeofValue(), etc. should go.  Also, I wonder about the static vs. dynamic<br>type issue here (despite having started the last thread, I still haven&#39;t<br>sat down to think it through).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c3e47780/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 11:10 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 12:03 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; If it&#39;s worth continuing the discussion in this thread, I rather like the MemoryLayout&lt;T&gt;.size idea. For discoverability, we might want to have @availability(*, unavailable, message: &quot;use MemoryLayout&lt;T&gt;.size, etc.&quot;) public init(){}.<br>&gt; <br>&gt; It&#39;s a nice syntax, but I&#39;m not fully comfortable with the suggestion that sizeofValue(), etc. should go.  Also, I wonder about the static vs. dynamic type issue here (despite having started the last thread, I still haven&#39;t sat down to think it through).<br>&gt; <br></p><p>Updated with all the feedback so far. Will keep an eye on this.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/fab4eeb3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>On Wed, Jun 1, 2016 at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jun 1, 2016 at 11:28 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Upon accepting SE-0098, the core team renamed the proposed stdlib<br>&gt;&gt; function from dynamicType() to type(of:).  They write, &quot;The core team<br>&gt;&gt; recognizes that this means that we should probably resyntax the existing<br>&gt;&gt; sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br>&gt;&gt;<br>&gt;&gt; Follow on discussion started. Have at it.<br>&gt;&gt;<br>&gt;<br>&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830<br>&gt;<br>&gt;<br></p><p>To summarize the previous discussion:<br></p><p>1. Per Joe Groff, although sizeof() and friends are treated as<br>terms-of-art, these names were lifted straight from C and do not correspond<br>to anything named &quot;sizeof&quot; in LLVM.<br></p><p>2. There are issues with using a name such as stride(of:), because<br>stride(...) already means something else in the stdlib; moreover, size(of:)<br>isn&#39;t the best name for something that doesn&#39;t do what its C namesake does;<br>therefore, larger changes to the naming were suggested.<br></p><p>2. Dave A. and others expressed the opinion that these should probably not<br>be global functions; his preference was for:<br></p><p>```<br>MemoryLayout&lt;T&gt;.size // currently sizeof()<br>MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>```<br></p><p>3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue()<br>are better off removed altogether. I don&#39;t know if people are going to be<br>happy about this idea.<br></p><p>* * *<br></p><p>If we take inspiration from type(of:), then it&#39;s actually sizeofValue(),<br>etc., that should be renamed size(of:), etc. Also, a fun tidbit is that<br>what&#39;s currently called sizeof(), etc.--the ones that take types rather<br>than values--are actually not very good candidates for having parameter<br>labels, because it&#39;s OK to write `sizeof(Int)`, but one must currently<br>write `size(of: Int.self)` when the function has a label.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/56995bd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br></p><p>Plus MemoryLayout can be extended with new convenience methods.<br></p><p>I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br></p><p>Patrick<br></p><p>&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt; <br>&gt; ```<br>&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt; ```<br>&gt; <br>&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/65af61c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  1, 2016 at 11:00:00pm</p></header><div class="content"><p>Using MemoryLayout is a much bigger change than the simple name changes being pitched here. I&#39;m not ruling it out, but it may be deferred or additive as the 3.0 timeline allows and the core team decides.<br></p><p>For now, my suggested design (strongly based on Wux&#39;s feedback and the previous thread discussion) is:<br></p><p>/// Returns the contiguous memory footprint of `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `size(of: X.self)`, when `X` is a class type, is the<br>/// same regardless of how many stored properties `X` has.<br>public func size&lt;T&gt;(of: T.Type) -&gt; Int<br></p><p>/// Returns the contiguous memory footprint of  `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `size(of: a)`, when `a` is a class instance, is the<br>/// same regardless of how many stored properties `a` has.<br>public func size&lt;T&gt;(ofValue: T) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func spacing&lt;T&gt;(of: T.Type) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func spacing&lt;T&gt;(ofValue: T) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func align&lt;T&gt;(of: T.Type) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func align&lt;T&gt;(ofValue: T) -&gt; Int<br></p><p><br>&gt; On Jun 1, 2016, at 11:24 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt; <br>&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt; <br>&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/3188fa08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(of: X.self)`, when `X` is a class type, is the<br>&gt; /// same regardless of how many stored properties `X` has.<br>&gt; public func size&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt; /// same regardless of how many stored properties `a` has.<br>&gt; public func size&lt;T&gt;(ofValue: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(ofValue: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func align&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func align&lt;T&gt;(ofValue: T) -&gt; Int<br></p><p>If `type(of:)` takes an instance, then I think `size(of:)`, `spacing(of:)` and `align(of:)` need to do the same, with `size(ofType:)`, `spacing(ofType:)`, and `align(ofType:)` handling the type side of things.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 2, 2016, at 6:26 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(of: X.self)`, when `X` is a class type, is the<br>&gt;&gt; /// same regardless of how many stored properties `X` has.<br>&gt;&gt; public func size&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt;&gt; /// same regardless of how many stored properties `a` has.<br>&gt;&gt; public func size&lt;T&gt;(ofValue: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(ofValue: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func align&lt;T&gt;(of: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func align&lt;T&gt;(ofValue: T) -&gt; Int<br>&gt; <br>&gt; If `type(of:)` takes an instance, then I think `size(of:)`, `spacing(of:)` and `align(of:)` need to do the same, with `size(ofType:)`, `spacing(ofType:)`, and `align(ofType:)` handling the type side of things.<br></p><p>+1 if we stick with the function direction.  But I&#39;m not convinced this is the best direction.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>Supporting Dave A, type-based calls are much more likely to be used than instance calls, unlike with dynamicType/type(of:)<br></p><p>Term	stdlib search	gist search	Google site:github +swift<br>sizeof	157	169	4880<br>sizeofValue	4	34	584<br>alignof	44	11	334<br>alignofValue	5	5	154<br>strideof	347	19	347<br>strideofValue	4	5	163<br>Type-based calls like sizeof() are poor candidates for parameter labels. While it&#39;s acceptable to write sizeof(Int), but one must write size(of: Int.self) (with the trailing self) when the function has a label. For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br></p><p>print(sizeof(Int)) // works<br>print(sizeof(Int.self)) // works<br></p><p>func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br></p><p><br>// Works<br>print(withoutLabel(Int))<br></p><p>// Works<br>print(withLabel(label: Int.self))<br></p><p>// Does not work<br>// error: cannot create a single-element tuple with an element label<br>// print(withLabel(label: Int)) <br></p><p><br>So with this in mind:<br></p><p>/// Returns the contiguous memory footprint of `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `size(X.self)`, when `X` is a class type, is the<br>/// same regardless of how many stored properties `X` has.<br>public func size&lt;T&gt;(_: T.Type) -&gt; Int<br></p><p>/// Returns the contiguous memory footprint of  `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `size(of: a)`, when `a` is a class instance, is the<br>/// same regardless of how many stored properties `a` has.<br>public func size&lt;T&gt;(of: T) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func spacing&lt;T&gt;(of: T) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func alignment&lt;T&gt;(of: T) -&gt; Int<br>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/96af5e86/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>And following up to myself.<br></p><p>Please look here: https://github.com/erica/swift-evolution/blob/0f93c3c31b1d59358a61a5e2608dc71a598d9316/proposals/XXXX-sidestride.md<br></p><p>Plus, I fixed the typos in strideof/strideofValue&#39;s counts.<br></p><p>-- E<br></p><p>&gt; On Jun 2, 2016, at 8:43 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Supporting Dave A, type-based calls are much more likely to be used than instance calls, unlike with dynamicType/type(of:)<br>&gt; <br>&gt; Term	stdlib search	gist search	Google site:github +swift<br>&gt; sizeof	157	169	4880<br>&gt; sizeofValue	4	34	584<br>&gt; alignof	44	11	334<br>&gt; alignofValue	5	5	154<br>&gt; strideof	347	19	347<br>&gt; strideofValue	4	5	163<br>&gt; Type-based calls like sizeof() are poor candidates for parameter labels. While it&#39;s acceptable to write sizeof(Int), but one must write size(of: Int.self) (with the trailing self) when the function has a label. For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br>&gt; <br>&gt; print(sizeof(Int)) // works<br>&gt; print(sizeof(Int.self)) // works<br>&gt; <br>&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>&gt; func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt; <br>&gt; <br>&gt; // Works<br>&gt; print(withoutLabel(Int))<br>&gt; <br>&gt; // Works<br>&gt; print(withLabel(label: Int.self))<br>&gt; <br>&gt; // Does not work<br>&gt; // error: cannot create a single-element tuple with an element label<br>&gt; // print(withLabel(label: Int)) <br>&gt; <br>&gt; <br>&gt; So with this in mind:<br>&gt; <br>&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt; /// same regardless of how many stored properties `X` has.<br>&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt; /// same regardless of how many stored properties `a` has.<br>&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt; -- E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/21b2c828/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 9:43 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Supporting Dave A, type-based calls are much more likely to be used than instance calls, unlike with dynamicType/type(of:)<br>&gt; <br>&gt; Term	stdlib search	gist search	Google site:github +swift<br>&gt; sizeof	157	169	4880<br>&gt; sizeofValue	4	34	584<br>&gt; alignof	44	11	334<br>&gt; alignofValue	5	5	154<br>&gt; strideof	347	19	347<br>&gt; strideofValue	4	5	163<br>&gt; Type-based calls like sizeof() are poor candidates for parameter labels. While it&#39;s acceptable to write sizeof(Int), but one must write size(of: Int.self) (with the trailing self) when the function has a label.<br></p><p>Isn’t this a short-term concern?  I thought that requirement was going away.<br></p><p>&gt; For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br>&gt; <br>&gt; print(sizeof(Int)) // works<br>&gt; print(sizeof(Int.self)) // works<br>&gt; <br>&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>&gt; func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt; <br>&gt; <br>&gt; // Works<br>&gt; print(withoutLabel(Int))<br>&gt; <br>&gt; // Works<br>&gt; print(withLabel(label: Int.self))<br>&gt; <br>&gt; // Does not work<br>&gt; // error: cannot create a single-element tuple with an element label<br>&gt; // print(withLabel(label: Int)) <br>&gt; <br>&gt; <br>&gt; So with this in mind:<br>&gt; <br>&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt; /// same regardless of how many stored properties `X` has.<br>&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt; /// same regardless of how many stored properties `a` has.<br>&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt; <br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt; -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/79ee93c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Isn’t this a short-term concern?  I thought that requirement was going away.<br></p><p>AFAIK there are still concerns about ambiguity - [Int] - is it an array with one element (Int.self), or is it [Int].self?<br></p><p>&gt; <br>&gt;&gt; For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br>&gt;&gt; <br>&gt;&gt; print(sizeof(Int)) // works<br>&gt;&gt; print(sizeof(Int.self)) // works<br>&gt;&gt; <br>&gt;&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt; func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Works<br>&gt;&gt; print(withoutLabel(Int))<br>&gt;&gt; <br>&gt;&gt; // Works<br>&gt;&gt; print(withLabel(label: Int.self))<br>&gt;&gt; <br>&gt;&gt; // Does not work<br>&gt;&gt; // error: cannot create a single-element tuple with an element label<br>&gt;&gt; // print(withLabel(label: Int)) <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So with this in mind:<br>&gt;&gt; <br>&gt;&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt;&gt; /// same regardless of how many stored properties `X` has.<br>&gt;&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt;&gt; /// same regardless of how many stored properties `a` has.<br>&gt;&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/1e9fbfa8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:01 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; Isn’t this a short-term concern?  I thought that requirement was going away.<br>&gt; <br>&gt; AFAIK there are still concerns about ambiguity - [Int] - is it an array with one element (Int.self), or is it [Int].self?<br></p><p>IIRC Joe Groff was going to work on sorting out the remaining issues but the plan is to move ahead eventually.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(sizeof(Int)) // works<br>&gt;&gt;&gt; print(sizeof(Int.self)) // works<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt;&gt; func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Works<br>&gt;&gt;&gt; print(withoutLabel(Int))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Works<br>&gt;&gt;&gt; print(withLabel(label: Int.self))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Does not work<br>&gt;&gt;&gt; // error: cannot create a single-element tuple with an element label<br>&gt;&gt;&gt; // print(withLabel(label: Int)) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So with this in mind:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt;&gt;&gt; /// same regardless of how many stored properties `X` has.<br>&gt;&gt;&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt;&gt;&gt; /// same regardless of how many stored properties `a` has.<br>&gt;&gt;&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt;&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt;&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt;&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt;&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/36964695/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>That proposal was returned for revision; as far as user ergonomics in Swift<br>3, .self is going to be a consideration. Best to find a solution that reads<br>nicely regardless of the situation with .self removal.<br></p><p>On Thu, Jun 2, 2016 at 9:57 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Jun 2, 2016, at 9:43 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; Supporting Dave A, type-based calls are much more likely to be used than<br>&gt; instance calls, unlike with dynamicType/type(of:)<br>&gt;<br>&gt; Termstdlib searchgist searchGoogle site:github +swift<br>&gt; sizeof 157 169 4880<br>&gt; sizeofValue 4 34 584<br>&gt; alignof 44 11 334<br>&gt; alignofValue 5 5 154<br>&gt; strideof 347 19 347<br>&gt; strideofValue 4 5 163<br>&gt; Type-based calls like sizeof() are poor candidates for parameter labels.<br>&gt; While it&#39;s acceptable to write sizeof(Int), but one must write size(of:<br>&gt; Int.self) (with the trailing self) when the function has a label.<br>&gt;<br>&gt;<br>&gt; Isn’t this a short-term concern?  I thought that requirement was going<br>&gt; away.<br>&gt;<br>&gt; For this reason, this proposal prefers using no-label calls for types<br>&gt; (otherwise they would have been ofType) and labeled calls for values:<br>&gt;<br>&gt; print(sizeof(Int)) // worksprint(sizeof(Int.self)) // works<br>&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;<br>&gt; // Worksprint(withoutLabel(Int))<br>&gt; // Worksprint(withLabel(label: Int.self))<br>&gt; // Does not work// error: cannot create a single-element tuple with an element label// print(withLabel(label: Int))<br>&gt;<br>&gt;<br>&gt;<br>&gt; So with this in mind:<br>&gt;<br>&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt; /// same regardless of how many stored properties `X` has.<br>&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;<br>&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt; ///<br>&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt; /// same regardless of how many stored properties `a` has.<br>&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt;<br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;<br>&gt; /// Returns the least possible interval between distinct instances of<br>&gt; /// `T` in memory.  The result is always positive.<br>&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt;<br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;<br>&gt; /// Returns the minimum memory alignment of `T`.<br>&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/bf675135/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:03 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; That proposal was returned for revision; as far as user ergonomics in Swift 3, .self is going to be a consideration. Best to find a solution that reads nicely regardless of the situation with .self removal.<br></p><p>From the core team decision:<br></p><p>&quot;The core team would definitely like to circle back to this proposal after Swift 3 is out the door.&quot;<br></p><p>I think we should consider the best long-term design.  If that happens to be dropping labels great, but if not, maybe we don’t want to do that just because it will look better in Swift 3 at the cost of a better design when “.self” is not required.<br></p><p>Dave’s MemoryLayout approach avoids the question of labels entirely.  This is another subtle nudge in that direction IMO.<br></p><p>&gt; <br>&gt; On Thu, Jun 2, 2016 at 9:57 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 9:43 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Supporting Dave A, type-based calls are much more likely to be used than instance calls, unlike with dynamicType/type(of:)<br>&gt;&gt; <br>&gt;&gt; Term	stdlib search	gist search	Google site:github +swift<br>&gt;&gt; sizeof	157	169	4880<br>&gt;&gt; sizeofValue	4	34	584<br>&gt;&gt; alignof	44	11	334<br>&gt;&gt; alignofValue	5	5	154<br>&gt;&gt; strideof	347	19	347<br>&gt;&gt; strideofValue	4	5	163<br>&gt;&gt; Type-based calls like sizeof() are poor candidates for parameter labels. While it&#39;s acceptable to write sizeof(Int), but one must write size(of: Int.self) (with the trailing self) when the function has a label.<br>&gt; <br>&gt; Isn’t this a short-term concern?  I thought that requirement was going away.<br>&gt; <br>&gt;&gt; For this reason, this proposal prefers using no-label calls for types (otherwise they would have been ofType) and labeled calls for values:<br>&gt;&gt; <br>&gt;&gt; print(sizeof(Int)) // works<br>&gt;&gt; print(sizeof(Int.self)) // works<br>&gt;&gt; <br>&gt;&gt; func withoutLabel&lt;T&gt;(thetype: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt; func withLabel&lt;T&gt;(label label: T.Type) -&gt; Int { return sizeof(T) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Works<br>&gt;&gt; print(withoutLabel(Int))<br>&gt;&gt; <br>&gt;&gt; // Works<br>&gt;&gt; print(withLabel(label: Int.self))<br>&gt;&gt; <br>&gt;&gt; // Does not work<br>&gt;&gt; // error: cannot create a single-element tuple with an element label<br>&gt;&gt; // print(withLabel(label: Int)) <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So with this in mind:<br>&gt;&gt; <br>&gt;&gt; /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(X.self)`, when `X` is a class type, is the<br>&gt;&gt; /// same regardless of how many stored properties `X` has.<br>&gt;&gt; public func size&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the contiguous memory footprint of  `T`.<br>&gt;&gt; ///<br>&gt;&gt; /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt; /// In particular, `size(of: a)`, when `a` is a class instance, is the<br>&gt;&gt; /// same regardless of how many stored properties `a` has.<br>&gt;&gt; public func size&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the least possible interval between distinct instances of<br>&gt;&gt; /// `T` in memory.  The result is always positive.<br>&gt;&gt; public func spacing&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func alignment&lt;T&gt;(_: T.Type) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; /// Returns the minimum memory alignment of `T`.<br>&gt;&gt; public func alignment&lt;T&gt;(of: T) -&gt; Int<br>&gt;&gt; -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/72c38296/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br></p><p>&gt; I really like this idea. This IMO is lower level functionality than<br>&gt; `type(of:)` (née dynamicType), so I think it makes sense for it to be<br>&gt; grouped under its own domain, the MemoryLayout type.<br>&gt;<br>&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;<br>&gt; I’m fine with those old methods being removed, but I never use them so! Is<br>&gt; it the same as calling type(of:) then using that with MemoryLayout? I<br>&gt; imagine they could be fixit’d easily, and that they compile down to the<br>&gt; same underlying code.<br>&gt;<br></p><p>I&#39;m actually souring to the idea. It goes in the diametrically opposite<br>direction from dynamicType. There, something was changed from being<br>property-like to being function-like. Here, Dave&#39;s proposal would take<br>something that&#39;s a function and turn it into a property. Hmm.<br></p><p>&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; 2. Dave A. and others expressed the opinion that these should probably not<br>&gt; be global functions; his preference was for:<br>&gt;<br>&gt; ```<br>&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt; ```<br>&gt;<br>&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and<br>&gt; alignofValue() are better off removed altogether. I don&#39;t know if people<br>&gt; are going to be happy about this idea.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/48d9bd59/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes but, if they weren’t functions now, what would be the best design?<br></p><p>How many Swift developers will be using this functionality? Less than 1%? I trust Dave’s judgement because he is in that small group.<br></p><p>&gt; On 2 Jun 2016, at 3:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt; <br>&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt; <br>&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt; <br>&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/8dc3ab52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 01:00:00am</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 12:37 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br></p><p>&gt; Yes but, if they weren’t functions now, what would be the best design?<br>&gt;<br></p><p>Dave&#39;s suggestions then were made in the context of a language that had<br>`.dynamicType`. The question today is how best to align these functions<br>with `type(of:)`. If we were to ignore this context, I&#39;m not sure on what<br>basis we could judge whether a property or function is &#39;best&#39; for these<br>facilities.<br></p><p><br>&gt; How many Swift developers will be using this functionality? Less than 1%?<br>&gt; I trust Dave’s judgement because he is in that small group.<br>&gt;<br></p><p>I would caution against this assumption. I&#39;m not a particularly advanced<br>developer by any stretch of the imagination, and I&#39;ve been using<br>`strideof()` plenty of times while doing some math with<br>Accelerate.framework and Metal buffers. That said, Dave&#39;s in a very small<br>group indeed, the group that wrote these functions to start with.<br></p><p>&gt; On 2 Jun 2016, at 3:27 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I really like this idea. This IMO is lower level functionality than<br>&gt;&gt; `type(of:)` (née dynamicType), so I think it makes sense for it to be<br>&gt;&gt; grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;<br>&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;<br>&gt;&gt; I’m fine with those old methods being removed, but I never use them so!<br>&gt;&gt; Is it the same as calling type(of:) then using that with MemoryLayout? I<br>&gt;&gt; imagine they could be fixit’d easily, and that they compile down to the<br>&gt;&gt; same underlying code.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite<br>&gt; direction from dynamicType. There, something was changed from being<br>&gt; property-like to being function-like. Here, Dave&#39;s proposal would take<br>&gt; something that&#39;s a function and turn it into a property. Hmm.<br>&gt;<br>&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably<br>&gt;&gt; not be global functions; his preference was for:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and<br>&gt;&gt; alignofValue() are better off removed altogether. I don&#39;t know if people<br>&gt;&gt; are going to be happy about this idea.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/89a0a7f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Yeah I realise who Dave is :)<br></p><p>Ok, that’s good to know about your uses. An extra benefit that MemoryLayout has is a developer who is familiar with sizeof() from other languages (I only know of C), if it was called the same thing in Swift they might just go ahead and use it and add their own alignment tricks. Whereas a MemoryLayout type ties of all this functionality together in the one place, where they can discover that `stride`/`spacing` might serve them better.<br></p><p>Patrick<br></p><p>&gt; On 2 Jun 2016, at 4:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 12:37 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; Yes but, if they weren’t functions now, what would be the best design?<br>&gt; <br>&gt; Dave&#39;s suggestions then were made in the context of a language that had `.dynamicType`. The question today is how best to align these functions with `type(of:)`. If we were to ignore this context, I&#39;m not sure on what basis we could judge whether a property or function is &#39;best&#39; for these facilities.<br>&gt;  <br>&gt; How many Swift developers will be using this functionality? Less than 1%? I trust Dave’s judgement because he is in that small group.<br>&gt; <br>&gt; I would caution against this assumption. I&#39;m not a particularly advanced developer by any stretch of the imagination, and I&#39;ve been using `strideof()` plenty of times while doing some math with Accelerate.framework and Metal buffers. That said, Dave&#39;s in a very small group indeed, the group that wrote these functions to start with.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/64d0f9ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt; <br>&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt; <br>&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt; <br>&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br></p><p>That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br></p><p>Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br></p><p>If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br></p><p>&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/cc143bd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Well, as I understand it, it&#39;s not actually possible to write your own<br>type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at<br>least for now.<br></p><p>I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss<br>of the `ofValue` family of functions. These functions don&#39;t fit with the<br>design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`?<br>But the response seems to be that these functions don&#39;t seem necessary at<br>all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient<br>justification for a feature removal. Looking to other languages, C# has<br>sizeof as a static property but tellingly offers the equivalent of<br>sizeofValue (well, strideofValue) as a function in a different module.<br>Essentially every other C-family language that exposes pointers to the user<br>offers both of and ofValue equivalents. The question is, how does a user<br>with existing code using sizeofValue() migrate to Swift 3? I do not see a<br>viable answer with the MemoryLayout design.<br></p><p>On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I really like this idea. This IMO is lower level functionality than<br>&gt;&gt; `type(of:)` (née dynamicType), so I think it makes sense for it to be<br>&gt;&gt; grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;<br>&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;<br>&gt;&gt; I’m fine with those old methods being removed, but I never use them so!<br>&gt;&gt; Is it the same as calling type(of:) then using that with MemoryLayout? I<br>&gt;&gt; imagine they could be fixit’d easily, and that they compile down to the<br>&gt;&gt; same underlying code.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite<br>&gt; direction from dynamicType. There, something was changed from being<br>&gt; property-like to being function-like. Here, Dave&#39;s proposal would take<br>&gt; something that&#39;s a function and turn it into a property. Hmm.<br>&gt;<br>&gt;<br>&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a<br>&gt; &quot;magic&quot; property visible on all types, which isn&#39;t something you can write<br>&gt; and turned it into a function (which is obviously something you can write).<br>&gt;<br>&gt;<br>&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items<br>&gt; which makes their semantic relationship more clear.  It also receives the<br>&gt; type via a generic argument rather than a function argument and makes the<br>&gt; properties static.  That is more representative of what is actually<br>&gt; happening and could help to prevent confusion.<br>&gt;<br>&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the<br>&gt; properties on MemoryLayout could also be made available as instance<br>&gt; properties and it could have an initializer that accepts an instance to T<br>&gt; and throws the value away.  However, I&#39;m not at all convinced this is<br>&gt; necessary.<br>&gt;<br>&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably<br>&gt;&gt; not be global functions; his preference was for:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and<br>&gt;&gt; alignofValue() are better off removed altogether. I don&#39;t know if people<br>&gt;&gt; are going to be happy about this idea.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/a51ed76a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br></p><p>No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br></p><p>&gt; <br>&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br></p><p>Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br></p><p>struct MemoryLayout&lt;T&gt; {<br>    init() {}<br>    init(t: T) { /* throw away the value */ }<br>    <br>    // we could omit the static properties and require <br>    // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>    static let size: Int<br>    static let spacing: Int<br>    static let alignment: Int<br></p><p>    let size: Int<br>    let spacing: Int<br>    let alignment: Int<br>}<br></p><p>let size = MemoryLayout&lt;Int&gt;.size<br>let sizeOfValue = MemoryLayout(42).size<br></p><p>&gt; <br>&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt; <br>&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt; <br>&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt; <br>&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt; <br>&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt; <br>&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt; <br>&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt; <br>&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/92660ea0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Both good points. I could live with your solution.<br></p><p>On Thu, Jun 2, 2016 at 10:48 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Well, as I understand it, it&#39;s not actually possible to write your own<br>&gt; type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at<br>&gt; least for now.<br>&gt;<br>&gt;<br>&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you<br>&gt; *cannot* write a property that is available for all properties - that would<br>&gt; require the ability to write `extension Any`.  This is the distinction I am<br>&gt; making.  Of course the implementation is compiler magic no matter how we<br>&gt; express it syntactically.  But we can make it *appear* just like it might<br>&gt; if the implementation *wasn’t* compiler magic.  That makes it fit into the<br>&gt; language better IMO and was the biggest motivator for changing<br>&gt; `dynamicType`.<br>&gt;<br>&gt;<br>&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss<br>&gt; of the `ofValue` family of functions. These functions don&#39;t fit with the<br>&gt; design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`?<br>&gt; But the response seems to be that these functions don&#39;t seem necessary at<br>&gt; all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient<br>&gt; justification for a feature removal. Looking to other languages, C# has<br>&gt; sizeof as a static property but tellingly offers the equivalent of<br>&gt; sizeofValue (well, strideofValue) as a function in a different module.<br>&gt; Essentially every other C-family language that exposes pointers to the user<br>&gt; offers both of and ofValue equivalents. The question is, how does a user<br>&gt; with existing code using sizeofValue() migrate to Swift 3? I do not see a<br>&gt; viable answer with the MemoryLayout design.<br>&gt;<br>&gt;<br>&gt; Going with MemoryLayout *does not* mean we would have to give up the value<br>&gt; functions if we don’t want to:<br>&gt;<br>&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;     init() {}<br>&gt;     init(t: T) { /* throw away the value */ }<br>&gt;<br>&gt;     // we could omit the static properties and require<br>&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;     static let size: Int<br>&gt;     static let spacing: Int<br>&gt;     static let alignment: Int<br>&gt;<br>&gt;     let size: Int<br>&gt;     let spacing: Int<br>&gt;     let alignment: Int<br>&gt; }<br>&gt;<br>&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than<br>&gt;&gt;&gt; `type(of:)` (née dynamicType), so I think it makes sense for it to be<br>&gt;&gt;&gt; grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so!<br>&gt;&gt;&gt; Is it the same as calling type(of:) then using that with MemoryLayout? I<br>&gt;&gt;&gt; imagine they could be fixit’d easily, and that they compile down to the<br>&gt;&gt;&gt; same underlying code.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite<br>&gt;&gt; direction from dynamicType. There, something was changed from being<br>&gt;&gt; property-like to being function-like. Here, Dave&#39;s proposal would take<br>&gt;&gt; something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a<br>&gt;&gt; &quot;magic&quot; property visible on all types, which isn&#39;t something you can write<br>&gt;&gt; and turned it into a function (which is obviously something you can write).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items<br>&gt;&gt; which makes their semantic relationship more clear.  It also receives the<br>&gt;&gt; type via a generic argument rather than a function argument and makes the<br>&gt;&gt; properties static.  That is more representative of what is actually<br>&gt;&gt; happening and could help to prevent confusion.<br>&gt;&gt;<br>&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the<br>&gt;&gt; properties on MemoryLayout could also be made available as instance<br>&gt;&gt; properties and it could have an initializer that accepts an instance to T<br>&gt;&gt; and throws the value away.  However, I&#39;m not at all convinced this is<br>&gt;&gt; necessary.<br>&gt;&gt;<br>&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably<br>&gt;&gt;&gt; not be global functions; his preference was for:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and<br>&gt;&gt;&gt; alignofValue() are better off removed altogether. I don&#39;t know if people<br>&gt;&gt;&gt; are going to be happy about this idea.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c2f10028/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  2, 2016 at 06:00:00pm</p></header><div class="content"><p>MemoryLayout is reminiscent of how of how mirror types are wrap around underlying data they represent... so that would add to the regularity if the runtime lib. Not to mention there are precedents outside swift.<br></p><p>&gt; On Jun 2, 2016, at 5:56 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Both good points. I could live with your solution.<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 10:48 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br>&gt;&gt; <br>&gt;&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt;&gt; <br>&gt;&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;     init() {}<br>&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;     <br>&gt;&gt;     // we could omit the static properties and require <br>&gt;&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;&gt;     static let size: Int<br>&gt;&gt;     static let spacing: Int<br>&gt;&gt;     static let alignment: Int<br>&gt;&gt; <br>&gt;&gt;     let size: Int<br>&gt;&gt;     let spacing: Int<br>&gt;&gt;     let alignment: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/f5a75e45/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Matthew Johnson wrote:<br>&gt; <br>&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt; <br>&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;     init(t: T) { /* throw away the value */ }<br>&gt;     // …<br>&gt; }<br>&gt; <br>&gt; let sizeOfValue = MemoryLayout(42).size<br></p><p>You could also use @autoclosure here to avoid evaluating whatever expression there is:<br></p><p>struct MemoryLayout&lt;T&gt; {<br>    init(_: @autoclosure () -&gt; T) {}<br>    // ...<br>}<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/0aeea3d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 11:04 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt;&gt; Matthew Johnson wrote:<br>&gt;&gt; <br>&gt;&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;     // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt; <br>&gt; You could also use @autoclosure here to avoid evaluating whatever expression there is:<br>&gt; <br>&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;     init(_: @autoclosure () -&gt; T) {}<br>&gt;     // ...<br>&gt; }<br></p><p>Brilliant!  Why didn’t I think of that? :-)<br></p><p>&gt; <br>&gt; — Pyry<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/5176840b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 9:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;     init() {}<br>&gt;     init(t: T) { /* throw away the value */ }<br>&gt;     <br>&gt;     // we could omit the static properties and require <br>&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;     static let size: Int<br>&gt;     static let spacing: Int<br>&gt;     static let alignment: Int<br>&gt; <br>&gt;     let size: Int<br>&gt;     let spacing: Int<br>&gt;     let alignment: Int<br>&gt; }<br>&gt; <br>&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt; let sizeOfValue = MemoryLayout(42).size<br></p><p>And amended Alternatives with this. :)<br></p><p>- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/92b91233/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 11:04 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 9:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;     init() {}<br>&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;     <br>&gt;&gt;     // we could omit the static properties and require <br>&gt;&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;&gt;     static let size: Int<br>&gt;&gt;     static let spacing: Int<br>&gt;&gt;     static let alignment: Int<br>&gt;&gt; <br>&gt;&gt;     let size: Int<br>&gt;&gt;     let spacing: Int<br>&gt;&gt;     let alignment: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt; <br>&gt; And amended Alternatives with this. :)<br></p><p>Thanks!  Can you change the init signature with Pyry’s improvement: `init(_: @autoclosure () -&gt; T) {}`?<br></p><p>&gt; <br>&gt; - E<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/1fcbfcf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 10:12 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 11:04 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 9:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;&gt;     init() {}<br>&gt;&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt; <br>&gt;&gt; And amended Alternatives with this. :)<br>&gt; <br>&gt; Thanks!  Can you change the init signature with Pyry’s improvement: `init(_: @autoclosure () -&gt; T) {}`?<br></p><p>https://github.com/erica/swift-evolution/blob/sizestride/proposals/XXXX-sidestride.md<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/ed71fe4f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br>&gt; <br>&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt; <br>&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt; <br>&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;     init() {}<br>&gt;     init(t: T) { /* throw away the value */ }<br>&gt;     <br>&gt;     // we could omit the static properties and require <br>&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;     static let size: Int<br>&gt;     static let spacing: Int<br>&gt;     static let alignment: Int<br>&gt; <br>&gt;     let size: Int<br>&gt;     let spacing: Int<br>&gt;     let alignment: Int<br>&gt; }<br>&gt; <br>&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt; let sizeOfValue = MemoryLayout(42).size<br></p><p>There&#39;s no good reason for this type to be generic.  It should be non-generic and require the use of the instance properties.<br></p><p>It&#39;s actively harmful for this type to appear to be computed from a value.  The layout is not in any way tied to the dynamic type of the value — for example, it is not the instance layout of the most-derived class or the value layout of the dynamic type of an existential.  Furthermore, saying that it is computed from a value means that attempting to compute it from a type will succeed using the layout of the metatype, which seems like a catastrophic failure of API design.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt; <br>&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt;&gt; <br>&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt;&gt; <br>&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/f9c7da99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br>&gt;&gt; <br>&gt;&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt;&gt; <br>&gt;&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;     init() {}<br>&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;     <br>&gt;&gt;     // we could omit the static properties and require <br>&gt;&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;&gt;     static let size: Int<br>&gt;&gt;     static let spacing: Int<br>&gt;&gt;     static let alignment: Int<br>&gt;&gt; <br>&gt;&gt;     let size: Int<br>&gt;&gt;     let spacing: Int<br>&gt;&gt;     let alignment: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt; <br>&gt; There&#39;s no good reason for this type to be generic.  It should be non-generic and require the use of the instance properties.<br></p><p>Dave&#39;s initial suggestion was generic and Joe suggested static properties.  I suppose it doesn&#39;t have to be generic if we pass the type directly to the initializer, but that design would eliminate the possibility of inferring the type from a value (which some people seem to want to retain).<br></p><p>I didn&#39;t mean to advocate either way about adding a value initializer and instance properties.  I was only trying to show that it is *possible* to do that if we want to preserve the ofValue capabilities.<br></p><p>&gt; <br>&gt; It&#39;s actively harmful for this type to appear to be computed from a value.  The layout is not in any way tied to the dynamic type of the value — for example, it is not the instance layout of the most-derived class or the value layout of the dynamic type of an existential.  <br></p><p>Understood, but that same problem exists for the current ofValue operations doesn&#39;t it? We can discuss removing them (I am not opposed to that), but that is independent of whether we should use a MemoryLayout struct as opposed to free functions.<br></p><p>&gt; Furthermore, saying that it is computed from a value means that attempting to compute it from a type will succeed using the layout of the metatype, which seems like a catastrophic failure of API design.<br></p><p>I was a bit hasty with the argument label and my example calling code wouldn&#39;t have actually worked.  I should have included a clear external label.<br></p><p>This is what we would want to actually do (Erica, can you update again?):<br></p><p>init(ofValue: @autoclosure () -&gt; T) { }<br></p><p>Used like this:<br></p><p>let sizeOfValue = MemoryLayout(ofValue: 42).size<br></p><p>Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/5122f0ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 11:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;&gt;     init() {}<br>&gt;&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // we could omit the static properties and require <br>&gt;&gt;&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;&gt;&gt;     static let size: Int<br>&gt;&gt;&gt;     static let spacing: Int<br>&gt;&gt;&gt;     static let alignment: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let size: Int<br>&gt;&gt;&gt;     let spacing: Int<br>&gt;&gt;&gt;     let alignment: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt;&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt;&gt; <br>&gt;&gt; There&#39;s no good reason for this type to be generic.  It should be non-generic and require the use of the instance properties.<br>&gt; <br>&gt; Dave&#39;s initial suggestion was generic and Joe suggested static properties.  I suppose it doesn&#39;t have to be generic if we pass the type directly to the initializer, but that design would eliminate the possibility of inferring the type from a value (which some people seem to want to retain).<br>&gt; <br>&gt; I didn&#39;t mean to advocate either way about adding a value initializer and instance properties.  I was only trying to show that it is *possible* to do that if we want to preserve the ofValue capabilities.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It&#39;s actively harmful for this type to appear to be computed from a value.  The layout is not in any way tied to the dynamic type of the value — for example, it is not the instance layout of the most-derived class or the value layout of the dynamic type of an existential.  <br>&gt; <br>&gt; Understood, but that same problem exists for the current ofValue operations doesn&#39;t it? We can discuss removing them (I am not opposed to that), but that is independent of whether we should use a MemoryLayout struct as opposed to free functions.<br></p><p>I&#39;m not trying to dictate the entire design.  I&#39;m saying that, if you&#39;re going to have a layout structure, I see no reason for it to be generic, and you should absolutely not make the primary way of constructing it be implicitly value-based.<br></p><p>I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br></p><p>&gt; Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br></p><p>I agree that the label makes the problem better.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/2b4e0f4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 1:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 11:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, as I understand it, it&#39;s not actually possible to write your own type(of:), so we&#39;re going from a &quot;magic&quot; property to a &quot;magic&quot; function at least for now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, but you *can* write `func foo&lt;T&gt;(_ t: T)` which accepts any value (you *cannot* write a property that is available for all properties - that would require the ability to write `extension Any`.  This is the distinction I am making.  Of course the implementation is compiler magic no matter how we express it syntactically.  But we can make it *appear* just like it might if the implementation *wasn’t* compiler magic.  That makes it fit into the language better IMO and was the biggest motivator for changing `dynamicType`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m most alarmed that one implication of the MemoryLayout proposal is loss of the `ofValue` family of functions. These functions don&#39;t fit with the design: imagine, what is `MemoryLayout&lt;Double&gt;.size(ofValue: Float(42))`? But the response seems to be that these functions don&#39;t seem necessary at all and should be removed. &quot;I don&#39;t see a use for it&quot; is an insufficient justification for a feature removal. Looking to other languages, C# has sizeof as a static property but tellingly offers the equivalent of sizeofValue (well, strideofValue) as a function in a different module. Essentially every other C-family language that exposes pointers to the user offers both of and ofValue equivalents. The question is, how does a user with existing code using sizeofValue() migrate to Swift 3? I do not see a viable answer with the MemoryLayout design.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Going with MemoryLayout *does not* mean we would have to give up the value functions if we don’t want to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MemoryLayout&lt;T&gt; {<br>&gt;&gt;&gt;&gt;     init() {}<br>&gt;&gt;&gt;&gt;     init(t: T) { /* throw away the value */ }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // we could omit the static properties and require <br>&gt;&gt;&gt;&gt;     // writing MemoryLayout&lt;Int&gt;() if we don’t like the duplication<br>&gt;&gt;&gt;&gt;     static let size: Int<br>&gt;&gt;&gt;&gt;     static let spacing: Int<br>&gt;&gt;&gt;&gt;     static let alignment: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     let size: Int<br>&gt;&gt;&gt;&gt;     let spacing: Int<br>&gt;&gt;&gt;&gt;     let alignment: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let size = MemoryLayout&lt;Int&gt;.size<br>&gt;&gt;&gt;&gt; let sizeOfValue = MemoryLayout(42).size<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s no good reason for this type to be generic.  It should be non-generic and require the use of the instance properties.<br>&gt;&gt; <br>&gt;&gt; Dave&#39;s initial suggestion was generic and Joe suggested static properties.  I suppose it doesn&#39;t have to be generic if we pass the type directly to the initializer, but that design would eliminate the possibility of inferring the type from a value (which some people seem to want to retain).<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t mean to advocate either way about adding a value initializer and instance properties.  I was only trying to show that it is *possible* to do that if we want to preserve the ofValue capabilities.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s actively harmful for this type to appear to be computed from a value.  The layout is not in any way tied to the dynamic type of the value — for example, it is not the instance layout of the most-derived class or the value layout of the dynamic type of an existential.  <br>&gt;&gt; <br>&gt;&gt; Understood, but that same problem exists for the current ofValue operations doesn&#39;t it? We can discuss removing them (I am not opposed to that), but that is independent of whether we should use a MemoryLayout struct as opposed to free functions.<br>&gt; <br>&gt; I&#39;m not trying to dictate the entire design.  I&#39;m saying that, if you&#39;re going to have a layout structure, I see no reason for it to be generic, and you should absolutely not make the primary way of constructing it be implicitly value-based.<br></p><p>I&#39;m interested to hear what others have to say about making this type generic or not.  I don&#39;t have a strong opinion about that.  I wonder if the initial motivation for that approach was that you would not create instances, just use the static properties.<br></p><p>I didn&#39;t consider the value-based initializer primary.  The generic parameter and default initializer is what I considered primary (following the previous discussion).<br></p><p>We could have a primary initializer like this:<br></p><p>init(_ type: T.Type)<br></p><p>It would look better than a default initializer that requires the type to be passed as a generic argument.  The fact that it is not labeled would make it clear that this is the primary initializer.<br></p><p>&gt; <br>&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br></p><p>Sure.  I don&#39;t necessarily disagree.  But I think it&#39;s important to make clear that this is orthogonal to the struct vs free function discussion.  That was the main point I was trying to make.  :)<br></p><p>&gt; <br>&gt;&gt; Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br>&gt; <br>&gt; I agree that the label makes the problem better.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 8:03 AM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:27 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 2, 2016 at 12:24 AM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really like this idea. This IMO is lower level functionality than `type(of:)` (née dynamicType), so I think it makes sense for it to be grouped under its own domain, the MemoryLayout type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plus MemoryLayout can be extended with new convenience methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m fine with those old methods being removed, but I never use them so! Is it the same as calling type(of:) then using that with MemoryLayout? I imagine they could be fixit’d easily, and that they compile down to the same underlying code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m actually souring to the idea. It goes in the diametrically opposite direction from dynamicType. There, something was changed from being property-like to being function-like. Here, Dave&#39;s proposal would take something that&#39;s a function and turn it into a property. Hmm.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not a fair comparison though.  With dynamicType we removed a &quot;magic&quot; property visible on all types, which isn&#39;t something you can write and turned it into a function (which is obviously something you can write).  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Dave&#39;s MemoryLayout creates a new type to bundle together related items which makes their semantic relationship more clear.  It also receives the type via a generic argument rather than a function argument and makes the properties static.  That is more representative of what is actually happening and could help to prevent confusion.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we really need an &#39;ofValue&#39; option that infers T from a value the properties on MemoryLayout could also be made available as instance properties and it could have an initializer that accepts an instance to T and throws the value away.  However, I&#39;m not at all convinced this is necessary.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jun 2016, at 3:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/e2ceb1d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 12:47 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Jun 2, 2016, at 1:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 11:22 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; We could have a primary initializer like this:<br>&gt; <br>&gt; init(_ type: T.Type)<br>&gt; <br>&gt; It would look better than a default initializer that requires the type to be passed as a generic argument.  The fact that it is not labeled would make it clear that this is the primary initializer.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt; <br>&gt; Sure.  I don&#39;t necessarily disagree.  But I think it&#39;s important to make clear that this is orthogonal to the struct vs free function discussion.  That was the main point I was trying to make.  :)<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br>&gt;&gt; <br>&gt;&gt; I agree that the label makes the problem better.<br>&gt;&gt; <br>&gt;&gt; John.<br></p><p><br>I do want to say that while I&#39;m including this in Alternatives Considered (and will update as soon as we finish lunch), that I stand by the freestanding functions as preferable to this clever but extremely indirect approach.<br></p><p>I believe the MemoryLayout type introduces a level of indirection that is less helpful in the rare times the user will consume this functionality, that it clutters calls and adds cognitive burden for reading code.<br></p><p>Let me give you some examples:<br></p><p>let errnoSize = sizeof(errno.dynamicType)<br>return sizeof(UInt) * 8<br>sendBytes(from: &amp;address, count: sizeof(UInt.self))<br>_class_getInstancePositiveExtentSize(bufferClass) == sizeof(_HeapObject.self)<br>bytesPerIndex: sizeof(IndexType))<br></p><p>In every example, calling a size function&#39;s clarity is simpler than using the Memory Layout approach:<br></p><p>let errnoSize = MemoryLayout.init(t: errno).size<br>return MemoryLayout&lt;UInt&gt;.size * 8<br>sendBytes(from: &amp;address, count: MemoryLayout&lt;UInt&gt;.size)<br>_class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout&lt;_HeapObject.self&gt;.size<br>bytesPerIndex: MemoryLayout&lt;IndexType&gt;.size<br></p><p>The full type specification lends the calls an importance and verbosity they don&#39;t deserve compared to their simpler counterparts. The eye is drawn every time to the &quot;MemoryLayout&lt;T&gt;&quot; pattern:<br></p><p>* Prominence of the type constructor<br>* Simplicity of the function call<br>* Number of code characters used<br>* Swift&#39;s adherence to a mantra of concision and clarity.<br></p><p>It fails all these. To put it in usability terms: it&#39;s a big stinking mess compared to the readability and eye tracking of the simpler function. (I&#39;ve cc&#39;ed in Chris Lattner, who has people who can test this kind of thing on call.)<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/d41e68e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 2:58 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 12:47 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 1:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; We could have a primary initializer like this:<br>&gt;&gt; <br>&gt;&gt; init(_ type: T.Type)<br>&gt;&gt; <br>&gt;&gt; It would look better than a default initializer that requires the type to be passed as a generic argument.  The fact that it is not labeled would make it clear that this is the primary initializer.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt; <br>&gt;&gt; Sure.  I don&#39;t necessarily disagree.  But I think it&#39;s important to make clear that this is orthogonal to the struct vs free function discussion.  That was the main point I was trying to make.  :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that the label makes the problem better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt; <br>&gt; <br>&gt; I do want to say that while I&#39;m including this in Alternatives Considered (and will update as soon as we finish lunch), that I stand by the freestanding functions as preferable to this clever but extremely indirect approach.<br>&gt; <br>&gt; I believe the MemoryLayout type introduces a level of indirection that is less helpful in the rare times the user will consume this functionality, that it clutters calls and adds cognitive burden for reading code.<br>&gt; <br>&gt; Let me give you some examples:<br>&gt; <br>&gt; let errnoSize = sizeof(errno.dynamicType)<br>&gt; return sizeof(UInt) * 8<br>&gt; sendBytes(from: &amp;address, count: sizeof(UInt.self))<br>&gt; _class_getInstancePositiveExtentSize(bufferClass) == sizeof(_HeapObject.self)<br>&gt; bytesPerIndex: sizeof(IndexType))<br>&gt; <br>&gt; In every example, calling a size function&#39;s clarity is simpler than using the Memory Layout approach:<br>&gt; <br>&gt; let errnoSize = MemoryLayout.init(t: errno).size<br>&gt; return MemoryLayout&lt;UInt&gt;.size * 8<br>&gt; sendBytes(from: &amp;address, count: MemoryLayout&lt;UInt&gt;.size)<br>&gt; _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout&lt;_HeapObject.self&gt;.size<br>&gt; bytesPerIndex: MemoryLayout&lt;IndexType&gt;.size<br>&gt; <br>&gt; The full type specification lends the calls an importance and verbosity they don&#39;t deserve compared to their simpler counterparts. The eye is drawn every time to the &quot;MemoryLayout&lt;T&gt;&quot; pattern:<br>&gt; <br>&gt; * Prominence of the type constructor<br>&gt; * Simplicity of the function call<br>&gt; * Number of code characters used<br>&gt; * Swift&#39;s adherence to a mantra of concision and clarity.<br>&gt; <br>&gt; It fails all these. To put it in usability terms: it&#39;s a big stinking mess compared to the readability and eye tracking of the simpler function. (I&#39;ve cc&#39;ed in Chris Lattner, who has people who can test this kind of thing on call.)<br></p><p>I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/bb62420c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:13 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br></p><p>And mentioned.<br></p><p>https://github.com/erica/swift-evolution/blob/sizestride/proposals/XXXX-sidestride.md<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/0eb524ad/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br></p><p>You know...rather than introducing a new type like MemoryLayout, would it make sense to do this with static properties on UnsafePointer?<br></p><p>	UnsafePointer&lt;Int&gt;.pointeeSize<br>	UnsafePointer&lt;Int&gt;.pointeeAlignment<br>	UnsafePointer&lt;Int&gt;.pointeeSpacing<br></p><p>If you need this information, 90% of the time you&#39;re probably using UnsafePointer or one of its friends, right?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  2, 2016 at 04:00:00pm</p></header><div class="content"><p>This might be silly, but what if there were a struct with all of the relevant fields (not sure what the best name would be):<br></p><p>struct MemoryLayout {<br>  let size: Int<br>  let alignment: Int<br>  let stride: Int<br> // etc<br>}<br></p><p>Then you’d only maybe need two functions:<br></p><p>memoryLayout(of:) and memoryLayout(ofType:)<br></p><p>Or perhaps just a single property on all types named “memoryLayout” (or whatever) that returns the MemoryLayout struct:<br></p><p>Int.memory.size<br>type(of: 42).memoryLayout.size<br>// etc<br></p><p>Or just a single property on UnsafePointer if we went that route..<br></p><p>It seems like this sort of approach would keep namespace pollution down, at least?<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 2, 2016, at 4:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br>&gt; <br>&gt; You know...rather than introducing a new type like MemoryLayout, would it make sense to do this with static properties on UnsafePointer?<br>&gt; <br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeSize<br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeAlignment<br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeSpacing<br>&gt; <br>&gt; If you need this information, 90% of the time you&#39;re probably using UnsafePointer or one of its friends, right?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 4:57 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; This might be silly, but what if there were a struct with all of the relevant fields (not sure what the best name would be):<br>&gt; <br>&gt; struct MemoryLayout {<br>&gt;  let size: Int<br>&gt;  let alignment: Int<br>&gt;  let stride: Int<br>&gt; // etc<br>&gt; }<br>&gt; <br>&gt; Then you’d only maybe need two functions:<br>&gt; <br>&gt; memoryLayout(of:) and memoryLayout(ofType:)<br></p><p>I like this much better than individual functions.  I do not like the next idea that considers using a property.  We moved away from that approach with dynamicType and should stick with that direction.  It&#39;s not worth bringing up that debate again IMO.<br></p><p>&gt; <br>&gt; Or perhaps just a single property on all types named “memoryLayout” (or whatever) that returns the MemoryLayout struct:<br>&gt; <br>&gt; Int.memory.size<br>&gt; type(of: 42).memoryLayout.size<br>&gt; // etc<br>&gt; <br>&gt; Or just a single property on UnsafePointer if we went that route..<br>&gt; <br>&gt; It seems like this sort of approach would keep namespace pollution down, at least?<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 4:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br>&gt;&gt; <br>&gt;&gt; You know...rather than introducing a new type like MemoryLayout, would it make sense to do this with static properties on UnsafePointer?<br>&gt;&gt; <br>&gt;&gt;    UnsafePointer&lt;Int&gt;.pointeeSize<br>&gt;&gt;    UnsafePointer&lt;Int&gt;.pointeeAlignment<br>&gt;&gt;    UnsafePointer&lt;Int&gt;.pointeeSpacing<br>&gt;&gt; <br>&gt;&gt; If you need this information, 90% of the time you&#39;re probably using UnsafePointer or one of its friends, right?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  3, 2016 at 06:00:00am</p></header><div class="content"><p>On Jun 2, 2016, at 16:57, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; This might be silly, but what if there were a struct with all of the relevant fields (not sure what the best name would be):<br>&gt; <br>&gt; struct MemoryLayout {<br>&gt;  let size: Int<br>&gt;  let alignment: Int<br>&gt;  let stride: Int<br>&gt; // etc<br>&gt; }<br>&gt; <br>&gt; Then you’d only maybe need two functions:<br>&gt; <br>&gt; memoryLayout(of:) and memoryLayout(ofType:)<br>&gt; <br>&gt; Or perhaps just a single property on all types named “memoryLayout” (or whatever) that returns the MemoryLayout struct:<br>&gt; <br>&gt; Int.memory.size<br>&gt; type(of: 42).memoryLayout.size<br>&gt; // etc<br>&gt; <br>&gt; Or just a single property on UnsafePointer if we went that route..<br>&gt; <br>&gt; It seems like this sort of approach would keep namespace pollution down, at least?<br>I was about to suggest the something very much like that.<br></p><p>In addition to reducing namespace &quot;pollution&quot;, I like that it kinda moves implementation and target-level details into their own little &quot;type terrarium&quot;... I might suggest renaming &quot;MemoryLayout&quot; to something like &quot;ImplementationDetails&quot;. The latter seems more to-the-point, but, aside from endianness, I&#39;m not sure if any such details wouldn&#39;t fall under the umbrella of &quot;memory layout&quot; anyway.<br></p><p>Hmm… If all the details of a type’s memory layout can be represented in this “MemoryLayout&quot; type, could we use it to manually construct a type &quot;in-code&quot; instead of going through the compiler? I’m not sure it works &quot;that way”… Nor am I sure what the point would be, but it might be handy if you have clever idea that the compiler can’t understand.<br></p><p>I clearly shouldn’t be up this early.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/43a8b5c4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  3, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; This might be silly, but what if there were a struct with all of the relevant fields (not sure what the best name would be):<br>&gt; <br>&gt; struct MemoryLayout {<br>&gt;  let size: Int<br>&gt;  let alignment: Int<br>&gt;  let stride: Int<br>&gt; // etc<br>&gt; }<br>&gt; <br>&gt; Then you’d only maybe need two functions:<br>&gt; <br>&gt; memoryLayout(of:) and memoryLayout(ofType:)<br></p><p>Could the `memoryLayout` functions just return `(size: Int, alignment: Int, spacing: Int)` tuples? It&#39;s hard to tell because it goes into Builtin land, but I get the impression that these values are calculated at compile time anyway, and if you only used one of them the optimizer could throw the others away.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  3, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 3, 2016, at 7:08 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; This might be silly, but what if there were a struct with all of the relevant fields (not sure what the best name would be):<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout {<br>&gt;&gt; let size: Int<br>&gt;&gt; let alignment: Int<br>&gt;&gt; let stride: Int<br>&gt;&gt; // etc<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then you’d only maybe need two functions:<br>&gt;&gt; <br>&gt;&gt; memoryLayout(of:) and memoryLayout(ofType:)<br>&gt; <br>&gt; Could the `memoryLayout` functions just return `(size: Int, alignment: Int, spacing: Int)` tuples? It&#39;s hard to tell because it goes into Builtin land, but I get the impression that these values are calculated at compile time anyway, and if you only used one of them the optimizer could throw the others away.<br></p><p>What would be the advantage of this over returning a value of a MemoryLayout type?  Obviously tuples can be destructured, but I can&#39;t think of any others.  I would like to see struct destructuring someday.  I&#39;m not sure destructuring is a strong enough argument to go with a tuple here.  If there is a good reason to have a MemoryLayout type we shouldn&#39;t drop it just for destructuring, which may eventually be possible anyway (I hope anyway).<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br></p><p>Pull Request: https://github.com/apple/swift-evolution/pull/350<br></p><p>Thanks, -- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Looks good! I definitely like the ‘memory’ prefixes for the functions. I appreciate that stating the name earlier with the functions vs MemoryLayout&lt;Type&gt;.blah is easier to read.<br></p><p>It feels a little bit of a shame to make `memorySize(ofType:)` longer than `memorySize(of:)`, as I think it will be used more and is the more direct variation of the two. I can see that it matches `type(of:)`. I’d possibly advocate for `memorySize(ofType:)` and `memorySize(ofValue:)`, as it’s less ambiguous and may steer those coming from `sizeof` in the right direction.<br></p><p>Patrick<br></p><p>&gt; On 4 Jun 2016, at 7:11 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br>&gt; <br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/350<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  3, 2016 at 10:00:00pm</p></header><div class="content"><p>In defense of MemoryLayout&lt;T&gt;&#39;s &quot;less clarity&quot;, the people who know enough to use that stuff won&#39;t have trouble understanding it.<br></p><p>That said, while I like it, I&#39;m mostly interested in sequestering this stuff away in a type as a step towards a some sort of vague macro system. Since that&#39;s obviously out of scope for, well, everything, I&#39;m +1 regardless.<br></p><p>- Dave Sweeris<br></p><p><br></p><p>&gt; On Jun 3, 2016, at 16:11, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br>&gt; <br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/350<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  3, 2016 at 11:00:00pm</p></header><div class="content"><p>There was also my suggestion for a function such as memoryLayout(of:) that returned an instance of a simple MemoryLayout struct which I believe is a bit different than the MemoryLayout&lt;T&gt; generics approach. I’m not sure if that was expressly shot down or ruled out or not, though.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 3, 2016, at 4:11 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br>&gt; <br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/350<br>&gt; <br>&gt; Thanks, -- Erica<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  4, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 04 Jun 2016, Erica Sadun wrote:<br>&gt; <br>&gt; Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br>&gt; <br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/350<br></p><p>Good proposal, Erica!<br></p><p>Regardless of the little input I&#39;ve given to this discussion, I actually prefer the set of `memory*` prefixed top-level functions to a `MemoryLayout` struct or tuple.<br></p><p>However, I think it&#39;s most common to call these functions with a type argument, and we should thus stick to the practice of keeping that use case short, and the call-with-value case explicit. In particular, I&#39;d avoid the label for a type argument, and say `ofValue:` when passing a value:<br></p><p>    memorySize(ofType:)      → memorySize(_:)<br>    memorySize(of:)          → memorySize(ofValue:)<br>    memoryInterval(ofType:)  → memoryInterval(_:)<br>    memoryInterval(of:)      → memoryInterval(ofValue:)<br>    memoryAlignment(ofType:) → memoryAlignment(_:)<br>    memoryAlignment(of:)     → memoryAlignment(ofValue:)<br></p><p>Secondly, (this might be over-engineering but) would it still make sense to use `@autoclosure` in the `ofValue:` functions because they don&#39;t really need their arguments evaluated?<br></p><p>    public func memorySize&lt;T&gt;(ofValue _: @autoclosure T -&gt; ()) -&gt; Int<br>    public func memoryInterval&lt;T&gt;(ofValue _: @autoclosure T -&gt; ()) -&gt; Int<br>    public func memoryAlignment&lt;T&gt;(ofValue _: @autoclosure T -&gt; ()) -&gt; Int<br></p><p>— Pyry, whose name gets autocoerced in various ways apparently.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/0244a8ac/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 3 juin 2016 à 17:11, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Discussion has more or less drawn down. Are there any further significant requests / issues that need addressing? Both standalone functions (my recommended approach)  and the MemoryLayout&lt;T&gt; struct approach (alternative, with reasons why I think it&#39;s not as ideal) are discussed in-proposal.<br>&gt; <br>&gt; Pull Request: https://github.com/apple/swift-evolution/pull/350<br></p><p>Is there any need to consider the following common C sizeof() usage, which is currently illegal in Swift?<br></p><p>#if sizeof(MyType) != sizeof(Int)<br># error &quot;Someone added too much data to MyType&quot;<br>#endif<br></p><p>It is not that I like fancy conditional compile, but having such compile time assertion is useful; at least in my day-time low-level C world. Most of the discussion seem to have been around sizeof() being more of a runtime function than a compiler directive; which would preclude being able to do compile time assertion to validate type size.<br></p><p>Dany<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  7, 2016 at 08:00:00am</p></header><div class="content"><p>This is a good point. This should, perhaps, be address using #if arch(x86_64), but you are right that many systems have some system typedefs defined otherwise even on the same architecture, which may be painful to deal with.<br></p><p>&gt; Is there any need to consider the following common C sizeof() usage, which is currently illegal in Swift?<br>&gt; <br>&gt; #if sizeof(MyType) != sizeof(Int)<br>&gt; # error &quot;Someone added too much data to MyType&quot;<br>&gt; #endif<br>&gt; <br>&gt; It is not that I like fancy conditional compile, but having such compile time assertion is useful; at least in my day-time low-level C world. Most of the discussion seem to have been around sizeof() being more of a runtime function than a compiler directive; which would preclude being able to do compile time assertion to validate type size.<br>&gt; <br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 3:55 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I don&#39;t disagree with the points you make.  But one can argue that this is a good thing.  It calls attention to code that requires extra attention and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br>&gt; <br>&gt; You know...rather than introducing a new type like MemoryLayout, would it make sense to do this with static properties on UnsafePointer?<br>&gt; <br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeSize<br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeAlignment<br>&gt; 	UnsafePointer&lt;Int&gt;.pointeeSpacing<br>&gt; <br>&gt; If you need this information, 90% of the time you&#39;re probably using UnsafePointer or one of its friends, right?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>Some quick greppage -- E<br></p><p>public/core/BridgeObjectiveC.swift:    _sanityCheck(sizeofValue(self) &gt;=<br>public/core/Builtin.swift:public func sizeofValue&lt;T&gt;(_:T) -&gt; Int {<br>public/core/Character.swift:    let bits = sizeofValue(initialUTF8) &amp;* 8 &amp;- 1<br>public/core/Unicode.swift:  if utf8Count &lt; sizeofValue(result) {<br></p><p>private/SwiftPrivateLibcExtras/Subprocess.swift:    let errnoSize = sizeof(errno.dynamicType)<br>private/SwiftPrivateLibcExtras/SwiftPrivateLibcExtras.swift:    return sizeof(UInt) * 8<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  sendBytes(from: &amp;address, count: sizeof(UInt.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  sendBytes(from: &amp;value, count: sizeof(T.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  fread(&amp;value, sizeof(UInt.self), 1, stdin)<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  sendBytes(from: &amp;numInfos, count: sizeof(UInt.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  let pointerSize = UInt8(sizeof(UnsafePointer&lt;Void&gt;.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  let anyPointer = UnsafeMutablePointer&lt;Any&gt;(allocatingCapacity: sizeof(Any.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  anyPointer.deallocateCapacity(sizeof(Any.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:      allocatingCapacity: sizeof(ThickFunction0.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  fn.deallocateCapacity(sizeof(ThickFunction0.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:      allocatingCapacity: sizeof(ThickFunction1.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  fn.deallocateCapacity(sizeof(ThickFunction1.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:      allocatingCapacity: sizeof(ThickFunction2.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  fn.deallocateCapacity(sizeof(ThickFunction2.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:      allocatingCapacity: sizeof(ThickFunction3.self))<br>private/SwiftReflectionTest/SwiftReflectionTest.swift:  fn.deallocateCapacity(sizeof(ThickFunction3.self))<br>public/core/BridgeObjectiveC.swift:                   sizeof(Optional&lt;UnsafePointer&lt;Void&gt;&gt;.self) * count)<br>public/core/Builtin.swift:/// In particular, `sizeof(X.self)`, when `X` is a class type, is the<br>public/core/Builtin.swift:public func sizeof&lt;T&gt;(_:T.Type) -&gt; Int {<br>public/core/Builtin.swift:  return Int(Builtin.sizeof(T.self))<br>public/core/Builtin.swift:/// In particular, `sizeof(a)`, when `a` is a class instance, is the<br>public/core/Builtin.swift:  return sizeof(T.self)<br>public/core/Builtin.swift:  _precondition(sizeof(T.self) == sizeof(U.self),<br>public/core/Builtin.swift:    sizeof(_HeapObject.self),<br>public/core/Character.swift:    // Notice that the result of sizeof() is a small non-zero number and can&#39;t<br>public/core/HeapBuffer.swift:      sizeof(_HeapObject.self),<br>public/core/HeapBuffer.swift:      _valueOffset() + sizeof(Value.self),<br>public/core/ManagedBuffer.swift:      _class_getInstancePositiveExtentSize(bufferClass) == sizeof(_HeapObject.self)<br>public/core/ManagedBuffer.swift:          == _valueOffset + sizeof(Value.self)),<br>public/core/ManagedBuffer.swift:      _class_getInstancePositiveExtentSize(bufferClass) == sizeof(_HeapObject.self)<br>public/core/ManagedBuffer.swift:          == _valueOffset + sizeof(Value.self)),<br>public/core/ManagedBuffer.swift:      sizeof(_HeapObject.self),<br>public/core/ManagedBuffer.swift:      _valueOffset + sizeof(Value.self),<br>public/core/Runtime.swift.gyb:  _sanityCheck(sizeof(_Buffer32.self) == 32)<br>public/core/Runtime.swift.gyb:  _sanityCheck(sizeof(_Buffer72.self) == 72)<br>public/core/Runtime.swift.gyb:  for _ in 0..&lt;(2 * sizeof(UnsafePointer&lt;Void&gt;) - result.utf16.count) {<br>public/core/Sequence.swift:    // `n` * sizeof(Iterator.Element) of memory, because slices keep the entire<br>public/core/StringUTF8.swift:      let utf16Count = Swift.min(sizeof(_UTF8Chunk.self), count - i)<br>public/core/StringUTF8.swift:        return 0xFF &lt;&lt; numericCast((sizeof(Buffer.self) &amp;- 1) &amp;* 8)<br>public/core/Unicode.swift:  let utf8Max = sizeof(_UTF8Chunk.self)<br>public/core/VarArgs.swift:    count: (sizeof(T.self) + sizeof(Int.self) - 1) / sizeof(Int.self))<br>public/core/VarArgs.swift:          size: UInt(sizeof(T.self)))<br>public/core/VarArgs.swift:      let alignmentInWords = arg._cVarArgAlignment / sizeof(Int)<br>public/runtime/HeapObject.cpp:extern &quot;C&quot; intptr_t swift_bufferHeaderSize() { return sizeof(HeapObject); }<br>public/runtime/Once.cpp:static_assert(sizeof(swift_once_t) &lt;= sizeof(void*),<br>public/SDK/CoreAudio/CoreAudio.swift:    return sizeof(AudioBufferList) +<br>public/SDK/SceneKit/SceneKit.swift:      data: NSData(bytes: indices, length: indexCount * sizeof(IndexType)),<br>public/SDK/SceneKit/SceneKit.swift:      bytesPerIndex: sizeof(IndexType))<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/4b6c6013/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 10:00:00pm</p></header><div class="content"><p>Nope. I use it with Metal buffers, for example :)<br></p><p>Moreover, there&#39;s nothing inherently unsafe about sizeof, and I think it&#39;s<br>important, *especially when you&#39;re working with UnsafePointers*, that safe<br>things look safe. If the moment a pointer comes into the picture everything<br>related to it is prefixed with Unsafe, that word loses its meaning entirely.<br>On Thu, Jun 2, 2016 at 16:54 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I don&#39;t disagree with the points you make.  But one can argue that this<br>&gt; is a good thing.  It calls attention to code that requires extra attention<br>&gt; and care.  In some ways this is similar to &#39;UnsafeMutablePointer&lt;T&gt;&#39; vs<br>&gt; &#39;*T&#39;.  Verbosity was a deliberate choice in that case.<br>&gt;<br>&gt; You know...rather than introducing a new type like MemoryLayout, would it<br>&gt; make sense to do this with static properties on UnsafePointer?<br>&gt;<br>&gt;         UnsafePointer&lt;Int&gt;.pointeeSize<br>&gt;         UnsafePointer&lt;Int&gt;.pointeeAlignment<br>&gt;         UnsafePointer&lt;Int&gt;.pointeeSpacing<br>&gt;<br>&gt; If you need this information, 90% of the time you&#39;re probably using<br>&gt; UnsafePointer or one of its friends, right?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/a0964b4f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  2, 2016 at 05:00:00pm</p></header><div class="content"><p>While I prefer Russ&#39;s approach...I actually find the MemoryLayout API much easier to read than the current way. <br></p><p>Namely:<br>- it stands out more and makes it clearer what you are doing <br>- less parens everywhere :)<br></p><p>Brandon <br></p><p>&gt; On Jun 2, 2016, at 3:58 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 12:47 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 1:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:22 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 12:01 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 8:48 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 10:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; We could have a primary initializer like this:<br>&gt;&gt; <br>&gt;&gt; init(_ type: T.Type)<br>&gt;&gt; <br>&gt;&gt; It would look better than a default initializer that requires the type to be passed as a generic argument.  The fact that it is not labeled would make it clear that this is the primary initializer.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt; <br>&gt;&gt; Sure.  I don&#39;t necessarily disagree.  But I think it&#39;s important to make clear that this is orthogonal to the struct vs free function discussion.  That was the main point I was trying to make.  :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adding the label will eliminate the potential for confusion about type vs metatype.  Wanting to know the size of the metatype is probably extremely rare, but there is not reason to prohibit it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that the label makes the problem better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt; <br>&gt; <br>&gt; I do want to say that while I&#39;m including this in Alternatives Considered (and will update as soon as we finish lunch), that I stand by the freestanding functions as preferable to this clever but extremely indirect approach.<br>&gt; <br>&gt; I believe the MemoryLayout type introduces a level of indirection that is less helpful in the rare times the user will consume this functionality, that it clutters calls and adds cognitive burden for reading code.<br>&gt; <br>&gt; Let me give you some examples:<br>&gt; <br>&gt; let errnoSize = sizeof(errno.dynamicType)<br>&gt; return sizeof(UInt) * 8<br>&gt; sendBytes(from: &amp;address, count: sizeof(UInt.self))<br>&gt; _class_getInstancePositiveExtentSize(bufferClass) == sizeof(_HeapObject.self)<br>&gt; bytesPerIndex: sizeof(IndexType))<br>&gt; <br>&gt; In every example, calling a size function&#39;s clarity is simpler than using the Memory Layout approach:<br>&gt; <br>&gt; let errnoSize = MemoryLayout.init(t: errno).size<br>&gt; return MemoryLayout&lt;UInt&gt;.size * 8<br>&gt; sendBytes(from: &amp;address, count: MemoryLayout&lt;UInt&gt;.size)<br>&gt; _class_getInstancePositiveExtentSize(bufferClass) == MemoryLayout&lt;_HeapObject.self&gt;.size<br>&gt; bytesPerIndex: MemoryLayout&lt;IndexType&gt;.size<br>&gt; <br>&gt; The full type specification lends the calls an importance and verbosity they don&#39;t deserve compared to their simpler counterparts. The eye is drawn every time to the &quot;MemoryLayout&lt;T&gt;&quot; pattern:<br>&gt; <br>&gt; * Prominence of the type constructor<br>&gt; * Simplicity of the function call<br>&gt; * Number of code characters used<br>&gt; * Swift&#39;s adherence to a mantra of concision and clarity.<br>&gt; <br>&gt; It fails all these. To put it in usability terms: it&#39;s a big stinking mess compared to the readability and eye tracking of the simpler function. (I&#39;ve cc&#39;ed in Chris Lattner, who has people who can test this kind of thing on call.)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/52626030/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt; <br>&gt; John.<br></p><p><br>I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>Having free functions or magic operators seems to be another holdover from C. <br></p><p><br>    Int.size<br>    Int.alignment<br>    Int.spacing<br></p><p>    let x: Any = 5<br>    type(of: x).size<br></p><p><br>The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/e4a9bc76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; <br>&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt; <br>&gt; <br>&gt;     Int.size<br>&gt;     Int.alignment<br>&gt;     Int.spacing<br>&gt; <br>&gt;     let x: Any = 5<br>&gt;     type(of: x).size<br>&gt; <br>&gt; <br>&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt; <br>&gt; <br>&gt; Russ<br></p><p>If achievable, this would certainly be clean and elegant.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/5f1e8d6a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; <br>&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt; <br>&gt; <br>&gt;     Int.size<br>&gt;     Int.alignment<br>&gt;     Int.spacing<br>&gt; <br>&gt;     let x: Any = 5<br>&gt;     type(of: x).size<br>&gt; <br>&gt; <br>&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br></p><p>Two reasons.  The first is that this is a user-extensible namespace via static members, so it&#39;s somewhat unfortunate to pollute it with names from the library.  The second is that there&#39;s currently no language mechanism for adding a static member to every type, so this would have to be built-in.  But I agree that in the abstract a static property would be preferable.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/7f0df67c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 04:00:00pm</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I still think the value-based APIs are misleading and that it would be<br>&gt; better to ask people to just use a type explicitly.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree; in fact *why aren’t these properties on the type itself*? The<br>&gt; type is what matters; why can’t the type just tell me it’s size?<br>&gt; Having free functions or magic operators seems to be another holdover from<br>&gt; C.<br>&gt;<br>&gt;<br>&gt;     Int.size<br>&gt;     Int.alignment<br>&gt;     Int.spacing<br>&gt;<br>&gt;     let x: Any = 5<br>&gt;     type(of: x).size<br>&gt;<br>&gt;<br>&gt; The compiler should be able to statically know the first three values and<br>&gt; inline them. The second is discovering the size dynamically.<br>&gt;<br>&gt;<br>&gt; Two reasons.  The first is that this is a user-extensible namespace via<br>&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names from<br>&gt; the library.  The second is that there&#39;s currently no language mechanism<br>&gt; for adding a static member to every type, so this would have to be<br>&gt; built-in.  But I agree that in the abstract a static property would be<br>&gt; preferable.<br>&gt;<br></p><p>In the earlier conversation, it was pointed out (by Dave A., I think?) that<br>examples such as Array.size show how this solution can get confusing. And<br>even though there aren&#39;t fixed-length arrays in Swift, those may come one<br>day, making the syntax even more confusing.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/4b2d2998/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Given that these are fairly low-level values with very specialized uses, I<br>definitely agree that they should be somehow namespaced in a way that<br>doesn&#39;t cause us to make very common words unusable for our users.<br></p><p>Even size(of:) seems more general to me than I&#39;d like. I&#39;d like to see the<br>word &quot;memory&quot; as part of the name somehow, whether it&#39;s a wrapping type or<br>a function prefix of some sort. These values are specialized; we don&#39;t need<br>to optimize typing them, IMO.<br></p><p>On Thu, Jun 2, 2016 at 2:06 PM Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I still think the value-based APIs are misleading and that it would be<br>&gt;&gt; better to ask people to just use a type explicitly.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree; in fact *why aren’t these properties on the type itself*? The<br>&gt;&gt; type is what matters; why can’t the type just tell me it’s size?<br>&gt;&gt; Having free functions or magic operators seems to be another holdover<br>&gt;&gt; from C.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Int.size<br>&gt;&gt;     Int.alignment<br>&gt;&gt;     Int.spacing<br>&gt;&gt;<br>&gt;&gt;     let x: Any = 5<br>&gt;&gt;     type(of: x).size<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The compiler should be able to statically know the first three values and<br>&gt;&gt; inline them. The second is discovering the size dynamically.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Two reasons.  The first is that this is a user-extensible namespace via<br>&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names from<br>&gt;&gt; the library.  The second is that there&#39;s currently no language mechanism<br>&gt;&gt; for adding a static member to every type, so this would have to be<br>&gt;&gt; built-in.  But I agree that in the abstract a static property would be<br>&gt;&gt; preferable.<br>&gt;&gt;<br>&gt;<br>&gt; In the earlier conversation, it was pointed out (by Dave A., I think?)<br>&gt; that examples such as Array.size show how this solution can get confusing.<br>&gt; And even though there aren&#39;t fixed-length arrays in Swift, those may come<br>&gt; one day, making the syntax even more confusing.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/6ad17ec6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>On the other hand, on its own sizeof() is not unsafe, and so the argument<br>that it should be longer to call attention to itself (by analogy with<br>UnsafePointer) isn&#39;t quite apt.<br></p><p>And I&#39;m not sure we really want to encourage anyone else to be defining a<br>global function named size(of:) anyway, so I wouldn&#39;t consider vacating<br>that name for end-user purposes to be a meaningful positive.<br>On Thu, Jun 2, 2016 at 16:15 Tony Allevato &lt;allevato at google.com&gt; wrote:<br></p><p>&gt; Given that these are fairly low-level values with very specialized uses, I<br>&gt; definitely agree that they should be somehow namespaced in a way that<br>&gt; doesn&#39;t cause us to make very common words unusable for our users.<br>&gt;<br>&gt; Even size(of:) seems more general to me than I&#39;d like. I&#39;d like to see the<br>&gt; word &quot;memory&quot; as part of the name somehow, whether it&#39;s a wrapping type or<br>&gt; a function prefix of some sort. These values are specialized; we don&#39;t need<br>&gt; to optimize typing them, IMO.<br>&gt;<br>&gt; On Thu, Jun 2, 2016 at 2:06 PM Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be<br>&gt;&gt;&gt; better to ask people to just use a type explicitly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree; in fact *why aren’t these properties on the type itself*? The<br>&gt;&gt;&gt; type is what matters; why can’t the type just tell me it’s size?<br>&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover<br>&gt;&gt;&gt; from C.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Int.size<br>&gt;&gt;&gt;     Int.alignment<br>&gt;&gt;&gt;     Int.spacing<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let x: Any = 5<br>&gt;&gt;&gt;     type(of: x).size<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler should be able to statically know the first three values<br>&gt;&gt;&gt; and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Two reasons.  The first is that this is a user-extensible namespace via<br>&gt;&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names from<br>&gt;&gt;&gt; the library.  The second is that there&#39;s currently no language mechanism<br>&gt;&gt;&gt; for adding a static member to every type, so this would have to be<br>&gt;&gt;&gt; built-in.  But I agree that in the abstract a static property would be<br>&gt;&gt;&gt; preferable.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In the earlier conversation, it was pointed out (by Dave A., I think?)<br>&gt;&gt; that examples such as Array.size show how this solution can get confusing.<br>&gt;&gt; And even though there aren&#39;t fixed-length arrays in Swift, those may come<br>&gt;&gt; one day, making the syntax even more confusing.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/d2019eea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Jun 2, 2016 at 2:25 PM Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On the other hand, on its own sizeof() is not unsafe, and so the argument<br>&gt; that it should be longer to call attention to itself (by analogy with<br>&gt; UnsafePointer) isn&#39;t quite apt.<br>&gt;<br>&gt; And I&#39;m not sure we really want to encourage anyone else to be defining a<br>&gt; global function named size(of:) anyway, so I wouldn&#39;t consider vacating<br>&gt; that name for end-user purposes to be a meaningful positive.<br>&gt;<br></p><p>I was thinking more of situations where someone is in a scope (such as a<br>method in a struct or class) that has its own size(of:) method but also<br>needs to do something with the global size(of:) and now has to distinguish<br>the two. I&#39;ll admit that the likelihood of all of those stars aligning is<br>probably rare, though.<br></p><p>That being said, I see no reason to choose a very general name over one<br>that is far more descriptive. We should optimize for the N times an<br>expression is read instead of the one time it&#39;s written.<br></p><p><br></p><p>&gt; On Thu, Jun 2, 2016 at 16:15 Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;<br>&gt;&gt; Given that these are fairly low-level values with very specialized uses,<br>&gt;&gt; I definitely agree that they should be somehow namespaced in a way that<br>&gt;&gt; doesn&#39;t cause us to make very common words unusable for our users.<br>&gt;&gt;<br>&gt;&gt; Even size(of:) seems more general to me than I&#39;d like. I&#39;d like to see<br>&gt;&gt; the word &quot;memory&quot; as part of the name somehow, whether it&#39;s a wrapping type<br>&gt;&gt; or a function prefix of some sort. These values are specialized; we don&#39;t<br>&gt;&gt; need to optimize typing them, IMO.<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 2:06 PM Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be<br>&gt;&gt;&gt;&gt; better to ask people to just use a type explicitly.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree; in fact *why aren’t these properties on the type itself*? The<br>&gt;&gt;&gt;&gt; type is what matters; why can’t the type just tell me it’s size?<br>&gt;&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover<br>&gt;&gt;&gt;&gt; from C.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Int.size<br>&gt;&gt;&gt;&gt;     Int.alignment<br>&gt;&gt;&gt;&gt;     Int.spacing<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let x: Any = 5<br>&gt;&gt;&gt;&gt;     type(of: x).size<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The compiler should be able to statically know the first three values<br>&gt;&gt;&gt;&gt; and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Two reasons.  The first is that this is a user-extensible namespace via<br>&gt;&gt;&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names from<br>&gt;&gt;&gt;&gt; the library.  The second is that there&#39;s currently no language mechanism<br>&gt;&gt;&gt;&gt; for adding a static member to every type, so this would have to be<br>&gt;&gt;&gt;&gt; built-in.  But I agree that in the abstract a static property would be<br>&gt;&gt;&gt;&gt; preferable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the earlier conversation, it was pointed out (by Dave A., I think?)<br>&gt;&gt;&gt; that examples such as Array.size show how this solution can get confusing.<br>&gt;&gt;&gt; And even though there aren&#39;t fixed-length arrays in Swift, those may come<br>&gt;&gt;&gt; one day, making the syntax even more confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/97bf70ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 3:35 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Jun 2, 2016 at 2:25 PM Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; On the other hand, on its own sizeof() is not unsafe, and so the argument that it should be longer to call attention to itself (by analogy with UnsafePointer) isn&#39;t quite apt.<br>&gt; <br>&gt; And I&#39;m not sure we really want to encourage anyone else to be defining a global function named size(of:) anyway, so I wouldn&#39;t consider vacating that name for end-user purposes to be a meaningful positive.<br>&gt; <br>&gt; I was thinking more of situations where someone is in a scope (such as a method in a struct or class) that has its own size(of:) method but also needs to do something with the global size(of:) and now has to distinguish the two. I&#39;ll admit that the likelihood of all of those stars aligning is probably rare, though.<br>&gt; <br>&gt; That being said, I see no reason to choose a very general name over one that is far more descriptive. We should optimize for the N times an expression is read instead of the one time it&#39;s written.<br></p><p>/// Returns the contiguous memory footprint of `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `memorySize(ofType: X.self)`, when `X` is a class type, is the<br>/// same regardless of how many stored properties `X` has.<br>public func memorySize &lt;T&gt;(ofType: T.Type) -&gt; Int<br></p><p>/// Returns the contiguous memory footprint of  `T`.<br>///<br>/// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>/// In particular, `memorySize(of: a)`, when `a` is a class instance, is the<br>/// same regardless of how many stored properties `a` has.<br>public func memorySize &lt;T&gt;(of: T) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func memoryInterval&lt;T&gt;(ofType: T.Type) -&gt; Int<br></p><p>/// Returns the least possible interval between distinct instances of<br>/// `T` in memory.  The result is always positive.<br>public func memoryInterval &lt;T&gt;(of: T) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func memoryAlignment&lt;T&gt;(ofType: T.Type) -&gt; Int<br></p><p>/// Returns the minimum memory alignment of `T`.<br>public func memoryAlignment &lt;T&gt;(of: T) -&gt; Int<br></p><p><br>https://github.com/erica/swift-evolution/blob/sizestride/proposals/XXXX-sidestride.md &lt;https://github.com/erica/swift-evolution/blob/sizestride/proposals/XXXX-sidestride.md&gt;<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/fae9c6d1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 4:25 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On the other hand, on its own sizeof() is not unsafe, and so the argument that it should be longer to call attention to itself (by analogy with UnsafePointer) isn&#39;t quite apt.<br></p><p>These operations aren&#39;t themselves unsafe.  But they are low level details that are not useful unless you are doing something that requires special care.  A name that stands out more calls attention to the surrounding code.  That is a good thing IMO.<br></p><p>&gt; <br>&gt; And I&#39;m not sure we really want to encourage anyone else to be defining a global function named size(of:) anyway, so I wouldn&#39;t consider vacating that name for end-user purposes to be a meaningful positive.<br>&gt;&gt; On Thu, Jun 2, 2016 at 16:15 Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt; Given that these are fairly low-level values with very specialized uses, I definitely agree that they should be somehow namespaced in a way that doesn&#39;t cause us to make very common words unusable for our users.<br>&gt;&gt; <br>&gt;&gt; Even size(of:) seems more general to me than I&#39;d like. I&#39;d like to see the word &quot;memory&quot; as part of the name somehow, whether it&#39;s a wrapping type or a function prefix of some sort. These values are specialized; we don&#39;t need to optimize typing them, IMO.<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 2:06 PM Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;&gt;&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     Int.size<br>&gt;&gt;&gt;&gt;&gt;     Int.alignment<br>&gt;&gt;&gt;&gt;&gt;     Int.spacing<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     let x: Any = 5<br>&gt;&gt;&gt;&gt;&gt;     type(of: x).size<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Two reasons.  The first is that this is a user-extensible namespace via static members, so it&#39;s somewhat unfortunate to pollute it with names from the library.  The second is that there&#39;s currently no language mechanism for adding a static member to every type, so this would have to be built-in.  But I agree that in the abstract a static property would be preferable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the earlier conversation, it was pointed out (by Dave A., I think?) that examples such as Array.size show how this solution can get confusing. And even though there aren&#39;t fixed-length arrays in Swift, those may come one day, making the syntax even more confusing.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/0f808b99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  3, 2016 at 01:00:00am</p></header><div class="content"><p>As I said above, I disagree. Unsafe things should have names that call<br>attention to themselves. Safe things should not, *especially* if they&#39;re<br>unsafe-adjacent. It&#39;s not useful in a line of code to have every part of it<br>competing for your attention merely because they&#39;re typically used in<br>conjunction with an unsafe operation. It&#39;s essential that the unsafe<br>operation itself stand out.<br></p><p>Ever see a doctor clicking their mouse faster than a video gamer to dismiss<br>20 warnings in a row on a computer screen? That&#39;s what happens when<br>everything unsafe-adjacent calls attention to itself.<br>On Thu, Jun 2, 2016 at 19:53 Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 2, 2016, at 4:25 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On the other hand, on its own sizeof() is not unsafe, and so the argument<br>&gt; that it should be longer to call attention to itself (by analogy with<br>&gt; UnsafePointer) isn&#39;t quite apt.<br>&gt;<br>&gt;<br>&gt; These operations aren&#39;t themselves unsafe.  But they are low level details<br>&gt; that are not useful unless you are doing something that requires special<br>&gt; care.  A name that stands out more calls attention to the surrounding<br>&gt; code.  That is a good thing IMO.<br>&gt;<br>&gt;<br>&gt; And I&#39;m not sure we really want to encourage anyone else to be defining a<br>&gt; global function named size(of:) anyway, so I wouldn&#39;t consider vacating<br>&gt; that name for end-user purposes to be a meaningful positive.<br>&gt; On Thu, Jun 2, 2016 at 16:15 Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;<br>&gt;&gt; Given that these are fairly low-level values with very specialized uses,<br>&gt;&gt; I definitely agree that they should be somehow namespaced in a way that<br>&gt;&gt; doesn&#39;t cause us to make very common words unusable for our users.<br>&gt;&gt;<br>&gt;&gt; Even size(of:) seems more general to me than I&#39;d like. I&#39;d like to see<br>&gt;&gt; the word &quot;memory&quot; as part of the name somehow, whether it&#39;s a wrapping type<br>&gt;&gt; or a function prefix of some sort. These values are specialized; we don&#39;t<br>&gt;&gt; need to optimize typing them, IMO.<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 2, 2016 at 2:06 PM Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be<br>&gt;&gt;&gt;&gt; better to ask people to just use a type explicitly.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree; in fact *why aren’t these properties on the type itself*? The<br>&gt;&gt;&gt;&gt; type is what matters; why can’t the type just tell me it’s size?<br>&gt;&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover<br>&gt;&gt;&gt;&gt; from C.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Int.size<br>&gt;&gt;&gt;&gt;     Int.alignment<br>&gt;&gt;&gt;&gt;     Int.spacing<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let x: Any = 5<br>&gt;&gt;&gt;&gt;     type(of: x).size<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The compiler should be able to statically know the first three values<br>&gt;&gt;&gt;&gt; and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Two reasons.  The first is that this is a user-extensible namespace via<br>&gt;&gt;&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names from<br>&gt;&gt;&gt;&gt; the library.  The second is that there&#39;s currently no language mechanism<br>&gt;&gt;&gt;&gt; for adding a static member to every type, so this would have to be<br>&gt;&gt;&gt;&gt; built-in.  But I agree that in the abstract a static property would be<br>&gt;&gt;&gt;&gt; preferable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In the earlier conversation, it was pointed out (by Dave A., I think?)<br>&gt;&gt;&gt; that examples such as Array.size show how this solution can get confusing.<br>&gt;&gt;&gt; And even though there aren&#39;t fixed-length arrays in Swift, those may come<br>&gt;&gt;&gt; one day, making the syntax even more confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/ec6871b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; In the earlier conversation, it was pointed out (by Dave A., I think?) that examples such as Array.size show how this solution can get confusing. And even though there aren&#39;t fixed-length arrays in Swift, those may come one day, making the syntax even more confusing.<br></p><p><br>Array.count is a function taking an instance; I’m not sure I agree it would be terribly confusing… then again I run in Xcode with the quick help pane open so I see the doc comments for every type, property, and function as I move around the code. It’s quite handy :)<br></p><p>I could see including memory in the name (or something similar) if we want to be extra clear about it.<br></p><p>    Int.memorySize<br>    Int.memoryAlignment<br></p><p><br>Ultimately the type’s size in memory is a property of the type so it seems clear that is where it belongs (being careful not to steal too much of the namespace of course).<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c825d2d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Isn&#39;t this the same argument for .dynamicType over type(of:) though?<br></p><p>Given that that debate has been settled in favor of the latter, I think the<br>question today is how best to come up with a consistent scheme.<br></p><p>Earlier in this conversation, it was pointed out (by Matt, I think?) that<br>one key advantage of type(of:) is that it takes on a syntax that is<br>actually possible to write in Swift, since one cannot extend Any.<br></p><p>If we take this principle to its logical conclusion, properties (of a type<br>or instance) which apply to Any should be global functions.<br></p><p>On Thu, Jun 2, 2016 at 16:26 Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 2, 2016, at 2:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; In the earlier conversation, it was pointed out (by Dave A., I think?)<br>&gt; that examples such as Array.size show how this solution can get confusing.<br>&gt; And even though there aren&#39;t fixed-length arrays in Swift, those may come<br>&gt; one day, making the syntax even more confusing.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Array.count is a function taking an instance; I’m not sure I agree it<br>&gt; would be terribly confusing… then again I run in Xcode with the quick help<br>&gt; pane open so I see the doc comments for every type, property, and function<br>&gt; as I move around the code. It’s quite handy :)<br>&gt;<br>&gt; I could see including memory in the name (or something similar) if we want<br>&gt; to be extra clear about it.<br>&gt;<br>&gt;     Int.memorySize<br>&gt;     Int.memoryAlignment<br>&gt;<br>&gt;<br>&gt; Ultimately the type’s size in memory *is a property of the type* so it<br>&gt; seems clear that is where it belongs (being careful not to steal too much<br>&gt; of the namespace of course).<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/c2547902/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Isn&#39;t this the same argument for .dynamicType over type(of:) though?<br>&gt; <br>&gt; Given that that debate has been settled in favor of the latter, I think the question today is how best to come up with a consistent scheme.<br>&gt; <br>&gt; Earlier in this conversation, it was pointed out (by Matt, I think?) that one key advantage of type(of:) is that it takes on a syntax that is actually possible to write in Swift, since one cannot extend Any.<br></p><p>Yep, IMO we should stick with the strategy that if something *looks* like a user-definable construct it should be possible to at least write the declaration even if it wouldn&#39;t be possible to implement.  That rules out static or instance properties or methods that apply to all types.<br></p><p>&gt; <br>&gt; If we take this principle to its logical conclusion, properties (of a type or instance) which apply to Any should be global functions.<br>&gt; <br>&gt;&gt; On Thu, Jun 2, 2016 at 16:26 Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 2:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the earlier conversation, it was pointed out (by Dave A., I think?) that examples such as Array.size show how this solution can get confusing. And even though there aren&#39;t fixed-length arrays in Swift, those may come one day, making the syntax even more confusing.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Array.count is a function taking an instance; I’m not sure I agree it would be terribly confusing… then again I run in Xcode with the quick help pane open so I see the doc comments for every type, property, and function as I move around the code. It’s quite handy :)<br>&gt;&gt; <br>&gt;&gt; I could see including memory in the name (or something similar) if we want to be extra clear about it.<br>&gt;&gt; <br>&gt;&gt;     Int.memorySize<br>&gt;&gt;     Int.memoryAlignment<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ultimately the type’s size in memory is a property of the type so it seems clear that is where it belongs (being careful not to steal too much of the namespace of course).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/a0f23dd2/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 2:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;     Int.size<br>&gt;&gt;     Int.alignment<br>&gt;&gt;     Int.spacing<br>&gt;&gt; <br>&gt;&gt;     let x: Any = 5<br>&gt;&gt;     type(of: x).size<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt; <br>&gt; Two reasons.  The first is that this is a user-extensible namespace via static members, so it&#39;s somewhat unfortunate to pollute it with names from the library.  The second is that there&#39;s currently no language mechanism for adding a static member to every type, so this would have to be built-in.  But I agree that in the abstract a static property would be preferable.<br>&gt; <br>&gt; In the earlier conversation, it was pointed out (by Dave A., I think?) that examples such as Array.size show how this solution can get confusing. And even though there aren&#39;t fixed-length arrays in Swift, those may come one day, making the syntax even more confusing.<br></p><p>Yes, I think that it is clear that, even if we added a property on all types, it would not be acceptable to name that property something like &quot;size&quot;; it would have to be something longer like &quot;storageSize&quot;.<br></p><p>John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/8dedf108/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 2, 2016, at 3:28 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 2:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Thu, Jun 2, 2016 at 3:46 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Yes, I think that it is clear that, even if we added a property on all types, it would not be acceptable to name that property something like &quot;size&quot;; it would have to be something longer like &quot;storageSize&quot;.<br></p><p>Suggested names so far for augmenting the base:<br></p><p>* memorySize, memoryAlignment, memorySpacing/memoryStride<br>* storageSize, storageAlignment, storageSpacing/storageStride<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/47bd1e17/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  2, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 2, 2016, at 12:05 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Jun 1, 2016 at 11:55 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; On Wed, Jun 1, 2016 at 11:28 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Upon accepting SE-0098, the core team renamed the proposed stdlib function from dynamicType() to type(of:).  They write, &quot;The core team recognizes that this means that we should probably resyntax the existing sizeof/strideof functions, but that should be a follow-on discussion.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Follow on discussion started. Have at it.<br>&gt;&gt; <br>&gt;&gt; See: http://thread.gmane.org/gmane.comp.lang.swift.evolution/15830<br>&gt; <br>&gt; To summarize the previous discussion:<br>&gt; <br>&gt; 1. Per Joe Groff, although sizeof() and friends are treated as terms-of-art, these names were lifted straight from C and do not correspond to anything named &quot;sizeof&quot; in LLVM.<br>&gt; <br>&gt; 2. There are issues with using a name such as stride(of:), because stride(...) already means something else in the stdlib; moreover, size(of:) isn&#39;t the best name for something that doesn&#39;t do what its C namesake does; therefore, larger changes to the naming were suggested.<br>&gt; <br>&gt; 2. Dave A. and others expressed the opinion that these should probably not be global functions; his preference was for:<br>&gt; <br>&gt; ```<br>&gt; MemoryLayout&lt;T&gt;.size // currently sizeof()<br>&gt; MemoryLayout&lt;T&gt;.spacing // currently strideof()<br>&gt; MemoryLayout&lt;T&gt;.alignment // currently alignof()<br>&gt; ```<br></p><p>Thanks for the summary.  I missed the original thread.  <br></p><p>I think I like this approach despite its verbosity.  Will give it a little bit more thought...<br></p><p>&gt; <br>&gt; 3. Dave A. proposed that sizeofValue(), strideofValue(), and alignofValue() are better off removed altogether. I don&#39;t know if people are going to be happy about this idea.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; If we take inspiration from type(of:), then it&#39;s actually sizeofValue(), etc., that should be renamed size(of:), etc. Also, a fun tidbit is that what&#39;s currently called sizeof(), etc.--the ones that take types rather than values--are actually not very good candidates for having parameter labels, because it&#39;s OK to write `sizeof(Int)`, but one must currently write `size(of: Int.self)` when the function has a label.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/f3780fd7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
