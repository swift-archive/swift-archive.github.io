<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sat Jan 23 2016, Tino Heth &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; We believe fairly strongly that Swift’s design here reflects the<br>&gt;&gt; appropriate defaults for clear, expressive APIs and code. The API<br>&gt;&gt; Design Guidelines line up with the default behavior of Swift for a<br>&gt;&gt; reason. Repeating the “Objective-C legacy” trope strongly implies<br>&gt;&gt; that you’re not considering the rationale behind Swift’s design, and<br>&gt;&gt; weakens your arguments considerably.<br>&gt;<br>&gt; I&#39;m not saying the influence of Objective-C is bad (therefore, I used<br>&gt; the quotation marks), but imho it&#39;s pointless to deny that it exists.<br></p><p>Nobody&#39;s denying that it was a consideration.  When I say, “these<br>defaults work well for the standard library,” I think it&#39;s relevant<br>because I don&#39;t have a Cocoa/ObjC background and the standard library<br>was designed, for the most part—and to the horror of some—without trying<br>to emulate Cocoa/ObjC conventions.<br></p><p>I initially thought, the same as you, that we wouldn&#39;t be doing it this<br>way if it weren&#39;t for legacy considerations, but what I found was that<br>my APIs generally fell in line naturally with the defaults.  And when<br>they didn&#39;t, looking for a way to take advantage of the defaults often<br>led to a better API<br>(c.f. http://news.gmane.org/find-root.php?message_id=m2h9i4hww3.fsf%40eno.apple.com).<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; but what I found was that my APIs generally fell in line naturally with<br>&gt; the defaults.<br></p><p>And when they didn&#39;t, looking for a way to take advantage of the defaults<br>&gt; often<br>&gt; led to a better API<br></p><p><br>I&#39;m not sure I follow this. A change would result in:<br></p><p>Pros:<br>- the rule of &quot;least surprise&quot;<br>- developers can edit function definitions more quickly<br></p><p>Cons:<br>- one extra character (i.e.: from &quot;*foo: Int*&quot; to &quot;*_ foo: Int*&quot;)<br>- one missed opportunity to set an example of &quot;good style&quot;<br></p><p>Am I missing something?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/27d47680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 24, 2016 at 11:00:00am</p></header><div class="content"><p>Reply below.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 24 Jan 2016, at 00:06, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; but what I found was that my APIs generally fell in line naturally with the defaults.  <br>&gt;&gt; And when they didn&#39;t, looking for a way to take advantage of the defaults often<br>&gt;&gt; led to a better API<br>&gt; <br>&gt; I&#39;m not sure I follow this. A change would result in:<br>&gt; <br>&gt; Pros:<br>&gt; - the rule of &quot;least surprise&quot;<br>&gt; - developers can edit function definitions more quickly <br>&gt; <br>&gt; Cons:<br>&gt; - one extra character (i.e.: from &quot;foo: Int&quot; to &quot;_ foo: Int&quot;)<br>&gt; - one missed opportunity to set an example of &quot;good style&quot;<br>&gt; <br>&gt; Am I missing something?<br></p><p>One extra character?<br></p><p>With our current Objective-C style, we need to repeat at least one word and often need to include &quot;with&quot;, &quot;by&quot;, &quot;using&quot;, etc. to make it read nicely.<br></p><p>Compare:<br></p><p>1.<br>splitWithSeparator(_ separator: ...<br></p><p>2.<br>split(separator: ...<br></p><p>The first form repeats &quot;separator&quot; twice and needs &quot;with&quot;. And then there&#39;s (as you mentioned) the underscore and the space character. In short, tons of crap.<br></p><p>R+<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/902c1431/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0fc40f95a5c6b063df44b3bc136d764b?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.com&gt;<p>January 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 24 Jan 2016, at 10:34, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; With our current Objective-C style, we need to repeat at least one word and often need to include &quot;with&quot;, &quot;by&quot;, &quot;using&quot;, etc. to make it read nicely.<br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; 1.<br>&gt; splitWithSeparator(_ separator: ...<br>&gt; <br>&gt; 2.<br>&gt; split(separator: ...<br>&gt; <br>&gt; The first form repeats &quot;separator&quot; twice and needs &quot;with&quot;. And then there&#39;s (as you mentioned) the underscore and the space character. In short, tons of crap.<br>&gt; <br>&gt; R+<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>Why not use split(withSeparator separator) instead?<br></p><p>The external parameter name still completes the natural language style, while allowing other split functions to be grouped together under a single action name (split). Personally I think is the best of both, in essence when you’re using the function/method you’re defining the action you want (split) then how you want to do it (withSeparator) which seems nice and logical.<br></p><p>- Haravikk<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/759abba2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January 24, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; With our current Objective-C style, we need to repeat at least one word<br>and often need to include &quot;with&quot;, &quot;by&quot;, &quot;using&quot;, etc. to make it read nicely<br></p><p>When it comes to my own code, I agree with you 100%. However, if I<br>understand the Swift team&#39;s rationale, using a label for the first argument<br>is more often than not, bad form.<br></p><p>The point I was trying to make with the pros/cons bullet points is that,<br>even being charitable with the cons and understated about the pros, the<br>change still makes more sense.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/2211af77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>named parameters - why hidden first?/proposal interest</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 24, 2016 at 07:00:00am</p></header><div class="content"><p>As another member of the “anti-fan-club” for the unnamed first parameter, I have to ask: what would be wrong with:<br></p><p>- single-argument functions: default to unnamed “first” (really: only) parameter<br>- multi-argument functions: default to all-named parameters<br></p><p>…(other than the obvious inconsistencies/special-casing so introduced)?<br></p><p>I mean more in terms of design goals/readability concerns.<br></p><p>The API guidelines seem to address two scenarios for multi-argument functions:<br></p><p>- functions in which one argument is the &quot;semantic focus” (and thus deserves to be the first argument, with its description folded-into the method name)<br>- functions in which all arguments are “co-equal participants” and have *identical* semantic roles, in which case all parameters should go un-named (e.g. ==, zip, etc.)<br></p><p>…but don’t address a third scenario, wherein:<br></p><p>- there are multiple arguments<br>- no one argument is the obvious, natural “semantic focus” of the method (thus there’s no natural candidate for which argument’s label ought to get folded-into the method name)<br>- the arguments all have distinct logical-roles within the method (thus the all-unnamed approach is not great)<br></p><p>…which scenario I think is not all that uncommon in application code (anecdotally 15-30%, depending on problem domain)?<br></p><p>As an example, consider something like this:<br></p><p>protocol PresentationController {<br>  typealias Content<br>  typealias PresentationUpdate<br></p><p>  // one of these feels right:<br>  func inferPresentationUpdate(fromPrevious previous: Content, toCurrent current: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdate(from previous: Content, to current: Content) -&gt; PresentationUpdate<br></p><p>  // none of these feels right:<br>  func inferPresentationUpdateFrom(content: Content, toCurrent current: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateFrom(content: Content, to current: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateFromPrevious(content: Content, toCurrent current: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateFromPrevious(content: Content, toCurrent current: Content) -&gt; PresentationUpdate<br></p><p>  // nor do any of these:<br>  func inferPresentationUpdateTo(content: Content, fromPrevious previous: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateTo(content: Content, from previous: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateToCurrent(content: Content, fromPrevious previous: Content) -&gt; PresentationUpdate<br>  func inferPresentationUpdateToCurrent(content: Content, from previous: Content) -&gt; PresentationUpdate<br></p><p>}<br></p><p>…which is as always a bit contrived, but illustrates a scenario wherein neither parameter is arguably the natural &quot;semantic focus” of the method.<br></p><p>(If you need to be convinced this shouldn’t be a method on `Content`, consider that `Content` may be a simple model entity, and that different types of “presentations” may differ in how they want to present model *updates* to the user).<br></p><p>But that’s my 2c; I don’t like the inconsistency, I understand the stated reasons for it, but I think multi-argument methods w/out an obvious “semantic focus” are common enough to deserve consideration.<br></p><p>&gt; On Jan 24, 2016, at 6:32 AM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; With our current Objective-C style, we need to repeat at least one word and often need to include &quot;with&quot;, &quot;by&quot;, &quot;using&quot;, etc. to make it read nicely<br>&gt; <br>&gt; When it comes to my own code, I agree with you 100%. However, if I understand the Swift team&#39;s rationale, using a label for the first argument is more often than not, bad form. <br>&gt; <br>&gt; The point I was trying to make with the pros/cons bullet points is that, even being charitable with the cons and understated about the pros, the change still makes more sense.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/08dc82a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
