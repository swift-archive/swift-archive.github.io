<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;Importing Objective-C Lightweight Generics&quot; begins now and runs through April 5. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p><br>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>Responses inline!<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p><p>On Thu, Mar 31, 2016, at 02:11 PM, Chris Lattner via swift-evolution<br>wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>The strongest of +1&#39;s. It will allow much greater flexibility for the<br>bridge, both in our own code and Apple&#39;s frameworks.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Like SE-0055, it&#39;s mildly ironic that these new features can<br>occasionally be more expressive or compiler-checked by Clang than by<br>Swift.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>At the high-level, absolutely. More generics = safer and smarter code.<br></p><p>At the lower-level, I&#39;m somewhat concerned about the mismatch between<br>the Swift side of lightweight generics vs. honest-to-god Swift generics.<br>As an instructor, I worry that the limitations may make learning<br>generics even more hairy. Considering &quot;Restrictions on uses of<br>Objective-C parameterized classes&quot; (while all the restrictions<br>completely make sense), I wonder how difficult it&#39;ll be to explain why<br>in a given specific instance (i.e., pulling a value out of a [String:<br>AnyObject]) can&#39;t be casted.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I&#39;ve used type-erased generics before in other languages. While not<br>preferable when you have something like Swift&#39;s implementation, this is<br>acceptable for a bridge.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve been considering the effects of this feature since bridging came to<br>ObjC, really excited to see it. Quick glance at the proposal itself.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>A couple of questions, since this proposal hasn&#39;t had the regular<br>Evolution run-through:<br></p><p>1. The section &quot;Importing unspecialized types&quot; makes reference to<br>defaulting to the unbound requirement when something isn&#39;t annotated in<br>Objective-C. This is notably something that isn&#39;t true in Swift at<br>present (i.e., a T: ErrorType can&#39;t be satisfied by ErrorType). Would<br>this be a change that comes generalized to Swift, or is just true of the<br>lightweight generics bridge.<br></p><p>2. How undefined is the undefined behavior in things coming from<br>Objective-C? If something is exposed into Swift as one type bounds, but<br>for legacy or bug reasons, another class is pushed across the bridge,<br>precisely what color will the resulting explosion be at runtime?<br></p><p>3. Re: &quot;Opting in to type argument discovery&quot;, how would initialization<br>look for GKComponentSystem? Having to do<br>GKComponentSystem&lt;SomeType&gt;(componentClass: SomeType.self) would be<br>pretty onerous. Would this have to be treated in the overlay framework<br>too as well?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 11:42 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Responses inline!<br>&gt; <br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me<br>&gt; <br>&gt; On Thu, Mar 31, 2016, at 02:11 PM, Chris Lattner via swift-evolution<br>&gt; wrote:<br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; The strongest of +1&#39;s. It will allow much greater flexibility for the<br>&gt; bridge, both in our own code and Apple&#39;s frameworks.<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes. Like SE-0055, it&#39;s mildly ironic that these new features can<br>&gt; occasionally be more expressive or compiler-checked by Clang than by<br>&gt; Swift.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; At the high-level, absolutely. More generics = safer and smarter code.<br>&gt; <br>&gt; At the lower-level, I&#39;m somewhat concerned about the mismatch between<br>&gt; the Swift side of lightweight generics vs. honest-to-god Swift generics.<br>&gt; As an instructor, I worry that the limitations may make learning<br>&gt; generics even more hairy. Considering &quot;Restrictions on uses of<br>&gt; Objective-C parameterized classes&quot; (while all the restrictions<br>&gt; completely make sense), I wonder how difficult it&#39;ll be to explain why<br>&gt; in a given specific instance (i.e., pulling a value out of a [String:<br>&gt; AnyObject]) can&#39;t be casted.<br></p><p>I agree that the restrictions will feel arbitrary, because it takes a fairly deep understanding of the implementation models of both ObjC generics and Swift generics to understand why they are there. My hope is that imported ObjC generic classes will be used far more than they are extended.<br></p><p>&gt; _<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; A couple of questions, since this proposal hasn&#39;t had the regular<br>&gt; Evolution run-through:<br></p><p>It did get some discussion at<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886<br></p><p>&gt; 1. The section &quot;Importing unspecialized types&quot; makes reference to<br>&gt; defaulting to the unbound requirement when something isn&#39;t annotated in<br>&gt; Objective-C. This is notably something that isn&#39;t true in Swift at<br>&gt; present (i.e., a T: ErrorType can&#39;t be satisfied by ErrorType). Would<br>&gt; this be a change that comes generalized to Swift, or is just true of the<br>&gt; lightweight generics bridge.<br></p><p>@objc protocols don’t have associated types or self requirements, and (from an implementation standpoint) a object of @objc protocol type isn’t actually any different from an object of some class type that conforms to the @objc protocol.<br></p><p>&gt; <br>&gt; 2. How undefined is the undefined behavior in things coming from<br>&gt; Objective-C? If something is exposed into Swift as one type bounds, but<br>&gt; for legacy or bug reasons, another class is pushed across the bridge,<br>&gt; precisely what color will the resulting explosion be at runtime?<br></p><p>It’s truly undefined behavior. For example, if it’s a Swift-defined class we’re expecting but we get an object of some unrelated type in its place, we might very well poke directly at storage in the object (i.e., when accessing a stored property), or grab a random pointer out of the vtable that isn’t what we expected.<br></p><p>&gt; <br>&gt; 3. Re: &quot;Opting in to type argument discovery&quot;, how would initialization<br>&gt; look for GKComponentSystem? Having to do<br>&gt; GKComponentSystem&lt;SomeType&gt;(componentClass: SomeType.self) would be<br>&gt; pretty onerous.<br></p><p>That onerous solution is what one gets from this proposal.<br></p><p>&gt; Would this have to be treated in the overlay framework<br>&gt; too as well?<br></p><p><br>One would have to clean this up in the overlay.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April  1, 2016 at 08:00:00am</p></header><div class="content"><p>A few quick questions:<br></p><p> * Is there a swift-evolution discussion thread? It&#39;s marked as TODO<br>currently.<br> * What if you want your generic parameter to be a protocol instead of a<br>class?<br></p><p>Thanks!<br>Andrew Bennett<br></p><p>On Friday, 1 April 2016, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;Importing Objective-C Lightweight Generics&quot; begins now and<br>&gt; runs through April 5. The proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at:<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the direction of<br>&gt; Swift. When writing your review, here are some questions you might want to<br>&gt; answer in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have you used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/f377f345/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 2:40 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A few quick questions:<br>&gt; <br>&gt;  * Is there a swift-evolution discussion thread? It&#39;s marked as TODO currently.<br></p><p>Thanks for catching that. The thread is here:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886<br></p><p>and I’ve updated the proposal with a link.<br></p><p>&gt;  * What if you want your generic parameter to be a protocol instead of a class?<br></p><p>The generic parameter itself can be required to conform to @objc protocols; the generic argument will be able to be an @objc protocol when the protocol conforms to itself.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Thanks!<br>&gt; Andrew Bennett<br>&gt; <br>&gt; On Friday, 1 April 2016, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;Importing Objective-C Lightweight Generics&quot; begins now and runs through April 5. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0057-importing-objc-generics.md&gt;<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/c43a442d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I like it, but I have a couple of minor issues with the details.<br></p><p>The first is that type discovery does not support the full richness of either language&#39;s type system. Both languages allow a type to be either a class or a group of protocols, and Objective-C even allows one class + N protocols. I believe these methods should permit any valid Objective-C generic type to be expressed. That could be achieved by having two methods (plus class method variants):<br></p><p>	- (nullable Class)classForGenericArgumentAtIndex:(NSUInteger)index;	// nil means id<br>	- (NSArray&lt;Protocol*&gt;*)protocolsForGenericArgumentAtIndex:(NSUInteger)index;<br></p><p>The second is the issue of extensions. Rather than rejecting the use of the generic type parameter, I think we would be better off treating it as though it were a nested typealias. That is, when you write this:<br></p><p>	@interface MySet&lt;__covariant ObjectType: id&lt;NSCopying&gt;&gt; : NSObject<br></p><p>Then MySet.ObjectType is NSCopying. That would allow you to use ObjectType in extensions without particularly caring whether or not you were working with full generics.<br></p><p>The third is that I&#39;m troubled by the invisibility of this feature given its limitations. I understand why you don&#39;t want to implement full type erasure, but there should at least be some suggestion of the semantics in the generated headers:<br></p><p>	class MySet&lt;@erased ObjectType: NSCopying&gt;: NSObject<br></p><p>@erased does not have to actually work in user-written code—it&#39;s just there in the generated header to mark the type parameter&#39;s special semantics.<br></p><p>Finally, this is a severable issue, but I think it&#39;s worth mentioning: it would be very helpful to expose generic classes back to Objective-C somehow. One of my projects has a CaseInsensitiveDictionary type written in Swift; I have reference-typed NSObject subclasses to expose it to Objective-C, but these can&#39;t be generic. Even lightweight generics, even exposed only to Objective-C, would make this code a lot better.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. I&#39;ve missed this type information in Swift.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have you used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Swift&#39;s interop concerns are pretty unique, in my experience.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Well, I&#39;ve been drafting this email for several hours. Does that count?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 31, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Mar 31, 2016, at 6:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I like it, but I have a couple of minor issues with the details.<br>&gt; <br>&gt; The first is that type discovery does not support the full richness of either language&#39;s type system. Both languages allow a type to be either a class or a group of protocols, and Objective-C even allows one class + N protocols. I believe these methods should permit any valid Objective-C generic type to be expressed. That could be achieved by having two methods (plus class method variants):<br>&gt; <br>&gt; 	- (nullable Class)classForGenericArgumentAtIndex:(NSUInteger)index;	// nil means id<br>&gt; 	- (NSArray&lt;Protocol*&gt;*)protocolsForGenericArgumentAtIndex:(NSUInteger)index;<br></p><p>That’s a great point. Objective-C metadata doesn’t allow us to model it as a single entity, but a Class + array-of-protocols pair would suffice. I’d rather fold this into a single entrypoint, however, to reduce objc_msgSend overhead. I will note that I haven’t come across a generic Objective-C class that actually has protocol information in it, so it’s not clear whether this would actually get used.<br></p><p>&gt; The second is the issue of extensions. Rather than rejecting the use of the generic type parameter, I think we would be better off treating it as though it were a nested typealias. That is, when you write this:<br>&gt; <br>&gt; 	@interface MySet&lt;__covariant ObjectType: id&lt;NSCopying&gt;&gt; : NSObject<br>&gt; <br>&gt; Then MySet.ObjectType is NSCopying. That would allow you to use ObjectType in extensions without particularly caring whether or not you were working with full generics.<br></p><p>I intentionally didn’t propose this because I think it would be very, very confusing. In extensions of Swift-defined generic types, ObjectType would have one meaning: it’s the type for the current specialization and it’s type-safe. In extensions of Objective-C generic types, ObjectType might have either the same meaning as in Swift-defined generic types (i.e., it’s type-safe) or it might be type-erased… and the answer could differ between a static method and an instance method in the same extension! Better to ban references to the generic parameter so it’s obvious to the user that it’s not a notion they can depend on.<br></p><p>&gt; The third is that I&#39;m troubled by the invisibility of this feature given its limitations. I understand why you don&#39;t want to implement full type erasure, but there should at least be some suggestion of the semantics in the generated headers:<br>&gt; <br>&gt; 	class MySet&lt;@erased ObjectType: NSCopying&gt;: NSObject<br>&gt; <br>&gt; @erased does not have to actually work in user-written code—it&#39;s just there in the generated header to mark the type parameter&#39;s special semantics.<br></p><p>I started with this, then eventually decided against it, because it’s just noise for the vast majority of users who just use the initializers, methods, and properties that exist on the type. It also implies that this is a general feature of the Swift generics system, which I don’t want: it’s limitations are an artifact of interoperability. <br></p><p>&gt; <br>&gt; Finally, this is a severable issue, but I think it&#39;s worth mentioning: it would be very helpful to expose generic classes back to Objective-C somehow. One of my projects has a CaseInsensitiveDictionary type written in Swift; I have reference-typed NSObject subclasses to expose it to Objective-C, but these can&#39;t be generic. Even lightweight generics, even exposed only to Objective-C, would make this code a lot better.<br></p><p>The main issue with this is that Objective-C cannot construct the specialized Swift metatype properly when allocating an instance of this class. We could perhaps export factory initializers to Objective-C that introduce additional “Class” parameters for each of the generic type arguments, so that the Swift-defined factory initializer could form the specialized Swift metatype, then allocate the instance. Or you could fake “alloc” for such types… it’s doable, but messy.<br></p><p>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Well, I&#39;ve been drafting this email for several hours. Does that count?<br></p><p>Hah! I’ll take it.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Review] SE-0057: Importing Objective-C Lightweight Generics</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>April  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Generally I like the proposal and I think it helps solidify the bridging story.<br></p><p><br>On casting: In our coding standards, any use of “as!” warrants much higher scrutiny (any use of try! or IUOs gets the same treatment). For a type that opts-in to type discovery, why can’t “as?” casting work? It seems like there’s enough information to determine if the cast should succeed or not. <br></p><p>It is also slightly strange that the collection types have the same problems but allow bridging, and in the as! case they actually defer checking until later. It may just be an inconsistency we have to live with for practical reasons.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes; the mountains of Objective-C code aren’t going away anytime soon.<br></p><p><br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>It has some rough edges but I think they’re unavoidable given the fundamental differences between Objective-C and Swift generics.<br></p><p><br></p><p><br>Russ<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
