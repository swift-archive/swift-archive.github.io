<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 18, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Given all this, I think it makes sense to go for syntactic<br>&gt;&gt; uniformity between parameter list and function types, and just<br>&gt;&gt; require parenthesis on the argument list.  The types above can be<br>&gt;&gt; trivially written as:<br>&gt;&gt; <br>&gt;&gt;  (Int) -&gt; Float<br>&gt;&gt;  (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;<br>&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that<br>&gt; this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people <br></p><p>Do we have any data on this (in either direction)?<br></p><p>Personally, it has always seemed obvious that T -&gt; U being a function<br>type would be quite novel to some people, considering the number of<br>times I&#39;ve seen in Haskell texts that (surprise!) you don&#39;t need<br>parentheses to invoke functions.  I guess those are invocations and<br>we&#39;re talking about declarations here, but declaration-follows-use is a<br>kind of principle the language tries to uphold.<br></p><p>But that&#39;s just intuition.  Data would be very interesting.<br></p><p>&gt; and doesn&#39;t confuse the compiler; removing it would require extra<br>&gt; punctuation for no particular reason. It would also become<br>&gt; inconsistent with the paren-less `{ param in … }` syntax, which I<br>&gt; think is very important for keeping usage sites simple and clean.<br>&gt;<br>&gt; What I think we *should* eliminate, however, is using `Void` to mean<br>&gt; &quot;no arguments&quot; in a closure type. `Void -&gt; Int` should mean that the<br>&gt; type takes one argument which happens to be an empty tuple. If you<br>&gt; want no arguments, write `() -&gt; Int`. Similarly, a typedef for a<br>&gt; 2-tuple (like `Dictionary.Element`) should be recognized as one tuple<br>&gt; parameter, not two singleton parameters. With that in place, `T -&gt; U`<br>&gt; becomes merely a convenient shorthand for the canonical form, `(T) -&gt;<br>&gt; U`.<br>&gt;<br>&gt; I mean, it&#39;s not that big a deal; if you remove it, everyone will type<br>&gt; extra parentheses and live with it. But recognize that doing so would<br>&gt; improve the language, not the end-user experience.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 19, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 18, 2016, at 4:31 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic<br>&gt;&gt;&gt; uniformity between parameter list and function types, and just<br>&gt;&gt;&gt; require parenthesis on the argument list.  The types above can be<br>&gt;&gt;&gt; trivially written as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that<br>&gt;&gt; this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people <br>&gt; <br>&gt; Do we have any data on this (in either direction)?<br>&gt; <br>&gt; Personally, it has always seemed obvious that T -&gt; U being a function<br>&gt; type would be quite novel to some people, considering the number of<br>&gt; times I&#39;ve seen in Haskell texts that (surprise!) you don&#39;t need<br>&gt; parentheses to invoke functions.  I guess those are invocations and<br>&gt; we&#39;re talking about declarations here, but declaration-follows-use is a<br>&gt; kind of principle the language tries to uphold.<br>&gt; <br>&gt; But that&#39;s just intuition.  Data would be very interesting.<br></p><p>Apart from intuition and confusion, parentheses are used at call sites<br>and declarations. It seems out of line that they can be removed in types <br>but only in one degenerate case.<br></p><p>This goes against the Swift core design goal of consistency.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/4dc7a57e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>For what it’s worth, I searched my Swift code and didn’t find a single instance where I did *not* use the parens - even for single-argument functions. Until this conversation came up, I don’t recall if it ever even occurred to me that I *could* leave the parentheses out!<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Apr 19, 2016, at 9:49 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 18, 2016, at 4:31 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic<br>&gt;&gt;&gt;&gt; uniformity between parameter list and function types, and just<br>&gt;&gt;&gt;&gt; require parenthesis on the argument list.  The types above can be<br>&gt;&gt;&gt;&gt; trivially written as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that<br>&gt;&gt;&gt; this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people <br>&gt;&gt; <br>&gt;&gt; Do we have any data on this (in either direction)?<br>&gt;&gt; <br>&gt;&gt; Personally, it has always seemed obvious that T -&gt; U being a function<br>&gt;&gt; type would be quite novel to some people, considering the number of<br>&gt;&gt; times I&#39;ve seen in Haskell texts that (surprise!) you don&#39;t need<br>&gt;&gt; parentheses to invoke functions.  I guess those are invocations and<br>&gt;&gt; we&#39;re talking about declarations here, but declaration-follows-use is a<br>&gt;&gt; kind of principle the language tries to uphold.<br>&gt;&gt; <br>&gt;&gt; But that&#39;s just intuition.  Data would be very interesting.<br>&gt; <br>&gt; Apart from intuition and confusion, parentheses are used at call sites<br>&gt; and declarations. It seems out of line that they can be removed in types <br>&gt; but only in one degenerate case.<br>&gt; <br>&gt; This goes against the Swift core design goal of consistency.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>April 19, 2016 at 05:00:00pm</p></header><div class="content"><p>Would this also affect the syntax for naming closure arguments? For example, would this (taken from &quot;The Swift Programming Language (Swift 2.2)”):<br>  reversed = names.sort( { s1, s2 in return s1 &gt; s2 } )<br>have to be written like this:<br>  reversed = names.sort( { (s1, s2) in return s1 &gt; s2 } )<br>or is that a different syntax?<br></p><p>As a developer focused on _writing_ and _reading_ code like this, I don’t see the real benefits of this change. It only feels natural to me that I would be able to omit the parentheses when there is only one type, but that I would need them to group multiple arguments or to label arguments.<br></p><p>That said, I don’t feel strongly about it and the work of transitioning our code would be minimal. If this change provides other engineering benefits that aren’t noticeable on the surface, then I’m positive to the change for those reasons.<br></p><p>- David<br> <br>&gt; On 19 Apr 2016, at 16:59, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For what it’s worth, I searched my Swift code and didn’t find a single instance where I did *not* use the parens - even for single-argument functions. Until this conversation came up, I don’t recall if it ever even occurred to me that I *could* leave the parentheses out!<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 19, 2016, at 9:49 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 18, 2016, at 4:31 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic<br>&gt;&gt;&gt;&gt;&gt; uniformity between parameter list and function types, and just<br>&gt;&gt;&gt;&gt;&gt; require parenthesis on the argument list.  The types above can be<br>&gt;&gt;&gt;&gt;&gt; trivially written as:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that<br>&gt;&gt;&gt;&gt; this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we have any data on this (in either direction)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, it has always seemed obvious that T -&gt; U being a function<br>&gt;&gt;&gt; type would be quite novel to some people, considering the number of<br>&gt;&gt;&gt; times I&#39;ve seen in Haskell texts that (surprise!) you don&#39;t need<br>&gt;&gt;&gt; parentheses to invoke functions.  I guess those are invocations and<br>&gt;&gt;&gt; we&#39;re talking about declarations here, but declaration-follows-use is a<br>&gt;&gt;&gt; kind of principle the language tries to uphold.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But that&#39;s just intuition.  Data would be very interesting.<br>&gt;&gt; <br>&gt;&gt; Apart from intuition and confusion, parentheses are used at call sites<br>&gt;&gt; and declarations. It seems out of line that they can be removed in types <br>&gt;&gt; but only in one degenerate case.<br>&gt;&gt; <br>&gt;&gt; This goes against the Swift core design goal of consistency.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/ac45a11d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 19, 2016, at 9:44 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would this also affect the syntax for naming closure arguments? For example, would this (taken from &quot;The Swift Programming Language (Swift 2.2)”):<br>&gt;   reversed = names.sort( { s1, s2 in return s1 &gt; s2 } )<br>&gt; have to be written like this:<br>&gt;   reversed = names.sort( { (s1, s2) in return s1 &gt; s2 } )<br>&gt; or is that a different syntax?<br>&gt; <br>&gt; As a developer focused on _writing_ and _reading_ code like this, I don’t see the real benefits of this change. It only feels natural to me that I would be able to omit the parentheses when there is only one type, but that I would need them to group multiple arguments or to label arguments.<br>&gt; <br>&gt; That said, I don’t feel strongly about it and the work of transitioning our code would be minimal. If this change provides other engineering benefits that aren’t noticeable on the surface, then I’m positive to the change for those reasons.<br>&gt; <br>&gt; - David<br></p><p>It would not affect the closure syntax. To paraphrase Chris:<br>No. Swift’s syntactic shortcuts in its closure parameter lists benefit simple functional algorithms. Few people would choose to write fully specified long-form declarations when, for example, reverse-sorting an array of integers:<br></p><p>y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>Compare the long form with this simpler form:<br></p><p>y = x.sorted { lhs, rhs in rhs &lt; lhs }<br>You can use the even shorter form of { $1 &lt; $0 }. <br></p><p>Closures offer a structurally distinct class of syntactic sugar: <br></p><p>You may elide parentheses (even with multiple arguments)<br>You may omit the return type<br>You may omit types<br>You may omit the parameter list in its entirety<br>Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/d2c11314/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 19, 2016 at 11:00:00am</p></header><div class="content"><p>I have a different read of the proposal I guess... I actually find that this:<br></p><p>(Int, Int) -&gt; (Int, Int)<br></p><p>Naturally reads take a single pair (e.g. tuple) of (Int, Int) and return a single pair of (Int, Int)<br></p><p>This actually looks and feels like the right implementation to me:<br></p><p>let tx: (Int, Int) -&gt; (Int, Int) = { ($0.1, $0.0) }<br></p><p>And I am saying that this would be explicitly wrong:<br></p><p>let tx: (Int, Int) -&gt; (Int, Int) = { ($1, $0) }<br></p><p>If I wanted a type signature of that took two Int params, I would expect to write this:<br></p><p>let tx: Int, Int -&gt; (Int, Int) = { ($1, $0) }<br></p><p>That reads, a type signature that takes two Int values and returns a single (Int, Int) pair.<br></p><p>The problem, to me at least, is that the function declaration overloads the meaning of () as &quot;start of parameter list for function declaration&quot;.<br></p><p>func tx((Int, Int)) -&gt; (Int, Int) { return ($0.1, $0.0) }<br></p><p>So now you have this mess to say the same thing: take a single pair of Int and return a pair of Int.<br></p><p>Similarly, if the () are going to required for parameter lists in function declarations, I really struggle to see why these two forms should mean the same thing:<br></p><p>y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>y = x.sorted { lhs, rhs in rhs &lt; lhs }<br></p><p>Dropping the type signatures because that can be inferred is one thing, but changing the structure of the parameter list seems like an orthogonal optimization.<br></p><p>y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>{ $1 &lt; $0 }<br></p><p>This process keeps the structural elements while dropping all of the type pieces and maintains the consistency that in function types (regardless of how they are defined), the () denotes a parameter list. If you actually want a tuple within the parameter list, you need to do `((lhs, rhs))`.<br></p><p>-David<br></p><p>&gt; On Apr 19, 2016, at 9:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 19, 2016, at 9:44 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would this also affect the syntax for naming closure arguments? For example, would this (taken from &quot;The Swift Programming Language (Swift 2.2)”):<br>&gt;&gt;   reversed = names.sort( { s1, s2 in return s1 &gt; s2 } )<br>&gt;&gt; have to be written like this:<br>&gt;&gt;   reversed = names.sort( { (s1, s2) in return s1 &gt; s2 } )<br>&gt;&gt; or is that a different syntax?<br>&gt;&gt; <br>&gt;&gt; As a developer focused on _writing_ and _reading_ code like this, I don’t see the real benefits of this change. It only feels natural to me that I would be able to omit the parentheses when there is only one type, but that I would need them to group multiple arguments or to label arguments.<br>&gt;&gt; <br>&gt;&gt; That said, I don’t feel strongly about it and the work of transitioning our code would be minimal. If this change provides other engineering benefits that aren’t noticeable on the surface, then I’m positive to the change for those reasons.<br>&gt;&gt; <br>&gt;&gt; - David<br>&gt; <br>&gt; It would not affect the closure syntax. To paraphrase Chris:<br>&gt; No. Swift’s syntactic shortcuts in its closure parameter lists benefit simple functional algorithms. Few people would choose to write fully specified long-form declarations when, for example, reverse-sorting an array of integers:<br>&gt; <br>&gt; y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>&gt; Compare the long form with this simpler form:<br>&gt; <br>&gt; y = x.sorted { lhs, rhs in rhs &lt; lhs }<br>&gt; You can use the even shorter form of { $1 &lt; $0 }. <br>&gt; <br>&gt; Closures offer a structurally distinct class of syntactic sugar: <br>&gt; <br>&gt; You may elide parentheses (even with multiple arguments)<br>&gt; You may omit the return type<br>&gt; You may omit types<br>&gt; You may omit the parameter list in its entirety<br>&gt; Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/996cf7da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 19, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 19, 2016, at 1:24 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have a different read of the proposal I guess... I actually find that this:<br>&gt; <br>&gt; (Int, Int) -&gt; (Int, Int)<br>&gt; <br>&gt; Naturally reads take a single pair (e.g. tuple) of (Int, Int) and return a single pair of (Int, Int)<br>&gt; <br>&gt; This actually looks and feels like the right implementation to me:<br>&gt; <br>&gt; let tx: (Int, Int) -&gt; (Int, Int) = { ($0.1, $0.0) }<br>&gt; <br>&gt; And I am saying that this would be explicitly wrong:<br>&gt; <br>&gt; let tx: (Int, Int) -&gt; (Int, Int) = { ($1, $0) }<br>&gt; <br>&gt; If I wanted a type signature of that took two Int params, I would expect to write this:<br>&gt; <br>&gt; let tx: Int, Int -&gt; (Int, Int) = { ($1, $0) }<br>&gt; <br>&gt; That reads, a type signature that takes two Int values and returns a single (Int, Int) pair.<br>&gt; <br>&gt; The problem, to me at least, is that the function declaration overloads the meaning of () as &quot;start of parameter list for function declaration&quot;.<br>&gt; <br>&gt; func tx((Int, Int)) -&gt; (Int, Int) { return ($0.1, $0.0) }<br>&gt; <br>&gt; So now you have this mess to say the same thing: take a single pair of Int and return a pair of Int.<br>&gt; <br>&gt; Similarly, if the () are going to required for parameter lists in function declarations, I really struggle to see why these two forms should mean the same thing:<br>&gt; <br>&gt; y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>&gt; y = x.sorted { lhs, rhs in rhs &lt; lhs }<br>&gt; <br>&gt; Dropping the type signatures because that can be inferred is one thing, but changing the structure of the parameter list seems like an orthogonal optimization.<br>&gt; <br>&gt; y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>&gt; y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>&gt; { $1 &lt; $0 }<br>&gt; <br>&gt; This process keeps the structural elements while dropping all of the type pieces and maintains the consistency that in function types (regardless of how they are defined), the () denotes a parameter list. If you actually want a tuple within the parameter list, you need to do `((lhs, rhs))`.<br></p><p>David, you make some great points about potential for confusion around tuples vs parentheses around the parameter list.  This is a great argument for only using them when we explicitly intend to specify a tuple rather than allowing them for the argument list.<br></p><p>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt;&gt; On Apr 19, 2016, at 9:24 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 19, 2016, at 9:44 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would this also affect the syntax for naming closure arguments? For example, would this (taken from &quot;The Swift Programming Language (Swift 2.2)”):<br>&gt;&gt;&gt;   reversed = names.sort( { s1, s2 in return s1 &gt; s2 } )<br>&gt;&gt;&gt; have to be written like this:<br>&gt;&gt;&gt;   reversed = names.sort( { (s1, s2) in return s1 &gt; s2 } )<br>&gt;&gt;&gt; or is that a different syntax?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a developer focused on _writing_ and _reading_ code like this, I don’t see the real benefits of this change. It only feels natural to me that I would be able to omit the parentheses when there is only one type, but that I would need them to group multiple arguments or to label arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I don’t feel strongly about it and the work of transitioning our code would be minimal. If this change provides other engineering benefits that aren’t noticeable on the surface, then I’m positive to the change for those reasons.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - David<br>&gt;&gt; <br>&gt;&gt; It would not affect the closure syntax. To paraphrase Chris:<br>&gt;&gt; No. Swift’s syntactic shortcuts in its closure parameter lists benefit simple functional algorithms. Few people would choose to write fully specified long-form declarations when, for example, reverse-sorting an array of integers:<br>&gt;&gt; <br>&gt;&gt; y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>&gt;&gt; Compare the long form with this simpler form:<br>&gt;&gt; <br>&gt;&gt; y = x.sorted { lhs, rhs in rhs &lt; lhs }<br>&gt;&gt; You can use the even shorter form of { $1 &lt; $0 }. <br>&gt;&gt; <br>&gt;&gt; Closures offer a structurally distinct class of syntactic sugar: <br>&gt;&gt; <br>&gt;&gt; You may elide parentheses (even with multiple arguments)<br>&gt;&gt; You may omit the return type<br>&gt;&gt; You may omit types<br>&gt;&gt; You may omit the parameter list in its entirety<br>&gt;&gt; Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/49595fac/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 20, 2016 at 10:00:00am</p></header><div class="content"><p>Great points! We definitely have some mess with tuples&amp;parameters list in <br>current Swift. Especially after we removed tuple splat feature.<br></p><p>But right now can&#39;t see what we can do about this.<br></p><p>(T1,T2) -&gt; (T3,T4) really reads as &quot;tuple (T1,T2) to tuple (T3,T4)&quot; and <br>this is partially true as result is really tuple (T3,T4).<br>Correct form looks like T1,T2 -&gt; (T3,T4), but this just can&#39;t be expressed <br>in current syntax of Swift - we need parens for param names, their <br>modifiers like inout/@noescape etc., don&#39;t think Swift can parse without <br>parens.<br></p><p><br></p><p>Even more. This is ok in current Swift 3:<br></p><p>let f : ((Int, Int)) -&gt; (Int, Int) = { return ($0, $1) }<br>let f2 : ((Int, Int)) -&gt; (Int, Int) = { return ($0.0, $0.1) }<br></p><p>I.e. absolutely the same functions, declared in different way. Why it <br>allows to point a tuple to $0 &amp; $1, instead of just $0.0 $0.1 ?<br></p><p><br>On 19.04.2016 21:24, David Owens II via swift-evolution wrote:<br>&gt; I have a different read of the proposal I guess... I actually find that this:<br>&gt;<br>&gt;     (Int, Int) -&gt; (Int, Int)<br>&gt;<br>&gt;<br>&gt; Naturally reads take a single pair (e.g. tuple) of (Int, Int) and return a<br>&gt; single pair of (Int, Int)<br>&gt;<br>&gt; This actually looks and feels like the right implementation to me:<br>&gt;<br>&gt;     let tx: (Int, Int) -&gt; (Int, Int) = { ($0.1, $0.0) }<br>&gt;<br>&gt;<br>&gt; And I am saying that this would be explicitly wrong:<br>&gt;<br>&gt;     let tx: (Int, Int) -&gt; (Int, Int) = { ($1, $0) }<br>&gt;<br>&gt;<br>&gt; If I wanted a type signature of that took two Int params, I would expect to<br>&gt; write this:<br>&gt;<br>&gt;     let tx: Int, Int -&gt; (Int, Int) = { ($1, $0) }<br>&gt;<br>&gt;<br>&gt; That reads, a type signature that takes two Int values and returns a single<br>&gt; (Int, Int) pair.<br>&gt;<br>&gt; The problem, to me at least, is that the function declaration overloads the<br>&gt; meaning of () as &quot;start of parameter list for function declaration&quot;.<br>&gt;<br>&gt;     func tx((Int, Int)) -&gt; (Int, Int) { return ($0.1, $0.0) }<br>&gt;<br>&gt;<br>&gt; So now you have this mess to say the same thing: take a single pair of Int<br>&gt; and return a pair of Int.<br>&gt;<br>&gt; Similarly, if the () are going to required for parameter lists in function<br>&gt; declarations, I really struggle to see why these two forms should mean the<br>&gt; same thing:<br>&gt;<br>&gt;     y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>&gt;     y = x.sorted { lhs, rhs in rhs &lt; lhs }<br>&gt;<br>&gt;<br>&gt; Dropping the type signatures because that can be inferred is one thing, but<br>&gt; changing the structure of the parameter list seems like an orthogonal<br>&gt; optimization.<br>&gt;<br>&gt;     y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }<br>&gt;     y = x.sorted { (lhs, rhs) in rhs &lt; lhs }<br>&gt;     { $1 &lt; $0 }<br>&gt;<br>&gt;<br>&gt; This process keeps the structural elements while dropping all of the type<br>&gt; pieces and maintains the consistency that in function types (regardless of<br>&gt; how they are defined), the () denotes a parameter list. If you actually<br>&gt; want a tuple within the parameter list, you need to do `((lhs, rhs))`.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;&gt; On Apr 19, 2016, at 9:24 AM, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Apr 19, 2016, at 9:44 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com<br>&gt;&gt;&gt; &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would this also affect the syntax for naming closure arguments? For<br>&gt;&gt;&gt; example, would this (taken from &quot;The Swift Programming Language (Swift<br>&gt;&gt;&gt; 2.2)”):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  1. |reversed = names.sort( { s1, s2 in return s1 &gt; s2 } )|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; have to be written like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  1. |reversed = names.sort( { (s1, s2) in return s1 &gt; s2 } )|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or is that a different syntax?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As a developer focused on _writing_ and _reading_ code like this, I<br>&gt;&gt;&gt; don’t see the real benefits of this change. It only feels natural to me<br>&gt;&gt;&gt; that I would be able to omit the parentheses when there is only one<br>&gt;&gt;&gt; type, but that I would need them to group multiple arguments or to label<br>&gt;&gt;&gt; arguments.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That said, I don’t feel strongly about it and the work of transitioning<br>&gt;&gt;&gt; our code would be minimal. If this change provides other engineering<br>&gt;&gt;&gt; benefits that aren’t noticeable on the surface, then I’m positive to the<br>&gt;&gt;&gt; change for those reasons.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - David<br>&gt;&gt;<br>&gt;&gt; It would not affect the closure syntax. To paraphrase Chris:<br>&gt;&gt;<br>&gt;&gt; No. Swift’s syntactic shortcuts in its closure parameter lists benefit<br>&gt;&gt; simple functional algorithms. Few people would choose to write fully<br>&gt;&gt; specified long-form declarations when, for example, reverse-sorting an<br>&gt;&gt; array of integers:<br>&gt;&gt;<br>&gt;&gt; |y = x.sorted { (lhs : Int, rhs : Int) -&gt; Bool in rhs &lt; lhs }|<br>&gt;&gt;<br>&gt;&gt; Compare the long form with this simpler form:<br>&gt;&gt;<br>&gt;&gt; |y = x.sorted { lhs, rhs in rhs &lt; lhs }|<br>&gt;&gt;<br>&gt;&gt; You can use the even shorter form of |{ $1 &lt; $0 }|.<br>&gt;&gt;<br>&gt;&gt; Closures offer a structurally distinct class of syntactic sugar:<br>&gt;&gt;<br>&gt;&gt;   * You may elide parentheses (even with multiple arguments)<br>&gt;&gt;   * You may omit the return type<br>&gt;&gt;   * You may omit types<br>&gt;&gt;   * You may omit the parameter list in its entirety<br>&gt;&gt;<br>&gt;&gt; Short of a complete rethink of closure syntax, requiring parentheses<br>&gt;&gt; there would not improve the language in any measurable way.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 20 Apr 2016, at 08:02, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Great points! We definitely have some mess with tuples&amp;parameters list in current Swift. Especially after we removed tuple splat feature.<br>&gt; <br>&gt; But right now can&#39;t see what we can do about this.<br>&gt; <br>&gt; (T1,T2) -&gt; (T3,T4) really reads as &quot;tuple (T1,T2) to tuple (T3,T4)”<br></p><p>To me that reads as &quot;function taking two parameters and returning a tuple”. <br></p><p>Full disclosure: until this thread started, I did not know that T1 -&gt; T2 was legal. However, except for function application, I have always though of parentheses as optional things that are there only to disambiguate syntax or override operator precedence. To me the consistent rule would be to allow T1 -&gt; T2 not to ban it.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 19 Apr 2016, at 17:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt; Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br></p><p>Does requiring the parentheses in (T1) -&gt; T2 improve the language in any measurable way?<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 5:09 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 19 Apr 2016, at 17:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br>&gt; <br>&gt; Does requiring the parentheses in (T1) -&gt; T2 improve the language in any measurable way?<br></p><p>I believe it does, as the parens are already required at call sites and in function declarations, and when using functions with more than one argument.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>April 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 20 Apr 2016, at 15:40, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 20, 2016, at 5:09 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 19 Apr 2016, at 17:24, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Short of a complete rethink of closure syntax, requiring parentheses there would not improve the language in any measurable way.<br>&gt;&gt; <br>&gt;&gt; Does requiring the parentheses in (T1) -&gt; T2 improve the language in any measurable way?<br>&gt; <br>&gt; I believe it does, as the parens are already required at call sites and in function declarations, and when using functions with more than one argument.<br></p><p>I’m sorry, but the one statement does not follow from the other. That parentheses are required at call sites and in function declarations (NB: but not in closure definitions) does not imply that the language would be measurably improved by mandating them in function type declarations of the form T1 -&gt; T2 as well.<br></p><p>In fact, it seems to me, that, generally, the language designers took the opposite point of view, namely that the language is measurably improved by allowing coders to omit syntax where the omission does not result in ambiguity. For instance, we can omit the statement terminator for the last statement on a line, type annotations for let and var identifiers where the type can be inferred, pretty much everything in a closure’s parameter and return type declaration.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>April 19, 2016 at 05:00:00pm</p></header><div class="content"><p>I’d place the ability to omit parenthesises for single args in the same category as being able to omit `self` when accessing properties. They are small conveniences that make a large difference to an entire codebase.<br></p><p>&gt; On 19 Apr 2016, at 15:49, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Apart from intuition and confusion, parentheses are used at call sites<br>&gt; and declarations. It seems out of line that they can be removed in types <br>&gt; but only in one degenerate case.<br>&gt; <br>&gt; This goes against the Swift core design goal of consistency.<br>&gt; <br>&gt; -- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/edbe8386/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Well said!<br></p><p>-Thorsten <br></p><p>&gt; Am 19.04.2016 um 18:01 schrieb Alan Skipp via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’d place the ability to omit parenthesises for single args in the same category as being able to omit `self` when accessing properties. They are small conveniences that make a large difference to an entire codebase.<br>&gt; <br>&gt;&gt; On 19 Apr 2016, at 15:49, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Apart from intuition and confusion, parentheses are used at call sites<br>&gt;&gt; and declarations. It seems out of line that they can be removed in types <br>&gt;&gt; but only in one degenerate case.<br>&gt;&gt; <br>&gt;&gt; This goes against the Swift core design goal of consistency.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/c8e0f742/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 19, 2016, at 7:49 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 18, 2016, at 4:31 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic<br>&gt;&gt;&gt;&gt; uniformity between parameter list and function types, and just<br>&gt;&gt;&gt;&gt; require parenthesis on the argument list.  The types above can be<br>&gt;&gt;&gt;&gt; trivially written as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that<br>&gt;&gt;&gt; this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people <br>&gt;&gt; <br>&gt;&gt; Do we have any data on this (in either direction)?<br>&gt;&gt; <br>&gt;&gt; Personally, it has always seemed obvious that T -&gt; U being a function<br>&gt;&gt; type would be quite novel to some people, considering the number of<br>&gt;&gt; times I&#39;ve seen in Haskell texts that (surprise!) you don&#39;t need<br>&gt;&gt; parentheses to invoke functions.  I guess those are invocations and<br>&gt;&gt; we&#39;re talking about declarations here, but declaration-follows-use is a<br>&gt;&gt; kind of principle the language tries to uphold.<br>&gt;&gt; <br>&gt;&gt; But that&#39;s just intuition.  Data would be very interesting.<br>&gt; <br>&gt; Apart from intuition and confusion, parentheses are used at call sites<br>&gt; and declarations. It seems out of line that they can be removed in types <br>&gt; but only in one degenerate case.<br>&gt; <br>&gt; This goes against the Swift core design goal of consistency.<br></p><p>For the sake of consistency, would you also support the requirement of `-&gt; Void` on functions that return nothing? There are a few different ways to declare function signatures, one of which requires the return type, the other can default one for, in the &quot;degenerate case&quot;.<br></p><p>Example:<br></p><p>typealias Callback = () -&gt; Void     // return type required<br>let f: () -&gt; Void = {}              // return type required<br></p><p>func g() {}                         // return type optional<br>func h() -&gt; Void {}                 // should this be required?<br></p><p>I think it&#39;s clear from this example, that consistency is not always the most important thing.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/e184f46b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
