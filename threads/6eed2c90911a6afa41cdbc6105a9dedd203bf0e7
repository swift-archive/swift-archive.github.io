<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>UnsafePointer and UnsafeMutablePointer both contain initializers to convert<br>from Int and Uint, but Int and UInt lack initializers to convert from<br>UnsafePointer and UnsafeMutablePointer. Over in swift-dev, Dimitri Gribenko<br>proposed adding something like the following initializers to stdlib.<br></p><p>extension UInt {<br>  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>extension Int {<br>  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>https://bugs.swift.org/browse/SR-131<br></p><p>There are two motivations behind this proposal. First, it would allow more<br>complicated pointer arithmetic, such as checking pointer alignment. Second,<br>some C functions take intptr_t and uintptr_t parameters, which are not<br>compatible with UnsafePointer.<br></p><p>As noted in UnsafePointer.swift.gyb the conversions from UInt and Int are<br>fundamentally unsafe, and these proposed conversions would also be unsafe.<br>They would also allow for more unsafe pointer arithmetic operations. For<br>example, it would allow users to convert two UnsafePointers to UInt8s in<br>order to find the distance between them, which would be a problem if the<br>user subtracted the larger pointer from the smaller pointer.<br></p><p>Because of this, and because it&#39;s part of the Swift evolution process, it&#39;s<br>worth considering alternatives. Pointer arithmetic could be taken care of<br>by adding functions to UnsafePointer, and these may be worth proposing<br>separately. I&#39;m thinking something like this.<br></p><p>func distanceToBoundary(_ boundary: Int) -&gt; Int {<br>    return Int(Builtin.ptrtoint_Word(self._rawValue)) % boundary<br>}<br></p><p>func isAlignedToBoundary(_ boundary: Int) -&gt; Bool {<br>    return distanceToBoundary(boundary) == 0<br>}<br></p><p>As for intptr_t parameters, the only alternative I can think of is to<br>require users to write adaptor functions in C. Requiring users to write C<br>code also works for pointer alignment and other pointer arithmetic, but it<br>doesn&#39;t feel like a great solution to the problem.<br></p><p>Any feedback, additional motivations, or additional alternatives welcome.<br>Thanks.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6eedf0e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Michael,<br></p><p>Thank you for working on this proposal!<br></p><p>On Tue, Dec 8, 2015 at 7:54 PM, Michael Buckley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; UnsafePointer and UnsafeMutablePointer both contain initializers to<br>&gt; convert from Int and Uint, but Int and UInt lack initializers to convert<br>&gt; from UnsafePointer and UnsafeMutablePointer. Over in swift-dev, Dimitri<br>&gt; Gribenko proposed adding something like the following initializers to<br>&gt; stdlib.<br>&gt;<br>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Int {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; https://bugs.swift.org/browse/SR-131<br>&gt;<br>&gt; There are two motivations behind this proposal. First, it would allow more<br>&gt; complicated pointer arithmetic, such as checking pointer alignment. Second,<br>&gt; some C functions take intptr_t and uintptr_t parameters, which are not<br>&gt; compatible with UnsafePointer.<br>&gt;<br>&gt; As noted in UnsafePointer.swift.gyb the conversions from UInt and Int are<br>&gt; fundamentally unsafe, and these proposed conversions would also be unsafe.<br>&gt; They would also allow for more unsafe pointer arithmetic operations. For<br>&gt; example, it would allow users to convert two UnsafePointers to UInt8s in<br>&gt; order to find the distance between them, which would be a problem if the<br>&gt; user subtracted the larger pointer from the smaller pointer.<br>&gt;<br></p><p>Another use case is tagged pointers, which there are at least two flavors<br>of: Lisp-style (low bits are the tag), or NSString-style (the pointer<br>payload contains character data).<br></p><p>We could consider adding APIs for tagged pointers, too (although I&#39;m<br>concerned that an API that exposes the operations with zero overhead would<br>be probably as unsafe as direct arithmetic and possibly more clumsy and<br>less readable).<br></p><p>A meta point is, though, that Swift, being a systems programming language,<br>should allow expressing these patterns (working with alignment, creating<br>tagged pointers), and any other things people might imagine (e.g., a XOR<br>linked list) directly in the language, without builtins.<br></p><p>Because of this, and because it&#39;s part of the Swift evolution process, it&#39;s<br>&gt; worth considering alternatives. Pointer arithmetic could be taken care of<br>&gt; by adding functions to UnsafePointer, and these may be worth proposing<br>&gt; separately. I&#39;m thinking something like this.<br>&gt;<br>&gt; func distanceToBoundary(_ boundary: Int) -&gt; Int {<br>&gt;     return Int(Builtin.ptrtoint_Word(self._rawValue)) % boundary<br>&gt; }<br>&gt;<br>&gt; func isAlignedToBoundary(_ boundary: Int) -&gt; Bool {<br>&gt;     return distanceToBoundary(boundary) == 0<br>&gt; }<br>&gt;<br></p><p>Then one would also need two other methods, I think: to align the pointer<br>to the nearest boundary, up and down.<br></p><p>As for intptr_t parameters, the only alternative I can think of is to<br>&gt; require users to write adaptor functions in C. Requiring users to write C<br>&gt; code also works for pointer alignment and other pointer arithmetic, but it<br>&gt; doesn&#39;t feel like a great solution to the problem.<br>&gt;<br></p><p>Even writing wrappers for intptr_t doesn&#39;t feel great.  One of the goals is<br>to be able to wrap C libraries and improve their API by augmenting with<br>Swift code to the extent possible (for multiple reasons).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f06d325a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; <br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br></p><p>I was helping someone in my NSCoder Night group struggle with UnsafePointer just last night. He was working with MIDIMetaEvent, a C struct with a variable-sized buffer at the end of it. There was just no good way to handle the allocation and use of this type; I ended up writing an extension full of bizarre magic just so he could access and use it..<br></p><p>Anyway, all this is to say I would have used these initializers if they’d existed, and the alignment stuff you’re suggesting probably wouldn’t have cut the mustard for some of what I was trying to do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 12:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; extension UInt {<br>&gt;&gt;  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;&gt;    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;&gt;    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt; <br>&gt; I was helping someone in my NSCoder Night group struggle with UnsafePointer just last night. He was working with MIDIMetaEvent, a C struct with a variable-sized buffer at the end of it. There was just no good way to handle the allocation and use of this type; I ended up writing an extension full of bizarre magic just so he could access and use it..<br>&gt; <br>&gt; Anyway, all this is to say I would have used these initializers if they’d existed, and the alignment stuff you’re suggesting probably wouldn’t have cut the mustard for some of what I was trying to do.<br></p><p>On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br></p><p>The buffer I’m accessing is UInt8, which I believe is always aligned, right?<br></p><p>C:<br></p><p>	typedef struct MIDIMetaEvent<br>	{<br>		UInt8		metaEventType;<br>		UInt8		unused1;<br>		UInt8		unused2;<br>		UInt8		unused3;<br>		UInt32		dataLength;<br>		UInt8		data[1];<br>	} MIDIMetaEvent;<br></p><p>Swift:<br></p><p>	public struct MIDIMetaEvent {<br>	    <br>	    public var metaEventType: UInt8<br>	    public var unused1: UInt8<br>	    public var unused2: UInt8<br>	    public var unused3: UInt8<br>	    public var dataLength: UInt32<br>	    public var data: (UInt8)<br>	    public init()<br>	    public init(metaEventType: UInt8, unused1: UInt8, unused2: UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>	}<br></p><p>For obvious reasons, Swift doesn’t understand the actual size of this data structure and only copies the amount of data it knows about. (It also has to be allocated with malloc(), because UnsafePointer.alloc() takes a number of objects, not a number of bytes. He was apparently in contact with someone at Apple about this MIDI stuff, and the “the guy on my team who knows Swift” *didn’t* know this.) We had to always access it through an UnsafePointer, and construct an UnsafeBufferPointer from &amp;data and dataLength. That all actually worked pretty straightforwardly, but then I started playing with the idea of a general purpose type to manage this kind of pointer, and it was at that point that I started doing ugly pointer arithmetic (to try to access the variable-length buffer at he end of the type).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br>&gt;<br>&gt; The buffer I’m accessing is UInt8, which I believe is always aligned, right?<br>&gt;<br>&gt; C:<br>&gt;<br>&gt;         typedef struct MIDIMetaEvent<br>&gt;         {<br>&gt;                 UInt8           metaEventType;<br>&gt;                 UInt8           unused1;<br>&gt;                 UInt8           unused2;<br>&gt;                 UInt8           unused3;<br>&gt;                 UInt32          dataLength;<br>&gt;                 UInt8           data[1];<br>&gt;         } MIDIMetaEvent;<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt;         public struct MIDIMetaEvent {<br>&gt;<br>&gt;             public var metaEventType: UInt8<br>&gt;             public var unused1: UInt8<br>&gt;             public var unused2: UInt8<br>&gt;             public var unused3: UInt8<br>&gt;             public var dataLength: UInt32<br>&gt;             public var data: (UInt8)<br>&gt;             public init()<br>&gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2: UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt;         }<br></p><p>FWIW, this problem looks very much like one for which we did the<br>CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks Dimitri, Brent, and Joe for the feedback. Your additional comments<br>on the motivation were very helpful, Dimitri. If I&#39;m not mistaken, there<br>has been no negative feedback expressed towards the proposal, nor have<br>there been any other alternatives proposed. I believe the next step in the<br>Swift evolution process is to draft a proposal in the swift-evolution<br>format and circulate it on this mailing list for refinement. So, without<br>further ado,<br></p><p>Introduction<br></p><p>Just as users can create Unsafe[Mutable]Pointers from Ints and UInts, they<br>should be able to create Ints and UInts from Unsafe[Mutable]Pointers. This<br>will allow users to call C functions with intptr_t and uintptr_t<br>parameters, and will allow users to perform more advanced pointer<br>arithmetic than is allowed by UnsafePointers.<br></p><p>Motivation<br></p><p>Swift currently lacks the ability to perform many complex operations on<br>pointers, such as checking pointer alignment, tagging pointers, or XORing<br>pointers (for working with XOR linked lists, for example). As a systems<br>programming language, Swift ought to be able to solve these problems<br>natively and concisely.<br></p><p>Additionally, since some C functions take intptr_t and uintptr_t<br>parameters, Swift currently has no ability to call these functions<br>directly. Users must wrap calls to these functions in C code.<br></p><p>Proposed solution<br></p><p>Initializers will be added to Int and UInt to convert from UnsafePointer<br>and UnsafeMutablePointer.<br></p><p>Currently, the only workaround which can solve these problems is to write<br>any code that requires pointer arithmetic in C. Writing this code in Swift<br>will be no safer than it is in C, as this is a fundamentally unsafe<br>operation. However, it will be cleaner in that users will not be forced to<br>write C code.<br></p><p>Detailed design<br></p><p>The initializers will be implemented using the built-in ptrtoint_Word<br>function.<br></p><p>extension UInt {<br>  init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>extension Int {<br>  init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>As an example, these initializers will allow the user to get the next<br>address of an XOR linked list in Swift.<br></p><p>struct XORLinkedList&lt;T&gt; {<br>  let address: UnsafePointer&lt;T&gt;<br></p><p>  ...<br></p><p>  func successor(_ predecessor: XORLinkedList&lt;T&gt;) -&gt; XORLinkedList&lt;T&gt; {<br>    return XorLinkedList(UnsafePointer&lt;T&gt;(UInt(address) ^<br>UInt(predecessor.address)))<br>  }<br>}<br></p><p>Impact on existing code<br></p><p>There is no impact on existing code.<br></p><p>Alternatives considered<br></p><p>Three alternatives were considered.<br></p><p>The first alternative was to add an intValue function to<br>Unsafe[Mutable]Pointer. This alternative was rejected because it is<br>preferred that type conversions be implemented as initializers where<br>possible.<br></p><p>The next alternative was to add functions to Unsafe[Mutable]Pointer which<br>covered the identified pointer arithmetic cases. This alternative was<br>rejected because it either would have required us to imagine every use-case<br>of pointer arithmetic and write functions for them, which is an impossible<br>task, or it would have required adding a full suite of arithmetic and<br>bitwise operators to Unsafe[Mutable]Pointer. Because some of these<br>operations are defined only on signed integers, and others on unsigned, it<br>would have required splitting Unsafe[Mutable]Pointer into signed and<br>unsigned variants, which would have complicated things for users who did<br>not need to do pointer arithmetic. Additionally, the implementations of<br>these operations would have probably converted the pointers to integers,<br>perform a single operation, and then convert them back. When chaining<br>operations, this would create a lot of unnecessary conversions.<br></p><p>The last alternative was to forgo these initializers and force users to<br>write all their complicated pointer code in C. This alternative was<br>rejected because it makes Swift less useful as a systems programming<br>language.<br></p><p>On Wed, Dec 9, 2015 at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; On the off chance you&#39;re trying to do loads from unaligned<br>&gt; UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to<br>&gt; memcpy to well-aligned memory first.<br>&gt; &gt;<br>&gt; &gt; The buffer I’m accessing is UInt8, which I believe is always aligned,<br>&gt; right?<br>&gt; &gt;<br>&gt; &gt; C:<br>&gt; &gt;<br>&gt; &gt;         typedef struct MIDIMetaEvent<br>&gt; &gt;         {<br>&gt; &gt;                 UInt8           metaEventType;<br>&gt; &gt;                 UInt8           unused1;<br>&gt; &gt;                 UInt8           unused2;<br>&gt; &gt;                 UInt8           unused3;<br>&gt; &gt;                 UInt32          dataLength;<br>&gt; &gt;                 UInt8           data[1];<br>&gt; &gt;         } MIDIMetaEvent;<br>&gt; &gt;<br>&gt; &gt; Swift:<br>&gt; &gt;<br>&gt; &gt;         public struct MIDIMetaEvent {<br>&gt; &gt;<br>&gt; &gt;             public var metaEventType: UInt8<br>&gt; &gt;             public var unused1: UInt8<br>&gt; &gt;             public var unused2: UInt8<br>&gt; &gt;             public var unused3: UInt8<br>&gt; &gt;             public var dataLength: UInt32<br>&gt; &gt;             public var data: (UInt8)<br>&gt; &gt;             public init()<br>&gt; &gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2:<br>&gt; UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt; &gt;         }<br>&gt;<br>&gt; FWIW, this problem looks very much like one for which we did the<br>&gt; CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/cd7dc78a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks Michael!  This looks good, please submit a pull request to<br>swift-evolution.<br></p><p>Dmitri<br></p><p>On Thu, Dec 10, 2015 at 9:04 PM, Michael Buckley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks Dimitri, Brent, and Joe for the feedback. Your additional comments<br>&gt; on the motivation were very helpful, Dimitri. If I&#39;m not mistaken, there<br>&gt; has been no negative feedback expressed towards the proposal, nor have<br>&gt; there been any other alternatives proposed. I believe the next step in the<br>&gt; Swift evolution process is to draft a proposal in the swift-evolution<br>&gt; format and circulate it on this mailing list for refinement. So, without<br>&gt; further ado,<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Just as users can create Unsafe[Mutable]Pointers from Ints and UInts, they<br>&gt; should be able to create Ints and UInts from Unsafe[Mutable]Pointers. This<br>&gt; will allow users to call C functions with intptr_t and uintptr_t<br>&gt; parameters, and will allow users to perform more advanced pointer<br>&gt; arithmetic than is allowed by UnsafePointers.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift currently lacks the ability to perform many complex operations on<br>&gt; pointers, such as checking pointer alignment, tagging pointers, or XORing<br>&gt; pointers (for working with XOR linked lists, for example). As a systems<br>&gt; programming language, Swift ought to be able to solve these problems<br>&gt; natively and concisely.<br>&gt;<br>&gt; Additionally, since some C functions take intptr_t and uintptr_t<br>&gt; parameters, Swift currently has no ability to call these functions<br>&gt; directly. Users must wrap calls to these functions in C code.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Initializers will be added to Int and UInt to convert from UnsafePointer<br>&gt; and UnsafeMutablePointer.<br>&gt;<br>&gt; Currently, the only workaround which can solve these problems is to write<br>&gt; any code that requires pointer arithmetic in C. Writing this code in Swift<br>&gt; will be no safer than it is in C, as this is a fundamentally unsafe<br>&gt; operation. However, it will be cleaner in that users will not be forced to<br>&gt; write C code.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; The initializers will be implemented using the built-in ptrtoint_Word<br>&gt; function.<br>&gt;<br>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Int {<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; As an example, these initializers will allow the user to get the next<br>&gt; address of an XOR linked list in Swift.<br>&gt;<br>&gt; struct XORLinkedList&lt;T&gt; {<br>&gt;   let address: UnsafePointer&lt;T&gt;<br>&gt;<br>&gt;   ...<br>&gt;<br>&gt;   func successor(_ predecessor: XORLinkedList&lt;T&gt;) -&gt; XORLinkedList&lt;T&gt; {<br>&gt;     return XorLinkedList(UnsafePointer&lt;T&gt;(UInt(address) ^<br>&gt; UInt(predecessor.address)))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; There is no impact on existing code.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Three alternatives were considered.<br>&gt;<br>&gt; The first alternative was to add an intValue function to<br>&gt; Unsafe[Mutable]Pointer. This alternative was rejected because it is<br>&gt; preferred that type conversions be implemented as initializers where<br>&gt; possible.<br>&gt;<br>&gt; The next alternative was to add functions to Unsafe[Mutable]Pointer which<br>&gt; covered the identified pointer arithmetic cases. This alternative was<br>&gt; rejected because it either would have required us to imagine every use-case<br>&gt; of pointer arithmetic and write functions for them, which is an impossible<br>&gt; task, or it would have required adding a full suite of arithmetic and<br>&gt; bitwise operators to Unsafe[Mutable]Pointer. Because some of these<br>&gt; operations are defined only on signed integers, and others on unsigned, it<br>&gt; would have required splitting Unsafe[Mutable]Pointer into signed and<br>&gt; unsigned variants, which would have complicated things for users who did<br>&gt; not need to do pointer arithmetic. Additionally, the implementations of<br>&gt; these operations would have probably converted the pointers to integers,<br>&gt; perform a single operation, and then convert them back. When chaining<br>&gt; operations, this would create a lot of unnecessary conversions.<br>&gt;<br>&gt; The last alternative was to forgo these initializers and force users to<br>&gt; write all their complicated pointer code in C. This alternative was<br>&gt; rejected because it makes Swift less useful as a systems programming<br>&gt; language.<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; On the off chance you&#39;re trying to do loads from unaligned<br>&gt;&gt; UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to<br>&gt;&gt; memcpy to well-aligned memory first.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The buffer I’m accessing is UInt8, which I believe is always aligned,<br>&gt;&gt; right?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; C:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         typedef struct MIDIMetaEvent<br>&gt;&gt; &gt;         {<br>&gt;&gt; &gt;                 UInt8           metaEventType;<br>&gt;&gt; &gt;                 UInt8           unused1;<br>&gt;&gt; &gt;                 UInt8           unused2;<br>&gt;&gt; &gt;                 UInt8           unused3;<br>&gt;&gt; &gt;                 UInt32          dataLength;<br>&gt;&gt; &gt;                 UInt8           data[1];<br>&gt;&gt; &gt;         } MIDIMetaEvent;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         public struct MIDIMetaEvent {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;             public var metaEventType: UInt8<br>&gt;&gt; &gt;             public var unused1: UInt8<br>&gt;&gt; &gt;             public var unused2: UInt8<br>&gt;&gt; &gt;             public var unused3: UInt8<br>&gt;&gt; &gt;             public var dataLength: UInt32<br>&gt;&gt; &gt;             public var data: (UInt8)<br>&gt;&gt; &gt;             public init()<br>&gt;&gt; &gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2:<br>&gt;&gt; UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt;&gt; &gt;         }<br>&gt;&gt;<br>&gt;&gt; FWIW, this problem looks very much like one for which we did the<br>&gt;&gt; CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/afdcfec7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
