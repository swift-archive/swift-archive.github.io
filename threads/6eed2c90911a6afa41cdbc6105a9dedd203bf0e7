<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December  8, 2015 at 07:00:00pm</p></header><div class="content"><p>UnsafePointer and UnsafeMutablePointer both contain initializers to convert<br>from Int and Uint, but Int and UInt lack initializers to convert from<br>UnsafePointer and UnsafeMutablePointer. Over in swift-dev, Dimitri Gribenko<br>proposed adding something like the following initializers to stdlib.<br></p><p>extension UInt {<br>  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>extension Int {<br>  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>https://bugs.swift.org/browse/SR-131<br></p><p>There are two motivations behind this proposal. First, it would allow more<br>complicated pointer arithmetic, such as checking pointer alignment. Second,<br>some C functions take intptr_t and uintptr_t parameters, which are not<br>compatible with UnsafePointer.<br></p><p>As noted in UnsafePointer.swift.gyb the conversions from UInt and Int are<br>fundamentally unsafe, and these proposed conversions would also be unsafe.<br>They would also allow for more unsafe pointer arithmetic operations. For<br>example, it would allow users to convert two UnsafePointers to UInt8s in<br>order to find the distance between them, which would be a problem if the<br>user subtracted the larger pointer from the smaller pointer.<br></p><p>Because of this, and because it&#39;s part of the Swift evolution process, it&#39;s<br>worth considering alternatives. Pointer arithmetic could be taken care of<br>by adding functions to UnsafePointer, and these may be worth proposing<br>separately. I&#39;m thinking something like this.<br></p><p>func distanceToBoundary(_ boundary: Int) -&gt; Int {<br>    return Int(Builtin.ptrtoint_Word(self._rawValue)) % boundary<br>}<br></p><p>func isAlignedToBoundary(_ boundary: Int) -&gt; Bool {<br>    return distanceToBoundary(boundary) == 0<br>}<br></p><p>As for intptr_t parameters, the only alternative I can think of is to<br>require users to write adaptor functions in C. Requiring users to write C<br>code also works for pointer alignment and other pointer arithmetic, but it<br>doesn&#39;t feel like a great solution to the problem.<br></p><p>Any feedback, additional motivations, or additional alternatives welcome.<br>Thanks.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6eedf0e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Michael,<br></p><p>Thank you for working on this proposal!<br></p><p>On Tue, Dec 8, 2015 at 7:54 PM, Michael Buckley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; UnsafePointer and UnsafeMutablePointer both contain initializers to<br>&gt; convert from Int and Uint, but Int and UInt lack initializers to convert<br>&gt; from UnsafePointer and UnsafeMutablePointer. Over in swift-dev, Dimitri<br>&gt; Gribenko proposed adding something like the following initializers to<br>&gt; stdlib.<br>&gt;<br>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Int {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; https://bugs.swift.org/browse/SR-131<br>&gt;<br>&gt; There are two motivations behind this proposal. First, it would allow more<br>&gt; complicated pointer arithmetic, such as checking pointer alignment. Second,<br>&gt; some C functions take intptr_t and uintptr_t parameters, which are not<br>&gt; compatible with UnsafePointer.<br>&gt;<br>&gt; As noted in UnsafePointer.swift.gyb the conversions from UInt and Int are<br>&gt; fundamentally unsafe, and these proposed conversions would also be unsafe.<br>&gt; They would also allow for more unsafe pointer arithmetic operations. For<br>&gt; example, it would allow users to convert two UnsafePointers to UInt8s in<br>&gt; order to find the distance between them, which would be a problem if the<br>&gt; user subtracted the larger pointer from the smaller pointer.<br>&gt;<br></p><p>Another use case is tagged pointers, which there are at least two flavors<br>of: Lisp-style (low bits are the tag), or NSString-style (the pointer<br>payload contains character data).<br></p><p>We could consider adding APIs for tagged pointers, too (although I&#39;m<br>concerned that an API that exposes the operations with zero overhead would<br>be probably as unsafe as direct arithmetic and possibly more clumsy and<br>less readable).<br></p><p>A meta point is, though, that Swift, being a systems programming language,<br>should allow expressing these patterns (working with alignment, creating<br>tagged pointers), and any other things people might imagine (e.g., a XOR<br>linked list) directly in the language, without builtins.<br></p><p>Because of this, and because it&#39;s part of the Swift evolution process, it&#39;s<br>&gt; worth considering alternatives. Pointer arithmetic could be taken care of<br>&gt; by adding functions to UnsafePointer, and these may be worth proposing<br>&gt; separately. I&#39;m thinking something like this.<br>&gt;<br>&gt; func distanceToBoundary(_ boundary: Int) -&gt; Int {<br>&gt;     return Int(Builtin.ptrtoint_Word(self._rawValue)) % boundary<br>&gt; }<br>&gt;<br>&gt; func isAlignedToBoundary(_ boundary: Int) -&gt; Bool {<br>&gt;     return distanceToBoundary(boundary) == 0<br>&gt; }<br>&gt;<br></p><p>Then one would also need two other methods, I think: to align the pointer<br>to the nearest boundary, up and down.<br></p><p>As for intptr_t parameters, the only alternative I can think of is to<br>&gt; require users to write adaptor functions in C. Requiring users to write C<br>&gt; code also works for pointer alignment and other pointer arithmetic, but it<br>&gt; doesn&#39;t feel like a great solution to the problem.<br>&gt;<br></p><p>Even writing wrappers for intptr_t doesn&#39;t feel great.  One of the goals is<br>to be able to wrap C libraries and improve their API by augmenting with<br>Swift code to the extent possible (for multiple reasons).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/f06d325a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; <br>&gt;   init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br></p><p>I was helping someone in my NSCoder Night group struggle with UnsafePointer just last night. He was working with MIDIMetaEvent, a C struct with a variable-sized buffer at the end of it. There was just no good way to handle the allocation and use of this type; I ended up writing an extension full of bizarre magic just so he could access and use it..<br></p><p>Anyway, all this is to say I would have used these initializers if theyâd existed, and the alignment stuff youâre suggesting probably wouldnât have cut the mustard for some of what I was trying to do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 12:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; extension UInt {<br>&gt;&gt;  init&lt;T&gt;(bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;&gt;    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  init&lt;T&gt;(bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;&gt;    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt; <br>&gt; I was helping someone in my NSCoder Night group struggle with UnsafePointer just last night. He was working with MIDIMetaEvent, a C struct with a variable-sized buffer at the end of it. There was just no good way to handle the allocation and use of this type; I ended up writing an extension full of bizarre magic just so he could access and use it..<br>&gt; <br>&gt; Anyway, all this is to say I would have used these initializers if theyâd existed, and the alignment stuff youâre suggesting probably wouldnât have cut the mustard for some of what I was trying to do.<br></p><p>On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br></p><p>The buffer Iâm accessing is UInt8, which I believe is always aligned, right?<br></p><p>C:<br></p><p>	typedef struct MIDIMetaEvent<br>	{<br>		UInt8		metaEventType;<br>		UInt8		unused1;<br>		UInt8		unused2;<br>		UInt8		unused3;<br>		UInt32		dataLength;<br>		UInt8		data[1];<br>	} MIDIMetaEvent;<br></p><p>Swift:<br></p><p>	public struct MIDIMetaEvent {<br>	    <br>	    public var metaEventType: UInt8<br>	    public var unused1: UInt8<br>	    public var unused2: UInt8<br>	    public var unused3: UInt8<br>	    public var dataLength: UInt32<br>	    public var data: (UInt8)<br>	    public init()<br>	    public init(metaEventType: UInt8, unused1: UInt8, unused2: UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>	}<br></p><p>For obvious reasons, Swift doesnât understand the actual size of this data structure and only copies the amount of data it knows about. (It also has to be allocated with malloc(), because UnsafePointer.alloc() takes a number of objects, not a number of bytes. He was apparently in contact with someone at Apple about this MIDI stuff, and the âthe guy on my team who knows Swiftâ *didnât* know this.) We had to always access it through an UnsafePointer, and construct an UnsafeBufferPointer from &amp;data and dataLength. That all actually worked pretty straightforwardly, but then I started playing with the idea of a general purpose type to manage this kind of pointer, and it was at that point that I started doing ugly pointer arithmetic (to try to access the variable-length buffer at he end of the type).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On the off chance you&#39;re trying to do loads from unaligned UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to memcpy to well-aligned memory first.<br>&gt;<br>&gt; The buffer Iâm accessing is UInt8, which I believe is always aligned, right?<br>&gt;<br>&gt; C:<br>&gt;<br>&gt;         typedef struct MIDIMetaEvent<br>&gt;         {<br>&gt;                 UInt8           metaEventType;<br>&gt;                 UInt8           unused1;<br>&gt;                 UInt8           unused2;<br>&gt;                 UInt8           unused3;<br>&gt;                 UInt32          dataLength;<br>&gt;                 UInt8           data[1];<br>&gt;         } MIDIMetaEvent;<br>&gt;<br>&gt; Swift:<br>&gt;<br>&gt;         public struct MIDIMetaEvent {<br>&gt;<br>&gt;             public var metaEventType: UInt8<br>&gt;             public var unused1: UInt8<br>&gt;             public var unused2: UInt8<br>&gt;             public var unused3: UInt8<br>&gt;             public var dataLength: UInt32<br>&gt;             public var data: (UInt8)<br>&gt;             public init()<br>&gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2: UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt;         }<br></p><p>FWIW, this problem looks very much like one for which we did the<br>CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks Dimitri, Brent, and Joe for the feedback. Your additional comments<br>on the motivation were very helpful, Dimitri. If I&#39;m not mistaken, there<br>has been no negative feedback expressed towards the proposal, nor have<br>there been any other alternatives proposed. I believe the next step in the<br>Swift evolution process is to draft a proposal in the swift-evolution<br>format and circulate it on this mailing list for refinement. So, without<br>further ado,<br></p><p>Introduction<br></p><p>Just as users can create Unsafe[Mutable]Pointers from Ints and UInts, they<br>should be able to create Ints and UInts from Unsafe[Mutable]Pointers. This<br>will allow users to call C functions with intptr_t and uintptr_t<br>parameters, and will allow users to perform more advanced pointer<br>arithmetic than is allowed by UnsafePointers.<br></p><p>Motivation<br></p><p>Swift currently lacks the ability to perform many complex operations on<br>pointers, such as checking pointer alignment, tagging pointers, or XORing<br>pointers (for working with XOR linked lists, for example). As a systems<br>programming language, Swift ought to be able to solve these problems<br>natively and concisely.<br></p><p>Additionally, since some C functions take intptr_t and uintptr_t<br>parameters, Swift currently has no ability to call these functions<br>directly. Users must wrap calls to these functions in C code.<br></p><p>Proposed solution<br></p><p>Initializers will be added to Int and UInt to convert from UnsafePointer<br>and UnsafeMutablePointer.<br></p><p>Currently, the only workaround which can solve these problems is to write<br>any code that requires pointer arithmetic in C. Writing this code in Swift<br>will be no safer than it is in C, as this is a fundamentally unsafe<br>operation. However, it will be cleaner in that users will not be forced to<br>write C code.<br></p><p>Detailed design<br></p><p>The initializers will be implemented using the built-in ptrtoint_Word<br>function.<br></p><p>extension UInt {<br>  init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>extension Int {<br>  init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br></p><p>  init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>    self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>  }<br>}<br></p><p>As an example, these initializers will allow the user to get the next<br>address of an XOR linked list in Swift.<br></p><p>struct XORLinkedList&lt;T&gt; {<br>  let address: UnsafePointer&lt;T&gt;<br></p><p>  ...<br></p><p>  func successor(_ predecessor: XORLinkedList&lt;T&gt;) -&gt; XORLinkedList&lt;T&gt; {<br>    return XorLinkedList(UnsafePointer&lt;T&gt;(UInt(address) ^<br>UInt(predecessor.address)))<br>  }<br>}<br></p><p>Impact on existing code<br></p><p>There is no impact on existing code.<br></p><p>Alternatives considered<br></p><p>Three alternatives were considered.<br></p><p>The first alternative was to add an intValue function to<br>Unsafe[Mutable]Pointer. This alternative was rejected because it is<br>preferred that type conversions be implemented as initializers where<br>possible.<br></p><p>The next alternative was to add functions to Unsafe[Mutable]Pointer which<br>covered the identified pointer arithmetic cases. This alternative was<br>rejected because it either would have required us to imagine every use-case<br>of pointer arithmetic and write functions for them, which is an impossible<br>task, or it would have required adding a full suite of arithmetic and<br>bitwise operators to Unsafe[Mutable]Pointer. Because some of these<br>operations are defined only on signed integers, and others on unsigned, it<br>would have required splitting Unsafe[Mutable]Pointer into signed and<br>unsigned variants, which would have complicated things for users who did<br>not need to do pointer arithmetic. Additionally, the implementations of<br>these operations would have probably converted the pointers to integers,<br>perform a single operation, and then convert them back. When chaining<br>operations, this would create a lot of unnecessary conversions.<br></p><p>The last alternative was to forgo these initializers and force users to<br>write all their complicated pointer code in C. This alternative was<br>rejected because it makes Swift less useful as a systems programming<br>language.<br></p><p>On Wed, Dec 9, 2015 at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; On the off chance you&#39;re trying to do loads from unaligned<br>&gt; UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to<br>&gt; memcpy to well-aligned memory first.<br>&gt; &gt;<br>&gt; &gt; The buffer Iâm accessing is UInt8, which I believe is always aligned,<br>&gt; right?<br>&gt; &gt;<br>&gt; &gt; C:<br>&gt; &gt;<br>&gt; &gt;         typedef struct MIDIMetaEvent<br>&gt; &gt;         {<br>&gt; &gt;                 UInt8           metaEventType;<br>&gt; &gt;                 UInt8           unused1;<br>&gt; &gt;                 UInt8           unused2;<br>&gt; &gt;                 UInt8           unused3;<br>&gt; &gt;                 UInt32          dataLength;<br>&gt; &gt;                 UInt8           data[1];<br>&gt; &gt;         } MIDIMetaEvent;<br>&gt; &gt;<br>&gt; &gt; Swift:<br>&gt; &gt;<br>&gt; &gt;         public struct MIDIMetaEvent {<br>&gt; &gt;<br>&gt; &gt;             public var metaEventType: UInt8<br>&gt; &gt;             public var unused1: UInt8<br>&gt; &gt;             public var unused2: UInt8<br>&gt; &gt;             public var unused3: UInt8<br>&gt; &gt;             public var dataLength: UInt32<br>&gt; &gt;             public var data: (UInt8)<br>&gt; &gt;             public init()<br>&gt; &gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2:<br>&gt; UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt; &gt;         }<br>&gt;<br>&gt; FWIW, this problem looks very much like one for which we did the<br>&gt; CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/cd7dc78a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Proposal: Add Initializers For Converting UnsafePointers to Int and Unit</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks Michael!  This looks good, please submit a pull request to<br>swift-evolution.<br></p><p>Dmitri<br></p><p>On Thu, Dec 10, 2015 at 9:04 PM, Michael Buckley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks Dimitri, Brent, and Joe for the feedback. Your additional comments<br>&gt; on the motivation were very helpful, Dimitri. If I&#39;m not mistaken, there<br>&gt; has been no negative feedback expressed towards the proposal, nor have<br>&gt; there been any other alternatives proposed. I believe the next step in the<br>&gt; Swift evolution process is to draft a proposal in the swift-evolution<br>&gt; format and circulate it on this mailing list for refinement. So, without<br>&gt; further ado,<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Just as users can create Unsafe[Mutable]Pointers from Ints and UInts, they<br>&gt; should be able to create Ints and UInts from Unsafe[Mutable]Pointers. This<br>&gt; will allow users to call C functions with intptr_t and uintptr_t<br>&gt; parameters, and will allow users to perform more advanced pointer<br>&gt; arithmetic than is allowed by UnsafePointers.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Swift currently lacks the ability to perform many complex operations on<br>&gt; pointers, such as checking pointer alignment, tagging pointers, or XORing<br>&gt; pointers (for working with XOR linked lists, for example). As a systems<br>&gt; programming language, Swift ought to be able to solve these problems<br>&gt; natively and concisely.<br>&gt;<br>&gt; Additionally, since some C functions take intptr_t and uintptr_t<br>&gt; parameters, Swift currently has no ability to call these functions<br>&gt; directly. Users must wrap calls to these functions in C code.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; Initializers will be added to Int and UInt to convert from UnsafePointer<br>&gt; and UnsafeMutablePointer.<br>&gt;<br>&gt; Currently, the only workaround which can solve these problems is to write<br>&gt; any code that requires pointer arithmetic in C. Writing this code in Swift<br>&gt; will be no safer than it is in C, as this is a fundamentally unsafe<br>&gt; operation. However, it will be cleaner in that users will not be forced to<br>&gt; write C code.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; The initializers will be implemented using the built-in ptrtoint_Word<br>&gt; function.<br>&gt;<br>&gt; extension UInt {<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = UInt(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension Int {<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt;<br>&gt;   init&lt;T&gt;(_ bitPattern: UnsafeMutablePointer&lt;T&gt;) {<br>&gt;     self = Int(Builtin.ptrtoint_Word(bitPattern._rawValue))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; As an example, these initializers will allow the user to get the next<br>&gt; address of an XOR linked list in Swift.<br>&gt;<br>&gt; struct XORLinkedList&lt;T&gt; {<br>&gt;   let address: UnsafePointer&lt;T&gt;<br>&gt;<br>&gt;   ...<br>&gt;<br>&gt;   func successor(_ predecessor: XORLinkedList&lt;T&gt;) -&gt; XORLinkedList&lt;T&gt; {<br>&gt;     return XorLinkedList(UnsafePointer&lt;T&gt;(UInt(address) ^<br>&gt; UInt(predecessor.address)))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; There is no impact on existing code.<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; Three alternatives were considered.<br>&gt;<br>&gt; The first alternative was to add an intValue function to<br>&gt; Unsafe[Mutable]Pointer. This alternative was rejected because it is<br>&gt; preferred that type conversions be implemented as initializers where<br>&gt; possible.<br>&gt;<br>&gt; The next alternative was to add functions to Unsafe[Mutable]Pointer which<br>&gt; covered the identified pointer arithmetic cases. This alternative was<br>&gt; rejected because it either would have required us to imagine every use-case<br>&gt; of pointer arithmetic and write functions for them, which is an impossible<br>&gt; task, or it would have required adding a full suite of arithmetic and<br>&gt; bitwise operators to Unsafe[Mutable]Pointer. Because some of these<br>&gt; operations are defined only on signed integers, and others on unsigned, it<br>&gt; would have required splitting Unsafe[Mutable]Pointer into signed and<br>&gt; unsigned variants, which would have complicated things for users who did<br>&gt; not need to do pointer arithmetic. Additionally, the implementations of<br>&gt; these operations would have probably converted the pointers to integers,<br>&gt; perform a single operation, and then convert them back. When chaining<br>&gt; operations, this would create a lot of unnecessary conversions.<br>&gt;<br>&gt; The last alternative was to forgo these initializers and force users to<br>&gt; write all their complicated pointer code in C. This alternative was<br>&gt; rejected because it makes Swift less useful as a systems programming<br>&gt; language.<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 1:55 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Wed, Dec 9, 2015 at 1:15 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; On the off chance you&#39;re trying to do loads from unaligned<br>&gt;&gt; UnsafePointers, that&#39;s undefined in the current interface. You&#39;ll need to<br>&gt;&gt; memcpy to well-aligned memory first.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The buffer Iâm accessing is UInt8, which I believe is always aligned,<br>&gt;&gt; right?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; C:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         typedef struct MIDIMetaEvent<br>&gt;&gt; &gt;         {<br>&gt;&gt; &gt;                 UInt8           metaEventType;<br>&gt;&gt; &gt;                 UInt8           unused1;<br>&gt;&gt; &gt;                 UInt8           unused2;<br>&gt;&gt; &gt;                 UInt8           unused3;<br>&gt;&gt; &gt;                 UInt32          dataLength;<br>&gt;&gt; &gt;                 UInt8           data[1];<br>&gt;&gt; &gt;         } MIDIMetaEvent;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Swift:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;         public struct MIDIMetaEvent {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;             public var metaEventType: UInt8<br>&gt;&gt; &gt;             public var unused1: UInt8<br>&gt;&gt; &gt;             public var unused2: UInt8<br>&gt;&gt; &gt;             public var unused3: UInt8<br>&gt;&gt; &gt;             public var dataLength: UInt32<br>&gt;&gt; &gt;             public var data: (UInt8)<br>&gt;&gt; &gt;             public init()<br>&gt;&gt; &gt;             public init(metaEventType: UInt8, unused1: UInt8, unused2:<br>&gt;&gt; UInt8, unused3: UInt8, dataLength: UInt32, data: (UInt8))<br>&gt;&gt; &gt;         }<br>&gt;&gt;<br>&gt;&gt; FWIW, this problem looks very much like one for which we did the<br>&gt;&gt; CoreAudio overlay: stdlib/public/SDK/CoreAudio/CoreAudio.swift<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/afdcfec7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
