<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br></p><p>This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br></p><p>The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br></p><p>The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br></p><p>The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br></p><p>David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>I&#39;d like to add that this would only apply to super invocation of non-final methods. Final methods always terminate with a static function reference, so the existing curry thunk mechanisms will continue to work with those until we remove them.<br></p><p>David<br></p><p>&gt; On Dec 7, 2015, at 1:51 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br>&gt; <br>&gt; This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br>&gt; <br>&gt; The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br>&gt; <br>&gt; The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br>&gt; <br>&gt; The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br>&gt; <br>&gt; David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>Here&#39;s a draft of the proposal:<br></p><p>https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md &lt;https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md&gt;<br></p><p>David<br></p><p>&gt; On Dec 7, 2015, at 3:37 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d like to add that this would only apply to super invocation of non-final methods. Final methods always terminate with a static function reference, so the existing curry thunk mechanisms will continue to work with those until we remove them.<br>&gt; <br>&gt; David<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 1:51 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br>&gt;&gt; <br>&gt;&gt; The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br>&gt;&gt; <br>&gt;&gt; David<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ad97eb52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>On Dec 9, 2015, at 5:46 PM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Here&#39;s a draft of the proposal:<br>&gt; <br>&gt; https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md &lt;https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md&gt;<br>Hi David,<br></p><p>Sorry for the delay, things have been busy lately :-)<br></p><p>&quot; Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured.”<br></p><p>This isn’t true.  The proposal you’re referring to removes the “func f(a : Int)(b : Int)” syntax, but methods will still be curried.  It will still be perfectly legal to do:<br></p><p>class Foo {<br>  func bar() {}<br>}<br></p><p>let fn = Foo.bar<br>fn()<br></p><p><br>So, I think that in a perfect world, the implementation would lazily generate curry thunks for super partial applications, and we would keep the current behavior.  However, if it is a significant implementation burden, I’d support doing a survey of existing code to see how widely used this is.  I suspect it is rare, and if you can prove this, we may be able to knowingly break compatibility in this case in  the service of getting the ABI stability.<br></p><p>-Chris<br></p><p><br></p><p><br>&gt; <br>&gt; David<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 3:37 PM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to add that this would only apply to super invocation of non-final methods. Final methods always terminate with a static function reference, so the existing curry thunk mechanisms will continue to work with those until we remove them.<br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 1:51 PM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3a7a23ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:00 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 9, 2015, at 5:46 PM, David Farler via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Here&#39;s a draft of the proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md &lt;https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md&gt;<br>&gt; Hi David,<br>&gt; <br>&gt; Sorry for the delay, things have been busy lately :-)<br>&gt; <br>&gt; &quot; Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured.”<br>&gt; <br>&gt; This isn’t true.  The proposal you’re referring to removes the “func f(a : Int)(b : Int)” syntax, but methods will still be curried.  It will still be perfectly legal to do:<br>&gt; <br>&gt; class Foo {<br>&gt;   func bar() {}<br>&gt; }<br>&gt; <br>&gt; let fn = Foo.bar<br>&gt; fn()<br></p><p>Sorry, the example should have been:<br></p><p>let fn = Foo.bar<br>fn(myFoo)()<br></p><p>and:<br></p><p>let fn2 = myFoo.bar<br>fn2()<br></p><p>-Chris<br></p><p>&gt; <br>&gt; <br>&gt; So, I think that in a perfect world, the implementation would lazily generate curry thunks for super partial applications, and we would keep the current behavior.  However, if it is a significant implementation burden, I’d support doing a survey of existing code to see how widely used this is.  I suspect it is rare, and if you can prove this, we may be able to knowingly break compatibility in this case in  the service of getting the ABI stability.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 3:37 PM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to add that this would only apply to super invocation of non-final methods. Final methods always terminate with a static function reference, so the existing curry thunk mechanisms will continue to work with those until we remove them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:51 PM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3947e0a5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 22:00, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 5:46 PM, David Farler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Here&#39;s a draft of the proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/bitjammer/swift-evolution/blob/remove-partial-super/proposals/0008-remove-partial-application-super.md<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; Sorry for the delay, things have been busy lately :-)<br></p><p>No problem! The activity has been intense and it&#39;s great.<br></p><p>&gt; &quot; Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured.”<br>&gt; <br>&gt; This isn’t true.  The proposal you’re referring to removes the “func f(a : Int)(b : Int)” syntax, but methods will still be curried.  It will still be perfectly legal to do:<br>&gt; <br>&gt; class Foo {<br>&gt;   func bar() {}<br>&gt; }<br>&gt; <br>&gt; let fn = Foo.bar<br>&gt; fn()<br></p><p>Yes, that&#39;s what I had meant actually but the wording was probably too broad. <br></p><p>&gt; So, I think that in a perfect world, the implementation would lazily generate curry thunks for super partial applications, and we would keep the current behavior.  However, if it is a significant implementation burden, I’d support doing a survey of existing code to see how widely used this is.  I suspect it is rare, and if you can prove this, we may be able to knowingly break compatibility in this case in  the service of getting the ABI stability.<br>&gt; <br>&gt; -Chris<br></p><p>It&#39;s probably not too burdensome in an absolute sense but it is more effort to thread the right information through a mechanism that expects arbitrary levels of currying. I figured it might be better to plug it into a (potentially) simpler system after we would only expect certain uncurry levels. Maybe that&#39;s not a good bet, though! Things are working as they are now but I can really make either work. What do you think?<br></p><p>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 3:37 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d like to add that this would only apply to super invocation of non-final methods. Final methods always terminate with a static function reference, so the existing curry thunk mechanisms will continue to work with those until we remove them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:51 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to propose removing partial application of super method calls (except bare `super.foo` which implicitly captures `self`) in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is motivated by the upcoming removal of curried function declaration syntax in Swift 3 combined with making super method calls dynamically dispatched instead of statically dispatched as they are now, which is scheduled to land in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The reason why dynamic dispatch is a motivator is mostly driven by implementation details, specifically how we emit partial application thunks. These thunks ultimately result in a static function reference, which is called immediately, or a dynamic dispatch through a class method. Now, you might be wondering how class methods differ from dynamic dispatch via super methods. Class methods use dynamic dispatch through the instance pointer to the class metadata for the vtable lookup, whereas super method dynamic dispatch loads the statically known superclass&#39;s metadata instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The logic around curry thunk emission is rather complicated so I&#39;d like to go ahead and make partial applications based in `super` disallowed, rather than invest time in an area we&#39;ll be ripping up in Swift 3 and increase risk for regressions in Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The implementation for disallowing this is dead simple and I&#39;ve already got a patch for that. I should also mention that I can&#39;t safely turn on the new dynamic super method dispatch mechanics in Swift 2.2 until we address this one way or the other. I do have progress on emitting curry thunks for these kinds of partial applications but it is a rather large patch that I&#39;d like to avoid for Swift 2.2 if possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/af1f959a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:38 PM, David Farler &lt;dfarler at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &quot; Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured.”<br>&gt;&gt; <br>&gt;&gt; This isn’t true.  The proposal you’re referring to removes the “func f(a : Int)(b : Int)” syntax, but methods will still be curried.  It will still be perfectly legal to do:<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt;   func bar() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let fn = Foo.bar<br>&gt;&gt; fn()<br>&gt; <br>&gt; Yes, that&#39;s what I had meant actually but the wording was probably too broad. <br>&gt; <br>&gt;&gt; So, I think that in a perfect world, the implementation would lazily generate curry thunks for super partial applications, and we would keep the current behavior.  However, if it is a significant implementation burden, I’d support doing a survey of existing code to see how widely used this is.  I suspect it is rare, and if you can prove this, we may be able to knowingly break compatibility in this case in  the service of getting the ABI stability.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; It&#39;s probably not too burdensome in an absolute sense but it is more effort to thread the right information through a mechanism that expects arbitrary levels of currying. I figured it might be better to plug it into a (potentially) simpler system after we would only expect certain uncurry levels. Maybe that&#39;s not a good bet, though! Things are working as they are now but I can really make either work. What do you think?<br></p><p>I’d suggesting that Joe Groff chime in on this, but my sense is that if there is no overwhelming implementation concern, that we’d prefer to keep currying of super methods.  It’s a totally narrow feature, but since we already support it, it would be nice to not regress.  Curry all the things :-)<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/36d9c2c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Swift 2.2: Removing partial application of super method calls</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:38 PM, David Farler &lt;dfarler at apple.com &lt;mailto:dfarler at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot; Currying will be removed in Swift 3.0 so, rather than invest more engineering in those mechanisms, I propose that we disallow partial application of non-final methods through super, except where the self parameter is implicitly captured.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t true.  The proposal you’re referring to removes the “func f(a : Int)(b : Int)” syntax, but methods will still be curried.  It will still be perfectly legal to do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;   func bar() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fn = Foo.bar<br>&gt;&gt;&gt; fn()<br>&gt;&gt; <br>&gt;&gt; Yes, that&#39;s what I had meant actually but the wording was probably too broad. <br>&gt;&gt; <br>&gt;&gt;&gt; So, I think that in a perfect world, the implementation would lazily generate curry thunks for super partial applications, and we would keep the current behavior.  However, if it is a significant implementation burden, I’d support doing a survey of existing code to see how widely used this is.  I suspect it is rare, and if you can prove this, we may be able to knowingly break compatibility in this case in  the service of getting the ABI stability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; It&#39;s probably not too burdensome in an absolute sense but it is more effort to thread the right information through a mechanism that expects arbitrary levels of currying. I figured it might be better to plug it into a (potentially) simpler system after we would only expect certain uncurry levels. Maybe that&#39;s not a good bet, though! Things are working as they are now but I can really make either work. What do you think?<br>&gt; <br>&gt; I’d suggesting that Joe Groff chime in on this, but my sense is that if there is no overwhelming implementation concern, that we’d prefer to keep currying of super methods.  It’s a totally narrow feature, but since we already support it, it would be nice to not regress.  Curry all the things :-)<br></p><p>I was thinking one potential use of partially-applied super is something like the following:<br></p><p>class Base {<br>	func doSomething() {}<br>	func doSomethingElse() {}<br>}<br></p><p>class Derived : Base {<br>	func executeAwesomely(f: () -&gt; ()) { … f() … }<br></p><p>	override func doSomething() {<br>		executeAwesomely(super.doSomething)<br>	}<br></p><p>	override func doSomethingElse() {<br>		executeAwesomely(super.doSomethingElse)<br>	}<br>}<br></p><p>I’ve written similar things before in Factor but I’m not sure if that counts as a real use-case :-)<br></p><p>As David mentioned the curry thunk code is rather complex and duplicates a lot of policy that’s encoded in SILGenApply.cpp. Now that @objc protocol methods can be partially applied, I think the main missing feature here is ‘Proto.someInstanceMethod’ unbound protocol method references. There might be some other corner cases too (dynamic method references perhaps?) It does feel like each corner case adds a sprinkle of ‘if’ statements in random places throughout the code.<br></p><p>How about we keep super.foo around for now. Once we get around to adding all the missing corner cases, we can try to re-organize and simplify the curry thunks implementation, and maybe then decide if we want to drop anything that it does.<br></p><p>Slava<br></p><p><br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/e99cdde0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
