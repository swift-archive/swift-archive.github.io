<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 10:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, Paul Cantrell &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 2:23 PM, Paul Cantrell via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some of the particulars of the guidelines haven’t worked well for me<br>&gt;&gt; in practice — and I see from this thread that others have hit some<br>&gt;&gt; of the same problems.<br>&gt; …<br>&gt;&gt; In short, in a real-world project, pre-guidelines code agreed with<br>&gt;&gt; the guidelines 89% of the time, but where it disagreed, the<br>&gt;&gt; guidelines achieved only a 25% acceptance rate with the curmudgeonly<br>&gt;&gt; developers.<br>&gt;&gt; <br>&gt;&gt; You can follow that discussion here:<br>&gt;&gt; <br>&gt;&gt; 	https://gist.github.com/pcantrell/22a6564ca7d22789315b<br>&gt;&gt; &lt;https://gist.github.com/pcantrell/22a6564ca7d22789315b&gt;<br>&gt;&gt; 	https://github.com/bustoutsolutions/siesta/issues/15<br>&gt;&gt; &lt;https://github.com/bustoutsolutions/siesta/issues/15&gt;…<br>&gt;&gt; I’ll share in a separate message some notes on the other places<br>&gt;&gt; where we rejected the guidelines on questions other than the first<br>&gt;&gt; arg label.<br>&gt;<br>&gt; Here is that separate message as promised, with real-world examples of<br>&gt; where the guidelines didn’t seem right for Siesta for reasons other<br>&gt; than first arg naming.<br>&gt;<br>&gt; Interestingly, all of them are part-of-speech questions. I’m<br>&gt; intentionally writing up these notes before perusing Erica’s grammar<br>&gt; writeup, so I can capture the raw reactions before letting them be<br>&gt; colored by that document. Erica, I’ll get to your doc soon!<br>&gt;<br>&gt; _____________<br>&gt;<br>&gt; Siesta uses the widespread fluent style of attaching callbacks to a<br>&gt; request:<br>&gt;<br>&gt;     resource.load()<br>&gt;         .onCompletion { _ in stopSpinnyThing() }<br>&gt;         .onSuccess { _ in showHappyFace() }<br>&gt;         .onFailure { _ in showSadFace() }<br>&gt;         .onNewData { _ in soundTrumpets() }<br>&gt;<br>&gt; These methods mutate the receiving request (by adding a callback), and<br>&gt; the guidelines thus say that they should be named as imperative<br>&gt; verbs. The results of that don’t seem like an improvement:<br>&gt;<br>&gt;     resource.load()<br>&gt;         .addCompletionCallback { _ in stopSpinnyThing() }<br>&gt;         .addSuccessCallback { _ in showHappyFace() }<br>&gt;         .addFailureCallback { _ in showSadFace() }<br>&gt;         .addNewDataCallback { _ in soundTrumpets() }<br></p><p>Agreed; the &quot;.onXXX&quot; paradigm is part of an EDSL, and you often can&#39;t<br>follow conventional rules for naming without breaking the power of an<br>EDSL.  What you have here is code that is notionally declarative,<br>(i.e. non-mutating) that just happens to do some mutation.<br></p><p>You could reformulate this in various ways so that it was technically in<br>conformance, e.g...<br></p><p>     resource.load().addHandlers(<br>         .onCompletion { _ in stopSpinnyThing() },<br>         .onSuccess { _ in showHappyFace() },<br>         .onFailure { _ in showSadFace() },<br>         .onNewData { _ in soundTrumpets() },<br>     )<br></p><p>...though I don&#39;t think you should necessarily feel compelled by the<br>guidelines to make a change like this.<br></p><p>&gt; In a related case, it’s possible to attach a callback to be run before<br>&gt; any request within a given context:<br>&gt;<br>&gt;     $0.config.beforeStartingRequest {<br>&gt;         _ in performDrumroll()<br>&gt;     }<br>&gt;<br>&gt; It’s not even clear to me what the imperative verb here should<br>&gt; be. Maybe “callBeforeStartingRequest”? The guideline-conforming<br>&gt; options are all awkward; the guideline-breaking form above is clear.<br>&gt;<br>&gt; I’d suggest a rule along these lines (but with less convoluted<br>&gt; phrasing, if anyone can figure that out):<br>&gt;<br>&gt; “When a method’s last argument is a closure, the method’s name and<br>&gt; other arguments may read as a clause which modifies the closure as if<br>&gt; it were a sentence with an imperative verb.”<br>&gt;<br>&gt; Um, yeah, mouthful. Examples may help:<br>&gt;<br>&gt; 	Before starting a request, ← method<br>&gt; 	perform a drumroll. ← closure<br>&gt;<br>&gt; 	On completion, ← method<br>&gt; 	stop the spinny thing. ← closure<br></p><p>I think you&#39;re pointing at a sub-category of EDSLs here.  I definitely<br>don&#39;t want to try to cover a subset of EDSLs in the guidelines and I am<br>almost as sure that I don&#39;t want to touch EDSLs at all.  The design of<br>declarative embedded languages is an art, and those who are going to<br>engage in it need to have the courage of their convictions :-).<br></p><p>&gt; ____<br>&gt;<br>&gt; The ResourceObserver protocol, which clients will implement<br>&gt; frequently, consists of “response to event” methods that may or may<br>&gt; not mutate the receiver, but probably have side effects. These are<br>&gt; methods clients will implement, but probably not call. An example:<br>&gt;<br>&gt;     func resourceChanged(resource: Resource, event: ResourceEvent) {<br>&gt;         tableView.reloadData()<br>&gt;     }<br>&gt;<br>&gt; The name “resourceChanged” feels right to me. The old-school Cocoa<br>&gt; name would be resourceDidChange, which also feels OK. Options that are<br>&gt; strictly nouns or verbs — resourceChange, respondToResourceChange —<br>&gt; all feel awkward by comparison.<br></p><p>Agreed.<br></p><p>&gt; I think this has something to do with the “responding to event” nature<br>&gt; of the method, crossed with the fact that it’s named in a protocol. We<br>&gt; can’t know what it does, so we it doesn’t make sense to describe it as<br>&gt; a verb. We only know why it’s called, what situation it’s responding<br>&gt; to.<br>&gt; ____<br>&gt;<br>&gt; On the other side of the verb/noun coin, the ResponseTransformer<br>&gt; protocol consists of a single method…<br>&gt;<br>&gt;     public protocol ResponseTransformer {<br>&gt;         @warn_unused_result<br>&gt;         func process(response: Response) -&gt; Response<br>&gt;     }<br>&gt;<br>&gt; …which is purely functional — should mutate neither the receiver nor<br>&gt; the argument — yet just really, really seems wrong to me if it’s not<br>&gt; named “process.” Why? I don’t have a rule. My gut just tells me that<br>&gt; method should be a verb.<br></p><p>Yep, it&#39;s not returning an altered version of the receiver; it&#39;s<br>returning an altered version of its argument.<br></p><p>&gt; ____<br>&gt;<br>&gt; Last up, the rule that all enum cases should be nouns didn’t seem to<br>&gt; fit here:<br>&gt;<br>&gt;     public enum ResourceEvent: CustomStringConvertible {<br>&gt;         case ObserverAdded<br>&gt;         case Requested<br>&gt;         case RequestCancelled<br>&gt;         case NewData(NewDataSource)<br>&gt;         case NotModified<br>&gt;         case Error<br>&gt;     }<br>&gt;<br>&gt; Noun alternatives such as “ObserverAddition” and “RequestStart”<br>&gt; somehow come with more mental friction.<br></p><p>Agreed again.<br></p><p>&gt; Again, I don’t have a rule to propose here — and in these cases, we<br>&gt; may just have to say “this is why guidelines are guidelines, not<br>&gt; laws,” and leave it at that. Or someone can propose better names,<br>&gt; which would be awesome!<br></p><p>The names look really well-chosen to me, but we&#39;ll have to see what <br>others think.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
