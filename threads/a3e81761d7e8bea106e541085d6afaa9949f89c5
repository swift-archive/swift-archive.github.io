<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3f7563d0a38a6e2635f5c2daa20082e6?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Andrew Volodin</string> &lt;siddok at gmail.com&gt;<p>November 13, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi, list!<br></p><p>I’m thinking about proposal that would add a possibility to save some time on creating symmetrical binary operators.<br></p><p>The latest code example from my math lib:<br></p><p>    @inline(__always)<br>    public static func *(lhs: Angle, rhs: Float) -&gt; Angle {<br>        return Angle(lhs.degrees * rhs)<br>    }<br>    <br>    @inline(__always)<br>    public static func *(lhs: Float, rhs: Angle) -&gt; Angle {<br>        return Angle(rhs.degrees * lhs)<br>    }<br></p><p>The API of Angle doesn’t really matter here, what’s important is that I have to write another operator to make it symmetrical. Not so hard: 3 lines of code. It can even refer to original implementation, instead of duplicating the logic. But I think it would be nice to have something like symmetrical keyword, just like we have associativity and precedence. <br></p><p>I also bet that all operators should be asymmetrical by default.<br></p><p>Any thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/a3e889c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Symmetrical operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 13, 2016, at 1:38 PM, Андрей Володин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, list!<br>&gt; <br>&gt; I’m thinking about proposal that would add a possibility to save some time on creating symmetrical binary operators.<br>&gt; <br>&gt; The latest code example from my math lib:<br>&gt; <br>&gt;     @inline(__always)<br>&gt;     public static func *(lhs: Angle, rhs: Float) -&gt; Angle {<br>&gt;         return Angle(lhs.degrees * rhs)<br>&gt;     }<br>&gt;     <br>&gt;     @inline(__always)<br>&gt;     public static func *(lhs: Float, rhs: Angle) -&gt; Angle {<br>&gt;         return Angle(rhs.degrees * lhs)<br>&gt;     }<br>&gt; <br>&gt; The API of Angle doesn’t really matter here, what’s important is that I have to write another operator to make it symmetrical. Not so hard: 3 lines of code. It can even refer to original implementation, instead of duplicating the logic. But I think it would be nice to have something like symmetrical keyword, just like we have associativity and precedence. <br>&gt; <br>&gt; I also bet that all operators should be asymmetrical by default.<br>&gt; <br>&gt; Any thoughts?<br></p><p>I fully support adding a “@commutative” attribute or something to let the compiler know that a function can be called with its arguments out of order, but I’m thoroughly against turning it on by default. Some operations, such as matrix multiplication, aren’t even defined if you swap the arguments.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/c2bd0da3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ff58ec71772b338e1c6202c0e4a6301c?s=50"></div><header><strong>Symmetrical operators</strong> from <string>arkadi daniyelian</string> &lt;arkdan at icloud.com&gt;<p>November 14, 2016 at 03:00:00am</p></header><div class="content"><p>David, what about un-labeled parameters? If a function has 2 parameters of the same type, how does compiler know which ones&#39;s which?<br></p><p>&gt; On Nov 13, 2016, at 9:49 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 13, 2016, at 1:38 PM, Андрей Володин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, list!<br>&gt;&gt; <br>&gt;&gt; I’m thinking about proposal that would add a possibility to save some time on creating symmetrical binary operators.<br>&gt;&gt; <br>&gt;&gt; The latest code example from my math lib:<br>&gt;&gt; <br>&gt;&gt;     @inline(__always)<br>&gt;&gt;     public static func *(lhs: Angle, rhs: Float) -&gt; Angle {<br>&gt;&gt;         return Angle(lhs.degrees * rhs)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     @inline(__always)<br>&gt;&gt;     public static func *(lhs: Float, rhs: Angle) -&gt; Angle {<br>&gt;&gt;         return Angle(rhs.degrees * lhs)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; The API of Angle doesn’t really matter here, what’s important is that I have to write another operator to make it symmetrical. Not so hard: 3 lines of code. It can even refer to original implementation, instead of duplicating the logic. But I think it would be nice to have something like symmetrical keyword, just like we have associativity and precedence. <br>&gt;&gt; <br>&gt;&gt; I also bet that all operators should be asymmetrical by default.<br>&gt;&gt; <br>&gt;&gt; Any thoughts?<br>&gt; <br>&gt; I fully support adding a “@commutative” attribute or something to let the compiler know that a function can be called with its arguments out of order, but I’m thoroughly against turning it on by default. Some operations, such as matrix multiplication, aren’t even defined if you swap the arguments.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/0c9869ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Symmetrical operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 13, 2016, at 19:04, arkadi daniyelian &lt;arkdan at icloud.com&gt; wrote:<br>&gt; <br>&gt; David, what about un-labeled parameters? If a function has 2 parameters of the same type, how does compiler know which ones&#39;s which?<br></p><p>If a function has two unlabeled parameters of the same type, you can already swap their order at the call site.<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Symmetrical operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Although you are correct in that the compiler wouldn&#39;t be able to guarantee that both &quot;versions&quot; would give the same answer, but that&#39;s currently the case anyway.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Nov 13, 2016, at 20:03, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 13, 2016, at 19:04, arkadi daniyelian &lt;arkdan at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; David, what about un-labeled parameters? If a function has 2 parameters of the same type, how does compiler know which ones&#39;s which?<br>&gt; <br>&gt; If a function has two unlabeled parameters of the same type, you can already swap their order at the call site.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>November 14, 2016 at 12:00:00pm</p></header><div class="content"><p>-1<br>Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an<br>additive feature.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/ed45f2f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/90331b9c1113c5039826dd5ce116e686?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Dimitri Racordon</string> &lt;Dimitri.Racordon at unige.ch&gt;<p>November 14, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>I think the use cases are not that sparse actually.<br>I would also argue that it would be easier to understand the intent of the code with some sort of keyword than with a hard copy of each function.<br></p><p><br></p><p>&gt; On 14 Nov 2016, at 10:51, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1<br>&gt; Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an additive feature.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 14, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m a +1 on the feature, though for simply handling symmetry it&#39;s not a super critical issue.<br></p><p><br>I wonder though, when you start looking at symmetry is it worth looking at other patterns? For example, could symmetrical operators be covered by a broader multi-part operator definition?<br></p><p>I was thinking recently it would be convenient if I could define say a 3-dimensional point like so: &lt;x, y, z&gt;<br></p><p>In this case you&#39;re looking at a symmetric operator with two different components (opening and closing angle brackets) with the ability to take three arguments. Is there a way we could define and implement something along these lines? If so it would be very flexible, and potential allow us to unify all operators into a single format.<br></p><p>For example, you can thing of a prefix operator as being a leading symbol plus one argument, while a postfix is one argument plus a trailing symbol, a binary operator is an argument, a symbol and another argument, a symmetric operator is a leading symbol, an argument and a trailing symbol (doesn&#39;t have to be identical).<br></p><p>If we had a means of specifying operators in this way (as a complete pattern) we could do away with special cases of operators entirely, though they may be worth keeping for compatibility and as a shorthand.<br></p><p>&gt; On 14 Nov 2016, at 09:57, Dimitri Racordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I think the use cases are not that sparse actually.<br>&gt; I would also argue that it would be easier to understand the intent of the code with some sort of keyword than with a hard copy of each function.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 14 Nov 2016, at 10:51, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1<br>&gt;&gt; Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an additive feature.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November 14, 2016 at 10:00:00am</p></header><div class="content"><p>Perhaps a more general solution would be a way to mark functions as<br>“rearrangeable”, meaning the arguments can appear in any order.<br></p><p>I also like Haravikk’s idea for “outfix” operators—there are certainly a<br>large number of bracket-type Unicode characters that could be useful in<br>such a role.<br></p><p>Nevin<br></p><p><br>On Mon, Nov 14, 2016 at 6:48 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m a +1 on the feature, though for simply handling symmetry it&#39;s not a<br>&gt; super critical issue.<br>&gt;<br>&gt;<br>&gt; I wonder though, when you start looking at symmetry is it worth looking at<br>&gt; other patterns? For example, could symmetrical operators be covered by a<br>&gt; broader multi-part operator definition?<br>&gt;<br>&gt; I was thinking recently it would be convenient if I could define say a<br>&gt; 3-dimensional point like so: &lt;x, y, z&gt;<br>&gt;<br>&gt; In this case you&#39;re looking at a symmetric operator with two different<br>&gt; components (opening and closing angle brackets) with the ability to take<br>&gt; three arguments. Is there a way we could define and implement something<br>&gt; along these lines? If so it would be very flexible, and potential allow us<br>&gt; to unify all operators into a single format.<br>&gt;<br>&gt; For example, you can thing of a prefix operator as being a leading symbol<br>&gt; plus one argument, while a postfix is one argument plus a trailing symbol,<br>&gt; a binary operator is an argument, a symbol and another argument, a<br>&gt; symmetric operator is a leading symbol, an argument and a trailing symbol<br>&gt; (doesn&#39;t have to be identical).<br>&gt;<br>&gt; If we had a means of specifying operators in this way (as a complete<br>&gt; pattern) we could do away with special cases of operators entirely, though<br>&gt; they may be worth keeping for compatibility and as a shorthand.<br>&gt;<br>&gt; &gt; On 14 Nov 2016, at 09:57, Dimitri Racordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; I think the use cases are not that sparse actually.<br>&gt; &gt; I would also argue that it would be easier to understand the intent of<br>&gt; the code with some sort of keyword than with a hard copy of each function.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 14 Nov 2016, at 10:51, Anton Zhilin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -1<br>&gt; &gt;&gt; Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an<br>&gt; additive feature.<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/dcea5fe9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Symmetrical operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 14, 2016, at 5:48 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m a +1 on the feature, though for simply handling symmetry it&#39;s not a super critical issue.<br>&gt; <br>&gt; <br>&gt; I wonder though, when you start looking at symmetry is it worth looking at other patterns? For example, could symmetrical operators be covered by a broader multi-part operator definition?<br>&gt; <br>&gt; I was thinking recently it would be convenient if I could define say a 3-dimensional point like so: &lt;x, y, z&gt;<br>&gt; <br>&gt; In this case you&#39;re looking at a symmetric operator with two different components (opening and closing angle brackets) with the ability to take three arguments. Is there a way we could define and implement something along these lines? If so it would be very flexible, and potential allow us to unify all operators into a single format.<br>&gt; <br>&gt; For example, you can thing of a prefix operator as being a leading symbol plus one argument, while a postfix is one argument plus a trailing symbol, a binary operator is an argument, a symbol and another argument, a symmetric operator is a leading symbol, an argument and a trailing symbol (doesn&#39;t have to be identical).<br>&gt; <br>&gt; If we had a means of specifying operators in this way (as a complete pattern) we could do away with special cases of operators entirely, though they may be worth keeping for compatibility and as a shorthand.<br>+11<br></p><p>I would *love* to be able to specify &quot;complex operators&quot; that take more than two arguments, are “symmetric” (in Haravikk’s sense of the word, like &quot;let y = |x|”), or really have whatever syntax I want. The difficulty would be doing it in such a way that it doesn&#39;t conflict with the existing grammar. This sounds difficult (to me, anyway), but it turns out that if we can represent operators’ grammar as regular expressions, it might be a more-or-less solved problem (http://stackoverflow.com/questions/3410256/regex-determine-if-two-regular-expressions-could-match-for-the-same-input). Now, actually finding a useful “complex” syntax that doesn’t conflict with anything might be tricky, but that’s not the language’s problem.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3f7563d0a38a6e2635f5c2daa20082e6?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Andrew Volodin</string> &lt;siddok at gmail.com&gt;<p>November 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Отправлено с iPhone<br></p><p>&gt; 14 нояб. 2016 г., в 12:51, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; написал(а):<br>&gt; <br>&gt; -1<br>&gt; Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an additive feature.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3f7563d0a38a6e2635f5c2daa20082e6?s=50"></div><header><strong>Symmetrical operators</strong> from <string>Andrew Volodin</string> &lt;siddok at gmail.com&gt;<p>November 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Well, I dont actually think it can be considered as a syntax sugar. It requires creating separate function to achieve same effect. This is all about how operators behave in general.<br></p><p>&gt; 14 нояб. 2016 г., в 12:51, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; написал(а):<br>&gt; <br>&gt; -1<br>&gt; Not worth adding syntactic sugar for a narrow use case. Plus it&#39;s an additive feature.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
