<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Drafting a proposal: Make conflicting with protocol extension methods an error</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 16, 2015 at 03:00:00pm</p></header><div class="content"><p>This proposal comes out of the threads &quot;Proposal: Universal dynamic dispatch for method calls” and “Proposal: Require explicit modifier for statically dispatched extension methods”. I’m posting it now as a new thread because it needs some attention from people who haven’t been following these long and detailed threads.<br></p><p>This proposal is intended to address a Swift behavior which surprises some people. Suppose you write a protocol and extension like this:<br></p><p>	protocol Turnable {<br>	    func turning() -&gt; Self<br>	    mutating func turn()<br>	}<br>	extension Turnable {<br>	    mutating func turn() {<br>	        self = turning()<br>	    }<br>	<br>	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>	        var turnedSelf = self<br>	        for _ in 1...additionalTurns {<br>	            turnedSelf.turn()<br>	        }<br>	        return turnedSelf<br>	    }<br>	}<br></p><p>Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br></p><p>1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol; it is only in the protocol extension. This is the case we are trying to address.<br></p><p>Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br></p><p>	var wicket: SpimsterWicket = SpimsterWicket()<br>	var turnable: Turnable = wicket<br>	<br>	wicket.turn()					// Calls SpimsterWicket.turn()<br>	turnable.turn()					// Also calls SpimsterWicket.turn()<br>	<br>	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br></p><p>In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br></p><p>But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br></p><p>This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br></p><p>The lack of a warning on this is currently considered a bug &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html&gt;, but I think we should go further. In brief, here’s what I propose.<br></p><p><br>MARK PROTOCOL EXTENSION MEMBERS AS FINAL AND PREVENT CONFLICTS<br>------------------------------------------------------------------------------------------------------------------<br></p><p>I think conflicting with a protocol extension member should be an error. But I also think the source code should tell you which protocol extension members this rule applies to.<br></p><p>What I think we should do is require protocol extension methods (that is, non-default ones) to be marked `final`. The current meaning of `final` is specific to classes: “Subclasses must use this as-is”. I think we can extend that to protocols by making it mean, more generally, “Subtypes must use this as-is”.<br></p><p>This also has the handy effect of making it obvious, without reading the original protocol definition, which members in a protocol extension are default implementations and which are not:<br></p><p>	extension Turnable {<br>	    mutating func turn() {<br>	        self = turning()<br>	    }<br>	<br>	    final func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>	        var turnedSelf = self<br>	        for _ in 1...additionalTurns {<br>	            turnedSelf.turn()<br>	        }<br>	        return turnedSelf<br>	    }<br>	}<br></p><p>With this in place, I would then make shadowing a visible `final` protocol extension member illegal. That means:<br></p><p>1. It is an error to conform a type* to a protocol which includes a visible `final` member matching one of its own members. (You can’t conform `SpimsterWicket` to `Turnable` if it has a `turningRepeatedly(_:)` method.)<br></p><p>2.  It is an error to extend a type to add a member matching a visible `final` member in any protocol it conforms to. (You can’t extend `SpimsterWicket` to add a `turningRepeatedly(_:)` method if it conforms to `Turnable`.)<br></p><p>3. It is an error to extend a protocol with a member that conflicts with any visible member of a conforming type. (You can’t extend `Turnable` to add a final `turningRepeatedly(_:)` method if `SpimsterWicket` has one.)<br></p><p>4. It is an error to conform a type to two protocols which both have `final` protocol extension members with the same name and signature. (You can’t extend `SpimsterWicket` with both `Turnable` and `VampireVictimizable` if they both have extensions with `final func turningRepeatedly(_: Int) -&gt; Self`.)<br></p><p>5. It is an error to import a combination of modules which causes any of the above conflicts. (If the `Turnable` protocol is in `TurnableKit`, the `SpimsterWicket` conformance is in `LibWickets`, and the `Turnable` protocol extension is in `TurnableExtensions`, you cannot import both `SpimsterWicket` and `TurnableExtensions` into the same file.)<br></p><p>* “Type” in this list means a class, struct, enum, or another protocol, whether existential or generic.<br></p><p>Though there are many permutations (and I may have missed some), these all express one simple rule: it should not be legal to have both a `final` protocol extension member and a member which conflicts with it visible in the same place.<br></p><p><br>SELECTIVELY PERMIT CONFLICTS WITH AN ATTRIBUTE<br>---------------------------------------------------------------------------------<br></p><p>This part I’m a little less sure about; we may want to drop it.<br></p><p>The enforcement of the above rule prevents bugs, but in some cases it may also prevent desirable conformances. I propose that we provide an escape hatch, which I’m calling the `@incoherent` attribute.<br></p><p>`@incoherent` basically acknowledges the conflict and explicitly declares that you are expecting the current behavior, where different variable types may call different implementations on the same instance. It may be used in any of the contexts listed above.<br></p><p>An `@incoherent` attribute should always make clear both the conforming type and the protocol it conforms to. However, in some contexts, one or both of these types are obvious, and can be left out. So it has several different syntactic forms.<br></p><p>On a protocol conformance declaration:<br></p><p>	extension SpimsterWicket: @incoherent Turnable { … }<br></p><p>On a protocol extension adding a member which conflicts with an existing conforming type:<br></p><p>	@incoherent(SpimsterWicket) extension Turnable {…}<br></p><p>On an extension to a conforming type which conflicts with an existing final protocol extension method:<br></p><p>	@incoherent(Turnable) extension SpimsterWicket {…}<br></p><p>On an import statement which imports extensions that conflict with a conformance:<br></p><p>	@incoherent(SpimsterWicket: Turnable) import TurnableExtensions<br></p><p>(Incidentally, we could make `@incoherent` also work when inheriting from a class with `final` members, with the same caveat: casting to the superclass may change the instance’s behavior. The result would be something like overriding a non-virtual member in C++.)<br></p><p>Keep in mind that, like `try!` or the various `Unsafe` APIs, `@incoherent` is not really a desirable feature—it is an escape hatch for difficult situations. The preferred solution is to rename conflicting members or add them to the protocol definition so that they can be non-final. I would suggest that Swift *not* offer a fix-it inserting an `@incoherent` annotation; people would use it without realizing what it meant.<br></p><p><br>A NOTE ON FUTURE EXPANSION<br>-----------------------------------------------<br></p><p>Some people have suggested that protocol extension methods should get the same dynamic dispatch as methods listed in the protocol itself, effectively erasing the distinction between defaulted members and other protocol extension members. I’m currently agnostic on this proposal, other than noting that implementation might be complicated. However, even if we do that, we may want `final` protocol extension members anyway, to give us better dispatch performance on certain calls.<br></p><p><br>So—any thoughts? Particularly, is `@incoherent` needed or wanted, or should we just error out when we see a conflict and demand that users disambiguate their code?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Drafting a proposal: Make conflicting with protocol extension methods an error</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 3:48 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This proposal comes out of the threads &quot;Proposal: Universal dynamic dispatch for method calls” and “Proposal: Require explicit modifier for statically dispatched extension methods”. I’m posting it now as a new thread because it needs some attention from people who haven’t been following these long and detailed threads.<br>&gt; <br>&gt; This proposal is intended to address a Swift behavior which surprises some people. Suppose you write a protocol and extension like this:<br>&gt; <br>&gt; 	protocol Turnable {<br>&gt; 	    func turning() -&gt; Self<br>&gt; 	    mutating func turn()<br>&gt; 	}<br>&gt; 	extension Turnable {<br>&gt; 	    mutating func turn() {<br>&gt; 	        self = turning()<br>&gt; 	    }<br>&gt; 	<br>&gt; 	    func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>&gt; 	        var turnedSelf = self<br>&gt; 	        for _ in 1...additionalTurns {<br>&gt; 	            turnedSelf.turn()<br>&gt; 	        }<br>&gt; 	        return turnedSelf<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; Now you want to write a conforming type, `SpimsterWicket`. There are three different rules about whether your type has to, or can, implement its own versions of these methods.<br>&gt; <br>&gt; 1. `turning()` is a “protocol method”: it is listed in the protocol but is not included in the extension. You *must* implement `turning()` to conform to `Turnable`.<br>&gt; 2. `turn()` is a “defaulted protocol method”: it is listed in the protocol but there is also an implementation of it in the extension. You *may* implement `turn()`; if you don’t, the protocol extension’s implementation will be used.<br>&gt; 3. `turningRepeatedly(_: Int)` is a “protocol extension method”: it is *not* listed in the protocol; it is only in the protocol extension. This is the case we are trying to address.<br>&gt; <br>&gt; Currently, in case 3, Swift permits you to implement your own `turningRepeatedly(_: Int)`. However, your implementation may not be called in every circumstance that you expect. If you call `turningRepeatedly` on a variable of type `SpimsterWicket`, you’ll get `SpimsterWicket`’s implementation of the method; however, if you call `turningRepeatedly` on a variable of type `Turnable`, you’ll get `Turnable`’s implementation of the method.<br>&gt; <br>&gt; 	var wicket: SpimsterWicket = SpimsterWicket()<br>&gt; 	var turnable: Turnable = wicket<br>&gt; 	<br>&gt; 	wicket.turn()					// Calls SpimsterWicket.turn()<br>&gt; 	turnable.turn()					// Also calls SpimsterWicket.turn()<br>&gt; 	<br>&gt; 	wicket.turningRepeatedly(5)		// Calls SpimsterWicket.turningRepeatedly(_:)<br>&gt; 	turnable.turningRepeatedly(5)	// Calls Turnable.turningRepeatedly(_:)<br>&gt; <br>&gt; In most parts of Swift, casting an instance or assigning it to a variable of a different type doesn’t change which implementation will be called when you put it on the left-hand side of a dot. (I’m leaving aside Objective-C bridging, like `Int` to `NSNumber`, which is really a different operation being performed with the same syntax.) If you put a `UIControl` into a variable of type `UIView`, and then call `touchesBegan()` on that variable, Swift will still call `UIControl.touchesBegan()`. The same is true of defaulted protocol methods—if you call `turn()` on `turnable`, you’ll get `SpimsterWicket.turn()`.<br>&gt; <br>&gt; But this is not true of protocol extension methods. There, the static type of the variable—the type known at compile time, the type that the variable is labeled with—is used. Thus, calling `turningRepeatedly(_:)` on `wicket` gets you `SpimsterWicket`’s implementation, but calling it on `turnable`—even though it&#39;s merely the same instance casted to a different type—gets you `Turnable`’s implementation.<br>&gt; <br>&gt; This creates what I call an “incoherent” dispatch, and it occurs nowhere else in Swift. In most places in Swift, dispatch is either based on the runtime type (reference types, normal protocol members), or the design of the language ensures there’s no difference between dispatching on the compile-time type and the runtime type (value types, `final` members). But in protocol extension members, dispatch is based on the compile-time type even though the runtime type might produce different behavior.<br>&gt; <br>&gt; The lack of a warning on this is currently considered a bug &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001861.html&gt;, but I think we should go further. In brief, here’s what I propose.<br>&gt; <br>&gt; <br>&gt; MARK PROTOCOL EXTENSION MEMBERS AS FINAL AND PREVENT CONFLICTS<br>&gt; ------------------------------------------------------------------------------------------------------------------<br>&gt; <br>&gt; I think conflicting with a protocol extension member should be an error. But I also think the source code should tell you which protocol extension members this rule applies to.<br>&gt; <br>&gt; What I think we should do is require protocol extension methods (that is, non-default ones) to be marked `final`. The current meaning of `final` is specific to classes: “Subclasses must use this as-is”. I think we can extend that to protocols by making it mean, more generally, “Subtypes must use this as-is”.<br>&gt; <br>&gt; This also has the handy effect of making it obvious, without reading the original protocol definition, which members in a protocol extension are default implementations and which are not:<br>&gt; <br>&gt; 	extension Turnable {<br>&gt; 	    mutating func turn() {<br>&gt; 	        self = turning()<br>&gt; 	    }<br>&gt; 	<br>&gt; 	    final func turningRepeatedly(additionalTurns: Int) -&gt; Self {<br>&gt; 	        var turnedSelf = self<br>&gt; 	        for _ in 1...additionalTurns {<br>&gt; 	            turnedSelf.turn()<br>&gt; 	        }<br>&gt; 	        return turnedSelf<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; With this in place, I would then make shadowing a visible `final` protocol extension member illegal. That means:<br>&gt; <br>&gt; 1. It is an error to conform a type* to a protocol which includes a visible `final` member matching one of its own members. (You can’t conform `SpimsterWicket` to `Turnable` if it has a `turningRepeatedly(_:)` method.)<br>&gt; <br>&gt; 2.  It is an error to extend a type to add a member matching a visible `final` member in any protocol it conforms to. (You can’t extend `SpimsterWicket` to add a `turningRepeatedly(_:)` method if it conforms to `Turnable`.)<br>&gt; <br>&gt; 3. It is an error to extend a protocol with a member that conflicts with any visible member of a conforming type. (You can’t extend `Turnable` to add a final `turningRepeatedly(_:)` method if `SpimsterWicket` has one.)<br>&gt; <br>&gt; 4. It is an error to conform a type to two protocols which both have `final` protocol extension members with the same name and signature. (You can’t extend `SpimsterWicket` with both `Turnable` and `VampireVictimizable` if they both have extensions with `final func turningRepeatedly(_: Int) -&gt; Self`.)<br>&gt; <br>&gt; 5. It is an error to import a combination of modules which causes any of the above conflicts. (If the `Turnable` protocol is in `TurnableKit`, the `SpimsterWicket` conformance is in `LibWickets`, and the `Turnable` protocol extension is in `TurnableExtensions`, you cannot import both `SpimsterWicket` and `TurnableExtensions` into the same file.)<br>&gt; <br>&gt; * “Type” in this list means a class, struct, enum, or another protocol, whether existential or generic.<br>&gt; <br>&gt; Though there are many permutations (and I may have missed some), these all express one simple rule: it should not be legal to have both a `final` protocol extension member and a member which conflicts with it visible in the same place.<br>&gt; <br>&gt; <br>&gt; SELECTIVELY PERMIT CONFLICTS WITH AN ATTRIBUTE<br>&gt; ---------------------------------------------------------------------------------<br>&gt; <br>&gt; This part I’m a little less sure about; we may want to drop it.<br>&gt; <br>&gt; The enforcement of the above rule prevents bugs, but in some cases it may also prevent desirable conformances. I propose that we provide an escape hatch, which I’m calling the `@incoherent` attribute.<br>&gt; <br>&gt; `@incoherent` basically acknowledges the conflict and explicitly declares that you are expecting the current behavior, where different variable types may call different implementations on the same instance. It may be used in any of the contexts listed above.<br>&gt; <br>&gt; An `@incoherent` attribute should always make clear both the conforming type and the protocol it conforms to. However, in some contexts, one or both of these types are obvious, and can be left out. So it has several different syntactic forms.<br>&gt; <br>&gt; On a protocol conformance declaration:<br>&gt; <br>&gt; 	extension SpimsterWicket: @incoherent Turnable { … }<br>&gt; <br>&gt; On a protocol extension adding a member which conflicts with an existing conforming type:<br>&gt; <br>&gt; 	@incoherent(SpimsterWicket) extension Turnable {…}<br>&gt; <br>&gt; On an extension to a conforming type which conflicts with an existing final protocol extension method:<br>&gt; <br>&gt; 	@incoherent(Turnable) extension SpimsterWicket {…}<br>&gt; <br>&gt; On an import statement which imports extensions that conflict with a conformance:<br>&gt; <br>&gt; 	@incoherent(SpimsterWicket: Turnable) import TurnableExtensions<br>&gt; <br>&gt; (Incidentally, we could make `@incoherent` also work when inheriting from a class with `final` members, with the same caveat: casting to the superclass may change the instance’s behavior. The result would be something like overriding a non-virtual member in C++.)<br>&gt; <br>&gt; Keep in mind that, like `try!` or the various `Unsafe` APIs, `@incoherent` is not really a desirable feature—it is an escape hatch for difficult situations. The preferred solution is to rename conflicting members or add them to the protocol definition so that they can be non-final. I would suggest that Swift *not* offer a fix-it inserting an `@incoherent` annotation; people would use it without realizing what it meant.<br>&gt; <br>&gt; <br>&gt; A NOTE ON FUTURE EXPANSION<br>&gt; -----------------------------------------------<br>&gt; <br>&gt; Some people have suggested that protocol extension methods should get the same dynamic dispatch as methods listed in the protocol itself, effectively erasing the distinction between defaulted members and other protocol extension members. I’m currently agnostic on this proposal, other than noting that implementation might be complicated. However, even if we do that, we may want `final` protocol extension members anyway, to give us better dispatch performance on certain calls.<br>&gt; <br>&gt; <br>&gt; So—any thoughts? Particularly, is `@incoherent` needed or wanted, or should we just error out when we see a conflict and demand that users disambiguate their code?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br></p><p><br>Hi Brent,<br></p><p>I’m not sure how it affects your proposal, but I just want to point out that having things that are *only* statically dispatched is sometimes desirable.  For example, Set equality is different from Collection equality, but Set conforms to Collection.  If you write an algorithm over equatable collections, it doesn’t know that the Collection happens to be a Set; it views the collection as a mere series of elements, and has a right to expect a == b to return true iff a[a.startIndex.advancedBy(n)] == b[b.startIndex.advancedBy(n)] for all n.  So the behavior of equality might be statically dispatched along this dimension.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Drafting a proposal: Make conflicting with protocol extension methods an error</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; I’m not sure how it affects your proposal, but I just want to point out that having things that are *only* statically dispatched is sometimes desirable.  For example, Set equality is different from Collection equality, but Set conforms to Collection.  If you write an algorithm over equatable collections, it doesn’t know that the Collection happens to be a Set; it views the collection as a mere series of elements, and has a right to expect a == b to return true iff a[a.startIndex.advancedBy(n)] == b[b.startIndex.advancedBy(n)] for all n.  So the behavior of equality might be statically dispatched along this dimension.<br></p><p>I agree, and with this proposal you would still get static dispatch from a `final` protocol extension method. This proposal simply ensures that you can’t then implement an identical method in a conforming type, under the mistaken impression that the type-specific method will override the protocol extension.<br></p><p>This proposal doesn’t actually change any calling semantics at all. It’s purely concerned with declarations: how they need to be keyworded to be more explicit, when a declaration might be forbidden in the presence of another declaration, and (if `@incoherent` is included) how you can disable that safety check when it’s getting in the way.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Drafting a proposal: Make conflicting with protocol extension methods an error</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 5:38 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I’m not sure how it affects your proposal, but I just want to point out that having things that are *only* statically dispatched is sometimes desirable.  For example, Set equality is different from Collection equality, but Set conforms to Collection.  If you write an algorithm over equatable collections, it doesn’t know that the Collection happens to be a Set; it views the collection as a mere series of elements, and has a right to expect a == b to return true iff a[a.startIndex.advancedBy(n)] == b[b.startIndex.advancedBy(n)] for all n.  So the behavior of equality might be statically dispatched along this dimension.<br>&gt; <br>&gt; I agree, and with this proposal you would still get static dispatch from a `final` protocol extension method. This proposal simply ensures that you can’t then implement an identical method in a conforming type, under the mistaken impression that the type-specific method will override the protocol extension.<br></p><p>That’s exactly what I think we want for Set (except for the “mistaken impression”) part.<br></p><p>&gt; This proposal doesn’t actually change any calling semantics at all. It’s purely concerned with declarations: how they need to be keyworded to be more explicit, when a declaration might be forbidden in the presence of another declaration, and (if `@incoherent` is included) how you can disable that safety check when it’s getting in the way.<br></p><p>Maybe the only conclusion is that something like your @incoherent is needed, as opposed to being optional as the proposal suggests.<br></p><p>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
