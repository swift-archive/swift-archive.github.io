<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Idea] Add dynamicType casting</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Currently, the language syntax only allows type identifiers in the<br>type-casting-operator productions:<br></p><p>&quot; &quot; surrounds a keyword<br></p><p>type-casting-operator -&gt; &quot;is&quot; type<br>type-casting-operator -&gt; &quot;as&quot; type<br>type-casting-operator -&gt; &quot;as&quot; &quot;?&quot; type<br>type-casting-operator -&gt; &quot;as&quot; &quot;!&quot; type<br></p><p>The type production doesn&#39;t allow for expressions which resolve to a type,<br>only explicit type references.<br></p><p>So, if you want to refer to the item *as* its dynamic type, there&#39;s no<br>direct way to do that unless you declare the name of the type in code:<br></p><p>class Example {}<br>var value: Any = Example()<br>var again = value as value.dynamicType<br>// doesn&#39;t work because value.dynamicType is an expression<br></p><p>It should be possible to upcast to dynamicType immediately with no chance<br>of failure. To that end, I suggest adding two productions:<br></p><p>type-casting-operator -&gt; &quot;is&quot; &quot;dynamicType&quot;<br>type-casting-operator -&gt; &quot;as&quot; &quot;dynamicType&quot;<br></p><p>Following along the example above, we could then do:<br></p><p>var nowPossible = value as dynamicType<br></p><p>and have nowPossible be Example.Type.<br></p><p>Possible use cases for this functionality include:<br></p><p>1. Dealing with mixed-type collections from Objective-C code:<br>   @[ @&quot;key1&quot;, @5, @&quot;key2&quot;, @20, @&quot;key3&quot;, @[@&quot;red&quot;,@&quot;green&quot;,@&quot;blue&quot;]]<br></p><p>2. Taking advantage of type-specific polymorphism without having to modify<br>code:<br></p><p>    func handleObject(obj: NSNumber) { print(&quot;Number&quot;) }<br>    func handleObject(obj: NSData) { print(&quot;Data&quot;) }<br></p><p>    func dispatchToHandler(kind: AnyObject) {<br>        print(&quot;dispatching \(kind.dynamicType)&quot;)<br>        handleObject(kind as dynamicType)<br>    }<br></p><p>I suspect that handling this use case might pose the most difficulties when<br>implementing the feature. It might make the whole thing impossible if<br>there&#39;s no way to resolve types at run-time in compiled code. For example,<br>if the dispatcher is in a Framework distributed as a binary and the user<br>does<br></p><p>class MyClass {}<br>func handleObject(obj: MyClass) { print &quot;Success!&quot; }<br></p><p>let stuff = MyClass()<br>dispatchToHandler(stuff)<br></p><p>in the project&#39;s code, what would happen?<br></p><p>Casting to an intermediate type between the static and dynamic types would<br>fall out naturally, though in that case you&#39;d already have to know the<br>dynamicType and write the explicit intermediate type name in the code. If<br>that much is known then it&#39;s possible to cast directly to that intermediate<br>type with existing syntax.<br></p><p>Also, it&#39;s worth noting that the &quot;Any&quot; case is only the broadest instance<br>possible. Anything that passes data along as a super type, by using a<br>Protocol as a concrete type specifier, etc. could benefit from this<br>mechanism.<br></p><p>Mike<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/00aa6b16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Add dynamicType casting</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; func magic(_ variable: Any) {<br>&gt; 	let foo = variable as dynamicType<br>&gt; 	// ???<br>&gt; }<br>&gt; <br>&gt; magic(&quot;hello&quot;)<br>&gt; magic(42)<br></p><p>What would be the result of this? What benefit do I get from casting it to its dynamic type?<br></p><p>Félix<br></p><p>&gt; Le 8 janv. 2016 à 23:40:46, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Currently, the language syntax only allows type identifiers in the type-casting-operator productions:<br>&gt; <br>&gt; &quot; &quot; surrounds a keyword<br>&gt; <br>&gt; type-casting-operator -&gt; &quot;is&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;?&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;!&quot; type<br>&gt; <br>&gt; The type production doesn&#39;t allow for expressions which resolve to a type, only explicit type references.<br>&gt; <br>&gt; So, if you want to refer to the item *as* its dynamic type, there&#39;s no direct way to do that unless you declare the name of the type in code:<br>&gt; <br>&gt; class Example {}<br>&gt; var value: Any = Example()<br>&gt; var again = value as value.dynamicType<br>&gt; // doesn&#39;t work because value.dynamicType is an expression<br>&gt; <br>&gt; It should be possible to upcast to dynamicType immediately with no chance of failure. To that end, I suggest adding two productions:<br>&gt; <br>&gt; type-casting-operator -&gt; &quot;is&quot; &quot;dynamicType&quot;<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;dynamicType&quot;<br>&gt; <br>&gt; Following along the example above, we could then do:<br>&gt; <br>&gt; var nowPossible = value as dynamicType<br>&gt; <br>&gt; and have nowPossible be Example.Type.<br>&gt; <br>&gt; Possible use cases for this functionality include:<br>&gt; <br>&gt; 1. Dealing with mixed-type collections from Objective-C code:<br>&gt;    @[ @&quot;key1&quot;, @5, @&quot;key2&quot;, @20, @&quot;key3&quot;, @[@&quot;red&quot;,@&quot;green&quot;,@&quot;blue&quot;]]<br>&gt; <br>&gt; 2. Taking advantage of type-specific polymorphism without having to modify code:<br>&gt; <br>&gt;     func handleObject(obj: NSNumber) { print(&quot;Number&quot;) }<br>&gt;     func handleObject(obj: NSData) { print(&quot;Data&quot;) }<br>&gt; <br>&gt;     func dispatchToHandler(kind: AnyObject) {<br>&gt;         print(&quot;dispatching \(kind.dynamicType)&quot;)<br>&gt;         handleObject(kind as dynamicType)<br>&gt;     }<br>&gt; <br>&gt; I suspect that handling this use case might pose the most difficulties when implementing the feature. It might make the whole thing impossible if there&#39;s no way to resolve types at run-time in compiled code. For example, if the dispatcher is in a Framework distributed as a binary and the user does<br>&gt; <br>&gt; class MyClass {}<br>&gt; func handleObject(obj: MyClass) { print &quot;Success!&quot; }<br>&gt; <br>&gt; let stuff = MyClass()<br>&gt; dispatchToHandler(stuff)<br>&gt; <br>&gt; in the project&#39;s code, what would happen?<br>&gt; <br>&gt; Casting to an intermediate type between the static and dynamic types would fall out naturally, though in that case you&#39;d already have to know the dynamicType and write the explicit intermediate type name in the code. If that much is known then it&#39;s possible to cast directly to that intermediate type with existing syntax.<br>&gt; <br>&gt; Also, it&#39;s worth noting that the &quot;Any&quot; case is only the broadest instance possible. Anything that passes data along as a super type, by using a Protocol as a concrete type specifier, etc. could benefit from this mechanism.<br>&gt; <br>&gt; Mike<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/a5cf7d9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[Idea] Add dynamicType casting</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January  9, 2016 at 10:00:00pm</p></header><div class="content"><p>As far as I know, dynamicType is something that doesn&#39;t work until the app<br>is running the specific code, which means your codes are no longer<br>protected by the compiler. That is what swift tries to keep you from. So I<br>believe this should not happen in swift at any time. You should use<br>dynamicType as little as possible. You should try generics instead of<br>dynamic type.<br></p><p>As you said, you&#39;d better to cast it to a protocol instead of dynamicType.<br></p><p>zhaoxin<br></p><p>On Sat, Jan 9, 2016 at 12:55 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt;<br>&gt; func magic(_ variable: Any) {<br>&gt; let foo = variable as dynamicType<br>&gt; // ???<br>&gt; }<br>&gt;<br>&gt; magic(&quot;hello&quot;)<br>&gt; magic(42)<br>&gt;<br>&gt;<br>&gt; What would be the result of this? What benefit do I get from casting it to<br>&gt; its dynamic type?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 8 janv. 2016 à 23:40:46, Michael Henson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; Currently, the language syntax only allows type identifiers in the<br>&gt; type-casting-operator productions:<br>&gt;<br>&gt; &quot; &quot; surrounds a keyword<br>&gt;<br>&gt; type-casting-operator -&gt; &quot;is&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;?&quot; type<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;!&quot; type<br>&gt;<br>&gt; The type production doesn&#39;t allow for expressions which resolve to a type,<br>&gt; only explicit type references.<br>&gt;<br>&gt; So, if you want to refer to the item *as* its dynamic type, there&#39;s no<br>&gt; direct way to do that unless you declare the name of the type in code:<br>&gt;<br>&gt; class Example {}<br>&gt; var value: Any = Example()<br>&gt; var again = value as value.dynamicType<br>&gt; // doesn&#39;t work because value.dynamicType is an expression<br>&gt;<br>&gt; It should be possible to upcast to dynamicType immediately with no chance<br>&gt; of failure. To that end, I suggest adding two productions:<br>&gt;<br>&gt; type-casting-operator -&gt; &quot;is&quot; &quot;dynamicType&quot;<br>&gt; type-casting-operator -&gt; &quot;as&quot; &quot;dynamicType&quot;<br>&gt;<br>&gt; Following along the example above, we could then do:<br>&gt;<br>&gt; var nowPossible = value as dynamicType<br>&gt;<br>&gt; and have nowPossible be Example.Type.<br>&gt;<br>&gt; Possible use cases for this functionality include:<br>&gt;<br>&gt; 1. Dealing with mixed-type collections from Objective-C code:<br>&gt;    @[ @&quot;key1&quot;, @5, @&quot;key2&quot;, @20, @&quot;key3&quot;, @[@&quot;red&quot;,@&quot;green&quot;,@&quot;blue&quot;]]<br>&gt;<br>&gt; 2. Taking advantage of type-specific polymorphism without having to modify<br>&gt; code:<br>&gt;<br>&gt;     func handleObject(obj: NSNumber) { print(&quot;Number&quot;) }<br>&gt;     func handleObject(obj: NSData) { print(&quot;Data&quot;) }<br>&gt;<br>&gt;     func dispatchToHandler(kind: AnyObject) {<br>&gt;         print(&quot;dispatching \(kind.dynamicType)&quot;)<br>&gt;         handleObject(kind as dynamicType)<br>&gt;     }<br>&gt;<br>&gt; I suspect that handling this use case might pose the most difficulties<br>&gt; when implementing the feature. It might make the whole thing impossible if<br>&gt; there&#39;s no way to resolve types at run-time in compiled code. For example,<br>&gt; if the dispatcher is in a Framework distributed as a binary and the user<br>&gt; does<br>&gt;<br>&gt; class MyClass {}<br>&gt; func handleObject(obj: MyClass) { print &quot;Success!&quot; }<br>&gt;<br>&gt; let stuff = MyClass()<br>&gt; dispatchToHandler(stuff)<br>&gt;<br>&gt; in the project&#39;s code, what would happen?<br>&gt;<br>&gt; Casting to an intermediate type between the static and dynamic types would<br>&gt; fall out naturally, though in that case you&#39;d already have to know the<br>&gt; dynamicType and write the explicit intermediate type name in the code. If<br>&gt; that much is known then it&#39;s possible to cast directly to that intermediate<br>&gt; type with existing syntax.<br>&gt;<br>&gt; Also, it&#39;s worth noting that the &quot;Any&quot; case is only the broadest instance<br>&gt; possible. Anything that passes data along as a super type, by using a<br>&gt; Protocol as a concrete type specifier, etc. could benefit from this<br>&gt; mechanism.<br>&gt;<br>&gt; Mike<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/1c75dd50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ca02c0ca5c5d6a28bc48eebb3b000c7?s=50"></div><header><strong>[Idea] Add dynamicType casting</strong> from <string>Michael Henson</string> &lt;mikehenson at gmail.com&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>Right, yes. That makes sense. It&#39;s clear to me now that this would require<br>adding the ability to dynamically dispatch / resolve method calls at<br>runtime, which is both a huge architectural change and probably<br>incompatible with Swift&#39;s design philosophy, even if the mechanism was<br>well-designed.<br></p><p>The use case that motivated the original idea is still valid, though. This<br>is a problem that is nearly trivial to solve in more dynamic languages, as<br>witnessed in the Objective-C compatibility example, but takes many lines of<br>code and much care to solve properly in Swift.<br></p><p>Mike<br></p><p>On Sat, Jan 9, 2016 at 6:35 AM, 肇鑫 &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; As far as I know, dynamicType is something that doesn&#39;t work until the app<br>&gt; is running the specific code, which means your codes are no longer<br>&gt; protected by the compiler. That is what swift tries to keep you from. So I<br>&gt; believe this should not happen in swift at any time. You should use<br>&gt; dynamicType as little as possible. You should try generics instead of<br>&gt; dynamic type.<br>&gt;<br>&gt; As you said, you&#39;d better to cast it to a protocol instead of dynamicType.<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 12:55 PM, Félix Cloutier &lt;swift-evolution at swift.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; func magic(_ variable: Any) {<br>&gt;&gt; let foo = variable as dynamicType<br>&gt;&gt; // ???<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; magic(&quot;hello&quot;)<br>&gt;&gt; magic(42)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What would be the result of this? What benefit do I get from casting it<br>&gt;&gt; to its dynamic type?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 8 janv. 2016 à 23:40:46, Michael Henson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Currently, the language syntax only allows type identifiers in the<br>&gt;&gt; type-casting-operator productions:<br>&gt;&gt;<br>&gt;&gt; &quot; &quot; surrounds a keyword<br>&gt;&gt;<br>&gt;&gt; type-casting-operator -&gt; &quot;is&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;?&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;!&quot; type<br>&gt;&gt;<br>&gt;&gt; The type production doesn&#39;t allow for expressions which resolve to a<br>&gt;&gt; type, only explicit type references.<br>&gt;&gt;<br>&gt;&gt; So, if you want to refer to the item *as* its dynamic type, there&#39;s no<br>&gt;&gt; direct way to do that unless you declare the name of the type in code:<br>&gt;&gt;<br>&gt;&gt; class Example {}<br>&gt;&gt; var value: Any = Example()<br>&gt;&gt; var again = value as value.dynamicType<br>&gt;&gt; // doesn&#39;t work because value.dynamicType is an expression<br>&gt;&gt;<br>&gt;&gt; It should be possible to upcast to dynamicType immediately with no chance<br>&gt;&gt; of failure. To that end, I suggest adding two productions:<br>&gt;&gt;<br>&gt;&gt; type-casting-operator -&gt; &quot;is&quot; &quot;dynamicType&quot;<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;dynamicType&quot;<br>&gt;&gt;<br>&gt;&gt; Following along the example above, we could then do:<br>&gt;&gt;<br>&gt;&gt; var nowPossible = value as dynamicType<br>&gt;&gt;<br>&gt;&gt; and have nowPossible be Example.Type.<br>&gt;&gt;<br>&gt;&gt; Possible use cases for this functionality include:<br>&gt;&gt;<br>&gt;&gt; 1. Dealing with mixed-type collections from Objective-C code:<br>&gt;&gt;    @[ @&quot;key1&quot;, @5, @&quot;key2&quot;, @20, @&quot;key3&quot;, @[@&quot;red&quot;,@&quot;green&quot;,@&quot;blue&quot;]]<br>&gt;&gt;<br>&gt;&gt; 2. Taking advantage of type-specific polymorphism without having to<br>&gt;&gt; modify code:<br>&gt;&gt;<br>&gt;&gt;     func handleObject(obj: NSNumber) { print(&quot;Number&quot;) }<br>&gt;&gt;     func handleObject(obj: NSData) { print(&quot;Data&quot;) }<br>&gt;&gt;<br>&gt;&gt;     func dispatchToHandler(kind: AnyObject) {<br>&gt;&gt;         print(&quot;dispatching \(kind.dynamicType)&quot;)<br>&gt;&gt;         handleObject(kind as dynamicType)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; I suspect that handling this use case might pose the most difficulties<br>&gt;&gt; when implementing the feature. It might make the whole thing impossible if<br>&gt;&gt; there&#39;s no way to resolve types at run-time in compiled code. For example,<br>&gt;&gt; if the dispatcher is in a Framework distributed as a binary and the user<br>&gt;&gt; does<br>&gt;&gt;<br>&gt;&gt; class MyClass {}<br>&gt;&gt; func handleObject(obj: MyClass) { print &quot;Success!&quot; }<br>&gt;&gt;<br>&gt;&gt; let stuff = MyClass()<br>&gt;&gt; dispatchToHandler(stuff)<br>&gt;&gt;<br>&gt;&gt; in the project&#39;s code, what would happen?<br>&gt;&gt;<br>&gt;&gt; Casting to an intermediate type between the static and dynamic types<br>&gt;&gt; would fall out naturally, though in that case you&#39;d already have to know<br>&gt;&gt; the dynamicType and write the explicit intermediate type name in the code.<br>&gt;&gt; If that much is known then it&#39;s possible to cast directly to that<br>&gt;&gt; intermediate type with existing syntax.<br>&gt;&gt;<br>&gt;&gt; Also, it&#39;s worth noting that the &quot;Any&quot; case is only the broadest instance<br>&gt;&gt; possible. Anything that passes data along as a super type, by using a<br>&gt;&gt; Protocol as a concrete type specifier, etc. could benefit from this<br>&gt;&gt; mechanism.<br>&gt;&gt;<br>&gt;&gt; Mike<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Owen Zhao<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/b5115805/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Idea] Add dynamicType casting</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  9, 2016 at 02:00:00pm</p></header><div class="content"><p>You may be thinking of something like C#&#39;s `dynamic` type. The C# compiler defers all checks, method resolution and overload resolution at runtime when a `dynamic` object is encountered.<br></p><p>I haven&#39;t used it a lot and I don&#39;t think that Swift would benefit a lot from it. However, it makes it easier to pick the &quot;best&quot; overload based on the runtime type: if you have Foo methods for 10-15 types, you can do Foo((dynamic)obj) to pick the appropriate one without a type switch.<br></p><p>Félix<br></p><p>&gt; Le 9 janv. 2016 à 14:21:50, Michael Henson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Right, yes. That makes sense. It&#39;s clear to me now that this would require adding the ability to dynamically dispatch / resolve method calls at runtime, which is both a huge architectural change and probably incompatible with Swift&#39;s design philosophy, even if the mechanism was well-designed.<br>&gt; <br>&gt; The use case that motivated the original idea is still valid, though. This is a problem that is nearly trivial to solve in more dynamic languages, as witnessed in the Objective-C compatibility example, but takes many lines of code and much care to solve properly in Swift.<br>&gt; <br>&gt; Mike<br>&gt; <br>&gt; On Sat, Jan 9, 2016 at 6:35 AM, 肇鑫 &lt;owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;&gt; wrote:<br>&gt; As far as I know, dynamicType is something that doesn&#39;t work until the app is running the specific code, which means your codes are no longer protected by the compiler. That is what swift tries to keep you from. So I believe this should not happen in swift at any time. You should use dynamicType as little as possible. You should try generics instead of dynamic type.<br>&gt; <br>&gt; As you said, you&#39;d better to cast it to a protocol instead of dynamicType.<br>&gt; <br>&gt; zhaoxin<br>&gt; <br>&gt; On Sat, Jan 9, 2016 at 12:55 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; func magic(_ variable: Any) {<br>&gt;&gt; 	let foo = variable as dynamicType<br>&gt;&gt; 	// ???<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; magic(&quot;hello&quot;)<br>&gt;&gt; magic(42)<br>&gt; <br>&gt; What would be the result of this? What benefit do I get from casting it to its dynamic type?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 8 janv. 2016 à 23:40:46, Michael Henson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Currently, the language syntax only allows type identifiers in the type-casting-operator productions:<br>&gt;&gt; <br>&gt;&gt; &quot; &quot; surrounds a keyword<br>&gt;&gt; <br>&gt;&gt; type-casting-operator -&gt; &quot;is&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;?&quot; type<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;!&quot; type<br>&gt;&gt; <br>&gt;&gt; The type production doesn&#39;t allow for expressions which resolve to a type, only explicit type references.<br>&gt;&gt; <br>&gt;&gt; So, if you want to refer to the item *as* its dynamic type, there&#39;s no direct way to do that unless you declare the name of the type in code:<br>&gt;&gt; <br>&gt;&gt; class Example {}<br>&gt;&gt; var value: Any = Example()<br>&gt;&gt; var again = value as value.dynamicType<br>&gt;&gt; // doesn&#39;t work because value.dynamicType is an expression<br>&gt;&gt; <br>&gt;&gt; It should be possible to upcast to dynamicType immediately with no chance of failure. To that end, I suggest adding two productions:<br>&gt;&gt; <br>&gt;&gt; type-casting-operator -&gt; &quot;is&quot; &quot;dynamicType&quot;<br>&gt;&gt; type-casting-operator -&gt; &quot;as&quot; &quot;dynamicType&quot;<br>&gt;&gt; <br>&gt;&gt; Following along the example above, we could then do:<br>&gt;&gt; <br>&gt;&gt; var nowPossible = value as dynamicType<br>&gt;&gt; <br>&gt;&gt; and have nowPossible be Example.Type.<br>&gt;&gt; <br>&gt;&gt; Possible use cases for this functionality include:<br>&gt;&gt; <br>&gt;&gt; 1. Dealing with mixed-type collections from Objective-C code:<br>&gt;&gt;    @[ @&quot;key1&quot;, @5, @&quot;key2&quot;, @20, @&quot;key3&quot;, @[@&quot;red&quot;,@&quot;green&quot;,@&quot;blue&quot;]]<br>&gt;&gt; <br>&gt;&gt; 2. Taking advantage of type-specific polymorphism without having to modify code:<br>&gt;&gt; <br>&gt;&gt;     func handleObject(obj: NSNumber) { print(&quot;Number&quot;) }<br>&gt;&gt;     func handleObject(obj: NSData) { print(&quot;Data&quot;) }<br>&gt;&gt; <br>&gt;&gt;     func dispatchToHandler(kind: AnyObject) {<br>&gt;&gt;         print(&quot;dispatching \(kind.dynamicType)&quot;)<br>&gt;&gt;         handleObject(kind as dynamicType)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; I suspect that handling this use case might pose the most difficulties when implementing the feature. It might make the whole thing impossible if there&#39;s no way to resolve types at run-time in compiled code. For example, if the dispatcher is in a Framework distributed as a binary and the user does<br>&gt;&gt; <br>&gt;&gt; class MyClass {}<br>&gt;&gt; func handleObject(obj: MyClass) { print &quot;Success!&quot; }<br>&gt;&gt; <br>&gt;&gt; let stuff = MyClass()<br>&gt;&gt; dispatchToHandler(stuff)<br>&gt;&gt; <br>&gt;&gt; in the project&#39;s code, what would happen?<br>&gt;&gt; <br>&gt;&gt; Casting to an intermediate type between the static and dynamic types would fall out naturally, though in that case you&#39;d already have to know the dynamicType and write the explicit intermediate type name in the code. If that much is known then it&#39;s possible to cast directly to that intermediate type with existing syntax.<br>&gt;&gt; <br>&gt;&gt; Also, it&#39;s worth noting that the &quot;Any&quot; case is only the broadest instance possible. Anything that passes data along as a super type, by using a Protocol as a concrete type specifier, etc. could benefit from this mechanism.<br>&gt;&gt; <br>&gt;&gt; Mike<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; <br>&gt; Owen Zhao<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/d04c88b5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
