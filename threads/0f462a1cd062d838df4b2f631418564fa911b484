<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17f3e4010ef1b1ed65d4926cbb191b2f?s=50"></div><header><strong>Counting in Threads</strong> from <string>Gerriet M. Denkmann</string> &lt;g at mdenkmann.de&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>How to translate this to Swift:<br></p><p>__block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>dispatch_apply( nbrInterations, queue, ^void(size_t idx)	<br>	{<br>		uint64_t tCount = 0;<br>		... do some counting ...<br>		atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>	}<br>)<br></p><p>Currently I am using:<br></p><p>var counter: UInt64 = 0<br>let dsema = DispatchSemaphore(value: 1)  <br>DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>{ ( idx: size_t) -&gt; Void in<br>			<br>	var tCount: UInt64 = 0<br>	... do some counting ...<br>	_ = dsema.wait(timeout: .distantFuture) <br>	counter += tCount;<br>	dsema.signal()  <br>}<br></p><p>Is there a better way?<br></p><p>Gerriet.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Counting in Threads</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 12, 2016 at 08:00:00am</p></header><div class="content"><p>I suspect one of the actual compiler people might tell me I shouldn&#39;t trust this, but in practice it works:<br>--<br>import Darwin.C<br></p><p>public class AtomicInt32 {<br>    public fileprivate (set) var value : Int32 = 0<br>    <br>    /// Create a new atomic integer with the specified initial value.<br>    public init(_ value: Int32 = 0) {<br>        self.value = value<br>    }<br>    <br>    /// Add one to the value.<br>    public func increment () {<br>        OSAtomicIncrement32(&amp;value)<br>    }<br>}<br></p><p>public func +=(int: AtomicInt32, value: Int32) {<br>    OSAtomicAdd32(value, &amp;int.value)<br>}<br>--<br></p><p>Would also love to know if compiler guarantees I *can* trust this.<br></p><p>Note that this has to be a class for this to be in any way safe, which means it is also rather inefficient if the use case was having a lot of them.<br></p><p> - Daniel<br></p><p>&gt; On Oct 12, 2016, at 12:47 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; How to translate this to Swift:<br>&gt; <br>&gt; __block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>&gt; dispatch_apply( nbrInterations, queue, ^void(size_t idx)	<br>&gt; 	{<br>&gt; 		uint64_t tCount = 0;<br>&gt; 		... do some counting ...<br>&gt; 		atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>&gt; 	}<br>&gt; )<br>&gt; <br>&gt; Currently I am using:<br>&gt; <br>&gt; var counter: UInt64 = 0<br>&gt; let dsema = DispatchSemaphore(value: 1)  <br>&gt; DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>&gt; { ( idx: size_t) -&gt; Void in<br>&gt; 			<br>&gt; 	var tCount: UInt64 = 0<br>&gt; 	... do some counting ...<br>&gt; 	_ = dsema.wait(timeout: .distantFuture) <br>&gt; 	counter += tCount;<br>&gt; 	dsema.signal()  <br>&gt; }<br>&gt; <br>&gt; Is there a better way?<br>&gt; <br>&gt; Gerriet.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Counting in Threads</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>October 12, 2016 at 08:00:00am</p></header><div class="content"><p>I was under the impression that taking the address was more than a single load instruction and would emit a placeholder invalid value: which would make that technically unsafe in a threaded context.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Oct 12, 2016, at 8:18 AM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I suspect one of the actual compiler people might tell me I shouldn&#39;t trust this, but in practice it works:<br>&gt; --<br>&gt; import Darwin.C<br>&gt; <br>&gt; public class AtomicInt32 {<br>&gt;    public fileprivate (set) var value : Int32 = 0<br>&gt; <br>&gt;    /// Create a new atomic integer with the specified initial value.<br>&gt;    public init(_ value: Int32 = 0) {<br>&gt;        self.value = value<br>&gt;    }<br>&gt; <br>&gt;    /// Add one to the value.<br>&gt;    public func increment () {<br>&gt;        OSAtomicIncrement32(&amp;value)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; public func +=(int: AtomicInt32, value: Int32) {<br>&gt;    OSAtomicAdd32(value, &amp;int.value)<br>&gt; }<br>&gt; --<br>&gt; <br>&gt; Would also love to know if compiler guarantees I *can* trust this.<br>&gt; <br>&gt; Note that this has to be a class for this to be in any way safe, which means it is also rather inefficient if the use case was having a lot of them.<br>&gt; <br>&gt; - Daniel<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 12:47 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; How to translate this to Swift:<br>&gt;&gt; <br>&gt;&gt; __block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>&gt;&gt; dispatch_apply( nbrInterations, queue, ^void(size_t idx)    <br>&gt;&gt;    {<br>&gt;&gt;        uint64_t tCount = 0;<br>&gt;&gt;        ... do some counting ...<br>&gt;&gt;        atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>&gt;&gt;    }<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; Currently I am using:<br>&gt;&gt; <br>&gt;&gt; var counter: UInt64 = 0<br>&gt;&gt; let dsema = DispatchSemaphore(value: 1)  <br>&gt;&gt; DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>&gt;&gt; { ( idx: size_t) -&gt; Void in<br>&gt;&gt;            <br>&gt;&gt;    var tCount: UInt64 = 0<br>&gt;&gt;    ... do some counting ...<br>&gt;&gt;    _ = dsema.wait(timeout: .distantFuture) <br>&gt;&gt;    counter += tCount;<br>&gt;&gt;    dsema.signal()  <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is there a better way?<br>&gt;&gt; <br>&gt;&gt; Gerriet.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/0fc5833b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Counting in Threads</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>October 12, 2016 at 11:00:00pm</p></header><div class="content"><p>So we would have to drop down to C code, etc. to safely leverage OSAtomic?<br></p><p>On Wed, Oct 12, 2016 at 8:32 AM Philippe Hausler via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I was under the impression that taking the address was more than a single<br>&gt; load instruction and would emit a placeholder invalid value: which would<br>&gt; make that technically unsafe in a threaded context.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Oct 12, 2016, at 8:18 AM, Daniel Dunbar via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I suspect one of the actual compiler people might tell me I shouldn&#39;t<br>&gt; trust this, but in practice it works:<br>&gt; --<br>&gt; import Darwin.C<br>&gt;<br>&gt; public class AtomicInt32 {<br>&gt;    public fileprivate (set) var value : Int32 = 0<br>&gt;<br>&gt;    /// Create a new atomic integer with the specified initial value.<br>&gt;    public init(_ value: Int32 = 0) {<br>&gt;        self.value = value<br>&gt;    }<br>&gt;<br>&gt;    /// Add one to the value.<br>&gt;    public func increment () {<br>&gt;        OSAtomicIncrement32(&amp;value)<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; public func +=(int: AtomicInt32, value: Int32) {<br>&gt;    OSAtomicAdd32(value, &amp;int.value)<br>&gt; }<br>&gt; --<br>&gt;<br>&gt; Would also love to know if compiler guarantees I *can* trust this.<br>&gt;<br>&gt; Note that this has to be a class for this to be in any way safe, which<br>&gt; means it is also rather inefficient if the use case was having a lot of<br>&gt; them.<br>&gt;<br>&gt; - Daniel<br>&gt;<br>&gt; On Oct 12, 2016, at 12:47 AM, Gerriet M. Denkmann via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; How to translate this to Swift:<br>&gt;<br>&gt;<br>&gt; __block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>&gt;<br>&gt; dispatch_apply( nbrInterations, queue, ^void(size_t idx)<br>&gt;<br>&gt;    {<br>&gt;<br>&gt;        uint64_t tCount = 0;<br>&gt;<br>&gt;        ... do some counting ...<br>&gt;<br>&gt;        atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>&gt;<br>&gt;    }<br>&gt;<br>&gt; )<br>&gt;<br>&gt;<br>&gt; Currently I am using:<br>&gt;<br>&gt;<br>&gt; var counter: UInt64 = 0<br>&gt;<br>&gt; let dsema = DispatchSemaphore(value: 1)<br>&gt;<br>&gt; DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>&gt;<br>&gt; { ( idx: size_t) -&gt; Void in<br>&gt;<br>&gt;<br>&gt;<br>&gt;    var tCount: UInt64 = 0<br>&gt;<br>&gt;    ... do some counting ...<br>&gt;<br>&gt;    _ = dsema.wait(timeout: .distantFuture)<br>&gt;<br>&gt;    counter += tCount;<br>&gt;<br>&gt;    dsema.signal()<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Is there a better way?<br>&gt;<br>&gt;<br>&gt; Gerriet.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-users mailing list<br>&gt;<br>&gt; swift-users at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/35901812/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Counting in Threads</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>October 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Or allocate a pointer for it. The other alternative would be NSLock but that might be swatting flies with sledgehammers. We had a similar issue implementing NSLock in swift-corelibs-foundation where taking the address of a pthread mutex corrupted the structure for when another thread would attempt to grab it.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Oct 12, 2016, at 4:45 PM, Shawn Erickson &lt;shawnce at gmail.com&gt; wrote:<br>&gt; <br>&gt; So we would have to drop down to C code, etc. to safely leverage OSAtomic?<br>&gt; <br>&gt;&gt; On Wed, Oct 12, 2016 at 8:32 AM Philippe Hausler via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; I was under the impression that taking the address was more than a single load instruction and would emit a placeholder invalid value: which would make that technically unsafe in a threaded context.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 8:18 AM, Daniel Dunbar via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suspect one of the actual compiler people might tell me I shouldn&#39;t trust this, but in practice it works:<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; import Darwin.C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class AtomicInt32 {<br>&gt;&gt;&gt;    public fileprivate (set) var value : Int32 = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    /// Create a new atomic integer with the specified initial value.<br>&gt;&gt;&gt;    public init(_ value: Int32 = 0) {<br>&gt;&gt;&gt;        self.value = value<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    /// Add one to the value.<br>&gt;&gt;&gt;    public func increment () {<br>&gt;&gt;&gt;        OSAtomicIncrement32(&amp;value)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func +=(int: AtomicInt32, value: Int32) {<br>&gt;&gt;&gt;    OSAtomicAdd32(value, &amp;int.value)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would also love to know if compiler guarantees I *can* trust this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that this has to be a class for this to be in any way safe, which means it is also rather inefficient if the use case was having a lot of them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 12, 2016, at 12:47 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How to translate this to Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; __block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>&gt;&gt;&gt;&gt; dispatch_apply( nbrInterations, queue, ^void(size_t idx)    <br>&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;        uint64_t tCount = 0;<br>&gt;&gt;&gt;&gt;        ... do some counting ...<br>&gt;&gt;&gt;&gt;        atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently I am using:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var counter: UInt64 = 0<br>&gt;&gt;&gt;&gt; let dsema = DispatchSemaphore(value: 1)  <br>&gt;&gt;&gt;&gt; DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>&gt;&gt;&gt;&gt; { ( idx: size_t) -&gt; Void in<br>&gt;&gt;&gt;&gt;            <br>&gt;&gt;&gt;&gt;    var tCount: UInt64 = 0<br>&gt;&gt;&gt;&gt;    ... do some counting ...<br>&gt;&gt;&gt;&gt;    _ = dsema.wait(timeout: .distantFuture) <br>&gt;&gt;&gt;&gt;    counter += tCount;<br>&gt;&gt;&gt;&gt;    dsema.signal()  <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a better way?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gerriet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/5f486425/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Counting in Threads</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>October 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Not in this case, today:<br>--<br>$ cat x.swift <br>import Darwin.C<br></p><p>public class AtomicInt32 {<br>   public fileprivate (set) var value : Int32 = 0<br></p><p>   /// Create a new atomic integer with the specified initial value.<br>   public init(_ value: Int32 = 0) {<br>       self.value = value<br>   }<br></p><p>   /// Add one to the value.<br>   public func increment () {<br>       OSAtomicIncrement32(&amp;value)<br>   }<br>}<br></p><p>$ swiftc -S -o - x.swift -O | grep &#39;.globl	__TFC4main11AtomicInt329incrementfT_T_&#39; -A16<br>	.globl	__TFC4main11AtomicInt329incrementfT_T_<br>	.align	4, 0x90<br>__TFC4main11AtomicInt329incrementfT_T_:<br>	.cfi_startproc<br>	pushq	%rbp<br>Ltmp4:<br>	.cfi_def_cfa_offset 16<br>Ltmp5:<br>	.cfi_offset %rbp, -16<br>	movq	%rsp, %rbp<br>Ltmp6:<br>	.cfi_def_cfa_register %rbp<br>	leaq	16(%rdi), %rsi<br>	movl	$1, %edi<br>	popq	%rbp<br>	jmp	_OSAtomicAdd32<br>	.cfi_endproc<br>--<br></p><p> - Daniel<br></p><p>&gt; On Oct 12, 2016, at 8:31 AM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; I was under the impression that taking the address was more than a single load instruction and would emit a placeholder invalid value: which would make that technically unsafe in a threaded context.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Oct 12, 2016, at 8:18 AM, Daniel Dunbar via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I suspect one of the actual compiler people might tell me I shouldn&#39;t trust this, but in practice it works:<br>&gt;&gt; --<br>&gt;&gt; import Darwin.C<br>&gt;&gt; <br>&gt;&gt; public class AtomicInt32 {<br>&gt;&gt;    public fileprivate (set) var value : Int32 = 0<br>&gt;&gt; <br>&gt;&gt;    /// Create a new atomic integer with the specified initial value.<br>&gt;&gt;    public init(_ value: Int32 = 0) {<br>&gt;&gt;        self.value = value<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    /// Add one to the value.<br>&gt;&gt;    public func increment () {<br>&gt;&gt;        OSAtomicIncrement32(&amp;value)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func +=(int: AtomicInt32, value: Int32) {<br>&gt;&gt;    OSAtomicAdd32(value, &amp;int.value)<br>&gt;&gt; }<br>&gt;&gt; --<br>&gt;&gt; <br>&gt;&gt; Would also love to know if compiler guarantees I *can* trust this.<br>&gt;&gt; <br>&gt;&gt; Note that this has to be a class for this to be in any way safe, which means it is also rather inefficient if the use case was having a lot of them.<br>&gt;&gt; <br>&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 12, 2016, at 12:47 AM, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How to translate this to Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; __block atomic_uint_fast64_t counter = ATOMIC_VAR_INIT(0);<br>&gt;&gt;&gt; dispatch_apply( nbrInterations, queue, ^void(size_t idx)    <br>&gt;&gt;&gt;    {<br>&gt;&gt;&gt;        uint64_t tCount = 0;<br>&gt;&gt;&gt;        ... do some counting ...<br>&gt;&gt;&gt;        atomic_fetch_add_explicit( &amp;counter, tCount, memory_order_relaxed );<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently I am using:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var counter: UInt64 = 0<br>&gt;&gt;&gt; let dsema = DispatchSemaphore(value: 1)  <br>&gt;&gt;&gt; DispatchQueue.concurrentPerform( iterations: nbrInterations )<br>&gt;&gt;&gt; { ( idx: size_t) -&gt; Void in<br>&gt;&gt;&gt;            <br>&gt;&gt;&gt;    var tCount: UInt64 = 0<br>&gt;&gt;&gt;    ... do some counting ...<br>&gt;&gt;&gt;    _ = dsema.wait(timeout: .distantFuture) <br>&gt;&gt;&gt;    counter += tCount;<br>&gt;&gt;&gt;    dsema.signal()  <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a better way?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gerriet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161012/0ea8c0bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
