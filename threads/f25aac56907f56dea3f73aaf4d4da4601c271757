<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4729f8a9e7a01004252415f089ecdff7?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Daniel Hooper</string> &lt;danielchasehooper at gmail.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot; optionals<br> - this works by creating a new non-optional variable to be used by future<br>code. Often, the new variable is given the same name as the original<br>optional variable, creating a shadow variable. This approach leads to odd<br>looking code like this:<br></p><p>if let nearestX = nearestX { closest = nearestX }<br>guard let layer = layer else { continue }<br>// use layer<br></p><p>At a glance, and to Swift newcomers, this code looks completely<br>non-sensical. It&#39;s also verbose for simply ensuring the variable is<br>non-nil.<br></p><p>The solution:<br>Swift should generate unwrapped shadow variables after nil checking. The<br>compiler would treat the below code as if it had created an unwrapped<br>shadow variable.<br></p><p>if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t<br>force unwrapped<br>guard layer != nil else { continue }<br>// use layer, without force unwrapping<br></p><p>Why force unwrapping isn&#39;t a good alternative:<br>You might suggest force unwrapping variables when they&#39;re inside an if or<br>after a guard that checks for nil. While this does allow for the &quot;layer =<br>nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>that this code was written:<br></p><p>{code:java}<br>if layer != nil {<br>// lots of code before //<br>layer!.backgroundColor = newColor<br>// lots of code after //<br>}<br>{code}<br></p><p>And much later, you need to use some of the the code in the if body<br>elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>it into an if that checked layer for nil. So you get a crash. Because of<br>this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>as possible, and minimize the situations that you would need to force<br>unwrap.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/f25a1757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br></p><p>	if let foo = foo { /* use foo */ }<br></p><p>could become this code:<br></p><p>	if let foo { /* use foo */ }<br></p><p>In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot; optionals  - this works by creating a new non-optional variable to be used by future code. Often, the new variable is given the same name as the original optional variable, creating a shadow variable. This approach leads to odd looking code like this:<br>&gt; <br>&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; guard let layer = layer else { continue } <br>&gt; // use layer<br>&gt; <br>&gt; At a glance, and to Swift newcomers, this code looks completely non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil. <br>&gt; <br>&gt; The solution:<br>&gt; Swift should generate unwrapped shadow variables after nil checking. The compiler would treat the below code as if it had created an unwrapped shadow variable.<br>&gt; <br>&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t force unwrapped<br>&gt; guard layer != nil else { continue } <br>&gt; // use layer, without force unwrapping<br>&gt; <br>&gt; Why force unwrapping isn&#39;t a good alternative: <br>&gt; You might suggest force unwrapping variables when they&#39;re inside an if or after a guard that checks for nil. While this does allow for the &quot;layer = nil&quot; syntax, it results in code that is less resilient to change. Imagine that this code was written:<br>&gt; <br>&gt; {code:java}<br>&gt; if layer != nil {<br>&gt; // lots of code before //<br>&gt; layer!.backgroundColor = newColor<br>&gt; // lots of code after //<br>&gt; }<br>&gt; {code}<br>&gt; <br>&gt; And much later, you need to use some of the the code in the if body elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste it into an if that checked layer for nil. So you get a crash. Because of this, it&#39;s important we make safe optional unwrapping as easy and sensical as possible, and minimize the situations that you would need to force unwrap.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/72e9dec4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>One problem with dropping if/guard let is something like this:<br></p><p>if let x = a?.b.c?.d, y = something(x) {<br>   …<br>}<br></p><p>would then have to become this:<br></p><p>let x = a?.b.c?.d<br>if x != nil {<br>   let y = something(x)<br>   if y != nil {<br>       …<br>   }<br>}<br></p><p>I&#39;m fine with<br>   if let x<br>as a shortcut for<br>   if let x = x<br></p><p>It just reads a bit weird - like declaring an immutable variable with no<br>type and no value.<br></p><p><br>On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt; altogether, another approach would be to use the existing name if no new<br>&gt; name is given, so that this code:<br>&gt;<br>&gt; if let foo = foo { /* use foo */ }<br>&gt;<br>&gt; could become this code:<br>&gt;<br>&gt; if let foo { /* use foo */ }<br>&gt;<br>&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt; another name with the if let syntax, that would work as it does today.<br>&gt;<br>&gt;<br>&gt; Jeff Kelley<br>&gt;<br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; |<br>&gt; jeffkelley.org<br>&gt;<br>&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if<br>&gt; let&quot; optionals  - this works by creating a new non-optional variable to be<br>&gt; used by future code. Often, the new variable is given the same name as the<br>&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt; to odd looking code like this:<br>&gt;<br>&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; guard let layer = layer else { continue }<br>&gt; // use layer<br>&gt;<br>&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is<br>&gt; non-nil.<br>&gt;<br>&gt; The solution:<br>&gt; Swift should generate unwrapped shadow variables after nil checking. The<br>&gt; compiler would treat the below code as if it had created an unwrapped<br>&gt; shadow variable.<br>&gt;<br>&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t<br>&gt; force unwrapped<br>&gt; guard layer != nil else { continue }<br>&gt; // use layer, without force unwrapping<br>&gt;<br>&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt; You might suggest force unwrapping variables when they&#39;re inside an if or<br>&gt; after a guard that checks for nil. While this does allow for the &quot;layer =<br>&gt; nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>&gt; that this code was written:<br>&gt;<br>&gt; {code:java}<br>&gt; if layer != nil {<br>&gt; // lots of code before //<br>&gt; layer!.backgroundColor = newColor<br>&gt; // lots of code after //<br>&gt; }<br>&gt; {code}<br>&gt;<br>&gt; And much later, you need to use some of the the code in the if body<br>&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt; as possible, and minimize the situations that you would need to force<br>&gt; unwrap.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/933d168a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>This has come up a few times. I’ve thrown my 2cents into a variant of “with” to solve this rather than messing with the meaning of if-let:<br></p><p>For example:<br></p><p>var x: MyType?<br></p><p>with x {<br>  x.someFunction()		// okay - this entire block is skipped if “x” is nil anyway<br>}<br>x.someFunction()		// not okay as-is since x is optional<br></p><p><br>Using the definition  of “with” from Erica’s Method Cascading proposal https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop the variable reference itself from inside the block body:<br></p><p>with x {<br>  someFunction()		// would call “someFunction()” on “x”<br>}<br></p><p><br>And I’d additionally propose that if you wanted to replace if-let-else, you could potentially do this:<br></p><p>if with x {<br>  // x is known non-nil<br>} else {<br>  // x is known to be nil<br>}<br>// x is optional and nil-ness is unknown<br></p><p><br>l8r<br>Sean<br></p><p><br>&gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One problem with dropping if/guard let is something like this:<br>&gt; <br>&gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt;    …<br>&gt; }<br>&gt; <br>&gt; would then have to become this:<br>&gt; <br>&gt; let x = a?.b.c?.d<br>&gt; if x != nil {<br>&gt;    let y = something(x)<br>&gt;    if y != nil {<br>&gt;        …<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I&#39;m fine with<br>&gt;    if let x<br>&gt; as a shortcut for<br>&gt;    if let x = x<br>&gt; <br>&gt; It just reads a bit weird - like declaring an immutable variable with no type and no value.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt; <br>&gt; 	if let foo = foo { /* use foo */ }<br>&gt; <br>&gt; could become this code:<br>&gt; <br>&gt; 	if let foo { /* use foo */ }<br>&gt; <br>&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot; optionals  - this works by creating a new non-optional variable to be used by future code. Often, the new variable is given the same name as the original optional variable, creating a shadow variable. This approach leads to odd looking code like this:<br>&gt;&gt; <br>&gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt;&gt; guard let layer = layer else { continue } <br>&gt;&gt; // use layer<br>&gt;&gt; <br>&gt;&gt; At a glance, and to Swift newcomers, this code looks completely non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil. <br>&gt;&gt; <br>&gt;&gt; The solution:<br>&gt;&gt; Swift should generate unwrapped shadow variables after nil checking. The compiler would treat the below code as if it had created an unwrapped shadow variable.<br>&gt;&gt; <br>&gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t force unwrapped<br>&gt;&gt; guard layer != nil else { continue } <br>&gt;&gt; // use layer, without force unwrapping<br>&gt;&gt; <br>&gt;&gt; Why force unwrapping isn&#39;t a good alternative: <br>&gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an if or after a guard that checks for nil. While this does allow for the &quot;layer = nil&quot; syntax, it results in code that is less resilient to change. Imagine that this code was written:<br>&gt;&gt; <br>&gt;&gt; {code:java}<br>&gt;&gt; if layer != nil {<br>&gt;&gt; // lots of code before //<br>&gt;&gt; layer!.backgroundColor = newColor<br>&gt;&gt; // lots of code after //<br>&gt;&gt; }<br>&gt;&gt; {code}<br>&gt;&gt; <br>&gt;&gt; And much later, you need to use some of the the code in the if body elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste it into an if that checked layer for nil. So you get a crash. Because of this, it&#39;s important we make safe optional unwrapping as easy and sensical as possible, and minimize the situations that you would need to force unwrap.<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>So guard let x = x would become without x or guard with x else? :)<br></p><p>Seems weird to have two control statements which do almost the same thing:<br></p><p>   - if (for any conditions) + with (for a subset of things doable with if)<br>   - guard (for any conditions) + without (for a subset of<br>   things doable with guard)<br></p><p>Also with/without would have to carry over the where clause which basically<br>is a if too.<br></p><p>And with multiple assignments Erica&#39;s proposal would not work anymore.<br></p><p>As in my previous example (made a bit larger to showcase where):<br></p><p>with x = a?.b.c?.d where !x.isEmpty, y = something(x) {<br>   // the scope cannot reference to both (x and y) now<br>}<br></p><p><br>Btw. there was a rather short discussion<br>&lt;https://forums.developer.apple.com/thread/5786&gt; in Apple Developer Forums<br>some time ago too.<br></p><p>On Fri, Dec 11, 2015 at 5:40 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; This has come up a few times. I’ve thrown my 2cents into a variant of<br>&gt; “with” to solve this rather than messing with the meaning of if-let:<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; var x: MyType?<br>&gt;<br>&gt; with x {<br>&gt;   x.someFunction()              // okay - this entire block is skipped if<br>&gt; “x” is nil anyway<br>&gt; }<br>&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt;<br>&gt;<br>&gt; Using the definition  of “with” from Erica’s Method Cascading proposal<br>&gt; https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop<br>&gt; the variable reference itself from inside the block body:<br>&gt;<br>&gt; with x {<br>&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And I’d additionally propose that if you wanted to replace if-let-else,<br>&gt; you could potentially do this:<br>&gt;<br>&gt; if with x {<br>&gt;   // x is known non-nil<br>&gt; } else {<br>&gt;   // x is known to be nil<br>&gt; }<br>&gt; // x is optional and nil-ness is unknown<br>&gt;<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt; &gt;<br>&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt; &gt;    …<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; would then have to become this:<br>&gt; &gt;<br>&gt; &gt; let x = a?.b.c?.d<br>&gt; &gt; if x != nil {<br>&gt; &gt;    let y = something(x)<br>&gt; &gt;    if y != nil {<br>&gt; &gt;        …<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I&#39;m fine with<br>&gt; &gt;    if let x<br>&gt; &gt; as a shortcut for<br>&gt; &gt;    if let x = x<br>&gt; &gt;<br>&gt; &gt; It just reads a bit weird - like declaring an immutable variable with no<br>&gt; type and no value.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt; altogether, another approach would be to use the existing name if no new<br>&gt; name is given, so that this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; could become this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt; another name with the if let syntax, that would work as it does today.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Jeff Kelley<br>&gt; &gt;<br>&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot;<br>&gt; optionals  - this works by creating a new non-optional variable to be used<br>&gt; by future code. Often, the new variable is given the same name as the<br>&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt; to odd looking code like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt; &gt;&gt; // use layer<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The solution:<br>&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking.<br>&gt; The compiler would treat the below code as if it had created an unwrapped<br>&gt; shadow variable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t<br>&gt; force unwrapped<br>&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an if<br>&gt; or after a guard that checks for nil. While this does allow for the &quot;layer<br>&gt; = nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>&gt; that this code was written:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; {code:java}<br>&gt; &gt;&gt; if layer != nil {<br>&gt; &gt;&gt; // lots of code before //<br>&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt; &gt;&gt; // lots of code after //<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; {code}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And much later, you need to use some of the the code in the if body<br>&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt; as possible, and minimize the situations that you would need to force<br>&gt; unwrap.<br>&gt; &gt;&gt;  _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/85a6a271/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>I would not have “without” - only “with”.  If you wanted to put it into a guard, I’d go with guard-with. If the *only* intent of the “with&quot; keyword was to unwrap-in-place (basically), then I’d imagine it would *only* work inside an if or guard and not stand on its own. If it was combined with Erica’s proposal, I think it could stand on its own, though.<br></p><p>&gt; with x = a?.b.c?.d where !x.isEmpty, y = something(x) {<br>&gt;    // the scope cannot reference to both (x and y) now<br>&gt; }<br></p><p><br>If you’re declaring “x” for the first time, you’d have to have a let/var in there.<br></p><p>with let x = &lt;potentially optional expression&gt;, y = &lt;another optional expression&gt; where &lt;cond&gt; {}<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 11, 2015, at 10:52 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; So guard let x = x would become without x or guard with x else? :)<br>&gt; <br>&gt; Seems weird to have two control statements which do almost the same thing:<br>&gt; 	• if (for any conditions) + with (for a subset of things doable with if)<br>&gt; 	• guard (for any conditions) + without (for a subset of things doable with guard)<br>&gt; Also with/without would have to carry over the where clause which basically is a if too.<br>&gt; <br>&gt; And with multiple assignments Erica&#39;s proposal would not work anymore.<br>&gt; <br>&gt; As in my previous example (made a bit larger to showcase where):<br>&gt; <br>&gt; <br>&gt; <br>&gt; Btw. there was a rather short discussion in Apple Developer Forums some time ago too.<br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 5:40 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; This has come up a few times. I’ve thrown my 2cents into a variant of “with” to solve this rather than messing with the meaning of if-let:<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; var x: MyType?<br>&gt; <br>&gt; with x {<br>&gt;   x.someFunction()              // okay - this entire block is skipped if “x” is nil anyway<br>&gt; }<br>&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt; <br>&gt; <br>&gt; Using the definition  of “with” from Erica’s Method Cascading proposal https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop the variable reference itself from inside the block body:<br>&gt; <br>&gt; with x {<br>&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt; }<br>&gt; <br>&gt; <br>&gt; And I’d additionally propose that if you wanted to replace if-let-else, you could potentially do this:<br>&gt; <br>&gt; if with x {<br>&gt;   // x is known non-nil<br>&gt; } else {<br>&gt;   // x is known to be nil<br>&gt; }<br>&gt; // x is optional and nil-ness is unknown<br>&gt; <br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt; &gt;<br>&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt; &gt;    …<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; would then have to become this:<br>&gt; &gt;<br>&gt; &gt; let x = a?.b.c?.d<br>&gt; &gt; if x != nil {<br>&gt; &gt;    let y = something(x)<br>&gt; &gt;    if y != nil {<br>&gt; &gt;        …<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I&#39;m fine with<br>&gt; &gt;    if let x<br>&gt; &gt; as a shortcut for<br>&gt; &gt;    if let x = x<br>&gt; &gt;<br>&gt; &gt; It just reads a bit weird - like declaring an immutable variable with no type and no value.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; could become this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Jeff Kelley<br>&gt; &gt;<br>&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot; optionals  - this works by creating a new non-optional variable to be used by future code. Often, the new variable is given the same name as the original optional variable, creating a shadow variable. This approach leads to odd looking code like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt; &gt;&gt; // use layer<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The solution:<br>&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking. The compiler would treat the below code as if it had created an unwrapped shadow variable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t force unwrapped<br>&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an if or after a guard that checks for nil. While this does allow for the &quot;layer = nil&quot; syntax, it results in code that is less resilient to change. Imagine that this code was written:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; {code:java}<br>&gt; &gt;&gt; if layer != nil {<br>&gt; &gt;&gt; // lots of code before //<br>&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt; &gt;&gt; // lots of code after //<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; {code}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And much later, you need to use some of the the code in the if body elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste it into an if that checked layer for nil. So you get a crash. Because of this, it&#39;s important we make safe optional unwrapping as easy and sensical as possible, and minimize the situations that you would need to force unwrap.<br>&gt; &gt;&gt;  _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4729f8a9e7a01004252415f089ecdff7?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Daniel Hooper</string> &lt;danielchasehooper at gmail.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>I don&#39;t think we should discuss &quot;with&quot; here as that is a separate proposal.<br>I&#39;m trying to draw attention of the approach of Swift generating shadow<br>variables for you when an optional has been proven to be non-null.<br></p><p>I didn&#39;t say we should remove if/guard let. They would stay.<br></p><p>My proposal is to improve readability and reduce verbosity by generating<br>shadow variables after &quot;x != nil&quot; checks. The &quot;with x {}&quot; and &quot;if let x {}&quot;<br>approaches only reduce verbosity, at the additional cost of adding new<br>keywords or syntax to the language, and do not really improve readability.<br>Due to this, generating a shadow variable after &quot;x != nil&quot; is the most<br>straightforward, lowest impact and readable approach.<br></p><p>ilya, you bring up a good point about &quot;create shadow-&gt;write to<br>original-&gt;read shadow&quot; situations being potentially confusing. However &quot;if<br>let x = x&quot; is very common in situations that this isn&#39;t an issue: taking a<br>quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on local<br>variables that cannot possibly change out from under the shadow variable.<br>If that could lead to confusion in a given situation, you could fall back<br>on &quot;if let x = maybe_x&quot; to make it clearer that you&#39;re operating on a copy<br>of a variable that won&#39;t change out from under you. Alternatively, the &quot;if<br>x != nil { x.bla() }&quot; syntax could only be allowed on optionals in the<br>current function scope.<br></p><p>On Fri, Dec 11, 2015 at 11:41 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; This has come up a few times. I’ve thrown my 2cents into a variant of<br>&gt; “with” to solve this rather than messing with the meaning of if-let:<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; var x: MyType?<br>&gt;<br>&gt; with x {<br>&gt;   x.someFunction()              // okay - this entire block is skipped if<br>&gt; “x” is nil anyway<br>&gt; }<br>&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt;<br>&gt;<br>&gt; Using the definition  of “with” from Erica’s Method Cascading proposal<br>&gt; https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop<br>&gt; the variable reference itself from inside the block body:<br>&gt;<br>&gt; with x {<br>&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt; }<br>&gt;<br>&gt;<br>&gt; And I’d additionally propose that if you wanted to replace if-let-else,<br>&gt; you could potentially do this:<br>&gt;<br>&gt; if with x {<br>&gt;   // x is known non-nil<br>&gt; } else {<br>&gt;   // x is known to be nil<br>&gt; }<br>&gt; // x is optional and nil-ness is unknown<br>&gt;<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt; &gt;<br>&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt; &gt;    …<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; would then have to become this:<br>&gt; &gt;<br>&gt; &gt; let x = a?.b.c?.d<br>&gt; &gt; if x != nil {<br>&gt; &gt;    let y = something(x)<br>&gt; &gt;    if y != nil {<br>&gt; &gt;        …<br>&gt; &gt;    }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I&#39;m fine with<br>&gt; &gt;    if let x<br>&gt; &gt; as a shortcut for<br>&gt; &gt;    if let x = x<br>&gt; &gt;<br>&gt; &gt; It just reads a bit weird - like declaring an immutable variable with no<br>&gt; type and no value.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt; altogether, another approach would be to use the existing name if no new<br>&gt; name is given, so that this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; could become this code:<br>&gt; &gt;<br>&gt; &gt;       if let foo { /* use foo */ }<br>&gt; &gt;<br>&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt; another name with the if let syntax, that would work as it does today.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Jeff Kelley<br>&gt; &gt;<br>&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot;<br>&gt; optionals  - this works by creating a new non-optional variable to be used<br>&gt; by future code. Often, the new variable is given the same name as the<br>&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt; to odd looking code like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt; &gt;&gt; // use layer<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The solution:<br>&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking.<br>&gt; The compiler would treat the below code as if it had created an unwrapped<br>&gt; shadow variable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t<br>&gt; force unwrapped<br>&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an if<br>&gt; or after a guard that checks for nil. While this does allow for the &quot;layer<br>&gt; = nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>&gt; that this code was written:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; {code:java}<br>&gt; &gt;&gt; if layer != nil {<br>&gt; &gt;&gt; // lots of code before //<br>&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt; &gt;&gt; // lots of code after //<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; {code}<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And much later, you need to use some of the the code in the if body<br>&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt; as possible, and minimize the situations that you would need to force<br>&gt; unwrap.<br>&gt; &gt;&gt;  _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/ece1772a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; taking a quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on<br>local variables that cannot possibly change out from under the shadow<br>variable.<br></p><p>I&#39;m a bit surprised you have a code with non-trivial code paths for both<br>optional and non-optional values of some computations. Could you perhaps<br>provide an idiomatic example of such a function?<br></p><p><br>On Fri, Dec 11, 2015 at 8:17 PM, Daniel Hooper via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t think we should discuss &quot;with&quot; here as that is a separate<br>&gt; proposal. I&#39;m trying to draw attention of the approach of Swift generating<br>&gt; shadow variables for you when an optional has been proven to be non-null.<br>&gt;<br>&gt; I didn&#39;t say we should remove if/guard let. They would stay.<br>&gt;<br>&gt; My proposal is to improve readability and reduce verbosity by generating<br>&gt; shadow variables after &quot;x != nil&quot; checks. The &quot;with x {}&quot; and &quot;if let x {}&quot;<br>&gt; approaches only reduce verbosity, at the additional cost of adding new<br>&gt; keywords or syntax to the language, and do not really improve readability.<br>&gt; Due to this, generating a shadow variable after &quot;x != nil&quot; is the most<br>&gt; straightforward, lowest impact and readable approach.<br>&gt;<br>&gt; ilya, you bring up a good point about &quot;create shadow-&gt;write to<br>&gt; original-&gt;read shadow&quot; situations being potentially confusing. However &quot;if<br>&gt; let x = x&quot; is very common in situations that this isn&#39;t an issue: taking a<br>&gt; quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on local<br>&gt; variables that cannot possibly change out from under the shadow variable.<br>&gt; If that could lead to confusion in a given situation, you could fall back<br>&gt; on &quot;if let x = maybe_x&quot; to make it clearer that you&#39;re operating on a copy<br>&gt; of a variable that won&#39;t change out from under you. Alternatively, the &quot;if<br>&gt; x != nil { x.bla() }&quot; syntax could only be allowed on optionals in the<br>&gt; current function scope.<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 11:41 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt;&gt; This has come up a few times. I’ve thrown my 2cents into a variant of<br>&gt;&gt; “with” to solve this rather than messing with the meaning of if-let:<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; var x: MyType?<br>&gt;&gt;<br>&gt;&gt; with x {<br>&gt;&gt;   x.someFunction()              // okay - this entire block is skipped if<br>&gt;&gt; “x” is nil anyway<br>&gt;&gt; }<br>&gt;&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Using the definition  of “with” from Erica’s Method Cascading proposal<br>&gt;&gt; https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop<br>&gt;&gt; the variable reference itself from inside the block body:<br>&gt;&gt;<br>&gt;&gt; with x {<br>&gt;&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; And I’d additionally propose that if you wanted to replace if-let-else,<br>&gt;&gt; you could potentially do this:<br>&gt;&gt;<br>&gt;&gt; if with x {<br>&gt;&gt;   // x is known non-nil<br>&gt;&gt; } else {<br>&gt;&gt;   // x is known to be nil<br>&gt;&gt; }<br>&gt;&gt; // x is optional and nil-ness is unknown<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt;&gt; &gt;    …<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; would then have to become this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let x = a?.b.c?.d<br>&gt;&gt; &gt; if x != nil {<br>&gt;&gt; &gt;    let y = something(x)<br>&gt;&gt; &gt;    if y != nil {<br>&gt;&gt; &gt;        …<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m fine with<br>&gt;&gt; &gt;    if let x<br>&gt;&gt; &gt; as a shortcut for<br>&gt;&gt; &gt;    if let x = x<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It just reads a bit weird - like declaring an immutable variable with<br>&gt;&gt; no type and no value.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt; name is given, so that this code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; could become this code:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       if let foo { /* use foo */ }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Jeff Kelley<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot;<br>&gt;&gt; optionals  - this works by creating a new non-optional variable to be used<br>&gt;&gt; by future code. Often, the new variable is given the same name as the<br>&gt;&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt;&gt; to odd looking code like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt;&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt;&gt; &gt;&gt; // use layer<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt;&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The solution:<br>&gt;&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking.<br>&gt;&gt; The compiler would treat the below code as if it had created an unwrapped<br>&gt;&gt; shadow variable.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX<br>&gt;&gt; isn&#39;t force unwrapped<br>&gt;&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt;&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt;&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an if<br>&gt;&gt; or after a guard that checks for nil. While this does allow for the &quot;layer<br>&gt;&gt; = nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>&gt;&gt; that this code was written:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; {code:java}<br>&gt;&gt; &gt;&gt; if layer != nil {<br>&gt;&gt; &gt;&gt; // lots of code before //<br>&gt;&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt;&gt; &gt;&gt; // lots of code after //<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; {code}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; And much later, you need to use some of the the code in the if body<br>&gt;&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt;&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt;&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt;&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt;&gt; as possible, and minimize the situations that you would need to force<br>&gt;&gt; unwrap.<br>&gt;&gt; &gt;&gt;  _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/e05e01e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>It would only work well for local variables which were not captured by<br>reference by a closure.<br>Anything else will either lead to race conditions or be confusing when a<br>variable suddenly becomes out of sync without the user copying the value to<br>another variable explicitly.<br></p><p>There doesn&#39;t have to be a shadow variable though.<br>When the compiler supports nil-analyis it does know when an optional is no<br>longer optional - and - it will also know when the variable was changed<br>locally and is now probably nil again.<br></p><p>var x: String?<br>if x == nil {<br>   return<br>}<br>// x is now non-optional<br></p><p>x = nil<br>// x is optional again<br></p><p><br>In any case this will work only for very simple if conditions.<br></p><p>On Fri, Dec 11, 2015 at 6:30 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br></p><p>&gt; &gt; taking a quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on<br>&gt; local variables that cannot possibly change out from under the shadow<br>&gt; variable.<br>&gt;<br>&gt; I&#39;m a bit surprised you have a code with non-trivial code paths for both<br>&gt; optional and non-optional values of some computations. Could you perhaps<br>&gt; provide an idiomatic example of such a function?<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 8:17 PM, Daniel Hooper via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think we should discuss &quot;with&quot; here as that is a separate<br>&gt;&gt; proposal. I&#39;m trying to draw attention of the approach of Swift generating<br>&gt;&gt; shadow variables for you when an optional has been proven to be non-null.<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t say we should remove if/guard let. They would stay.<br>&gt;&gt;<br>&gt;&gt; My proposal is to improve readability and reduce verbosity by generating<br>&gt;&gt; shadow variables after &quot;x != nil&quot; checks. The &quot;with x {}&quot; and &quot;if let x {}&quot;<br>&gt;&gt; approaches only reduce verbosity, at the additional cost of adding new<br>&gt;&gt; keywords or syntax to the language, and do not really improve readability.<br>&gt;&gt; Due to this, generating a shadow variable after &quot;x != nil&quot; is the most<br>&gt;&gt; straightforward, lowest impact and readable approach.<br>&gt;&gt;<br>&gt;&gt; ilya, you bring up a good point about &quot;create shadow-&gt;write to<br>&gt;&gt; original-&gt;read shadow&quot; situations being potentially confusing. However &quot;if<br>&gt;&gt; let x = x&quot; is very common in situations that this isn&#39;t an issue: taking a<br>&gt;&gt; quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on local<br>&gt;&gt; variables that cannot possibly change out from under the shadow variable.<br>&gt;&gt; If that could lead to confusion in a given situation, you could fall back<br>&gt;&gt; on &quot;if let x = maybe_x&quot; to make it clearer that you&#39;re operating on a copy<br>&gt;&gt; of a variable that won&#39;t change out from under you. Alternatively, the &quot;if<br>&gt;&gt; x != nil { x.bla() }&quot; syntax could only be allowed on optionals in the<br>&gt;&gt; current function scope.<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 11:41 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This has come up a few times. I’ve thrown my 2cents into a variant of<br>&gt;&gt;&gt; “with” to solve this rather than messing with the meaning of if-let:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var x: MyType?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with x {<br>&gt;&gt;&gt;   x.someFunction()              // okay - this entire block is skipped<br>&gt;&gt;&gt; if “x” is nil anyway<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using the definition  of “with” from Erica’s Method Cascading proposal<br>&gt;&gt;&gt; https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop<br>&gt;&gt;&gt; the variable reference itself from inside the block body:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with x {<br>&gt;&gt;&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And I’d additionally propose that if you wanted to replace if-let-else,<br>&gt;&gt;&gt; you could potentially do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if with x {<br>&gt;&gt;&gt;   // x is known non-nil<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;   // x is known to be nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // x is optional and nil-ness is unknown<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt;&gt;&gt; &gt;    …<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; would then have to become this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; let x = a?.b.c?.d<br>&gt;&gt;&gt; &gt; if x != nil {<br>&gt;&gt;&gt; &gt;    let y = something(x)<br>&gt;&gt;&gt; &gt;    if y != nil {<br>&gt;&gt;&gt; &gt;        …<br>&gt;&gt;&gt; &gt;    }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m fine with<br>&gt;&gt;&gt; &gt;    if let x<br>&gt;&gt;&gt; &gt; as a shortcut for<br>&gt;&gt;&gt; &gt;    if let x = x<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It just reads a bit weird - like declaring an immutable variable with<br>&gt;&gt;&gt; no type and no value.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; could become this code:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       if let foo { /* use foo */ }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Jeff Kelley<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot;<br>&gt;&gt;&gt; optionals  - this works by creating a new non-optional variable to be used<br>&gt;&gt;&gt; by future code. Often, the new variable is given the same name as the<br>&gt;&gt;&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt;&gt;&gt; to odd looking code like this:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt;&gt;&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt;&gt;&gt; &gt;&gt; // use layer<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt;&gt;&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; The solution:<br>&gt;&gt;&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking.<br>&gt;&gt;&gt; The compiler would treat the below code as if it had created an unwrapped<br>&gt;&gt;&gt; shadow variable.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX<br>&gt;&gt;&gt; isn&#39;t force unwrapped<br>&gt;&gt;&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt;&gt;&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt;&gt;&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an<br>&gt;&gt;&gt; if or after a guard that checks for nil. While this does allow for the<br>&gt;&gt;&gt; &quot;layer = nil&quot; syntax, it results in code that is less resilient to change.<br>&gt;&gt;&gt; Imagine that this code was written:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; {code:java}<br>&gt;&gt;&gt; &gt;&gt; if layer != nil {<br>&gt;&gt;&gt; &gt;&gt; // lots of code before //<br>&gt;&gt;&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt;&gt;&gt; &gt;&gt; // lots of code after //<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; {code}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; And much later, you need to use some of the the code in the if body<br>&gt;&gt;&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt;&gt;&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt;&gt;&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt;&gt;&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt;&gt;&gt; as possible, and minimize the situations that you would need to force<br>&gt;&gt;&gt; unwrap.<br>&gt;&gt;&gt; &gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/0208b833/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4729f8a9e7a01004252415f089ecdff7?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Daniel Hooper</string> &lt;danielchasehooper at gmail.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>Comes up all the time in swift code that interfaces with objective-c. For<br>safety all object parameters should be optional since objective-c can&#39;t<br>make strong guarantees about nullability.<br></p><p>for example:<br></p><p>extension SomeObjcClass {<br></p><p>func selectLayer(layer: PRLayer?) {<br></p><p>        guard let layer = layer else { return }<br></p><p>//  do things with layer<br></p><p>}<br></p><p>}<br></p><p><br>On Fri, Dec 11, 2015 at 12:30 PM ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br></p><p>&gt; &gt; taking a quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on<br>&gt; local variables that cannot possibly change out from under the shadow<br>&gt; variable.<br>&gt;<br>&gt; I&#39;m a bit surprised you have a code with non-trivial code paths for both<br>&gt; optional and non-optional values of some computations. Could you perhaps<br>&gt; provide an idiomatic example of such a function?<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 8:17 PM, Daniel Hooper via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think we should discuss &quot;with&quot; here as that is a separate<br>&gt;&gt; proposal. I&#39;m trying to draw attention of the approach of Swift generating<br>&gt;&gt; shadow variables for you when an optional has been proven to be non-null.<br>&gt;&gt;<br>&gt;&gt; I didn&#39;t say we should remove if/guard let. They would stay.<br>&gt;&gt;<br>&gt;&gt; My proposal is to improve readability and reduce verbosity by generating<br>&gt;&gt; shadow variables after &quot;x != nil&quot; checks. The &quot;with x {}&quot; and &quot;if let x {}&quot;<br>&gt;&gt; approaches only reduce verbosity, at the additional cost of adding new<br>&gt;&gt; keywords or syntax to the language, and do not really improve readability.<br>&gt;&gt; Due to this, generating a shadow variable after &quot;x != nil&quot; is the most<br>&gt;&gt; straightforward, lowest impact and readable approach.<br>&gt;&gt;<br>&gt;&gt; ilya, you bring up a good point about &quot;create shadow-&gt;write to<br>&gt;&gt; original-&gt;read shadow&quot; situations being potentially confusing. However &quot;if<br>&gt;&gt; let x = x&quot; is very common in situations that this isn&#39;t an issue: taking a<br>&gt;&gt; quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on local<br>&gt;&gt; variables that cannot possibly change out from under the shadow variable.<br>&gt;&gt; If that could lead to confusion in a given situation, you could fall back<br>&gt;&gt; on &quot;if let x = maybe_x&quot; to make it clearer that you&#39;re operating on a copy<br>&gt;&gt; of a variable that won&#39;t change out from under you. Alternatively, the &quot;if<br>&gt;&gt; x != nil { x.bla() }&quot; syntax could only be allowed on optionals in the<br>&gt;&gt; current function scope.<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 11:41 AM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This has come up a few times. I’ve thrown my 2cents into a variant of<br>&gt;&gt;&gt; “with” to solve this rather than messing with the meaning of if-let:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var x: MyType?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with x {<br>&gt;&gt;&gt;   x.someFunction()              // okay - this entire block is skipped<br>&gt;&gt;&gt; if “x” is nil anyway<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; x.someFunction()                // not okay as-is since x is optional<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using the definition  of “with” from Erica’s Method Cascading proposal<br>&gt;&gt;&gt; https://gist.github.com/erica/6794d48d917e2084d6ed, you could even drop<br>&gt;&gt;&gt; the variable reference itself from inside the block body:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; with x {<br>&gt;&gt;&gt;   someFunction()                // would call “someFunction()” on “x”<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And I’d additionally propose that if you wanted to replace if-let-else,<br>&gt;&gt;&gt; you could potentially do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if with x {<br>&gt;&gt;&gt;   // x is known non-nil<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;   // x is known to be nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // x is optional and nil-ness is unknown<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 11, 2015, at 10:28 AM, Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; One problem with dropping if/guard let is something like this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; if let x = a?.b.c?.d, y = something(x) {<br>&gt;&gt;&gt; &gt;    …<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; would then have to become this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; let x = a?.b.c?.d<br>&gt;&gt;&gt; &gt; if x != nil {<br>&gt;&gt;&gt; &gt;    let y = something(x)<br>&gt;&gt;&gt; &gt;    if y != nil {<br>&gt;&gt;&gt; &gt;        …<br>&gt;&gt;&gt; &gt;    }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m fine with<br>&gt;&gt;&gt; &gt;    if let x<br>&gt;&gt;&gt; &gt; as a shortcut for<br>&gt;&gt;&gt; &gt;    if let x = x<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It just reads a bit weird - like declaring an immutable variable with<br>&gt;&gt;&gt; no type and no value.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Fri, Dec 11, 2015 at 5:19 PM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; could become this code:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       if let foo { /* use foo */ }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Jeff Kelley<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Dec 11, 2015, at 11:11 AM, Daniel Hooper via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot;<br>&gt;&gt;&gt; optionals  - this works by creating a new non-optional variable to be used<br>&gt;&gt;&gt; by future code. Often, the new variable is given the same name as the<br>&gt;&gt;&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt;&gt;&gt; to odd looking code like this:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt;&gt;&gt; &gt;&gt; guard let layer = layer else { continue }<br>&gt;&gt;&gt; &gt;&gt; // use layer<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt;&gt;&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; The solution:<br>&gt;&gt;&gt; &gt;&gt; Swift should generate unwrapped shadow variables after nil checking.<br>&gt;&gt;&gt; The compiler would treat the below code as if it had created an unwrapped<br>&gt;&gt;&gt; shadow variable.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; if nearestX != nil { closest = nearestX } // notice that nearestX<br>&gt;&gt;&gt; isn&#39;t force unwrapped<br>&gt;&gt;&gt; &gt;&gt; guard layer != nil else { continue }<br>&gt;&gt;&gt; &gt;&gt; // use layer, without force unwrapping<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt;&gt;&gt; &gt;&gt; You might suggest force unwrapping variables when they&#39;re inside an<br>&gt;&gt;&gt; if or after a guard that checks for nil. While this does allow for the<br>&gt;&gt;&gt; &quot;layer = nil&quot; syntax, it results in code that is less resilient to change.<br>&gt;&gt;&gt; Imagine that this code was written:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; {code:java}<br>&gt;&gt;&gt; &gt;&gt; if layer != nil {<br>&gt;&gt;&gt; &gt;&gt; // lots of code before //<br>&gt;&gt;&gt; &gt;&gt; layer!.backgroundColor = newColor<br>&gt;&gt;&gt; &gt;&gt; // lots of code after //<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; {code}<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; And much later, you need to use some of the the code in the if body<br>&gt;&gt;&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt;&gt;&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt;&gt;&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt;&gt;&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt;&gt;&gt; as possible, and minimize the situations that you would need to force<br>&gt;&gt;&gt; unwrap.<br>&gt;&gt;&gt; &gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/7c783572/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>Personally, I wouldn’t like to see any more specialised syntax or compiler voodoo to deal with Optionals. They’re like the Hydra of Swift, though instead of sprouting heads, they sprout new syntax : )<br></p><p>I’d be all for a more generalised approach, ‘do notation’, ‘for comprehensions’, etc – though that’s not likely to happen in the near term (if ever).<br></p><p>&gt; On 11 Dec 2015, at 17:17, Daniel Hooper via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think we should discuss &quot;with&quot; here as that is a separate proposal. I&#39;m trying to draw attention of the approach of Swift generating shadow variables for you when an optional has been proven to be non-null. <br>&gt; <br>&gt; I didn&#39;t say we should remove if/guard let. They would stay.<br>&gt; <br>&gt; My proposal is to improve readability and reduce verbosity by generating shadow variables after &quot;x != nil&quot; checks. The &quot;with x {}&quot; and &quot;if let x {}&quot; approaches only reduce verbosity, at the additional cost of adding new keywords or syntax to the language, and do not really improve readability. Due to this, generating a shadow variable after &quot;x != nil&quot; is the most straightforward, lowest impact and readable approach.<br>&gt; <br>&gt; ilya, you bring up a good point about &quot;create shadow-&gt;write to original-&gt;read shadow&quot; situations being potentially confusing. However &quot;if let x = x&quot; is very common in situations that this isn&#39;t an issue: taking a quick look at my code, 50% of all &quot;if/guard let x = x&quot; are on local variables that cannot possibly change out from under the shadow variable. If that could lead to confusion in a given situation, you could fall back on &quot;if let x = maybe_x&quot; to make it clearer that you&#39;re operating on a copy of a variable that won&#39;t change out from under you. Alternatively, the &quot;if x != nil { x.bla() }&quot; syntax could only be allowed on optionals in the current function scope.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/2f8d018b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 19, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt; <br>&gt; 	if let foo = foo { /* use foo */ }<br>&gt; <br>&gt; could become this code:<br>&gt; <br>&gt; 	if let foo { /* use foo */ }<br>&gt; <br>&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br></p><p>Hi Jeff,<br></p><p>This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/47d75c20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 19, 2015 at 11:00:00am</p></header><div class="content"><p>As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br></p><p>if let someInterestingViewConroller = someInterestingViewConroller {<br>}<br></p><p>vs<br></p><p>If let someInterestingViewConroller {<br>}<br></p><p>We know what let does and it should be enough to impart the necessary information for this statement.<br></p><p>When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br></p><p><br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt; <br>&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt; <br>&gt;&gt; could become this code:<br>&gt;&gt; <br>&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt; <br>&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt; <br>&gt; Hi Jeff,<br>&gt; <br>&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/ba8f3b18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>What if we made the keyword &quot;unwrap&quot;?<br></p><p>if unwrap someViewController {<br>// now there is a shadowing nonoptional (unwrapped) variable of the same<br>name only within this scope, boiling down to simple syntactic sugar for<br>optional binding and it is fairly clear.<br>}<br></p><p>On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As much fun as it to example with foo, I would argue the opposite when you<br>&gt; use some real world variable names:<br>&gt;<br>&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt; }<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; If let someInterestingViewConroller {<br>&gt; }<br>&gt;<br>&gt; We know what let does and it should be enough to impart the necessary<br>&gt; information for this statement.<br>&gt;<br>&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody<br>&gt; who&#39;d be able to understand either form without teaching; so not losing<br>&gt; much there.<br>&gt;<br>&gt;<br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt; altogether, another approach would be to use the existing name if no new<br>&gt; name is given, so that this code:<br>&gt;<br>&gt; if let foo = foo { /* use foo */ }<br>&gt;<br>&gt; could become this code:<br>&gt;<br>&gt; if let foo { /* use foo */ }<br>&gt;<br>&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt; another name with the if let syntax, that would work as it does today.<br>&gt;<br>&gt;<br>&gt; Hi Jeff,<br>&gt;<br>&gt; This is commonly requested - the problem is that while it does help reduce<br>&gt; boilerplate, it runs counter to the goal of improving clarity.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/aaf708a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>I was going to suggest something similar (a hard naming problem also):<br></p><p>if has foo {<br>    // foo is now unwrapped and non-optional<br>}<br></p><p>guard has foo else { return }<br></p><p>Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br></p><p>IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br></p><p>Curious to hear Chris Lattner’s opinion :-) <br></p><p>— Radek<br></p><p>&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt; <br>&gt; if unwrap someViewController {<br>&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt; }<br>&gt; <br>&gt; <br>&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt; <br>&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; If let someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt; <br>&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt; <br>&gt; <br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt; <br>&gt;&gt; Hi Jeff,<br>&gt;&gt; <br>&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/46030ae9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt; <br>&gt; if has foo {<br>&gt;     // foo is now unwrapped and non-optional<br>&gt; }<br>&gt; <br>&gt; guard has foo else { return }<br>&gt; <br>&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt; <br>&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt; <br>&gt; Curious to hear Chris Lattner’s opinion :-) <br></p><p>IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br></p><p>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt; <br>&gt;&gt; if unwrap someViewController {<br>&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt; <br>&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt; <br>&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/8fe9e3c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23a31075ffa046c5a4da64af895ceb07?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Cihat Gündüz</string> &lt;CihatGuenduez at posteo.de&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>I’ve only read the last couple of posts but has anybody already suggested using something like this:<br></p><p>if let foo! {<br>  // code that uses foo<br>}<br></p><p>People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>Alternatively it could also be:<br></p><p>if let foo? {<br>  // code that uses foo<br>}<br></p><p>What do you think?<br></p><p>– Cihat<br></p><p>&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt; <br>&gt;&gt; if has foo {<br>&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard has foo else { return }<br>&gt;&gt; <br>&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt; <br>&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt; <br>&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt; <br>&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; — Radek<br>&gt;&gt; <br>&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/aeb8406e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 12:00:00am</p></header><div class="content"><p>Cihat, if either of the two you proposed I would prefer &quot;let foo?&quot; as the<br>bang (!), outside of logical negation, carries a meaning of &quot;this is<br>dangerous and something could go wrong at runtime here&quot;. Evidenced by its<br>only other uses--try!, force-unwrapping, and implicitly unwrapped optionals.<br></p><p>However, you may be interested in the last email Chris sent in this chain<br>with regards to shortening it to just &quot;let foo&quot;:<br></p><p>&quot;This is commonly requested - the problem is that while it does help reduce<br>boilerplate, it runs counter to the goal of improving clarity.&quot;<br></p><p>He&#39;s got a point; &quot;if let foo = bar&quot; makes sense in a way, but just &quot;if let<br>foo&quot; is a bit nonsensical to me when I take my mind outside of the narrow<br>swift mindset I tend to get into. This extends to decorating the foo with a<br>question mark or a bang, imo.<br></p><p>On Sat, Dec 19, 2015 at 7:02 PM Cihat Gündüz &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I’ve only read the last couple of posts but has anybody already suggested<br>&gt; using something like this:<br>&gt;<br>&gt; if let foo! {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt;<br>&gt; People already know that the ! is unwrapping a value and that let is<br>&gt; defining a new constant. So why not combine those two?<br>&gt; Alternatively it could also be:<br>&gt;<br>&gt; if let foo? {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; – Cihat<br>&gt;<br>&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;<br>&gt; if has foo {<br>&gt;     // foo is now unwrapped and non-optional<br>&gt; }<br>&gt;<br>&gt; guard has foo else { return }<br>&gt;<br>&gt; Does the same thing as `let foo = foo` in practice, but places it in a<br>&gt; somewhat different mental model. Instead of unwrapping and immediately<br>&gt; assigning to a new constant with the same name (which just looks kind of<br>&gt; silly, like some magic voodoo ritual), it sort of asserts that we “have”<br>&gt; foo (i.e. it’s not nil), and therefore from that point it can just be<br>&gt; treated as non-optional.<br>&gt;<br>&gt; IMHO this, although introduces a new keyword, makes more sense than trying<br>&gt; to reuse “let” in a context where it seems nonsensical. Perhaps this would<br>&gt; be closer to Swift’s goals, by reducing very common boilerplate, but<br>&gt; without harming clarity in a way adding a new meaning to “let” would.<br>&gt;<br>&gt; Curious to hear Chris Lattner’s opinion :-)<br>&gt;<br>&gt;<br>&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are<br>&gt; uncomfortable with the idea that a single declared property might have<br>&gt; different static types in different regions of code.<br>&gt;<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt;<br>&gt; if unwrap someViewController {<br>&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same<br>&gt; name only within this scope, boiling down to simple syntactic sugar for<br>&gt; optional binding and it is fairly clear.<br>&gt; }<br>&gt;<br>&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt; you use some real world variable names:<br>&gt;&gt;<br>&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt; information for this statement.<br>&gt;&gt;<br>&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody<br>&gt;&gt; who&#39;d be able to understand either form without teaching; so not losing<br>&gt;&gt; much there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt; name is given, so that this code:<br>&gt;&gt;<br>&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; could become this code:<br>&gt;&gt;<br>&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Jeff,<br>&gt;&gt;<br>&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/01348bdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 19, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 5:12 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Cihat, if either of the two you proposed I would prefer &quot;let foo?&quot; as the bang (!), outside of logical negation, carries a meaning of &quot;this is dangerous and something could go wrong at runtime here&quot;. Evidenced by its only other uses--try!, force-unwrapping, and implicitly unwrapped optionals.<br>&gt; <br>&gt; However, you may be interested in the last email Chris sent in this chain with regards to shortening it to just &quot;let foo&quot;:<br>&gt; <br>&gt; &quot;This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.&quot;<br>&gt; <br>&gt; He&#39;s got a point; &quot;if let foo = bar&quot; makes sense in a way, but just &quot;if let foo&quot; is a bit nonsensical to me when I take my mind outside of the narrow swift mindset I tend to get into. This extends to decorating the foo with a question mark or a bang, imo. <br></p><p>But, “if let foo = foo {}” makes no sense to anybody but people familiar with swift already.  Dropping the redundancy really doesn’t harm much because you’ll first have to learn what “let” is doing; once you know what “let” is doing “if let foo {}” is fairly clear.<br></p><p>&gt; <br>&gt; On Sat, Dec 19, 2015 at 7:02 PM Cihat Gündüz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt; <br>&gt; if let foo! {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt; Alternatively it could also be:<br>&gt; <br>&gt; if let foo? {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; – Cihat<br>&gt; <br>&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt; <br>&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/790df197/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>One question first: Have you thought of user trying to do<br>let object.someProperty<br>?<br>The syntax looks like a nice shortcut at the first glance, but we shouldn&#39;t forget that there is already a different shortcut involved in many of those assignments:<br>self.foo...<br></p><p>&gt; But, “if let foo = foo {}” makes no sense to anybody but people familiar with swift already.<br>I&#39;ve to agree on that — imho the syntax isn&#39;t very intuitive.<br>But it has the advantage to make clear that you declare a new value with the name &quot;foo&quot; (without explaining why that new foo has a different type despite using the normal assignment operator… I wonder if there has been a discussion about something like &quot;?=&quot;)<br></p><p>For me everything boils down that we as programmers put a lot of stress on those tiny equal signs (to bad our natural language evolved in the way it did ;-), but that&#39;s life, and we know how to deal with it.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/2db3de6d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23a31075ffa046c5a4da64af895ceb07?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Cihat Gündüz</string> &lt;CihatGuenduez at posteo.de&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; However, you may be interested in the last email Chris sent in this chain with regards to shortening it to just &quot;let foo&quot;:<br>&gt; <br>&gt; &quot;This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.&quot;<br>&gt; <br>&gt; He&#39;s got a point; &quot;if let foo = bar&quot; makes sense in a way, but just &quot;if let foo&quot; is a bit nonsensical to me when I take my mind outside of the narrow swift mindset I tend to get into. This extends to decorating the foo with a question mark or a bang, imo. <br></p><p>Thank you for the feedback, Dennis. That post you quote is amongst the ones I read and it is even the reason I am suggesting these alternatives. Let me explain my thinking behind my suggestions a bit. I agree with Chris that `if let foo { /* code */ }` isn’t very readable mainly because there is no action done on the `foo` like a `= bar` or something else. But I also had the thought ‚why do I need to type this twice, can’t this be optimized?‘ quite a few times when I used `if let foo = foo { /* code */ }` in practice.<br></p><p>So that’s why I thought there must be a way. First I started with something that contained the `=` sign also using the shorthand `x += 1` for `x = x + 1` as an inspiration. That lead to things like these:<br></p><p>if let foo = _ { /* code */ }<br>if let foo = ! { /* code */ }<br>if let foo ?= _ { /* code */ }<br>if foo ?= foo { /* code */ }<br>if let foo ?= { /* code */ }<br></p><p>But being honest to myself I thought all of those were even less readable then `if let foo { /* code */ }`. But once I dropped the `=` sign like in `if let foo! { /* code */ }` I started to like the idea and still found it readable.<br></p><p>I generally read let like a ‚define constant with name‘ and a ! like ‚force unwrap value‘ so I would read `let foo!` as ‚define constant with name and force unwrap value`. But I agree that ? may be more correct which I read as `try to unwrap value only continuing if unwrap succeeds` so `let foo?` would read as `define constant with name and try to unwrap only continuing if unwrap succeeds`.<br></p><p>So in conclusion to me `if let foo { }` isn’t readable but `if let foo? { }` is. That is only my opinion though.<br></p><p>&gt; <br>&gt; On Sat, Dec 19, 2015 at 7:02 PM Cihat Gündüz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt; <br>&gt; if let foo! {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt; Alternatively it could also be:<br>&gt; <br>&gt; if let foo? {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; – Cihat<br>&gt; <br>&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt; <br>&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/19610570/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 04:00:00am</p></header><div class="content"><p>@Kevin: That is why I&#39;m suggesting if unwrap foo {, because I believe it&#39;s<br>clearer than either. I was trying to say, though, that &quot;if let foo = bar&quot;,<br>one of the first things you learn in swift, transitions naturally to &quot;if<br>let foo = foo&quot;, though slightly disorienting at first, but will be<br>disconnected from just &quot;if let foo&quot; due to being in a fundamentally<br>different format.<br></p><p>@Cihat: Aha, interesting points. I still think a more explicit keyword like<br>&quot;unwrap&quot; or &quot;bind&quot; would achieve a bit more clarity.<br></p><p>On Sat, Dec 19, 2015 at 7:47 PM Cihat Gündüz &lt;CihatGuenduez at posteo.de&gt;<br>wrote:<br></p><p>&gt; However, you may be interested in the last email Chris sent in this chain<br>&gt; with regards to shortening it to just &quot;let foo&quot;:<br>&gt;<br>&gt; &quot;This is commonly requested - the problem is that while it does help<br>&gt; reduce boilerplate, it runs counter to the goal of improving clarity.&quot;<br>&gt;<br>&gt; He&#39;s got a point; &quot;if let foo = bar&quot; makes sense in a way, but just &quot;if<br>&gt; let foo&quot; is a bit nonsensical to me when I take my mind outside of the<br>&gt; narrow swift mindset I tend to get into. This extends to decorating the foo<br>&gt; with a question mark or a bang, imo.<br>&gt;<br>&gt;<br>&gt; Thank you for the feedback, Dennis. That post you quote is amongst the<br>&gt; ones I read and it is even the reason I am suggesting these alternatives.<br>&gt; Let me explain my thinking behind my suggestions a bit. I agree with Chris<br>&gt; that `if let foo { /* code */ }` isn’t very readable mainly because there<br>&gt; is no action done on the `foo` like a `= bar` or something else. But I also<br>&gt; had the thought ‚why do I need to type this twice, can’t this be<br>&gt; optimized?‘ quite a few times when I used `if let foo = foo { /* code */ }`<br>&gt; in practice.<br>&gt;<br>&gt; So that’s why I thought there must be a way. First I started with<br>&gt; something that contained the `=` sign also using the shorthand `x += 1` for<br>&gt; `x = x + 1` as an inspiration. That lead to things like these:<br>&gt;<br>&gt; if let foo = _ { /* code */ }<br>&gt; if let foo = ! { /* code */ }<br>&gt; if let foo ?= _ { /* code */ }<br>&gt; if foo ?= foo { /* code */ }<br>&gt; if let foo ?= { /* code */ }<br>&gt;<br>&gt; But being honest to myself I thought all of those were even less readable<br>&gt; then `if let foo { /* code */ }`. But once I dropped the `=` sign like in<br>&gt; `if let foo! { /* code */ }` I started to like the idea and still found it<br>&gt; readable.<br>&gt;<br>&gt; I generally read let like a ‚define constant with name‘ and a ! like<br>&gt; ‚force unwrap value‘ so I would read `let foo!` as ‚define constant with<br>&gt; name and force unwrap value`. But I agree that ? may be more correct which<br>&gt; I read as `try to unwrap value only continuing if unwrap succeeds` so `let<br>&gt; foo?` would read as `define constant with name and try to unwrap only<br>&gt; continuing if unwrap succeeds`.<br>&gt;<br>&gt; So in conclusion to me `if let foo { }` isn’t readable but `if let foo? {<br>&gt; }` is. That is only my opinion though.<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 19, 2015 at 7:02 PM Cihat Gündüz &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I’ve only read the last couple of posts but has anybody already suggested<br>&gt;&gt; using something like this:<br>&gt;&gt;<br>&gt;&gt; if let foo! {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; People already know that the ! is unwrapping a value and that let is<br>&gt;&gt; defining a new constant. So why not combine those two?<br>&gt;&gt; Alternatively it could also be:<br>&gt;&gt;<br>&gt;&gt; if let foo? {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What do you think?<br>&gt;&gt;<br>&gt;&gt; – Cihat<br>&gt;&gt;<br>&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;<br>&gt;&gt; if has foo {<br>&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; guard has foo else { return }<br>&gt;&gt;<br>&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a<br>&gt;&gt; somewhat different mental model. Instead of unwrapping and immediately<br>&gt;&gt; assigning to a new constant with the same name (which just looks kind of<br>&gt;&gt; silly, like some magic voodoo ritual), it sort of asserts that we “have”<br>&gt;&gt; foo (i.e. it’s not nil), and therefore from that point it can just be<br>&gt;&gt; treated as non-optional.<br>&gt;&gt;<br>&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than<br>&gt;&gt; trying to reuse “let” in a context where it seems nonsensical. Perhaps this<br>&gt;&gt; would be closer to Swift’s goals, by reducing very common boilerplate, but<br>&gt;&gt; without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;<br>&gt;&gt; Curious to hear Chris Lattner’s opinion :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are<br>&gt;&gt; uncomfortable with the idea that a single declared property might have<br>&gt;&gt; different static types in different regions of code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; — Radek<br>&gt;&gt;<br>&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt;&gt;<br>&gt;&gt; if unwrap someViewController {<br>&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same<br>&gt;&gt; name only within this scope, boiling down to simple syntactic sugar for<br>&gt;&gt; optional binding and it is fairly clear.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt;&gt; you use some real world variable names:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt;&gt; information for this statement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find<br>&gt;&gt;&gt; somebody who&#39;d be able to understand either form without teaching; so not<br>&gt;&gt;&gt; losing much there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/9d4a0925/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  1, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve always thought that, <br></p><p>if let foo = foo? {<br></p><p>}<br></p><p>makes more sense than <br></p><p>if let foo = foo {<br></p><p>}<br></p><p>as the ? indicates that you are unwrapping the optional and then assigning it to the new variable<br></p><p>&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt; <br>&gt; if let foo! {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt; Alternatively it could also be:<br>&gt; <br>&gt; if let foo? {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; – Cihat<br>&gt; <br>&gt;&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt; <br>&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/9e961c53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  2, 2016 at 12:00:00am</p></header><div class="content"><p>Whoops, errant button tap.<br></p><p>I&#39;ve always thought that, <br></p><p>if let foo = foo? {<br></p><p>}<br></p><p>makes more sense than <br></p><p>if let foo = foo {<br></p><p>}<br></p><p>as the ? indicates that you are unwrapping the optional and then assigning it to the new variable.<br></p><p>The current syntax must seem incomprehensible/redundant to those new to Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems to be more consistent with ? being the operator for unwrapping.<br></p><p>Of course there is also the current optional pattern matching syntax:<br></p><p>if case let foo? = foo {<br></p><p>}<br></p><p>This accomplishes the same thing and is somewhat less perplexing than &quot;if let foo = foo&quot;, but must still be baffling to a new user.<br></p><p>You could even have:<br></p><p>if foo? {<br>    foo.blah()<br>}<br></p><p>Which would not create a shadow local variable but would have the same semantics as<br></p><p>foo?.blah()<br></p><p>in that is just providing conditional access to the variable if it&#39;s not .None. Not sure if this direct access is desired as it is still magical scoped type manipulation without declaring a new variable.<br></p><p><br>Tyler<br></p><p><br>&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve always thought that, <br>&gt; <br>&gt; if let foo = foo? {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; makes more sense than <br>&gt; <br>&gt; if let foo = foo {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; as the ? indicates that you are unwrapping the optional and then assigning it to the new variable<br>&gt; <br>&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt;&gt; <br>&gt;&gt; if let foo! {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt;&gt; Alternatively it could also be:<br>&gt;&gt; <br>&gt;&gt; if let foo? {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; – Cihat<br>&gt;&gt; <br>&gt;&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160102/15154e0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 11:00:00pm</p></header><div class="content"><p>Ceylon has type narrowing (not only for optional unwrapping but for type checks as well): http://ceylon-lang.org/documentation/1.2/tour/types/#narrowing_the_type_of_an_object_reference<br></p><p>It always struck me as quite natural to do this.<br></p><p>-Thorsten<br></p><p>&gt; Am 02.01.2016 um 06:08 schrieb Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; Whoops, errant button tap.<br>&gt; <br>&gt; I&#39;ve always thought that, <br>&gt; <br>&gt; if let foo = foo? {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; makes more sense than <br>&gt; <br>&gt; if let foo = foo {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; as the ? indicates that you are unwrapping the optional and then assigning it to the new variable.<br>&gt; <br>&gt; The current syntax must seem incomprehensible/redundant to those new to Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems to be more consistent with ? being the operator for unwrapping.<br>&gt; <br>&gt; Of course there is also the current optional pattern matching syntax:<br>&gt; <br>&gt; if case let foo? = foo {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; This accomplishes the same thing and is somewhat less perplexing than &quot;if let foo = foo&quot;, but must still be baffling to a new user.<br>&gt; <br>&gt; You could even have:<br>&gt; <br>&gt; if foo? {<br>&gt;     foo.blah()<br>&gt; }<br>&gt; <br>&gt; Which would not create a shadow local variable but would have the same semantics as<br>&gt; <br>&gt; foo?.blah()<br>&gt; <br>&gt; in that is just providing conditional access to the variable if it&#39;s not .None. Not sure if this direct access is desired as it is still magical scoped type manipulation without declaring a new variable.<br>&gt; <br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve always thought that, <br>&gt;&gt; <br>&gt;&gt; if let foo = foo? {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; makes more sense than <br>&gt;&gt; <br>&gt;&gt; if let foo = foo {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; as the ? indicates that you are unwrapping the optional and then assigning it to the new variable<br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let foo! {<br>&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt;&gt;&gt; Alternatively it could also be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let foo? {<br>&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Cihat<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/32325215/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>Thorsten,<br></p><p>Not that I disapprove (Kotlin does the same and it&#39;s great), the precedent<br>seems to have already been set in people&#39;s minds that there won&#39;t be any<br>kind of implicit type narrowing and I predict a fair few will respond with<br>&quot;You can already do that with optional binding, and I&#39;m uncomfortable<br>seeing a variable change type in an inner scope&quot; even though shadowing<br>achieves exactly the same aim. The same happened the last time that type<br>narrowing was mentioned.<br></p><p><br>On Tue, Jan 5, 2016 at 5:27 PM Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ceylon has type narrowing (not only for optional unwrapping but for type<br>&gt; checks as well):<br>&gt; http://ceylon-lang.org/documentation/1.2/tour/types/#narrowing_the_type_of_an_object_reference<br>&gt;<br>&gt; It always struck me as quite natural to do this.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 02.01.2016 um 06:08 schrieb Tyler Fleming Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt; Whoops, errant button tap.<br>&gt;<br>&gt; I&#39;ve always thought that,<br>&gt;<br>&gt; if let foo = foo? {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; makes more sense than<br>&gt;<br>&gt; if let foo = foo {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; as the ? indicates that you are unwrapping the optional and then assigning<br>&gt; it to the new variable.<br>&gt;<br>&gt; The current syntax must seem incomprehensible/redundant to those new to<br>&gt; Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems<br>&gt; to be more consistent with ? being the operator for unwrapping.<br>&gt;<br>&gt; Of course there is also the current optional pattern matching syntax:<br>&gt;<br>&gt; if case let foo? = foo {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; This accomplishes the same thing and is somewhat less perplexing than &quot;if<br>&gt; let foo = foo&quot;, but must still be baffling to a new user.<br>&gt;<br>&gt; You could even have:<br>&gt;<br>&gt; if foo? {<br>&gt;     foo.blah()<br>&gt; }<br>&gt;<br>&gt; Which would not create a shadow local variable but would have the same<br>&gt; semantics as<br>&gt;<br>&gt; foo?.blah()<br>&gt;<br>&gt; in that is just providing conditional access to the variable if it&#39;s not<br>&gt; .None. Not sure if this direct access is desired as it is still magical<br>&gt; scoped type manipulation without declaring a new variable.<br>&gt;<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve always thought that,<br>&gt;<br>&gt; if let foo = foo? {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; makes more sense than<br>&gt;<br>&gt; if let foo = foo {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; as the ? indicates that you are unwrapping the optional and then assigning<br>&gt; it to the new variable<br>&gt;<br>&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I’ve only read the last couple of posts but has anybody already suggested<br>&gt; using something like this:<br>&gt;<br>&gt; if let foo! {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt;<br>&gt; People already know that the ! is unwrapping a value and that let is<br>&gt; defining a new constant. So why not combine those two?<br>&gt; Alternatively it could also be:<br>&gt;<br>&gt; if let foo? {<br>&gt;   // code that uses foo<br>&gt; }<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; – Cihat<br>&gt;<br>&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;<br>&gt; if has foo {<br>&gt;     // foo is now unwrapped and non-optional<br>&gt; }<br>&gt;<br>&gt; guard has foo else { return }<br>&gt;<br>&gt; Does the same thing as `let foo = foo` in practice, but places it in a<br>&gt; somewhat different mental model. Instead of unwrapping and immediately<br>&gt; assigning to a new constant with the same name (which just looks kind of<br>&gt; silly, like some magic voodoo ritual), it sort of asserts that we “have”<br>&gt; foo (i.e. it’s not nil), and therefore from that point it can just be<br>&gt; treated as non-optional.<br>&gt;<br>&gt; IMHO this, although introduces a new keyword, makes more sense than trying<br>&gt; to reuse “let” in a context where it seems nonsensical. Perhaps this would<br>&gt; be closer to Swift’s goals, by reducing very common boilerplate, but<br>&gt; without harming clarity in a way adding a new meaning to “let” would.<br>&gt;<br>&gt; Curious to hear Chris Lattner’s opinion :-)<br>&gt;<br>&gt;<br>&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are<br>&gt; uncomfortable with the idea that a single declared property might have<br>&gt; different static types in different regions of code.<br>&gt;<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt;<br>&gt; if unwrap someViewController {<br>&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same<br>&gt; name only within this scope, boiling down to simple syntactic sugar for<br>&gt; optional binding and it is fairly clear.<br>&gt; }<br>&gt;<br>&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt; you use some real world variable names:<br>&gt;&gt;<br>&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt; information for this statement.<br>&gt;&gt;<br>&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody<br>&gt;&gt; who&#39;d be able to understand either form without teaching; so not losing<br>&gt;&gt; much there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt; name is given, so that this code:<br>&gt;&gt;<br>&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; could become this code:<br>&gt;&gt;<br>&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Jeff,<br>&gt;&gt;<br>&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/64fddb9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>That said, I am in favor of automatic type narrowing. As long as it doesn&#39;t<br>complicate the compiler considerably (if it does, there&#39;s little reason to<br>replace optional binding), it&#39;s no less confusing than shadowing was when I<br>first saw it, and once you get used to it (shouldn&#39;t be more than a day):<br>it is less verbose and perhaps more intuitive (I&#39;ve found myself reacting<br>to optionals saying &quot;duh, I&#39;ve already guarded that X is nonnull on this<br>codepath, why would I have to unwrap it again?&quot; in Swift).<br></p><p>On Tue, Jan 5, 2016 at 5:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Thorsten,<br>&gt;<br>&gt; Not that I disapprove (Kotlin does the same and it&#39;s great), the precedent<br>&gt; seems to have already been set in people&#39;s minds that there won&#39;t be any<br>&gt; kind of implicit type narrowing and I predict a fair few will respond with<br>&gt; &quot;You can already do that with optional binding, and I&#39;m uncomfortable<br>&gt; seeing a variable change type in an inner scope&quot; even though shadowing<br>&gt; achieves exactly the same aim. The same happened the last time that type<br>&gt; narrowing was mentioned.<br>&gt;<br>&gt;<br>&gt; On Tue, Jan 5, 2016 at 5:27 PM Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Ceylon has type narrowing (not only for optional unwrapping but for type<br>&gt;&gt; checks as well):<br>&gt;&gt; http://ceylon-lang.org/documentation/1.2/tour/types/#narrowing_the_type_of_an_object_reference<br>&gt;&gt;<br>&gt;&gt; It always struck me as quite natural to do this.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 02.01.2016 um 06:08 schrieb Tyler Fleming Cloutier via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Whoops, errant button tap.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve always thought that,<br>&gt;&gt;<br>&gt;&gt; if let foo = foo? {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; makes more sense than<br>&gt;&gt;<br>&gt;&gt; if let foo = foo {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; as the ? indicates that you are unwrapping the optional and then<br>&gt;&gt; assigning it to the new variable.<br>&gt;&gt;<br>&gt;&gt; The current syntax must seem incomprehensible/redundant to those new to<br>&gt;&gt; Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems<br>&gt;&gt; to be more consistent with ? being the operator for unwrapping.<br>&gt;&gt;<br>&gt;&gt; Of course there is also the current optional pattern matching syntax:<br>&gt;&gt;<br>&gt;&gt; if case let foo? = foo {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This accomplishes the same thing and is somewhat less perplexing than &quot;if<br>&gt;&gt; let foo = foo&quot;, but must still be baffling to a new user.<br>&gt;&gt;<br>&gt;&gt; You could even have:<br>&gt;&gt;<br>&gt;&gt; if foo? {<br>&gt;&gt;     foo.blah()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Which would not create a shadow local variable but would have the same<br>&gt;&gt; semantics as<br>&gt;&gt;<br>&gt;&gt; foo?.blah()<br>&gt;&gt;<br>&gt;&gt; in that is just providing conditional access to the variable if it&#39;s not<br>&gt;&gt; .None. Not sure if this direct access is desired as it is still magical<br>&gt;&gt; scoped type manipulation without declaring a new variable.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Tyler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve always thought that,<br>&gt;&gt;<br>&gt;&gt; if let foo = foo? {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; makes more sense than<br>&gt;&gt;<br>&gt;&gt; if let foo = foo {<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; as the ? indicates that you are unwrapping the optional and then<br>&gt;&gt; assigning it to the new variable<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve only read the last couple of posts but has anybody already suggested<br>&gt;&gt; using something like this:<br>&gt;&gt;<br>&gt;&gt; if let foo! {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; People already know that the ! is unwrapping a value and that let is<br>&gt;&gt; defining a new constant. So why not combine those two?<br>&gt;&gt; Alternatively it could also be:<br>&gt;&gt;<br>&gt;&gt; if let foo? {<br>&gt;&gt;   // code that uses foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; What do you think?<br>&gt;&gt;<br>&gt;&gt; – Cihat<br>&gt;&gt;<br>&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;<br>&gt;&gt; if has foo {<br>&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; guard has foo else { return }<br>&gt;&gt;<br>&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a<br>&gt;&gt; somewhat different mental model. Instead of unwrapping and immediately<br>&gt;&gt; assigning to a new constant with the same name (which just looks kind of<br>&gt;&gt; silly, like some magic voodoo ritual), it sort of asserts that we “have”<br>&gt;&gt; foo (i.e. it’s not nil), and therefore from that point it can just be<br>&gt;&gt; treated as non-optional.<br>&gt;&gt;<br>&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than<br>&gt;&gt; trying to reuse “let” in a context where it seems nonsensical. Perhaps this<br>&gt;&gt; would be closer to Swift’s goals, by reducing very common boilerplate, but<br>&gt;&gt; without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;<br>&gt;&gt; Curious to hear Chris Lattner’s opinion :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are<br>&gt;&gt; uncomfortable with the idea that a single declared property might have<br>&gt;&gt; different static types in different regions of code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; — Radek<br>&gt;&gt;<br>&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt;&gt;<br>&gt;&gt; if unwrap someViewController {<br>&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same<br>&gt;&gt; name only within this scope, boiling down to simple syntactic sugar for<br>&gt;&gt; optional binding and it is fairly clear.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt;&gt; you use some real world variable names:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt;&gt; information for this statement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find<br>&gt;&gt;&gt; somebody who&#39;d be able to understand either form without teaching; so not<br>&gt;&gt;&gt; losing much there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/bcc146d4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 07:00:00am</p></header><div class="content"><p>+1<br></p><p>Type narrowing would also fit nicely with union types (as demonstrated in Ceylon).<br></p><p>-Thorsten <br></p><p>&gt; Am 05.01.2016 um 23:37 schrieb Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;:<br>&gt; <br>&gt; That said, I am in favor of automatic type narrowing. As long as it doesn&#39;t complicate the compiler considerably (if it does, there&#39;s little reason to replace optional binding), it&#39;s no less confusing than shadowing was when I first saw it, and once you get used to it (shouldn&#39;t be more than a day): it is less verbose and perhaps more intuitive (I&#39;ve found myself reacting to optionals saying &quot;duh, I&#39;ve already guarded that X is nonnull on this codepath, why would I have to unwrap it again?&quot; in Swift).<br>&gt; <br>&gt;&gt; On Tue, Jan 5, 2016 at 5:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt;&gt; Thorsten,<br>&gt;&gt; <br>&gt;&gt; Not that I disapprove (Kotlin does the same and it&#39;s great), the precedent seems to have already been set in people&#39;s minds that there won&#39;t be any kind of implicit type narrowing and I predict a fair few will respond with &quot;You can already do that with optional binding, and I&#39;m uncomfortable seeing a variable change type in an inner scope&quot; even though shadowing achieves exactly the same aim. The same happened the last time that type narrowing was mentioned.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jan 5, 2016 at 5:27 PM Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Ceylon has type narrowing (not only for optional unwrapping but for type checks as well): http://ceylon-lang.org/documentation/1.2/tour/types/#narrowing_the_type_of_an_object_reference<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It always struck me as quite natural to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 02.01.2016 um 06:08 schrieb Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whoops, errant button tap.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve always thought that, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let foo = foo? {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; makes more sense than <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let foo = foo {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; as the ? indicates that you are unwrapping the optional and then assigning it to the new variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current syntax must seem incomprehensible/redundant to those new to Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems to be more consistent with ? being the operator for unwrapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course there is also the current optional pattern matching syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if case let foo? = foo {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This accomplishes the same thing and is somewhat less perplexing than &quot;if let foo = foo&quot;, but must still be baffling to a new user.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could even have:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if foo? {<br>&gt;&gt;&gt;&gt;     foo.blah()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which would not create a shadow local variable but would have the same semantics as<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo?.blah()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; in that is just providing conditional access to the variable if it&#39;s not .None. Not sure if this direct access is desired as it is still magical scoped type manipulation without declaring a new variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve always thought that, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let foo = foo? {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; makes more sense than <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if let foo = foo {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; as the ? indicates that you are unwrapping the optional and then assigning it to the new variable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve only read the last couple of posts but has anybody already suggested using something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let foo! {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; People already know that the ! is unwrapping a value and that let is defining a new constant. So why not combine those two?<br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatively it could also be:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if let foo? {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; – Cihat<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a somewhat different mental model. Instead of unwrapping and immediately assigning to a new constant with the same name (which just looks kind of silly, like some magic voodoo ritual), it sort of asserts that we “have” foo (i.e. it’s not nil), and therefore from that point it can just be treated as non-optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than trying to reuse “let” in a context where it seems nonsensical. Perhaps this would be closer to Swift’s goals, by reducing very common boilerplate, but without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are uncomfortable with the idea that a single declared property might have different static types in different regions of code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;? <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same name only within this scope, boiling down to simple syntactic sugar for optional binding and it is fairly clear. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/7aa16c07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  6, 2016 at 10:00:00am</p></header><div class="content"><p>We should add an unless one to compliement it :)<br></p><p>unless foo?<br>{<br>}<br></p><p>On Wed, Jan 6, 2016 at 6:16 AM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; Type narrowing would also fit nicely with union types (as demonstrated in<br>&gt; Ceylon).<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 05.01.2016 um 23:37 schrieb Dennis Lysenko &lt;dennis.s.lysenko at gmail.com<br>&gt; &gt;:<br>&gt;<br>&gt; That said, I am in favor of automatic type narrowing. As long as it<br>&gt; doesn&#39;t complicate the compiler considerably (if it does, there&#39;s little<br>&gt; reason to replace optional binding), it&#39;s no less confusing than shadowing<br>&gt; was when I first saw it, and once you get used to it (shouldn&#39;t be more<br>&gt; than a day): it is less verbose and perhaps more intuitive (I&#39;ve found<br>&gt; myself reacting to optionals saying &quot;duh, I&#39;ve already guarded that X is<br>&gt; nonnull on this codepath, why would I have to unwrap it again?&quot; in Swift).<br>&gt;<br>&gt; On Tue, Jan 5, 2016 at 5:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Thorsten,<br>&gt;&gt;<br>&gt;&gt; Not that I disapprove (Kotlin does the same and it&#39;s great), the<br>&gt;&gt; precedent seems to have already been set in people&#39;s minds that there won&#39;t<br>&gt;&gt; be any kind of implicit type narrowing and I predict a fair few will<br>&gt;&gt; respond with &quot;You can already do that with optional binding, and I&#39;m<br>&gt;&gt; uncomfortable seeing a variable change type in an inner scope&quot; even though<br>&gt;&gt; shadowing achieves exactly the same aim. The same happened the last time<br>&gt;&gt; that type narrowing was mentioned.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 5, 2016 at 5:27 PM Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Ceylon has type narrowing (not only for optional unwrapping but for type<br>&gt;&gt;&gt; checks as well):<br>&gt;&gt;&gt; http://ceylon-lang.org/documentation/1.2/tour/types/#narrowing_the_type_of_an_object_reference<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It always struck me as quite natural to do this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 02.01.2016 um 06:08 schrieb Tyler Fleming Cloutier via<br>&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Whoops, errant button tap.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve always thought that,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo? {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; makes more sense than<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; as the ? indicates that you are unwrapping the optional and then<br>&gt;&gt;&gt; assigning it to the new variable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The current syntax must seem incomprehensible/redundant to those new to<br>&gt;&gt;&gt; Swift. This obviously doesn&#39;t help with the verbosity at all, but it seems<br>&gt;&gt;&gt; to be more consistent with ? being the operator for unwrapping.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course there is also the current optional pattern matching syntax:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if case let foo? = foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This accomplishes the same thing and is somewhat less perplexing than<br>&gt;&gt;&gt; &quot;if let foo = foo&quot;, but must still be baffling to a new user.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You could even have:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if foo? {<br>&gt;&gt;&gt;     foo.blah()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Which would not create a shadow local variable but would have the same<br>&gt;&gt;&gt; semantics as<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; foo?.blah()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; in that is just providing conditional access to the variable if it&#39;s not<br>&gt;&gt;&gt; .None. Not sure if this direct access is desired as it is still magical<br>&gt;&gt;&gt; scoped type manipulation without declaring a new variable.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 1, 2016, at 11:44 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve always thought that,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo? {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; makes more sense than<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; as the ? indicates that you are unwrapping the optional and then<br>&gt;&gt;&gt; assigning it to the new variable<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 7:02 PM, Cihat Gündüz via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve only read the last couple of posts but has anybody already<br>&gt;&gt;&gt; suggested using something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo! {<br>&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; People already know that the ! is unwrapping a value and that let is<br>&gt;&gt;&gt; defining a new constant. So why not combine those two?<br>&gt;&gt;&gt; Alternatively it could also be:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo? {<br>&gt;&gt;&gt;   // code that uses foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Cihat<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 19.12.2015 um 23:43 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 2:15 PM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was going to suggest something similar (a hard naming problem also):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if has foo {<br>&gt;&gt;&gt;     // foo is now unwrapped and non-optional<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; guard has foo else { return }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does the same thing as `let foo = foo` in practice, but places it in a<br>&gt;&gt;&gt; somewhat different mental model. Instead of unwrapping and immediately<br>&gt;&gt;&gt; assigning to a new constant with the same name (which just looks kind of<br>&gt;&gt;&gt; silly, like some magic voodoo ritual), it sort of asserts that we “have”<br>&gt;&gt;&gt; foo (i.e. it’s not nil), and therefore from that point it can just be<br>&gt;&gt;&gt; treated as non-optional.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO this, although introduces a new keyword, makes more sense than<br>&gt;&gt;&gt; trying to reuse “let” in a context where it seems nonsensical. Perhaps this<br>&gt;&gt;&gt; would be closer to Swift’s goals, by reducing very common boilerplate, but<br>&gt;&gt;&gt; without harming clarity in a way adding a new meaning to “let” would.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Curious to hear Chris Lattner’s opinion :-)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IANACL (I am not a Chris Lattner) but, FWIW, several of us are<br>&gt;&gt;&gt; uncomfortable with the idea that a single declared property might have<br>&gt;&gt;&gt; different static types in different regions of code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 19 Dec 2015, at 21:31, Dennis Lysenko via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if we made the keyword &quot;unwrap&quot;?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if unwrap someViewController {<br>&gt;&gt;&gt; // now there is a shadowing nonoptional (unwrapped) variable of the same<br>&gt;&gt;&gt; name only within this scope, boiling down to simple syntactic sugar for<br>&gt;&gt;&gt; optional binding and it is fairly clear.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Dec 19, 2015, 1:31 PM Kevin Wooten via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt;&gt;&gt; you use some real world variable names:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt;&gt;&gt; information for this statement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find<br>&gt;&gt;&gt;&gt; somebody who&#39;d be able to understand either form without teaching; so not<br>&gt;&gt;&gt;&gt; losing much there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt;&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/1fcdc6a7/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>I prefer<br></p><p>if let vc = someInterestingViewConroller {<br>vc.doSomething()<br>}<br></p><p>- Explicit is better than implicit<br>- shadowing is bad<br>- now there&#39;s no ambiguity about how to change the original property.<br></p><p>Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or<br>increases shadowing, including let foo and unwrap foo.<br></p><p>On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As much fun as it to example with foo, I would argue the opposite when you<br>&gt; use some real world variable names:<br>&gt;<br>&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt; }<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; If let someInterestingViewConroller {<br>&gt; }<br>&gt;<br>&gt; We know what let does and it should be enough to impart the necessary<br>&gt; information for this statement.<br>&gt;<br>&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody<br>&gt; who&#39;d be able to understand either form without teaching; so not losing<br>&gt; much there.<br>&gt;<br>&gt;<br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt; altogether, another approach would be to use the existing name if no new<br>&gt; name is given, so that this code:<br>&gt;<br>&gt; if let foo = foo { /* use foo */ }<br>&gt;<br>&gt; could become this code:<br>&gt;<br>&gt; if let foo { /* use foo */ }<br>&gt;<br>&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt; another name with the if let syntax, that would work as it does today.<br>&gt;<br>&gt;<br>&gt; Hi Jeff,<br>&gt;<br>&gt; This is commonly requested - the problem is that while it does help reduce<br>&gt; boilerplate, it runs counter to the goal of improving clarity.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/c6a21cc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 12:37 PM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I prefer <br>&gt; <br>&gt; if let vc = someInterestingViewConroller {<br>&gt;   vc.doSomething()<br>&gt; }<br>&gt; <br>&gt; - Explicit is better than implicit<br>&gt; - shadowing is bad <br>&gt; - now there&#39;s no ambiguity about how to change the original property. <br>&gt; <br>&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or increases shadowing, including let foo and unwrap foo. <br></p><p>+1 to that.  IMO re-using the same name for the unwrapped version of an optional variable does not help readability, and I don&#39;t want to encourage it.  In a localized context like this, a short name is often better anyway as it declutters the code inside the block.<br></p><p>&gt; <br>&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt; <br>&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; If let someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt; <br>&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt; <br>&gt; <br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt; <br>&gt;&gt; Hi Jeff,<br>&gt;&gt; <br>&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/0a0d5bcd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>Disagree. Short names are less descriptive and less readable. And saying<br>&quot;shadowing is bad&quot; without any argument is just silly for a mailing list.<br></p><p>On Sat, Dec 19, 2015, 3:57 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 19, 2015, at 12:37 PM, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I prefer<br>&gt;<br>&gt; if let vc = someInterestingViewConroller {<br>&gt; vc.doSomething()<br>&gt; }<br>&gt;<br>&gt; - Explicit is better than implicit<br>&gt; - shadowing is bad<br>&gt; - now there&#39;s no ambiguity about how to change the original property.<br>&gt;<br>&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or<br>&gt; increases shadowing, including let foo and unwrap foo.<br>&gt;<br>&gt;<br>&gt; +1 to that.  IMO re-using the same name for the unwrapped version of an<br>&gt; optional variable does not help readability, and I don&#39;t want to encourage<br>&gt; it.  In a localized context like this, a short name is often better anyway<br>&gt; as it declutters the code inside the block.<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt; you use some real world variable names:<br>&gt;&gt;<br>&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; vs<br>&gt;&gt;<br>&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt; information for this statement.<br>&gt;&gt;<br>&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody<br>&gt;&gt; who&#39;d be able to understand either form without teaching; so not losing<br>&gt;&gt; much there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt; name is given, so that this code:<br>&gt;&gt;<br>&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; could become this code:<br>&gt;&gt;<br>&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;<br>&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Jeff,<br>&gt;&gt;<br>&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/67eb7c13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>Shadowing is good in this case because it lets you capture constant values<br>for the exact scope in which you need them. This helps avoid overhead of<br>repeated getters and method calls. Using shorter names is automatically<br>less descriptive; otherwise, people would advocate using abbreviations in<br>property names, which is a stylistic and readability faux pas.<br></p><p>On Sat, Dec 19, 2015, 4:34 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Disagree. Short names are less descriptive and less readable. And saying<br>&gt; &quot;shadowing is bad&quot; without any argument is just silly for a mailing list.<br>&gt;<br>&gt; On Sat, Dec 19, 2015, 3:57 PM Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 19, 2015, at 12:37 PM, ilya via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I prefer<br>&gt;&gt;<br>&gt;&gt; if let vc = someInterestingViewConroller {<br>&gt;&gt; vc.doSomething()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; - Explicit is better than implicit<br>&gt;&gt; - shadowing is bad<br>&gt;&gt; - now there&#39;s no ambiguity about how to change the original property.<br>&gt;&gt;<br>&gt;&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or<br>&gt;&gt; increases shadowing, including let foo and unwrap foo.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1 to that.  IMO re-using the same name for the unwrapped version of an<br>&gt;&gt; optional variable does not help readability, and I don&#39;t want to encourage<br>&gt;&gt; it.  In a localized context like this, a short name is often better anyway<br>&gt;&gt; as it declutters the code inside the block.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt;&gt; you use some real world variable names:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt;&gt; information for this statement.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find<br>&gt;&gt;&gt; somebody who&#39;d be able to understand either form without teaching; so not<br>&gt;&gt;&gt; losing much there.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/f961e7e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>Another argument is in a large block with several bound optionals, reusing<br>names prevents people from accidentally accessing optionals that were<br>already bound to non optional values.<br></p><p>We were all skeptical, I think, of reusing names in optional binding at<br>first (I thought it looked ugly), but I grew accustomed to it and it works<br>really well. Even Ray Wenderlich&#39;s style guide (only comprehensive one I&#39;ve<br>come across so far) suggests doing that. May I ask if those who oppose<br>shadowing in optional binding have ever actually given it a chance?<br></p><p>On Sat, Dec 19, 2015, 4:41 PM Dennis Lysenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Shadowing is good in this case because it lets you capture constant values<br>&gt; for the exact scope in which you need them. This helps avoid overhead of<br>&gt; repeated getters and method calls. Using shorter names is automatically<br>&gt; less descriptive; otherwise, people would advocate using abbreviations in<br>&gt; property names, which is a stylistic and readability faux pas.<br>&gt;<br>&gt; On Sat, Dec 19, 2015, 4:34 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Disagree. Short names are less descriptive and less readable. And saying<br>&gt;&gt; &quot;shadowing is bad&quot; without any argument is just silly for a mailing list.<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 19, 2015, 3:57 PM Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 19, 2015, at 12:37 PM, ilya via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I prefer<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if let vc = someInterestingViewConroller {<br>&gt;&gt;&gt; vc.doSomething()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Explicit is better than implicit<br>&gt;&gt;&gt; - shadowing is bad<br>&gt;&gt;&gt; - now there&#39;s no ambiguity about how to change the original property.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or<br>&gt;&gt;&gt; increases shadowing, including let foo and unwrap foo.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 to that.  IMO re-using the same name for the unwrapped version of an<br>&gt;&gt;&gt; optional variable does not help readability, and I don&#39;t want to encourage<br>&gt;&gt;&gt; it.  In a localized context like this, a short name is often better anyway<br>&gt;&gt;&gt; as it declutters the code inside the block.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As much fun as it to example with foo, I would argue the opposite when<br>&gt;&gt;&gt;&gt; you use some real world variable names:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We know what let does and it should be enough to impart the necessary<br>&gt;&gt;&gt;&gt; information for this statement.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find<br>&gt;&gt;&gt;&gt; somebody who&#39;d be able to understand either form without teaching; so not<br>&gt;&gt;&gt;&gt; losing much there.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax<br>&gt;&gt;&gt;&gt; altogether, another approach would be to use the existing name if no new<br>&gt;&gt;&gt;&gt; name is given, so that this code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it<br>&gt;&gt;&gt;&gt; another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is commonly requested - the problem is that while it does help<br>&gt;&gt;&gt;&gt; reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/eb5633d0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 1:41 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Shadowing is good in this case because it lets you capture constant values for the exact scope in which you need them.<br>&gt; <br>That is completely independent of shadowing.  You do that even if you choose different names inside the block from outside.<br>&gt; This helps avoid overhead of repeated getters and method calls. Using shorter names is automatically less descriptive; otherwise, people would advocate using abbreviations in property names, which is a stylistic and readability faux pas.<br>&gt; <br>&quot;More descriptive&quot; ≠ &quot;more readable&quot;.  When writing, we don&#39;t go into reams of detail about everything; we go into detail about the salient things.  We have pronouns for a reason, e.g. &quot;when a person arriving at the refrigerator opens the door, she sees what&#39;s inside; then she decides whether she wants it.&quot;  &quot;She&quot; is a short name used in a localized context as a stand-in for a more-descriptive phrase, &quot;a person arriving at the refrigerator&quot;.  Repeating the more descriptive phrase would harm readability.<br></p><p>&gt; <br>&gt; On Sat, Dec 19, 2015, 4:34 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt; Disagree. Short names are less descriptive and less readable. And saying &quot;shadowing is bad&quot; without any argument is just silly for a mailing list.<br>&gt; <br>&gt; <br>&gt; On Sat, Dec 19, 2015, 3:57 PM Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Dec 19, 2015, at 12:37 PM, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I prefer <br>&gt;&gt; <br>&gt;&gt; if let vc = someInterestingViewConroller {<br>&gt;&gt;   vc.doSomething()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - Explicit is better than implicit<br>&gt;&gt; - shadowing is bad <br>&gt;&gt; - now there&#39;s no ambiguity about how to change the original property. <br>&gt;&gt; <br>&gt;&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or increases shadowing, including let foo and unwrap foo. <br>&gt; <br>&gt; +1 to that.  IMO re-using the same name for the unwrapped version of an optional variable does not help readability, and I don&#39;t want to encourage it.  In a localized context like this, a short name is often better anyway as it declutters the code inside the block.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt;&gt; <br>&gt;&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; If let someInterestingViewConroller {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt;&gt; <br>&gt;&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Jeff,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/f18f77a2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December 19, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 1:37 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I prefer <br>&gt; <br>&gt; if let vc = someInterestingViewConroller {<br>&gt;   vc.doSomething()<br>&gt; }<br>&gt; <br>&gt; - Explicit is better than implicit<br>&gt; - shadowing is bad <br>&gt; - now there&#39;s no ambiguity about how to change the original property. <br>&gt; <br></p><p>Creating a less descriptive short name in place of usually more descriptive name, which is already used throughout your code, is not “more explicit”.  You’ve removed shadowing and instead created two separately name variables referring to the same value. You’ve created _more_ ambiguity, not less.<br></p><p>Also, for 1 line blocks of code, “vc” might be ok but blocks 20 lines long that contain other contrived names, just to remove shadowing, (e.g. “vc2”, using your example) is only going to make it worse.<br></p><p>&gt; Therefore I&#39;m -1 on any proposal that hides explicit name binding and/or increases shadowing, including let foo and unwrap foo. <br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 21:31 Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; As much fun as it to example with foo, I would argue the opposite when you use some real world variable names:<br>&gt; <br>&gt; if let someInterestingViewConroller = someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; If let someInterestingViewConroller {<br>&gt; }<br>&gt; <br>&gt; We know what let does and it should be enough to impart the necessary information for this statement.<br>&gt; <br>&gt; When it comes to newcomers I think you&#39;d be hard pressed to find somebody who&#39;d be able to understand either form without teaching; so not losing much there.<br>&gt; <br>&gt; <br>&gt; On Dec 19, 2015, at 10:01 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 8:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve had similar ideas to this. Instead of ditching the if let syntax altogether, another approach would be to use the existing name if no new name is given, so that this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo = foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; could become this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let foo { /* use foo */ }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In both cases, foo is non-optional inside the braces. If you gave it another name with the if let syntax, that would work as it does today.<br>&gt;&gt; <br>&gt;&gt; Hi Jeff,<br>&gt;&gt; <br>&gt;&gt; This is commonly requested - the problem is that while it does help reduce boilerplate, it runs counter to the goal of improving clarity.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/3c86ce41/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>This was discussed in the old forums... ah, those times :)<br></p><p>As before, I don&#39;t think this idea is workable, because this only works for<br>names that describe local variables and only if they are not captured by<br>long-running closures.<br></p><p>Imagine the code<br></p><p>class C {<br>  var layer: CALayer? { can be changed from other threads }<br></p><p>  func f() {<br>    var nearestX = X()<br></p><p>    doSomethingAsync {<br>        nearestX = compute(...)<br>    }<br></p><p>    // later<br></p><p>    if nearestX != nil {<br>      // *can&#39;t* use nearestX without unwrapping<br>    }<br></p><p>    guard layer != nil else { continue }<br>    // *can&#39;t* use layer without force unwrapping<br>  }<br>}<br></p><p>This will, however, work if we do create a new name that shadows an old<br>name with if let nearestX = nearestX or guard let layer = layer.<br>let here plays an important role by reminding that original nearestX or<br>layer may have already changed in the meantime.<br></p><p>I agree this shadowing may not look best if nearestX and layer *are* plain<br>old local variables. In that case those names are under your control and I<br>would find this refactoring benefitial:<br></p><p>    let maybe_nearestX = ...<br>    let maybe_layer = ...<br></p><p>    if let nearestX = maybe_nearestX {<br>      // use nearestX<br>    }<br></p><p>    guard let layer = maybe_layer else { continue }<br>    // use layer<br></p><p><br>On Fri, Dec 11, 2015 at 7:11 PM, Daniel Hooper via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if<br>&gt; let&quot; optionals  - this works by creating a new non-optional variable to be<br>&gt; used by future code. Often, the new variable is given the same name as the<br>&gt; original optional variable, creating a shadow variable. This approach leads<br>&gt; to odd looking code like this:<br>&gt;<br>&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; guard let layer = layer else { continue }<br>&gt; // use layer<br>&gt;<br>&gt; At a glance, and to Swift newcomers, this code looks completely<br>&gt; non-sensical. It&#39;s also verbose for simply ensuring the variable is<br>&gt; non-nil.<br>&gt;<br>&gt; The solution:<br>&gt; Swift should generate unwrapped shadow variables after nil checking. The<br>&gt; compiler would treat the below code as if it had created an unwrapped<br>&gt; shadow variable.<br>&gt;<br>&gt; if nearestX != nil { closest = nearestX } // notice that nearestX isn&#39;t<br>&gt; force unwrapped<br>&gt; guard layer != nil else { continue }<br>&gt; // use layer, without force unwrapping<br>&gt;<br>&gt; Why force unwrapping isn&#39;t a good alternative:<br>&gt; You might suggest force unwrapping variables when they&#39;re inside an if or<br>&gt; after a guard that checks for nil. While this does allow for the &quot;layer =<br>&gt; nil&quot; syntax, it results in code that is less resilient to change. Imagine<br>&gt; that this code was written:<br>&gt;<br>&gt; {code:java}<br>&gt; if layer != nil {<br>&gt; // lots of code before //<br>&gt; layer!.backgroundColor = newColor<br>&gt; // lots of code after //<br>&gt; }<br>&gt; {code}<br>&gt;<br>&gt; And much later, you need to use some of the the code in the if body<br>&gt; elsewhere, so you copy and paste a huge chunk of it. You likely won&#39;t<br>&gt; notice the force unwrap, and unless you&#39;re lucky, you probably didn&#39;t paste<br>&gt; it into an if that checked layer for nil. So you get a crash. Because of<br>&gt; this, it&#39;s important we make safe optional unwrapping as easy and sensical<br>&gt; as possible, and minimize the situations that you would need to force<br>&gt; unwrap.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/1ac0c0d1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal Sketch: simplify optional unwrapping syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 19, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 8:11 AM, Daniel Hooper via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A very common pattern in swift code is to &quot;guard let&quot; or &quot;if let&quot; optionals  - this works by creating a new non-optional variable to be used by future code. Often, the new variable is given the same name as the original optional variable, creating a shadow variable. This approach leads to odd looking code like this:<br>&gt; <br>&gt; if let nearestX = nearestX { closest = nearestX }<br>&gt; guard let layer = layer else { continue } <br>&gt; // use layer<br>&gt; <br>&gt; At a glance, and to Swift newcomers, this code looks completely non-sensical. It&#39;s also verbose for simply ensuring the variable is non-nil. <br>&gt; <br>&gt; The solution:<br>&gt; Swift should generate unwrapped shadow variables after nil checking. The compiler would treat the below code as if it had created an unwrapped shadow variable.<br></p><p>Hi Daniel,<br></p><p>We discussed this extensively (and for a while this was plan of record to implement) but it has some pretty significant challenges.  The main problem is that it makes it extremely unclear and unpredictable what the type of a variable is.  One of the primary reasons we constrain type inference to a statement boundary to is to make it more clear what is going on.  You don’t have “spooky type action at a distance” like you do in some other languages with whole-function type inference.<br></p><p>Type confusion is particularly problematic here because the different cases you have depending on what T? is:<br></p><p>- With something like Int?, there are many operations that make sense on Int but not on Int?<br>- With something like [Int]?, there are operations (like map) that make sense on both types.<br>- Some operations are completely common between the two (e.g. “let x = v”).<br></p><p>Further, swift has an implicit promotion from T to T?, which can cause extremely confusing downstream errors if you’re not aware of what is going on.  There are also implementation concerns as well.<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
