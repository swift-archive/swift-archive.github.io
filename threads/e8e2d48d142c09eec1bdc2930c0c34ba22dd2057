<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 11:00:00am</p></header><div class="content"><p>Hello all,<br></p><p>I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br></p><p>It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br></p><p>Thanks,<br></p><p>~Robert Widmann<br></p><p>Qualified Imports Revisited<br></p><p>Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>Status: Awaiting review<br>Review manager: TBD<br></p><p> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br></p><p>We propose a complete overhaul of the qualified imports syntax and semantics.<br></p><p><br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br></p><p>The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br></p><p>import class Foundation.Date<br>This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br></p><p><br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br></p><p>The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br></p><p><br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br></p><p>Qualified import syntax will be revised to the following<br></p><p>import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>import-path -&gt; &lt;identifier&gt;<br>            -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>import-directive-list -&gt; &lt;import-directive&gt;<br>                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>import-directive -&gt; using (&lt;identifier&gt;, ...)<br>                 -&gt; hiding (&lt;identifier&gt;, ...)<br>This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br></p><p>1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br></p><p>// The only visible parts of Foundation in this file are <br>// Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>//<br>// Previously, this was<br>// import class Foundation.Date<br>// import class Foundation.DateFormatter<br>// import class Foundation.DateComponents<br>import Foundation using (Date, DateFormatter, DateComponents)<br>2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br></p><p>// Imports all of Foundation except `Date`<br>import Foundation hiding (Date)<br>As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br></p><p>// Imports `DateFormatter` but the declaration of `Date` is hidden.<br>import Foundation using (DateFormatter)<br></p><p>var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>Import directives chain to one another and can be used to create a fine-grained module import:<br></p><p>// This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>import Swift using (String, Int, Double) <br>             hiding (String.UTF8View)<br>Directive chaining occurs left-to-right:<br></p><p>// This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>// because 1) Int is available 2) String is not, error.<br>import Swift using (Int) hiding (String)<br>// Valid.  This will be merged as `using (Int)`<br>import Swift using () using (Int)<br>// Valid.  This will be merged as `hiding (String, Double)`<br>import Swift hiding (String) hiding (Double) hiding ()<br>// Valid (if redundant). This will be merged as `using ()`<br>import Swift using (String) hiding (String)<br>Because import directives are file-local, they will never be exported along with the module that declares them.<br></p><p><br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br></p><p>Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br></p><p><br> &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br></p><p>A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e8e22057/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 20, 2016 at 02:00:00pm</p></header><div class="content"><p>As Joe and others mentioned in the previous thread, this syntax could be<br>greatly simplified in ways that resemble analogous facilities in other<br>languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>proposal, `import Swift using (String)` imports *only* String while `import<br>Swift hiding (String)` imports *everything but* String. This becomes<br>evident when chained together:<br></p><p>```<br>import Swift using (String, Int)<br>// imports only String and Int<br>import Swift using (String, Int) hiding (String)<br>// imports only Int<br>import Swift hiding (String, Int)<br>// imports everything except String and Int<br>import Swift hiding (String, Int) using (String)<br>// imports *nothing*? nothing except String? everything except Int?<br>confusing.<br>```<br></p><p>By contrast, Joe&#39;s proposed syntax (with some riffs) produces something<br>much more terse *and* much more clear:<br></p><p>```<br>import Swift.*<br>import Swift.(Int as MyInt, *)<br>import Swift.(Int as _, *)<br>```<br></p><p><br>On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello all,<br>&gt;<br>&gt; I’d like to thank the members of the community that have guided the<br>&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt; community and break down our original proposal on modules and qualified<br>&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt; are pushing that proposal now as our final draft.<br>&gt;<br>&gt; It can be had inline with this email, on Github<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; Qualified Imports Revisited<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan<br>&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt; semantics.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt; looks something like this<br>&gt;<br>&gt; import class Foundation.Date<br>&gt;<br>&gt; This means that clients of Foundation that wish to see only Date must<br>&gt; know the exact kind of declaration that identifier is. In addition, though<br>&gt; this import specifies exactly one class be imported from Foundation, the<br>&gt; actual semantics mean Swift will recursively open all of Foundation&#39;s<br>&gt; submodules so you can see, and use, every other identifier anyway - and<br>&gt; they are not filtered from code completion. Qualified imports deserve to be<br>&gt; first-class in Swift, and that is what we intend to make them with this<br>&gt; proposal.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The grammar and semantics of qualified imports will change completely with<br>&gt; the addition of *import qualifiers* and *import directives*. We also<br>&gt; introduce two new contextual keywords: using and hiding, to facilitate<br>&gt; fine-grained usage of module contents.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Qualified import syntax will be revised to the following<br>&gt;<br>&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;<br>&gt; This introduces the concept of an import *directive*. An import directive<br>&gt; is a file-local modification of an imported identifier. A directive can be<br>&gt; one of 2 operations:<br>&gt;<br>&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt; for non-member nominal declarations within the imported module that should<br>&gt; be exposed to this file.<br>&gt;<br>&gt; // The only visible parts of Foundation in this file are // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents//// Previously, this was// import class Foundation.Date// import class Foundation.DateFormatter// import class Foundation.DateComponentsimport Foundation using (Date, DateFormatter, DateComponents)<br>&gt;<br>&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt; for non-member nominal declarations within the imported module that should<br>&gt; be hidden from this file.<br>&gt;<br>&gt; // Imports all of Foundation except `Date`import Foundation hiding (Date)<br>&gt;<br>&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt; that type’s members and its declaration. For example, this means values of<br>&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt; their members is forbidden.<br>&gt;<br>&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.import Foundation using (DateFormatter)<br>&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Validvar dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;<br>&gt; Import directives chain to one another and can be used to create a<br>&gt; fine-grained module import:<br>&gt;<br>&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8Viewimport Swift using (String, Int, Double)<br>&gt;              hiding (String.UTF8View)<br>&gt;<br>&gt; Directive chaining occurs left-to-right:<br>&gt;<br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error.import Swift using (Int) hiding (String)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;<br>&gt; Because import directives are file-local, they will never be exported<br>&gt; along with the module that declares them.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Existing code that is using qualified module import syntax (import<br>&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt; be deprecated and should be removed or migrated.<br>&gt;<br>&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; A previous iteration of this proposal introduced an operation to allow the<br>&gt; renaming of identifiers, especially members. The original intent was to<br>&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt; their specific coding style. On review, we felt the feature was not as<br>&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt; projects.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/9b1d8a08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;m not very fond of this proposal at all as I don&#39;t believe there<br>will be much gain with it (correct me if I&#39;m wrong but libraries in<br>Swift are monolithic and nothing to Java, where there is a benefit in<br>doing this). That said, if this really has to go, Joe&#39;s syntax seems<br>much cleaner but I&#39;d drop the requirement for a dot and implicitly<br>require anything by omiting the parenthesis. Thus:<br></p><p>   import Swift<br>   import Swift(Int as MyInt, *)<br>   import Swift(Int as _, *)<br></p><p>Also supporting this form does not break existing code since the first<br>option here is how we already do.<br></p><p>L<br></p><p>On 20 July 2016 at 16:08, Xiaodi Wu via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; As Joe and others mentioned in the previous thread, this syntax could be<br>&gt; greatly simplified in ways that resemble analogous facilities in other<br>&gt; languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>&gt; proposal, `import Swift using (String)` imports *only* String while `import<br>&gt; Swift hiding (String)` imports *everything but* String. This becomes evident<br>&gt; when chained together:<br>&gt;<br>&gt; ```<br>&gt; import Swift using (String, Int)<br>&gt; // imports only String and Int<br>&gt; import Swift using (String, Int) hiding (String)<br>&gt; // imports only Int<br>&gt; import Swift hiding (String, Int)<br>&gt; // imports everything except String and Int<br>&gt; import Swift hiding (String, Int) using (String)<br>&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt; confusing.<br>&gt; ```<br>&gt;<br>&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much<br>&gt; more terse *and* much more clear:<br>&gt;<br>&gt; ```<br>&gt; import Swift.*<br>&gt; import Swift.(Int as MyInt, *)<br>&gt; import Swift.(Int as _, *)<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt;&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt;&gt; community and break down our original proposal on modules and qualified<br>&gt;&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt;&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt;&gt; are pushing that proposal now as our final draft.<br>&gt;&gt;<br>&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt; semantics.<br>&gt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt;&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt;&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt;&gt; looks something like this<br>&gt;&gt;<br>&gt;&gt; import class Foundation.Date<br>&gt;&gt;<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must know<br>&gt;&gt; the exact kind of declaration that identifier is. In addition, though this<br>&gt;&gt; import specifies exactly one class be imported from Foundation, the actual<br>&gt;&gt; semantics mean Swift will recursively open all of Foundation&#39;s submodules so<br>&gt;&gt; you can see, and use, every other identifier anyway - and they are not<br>&gt;&gt; filtered from code completion. Qualified imports deserve to be first-class<br>&gt;&gt; in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; The grammar and semantics of qualified imports will change completely with<br>&gt;&gt; the addition of import qualifiers and import directives. We also introduce<br>&gt;&gt; two new contextual keywords: using and hiding, to facilitate fine-grained<br>&gt;&gt; usage of module contents.<br>&gt;&gt;<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;<br>&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;<br>&gt;&gt; This introduces the concept of an import directive. An import directive is<br>&gt;&gt; a file-local modification of an imported identifier. A directive can be one<br>&gt;&gt; of 2 operations:<br>&gt;&gt;<br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers for<br>&gt;&gt; non-member nominal declarations within the imported module that should be<br>&gt;&gt; exposed to this file.<br>&gt;&gt;<br>&gt;&gt; // The only visible parts of Foundation in this file are<br>&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and<br>&gt;&gt; Foundation.DateComponents<br>&gt;&gt; //<br>&gt;&gt; // Previously, this was<br>&gt;&gt; // import class Foundation.Date<br>&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for<br>&gt;&gt; non-member nominal declarations within the imported module that should be<br>&gt;&gt; hidden from this file.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt;&gt; that type’s members and its declaration. For example, this means values of<br>&gt;&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt;&gt; their members is forbidden.<br>&gt;&gt;<br>&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;<br>&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use<br>&gt;&gt; name of hidden type.<br>&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;<br>&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt; fine-grained module import:<br>&gt;&gt;<br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides<br>&gt;&gt; Swift.String.UTF8View<br>&gt;&gt; import Swift using (String, Int, Double)<br>&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;<br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It<br>&gt;&gt; is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;<br>&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt; along with the module that declares them.<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be<br>&gt;&gt; deprecated and should be removed or migrated.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; A previous iteration of this proposal introduced an operation to allow the<br>&gt;&gt; renaming of identifiers, especially members. The original intent was to<br>&gt;&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt;&gt; their specific coding style. On review, we felt the feature was not as<br>&gt;&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt;&gt; projects.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>July 21, 2016 at 01:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/07/20 12:19、Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I&#39;m not very fond of this proposal at all as I don&#39;t believe there<br>&gt; will be much gain with it (correct me if I&#39;m wrong but libraries in<br>&gt; Swift are monolithic and nothing to Java, where there is a benefit in<br>&gt; doing this). That said, if this really has to go, Joe&#39;s syntax seems<br>&gt; much cleaner but I&#39;d drop the requirement for a dot and implicitly<br>&gt; require anything by omiting the parenthesis. Thus:<br>&gt; <br>&gt;   import Swift<br>&gt;   import Swift(Int as MyInt, *)<br>&gt;   import Swift(Int as _, *)<br>&gt; <br>&gt; Also supporting this form does not break existing code since the first<br>&gt; option here is how we already do.<br>&gt; <br></p><p>Reread the proposal please.  Qualified import syntax is being subsumed by ours (and Joe&#39;s) syntax.  This is a breaking change.<br></p><p>Second, while this is more concise, it is not more semantically meaningful and does not reasonably extend to any other operations.  It does not fit any existing syntax in Swift outside of compiler attributes (of which import is not one), and assumes that renaming is a common operation without actually specifying how it works with re-export.<br></p><p>In short: I can&#39;t read this.  It&#39;s small, it&#39;s convenient, but it&#39;s semantically meaningless.<br></p><p>&gt; L<br>&gt; <br>&gt; On 20 July 2016 at 16:08, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be<br>&gt;&gt; greatly simplified in ways that resemble analogous facilities in other<br>&gt;&gt; languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>&gt;&gt; proposal, `import Swift using (String)` imports *only* String while `import<br>&gt;&gt; Swift hiding (String)` imports *everything but* String. This becomes evident<br>&gt;&gt; when chained together:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; import Swift using (String, Int)<br>&gt;&gt; // imports only String and Int<br>&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt; // imports only Int<br>&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt; // imports everything except String and Int<br>&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt;&gt; confusing.<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much<br>&gt;&gt; more terse *and* much more clear:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; import Swift.*<br>&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt;&gt;&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt;&gt;&gt; community and break down our original proposal on modules and qualified<br>&gt;&gt;&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt;&gt;&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt;&gt;&gt; are pushing that proposal now as our final draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt;&gt;&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt;&gt;&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt;&gt;&gt; looks something like this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know<br>&gt;&gt;&gt; the exact kind of declaration that identifier is. In addition, though this<br>&gt;&gt;&gt; import specifies exactly one class be imported from Foundation, the actual<br>&gt;&gt;&gt; semantics mean Swift will recursively open all of Foundation&#39;s submodules so<br>&gt;&gt;&gt; you can see, and use, every other identifier anyway - and they are not<br>&gt;&gt;&gt; filtered from code completion. Qualified imports deserve to be first-class<br>&gt;&gt;&gt; in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with<br>&gt;&gt;&gt; the addition of import qualifiers and import directives. We also introduce<br>&gt;&gt;&gt; two new contextual keywords: using and hiding, to facilitate fine-grained<br>&gt;&gt;&gt; usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is<br>&gt;&gt;&gt; a file-local modification of an imported identifier. A directive can be one<br>&gt;&gt;&gt; of 2 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for<br>&gt;&gt;&gt; non-member nominal declarations within the imported module that should be<br>&gt;&gt;&gt; exposed to this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are<br>&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and<br>&gt;&gt;&gt; Foundation.DateComponents<br>&gt;&gt;&gt; //<br>&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for<br>&gt;&gt;&gt; non-member nominal declarations within the imported module that should be<br>&gt;&gt;&gt; hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt;&gt;&gt; that type’s members and its declaration. For example, this means values of<br>&gt;&gt;&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt;&gt;&gt; their members is forbidden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use<br>&gt;&gt;&gt; name of hidden type.<br>&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt;&gt; fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides<br>&gt;&gt;&gt; Swift.String.UTF8View<br>&gt;&gt;&gt; import Swift using (String, Int, Double)<br>&gt;&gt;&gt;             hiding (String.UTF8View)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It<br>&gt;&gt;&gt; is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt;&gt; along with the module that declares them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be<br>&gt;&gt;&gt; deprecated and should be removed or migrated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the<br>&gt;&gt;&gt; renaming of identifiers, especially members. The original intent was to<br>&gt;&gt;&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt;&gt;&gt; their specific coding style. On review, we felt the feature was not as<br>&gt;&gt;&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt;&gt;&gt; projects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt; <br>&gt; ```<br>&gt; import Swift using (String, Int)<br>&gt; // imports only String and Int<br>&gt; import Swift using (String, Int) hiding (String)<br>&gt; // imports only Int<br>&gt; import Swift hiding (String, Int)<br>&gt; // imports everything except String and Int<br>&gt; import Swift hiding (String, Int) using (String)<br>&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt; ```<br>&gt; <br>&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt; <br>&gt; ```<br>&gt; import Swift.*<br>&gt; import Swift.(Int as MyInt, *)<br>&gt; import Swift.(Int as _, *)<br>&gt; ```<br></p><p>I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br></p><p>Joe&#39;s syntax has a lot going on in my opinion.<br></p><p>For the proposal, do we really need the parentheses? It makes the syntax look heavier<br></p><p>Brandon <br></p><p><br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt; <br>&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports Revisited<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt; <br>&gt;&gt; import class Foundation.Date<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt; //<br>&gt;&gt; // Previously, this was<br>&gt;&gt; // import class Foundation.Date<br>&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt; <br>&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt; <br>&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/0f224342/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Yeah, I&#39;d be happy to lose the parentheses as well.<br></p><p>In the last thread, my take on simplifying the proposed syntax was:<br></p><p>```<br>import Swift using String, Int<br></p><p>// or, for hiding:<br>import Swift using Int as _<br>```<br></p><p>The key simplification here is that hiding doesn&#39;t need its own contextual<br>keyboard, especially if we support renaming (a huge plus in my book), as<br>renaming to anything unused (or explicitly to `_`) is what hiding is all<br>about.<br>On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; As Joe and others mentioned in the previous thread, this syntax could be<br>&gt; greatly simplified in ways that resemble analogous facilities in other<br>&gt; languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>&gt; proposal, `import Swift using (String)` imports *only* String while `import<br>&gt; Swift hiding (String)` imports *everything but* String. This becomes<br>&gt; evident when chained together:<br>&gt;<br>&gt; ```<br>&gt; import Swift using (String, Int)<br>&gt; // imports only String and Int<br>&gt; import Swift using (String, Int) hiding (String)<br>&gt; // imports only Int<br>&gt; import Swift hiding (String, Int)<br>&gt; // imports everything except String and Int<br>&gt; import Swift hiding (String, Int) using (String)<br>&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt; confusing.<br>&gt; ```<br>&gt;<br>&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something<br>&gt; much more terse *and* much more clear:<br>&gt;<br>&gt; ```<br>&gt; import Swift.*<br>&gt; import Swift.(Int as MyInt, *)<br>&gt; import Swift.(Int as _, *)<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; I really don&#39;t find this much clearer than the proposed one. The proposal<br>&gt; reads much clearer.<br>&gt;<br>&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;<br>&gt; For the proposal, do we really need the parentheses? It makes the syntax<br>&gt; look heavier<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello all,<br>&gt;&gt;<br>&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt;&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt;&gt; community and break down our original proposal on modules and qualified<br>&gt;&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt;&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt;&gt; are pushing that proposal now as our final draft.<br>&gt;&gt;<br>&gt;&gt; It can be had inline with this email, on Github<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan<br>&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt; semantics.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt;&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt;&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt;&gt; looks something like this<br>&gt;&gt;<br>&gt;&gt; import class Foundation.Date<br>&gt;&gt;<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must<br>&gt;&gt; know the exact kind of declaration that identifier is. In addition, though<br>&gt;&gt; this import specifies exactly one class be imported from Foundation, the<br>&gt;&gt; actual semantics mean Swift will recursively open all of Foundation&#39;s<br>&gt;&gt; submodules so you can see, and use, every other identifier anyway - and<br>&gt;&gt; they are not filtered from code completion. Qualified imports deserve to be<br>&gt;&gt; first-class in Swift, and that is what we intend to make them with this<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The grammar and semantics of qualified imports will change completely<br>&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt; also introduce two new contextual keywords: using and hiding, to<br>&gt;&gt; facilitate fine-grained usage of module contents.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;<br>&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;<br>&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt; directive can be one of 2 operations:<br>&gt;&gt;<br>&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt; be exposed to this file.<br>&gt;&gt;<br>&gt;&gt; // The only visible parts of Foundation in this file are // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents//// Previously, this was// import class Foundation.Date// import class Foundation.DateFormatter// import class Foundation.DateComponentsimport Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;<br>&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt; be hidden from this file.<br>&gt;&gt;<br>&gt;&gt; // Imports all of Foundation except `Date`import Foundation hiding (Date)<br>&gt;&gt;<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt;&gt; that type’s members and its declaration. For example, this means values of<br>&gt;&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt;&gt; their members is forbidden.<br>&gt;&gt;<br>&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.import Foundation using (DateFormatter)<br>&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Validvar dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;<br>&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt; fine-grained module import:<br>&gt;&gt;<br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8Viewimport Swift using (String, Int, Double)<br>&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;<br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error.import Swift using (Int) hiding (String)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;<br>&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt; along with the module that declares them.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will<br>&gt;&gt; be deprecated and should be removed or migrated.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt; A previous iteration of this proposal introduced an operation to allow<br>&gt;&gt; the renaming of identifiers, especially members. The original intent was to<br>&gt;&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt;&gt; their specific coding style. On review, we felt the feature was not as<br>&gt;&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt;&gt; projects.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/a6ecf65b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I prefer this 100x more<br></p><p>Is there any reason why this wouldn&#39;t work?<br></p><p>Brandon <br></p><p>&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt; <br>&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt; <br>&gt; ```<br>&gt; import Swift using String, Int<br>&gt; <br>&gt; // or, for hiding:<br>&gt; import Swift using Int as _<br>&gt; ```<br>&gt; <br>&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt; <br>&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt; <br>&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/07aca597/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 01:00:00pm</p></header><div class="content"><p>Renaming is out of scope for this proposal, that’s why.<br></p><p>&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; I prefer this 100x more<br>&gt; <br>&gt; Is there any reason why this wouldn&#39;t work?<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt; <br>&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; import Swift using String, Int<br>&gt;&gt; <br>&gt;&gt; // or, for hiding:<br>&gt;&gt; import Swift using Int as _<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt; <br>&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt; <br>&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt; //<br>&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/344c0ccd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I meant is there any reason for requiring parentheses <br></p><p>&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I prefer this 100x more<br>&gt;&gt; <br>&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/8135324f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Why is hiding in-scope but renaming out-of-scope? Both are additive to<br>Swift, and as has been argued by others, the former is a special case of<br>the latter.<br></p><p>On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; I meant is there any reason for requiring parentheses<br>&gt;<br>&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;<br>&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;<br>&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt; I prefer this 100x more<br>&gt;<br>&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;<br>&gt; Brandon<br>&gt;<br>&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;<br>&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;<br>&gt; ```<br>&gt; import Swift using String, Int<br>&gt;<br>&gt; // or, for hiding:<br>&gt; import Swift using Int as _<br>&gt; ```<br>&gt;<br>&gt; The key simplification here is that hiding doesn&#39;t need its own contextual<br>&gt; keyboard, especially if we support renaming (a huge plus in my book), as<br>&gt; renaming to anything unused (or explicitly to `_`) is what hiding is all<br>&gt; about.<br>&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be<br>&gt;&gt; greatly simplified in ways that resemble analogous facilities in other<br>&gt;&gt; languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>&gt;&gt; proposal, `import Swift using (String)` imports *only* String while `import<br>&gt;&gt; Swift hiding (String)` imports *everything but* String. This becomes<br>&gt;&gt; evident when chained together:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; import Swift using (String, Int)<br>&gt;&gt; // imports only String and Int<br>&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt; // imports only Int<br>&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt; // imports everything except String and Int<br>&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt;&gt; confusing.<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something<br>&gt;&gt; much more terse *and* much more clear:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; import Swift.*<br>&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal<br>&gt;&gt; reads much clearer.<br>&gt;&gt;<br>&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;<br>&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax<br>&gt;&gt; look heavier<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt;&gt;&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt;&gt;&gt; community and break down our original proposal on modules and qualified<br>&gt;&gt;&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt;&gt;&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt;&gt;&gt; are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It can be had inline with this email, on Github<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan<br>&gt;&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt;&gt;&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt;&gt;&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt;&gt;&gt; looks something like this<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must<br>&gt;&gt;&gt; know the exact kind of declaration that identifier is. In addition, though<br>&gt;&gt;&gt; this import specifies exactly one class be imported from Foundation, the<br>&gt;&gt;&gt; actual semantics mean Swift will recursively open all of Foundation&#39;s<br>&gt;&gt;&gt; submodules so you can see, and use, every other identifier anyway - and<br>&gt;&gt;&gt; they are not filtered from code completion. Qualified imports deserve to be<br>&gt;&gt;&gt; first-class in Swift, and that is what we intend to make them with this<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt;&gt; solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely<br>&gt;&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt;&gt; also introduce two new contextual keywords: using and hiding, to<br>&gt;&gt;&gt; facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt;&gt; design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt;&gt; directive can be one of 2 operations:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt;&gt; be exposed to this file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents//// Previously, this was// import class Foundation.Date// import class Foundation.DateFormatter// import class Foundation.DateComponentsimport Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt;&gt; be hidden from this file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Imports all of Foundation except `Date`import Foundation hiding (Date)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt;&gt;&gt; that type’s members and its declaration. For example, this means values of<br>&gt;&gt;&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt;&gt;&gt; their members is forbidden.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.import Foundation using (DateFormatter)<br>&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Validvar dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt;&gt; fine-grained module import:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8Viewimport Swift using (String, Int, Double)<br>&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error.import Swift using (Int) hiding (String)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt;&gt; along with the module that declares them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;)<br>&gt;&gt;&gt; will be deprecated and should be removed or migrated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; considered<br>&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow<br>&gt;&gt;&gt; the renaming of identifiers, especially members. The original intent was to<br>&gt;&gt;&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt;&gt;&gt; their specific coding style. On review, we felt the feature was not as<br>&gt;&gt;&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt;&gt;&gt; projects.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/f314423a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Why is hiding in-scope but renaming out-of-scope?<br></p><p><br>Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br></p><p>&gt; Both are additive to Swift,<br></p><p>As part of this proposal, both are source-breaking.<br></p><p>&gt; and as has been argued by others, the former is a special case of the latter.<br></p><p>A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br></p><p>&gt; <br>&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt; I meant is there any reason for requiring parentheses <br>&gt; <br>&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/0847154f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 2:04 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt; <br>&gt; <br>&gt; Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br>&gt; <br></p><p>I mistyped.  Should be &quot;Because hiding and using can be used in combination to subset out APIs, not alter them.&quot;<br></p><p>&gt;&gt; Both are additive to Swift, <br>&gt; <br>&gt; As part of this proposal, both are source-breaking.<br>&gt; <br>&gt;&gt; and as has been argued by others, the former is a special case of the latter.<br>&gt; <br>&gt; A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/b7a19037/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jul 20, 2016 at 4:06 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 20, 2016, at 2:04 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Because hiding and renaming can be used in combination to subset out APIs,<br>&gt; not alter them.<br>&gt;<br>&gt;<br>&gt; I mistyped.  Should be &quot;Because hiding and using can be used in<br>&gt; combination to subset out APIs, not alter them.&quot;<br>&gt;<br></p><p><br>Sure, I buy that.<br></p><p>Both are additive to Swift,<br>&gt;<br>&gt;<br>&gt; As part of this proposal, both are source-breaking.<br>&gt;<br>&gt;<br>I don&#39;t see how. If hiding were cut from the proposal, adding it later with<br>even the exact syntax you propose should break no pre-existing code--am I<br>wrong?<br></p><p>and as has been argued by others, the former is a special case of the<br>&gt; latter.<br>&gt;<br>&gt;<br>&gt; A special case that cannot cause large-scale file-relative changes to<br>&gt; APIs.  Renaming is primarily used in other languages that treat free<br>&gt; functions as more canonical than we do, or allow operator definitions that<br>&gt; can be used as notation.<br>&gt;<br>&gt;<br>I don&#39;t know about &#39;primary use,&#39; but the most common use I&#39;ve experienced<br>in Python, for example, is the mundane task of importing module Foo2 as Foo.<br></p><p><br>&gt; In those cases, you often have your own notation you’d like to use.  In<br>&gt; Swift, such changes should be rare enough that if you can’t solve them with<br>&gt; a disambiguating qualified import then you can just redeclare the<br>&gt; identifier some other way (typealias, top-level let, wrapper class,<br>&gt; whatever).<br>&gt;<br>&gt;<br>You&#39;ve already stripped out renaming of members from the proposal. I agree<br>wholeheartedly. The only flavor of renaming I&#39;m thinking of here is<br>equivalent to a fileprivate typealias and hiding, which cannot be done in<br>this version of the proposal because hiding always comes before<br>typealiasing and you can&#39;t typealias what isn&#39;t imported. It isn&#39;t about<br>altering APIs any more than a fileprivate typealias can be thought of as<br>altering APIs.<br></p><p><br>&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; I meant is there any reason for requiring parentheses<br>&gt;&gt;<br>&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;<br>&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I prefer this 100x more<br>&gt;&gt;<br>&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;<br>&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; import Swift using String, Int<br>&gt;&gt;<br>&gt;&gt; // or, for hiding:<br>&gt;&gt; import Swift using Int as _<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own<br>&gt;&gt; contextual keyboard, especially if we support renaming (a huge plus in my<br>&gt;&gt; book), as renaming to anything unused (or explicitly to `_`) is what hiding<br>&gt;&gt; is all about.<br>&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be<br>&gt;&gt;&gt; greatly simplified in ways that resemble analogous facilities in other<br>&gt;&gt;&gt; languages. In particular I think it&#39;s alarmingly asymmetrical that, in your<br>&gt;&gt;&gt; proposal, `import Swift using (String)` imports *only* String while `import<br>&gt;&gt;&gt; Swift hiding (String)` imports *everything but* String. This becomes<br>&gt;&gt;&gt; evident when chained together:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt;&gt;&gt; confusing.<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something<br>&gt;&gt;&gt; much more terse *and* much more clear:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The<br>&gt;&gt;&gt; proposal reads much clearer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax<br>&gt;&gt;&gt; look heavier<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt;&gt;&gt;&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt;&gt;&gt;&gt; community and break down our original proposal on modules and qualified<br>&gt;&gt;&gt;&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt;&gt;&gt;&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt;&gt;&gt;&gt; are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It can be had inline with this email, on Github<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;    &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan<br>&gt;&gt;&gt;&gt;    &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;&gt;&gt;    - Review manager: TBD<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt;&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;<br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt;&gt;&gt;&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt;&gt;&gt;&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt;&gt;&gt;&gt; looks something like this<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must<br>&gt;&gt;&gt;&gt; know the exact kind of declaration that identifier is. In addition, though<br>&gt;&gt;&gt;&gt; this import specifies exactly one class be imported from Foundation, the<br>&gt;&gt;&gt;&gt; actual semantics mean Swift will recursively open all of Foundation&#39;s<br>&gt;&gt;&gt;&gt; submodules so you can see, and use, every other identifier anyway - and<br>&gt;&gt;&gt;&gt; they are not filtered from code completion. Qualified imports deserve to be<br>&gt;&gt;&gt;&gt; first-class in Swift, and that is what we intend to make them with this<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt; solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely<br>&gt;&gt;&gt;&gt; with the addition of *import qualifiers* and *import directives*. We<br>&gt;&gt;&gt;&gt; also introduce two new contextual keywords: using and hiding, to<br>&gt;&gt;&gt;&gt; facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt; design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This introduces the concept of an import *directive*. An import<br>&gt;&gt;&gt;&gt; directive is a file-local modification of an imported identifier. A<br>&gt;&gt;&gt;&gt; directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) *using*: The *using* directive is followed by a list of identifiers<br>&gt;&gt;&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt;&gt;&gt; be exposed to this file.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents//// Previously, this was// import class Foundation.Date// import class Foundation.DateFormatter// import class Foundation.DateComponentsimport Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2) *hiding*: The hiding directive is followed by a list of identifiers<br>&gt;&gt;&gt;&gt; for non-member nominal declarations within the imported module that should<br>&gt;&gt;&gt;&gt; be hidden from this file.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide<br>&gt;&gt;&gt;&gt; that type’s members and its declaration. For example, this means values of<br>&gt;&gt;&gt;&gt; hidden types are still allowed. Unlike the existing implementation, using<br>&gt;&gt;&gt;&gt; their members is forbidden.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Validvar dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt;&gt;&gt;&gt; fine-grained module import:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8Viewimport Swift using (String, Int, Double)<br>&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid// because 1) Int is available 2) String is not, error.import Swift using (Int) hiding (String)// Valid.  This will be merged as `using (Int)`import Swift using () using (Int)// Valid.  This will be merged as `hiding (String, Double)`import Swift hiding (String) hiding (Double) hiding ()// Valid (if redundant). This will be merged as `using ()`import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported<br>&gt;&gt;&gt;&gt; along with the module that declares them.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt; on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt;&gt;&gt;&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;)<br>&gt;&gt;&gt;&gt; will be deprecated and should be removed or migrated.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;&gt; considered<br>&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow<br>&gt;&gt;&gt;&gt; the renaming of identifiers, especially members. The original intent was to<br>&gt;&gt;&gt;&gt; allow file-local modifications of APIs consumers felt needed to conform to<br>&gt;&gt;&gt;&gt; their specific coding style. On review, we felt the feature was not as<br>&gt;&gt;&gt;&gt; significant as to warrant inclusion and was ripe for abuse in large<br>&gt;&gt;&gt;&gt; projects.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e8b6cdd4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>Hiding is not necessary if you import into a pseudo container... It means the ide does not have to keep track of whats here whats not on a per source file basis....<br></p><p>Import CoreGraphics as cg<br>cg.xxxxx<br></p><p>Collisions are always avoided and there is only adding imports. Simple.<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 20, 2016, at 11:04 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt; <br>&gt; <br>&gt; Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br>&gt; <br>&gt;&gt; Both are additive to Swift,<br>&gt; <br>&gt; As part of this proposal, both are source-breaking.<br>&gt; <br>&gt;&gt; and as has been argued by others, the former is a special case of the latter.<br>&gt; <br>&gt; A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/dca59271/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 03:00:00pm</p></header><div class="content"><p>As cannot (and should not) hide substructures and can be added later if you so desire.<br></p><p><br>&gt; On Jul 20, 2016, at 3:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hiding is not necessary if you import into a pseudo container... It means the ide does not have to keep track of whats here whats not on a per source file basis....<br>&gt; <br>&gt; Import CoreGraphics as cg<br>&gt; cg.xxxxx<br>&gt; <br>&gt; Collisions are always avoided and there is only adding imports. Simple.<br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 20, 2016, at 11:04 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br>&gt;&gt; <br>&gt;&gt;&gt; Both are additive to Swift,<br>&gt;&gt; <br>&gt;&gt; As part of this proposal, both are source-breaking.<br>&gt;&gt; <br>&gt;&gt;&gt; and as has been argued by others, the former is a special case of the latter.<br>&gt;&gt; <br>&gt;&gt; A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/e675ea03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 01:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 21, 2016, at 12:38 AM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt; As cannot (and should not) hide substructures and can be added later if you so desire.<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 3:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hiding is not necessary if you import into a pseudo container... It means the ide does not have to keep track of whats here whats not on a per source file basis....<br>&gt;&gt; <br>&gt;&gt; Import CoreGraphics as cg<br>&gt;&gt; cg.xxxxx<br>&gt;&gt; <br>&gt;&gt; Collisions are always avoided and there is only adding imports. Simple.<br>&gt;&gt; <br></p><p>and what&#39;s more:<br></p><p>  Import CoreGraphics as cg<br>  cg.xxxxx()<br></p><p>and <br>  Import CoreGraphics<br>  xxxxx()<br></p><p>don&#39;t even require two separate internal implementations in the compiler... Done well, the exact same code can handle both scenarios. <br></p><p><br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 11:04 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both are additive to Swift,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As part of this proposal, both are source-breaking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and as has been argued by others, the former is a special case of the latter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/40620db7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 04:00:00pm</p></header><div class="content"><p>I am confused as to why you think this would necessitate multiple phases of import logic to implement.  We already have code that essentially does this baked into the code completion system. &lt;https://github.com/apple/swift/blob/f72bd5453f2fa4f89d075d90210cb41c124c9e74/tools/SourceKit/lib/SwiftLang/SwiftCompletion.cpp#L1128-L1131&gt;<br></p><p>Moreover, I’m not convinced that shuffling identifiers off into a “pseudo-container” is the right idea for an operation we already know how to perform.<br></p><p>&gt; On Jul 20, 2016, at 4:05 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 21, 2016, at 12:38 AM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; As cannot (and should not) hide substructures and can be added later if you so desire.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 3:36 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hiding is not necessary if you import into a pseudo container... It means the ide does not have to keep track of whats here whats not on a per source file basis....<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Import CoreGraphics as cg<br>&gt;&gt;&gt; cg.xxxxx<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collisions are always avoided and there is only adding imports. Simple.<br>&gt;&gt;&gt; <br>&gt; <br>&gt; and what&#39;s more:<br>&gt; <br>&gt;   Import CoreGraphics as cg<br>&gt;   cg.xxxxx()<br>&gt; <br>&gt; and <br>&gt;   Import CoreGraphics<br>&gt;   xxxxx()<br>&gt; <br>&gt; don&#39;t even require two separate internal implementations in the compiler... Done well, the exact same code can handle both scenarios. <br>&gt; <br>&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 11:04 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why is hiding in-scope but renaming out-of-scope?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because hiding and renaming can be used in combination to subset out APIs, not alter them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Both are additive to Swift,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As part of this proposal, both are source-breaking.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and as has been argued by others, the former is a special case of the latter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A special case that cannot cause large-scale file-relative changes to APIs.  Renaming is primarily used in other languages that treat free functions as more canonical than we do, or allow operator definitions that can be used as notation.  In those cases, you often have your own notation you’d like to use.  In Swift, such changes should be rare enough that if you can’t solve them with a disambiguating qualified import then you can just redeclare the identifier some other way (typealias, top-level let, wrapper class, whatever).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com &lt;mailto:rwidmann at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/47f85a29/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 21, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why is hiding in-scope but renaming out-of-scope? Both are additive to Swift, and as has been argued by others, the former is a special case of the latter.<br></p><p>Hiding also doesn&#39;t seem useful to me at all. The main use case I can see is to resolve a name conflict introduced between two import-everything declarations, or between an imported and local name, and both of these use cases seem better served to me by a name lookup rule that locals are favored over qualified imports, which in turn are favored over everything imports. &#39;hiding&#39; puts the import declaration in the wrong place. Consider that:<br></p><p>	import Foo hiding foo<br>	import Bar<br></p><p>	foo()<br></p><p>declares the un-import of &#39;foo&#39; next to &#39;Foo&#39;. The user (or IDE) has to do the mental gymnastics to figure out that &#39;foo()&#39; refers to Bar.foo() by omission. This is much clearer expressed with &#39;using&#39;, which puts the disambiguation next to the chosen module:<br></p><p>	import Foo<br>	import Bar<br>	import Bar using foo // favor Bar.foo over Foo.foo<br></p><p>	foo()<br></p><p>&#39;using&#39; is also more resilient against module evolution; as modules gain new members, their clients would potentially be forced to play whack-a-mole with &#39;hiding&#39; as new conflicts are introduced. A user who diligently uses qualified imports doesn&#39;t need to worry about that. I would suggest removing &#39;hiding&#39; in favor of a rule like this.<br></p><p>-Joe<br></p><p>&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; I meant is there any reason for requiring parentheses <br>&gt; <br>&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt; 	• Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt;&gt;  using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; d<br>&gt;&gt;&gt;&gt;&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double<br>&gt;&gt;&gt;&gt;&gt; ) <br>&gt;&gt;&gt;&gt;&gt;              hiding (<br>&gt;&gt;&gt;&gt;&gt; String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String<br>&gt;&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int<br>&gt;&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt;&gt;&gt;&gt; ) hiding ()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 21, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree with your line of reasoning regarding not needing &#39;hiding&#39;<br>(leveraging order of lookup as you noted).<br>On Thu, Jul 21, 2016 at 12:41 PM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Why is hiding in-scope but renaming out-of-scope? Both are additive to<br>&gt; Swift, and as has been argued by others, the former is a special case of<br>&gt; the latter.<br>&gt;<br>&gt; Hiding also doesn&#39;t seem useful to me at all. The main use case I can see<br>&gt; is to resolve a name conflict introduced between two import-everything<br>&gt; declarations, or between an imported and local name, and both of these use<br>&gt; cases seem better served to me by a name lookup rule that locals are<br>&gt; favored over qualified imports, which in turn are favored over everything<br>&gt; imports. &#39;hiding&#39; puts the import declaration in the wrong place. Consider<br>&gt; that:<br>&gt;<br>&gt;         import Foo hiding foo<br>&gt;         import Bar<br>&gt;<br>&gt;         foo()<br>&gt;<br>&gt; declares the un-import of &#39;foo&#39; next to &#39;Foo&#39;. The user (or IDE) has to do<br>&gt; the mental gymnastics to figure out that &#39;foo()&#39; refers to Bar.foo() by<br>&gt; omission. This is much clearer expressed with &#39;using&#39;, which puts the<br>&gt; disambiguation next to the chosen module:<br>&gt;<br>&gt;         import Foo<br>&gt;         import Bar<br>&gt;         import Bar using foo // favor Bar.foo over Foo.foo<br>&gt;<br>&gt;         foo()<br>&gt;<br>&gt; &#39;using&#39; is also more resilient against module evolution; as modules gain<br>&gt; new members, their clients would potentially be forced to play whack-a-mole<br>&gt; with &#39;hiding&#39; as new conflicts are introduced. A user who diligently uses<br>&gt; qualified imports doesn&#39;t need to worry about that. I would suggest<br>&gt; removing &#39;hiding&#39; in favor of a rule like this.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; &gt; I meant is there any reason for requiring parentheses<br>&gt; &gt;<br>&gt; &gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I prefer this 100x more<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Brandon<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; // or, for hiding:<br>&gt; &gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt; &gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own<br>&gt; contextual keyboard, especially if we support renaming (a huge plus in my<br>&gt; book), as renaming to anything unused (or explicitly to `_`) is what hiding<br>&gt; is all about.<br>&gt; &gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax<br>&gt; could be greatly simplified in ways that resemble analogous facilities in<br>&gt; other languages. In particular I think it&#39;s alarmingly asymmetrical that,<br>&gt; in your proposal, `import Swift using (String)` imports *only* String while<br>&gt; `import Swift hiding (String)` imports *everything but* String. This<br>&gt; becomes evident when chained together:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt; &gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt; &gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt; &gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt; &gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int?<br>&gt; confusing.<br>&gt; &gt;&gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces<br>&gt; something much more terse *and* much more clear:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt; &gt;&gt;&gt;&gt;&gt; ```<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The<br>&gt; proposal reads much clearer.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the<br>&gt; syntax look heavier<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Brandon<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the<br>&gt; revisions of this proposal.  We have decided to heed the advice of the<br>&gt; community and break down our original proposal on modules and qualified<br>&gt; imports into source-breaking (qualified imports) and additive (modules)<br>&gt; proposals.  As qualified imports is the change most suited to Swift 3, we<br>&gt; are pushing that proposal now as our final draft.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;   • Proposal: SE-NNNN<br>&gt; &gt;&gt;&gt;&gt;&gt;   • Authors: Robert Widmann, TJ Usiyan<br>&gt; &gt;&gt;&gt;&gt;&gt;   • Status: Awaiting review<br>&gt; &gt;&gt;&gt;&gt;&gt;   • Review manager: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and<br>&gt; semantics.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly<br>&gt; explicit, does not compose, and has a default semantics that dilutes the<br>&gt; intended meaning of the very operation itself. Today, a qualified import<br>&gt; looks something like this<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt; &gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date<br>&gt; must know the exact kind of declaration that identifier is. In addition,<br>&gt; though this import specifies exactly one class be imported from Foundation,<br>&gt; the actual semantics mean Swift will recursively open all of Foundation&#39;s<br>&gt; submodules so you can see, and use, every other identifier anyway - and<br>&gt; they are not filtered from code completion. Qualified imports deserve to be<br>&gt; first-class in Swift, and that is what we intend to make them with this<br>&gt; proposal.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change<br>&gt; completely with the addition of import qualifiers and import directives. We<br>&gt; also introduce two new contextual keywords: using and hiding, to facilitate<br>&gt; fine-grained usage of module contents.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt; &gt;&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import<br>&gt; directive is a file-local modification of an imported identifier. A<br>&gt; directive can be one of 2 operations:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers<br>&gt; for non-member nominal declarations within the imported module that should<br>&gt; be exposed to this file.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are<br>&gt; &gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and<br>&gt; Foundation.DateComponents<br>&gt; &gt;&gt;&gt;&gt;&gt; //<br>&gt; &gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt; &gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt; &gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt; &gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt; &gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt; &gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers<br>&gt; for non-member nominal declarations within the imported module that should<br>&gt; be hidden from this file.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt; &gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt; &gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely<br>&gt; hide that type’s members and its declaration. For example, this means<br>&gt; values of hidden types are still allowed. Unlike the existing<br>&gt; implementation, using their members is forbidden.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt; &gt;&gt;&gt;&gt;&gt; import Foundation<br>&gt; &gt;&gt;&gt;&gt;&gt;  using (DateFormatter)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt; &gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot<br>&gt; use name of hidden type.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; d<br>&gt; &gt;&gt;&gt;&gt;&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt; &gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a<br>&gt; fine-grained module import:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides<br>&gt; Swift.String.UTF8View<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double<br>&gt; &gt;&gt;&gt;&gt;&gt; )<br>&gt; &gt;&gt;&gt;&gt;&gt;              hiding (<br>&gt; &gt;&gt;&gt;&gt;&gt; String.UTF8View)<br>&gt; &gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to<br>&gt; Triple.  It is invalid<br>&gt; &gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String<br>&gt; &gt;&gt;&gt;&gt;&gt; )<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using () using (Int<br>&gt; &gt;&gt;&gt;&gt;&gt; )<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt; &gt;&gt;&gt;&gt;&gt; ) hiding ()<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; &gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt; &gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be<br>&gt; exported along with the module that declares them.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import<br>&gt; {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be<br>&gt; deprecated and should be removed or migrated.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to<br>&gt; allow the renaming of identifiers, especially members. The original intent<br>&gt; was to allow file-local modifications of APIs consumers felt needed to<br>&gt; conform to their specific coding style. On review, we felt the feature was<br>&gt; not as significant as to warrant inclusion and was ripe for abuse in large<br>&gt; projects.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/cd45ca9b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 9:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 1:59 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why is hiding in-scope but renaming out-of-scope? Both are additive to Swift, and as has been argued by others, the former is a special case of the latter.<br>&gt; <br>&gt; Hiding also doesn&#39;t seem useful to me at all. The main use case I can see is to resolve a name conflict introduced between two import-everything declarations, or between an imported and local name, and both of these use cases seem better served to me by a name lookup rule that locals are favored over qualified imports, which in turn are favored over everything imports. &#39;hiding&#39; puts the import declaration in the wrong place. Consider that:<br>&gt; <br>&gt; 	import Foo hiding foo<br>&gt; 	import Bar<br>&gt; <br>&gt; 	foo()<br>&gt; <br>&gt; declares the un-import of &#39;foo&#39; next to &#39;Foo&#39;. The user (or IDE) has to do the mental gymnastics to figure out that &#39;foo()&#39; refers to Bar.foo() by omission. This is much clearer expressed with &#39;using&#39;, which puts the disambiguation next to the chosen module:<br>&gt; <br></p><p>We were already doing those gymnastics before (in fact, one of the diagnostics for the old style would remind you of the correct decl kind if you thought a struct was a class etc.  Clearly, we already know).  If you want to be explicit, <br></p><p>import Bar using (foo)<br>import Foo hiding (foo)<br></p><p>import Bar<br></p><p>Works just fine.  <br></p><p>The lookup rule seems to be justifying introducing the “confusing” example above.  It would definitely work, but why not just be explicit about what you’re using and what you’re hiding?<br></p><p>&gt; 	import Foo<br>&gt; 	import Bar<br>&gt; 	import Bar using foo // favor Bar.foo over Foo.foo<br>&gt; <br>&gt; 	foo()<br>&gt; <br>&gt; &#39;using&#39; is also more resilient against module evolution; as modules gain new members, their clients would potentially be forced to play whack-a-mole with &#39;hiding&#39; as new conflicts are introduced. A user who diligently uses qualified imports doesn&#39;t need to worry about that. I would suggest removing &#39;hiding&#39; in favor of a rule like this.<br></p><p>Is this not the same case with using declarations as the client module evolves?  It is more likely that a using import will grow in size as a module evolves than a hiding one - after all a hiding import says you explicitly intend to use everything else.  And if you start hiding enough identifiers that it becomes unwieldy you can always flip the script and use a using directive.  The same applies the other way around for big using clauses.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Wed, Jul 20, 2016 at 15:55 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; I meant is there any reason for requiring parentheses <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 4:53 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Renaming is out of scope for this proposal, that’s why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 1:26 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I prefer this 100x more<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there any reason why this wouldn&#39;t work?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 4:13 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, I&#39;d be happy to lose the parentheses as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the last thread, my take on simplifying the proposed syntax was:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; import Swift using String, Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // or, for hiding:<br>&gt;&gt;&gt;&gt;&gt; import Swift using Int as _<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The key simplification here is that hiding doesn&#39;t need its own contextual keyboard, especially if we support renaming (a huge plus in my book), as renaming to anything unused (or explicitly to `_`) is what hiding is all about.<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 15:01 Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 20, 2016, at 3:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As Joe and others mentioned in the previous thread, this syntax could be greatly simplified in ways that resemble analogous facilities in other languages. In particular I think it&#39;s alarmingly asymmetrical that, in your proposal, `import Swift using (String)` imports *only* String while `import Swift hiding (String)` imports *everything but* String. This becomes evident when chained together:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports only String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports only Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports everything except String and Int<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String, Int) using (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; // imports *nothing*? nothing except String? everything except Int? confusing.<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; By contrast, Joe&#39;s proposed syntax (with some riffs) produces something much more terse *and* much more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.*<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as MyInt, *)<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift.(Int as _, *)<br>&gt;&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really don&#39;t find this much clearer than the proposed one. The proposal reads much clearer. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Joe&#39;s syntax has a lot going on in my opinion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For the proposal, do we really need the parentheses? It makes the syntax look heavier<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jul 20, 2016 at 1:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt;&gt;&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt;&gt;&gt; using (DateFormatter)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; d<br>&gt;&gt;&gt;&gt;&gt;&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String, Int, Double<br>&gt;&gt;&gt;&gt;&gt;&gt; ) <br>&gt;&gt;&gt;&gt;&gt;&gt;             hiding (<br>&gt;&gt;&gt;&gt;&gt;&gt; String.UTF8View)<br>&gt;&gt;&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String<br>&gt;&gt;&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using () using (Int<br>&gt;&gt;&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt;&gt;&gt;&gt;&gt; ) hiding ()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/08cb1a35/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>One thing to consider is that Swift has compound names, and also extension members, which are modularized but also scoped to the extended nominal type or protocol. Extension method collisions are a non-theoretical issue. Whatever bikeshed we pick, we&#39;ll want a syntax able to support something like this:<br></p><p>// Pick Int extension members from Module<br>import Module using Int.extensionProperty, Int.extensionMethod(label:)<br></p><p>Maybe there&#39;s also a need to pick a specific decl out of an overload set by type. I hope not…<br></p><p>-Joe<br></p><p>&gt; On Jul 20, 2016, at 11:52 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt; <br>&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports Revisited<br>&gt; <br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Authors: Robert Widmann, TJ Usiyan<br>&gt; 	• Status: Awaiting review<br>&gt; 	• Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt; <br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt; <br>&gt; import class Foundation.Date<br>&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt; <br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt; //<br>&gt; // Previously, this was<br>&gt; // import class Foundation.Date<br>&gt; // import class Foundation.DateFormatter<br>&gt; // import class Foundation.DateComponents<br>&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation except `Date`<br>&gt; import Foundation hiding (Date)<br>&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt; <br>&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt; import Foundation<br>&gt;  using (DateFormatter)<br>&gt; <br>&gt; <br>&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt; <br>&gt; d<br>&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt; import Swift using (String, Int, Double<br>&gt; ) <br>&gt;              hiding (<br>&gt; String.UTF8View)<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error.<br>&gt; import Swift using (Int) hiding (String<br>&gt; )<br>&gt; <br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int<br>&gt; )<br>&gt; <br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double<br>&gt; ) hiding ()<br>&gt; <br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Max and I had a discussion about how overloading would work here.  We came to the conclusion that we probably don’t need an “overload picker” because it defeats the point of an overloaded name in the first place.  <br></p><p>As for the extension members, the current qualified import mechanism doesn’t allow you to get that specific and I don’t see a reason why we should either.  Plus we dropped member imports from the revision :)<br></p><p>That can come later as an additive change on top of this system.<br></p><p>&gt; On Jul 20, 2016, at 5:53 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; One thing to consider is that Swift has compound names, and also extension members, which are modularized but also scoped to the extended nominal type or protocol. Extension method collisions are a non-theoretical issue. Whatever bikeshed we pick, we&#39;ll want a syntax able to support something like this:<br>&gt; <br>&gt; // Pick Int extension members from Module<br>&gt; import Module using Int.extensionProperty, Int.extensionMethod(label:)<br>&gt; <br>&gt; Maybe there&#39;s also a need to pick a specific decl out of an overload set by type. I hope not…<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 11:52 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt; <br>&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports Revisited<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt; 	• Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt; <br>&gt;&gt; import class Foundation.Date<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;            -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                      -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                 -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt; <br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt; //<br>&gt;&gt; // Previously, this was<br>&gt;&gt; // import class Foundation.Date<br>&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt; <br>&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt; import Foundation<br>&gt;&gt; using (DateFormatter)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt; <br>&gt;&gt; d<br>&gt;&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt; import Swift using (String, Int, Double<br>&gt;&gt; ) <br>&gt;&gt;             hiding (<br>&gt;&gt; String.UTF8View)<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt; import Swift using (Int) hiding (String<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt; ) hiding ()<br>&gt;&gt; <br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:56 PM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt; Max and I had a discussion about how overloading would work here.  We came to the conclusion that we probably don’t need an “overload picker” because it defeats the point of an overloaded name in the first place.  <br>&gt; <br>&gt; As for the extension members, the current qualified import mechanism doesn’t allow you to get that specific and I don’t see a reason why we should either.  Plus we dropped member imports from the revision :)<br></p><p>I suppose it can be added later, but I consider the inability to deal with extension method conflicts to be a pretty serious language shortcoming today. It would be nice to fix that.<br></p><p>-Joe<br></p><p>&gt; That can come later as an additive change on top of this system.<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 5:53 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One thing to consider is that Swift has compound names, and also extension members, which are modularized but also scoped to the extended nominal type or protocol. Extension method collisions are a non-theoretical issue. Whatever bikeshed we pick, we&#39;ll want a syntax able to support something like this:<br>&gt;&gt; <br>&gt;&gt; // Pick Int extension members from Module<br>&gt;&gt; import Module using Int.extensionProperty, Int.extensionMethod(label:)<br>&gt;&gt; <br>&gt;&gt; Maybe there&#39;s also a need to pick a specific decl out of an overload set by type. I hope not…<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 11:52 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Proposal: SE-NNNN<br>&gt;&gt;&gt; 	• Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt; 	• Status: Awaiting review<br>&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;           -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                     -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt; //<br>&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; using (DateFormatter)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; d<br>&gt;&gt;&gt; .addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt; import Swift using (String, Int, Double<br>&gt;&gt;&gt; ) <br>&gt;&gt;&gt;            hiding (<br>&gt;&gt;&gt; String.UTF8View)<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double<br>&gt;&gt;&gt; ) hiding ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>July 21, 2016 at 01:00:00am</p></header><div class="content"><p>Thanks for writing these up, I found them clear and easy to read.<br></p><p>While I don’t know the precise inspirations, both of these drafts seem more or less in line with the sorts of modules and importing that’s found in Haskell. I’d much prefer these facilities not be added to Swift. I would much rather see Swift develop in the direction of ML and add something like first-class modules and (module) functors. After writing a lot of both Haskell and ML family languages, I can say from experience that the Haskell-style approach is broadly inferior.<br></p><p>I have no idea if first-class modules are on the Core Team’s collective mind, but it’s what I’d advocate for.<br></p><p>-Colin<br></p><p>&gt; On Jul 20, 2016, at 2:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt; <br>&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; Qualified Imports Revisited<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt; <br>&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt; <br>&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt; <br>&gt; import class Foundation.Date<br>&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Qualified import syntax will be revised to the following<br>&gt; <br>&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt; //<br>&gt; // Previously, this was<br>&gt; // import class Foundation.Date<br>&gt; // import class Foundation.DateFormatter<br>&gt; // import class Foundation.DateComponents<br>&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation except `Date`<br>&gt; import Foundation hiding (Date)<br>&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt; <br>&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt; import Foundation using (DateFormatter)<br>&gt; <br>&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt; import Swift using (String, Int, Double) <br>&gt;              hiding (String.UTF8View)<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error.<br>&gt; import Swift using (Int) hiding (String)<br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int)<br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt; <br>&gt; <br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/f67e1fed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 20, 2016 at 11:00:00pm</p></header><div class="content"><p>This approach in no way rules out that direction and the syntax here was built with a module system in mind.  Agda modules admit the kind of abstraction you’re looking for, but they call them Parameterized Modules and they take after Coq’s sections rather than SML’s module functors.  I can assure you, this proposal has nothing to do with Haskell and everything to do with trying to approach scoping and imports with their mindset.<br></p><p>&gt; On Jul 20, 2016, at 10:18 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; <br>&gt; Thanks for writing these up, I found them clear and easy to read.<br>&gt; <br>&gt; While I don’t know the precise inspirations, both of these drafts seem more or less in line with the sorts of modules and importing that’s found in Haskell. I’d much prefer these facilities not be added to Swift. I would much rather see Swift develop in the direction of ML and add something like first-class modules and (module) functors. After writing a lot of both Haskell and ML family languages, I can say from experience that the Haskell-style approach is broadly inferior.<br>&gt; <br>&gt; I have no idea if first-class modules are on the Core Team’s collective mind, but it’s what I’d advocate for.<br>&gt; <br>&gt; -Colin<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 2:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt; <br>&gt;&gt; It can be had inline with this email, on Github &lt;https://github.com/apple/swift-evolution/pull/440&gt;, or as a gist &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6&gt;.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; Qualified Imports Revisited<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CodaFi/NNNN-first-class-qualified-imports.md&gt;<br>&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, TJ Usiyan &lt;https://github.com/griotspeak&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt; <br>&gt;&gt; import class Foundation.Date<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt; <br>&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt; //<br>&gt;&gt; // Previously, this was<br>&gt;&gt; // import class Foundation.Date<br>&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt; <br>&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt; <br>&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/572a1c8e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m not sure how any of that&#39;s relevant to what I said. (I&#39;m on my phone. Please excuse any incoherence or typos.) Your module system from the other proposal is, like in Haskell, tied to the directory structure of the project, which is in my mind an anti-pattern. And I don&#39;t believe either SML or OCaml have a way to selectively import (open in ML terms), much less do renaming. Using ML style modules a bunch has me convinced. Beyond first-class modules, the key aspects of ML germane to this proposal in my mind are: qualified import by default (module statement) and separating identifier search (open statement) from re-exporting (include statement). Local open is also a big deal.<br></p><p>For anyone else in the thread curious about ML modules, my friend Danny wrote this up a while ago, it&#39;s quite good http://jozefg.bitbucket.org/posts/2015-01-08-modules.html<br></p><p>-Colin (via thumbs)<br></p><p>&gt; On Jul 21, 2016, at 2:28 AM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt; This approach in no way rules out that direction and the syntax here was built with a module system in mind.  Agda modules admit the kind of abstraction you’re looking for, but they call them Parameterized Modules and they take after Coq’s sections rather than SML’s module functors.  I can assure you, this proposal has nothing to do with Haskell and everything to do with trying to approach scoping and imports with their mindset.<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 10:18 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for writing these up, I found them clear and easy to read.<br>&gt;&gt; <br>&gt;&gt; While I don’t know the precise inspirations, both of these drafts seem more or less in line with the sorts of modules and importing that’s found in Haskell. I’d much prefer these facilities not be added to Swift. I would much rather see Swift develop in the direction of ML and add something like first-class modules and (module) functors. After writing a lot of both Haskell and ML family languages, I can say from experience that the Haskell-style approach is broadly inferior.<br>&gt;&gt; <br>&gt;&gt; I have no idea if first-class modules are on the Core Team’s collective mind, but it’s what I’d advocate for.<br>&gt;&gt; <br>&gt;&gt; -Colin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 2:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt; //<br>&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/7c1d1f36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>July 21, 2016 at 09:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/07/21 8:21、Colin Barrett via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I&#39;m not sure how any of that&#39;s relevant to what I said. (I&#39;m on my phone. Please excuse any incoherence or typos.) Your module system from the other proposal is, like in Haskell, tied to the directory structure of the project, which is in my mind an anti-pattern.<br></p><p>This thread is about qualified imports.  I initially thought you mean the import system wouldn&#39;t scale to accommodate ML-style modules.   Now I see this is just about modules.  We need to postpone this discussion until that proposal comes up, or use the old thread to voice this please.<br></p><p><br>&gt; And I don&#39;t believe either SML or OCaml have a way to selectively import (open in ML terms), much less do renaming. Using ML style modules a bunch has me convinced. Beyond first-class modules, the key aspects of ML germane to this proposal in my mind are: qualified import by default (module statement) and separating identifier search (open statement) from re-exporting (include statement). Local open is also a big deal.<br></p><p>It is a big deal, we know about it, and we wanted it.  It is out of scope for this proposal.<br></p><p>&gt; <br>&gt; For anyone else in the thread curious about ML modules, my friend Danny wrote this up a while ago, it&#39;s quite good http://jozefg.bitbucket.org/posts/2015-01-08-modules.html<br>&gt; <br></p><p>Seconded.  Fine blog. <br></p><p>&gt; -Colin (via thumbs)<br>&gt; <br>&gt;&gt; On Jul 21, 2016, at 2:28 AM, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This approach in no way rules out that direction and the syntax here was built with a module system in mind.  Agda modules admit the kind of abstraction you’re looking for, but they call them Parameterized Modules and they take after Coq’s sections rather than SML’s module functors.  I can assure you, this proposal has nothing to do with Haskell and everything to do with trying to approach scoping and imports with their mindset.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 10:18 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for writing these up, I found them clear and easy to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I don’t know the precise inspirations, both of these drafts seem more or less in line with the sorts of modules and importing that’s found in Haskell. I’d much prefer these facilities not be added to Swift. I would much rather see Swift develop in the direction of ML and add something like first-class modules and (module) functors. After writing a lot of both Haskell and ML family languages, I can say from experience that the Haskell-style approach is broadly inferior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have no idea if first-class modules are on the Core Team’s collective mind, but it’s what I’d advocate for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Colin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 20, 2016, at 2:52 PM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to thank the members of the community that have guided the revisions of this proposal.  We have decided to heed the advice of the community and break down our original proposal on modules and qualified imports into source-breaking (qualified imports) and additive (modules) proposals.  As qualified imports is the change most suited to Swift 3, we are pushing that proposal now as our final draft.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It can be had inline with this email, on Github, or as a gist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified Imports Revisited<br>&gt;&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt; Authors: Robert Widmann, TJ Usiyan<br>&gt;&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose a complete overhaul of the qualified imports syntax and semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import class Foundation.Date<br>&gt;&gt;&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is. In addition, though this import specifies exactly one class be imported from Foundation, the actual semantics mean Swift will recursively open all of Foundation&#39;s submodules so you can see, and use, every other identifier anyway - and they are not filtered from code completion. Qualified imports deserve to be first-class in Swift, and that is what we intend to make them with this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Qualified import syntax will be revised to the following<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import-decl -&gt; import &lt;import-path&gt; &lt;(opt) import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-path -&gt; &lt;identifier&gt;<br>&gt;&gt;&gt;&gt;             -&gt; &lt;identifier&gt;.&lt;identifier&gt;<br>&gt;&gt;&gt;&gt; import-directive-list -&gt; &lt;import-directive&gt;<br>&gt;&gt;&gt;&gt;                       -&gt; &lt;import-directive&gt; &lt;import-directive-list&gt;<br>&gt;&gt;&gt;&gt; import-directive -&gt; using (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt;                  -&gt; hiding (&lt;identifier&gt;, ...)<br>&gt;&gt;&gt;&gt; This introduces the concept of an import directive. An import directive is a file-local modification of an imported identifier. A directive can be one of 2 operations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt;&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt; // Previously, this was<br>&gt;&gt;&gt;&gt; // import class Foundation.Date<br>&gt;&gt;&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt;&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt;&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt;&gt;&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt;&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt;&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Imports `DateFormatter` but the declaration of `Date` is hidden.<br>&gt;&gt;&gt;&gt; import Foundation using (DateFormatter)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var d = DateFormatter().date(from: &quot;...&quot;) // Valid<br>&gt;&gt;&gt;&gt; var dt : Date = DateFormatter().date(from: &quot;...&quot;) // Invalid: Cannot use name of hidden type.<br>&gt;&gt;&gt;&gt; d.addTimeInterval(5.0) // Invalid: Cannot use members of hidden type.<br>&gt;&gt;&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt;&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt;&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt;&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt;&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt;&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt;&gt;&gt; import Swift using () using (Int)<br>&gt;&gt;&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt;&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt;&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt;&gt;&gt; import Swift using (String) hiding (String)<br>&gt;&gt;&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A previous iteration of this proposal introduced an operation to allow the renaming of identifiers, especially members. The original intent was to allow file-local modifications of APIs consumers felt needed to conform to their specific coding style. On review, we felt the feature was not as significant as to warrant inclusion and was ripe for abuse in large projects.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/a7e65a0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>Back to the pre-proposal itself,<br></p><p>I support taking it forward and it being accepted in some form. However, I remain unconvinced that we&#39;d ever want `hiding` imports in Swift.<br></p><p>Here are a few specific comments on the text (8 in total):<br>&gt; Motivation<br>&gt; <br>&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt; <br>&gt; import class Foundation.Date<br>&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is.<br>&gt; <br>&gt; <br></p><p>1. Given this motivation, isn&#39;t it sufficient being able to import without knowing the exact kind of declaration? In other words, I agree we want `using` imports, but what motivates `hiding` imports really?<br></p><p>As it was pointed out by Félix, the use of `hiding` imports moves away the focus of what is imported into what is not imported, and while name conflict problems usually arise when importing another module on top of already working code, I think it&#39;s better to fix them at the import statement which brings in the winning name declaration, i.e. the `using` import.<br></p><p><br>&gt;  &lt;https://gist.github.com/CodaFi/42e5e5e94d857547abc381d9a9d0afd6#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt; <br>&gt; <br></p><p>2. Is there a typo above? The proposal does not mention import qualifiers anywhere else. I guess those are part of what got postponed into later proposals.<br></p><p><br>&gt; Detailed design<br>&gt; <br>&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt; <br>&gt; // The only visible parts of Foundation in this file are <br>&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt; //<br>&gt; // Previously, this was<br>&gt; // import class Foundation.Date<br>&gt; // import class Foundation.DateFormatter<br>&gt; // import class Foundation.DateComponents<br>&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt; <br>3. I support the idea of `using` imports. That&#39;s something we do need, and its introduction is sufficient to cover the existing use cases of the old selective import syntax about to be deprecated here.<br></p><p><br></p><p>&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt; <br>&gt; // Imports all of Foundation except `Date`<br>&gt; import Foundation hiding (Date)<br>&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt; <br>&gt; <br>4. Hmm, the above design detail is easily missed when reading the proposal. So what you&#39;re proposing is that the hiding of Date essentially turns Date into a type that the code will know almost nothing about, except it&#39;s something we can pass to other types&#39; methods that expect a Date, am I right?<br></p><p>What&#39;s the benefit in that? Do you anticipate it will make importing lighter somehow, possibly improving compilation or library loading speed? You mentioned something along those lines in the Motivation, but I&#39;m not sure if I got it right here.<br></p><p><br></p><p>&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt; <br>&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt; import Swift using (String, Int, Double) <br>&gt;              hiding (String.UTF8View)<br>&gt; Directive chaining occurs left-to-right:<br>&gt; <br>&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt; // because 1) Int is available 2) String is not, error.<br>&gt; import Swift using (Int) hiding (String)<br>&gt; // Valid.  This will be merged as `using (Int)`<br>&gt; import Swift using () using (Int)<br>&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt; import Swift using (String) hiding (String)<br>&gt; <br>5. These chaining rules do fit on the back of a napkin, but I&#39;m not sure if we need them at all. I&#39;m not convinced we need `hiding` imports, and without hiding imports, we need no rules for the order of imports.<br></p><p><br></p><p>&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt; <br>&gt; <br>6. +1 on imports being file-local, that&#39;s essentially what we have today.<br></p><p>What I will keep suggesting is that `using` imports actually take up the name in the file-local scope such that nothing else in the same file&#39;s scope — be it another `import ... using (...)`, a local type declaration, function, or value — can declare the same name with a different meaning. That way, a plain<br></p><p>    import Foo<br></p><p>can import everything from Foo, while another<br></p><p>    import Foo using (Bar)<br></p><p>can be used to explicitly choose the Bar the code is about to use.<br></p><p><br>7. (Off-topic to this proposal.) Given that you briefly expressed the interest in turning imports `public` or `internal` — some of which would indeed be useful in a better module system —, I think it&#39;s curious in that design that the default visibility level of imports would likely be `fileprivate`, which is different from the rest of Swift. That said, I think it&#39;s absolutely right for imports to remain file-local by default, because explicit tends to be better than implicit.<br></p><p><br>&gt; Impact on existing code<br>&gt; <br>&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt; <br>&gt; <br>8. +1 on deprecating the old selective import syntax.<br></p><p>Thank you for driving this forward!<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/344a3516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d972db2b6ee8b77746ce7122663eb4f8?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;rwidmann at apple.com&gt;<p>July 21, 2016 at 02:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/07/21 1:43、Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; のメッセージ:<br></p><p>&gt; Back to the pre-proposal itself,<br>&gt; <br>&gt; I support taking it forward and it being accepted in some form. However, I remain unconvinced that we&#39;d ever want `hiding` imports in Swift.<br>&gt; <br>&gt; Here are a few specific comments on the text (8 in total):<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The existing syntax for qualified imports from modules is needlessly explicit, does not compose, and has a default semantics that dilutes the intended meaning of the very operation itself. Today, a qualified import looks something like this<br>&gt;&gt; <br>&gt;&gt; import class Foundation.Date<br>&gt;&gt; This means that clients of Foundation that wish to see only Date must know the exact kind of declaration that identifier is.<br>&gt;&gt; <br>&gt; <br>&gt; 1. Given this motivation, isn&#39;t it sufficient being able to import without knowing the exact kind of declaration? In other words, I agree we want `using` imports, but what motivates `hiding` imports really?<br>&gt; <br>&gt; As it was pointed out by Félix, the use of `hiding` imports moves away the focus of what is imported into what is not imported, and while name conflict problems usually arise when importing another module on top of already working code, I think it&#39;s better to fix them at the import statement which brings in the winning name declaration, i.e. the `using` import.<br>&gt; <br>&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The grammar and semantics of qualified imports will change completely with the addition of import qualifiers and import directives. We also introduce two new contextual keywords: using and hiding, to facilitate fine-grained usage of module contents.<br>&gt;&gt; <br>&gt; <br>&gt; 2. Is there a typo above? The proposal does not mention import qualifiers anywhere else. I guess those are part of what got postponed into later proposals.<br>&gt; <br></p><p>It is.<br>&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; 1) using: The using directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be exposed to this file. <br>&gt;&gt; <br>&gt;&gt; // The only visible parts of Foundation in this file are <br>&gt;&gt; // Foundation.Date, Foundation.DateFormatter, and Foundation.DateComponents<br>&gt;&gt; //<br>&gt;&gt; // Previously, this was<br>&gt;&gt; // import class Foundation.Date<br>&gt;&gt; // import class Foundation.DateFormatter<br>&gt;&gt; // import class Foundation.DateComponents<br>&gt;&gt; import Foundation using (Date, DateFormatter, DateComponents)<br>&gt; 3. I support the idea of `using` imports. That&#39;s something we do need, and its introduction is sufficient to cover the existing use cases of the old selective import syntax about to be deprecated here.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; 2) hiding: The hiding directive is followed by a list of identifiers for non-member nominal declarations within the imported module that should be hidden from this file.<br>&gt;&gt; <br>&gt;&gt; // Imports all of Foundation except `Date`<br>&gt;&gt; import Foundation hiding (Date)<br>&gt;&gt; As today, all hidden identifiers do not hide the type, they merely hide that type’s members and its declaration. For example, this means values of hidden types are still allowed. Unlike the existing implementation, using their members is forbidden.<br>&gt;&gt; <br>&gt; 4. Hmm, the above design detail is easily missed when reading the proposal. So what you&#39;re proposing is that the hiding of Date essentially turns Date into a type that the code will know almost nothing about, except it&#39;s something we can pass to other types&#39; methods that expect a Date, am I right?<br>&gt; <br>&gt; What&#39;s the benefit in that? Do you anticipate it will make importing lighter somehow, possibly improving compilation or library loading speed? You mentioned something along those lines in the Motivation, but I&#39;m not sure if I got it right here.<br></p><p>It is so that use of an API in a framework like Foundation does not necessitate polluting your Swift files with a million using imports - thus defeating the purpose of this proposal.  DateFormatter alone needs to know about Date, String, TimeInterval, Calendar, Locale, and TimeZone.  Each of those needs to know about additional components.  To require an import decl to use these types explicitly would be madness.  You&#39;d just wind up importing Foundation anyway.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Import directives chain to one another and can be used to create a fine-grained module import:<br>&gt;&gt; <br>&gt;&gt; // This imports Swift.Int, Swift.Double, and Swift.String but hides Swift.String.UTF8View<br>&gt;&gt; import Swift using (String, Int, Double) <br>&gt;&gt;              hiding (String.UTF8View)<br>&gt;&gt; Directive chaining occurs left-to-right:<br>&gt;&gt; <br>&gt;&gt; // This says to 1) Use Int 2) Hide String 3) rename Double to Triple.  It is invalid<br>&gt;&gt; // because 1) Int is available 2) String is not, error.<br>&gt;&gt; import Swift using (Int) hiding (String)<br>&gt;&gt; // Valid.  This will be merged as `using (Int)`<br>&gt;&gt; import Swift using () using (Int)<br>&gt;&gt; // Valid.  This will be merged as `hiding (String, Double)`<br>&gt;&gt; import Swift hiding (String) hiding (Double) hiding ()<br>&gt;&gt; // Valid (if redundant). This will be merged as `using ()`<br>&gt;&gt; import Swift using (String) hiding (String)<br>&gt; 5. These chaining rules do fit on the back of a napkin, but I&#39;m not sure if we need them at all. I&#39;m not convinced we need `hiding` imports, and without hiding imports, we need no rules for the order of imports.<br>&gt; <br></p><p>How else are we to allow you to import a using type but not any of its member types?  How could we support removing APIs related to NSCell in AppKit apps? How about NSStream everywhere else? How else can we allow, in the future, the ability to import NSObject but none of its KVO-related members?  A hiding import is an invariant: It says a particular API should never be considered for use in this file.  The very act of &#39;using&#39; an identifier means you are hiding all others.  The very act of &#39;hiding&#39; an identifier means you are using all others.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Because import directives are file-local, they will never be exported along with the module that declares them.<br>&gt;&gt; <br>&gt; 6. +1 on imports being file-local, that&#39;s essentially what we have today.<br>&gt; <br>&gt; What I will keep suggesting is that `using` imports actually take up the name in the file-local scope such that nothing else in the same file&#39;s scope — be it another `import ... using (...)`, a local type declaration, function, or value — can declare the same name with a different meaning. That way, a plain<br>&gt; <br>&gt;     import Foo<br>&gt; <br>&gt; can import everything from Foo, while another<br>&gt; <br>&gt;     import Foo using (Bar)<br>&gt; <br>&gt; can be used to explicitly choose the Bar the code is about to use.<br></p><p>That was the plan.  You will receive an &quot;invalid redeclaration&quot; error as always.<br> <br>&gt; <br>&gt; <br>&gt; 7. (Off-topic to this proposal.) Given that you briefly expressed the interest in turning imports `public` or `internal` — some of which would indeed be useful in a better module system —, I think it&#39;s curious in that design that the default visibility level of imports would likely be `fileprivate`, which is different from the rest of Swift. That said, I think it&#39;s absolutely right for imports to remain file-local by default, because explicit tends to be better than implicit.<br>&gt; <br>&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Existing code that is using qualified module import syntax (import {func|class|typealias|class|struct|enum|protocol} &lt;qualified-name&gt;) will be deprecated and should be removed or migrated. <br>&gt;&gt; <br>&gt; 8. +1 on deprecating the old selective import syntax.<br>&gt; <br>&gt; Thank you for driving this forward!<br>&gt; <br>&gt; — Pyry<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/d762ffc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 21, 2016 at 01:00:00pm</p></header><div class="content"><p>I think we&#39;re getting somewhere.<br></p><p>&gt; On 21 Jul 2016, at 12:01, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; (An excerpt about the hiding directive &lt;https://github.com/CodaFi/swift-evolution/blob/ab091043daa62158bd3337a2a2a467be3e16ff18/proposals/XXXX-qualified-imports.md#detailed-design&gt;)<br>&gt;&gt; <br>&gt;&gt; 4. Hmm, the above design detail is easily missed when reading the proposal. So what you&#39;re proposing is that the hiding of Date essentially turns Date into a type that the code will know almost nothing about, except it&#39;s something we can pass to other types&#39; methods that expect a Date, am I right?<br>&gt;&gt; <br>&gt;&gt; What&#39;s the benefit in that? Do you anticipate it will make importing lighter somehow, possibly improving compilation or library loading speed? You mentioned something along those lines in the Motivation, but I&#39;m not sure if I got it right here.<br>&gt; <br>&gt; It is so that use of an API in a framework like Foundation does not necessitate polluting your Swift files with a million using imports - thus defeating the purpose of this proposal.<br></p><p>You explained further below what else `hiding` imports can be used for. But my comment was motivated by your example of `import Foundation hiding (Date)`. <br></p><p>I fail to see how the lack of `hiding` imports would imply Swift files with a lot using imports. In my counting, they amount to at most one extra using import. (And I propose ~10 lines below what would get that to zero.)<br></p><p>The simple reason I could see someone write `import Foundation hiding (Date)` is because another imported module &quot;Julian&quot; she uses happens to export another Date type which she wants to use instead. And if we could just as well solve that use case by making it so that<br></p><p>    import Foundation<br>    import Julian, Julian using (Date)<br>    assert(Date.self == Julian.Date.self)<br></p><p>brings in both modules but makes Julian.Date the one that Date is shorthand of.<br></p><p>Besides, Joe and friends offered the use of `*` to mean &quot;and everything else&quot;, which is problematic because `*` also happens to be an operator function name. But we could make it so that the underscore imports everything else (without explicit qualification), making the above example exactly equivalent to:<br></p><p>    import Foundation using (_)   // same as `import Foundation`<br>    import Julian using (_, Date) // bring in Date explicitly and all else implicitly<br>    assert(Date.self == Julian.Date.self)<br></p><p><br>&gt; DateFormatter alone needs to know about Date, String, TimeInterval, Calendar, Locale, and TimeZone.  Each of those needs to know about additional components.  To require an import decl to use these types explicitly would be madness.  You&#39;d just wind up importing Foundation anyway.<br></p><p>&quot;You&#39;d just wind up importing Foundation anyway&quot; is an argument that doesn&#39;t seem imply from the given Motivation section AFAICT.<br></p><p>I can see three kinds of problems here (objective or subjective), caused by importing the whole Foundation:<br>Identifier name conflicts, which we could solve with just the `import Module using (name, Name, _)` syntax, essentially indicating which Module should be preferred.<br></p><p>Identifier names shadowing module names, where e.g. a `private enum Foundation {}` disables the fully qualified access to the Foundation module&#39;s API). This remains an unsolved problem, but the introduction of qualified module imports `import Foundation as Foundation` or `import Foundation as F` (or, heh, `import Foundation as is`) would be one way of going about it.<br></p><p>Auto-completer &quot;hygiene&quot;, or being explicit which part of a large imported API is not considered appropriate to use by the author.<br>Point 3 is the only problem that `hiding` imports could be uniquely used for, especially if they can be narrowed down to members of imported types and extensions (e.g. Swift.String.UTF8View, as given in the proposal). But is that worth having?<br></p><p><br>&gt;&gt; 5. These chaining rules do fit on the back of a napkin, but I&#39;m not sure if we need them at all. I&#39;m not convinced we need `hiding` imports, and without hiding imports, we need no rules for the order of imports.<br>&gt; <br>&gt; How else are we to allow you to import a using type but not any of its member types?<br></p><p>I don&#39;t know. I&#39;m asking &quot;why?&quot; not &quot;how?&quot;<br></p><p><br>&gt; How could we support removing APIs related to NSCell in AppKit apps? How about NSStream everywhere else? How else can we allow, in the future, the ability to import NSObject but none of its KVO-related members?<br></p><p>I&#39;m saying you should explain this in the Motivation. Or consider moving the `hiding` import syntax into a further proposal.<br></p><p><br>&gt; A hiding import is an invariant: It says a particular API should never be considered for use in this file.  The very act of &#39;using&#39; an identifier means you are hiding all others.  The very act of &#39;hiding&#39; an identifier means you are using all others.<br></p><p>That is very logical. But it would be better if there was a real-world example use case given where the use of `hiding` was a clear win over a combination of `import` and `import ... using (...)`. The current one about Date isn&#39;t very convincing because instead of hiding one, it could be solved by highlighting (using) the other.<br></p><p><br>&gt;&gt; What I will keep suggesting is that `using` imports actually take up the name in the file-local scope such that nothing else in the same file&#39;s scope — be it another `import ... using (...)`, a local type declaration, function, or value — can declare the same name with a different meaning. That way, a plain<br>&gt;&gt; <br>&gt;&gt;     import Foo<br>&gt;&gt; <br>&gt;&gt; can import everything from Foo, while another<br>&gt;&gt; <br>&gt;&gt;     import Foo using (Bar)<br>&gt;&gt; <br>&gt;&gt; can be used to explicitly choose the Bar the code is about to use.<br>&gt; <br>&gt; That was the plan.  You will receive an &quot;invalid redeclaration&quot; error as always. <br></p><p>👍!<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/4142efc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal][Discussion] Qualified Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>July 21, 2016 at 08:00:00am</p></header><div class="content"><p>~Robert Widmann<br></p><p>2016/07/21 3:19、Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I think we&#39;re getting somewhere.<br>&gt; <br>&gt;&gt;&gt; On 21 Jul 2016, at 12:01, Robert Widmann &lt;rwidmann at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; (An excerpt about the hiding directive)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Hmm, the above design detail is easily missed when reading the proposal. So what you&#39;re proposing is that the hiding of Date essentially turns Date into a type that the code will know almost nothing about, except it&#39;s something we can pass to other types&#39; methods that expect a Date, am I right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s the benefit in that? Do you anticipate it will make importing lighter somehow, possibly improving compilation or library loading speed? You mentioned something along those lines in the Motivation, but I&#39;m not sure if I got it right here.<br>&gt;&gt; <br>&gt;&gt; It is so that use of an API in a framework like Foundation does not necessitate polluting your Swift files with a million using imports - thus defeating the purpose of this proposal.<br>&gt; <br>&gt; You explained further below what else `hiding` imports can be used for. But my comment was motivated by your example of `import Foundation hiding (Date)`. <br>&gt; <br>&gt; I fail to see how the lack of `hiding` imports would imply Swift files with a lot using imports. In my counting, they amount to at most one extra using import. (And I propose ~10 lines below what would get that to zero.)<br>&gt; <br>&gt; The simple reason I could see someone write `import Foundation hiding (Date)` is because another imported module &quot;Julian&quot; she uses happens to export another Date type which she wants to use instead. And if we could just as well solve that use case by making it so that<br>&gt; <br>&gt;     import Foundation<br>&gt;     import Julian, Julian using (Date)<br>&gt;     assert(Date.self == Julian.Date.self)<br>&gt; <br>&gt; brings in both modules but makes Julian.Date the one that Date is shorthand of.<br>&gt; <br>&gt; Besides, Joe and friends offered the use of `*` to mean &quot;and everything else&quot;, which is problematic because `*` also happens to be an operator function name. But we could make it so that the underscore imports everything else (without explicit qualification), making the above example exactly equivalent to:<br>&gt; <br>&gt;     import Foundation using (_)   // same as `import Foundation`<br>&gt;     import Julian using (_, Date) // bring in Date explicitly and all else implicitly<br>&gt;     assert(Date.self == Julian.Date.self)<br></p><p>Funny, others have been suggesting _ be used as a special namespace to hide identifiers in.  It implies you don&#39;t care about identifiers, not that you want all of them.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; DateFormatter alone needs to know about Date, String, TimeInterval, Calendar, Locale, and TimeZone.  Each of those needs to know about additional components.  To require an import decl to use these types explicitly would be madness.  You&#39;d just wind up importing Foundation anyway.<br>&gt; <br>&gt; &quot;You&#39;d just wind up importing Foundation anyway&quot; is an argument that doesn&#39;t seem imply from the given Motivation section AFAICT.<br></p><p>I should be more clear: If we requires you to qualified import types without these allowances then you would have to recursively import types out of Foundation until you wind up importing the whole thing anyway.  To be able to use DateFormatter you shouldn&#39;t have to tell Swift you also want to use Date, String, TimeInterval, etc.  We know you want to, we can see all of these identifiers.  When the time comes for you to pick a member on Date, then you want a using or hiding import to let us know you want to see it.<br></p><p>&gt; <br>&gt; I can see three kinds of problems here (objective or subjective), caused by importing the whole Foundation:<br>&gt; Identifier name conflicts, which we could solve with just the `import Module using (name, Name, _)` syntax, essentially indicating which Module should be preferred.<br>The grammar makes no allowances for types to be imported there, only qualified module name.  Not sure what you mean.<br>&gt; <br>&gt; Identifier names shadowing module names, where e.g. a `private enum Foundation {}` disables the fully qualified access to the Foundation module&#39;s API). This remains an unsolved problem, but the introduction of qualified module imports `import Foundation as Foundation` or `import Foundation as F` (or, heh, `import Foundation as is`) would be one way of going about it.<br></p><p>And additive and can be introduced in a future proposal as a new directive on top of this system.  We wanted this, the community had reservations, we backed off.<br>&gt; <br>&gt; Auto-completer &quot;hygiene&quot;, or being explicit which part of a large imported API is not considered appropriate to use by the author<br>&gt; Point 3 is the only problem that `hiding` imports could be uniquely used for, especially if they can be narrowed down to members of imported types and extensions (e.g. Swift.String.UTF8View, as given in the proposal). But is that worth having?<br></p><p>We need to be able to disambiguate more than just top-level names, for one.  Hiding can do that.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; 5. These chaining rules do fit on the back of a napkin, but I&#39;m not sure if we need them at all. I&#39;m not convinced we need `hiding` imports, and without hiding imports, we need no rules for the order of imports.<br>&gt;&gt; <br>&gt;&gt; How else are we to allow you to import a using type but not any of its member types?<br>&gt; <br>&gt; I don&#39;t know. I&#39;m asking &quot;why?&quot; not &quot;how?&quot;<br></p><p>That is why, just rhetorical.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; How could we support removing APIs related to NSCell in AppKit apps? How about NSStream everywhere else? How else can we allow, in the future, the ability to import NSObject but none of its KVO-related members?<br>&gt; <br>&gt; I&#39;m saying you should explain this in the Motivation. Or consider moving the `hiding` import syntax into a further proposal.<br></p><p>Fair.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; A hiding import is an invariant: It says a particular API should never be considered for use in this file.  The very act of &#39;using&#39; an identifier means you are hiding all others.  The very act of &#39;hiding&#39; an identifier means you are using all others.<br>&gt; <br>&gt; That is very logical. But it would be better if there was a real-world example use case given where the use of `hiding` was a clear win over a combination of `import` and `import ... using (...)`. The current one about Date isn&#39;t very convincing because instead of hiding one, it could be solved by highlighting (using) the other.<br></p><p>I have given one.  Show me how to express the &quot;give me String but not String.UTF8View&quot; example without hiding?<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; What I will keep suggesting is that `using` imports actually take up the name in the file-local scope such that nothing else in the same file&#39;s scope — be it another `import ... using (...)`, a local type declaration, function, or value — can declare the same name with a different meaning. That way, a plain<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; can import everything from Foo, while another<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import Foo using (Bar)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; can be used to explicitly choose the Bar the code is about to use.<br>&gt;&gt; <br>&gt;&gt; That was the plan.  You will receive an &quot;invalid redeclaration&quot; error as always. <br>&gt; <br>&gt; 👍!<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/4892b97d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
