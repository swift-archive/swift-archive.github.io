<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089:	Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 25, 2016 at 02:00:00pm</p></header><div class="content"><p>This is unfortunate, because then the meaning of &quot;existential&quot; and &quot;non-existential&quot; in Swift are just the opposite of their respective meaning in standard terminology :-(<br></p><p><br></p><p>-Thorsten<br></p><p><br></p><p><br>Am 25. Mai 2016 um 14:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p><br>AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br></p><p>My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br></p><p>If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br></p><p>--<br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/be84fc0b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 7:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; This is unfortunate, because then the meaning of &quot;existential&quot; and &quot;non-existential&quot; in Swift are just the opposite of their respective meaning in standard terminology :-(<br></p><p>I don&#39;t know what you mean by this.  The standard terminology is that an existential type is one that&#39;s directly existentially-quantified, e.g. ∃ t . t, which is essentially what a Swift protocol type is:<br>  P ::= ∃ t : P . t<br>  P.Type ::= ∃ t : P . t.Type<br>etc.  Language operations then implicitly form (erasure) and break down (opening) those qualifiers in basically the same way that they implicitly break down the universal quantifiers on generic functions.<br></p><p>If you&#39;re thinking about Haskell, Haskell&#39;s existential features are carefully tied to constructors and pattern-matching in part because erasure is a kind of implicit conversion, which would not fit cleanly into Haskell&#39;s type system.  (Universal application also requires an implicit representation change, but that doesn&#39;t need to be reflected in H-M systems for technical reasons unless you&#39;re trying to support higher-rank polymorphism; I&#39;m not up on the type-checking literature there.)<br></p><p>John.<br></p><p><br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; Am 25. Mai 2016 um 14:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt;), i.e. have not been assigned concrete values.<br>&gt;&gt; <br>&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt; <br>&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/b335a26e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 29, 2016 at 03:00:00pm</p></header><div class="content"><p>An, now I see what you mean. You are right, P ::= ∃ t : P . t is a constrained existential type defining a subtype relationship.<br>Thanks for enlightening me!<br></p><p>I haven’t perceived a protocol as an existential up to now, probably because my understanding has come from Haskell where subtyping does not exists and where therefore a hidden unbound type parameter plays a central role (see definitions below) which has made me believe that an associated type is necessary. But for simple protocols this role is indeed taken by the conforming type. The difference is that this is equivalent to subtyping whereas associated types (as another form of hidden unbound type parameters) are not, resulting in two kinds of protocols.<br>Is there another terminology to distinguish between those two kinds?<br></p><p>-Thorsten<br></p><p><br>&quot;Existential types, or &#39;existentials&#39; for short, are a way of &#39;squashing&#39; a group of types into one, single type. […] <br>data T = forall a. MkT a“ <br>(https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types)<br></p><p>&quot;Existential quantification hides a type variable within a data constructor.“<br>(https://prime.haskell.org/wiki/ExistentialQuantification)<br></p><p>&quot;For example, the type &quot;T = ∃X { a: X; f: (X → int); }&quot; describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. […] Given a value &quot;t&quot; of type &quot;T&quot;, we know that &quot;t.f(t.a)&quot; is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation while clients that use only values of the interface type—the existential type—are isolated from these choices.“<br>(https://en.wikipedia.org/wiki/Type_system#Existential_types)<br></p><p><br></p><p>&gt; Am 27.05.2016 um 19:36 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt; <br>&gt;&gt; On May 25, 2016, at 7:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; This is unfortunate, because then the meaning of &quot;existential&quot; and &quot;non-existential&quot; in Swift are just the opposite of their respective meaning in standard terminology :-(<br>&gt; <br>&gt; I don&#39;t know what you mean by this.  The standard terminology is that an existential type is one that&#39;s directly existentially-quantified, e.g. ∃ t . t, which is essentially what a Swift protocol type is:<br>&gt;   P ::= ∃ t : P . t<br>&gt;   P.Type ::= ∃ t : P . t.Type<br>&gt; etc.  Language operations then implicitly form (erasure) and break down (opening) those qualifiers in basically the same way that they implicitly break down the universal quantifiers on generic functions.<br>&gt; <br>&gt; If you&#39;re thinking about Haskell, Haskell&#39;s existential features are carefully tied to constructors and pattern-matching in part because erasure is a kind of implicit conversion, which would not fit cleanly into Haskell&#39;s type system.  (Universal application also requires an implicit representation change, but that doesn&#39;t need to be reflected in H-M systems for technical reasons unless you&#39;re trying to support higher-rank polymorphism; I&#39;m not up on the type-checking literature there.)<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 25. Mai 2016 um 14:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt;), i.e. have not been assigned concrete values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/71961ab2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 29, 2016, at 6:38 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; An, now I see what you mean. You are right, P ::= ∃ t : P . t is a constrained existential type defining a subtype relationship.<br>&gt; Thanks for enlightening me!<br>&gt; <br>&gt; I haven’t perceived a protocol as an existential up to now, probably because my understanding has come from Haskell where subtyping does not exists and where therefore a hidden unbound type parameter plays a central role (see definitions below) which has made me believe that an associated type is necessary. But for simple protocols this role is indeed taken by the conforming type. The difference is that this is equivalent to subtyping whereas associated types (as another form of hidden unbound type parameters) are not, resulting in two kinds of protocols.<br>&gt; Is there another terminology to distinguish between those two kinds?<br></p><p>It&#39;s not a standard restriction or really even a necessary one.  It&#39;s an artifact of earlier implementations of both the type-checker and the runtime representation of protocol conformances.<br></p><p>RE: the type-checker, it used to be the case that calls on existentials were awkward special cases: the type-checker didn&#39;t actually &quot;open&quot; the existential as a rigid type variable, it just magically ignored self and patched things together later.  That&#39;s a type-checking strategy that&#39;s extremely prone to soundness bugs, so a harsh restriction is required.  Fortunately, it&#39;s also a type-checking strategy we&#39;ve abandoned, although there&#39;s still work to be done to build associated types correctly for opened existentials.<br></p><p>RE: the runtime representation, it used to be the case that you couldn&#39;t recover associated type information at runtime from a protocol conformance and so it had to be passed separately; that could have been supported in the existential representation as well, but we knew we wanted to change that about protocol conformances, and we didn&#39;t want to introduce a great deal of complexity for an unnecessary intermediate position.<br></p><p>So I wouldn&#39;t sweat trying to formally describe the current situation, because it&#39;s a &quot;temporary&quot; implementation limitation.<br></p><p>John.<br></p><p><br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; &quot;Existential types, or &#39;existentials&#39; for short, are a way of &#39;squashing&#39; a group of types into one, single type. […] <br>&gt; data T = forall a. MkT a“ <br>&gt; (https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types &lt;https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types&gt;)<br>&gt; <br>&gt; &quot;Existential quantification hides a type variable within a data constructor.“<br>&gt; (https://prime.haskell.org/wiki/ExistentialQuantification &lt;https://prime.haskell.org/wiki/ExistentialQuantification&gt;)<br>&gt; <br>&gt; &quot;For example, the type &quot;T = ∃X { a: X; f: (X → int); }&quot; describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. […] Given a value &quot;t&quot; of type &quot;T&quot;, we know that &quot;t.f(t.a)&quot; is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation while clients that use only values of the interface type—the existential type—are isolated from these choices.“<br>&gt; (https://en.wikipedia.org/wiki/Type_system#Existential_types &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt;)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 27.05.2016 um 19:36 schrieb John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 7:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; This is unfortunate, because then the meaning of &quot;existential&quot; and &quot;non-existential&quot; in Swift are just the opposite of their respective meaning in standard terminology :-(<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean by this.  The standard terminology is that an existential type is one that&#39;s directly existentially-quantified, e.g. ∃ t . t, which is essentially what a Swift protocol type is:<br>&gt;&gt;   P ::= ∃ t : P . t<br>&gt;&gt;   P.Type ::= ∃ t : P . t.Type<br>&gt;&gt; etc.  Language operations then implicitly form (erasure) and break down (opening) those qualifiers in basically the same way that they implicitly break down the universal quantifiers on generic functions.<br>&gt;&gt; <br>&gt;&gt; If you&#39;re thinking about Haskell, Haskell&#39;s existential features are carefully tied to constructors and pattern-matching in part because erasure is a kind of implicit conversion, which would not fit cleanly into Haskell&#39;s type system.  (Universal application also requires an implicit representation change, but that doesn&#39;t need to be reflected in H-M systems for technical reasons unless you&#39;re trying to support higher-rank polymorphism; I&#39;m not up on the type-checking literature there.)<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 25. Mai 2016 um 14:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types &lt;https://en.wikipedia.org/wiki/Type_system#Existential_types&gt;), i.e. have not been assigned concrete values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/19c78631/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>Great! Thanks for the additional details!<br></p><p>-Thorsten <br></p><p>&gt; Am 31.05.2016 um 19:31 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt; <br>&gt;&gt; On May 29, 2016, at 6:38 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; An, now I see what you mean. You are right, P ::= ∃ t : P . t is a constrained existential type defining a subtype relationship.<br>&gt;&gt; Thanks for enlightening me!<br>&gt;&gt; <br>&gt;&gt; I haven’t perceived a protocol as an existential up to now, probably because my understanding has come from Haskell where subtyping does not exists and where therefore a hidden unbound type parameter plays a central role (see definitions below) which has made me believe that an associated type is necessary. But for simple protocols this role is indeed taken by the conforming type. The difference is that this is equivalent to subtyping whereas associated types (as another form of hidden unbound type parameters) are not, resulting in two kinds of protocols.<br>&gt;&gt; Is there another terminology to distinguish between those two kinds?<br>&gt; <br>&gt; It&#39;s not a standard restriction or really even a necessary one.  It&#39;s an artifact of earlier implementations of both the type-checker and the runtime representation of protocol conformances.<br>&gt; <br>&gt; RE: the type-checker, it used to be the case that calls on existentials were awkward special cases: the type-checker didn&#39;t actually &quot;open&quot; the existential as a rigid type variable, it just magically ignored self and patched things together later.  That&#39;s a type-checking strategy that&#39;s extremely prone to soundness bugs, so a harsh restriction is required.  Fortunately, it&#39;s also a type-checking strategy we&#39;ve abandoned, although there&#39;s still work to be done to build associated types correctly for opened existentials.<br>&gt; <br>&gt; RE: the runtime representation, it used to be the case that you couldn&#39;t recover associated type information at runtime from a protocol conformance and so it had to be passed separately; that could have been supported in the existential representation as well, but we knew we wanted to change that about protocol conformances, and we didn&#39;t want to introduce a great deal of complexity for an unnecessary intermediate position.<br>&gt; <br>&gt; So I wouldn&#39;t sweat trying to formally describe the current situation, because it&#39;s a &quot;temporary&quot; implementation limitation.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &quot;Existential types, or &#39;existentials&#39; for short, are a way of &#39;squashing&#39; a group of types into one, single type. […] <br>&gt;&gt; data T = forall a. MkT a“ <br>&gt;&gt; (https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types)<br>&gt;&gt; <br>&gt;&gt; &quot;Existential quantification hides a type variable within a data constructor.“<br>&gt;&gt; (https://prime.haskell.org/wiki/ExistentialQuantification)<br>&gt;&gt; <br>&gt;&gt; &quot;For example, the type &quot;T = ∃X { a: X; f: (X → int); }&quot; describes a module interface that has a data member named a of type X and a function named f that takes a parameter of the same type X and returns an integer. […] Given a value &quot;t&quot; of type &quot;T&quot;, we know that &quot;t.f(t.a)&quot; is well-typed, regardless of what the abstract type X is. This gives flexibility for choosing types suited to a particular implementation while clients that use only values of the interface type—the existential type—are isolated from these choices.“<br>&gt;&gt; (https://en.wikipedia.org/wiki/Type_system#Existential_types)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 27.05.2016 um 19:36 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 25, 2016, at 7:07 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; This is unfortunate, because then the meaning of &quot;existential&quot; and &quot;non-existential&quot; in Swift are just the opposite of their respective meaning in standard terminology :-(<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what you mean by this.  The standard terminology is that an existential type is one that&#39;s directly existentially-quantified, e.g. ∃ t . t, which is essentially what a Swift protocol type is:<br>&gt;&gt;&gt;   P ::= ∃ t : P . t<br>&gt;&gt;&gt;   P.Type ::= ∃ t : P . t.Type<br>&gt;&gt;&gt; etc.  Language operations then implicitly form (erasure) and break down (opening) those qualifiers in basically the same way that they implicitly break down the universal quantifiers on generic functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;re thinking about Haskell, Haskell&#39;s existential features are carefully tied to constructors and pattern-matching in part because erasure is a kind of implicit conversion, which would not fit cleanly into Haskell&#39;s type system.  (Universal application also requires an implicit representation change, but that doesn&#39;t need to be reflected in H-M systems for technical reasons unless you&#39;re trying to support higher-rank polymorphism; I&#39;m not up on the type-checking literature there.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25. Mai 2016 um 14:27 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; AFAIK an existential type is a type T with type parameters that are still abstract (see for example https://en.wikipedia.org/wiki/Type_system#Existential_types), i.e. have not been assigned concrete values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My understanding is that, in Swift, the instance used to store something whose concrete type is unknown (i.e. is still abstract), but which is known to conform to some protocol, is called an &quot;existential&quot;. Protocols with associated values cannot be packed into normal existentials because, even though we know that the concrete type conforms to some protocol, the associated types represent additional unknowns, and Swift cannot be sure how to translate uses of those unknown types into callable members. Hence, protocols with associated types are sometimes called &quot;non-existential&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If I am misusing the terminology in this area, please understand that that&#39;s what I mean when I use that word.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/1b60baec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
