<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 10:00:00am</p></header><div class="content"><p>A “mutating” keyword on a protocol method is only useful if<br>you can reason about the mutation in generic code.  <br></p><p>  protocol P {<br>    mutating func changeMe()<br>    func noChange() -&gt; Int<br>  }<br></p><p>In other words, given x of some type conforming to P, it should be<br>meaningful that this is an error:<br></p><p>  func f&lt;T: P&gt;(x: T) {<br>    immutable.changeMe() // can&#39;t mutate a &quot;let&quot; binding<br>  }<br></p><p>which means that you shouldn&#39;t be able to get around that meaning by<br>writing:<br></p><p>  func g&lt;T: P&gt;(x: T) {<br>    var mutable = x<br>    mutable.changeMe() // OK<br>  }<br></p><p>Also, you should be able to reason that both of the following print the same<br>thing twice, for types whose methods have no external side-effects:<br></p><p>  func gg&lt;T: P&gt;(x: T) {<br>    print(x)<br>    x.noChange()<br>    print(x)<br>  }<br></p><p>  func ggg&lt;T: P&gt;(x: T) {<br>    print(x)<br>    var y = x<br>    y.changeMe()<br>    print(x)<br>  }<br></p><p>When T is a class type, it can easily violate *all* of these<br>expectations.  In other words, classes naturally bypass the mutation<br>model.<br></p><p>If we are going to maintain source stability after Swift 3, it seems<br>that we either need to address this now, or decide that it won&#39;t be<br>addressed, because of the “viral const” problem.<br></p><p>One idea that Jordan and I have floated is that protocols with mutating<br>methods should be constrained to applying to non-class types.  That<br>would be a step in the right direction, but, that still leaves cases<br>like gg able to easily violate expectations when the protocol in<br>question has no mutating methods.<br></p><p>Another possibility would be to formalize the idea of value semantics in<br>protocol declarations, so that non-class protocols were only allowed to<br>apply to values.<br></p><p>It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>and we actually can afford to postpone thinking about it until after<br>Swift 4.<br></p><p>Thoughts?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  5, 2016 at 10:00:00pm</p></header><div class="content"><p>Personally, I&#39;m fine with current state of things.<br></p><p>Firstly, I consider classes like a compatibility feature. They slightly<br>fall out of Swift type system. One can almost entirely avoid them, except<br>when interacting with ObjC. (They somehow code in Haskell, right?)<br></p><p>Secondly, when we interact with a struct (record), we expect it not to<br>mutate itself by default.<br>On the other hand, classes are black boxes, they represent some entity with<br>which we interact. It is natural for such entities to perform internal<br>mutation during operation.<br></p><p>&gt; protocols with mutating methods should be constrained to applying to<br>non-class types<br>All methods of classes are implicitly mutating, so if something, then<br>protocols with non-mutating methods should be disallowed for classes.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/3efb7a1e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 01:00:00pm</p></header><div class="content"><p>On Jul 5, 2016, at 10:53 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; When T is a class type, it can easily violate *all* of these<br>&gt; expectations.  In other words, classes naturally bypass the mutation<br>&gt; model.<br>&gt; <br>&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt; addressed, because of the “viral const” problem.<br>&gt; <br>&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt; methods should be constrained to applying to non-class types.  That<br>&gt; would be a step in the right direction, but, that still leaves cases<br>&gt; like gg able to easily violate expectations when the protocol in<br>&gt; question has no mutating methods.<br>&gt; <br>&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt; apply to values.<br>&gt; <br>&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt; and we actually can afford to postpone thinking about it until after<br>&gt; Swift 4.<br></p><p>There is no chance that we will have time to re-evaluate this for Swift 3.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Jul 05 2016, Chris Lattner &lt;clattner-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt;&gt; and we actually can afford to postpone thinking about it until after<br>&gt;&gt; Swift 4.<br>&gt;<br>&gt; There is no chance that we will have time to re-evaluate this for Swift 3.<br></p><p>There are too many things in that category already... but I guess maybe<br>“we can&#39;t afford to postpone thinking about this” is a moot point in<br>that context.  OK, I&#39;ll put it on ice.<br></p><p>Thanks,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 4:15 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jul 05 2016, Chris Lattner &lt;clattner-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt;&gt;&gt; and we actually can afford to postpone thinking about it until after<br>&gt;&gt;&gt; Swift 4.<br>&gt;&gt; <br>&gt;&gt; There is no chance that we will have time to re-evaluate this for Swift 3.<br>&gt; <br>&gt; There are too many things in that category already... but I guess maybe<br>&gt; “we can&#39;t afford to postpone thinking about this” is a moot point in<br>&gt; that context.  OK, I&#39;ll put it on ice.<br></p><p>Agree.  I hope things as important as a mutability model for classes will still give them due consideration after Swift 3 even if it means a breaking change.  <br></p><p>I don’t recall any statements regarding Swift 3.x vs Swift 4, but maybe there is still a chance to do some of these things in the Swift 3.x set of releases (where x &gt; 0) without waiting for Swift 4.  <br></p><p>I was going to comment on the mutability model for classes, but now that you’re putting it on ice I’ll save my comments until we pick it back up.<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Class mutation model and value-constrained protocols</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; If we are going to maintain source stability after Swift 3, it seems<br>&gt; that we either need to address this now, or decide that it won&#39;t be<br>&gt; addressed, because of the “viral const” problem.<br>&gt; <br></p><p>IMHO immutable instances and value vs reference allocation are separate concerns. Just like you can have a struct which contains a memory reference or class that provide shared state, you can a class which is immutable and only represent changes via new object instances.<br></p><p>However, mutable methods and property setters do not expose the ability for a class to behave in this manner, as they have an effective inout self which is not exposed to code. There are optimizations which couldn’t be taken with this sort of approach, but it would certainly be valid for a class to implement “value semantics” with language support. There are abstractions available when using classes that are not available using structs/enums, including class clusters and the State pattern with open subclassing.<br></p><p>If it is impossible for a class to implement the requirements of say MutableCollection, then it makes sense to limit it to value types. But I’ll claim thats a limitation of the language’s support for letting people implement said protocols with immutable reference types, one that we might one day wish to allow for.<br></p><p>All that said, even if a class cannot implement MutableCollection today, they still would be in violation of the protocol with no changes - they just wouldn’t get compiler errors as a result. So given the other enthusiastic proposals in flight, I’d consider such compiler errors to be additive.<br></p><p>-DW<br></p><p>&gt; One idea that Jordan and I have floated is that protocols with mutating<br>&gt; methods should be constrained to applying to non-class types.  That<br>&gt; would be a step in the right direction, but, that still leaves cases<br>&gt; like gg able to easily violate expectations when the protocol in<br>&gt; question has no mutating methods.<br>&gt; <br>&gt; Another possibility would be to formalize the idea of value semantics in<br>&gt; protocol declarations, so that non-class protocols were only allowed to<br>&gt; apply to values.<br>&gt; <br>&gt; It&#39;s also possible that I&#39;ve overestimated the seriousness of the issue<br>&gt; and we actually can afford to postpone thinking about it until after<br>&gt; Swift 4.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
