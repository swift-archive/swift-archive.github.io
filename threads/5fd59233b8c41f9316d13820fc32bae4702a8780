<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>April 17, 2016 at 01:00:00am</p></header><div class="content"><p>Hello all,<br></p><p>Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here &lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt; and inlined below—would love to hear any comments or feedback before submitting the proposal.<br></p><p>Nate<br></p><p><br>Proposal: Expanded min/max algorithms<br>This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br></p><p>Related Bugs: SR-889 &lt;https://bugs.swift.org/browse/SR-889&gt; and SR-890 &lt;https://bugs.swift.org/browse/SR-890&gt;<br>Motivation<br>The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br></p><p>First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br></p><p>Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br></p><p>Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br></p><p>Proposed solution<br>This proposal has three parts:<br></p><p>Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br></p><p>let numbers = [30, 40, 10, 20, 60, 50]<br></p><p>if let i = numbers.minIndex() {<br>    print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>}<br>Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br></p><p>if let result = numbers.minmax() {<br>    // result == (minimum: 10, maximum: 60)<br>    // ...<br>}<br>if let i = numbers.minmaxIndices() {<br>    // i == (minimum: 2, maximum: 4)<br>    print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>}<br>Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br></p><p>Detailed design<br>The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br></p><p>extension Sequence {<br>    /// Returns the minimum and maximum values of `self`, using <br>    /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>    /// has no elements.<br>    func minmax(@noescape isOrderedBefore isOrderedBefore: <br>        (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>        ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>}<br></p><p>extension Sequence where Iterator.Element: Comparable {<br>    /// Returns the minimum and maximum values of `self`, or `nil` <br>    /// if the sequence has no elements.<br>    func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>}<br></p><p>extension Collection {<br>    /// Returns the index of the minimum element of `self`, using <br>    /// `isOrderedBefore` to compare elements, or `nil` if the<br>    /// collection has no elements.<br>    func minIndex(@noescape isOrderedBefore isOrderedBefore: <br>        (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>        ) rethrows -&gt; Index?<br>        <br>    /// Returns the index of the maximum element of `self`, using <br>    /// `isOrderedBefore` to compare elements, or `nil` if the<br>    /// collection has no elements.<br>    func maxIndex(@noescape isOrderedBefore isOrderedBefore: <br>        (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>        ) rethrows -&gt; Index?<br></p><p>    /// Returns the indices of the minimum and maximum elements of `self`, <br>    /// using `isOrderedBefore` to compare elements, or `nil` if the<br>    /// collection has no elements.<br>    func minmaxIndices(@noescape isOrderedBefore isOrderedBefore: <br>        (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>        ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?<br>}<br></p><p>extension Collection where Iterator.Element: Comparable {<br>    /// Returns the index of the minimum element of `self`, or `nil` <br>    /// if the collection has no elements.<br>    func minIndex() -&gt; Index?<br>        <br>    /// Returns the index of the maximum element of `self`, or `nil` <br>    /// if the collection has no elements.<br>    func maxIndex() -&gt; Index?<br></p><p>    /// Returns the indices of the minimum and maximum elements of `self`, <br>    /// or `nil` if the collection has no elements.<br>    func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?<br>}<br>The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br></p><p>protocol Sequence {<br>    // ...<br>    <br>    /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>    /// if the sequence has no elements. The uncustomized version returns<br>    /// `nil`.<br>    func _customMinComparableElement() -&gt; Iterator.Element??<br>    <br>    /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>    /// if the sequence has no elements. The uncustomized version returns<br>    /// `nil`.<br>    func _customMaxComparableElement() -&gt; Iterator.Element??<br>}<br></p><p>protocol Collection {<br>    // ...<br>    <br>    /// Returns the index of the minimum element as `Optional(index)` or<br>    /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>    /// version returns `nil`.<br>    func _customIndexOfMinComparableElement() -&gt; Index??<br>    <br>    /// Returns the index of the maximum element as `Optional(index)` or<br>    /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>    /// version returns `nil`.<br>    func _customIndexOfMaxComparableElement() -&gt; Index??<br>}<br>Minmax Algorithm<br></p><p>The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time. <br></p><p>In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br></p><p>Impact on existing code<br>As new APIs these should have no effect on existing code.<br></p><p>Alternatives considered<br>None.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/5fd58780/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 17, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Nate, <br></p><p> I think this is a very useful addition! I also had a related proposal few days ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014665.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014665.html&gt;<br> <br> I feel like min/max extension and element order belong to the same family of enhancements. If you are interested, maybe we can combine them together into a single proposal? <br></p><p>Best, <br></p><p> Taras<br></p><p><br>&gt; On 17 Apr 2016, at 08:44, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here &lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt; and inlined below—would love to hear any comments or feedback before submitting the proposal.<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt; Proposal: Expanded min/max algorithms<br>&gt; This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br>&gt; <br>&gt; Related Bugs: SR-889 &lt;https://bugs.swift.org/browse/SR-889&gt; and SR-890 &lt;https://bugs.swift.org/browse/SR-890&gt;<br>&gt; Motivation<br>&gt; The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br>&gt; <br>&gt; First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br>&gt; <br>&gt; Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br>&gt; <br>&gt; Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt; <br>&gt; Proposed solution<br>&gt; This proposal has three parts:<br>&gt; <br>&gt; Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br>&gt; <br>&gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt; <br>&gt; if let i = numbers.minIndex() {<br>&gt;     print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>&gt; }<br>&gt; Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br>&gt; <br>&gt; if let result = numbers.minmax() {<br>&gt;     // result == (minimum: 10, maximum: 60)<br>&gt;     // ...<br>&gt; }<br>&gt; if let i = numbers.minmaxIndices() {<br>&gt;     // i == (minimum: 2, maximum: 4)<br>&gt;     print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>&gt; }<br>&gt; Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br>&gt; <br>&gt; Detailed design<br>&gt; The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br>&gt; <br>&gt; extension Sequence {<br>&gt;     /// Returns the minimum and maximum values of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt;     /// has no elements.<br>&gt;     func minmax(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt;     /// Returns the minimum and maximum values of `self`, or `nil` <br>&gt;     /// if the sequence has no elements.<br>&gt;     func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns the index of the minimum element of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt;         <br>&gt;     /// Returns the index of the maximum element of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func maxIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt; <br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;     /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minmaxIndices(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; <br>&gt; extension Collection where Iterator.Element: Comparable {<br>&gt;     /// Returns the index of the minimum element of `self`, or `nil` <br>&gt;     /// if the collection has no elements.<br>&gt;     func minIndex() -&gt; Index?<br>&gt;         <br>&gt;     /// Returns the index of the maximum element of `self`, or `nil` <br>&gt;     /// if the collection has no elements.<br>&gt;     func maxIndex() -&gt; Index?<br>&gt; <br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;     /// or `nil` if the collection has no elements.<br>&gt;     func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     // ...<br>&gt;     <br>&gt;     /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMinComparableElement() -&gt; Iterator.Element??<br>&gt;     <br>&gt;     /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMaxComparableElement() -&gt; Iterator.Element??<br>&gt; }<br>&gt; <br>&gt; protocol Collection {<br>&gt;     // ...<br>&gt;     <br>&gt;     /// Returns the index of the minimum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMinComparableElement() -&gt; Index??<br>&gt;     <br>&gt;     /// Returns the index of the maximum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMaxComparableElement() -&gt; Index??<br>&gt; }<br>&gt; Minmax Algorithm<br>&gt; <br>&gt; The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time. <br>&gt; <br>&gt; In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br>&gt; <br>&gt; Impact on existing code<br>&gt; As new APIs these should have no effect on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; None.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/a5f1ca7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 16, 2016 at 11:00:00pm</p></header><div class="content"><p>On Sat, Apr 16, 2016 at 11:50 PM, Taras Zakharko via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi Nate,<br>&gt;<br>&gt;  I think this is a very useful addition! I also had a related proposal few<br>&gt; days ago:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014665.html<br>&gt;<br>&gt;  I feel like min/max extension and element order belong to the same family<br>&gt; of enhancements. If you are interested, maybe we can combine them together<br>&gt; into a single proposal?<br></p><p>Thanks Nate and Taras!  I&#39;d recommend to keep minmax and .order()<br>proposals separate.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 17, 2016 at 08:00:00am</p></header><div class="content"><p>I like the idea. It worries me a bit if the general recipe for such situations is to add dedicated-purpose methods like `_customIndexOfMinComparableElement` (etc.) to standard-library protocols; it *will* work, but is only going to work for the methods that get such treatment.<br></p><p>If it were feasible, I’d *greatly* prefer having some more-general way to (conditionally?) add overridable methods to a protocol, e.g.:<br></p><p>  // made-up declaration, all declared methods below are now overridable<br>  // on suitable types<br>  overridable extension Collection where Iterator.Element: Comparable {<br>    <br>    func min() -&gt; Iterator.Element?    <br></p><p>  }<br></p><p>…but am not sure that’s even realistically possible.<br></p><p>The reason I bring it up is that I’d hope that `indexOf`, `contains`, and also `upperBound`/`lowerBound` would merit a similar treatment to that proposed here for min, max, and minmax (if not already given such; if they get added to standard-library; etc.).<br></p><p>Moving on, wrt these min/max elements themselves: I think any expectation about *which* index gets returned should be document—either no such expectation in general, or a specific expectation, or that each concrete collection should document the expectation, etc.—because for the minIndex/maxIndex methods different approaches can yield different results.<br></p><p>EG: consider an order-maintaining collection that has contents ~ `[1,1,1,2,2,2,3,3,3]`. There are multiple candidates for both `minIndex` and `maxIndex`.<br></p><p>I don’t have a strong opinion on what the right preference would be here, but I think whatever the behavior winds up being should be at least documented.<br></p><p>Finally, FWIW if more of these semi-hidden methods become something exposed to users (as “advanced” options, perhaps, but still) I think replacing `??` with something like<br></p><p>  enum AdvancedCustomizationPointResult&lt;T&gt; {<br>    case NotCustomized // like `nil` for ??<br>    case NoResult // like `Optional(nil)` for ??<br>    case Result(T) // like `Optional(T)` for ??<br>  }<br></p><p>…might be worth considering (except with a better name than that). I’m not trying to backdoor optional protocol methods or anything, it just seems advisable to more-explicitly represent the intent (?? certainly works but feels a bit obscure).<br></p><p>&gt; On Apr 17, 2016, at 1:44 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here &lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt; and inlined below—would love to hear any comments or feedback before submitting the proposal.<br>&gt; <br>&gt; Nate<br>&gt; <br>&gt; <br>&gt; Proposal: Expanded min/max algorithms<br>&gt; This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br>&gt; <br>&gt; Related Bugs: SR-889 &lt;https://bugs.swift.org/browse/SR-889&gt; and SR-890 &lt;https://bugs.swift.org/browse/SR-890&gt;<br>&gt; Motivation<br>&gt; The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br>&gt; <br>&gt; First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br>&gt; <br>&gt; Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br>&gt; <br>&gt; Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt; <br>&gt; Proposed solution<br>&gt; This proposal has three parts:<br>&gt; <br>&gt; Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br>&gt; <br>&gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt; <br>&gt; if let i = numbers.minIndex() {<br>&gt;     print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>&gt; }<br>&gt; Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br>&gt; <br>&gt; if let result = numbers.minmax() {<br>&gt;     // result == (minimum: 10, maximum: 60)<br>&gt;     // ...<br>&gt; }<br>&gt; if let i = numbers.minmaxIndices() {<br>&gt;     // i == (minimum: 2, maximum: 4)<br>&gt;     print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>&gt; }<br>&gt; Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br>&gt; <br>&gt; Detailed design<br>&gt; The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br>&gt; <br>&gt; extension Sequence {<br>&gt;     /// Returns the minimum and maximum values of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt;     /// has no elements.<br>&gt;     func minmax(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt;     /// Returns the minimum and maximum values of `self`, or `nil` <br>&gt;     /// if the sequence has no elements.<br>&gt;     func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt; }<br>&gt; <br>&gt; extension Collection {<br>&gt;     /// Returns the index of the minimum element of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt;         <br>&gt;     /// Returns the index of the maximum element of `self`, using <br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func maxIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt; <br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;     /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minmaxIndices(@noescape isOrderedBefore isOrderedBefore: <br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; <br>&gt; extension Collection where Iterator.Element: Comparable {<br>&gt;     /// Returns the index of the minimum element of `self`, or `nil` <br>&gt;     /// if the collection has no elements.<br>&gt;     func minIndex() -&gt; Index?<br>&gt;         <br>&gt;     /// Returns the index of the maximum element of `self`, or `nil` <br>&gt;     /// if the collection has no elements.<br>&gt;     func maxIndex() -&gt; Index?<br>&gt; <br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;     /// or `nil` if the collection has no elements.<br>&gt;     func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt; }<br>&gt; The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     // ...<br>&gt;     <br>&gt;     /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMinComparableElement() -&gt; Iterator.Element??<br>&gt;     <br>&gt;     /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMaxComparableElement() -&gt; Iterator.Element??<br>&gt; }<br>&gt; <br>&gt; protocol Collection {<br>&gt;     // ...<br>&gt;     <br>&gt;     /// Returns the index of the minimum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMinComparableElement() -&gt; Index??<br>&gt;     <br>&gt;     /// Returns the index of the maximum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMaxComparableElement() -&gt; Index??<br>&gt; }<br>&gt; Minmax Algorithm<br>&gt; <br>&gt; The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time. <br>&gt; <br>&gt; In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br>&gt; <br>&gt; Impact on existing code<br>&gt; As new APIs these should have no effect on existing code.<br>&gt; <br>&gt; Alternatives considered<br>&gt; None.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/4aaf64e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>April 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 17, 2016, at 8:46 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea. It worries me a bit if the general recipe for such situations is to add dedicated-purpose methods like `_customIndexOfMinComparableElement` (etc.) to standard-library protocols; it *will* work, but is only going to work for the methods that get such treatment.<br></p><p>Agreed! I&#39;m not sure if that&#39;s part of the generics manifesto or not, but it&#39;d be great to have conditionally applied dynamically dispatched methods for cases like this.<br></p><p>&gt; If it were feasible, I’d *greatly* prefer having some more-general way to (conditionally?) add overridable methods to a protocol, e.g.:<br>&gt; <br>&gt;   // made-up declaration, all declared methods below are now overridable<br>&gt;   // on suitable types<br>&gt;   overridable extension Collection where Iterator.Element: Comparable {<br>&gt;     <br>&gt;     func min() -&gt; Iterator.Element?    <br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …but am not sure that’s even realistically possible.<br>&gt; <br>&gt; The reason I bring it up is that I’d hope that `indexOf`, `contains`, and also `upperBound`/`lowerBound` would merit a similar treatment to that proposed here for min, max, and minmax (if not already given such; if they get added to standard-library; etc.).<br></p><p>The customization points in the proposal are modeled after the two existing ones in the standard library for `contains` and `index(of:)`. You can see them here:<br></p><p>https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift#L190<br>https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift#L184<br></p><p>&gt; Moving on, wrt these min/max elements themselves: I think any expectation about *which* index gets returned should be document―either no such expectation in general, or a specific expectation, or that each concrete collection should document the expectation, etc.―because for the minIndex/maxIndex methods different approaches can yield different results.<br>&gt; <br>&gt; EG: consider an order-maintaining collection that has contents ~ `[1,1,1,2,2,2,3,3,3]`. There are multiple candidates for both `minIndex` and `maxIndex`.<br>&gt; <br>&gt; I don’t have a strong opinion on what the right preference would be here, but I think whatever the behavior winds up being should be at least documented.<br>&gt; <br>&gt; Finally, FWIW if more of these semi-hidden methods become something exposed to users (as “advanced” options, perhaps, but still) I think replacing `??` with something like<br>&gt; <br>&gt;   enum AdvancedCustomizationPointResult&lt;T&gt; {<br>&gt;     case NotCustomized // like `nil` for ??<br>&gt;     case NoResult // like `Optional(nil)` for ??<br>&gt;     case Result(T) // like `Optional(T)` for ??<br>&gt;   }<br>&gt; <br>&gt; …might be worth considering (except with a better name than that). I’m not trying to backdoor optional protocol methods or anything, it just seems advisable to more-explicitly represent the intent (?? certainly works but feels a bit obscure).<br>&gt; <br>&gt;&gt; On Apr 17, 2016, at 1:44 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here and inlined below―would love to hear any comments or feedback before submitting the proposal.<br>&gt;&gt; <br>&gt;&gt; Nate<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Proposal: Expanded min/max algorithms<br>&gt;&gt; This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br>&gt;&gt; <br>&gt;&gt; Related Bugs: SR-889 and SR-890<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br>&gt;&gt; <br>&gt;&gt; First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br>&gt;&gt; <br>&gt;&gt; Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br>&gt;&gt; <br>&gt;&gt; Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; This proposal has three parts:<br>&gt;&gt; <br>&gt;&gt; Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br>&gt;&gt; <br>&gt;&gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt;&gt; <br>&gt;&gt; if let i = numbers.minIndex() {<br>&gt;&gt;     print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>&gt;&gt; }<br>&gt;&gt; Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br>&gt;&gt; <br>&gt;&gt; if let result = numbers.minmax() {<br>&gt;&gt;     // result == (minimum: 10, maximum: 60)<br>&gt;&gt;     // ...<br>&gt;&gt; }<br>&gt;&gt; if let i = numbers.minmaxIndices() {<br>&gt;&gt;     // i == (minimum: 2, maximum: 4)<br>&gt;&gt;     print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>&gt;&gt; }<br>&gt;&gt; Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br>&gt;&gt; <br>&gt;&gt; extension Sequence {<br>&gt;&gt;     /// Returns the minimum and maximum values of `self`, using <br>&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt;&gt;     /// has no elements.<br>&gt;&gt;     func minmax(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;         ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt;&gt;     /// Returns the minimum and maximum values of `self`, or `nil` <br>&gt;&gt;     /// if the sequence has no elements.<br>&gt;&gt;     func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Collection {<br>&gt;&gt;     /// Returns the index of the minimum element of `self`, using <br>&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;     /// collection has no elements.<br>&gt;&gt;     func minIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;         ) rethrows -&gt; Index?<br>&gt;&gt;         <br>&gt;&gt;     /// Returns the index of the maximum element of `self`, using <br>&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;     /// collection has no elements.<br>&gt;&gt;     func maxIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;         ) rethrows -&gt; Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;&gt;     /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;     /// collection has no elements.<br>&gt;&gt;     func minmaxIndices(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;         ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Collection where Iterator.Element: Comparable {<br>&gt;&gt;     /// Returns the index of the minimum element of `self`, or `nil` <br>&gt;&gt;     /// if the collection has no elements.<br>&gt;&gt;     func minIndex() -&gt; Index?<br>&gt;&gt;         <br>&gt;&gt;     /// Returns the index of the maximum element of `self`, or `nil` <br>&gt;&gt;     /// if the collection has no elements.<br>&gt;&gt;     func maxIndex() -&gt; Index?<br>&gt;&gt; <br>&gt;&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;&gt;     /// or `nil` if the collection has no elements.<br>&gt;&gt;     func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt;&gt; }<br>&gt;&gt; The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;     // ...<br>&gt;&gt;     <br>&gt;&gt;     /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt;&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;&gt;     /// `nil`.<br>&gt;&gt;     func _customMinComparableElement() -&gt; Iterator.Element??<br>&gt;&gt;     <br>&gt;&gt;     /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt;&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;&gt;     /// `nil`.<br>&gt;&gt;     func _customMaxComparableElement() -&gt; Iterator.Element??<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Collection {<br>&gt;&gt;     // ...<br>&gt;&gt;     <br>&gt;&gt;     /// Returns the index of the minimum element as `Optional(index)` or<br>&gt;&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;&gt;     /// version returns `nil`.<br>&gt;&gt;     func _customIndexOfMinComparableElement() -&gt; Index??<br>&gt;&gt;     <br>&gt;&gt;     /// Returns the index of the maximum element as `Optional(index)` or<br>&gt;&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;&gt;     /// version returns `nil`.<br>&gt;&gt;     func _customIndexOfMaxComparableElement() -&gt; Index??<br>&gt;&gt; }<br>&gt;&gt; Minmax Algorithm<br>&gt;&gt; <br>&gt;&gt; The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time. <br>&gt;&gt; <br>&gt;&gt; In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; As new APIs these should have no effect on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; None.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/b4d9044c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>April 17, 2016 at 05:00:00pm</p></header><div class="content"><p>I like the idea. A few notes on naming:<br>– minIndex is somewhat confusing to me (it sounds like it&#39;s getting the<br>minimum index, i.e. indices.minElement()). How about indexOfMin() or<br>indexOfMinElement()?<br>– minmax() also doesn&#39;t read very well to me, plus it should technically be<br>minMax() which is kinda ugly. Perhaps limits() or extrema()? The latter<br>would be the most correct mathematically. For the index form that would<br>give e.g. indicesOfExtrema().<br></p><p><br>On Sun, Apr 17, 2016 at 4:42 PM, Nate Cook via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 17, 2016, at 8:46 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like the idea. It worries me a bit if the general recipe for such<br>&gt; situations is to add dedicated-purpose methods like<br>&gt; `_customIndexOfMinComparableElement` (etc.) to standard-library protocols;<br>&gt; it *will* work, but is only going to work for the methods that get such<br>&gt; treatment.<br>&gt;<br>&gt;<br>&gt; Agreed! I&#39;m not sure if that&#39;s part of the generics manifesto or not, but<br>&gt; it&#39;d be great to have conditionally applied dynamically dispatched methods<br>&gt; for cases like this.<br>&gt;<br>&gt; If it were feasible, I’d *greatly* prefer having some more-general way to<br>&gt; (conditionally?) add overridable methods to a protocol, e.g.:<br>&gt;<br>&gt;   // made-up declaration, all declared methods below are now overridable<br>&gt;   // on suitable types<br>&gt;   overridable extension Collection where Iterator.Element: Comparable {<br>&gt;<br>&gt;     func min() -&gt; Iterator.Element?<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; …but am not sure that’s even realistically possible.<br>&gt;<br>&gt; The reason I bring it up is that I’d hope that `indexOf`, `contains`, and<br>&gt; also `upperBound`/`lowerBound` would merit a similar treatment to that<br>&gt; proposed here for min, max, and minmax (if not already given such; if they<br>&gt; get added to standard-library; etc.).<br>&gt;<br>&gt;<br>&gt; The customization points in the proposal are modeled after the two<br>&gt; existing ones in the standard library for `contains` and `index(of:)`. You<br>&gt; can see them here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift#L190<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift#L184<br>&gt;<br>&gt; Moving on, wrt these min/max elements themselves: I think any expectation<br>&gt; about *which* index gets returned should be document—either no such<br>&gt; expectation in general, or a specific expectation, or that each concrete<br>&gt; collection should document the expectation, etc.—because for the<br>&gt; minIndex/maxIndex methods different approaches can yield different results.<br>&gt;<br>&gt; EG: consider an order-maintaining collection that has contents ~<br>&gt; `[1,1,1,2,2,2,3,3,3]`. There are multiple candidates for both `minIndex`<br>&gt; and `maxIndex`.<br>&gt;<br>&gt; I don’t have a strong opinion on what the right preference would be here,<br>&gt; but I think whatever the behavior winds up being should be at least<br>&gt; documented.<br>&gt;<br>&gt; Finally, FWIW if more of these semi-hidden methods become something<br>&gt; exposed to users (as “advanced” options, perhaps, but still) I think<br>&gt; replacing `??` with something like<br>&gt;<br>&gt;   enum AdvancedCustomizationPointResult&lt;T&gt; {<br>&gt;     case NotCustomized // like `nil` for ??<br>&gt;     case NoResult // like `Optional(nil)` for ??<br>&gt;     case Result(T) // like `Optional(T)` for ??<br>&gt;   }<br>&gt;<br>&gt; …might be worth considering (except with a better name than that). I’m not<br>&gt; trying to backdoor optional protocol methods or anything, it just seems<br>&gt; advisable to more-explicitly represent the intent (?? certainly works but<br>&gt; feels a bit obscure).<br>&gt;<br>&gt; On Apr 17, 2016, at 1:44 AM, Nate Cook via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello all,<br>&gt;<br>&gt; Attached is a draft of a proposal to expand the min and max sequence APIs<br>&gt; to better handle collections and to support future sorted<br>&gt; sequences/collections. The proposal is in a gist here<br>&gt; &lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt; and inlined<br>&gt; below—would love to hear any comments or feedback before submitting the<br>&gt; proposal.<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;<br>&gt; Proposal: Expanded min/max algorithms<br>&gt;<br>&gt; This proposal would expand on the min() and max() sequence methods to add<br>&gt; methods that return the corresponding index for a collection, efficiently<br>&gt; find the minimum and maximum elements or indices at the same time, and<br>&gt; provide extension points for sorted collections to provide all these<br>&gt; results more efficiently.<br>&gt;<br>&gt; *Related Bugs:* SR-889 &lt;https://bugs.swift.org/browse/SR-889&gt; and SR-890<br>&gt; &lt;https://bugs.swift.org/browse/SR-890&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The Sequence protocol currently offers min() and max() methods that<br>&gt; return the minimum and maximum elements of a sequence or collection.<br>&gt; Unfortunately, there are applications where these methods do not provide<br>&gt; enough flexibility to be useful.<br>&gt;<br>&gt; First, if the user of a collection wants not just to get the minimum value<br>&gt; but also to operate on it in some way (e.g., mutation or just accessing it<br>&gt; multiple times), she would need the index of the minimum element. The<br>&gt; current APIs don&#39;t support that, so she would need to write her own.<br>&gt;<br>&gt; Second, the writer of a sorted collection is currently unable to provide<br>&gt; efficient responses to the min() and max() methods when used in a generic<br>&gt; context, even though these should be O(1) operations. Just like Set can<br>&gt; respond quickly to contains(_:) even in a generic context, so too should<br>&gt; new sorted collections be able to optimize their responses.<br>&gt;<br>&gt; Finally, getting the minimum and maximum elements (or indices) of a<br>&gt; collection or sequence currently requires calling both min() and max().<br>&gt; With two calls, every element is iterated and compared twice. When you need<br>&gt; both results, finding both the minimum and the maximum at the same time is<br>&gt; more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt; Proposed solution<br>&gt;<br>&gt; This proposal has three parts:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Adding minIndex() and maxIndex() methods to Collection that return the<br>&gt;    index of the minimum and maximum elements, respectively.<br>&gt;<br>&gt;    let numbers = [30, 40, 10, 20, 60, 50]<br>&gt;    if let i = numbers.minIndex() {<br>&gt;        print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10}<br>&gt;<br>&gt;    2.<br>&gt;<br>&gt;    Adding minmax() and minmaxIndices() methods to Sequence and Collection,<br>&gt;    respectively, to calculate the values (or indices) of the minimum and<br>&gt;    maximum elements simultaneously.<br>&gt;<br>&gt;    if let result = numbers.minmax() {<br>&gt;        // result == (minimum: 10, maximum: 60)<br>&gt;        // ...}if let i = numbers.minmaxIndices() {<br>&gt;        // i == (minimum: 2, maximum: 4)<br>&gt;        print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)}<br>&gt;<br>&gt;    3.<br>&gt;<br>&gt;    Adding customization points for sequences and collections that can<br>&gt;    offer more efficient results: _customMinComparableElement()/<br>&gt;    _customMaxComparableElement() for Sequence and<br>&gt;    _customIndexOfMinComparableElement()/<br>&gt;    _customIndexOfMaxComparableElement()for Collection.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; The following methods would be added to the visible public APIs of<br>&gt; Sequence and Collection as default implementations.<br>&gt;<br>&gt; extension Sequence {<br>&gt;     /// Returns the minimum and maximum values of `self`, using<br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt;     /// has no elements.<br>&gt;     func minmax(@noescape isOrderedBefore isOrderedBefore:<br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?}<br>&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt;     /// Returns the minimum and maximum values of `self`, or `nil`<br>&gt;     /// if the sequence has no elements.<br>&gt;     func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?}<br>&gt; extension Collection {<br>&gt;     /// Returns the index of the minimum element of `self`, using<br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minIndex(@noescape isOrderedBefore isOrderedBefore:<br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt;<br>&gt;     /// Returns the index of the maximum element of `self`, using<br>&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func maxIndex(@noescape isOrderedBefore isOrderedBefore:<br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; Index?<br>&gt;<br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`,<br>&gt;     /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;     /// collection has no elements.<br>&gt;     func minmaxIndices(@noescape isOrderedBefore isOrderedBefore:<br>&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;         ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?}<br>&gt; extension Collection where Iterator.Element: Comparable {<br>&gt;     /// Returns the index of the minimum element of `self`, or `nil`<br>&gt;     /// if the collection has no elements.<br>&gt;     func minIndex() -&gt; Index?<br>&gt;<br>&gt;     /// Returns the index of the maximum element of `self`, or `nil`<br>&gt;     /// if the collection has no elements.<br>&gt;     func maxIndex() -&gt; Index?<br>&gt;<br>&gt;     /// Returns the indices of the minimum and maximum elements of `self`,<br>&gt;     /// or `nil` if the collection has no elements.<br>&gt;     func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?}<br>&gt;<br>&gt; The customization points would be added to Sequence and Collection as<br>&gt; protocol requirements, along with default implementations that return nil.<br>&gt; The existing min()and max() methods would be updated to call the<br>&gt; corresponding methods before iterating over the entire sequence.<br>&gt;<br>&gt; protocol Sequence {<br>&gt;     // ...<br>&gt;<br>&gt;     /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMinComparableElement() -&gt; Iterator.Element??<br>&gt;<br>&gt;     /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;     /// `nil`.<br>&gt;     func _customMaxComparableElement() -&gt; Iterator.Element??}<br>&gt;<br>&gt; protocol Collection {<br>&gt;     // ...<br>&gt;<br>&gt;     /// Returns the index of the minimum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized<br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMinComparableElement() -&gt; Index??<br>&gt;<br>&gt;     /// Returns the index of the maximum element as `Optional(index)` or<br>&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized<br>&gt;     /// version returns `nil`.<br>&gt;     func _customIndexOfMaxComparableElement() -&gt; Index??}<br>&gt;<br>&gt; Minmax Algorithm<br>&gt;<br>&gt; The minmax() algorithm finds the minimum and maximum elements of a<br>&gt; sequence in one pass more efficiently than consecutive calls to min() and<br>&gt; max(). This optimization comes from iterating over a sequence two<br>&gt; elements at a time.<br>&gt;<br>&gt; In each iteration, two consecutive elements are compared with each other.<br>&gt; Only the lesser element could be a minimum for the whole sequence, so it is<br>&gt; compared with the current minimum, while only the greater element could be<br>&gt; a maximum, so it is compared with the current maximum. This works out to 3<br>&gt; comparisons for every 2 elements vs. 2 comparisons for every element when<br>&gt; the minimum and maximum are found individually.<br>&gt; Impact on existing code<br>&gt;<br>&gt; As new APIs these should have no effect on existing code.<br>&gt; Alternatives considered<br>&gt;<br>&gt; None.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/77a8e46a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 17, 2016 at 10:00:00am</p></header><div class="content"><p>I *quite* like `extrema`/`indicesOfExtrema` over minmax.<br></p><p>&gt; On Apr 17, 2016, at 10:03 AM, Patrick Pijnappel &lt;patrickpijnappel at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the idea. A few notes on naming:<br>&gt; – minIndex is somewhat confusing to me (it sounds like it&#39;s getting the minimum index, i.e. indices.minElement()). How about indexOfMin() or indexOfMinElement()?<br>&gt; – minmax() also doesn&#39;t read very well to me, plus it should technically be minMax() which is kinda ugly. Perhaps limits() or extrema()? The latter would be the most correct mathematically. For the index form that would give e.g. indicesOfExtrema().<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/0b6d130c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 17, 2016, at 9:42 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Apr 17, 2016, at 8:46 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I like the idea. It worries me a bit if the general recipe for such situations is to add dedicated-purpose methods like `_customIndexOfMinComparableElement` (etc.) to standard-library protocols; it *will* work, but is only going to work for the methods that get such treatment.<br>&gt; <br>&gt; Agreed! I&#39;m not sure if that&#39;s part of the generics manifesto or not, but it&#39;d be great to have conditionally applied dynamically dispatched methods for cases like this.<br>&gt; <br>&gt;&gt; If it were feasible, I’d *greatly* prefer having some more-general way to (conditionally?) add overridable methods to a protocol, e.g.:<br>&gt;&gt; <br>&gt;&gt;   // made-up declaration, all declared methods below are now overridable<br>&gt;&gt;   // on suitable types<br>&gt;&gt;   overridable extension Collection where Iterator.Element: Comparable {<br>&gt;&gt;     <br>&gt;&gt;     func min() -&gt; Iterator.Element?    <br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …but am not sure that’s even realistically possible.<br>&gt;&gt; <br>&gt;&gt; The reason I bring it up is that I’d hope that `indexOf`, `contains`, and also `upperBound`/`lowerBound` would merit a similar treatment to that proposed here for min, max, and minmax (if not already given such; if they get added to standard-library; etc.).<br>&gt; <br>&gt; The customization points in the proposal are modeled after the two existing ones in the standard library for `contains` and `index(of:)`. You can see them here:<br>&gt; <br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift#L190 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift#L190&gt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift#L184 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift#L184&gt;<br>I thought the _ prefix meant “internal to stdlib”.  Are the existing extension points intended to be exposed as part of the public interface?  Or are they just intended to be implementation details of the library which are implemented by some of the stdlib types?  If they are implementation details they are probably not a good model for public interfaces.<br></p><p>These extension points are effectively “optional protocol requirements”.  There has been a lengthy thread about those, with much discussion around Cocoa protocols such as UITableView using lack of customization to take a fast path implementation.  Your extension points essentially do the opposite - implementing them means there is a custom fast path that can be taken, rather than a complex custom layout that defeats the standard fast path.  <br></p><p>Despite the differences the impact on the design of the protocol is quite similar.  I think this is a good opportunity to agree on the most Swifty way to handle this kind of customization point (i.e. “optional” requirement with a default implementation).  Some of the ideas discussed in the other thread would require language tweaks if we go with them.  <br></p><p>I think the “optional requirement” issue should be sorted out first and this proposal updated accordingly before proceeding with a review.  <br></p><p><br>&gt; <br>&gt;&gt; Moving on, wrt these min/max elements themselves: I think any expectation about *which* index gets returned should be document—either no such expectation in general, or a specific expectation, or that each concrete collection should document the expectation, etc.—because for the minIndex/maxIndex methods different approaches can yield different results.<br>&gt;&gt; <br>&gt;&gt; EG: consider an order-maintaining collection that has contents ~ `[1,1,1,2,2,2,3,3,3]`. There are multiple candidates for both `minIndex` and `maxIndex`.<br>&gt;&gt; <br>&gt;&gt; I don’t have a strong opinion on what the right preference would be here, but I think whatever the behavior winds up being should be at least documented.<br>&gt;&gt; <br>&gt;&gt; Finally, FWIW if more of these semi-hidden methods become something exposed to users (as “advanced” options, perhaps, but still) I think replacing `??` with something like<br>&gt;&gt; <br>&gt;&gt;   enum AdvancedCustomizationPointResult&lt;T&gt; {<br>&gt;&gt;     case NotCustomized // like `nil` for ??<br>&gt;&gt;     case NoResult // like `Optional(nil)` for ??<br>&gt;&gt;     case Result(T) // like `Optional(T)` for ??<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …might be worth considering (except with a better name than that). I’m not trying to backdoor optional protocol methods or anything, it just seems advisable to more-explicitly represent the intent (?? certainly works but feels a bit obscure).<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 17, 2016, at 1:44 AM, Nate Cook via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attached is a draft of a proposal to expand the min and max sequence APIs to better handle collections and to support future sorted sequences/collections. The proposal is in a gist here &lt;https://gist.github.com/natecook1000/d51267a6cf9e9463b9387bced4c65b16&gt; and inlined below—would love to hear any comments or feedback before submitting the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nate<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: Expanded min/max algorithms<br>&gt;&gt;&gt; This proposal would expand on the min() and max() sequence methods to add methods that return the corresponding index for a collection, efficiently find the minimum and maximum elements or indices at the same time, and provide extension points for sorted collections to provide all these results more efficiently.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related Bugs: SR-889 &lt;https://bugs.swift.org/browse/SR-889&gt; and SR-890 &lt;https://bugs.swift.org/browse/SR-890&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; The Sequence protocol currently offers min() and max() methods that return the minimum and maximum elements of a sequence or collection. Unfortunately, there are applications where these methods do not provide enough flexibility to be useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First, if the user of a collection wants not just to get the minimum value but also to operate on it in some way (e.g., mutation or just accessing it multiple times), she would need the index of the minimum element. The current APIs don&#39;t support that, so she would need to write her own.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Second, the writer of a sorted collection is currently unable to provide efficient responses to the min() and max() methods when used in a generic context, even though these should be O(1) operations. Just like Set can respond quickly to contains(_:) even in a generic context, so too should new sorted collections be able to optimize their responses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, getting the minimum and maximum elements (or indices) of a collection or sequence currently requires calling both min() and max(). With two calls, every element is iterated and compared twice. When you need both results, finding both the minimum and the maximum at the same time is more efficient, requiring only a single pass and 25% fewer comparisons.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; This proposal has three parts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding minIndex() and maxIndex() methods to Collection that return the index of the minimum and maximum elements, respectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let numbers = [30, 40, 10, 20, 60, 50]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let i = numbers.minIndex() {<br>&gt;&gt;&gt;     print(&quot;\(i): \(numbers[i])&quot;)               // 2: 10<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Adding minmax() and minmaxIndices() methods to Sequence and Collection, respectively, to calculate the values (or indices) of the minimum and maximum elements simultaneously.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let result = numbers.minmax() {<br>&gt;&gt;&gt;     // result == (minimum: 10, maximum: 60)<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; if let i = numbers.minmaxIndices() {<br>&gt;&gt;&gt;     // i == (minimum: 2, maximum: 4)<br>&gt;&gt;&gt;     print(&quot;\(i.minimum): \(numbers[i.minimum])&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Adding customization points for sequences and collections that can offer more efficient results: _customMinComparableElement()/_customMaxComparableElement() for Sequence and _customIndexOfMinComparableElement()/_customIndexOfMaxComparableElement()for Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; The following methods would be added to the visible public APIs of Sequence and Collection as default implementations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt;     /// Returns the minimum and maximum values of `self`, using <br>&gt;&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the sequence<br>&gt;&gt;&gt;     /// has no elements.<br>&gt;&gt;&gt;     func minmax(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt;         ) rethrows -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence where Iterator.Element: Comparable {<br>&gt;&gt;&gt;     /// Returns the minimum and maximum values of `self`, or `nil` <br>&gt;&gt;&gt;     /// if the sequence has no elements.<br>&gt;&gt;&gt;     func minmax() -&gt; (min: Iterator.Element, max: Iterator.Element)?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;     /// Returns the index of the minimum element of `self`, using <br>&gt;&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;&gt;     /// collection has no elements.<br>&gt;&gt;&gt;     func minIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt;         ) rethrows -&gt; Index?<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     /// Returns the index of the maximum element of `self`, using <br>&gt;&gt;&gt;     /// `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;&gt;     /// collection has no elements.<br>&gt;&gt;&gt;     func maxIndex(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt;         ) rethrows -&gt; Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;&gt;&gt;     /// using `isOrderedBefore` to compare elements, or `nil` if the<br>&gt;&gt;&gt;     /// collection has no elements.<br>&gt;&gt;&gt;     func minmaxIndices(@noescape isOrderedBefore isOrderedBefore: <br>&gt;&gt;&gt;         (Iterator.Element, Iterator.Element) throws -&gt; Bool<br>&gt;&gt;&gt;         ) rethrows -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection where Iterator.Element: Comparable {<br>&gt;&gt;&gt;     /// Returns the index of the minimum element of `self`, or `nil` <br>&gt;&gt;&gt;     /// if the collection has no elements.<br>&gt;&gt;&gt;     func minIndex() -&gt; Index?<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;     /// Returns the index of the maximum element of `self`, or `nil` <br>&gt;&gt;&gt;     /// if the collection has no elements.<br>&gt;&gt;&gt;     func maxIndex() -&gt; Index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     /// Returns the indices of the minimum and maximum elements of `self`, <br>&gt;&gt;&gt;     /// or `nil` if the collection has no elements.<br>&gt;&gt;&gt;     func minmaxIndices() -&gt; (minIndex: Index, maxIndex: Index)?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The customization points would be added to Sequence and Collection as protocol requirements, along with default implementations that return nil. The existing min()and max() methods would be updated to call the corresponding methods before iterating over the entire sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Returns the minimum element as `Optional(element)` or `Optional(nil)`<br>&gt;&gt;&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;&gt;&gt;     /// `nil`.<br>&gt;&gt;&gt;     func _customMinComparableElement() -&gt; Iterator.Element??<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Returns the maximum element as `Optional(element)` or `Optional(nil)`<br>&gt;&gt;&gt;     /// if the sequence has no elements. The uncustomized version returns<br>&gt;&gt;&gt;     /// `nil`.<br>&gt;&gt;&gt;     func _customMaxComparableElement() -&gt; Iterator.Element??<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;     // ...<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Returns the index of the minimum element as `Optional(index)` or<br>&gt;&gt;&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;&gt;&gt;     /// version returns `nil`.<br>&gt;&gt;&gt;     func _customIndexOfMinComparableElement() -&gt; Index??<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     /// Returns the index of the maximum element as `Optional(index)` or<br>&gt;&gt;&gt;     /// `Optional(nil)` if the sequence has no elements. The uncustomized <br>&gt;&gt;&gt;     /// version returns `nil`.<br>&gt;&gt;&gt;     func _customIndexOfMaxComparableElement() -&gt; Index??<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Minmax Algorithm<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The minmax() algorithm finds the minimum and maximum elements of a sequence in one pass more efficiently than consecutive calls to min() and max(). This optimization comes from iterating over a sequence two elements at a time. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In each iteration, two consecutive elements are compared with each other. Only the lesser element could be a minimum for the whole sequence, so it is compared with the current minimum, while only the greater element could be a maximum, so it is compared with the current maximum. This works out to 3 comparisons for every 2 elements vs. 2 comparisons for every element when the minimum and maximum are found individually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; As new APIs these should have no effect on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; None.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160417/9c5833fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 18, 2016 at 09:00:00am</p></header><div class="content"><p>On Sun, Apr 17, 2016 at 11:10 AM, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; These extension points are effectively “optional protocol requirements”.<br></p><p>I&#39;m sorry, but they are not optional requirements.  They are<br>workarounds for a language issue -- inability to make<br>conditionally-available methods customizable by a conforming type.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Expanded min/max algorithms</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 18, 2016, at 11:08 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Sun, Apr 17, 2016 at 11:10 AM, Matthew Johnson via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; These extension points are effectively “optional protocol requirements”.<br>&gt; <br>&gt; I&#39;m sorry, but they are not optional requirements.  They are<br>&gt; workarounds for a language issue -- inability to make<br>&gt; conditionally-available methods customizable by a conforming type.<br></p><p>I understand that they are not optional requirements as they exist in the language today.  What I meant is that the approach these extension points are taking is effectively the same as one of the approaches discussed in the &quot;How to eliminate &#39;optional&#39; protocol	requirements” thread.  <br></p><p>I am referring to the first option in Doug’s initial message: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160404/014471.html.  Doug considered this unworkable but Joe considers the reasons Doug called it unworkable to be missing language features that should exist anyway: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/014696.html.  There has not yet been a resolution on this issue.<br></p><p>The primary difference between that approach and your extension points is that you add and extra level of optionality to the value returned whereas the approach in that thread has an optional closure property.  Both approaches use a default implementation of “return nil” to indicate that there is no customization requested by the implementer.<br></p><p>In your proposal the extension points look like this:<br></p><p>func _customMinComparableElement() -&gt; Iterator.Element??<br></p><p>Translating to the option Doug presented they would look like this:<br></p><p>var _customMinComparableElement: (() -&gt; Iterator.Element?)? { get }<br></p><p>In either case a default implementation that returns nil would be provided.  Under Doug’s model where methods can be used to implement such requirements, implementers would provide a method like this:<br></p><p>func _customMinComparableElement() -&gt; Iterator.Element?<br></p><p>I hope I have clarified how I believe these extension points are related to the thread about removing optional protocol requirements from the language.  My opinion is that if we are going to remove them and import them from Objective-C in a more Swifty way by embedding the optionality in the type system that same mechanism should be used by any extension points which behave similarly.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/731e11a3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
