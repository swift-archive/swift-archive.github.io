<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>A type-checking performance case study</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April  8, 2016 at 11:00:00am</p></header><div class="content"><p>The standard library team asked the compiler team to take a look at the performance of the type-checker.  Their observation was that several in-progress additions to the standard library were causing a disproportionate increase in the time it required to compile a simple-seeming expression, and they were concerned that this was going to block library progress.  This is the resulting analysis.<br></p><p>Thanks go to Doug Gregor for being a sounding board for a lot of ideas that came up during this investigation.<br></p><p>1. Introduction<br></p><p>In general, it is expected that changes to the source code can cause non-linear increases in type-checking time.  For one, all type systems with some form of generic type propagation have the ability to create exponentially-large types that will generally require exponential work to manipulate.  But Swift also introduces several forms of disjunctive constraint, most notably overload resolution, and solving these can require combinatorial explosions in type-checker work.  Nonetheless, for any particular problem, there are usually things we can do to avoid or limit that combinatorial explosion, and so it is always reasonable to take a look.<br></p><p>Some background for the rest of this discussion.  The current semantics for name lookup, member or otherwise, are that all possible matches are dropped into an overload set with no explicit ranking between them.  If solutions can be found with multiple overloads, they are disambiguated (hopefully) using the ambiguity resolution rules.  Some aspects of the ambiguity resolution rules do apply to declarations in the abstract; for example, there is a rule that prefers a solution that picks a function with a strictly-more-specialized signature.  However, in general, such rules cannot be applied immediately during type-checking.  This is because of the &quot;score&quot; system in which solutions are ranked according to the kind and number of various undesired implicit conversions they perform: for example, it is possible that a solution using a more-specialized function will end up requiring more undesired conversions and thus rank worse.  Therefore, the type-checker must find all possible solutions and only then rank them, which often prohibits short-circuits of the combinatorial explosion.<br></p><p>2. The problem<br></p><p>Okay, concrete stuff.  The expression in question is:<br></p><p>  (0..&lt;5).lazy.map { String($0) }<br></p><p>The types of &#39;0&#39; and &#39;5&#39; are not immediately constrained; in fact, it will turn out that they can only be constrained by assigning them their default literal type.  Many expressions that are expensive to type-check feature this property, because the assignment of default types must occur very late in type-checking, as a matter of last resort.<br></p><p>&#39;..&lt;&#39; has two overloads, one requiring the value type to be Comparable and a more specialized one which also requires it to be Strideable.  They yield different types.<br></p><p>&#39;lazy&#39; is a member name and therefore can only be resolved when the base type is known.  As it happens, in both cases the overload set will end up the same: a small number of overloads from various protocol extensions.  The proposed library change adds several of these, greatly exacerbating the explosion.  All of these definitions yield different types.<br></p><p>&#39;map&#39; is a member name and therefore can only be resolved when the base type is known.  It has a small number of overloads in different types and protocol extensions.<br></p><p>&#39;String.init&#39; has a huge number of overloads, somewhere around fifty.<br></p><p>3. Current type-checker behavior<br></p><p>The type-checker ends up taking the right basic approach for solving this: it experimentally picks one of the overloads for &#39;..&lt;&#39;, then an overload for &#39;.lazy&#39;, then an overload for &#39;.map&#39;, then an overload for &#39;String.init&#39;.<br></p><p>As the constraint system is progressively solved, it will turn out that the value type of the integer literals will propagate all the way down to be the type of &#39;$0&#39; and hence of the argument to String.  This sort of propagation could, in general, require the literals to have a specific type.  In this case, since &#39;String(x)&#39; will take basically anything, the literals are not constrained, and we will end up defaulting their types.  I mention this only to underline why the type-checker cannot apply this defaulting quickly.<br></p><p>Because the literals end up needing to be defaulted, and because there are two possible default types for integer literals (we will use &#39;Double&#39; if &#39;Int&#39; does not work), the basic combinatoric formula for this constraint system is something like 2 x 4 x 4 x 50 x 2 x 2.  (I don&#39;t remember the actual numbers of overloads.)  This is why type-checking is slow.<br></p><p>4. Possible solutions<br></p><p>As a patch to the problem, I recognized that many of those 50 overloads of &#39;String.init&#39; were not viable due to argument-label mismatches, but were only being recognized as such in the innermost loop.  (The rule here is that you cannot pass a tuple value and have it automatically &quot;explode&quot; to match the parameter list; the syntactic call arguments must structurally match the parameters.  This was an accepted proposal with corresponding compiler implementation from Februrary.  Unfortunately, it turns out that our enforcement of this is inconsistent.)  It was simple enough to avoid this by marking the overloads as non-viable upon lookup; it even turns out that we already has this heuristic, and it just hadn&#39;t kept pace with the language change.  So this limits the explosion in this case.<br></p><p>There are various other type-checking heuristics that might also have helped with this.  For example, the overload sets of &#39;lazy&#39; are the same in both cases; this is something that could theoretically be observed without expanding the overload set of &#39;..&lt;&#39;, and in some cases this might allow some downstream type-checking to proceed outside of any contingencies.  I don&#39;t know that it would have significantly helped in this case, however.<br></p><p>Anything beyond that will require language changes.<br></p><p>Note that there have been proposals about restricting various kinds of implicit conversions.  Those proposals are not pertinent here; the implicit conversion are not a significant contributor to this particular problem.  The real problem is overloading.<br></p><p>One very drastic solution to this problem would be to eliminate non-labelled overloads.  (A perhaps more-reasonable way to describe this is to say that argument labels are a part of the name, and therefore two declarations with different labels are not overloads.)  That is, given the syntactic form of an expression, we would always be able to find a single function that it could invoke.  The current argument-labelling design of the language does make this more palatable than it was in earlier iterations.  However, I don&#39;t think it&#39;s palatable enough: this change would be very limiting, and in particular I think we are very unlikely to accept it for operators or single-argument initializers.<br></p><p>A less drastic solution suggests itself when we examine the nature of these overloads.  &#39;..&lt;&#39;, &#39;lazy&#39;, and &#39;map&#39; all obey an implicit hierarchy of overloads, each imposing stricter constraints than the last.  Furthermore, specifically for &#39;lazy&#39; and &#39;map&#39;, this hierarchy actually follows the explicit hierarchy of types and the protocols they conform to.  Perhaps we could use this to declare that certain declarations unconditionally hide declarations with the same name from &quot;base&quot; types: for example, a declaration from a concrete type would always hide a declaration from a protocol (or an extension thereof) that the type declares conformance to, and a declaration from a protocol would hide a declaration from a protocol it is derived from.  (This rule could still be implemented in the presence of conditional conformances, but it would be more difficult to apply &quot;statically&quot; during type-checking; we might have to compute a full solution before we could recognize that an overload was actually hidden by a conditional conformance.)  In this case, I believe this would have left us with only a single overload to consider for both &#39;lazy&#39; and &#39;map&#39;, greatly reducing the combinatorial space of solutions.  Of course, it&#39;s also possible that this would remove viable solutions.<br></p><p>5. Actions and recommendations<br></p><p>I&#39;ve landed the viability-limiting patch as 563057ca980fb9a8fce899184761a812164dc9d2.  Hopefully it sticks.<br></p><p>I strongly recommend that we pursue declaration hiding as a language change.  Even independent of type-checker performance, this seems quite defensible as a language direction, since it makes it much easier to reason about overloading in the presence of protocol extensions and so on.  However, there are still a lot of major open questions with the design.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>A type-checking performance case study</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April  8, 2016 at 01:00:00pm</p></header><div class="content"><p>On Fri, Apr 8, 2016 at 11:47 AM, John McCall via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; I strongly recommend that we pursue declaration hiding as a language change.<br></p><p>I completely agree with John.  Not having this rule is not just a<br>performance problem, it also leaks into the user model.  For example:<br></p><p>- If you have a lazy collection, you can still call the eager `map` if<br>you provide matching type context.<br></p><p>- If a protocol extension method that was intended to be a default<br>implementation does not get selected as the implementation, then both<br>are visible on the type.  This causes ambiguities when chaining.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>A type-checking performance case study</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 8, 2016, at 11:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; One very drastic solution to this problem would be to eliminate non-labelled overloads.  (A perhaps more-reasonable way to describe this is to say that argument labels are a part of the name, and therefore two declarations with different labels are not overloads.)  That is, given the syntactic form of an expression, we would always be able to find a single function that it could invoke.  The current argument-labelling design of the language does make this more palatable than it was in earlier iterations.  However, I don&#39;t think it&#39;s palatable enough: this change would be very limiting, and in particular I think we are very unlikely to accept it for operators or single-argument initializers.<br></p><p>Independent of eliminating overloads, our model has been strongly trending toward &quot;labels are part of the name&quot;. It seems like a bug to me at this point that we consider declarations with different argument labels to be overloads in the type checker. Now that we&#39;ve banned tuple splatting, we should be able to enforce argument label matching much earlier in the type-checker pipeline, which should prune the overload set a lot for initializers and many Cocoa naming conventions.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>A type-checking performance case study</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 11, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 8:35 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Apr 8, 2016, at 11:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One very drastic solution to this problem would be to eliminate non-labelled overloads.  (A perhaps more-reasonable way to describe this is to say that argument labels are a part of the name, and therefore two declarations with different labels are not overloads.)  That is, given the syntactic form of an expression, we would always be able to find a single function that it could invoke.  The current argument-labelling design of the language does make this more palatable than it was in earlier iterations.  However, I don&#39;t think it&#39;s palatable enough: this change would be very limiting, and in particular I think we are very unlikely to accept it for operators or single-argument initializers.<br>&gt; <br>&gt; Independent of eliminating overloads, our model has been strongly trending toward &quot;labels are part of the name&quot;. It seems like a bug to me at this point that we consider declarations with different argument labels to be overloads in the type checker. Now that we&#39;ve banned tuple splatting, we should be able to enforce argument label matching much earlier in the type-checker pipeline, which should prune the overload set a lot for initializers and many Cocoa naming conventions.<br></p><p>I completely agree, and the type-checker does now do this.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>A type-checking performance case study</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 8:40 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 11, 2016, at 8:35 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 8, 2016, at 11:47 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One very drastic solution to this problem would be to eliminate non-labelled overloads.  (A perhaps more-reasonable way to describe this is to say that argument labels are a part of the name, and therefore two declarations with different labels are not overloads.)  That is, given the syntactic form of an expression, we would always be able to find a single function that it could invoke.  The current argument-labelling design of the language does make this more palatable than it was in earlier iterations.  However, I don&#39;t think it&#39;s palatable enough: this change would be very limiting, and in particular I think we are very unlikely to accept it for operators or single-argument initializers.<br>&gt;&gt; <br>&gt;&gt; Independent of eliminating overloads, our model has been strongly trending toward &quot;labels are part of the name&quot;. It seems like a bug to me at this point that we consider declarations with different argument labels to be overloads in the type checker. Now that we&#39;ve banned tuple splatting, we should be able to enforce argument label matching much earlier in the type-checker pipeline, which should prune the overload set a lot for initializers and many Cocoa naming conventions.<br>&gt; <br>&gt; I completely agree, and the type-checker does now do this.<br></p><p>Nice. FWIW, your overload-hiding approach makes sense to me.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
