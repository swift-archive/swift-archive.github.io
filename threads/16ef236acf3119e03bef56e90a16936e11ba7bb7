<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>December 13, 2015 at 06:00:00am</p></header><div class="content"><p>Personally, I am agains generators (its quite specific syntactic sugar that adds a lot of complexity), but I would be all for a comprehensive coroutine library*. One can model it after Lua’s coroutines (http://www.lua.org/pil/9.1.html), which works well with the existing syntax. Your example becomes something like:<br></p><p>helloGenerator = Coroutine.create&lt;()-&gt;String&gt;({name:String -&gt; () in <br>   Coroutine.yield(“Hello”)<br>   Coroutine.yield(name ?? “World”)<br>})<br></p><p>this generates a class instance with a resume ()-&gt;String? method that can be used to retrieve the values. You can also pass values via resume (they will be then available as results of coroutine.yield)<br></p><p>One can than use helloGenerator.resume() to get the values (which can be easily wrapped in a sequence etc).<br></p><p>Benefits of this approach: no need for significant syntactic change (although a coroutine keyword could be introduced instead of func to wrap the above declaration), the coroutine functions are offloaded to a type rather than syntactic construct, type safety is quite easy to preserve. Still, its far from being a trivial thing to implement as it would require support of continuations on the compiler level. <br></p><p>Cheers, <br></p><p> Taras<br></p><p>*Yes, current generators in Python are essentially coroutines but I think it important to keep the terminology clean. Generators are intended first and foremost as lazy sequence, well, generators. Coroutines are a much more versatile construct. <br></p><p><br></p><p>On Fri, Dec 11, 2015 at 18:21 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/16ef7bb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 13, 2015 at 11:00:00am</p></header><div class="content"><p>Because stackful coroutines quickly start to quickly approximate threading, I didn’t think they were appropriate to propose at this time. That said:<br></p><p>I think you would probably want something like Coroutine.create&lt;String,()&gt; so that the String-&gt;() and ()-&gt;String interfaces of the two objects can be generated. Likewise, in your example I believe a Coroutine-related protocol instance should be passed in that exposes a yield(value:String) -&gt; () method <br></p><p>Coroutines and generator functions both involve additional rules for cleanup. Imagine a coroutine or generator which walks a file or network stream, returning individual lines of text. The code using .resume() may stop reading once they recognize the line they need or encounter an error, but the system still needs to be able to reclaim the coroutine as well as close/reclaim the local/network stream resources.<br></p><p>The references need to be set up in such a way that objects are reclaimed in a predictable order, and defer blocks would probably be supported and run, to make such control flow more obvious. This compiler support which would be required whether you were doing (sequence) generator functions or “full” coroutines. In the generator case, such cleanup needs to be moved to the teardown of your state objects. It is possible some of the cleanup for full coroutines would be shared with pre-existing thread termination support.<br></p><p>Finally - any calls to yield might never resume, and it is possible your code will transition between processors/parent threads on the subsequent resume. This pushes me toward promoting a keyword vs using Coroutine.yield, and restricting use of the yield keyword to make such behavior more obvious (in the same way throws must be declared and try must be used when calling an error-throwing method today)<br></p><p>-DW<br></p><p>&gt; On Dec 12, 2015, at 9:43 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, I am agains generators (its quite specific syntactic sugar that adds a lot of complexity), but I would be all for a comprehensive coroutine library*. One can model it after Lua’s coroutines (http://www.lua.org/pil/9.1.html &lt;http://www.lua.org/pil/9.1.html&gt;), which works well with the existing syntax. Your example becomes something like:<br>&gt; <br>&gt; helloGenerator = Coroutine.create&lt;()-&gt;String&gt;({name:String -&gt; () in <br>&gt;    Coroutine.yield(“Hello”)<br>&gt;    Coroutine.yield(name ?? “World”)<br>&gt; })<br>&gt; <br>&gt; this generates a class instance with a resume ()-&gt;String? method that can be used to retrieve the values. You can also pass values via resume (they will be then available as results of coroutine.yield)<br>&gt; <br>&gt; One can than use helloGenerator.resume() to get the values (which can be easily wrapped in a sequence etc).<br>&gt; <br>&gt; Benefits of this approach: no need for significant syntactic change (although a coroutine keyword could be introduced instead of func to wrap the above declaration), the coroutine functions are offloaded to a type rather than syntactic construct, type safety is quite easy to preserve. Still, its far from being a trivial thing to implement as it would require support of continuations on the compiler level. <br>&gt; <br>&gt; Cheers, <br>&gt; <br>&gt;  Taras<br>&gt; <br>&gt; *Yes, current generators in Python are essentially coroutines but I think it important to keep the terminology clean. Generators are intended first and foremost as lazy sequence, well, generators. Coroutines are a much more versatile construct. <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 18:21 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/bc363eeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>Proposal: Add generator functions to the language</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 13, 2015 at 06:00:00pm</p></header><div class="content"><p>A coroutine library can be implemented in terms of the generators in Swift<br>2. Coroutines are different from generators in that they can send<br>information back to the subordinate function. This can be done using<br>additional ivars in the generator struct.<br></p><p>In a compiled language, Generator.yield() cannot be a library function, it<br>must be a statement or expression, as each yield is an exit point of the<br>function.<br></p><p>- Alex<br></p><p><br>On Sun, Dec 13, 2015 at 6:13 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Because stackful coroutines quickly start to quickly approximate<br>&gt; threading, I didn’t think they were appropriate to propose at this time.<br>&gt; That said:<br>&gt;<br>&gt; I think you would probably want something like Coroutine.create&lt;String,()&gt;<br>&gt; so that the String-&gt;() and ()-&gt;String interfaces of the two objects can be<br>&gt; generated. Likewise, in your example I believe a Coroutine-related protocol<br>&gt; instance should be passed in that exposes a yield(value:String) -&gt; ()<br>&gt; method<br>&gt;<br>&gt; Coroutines and generator functions both involve additional rules for<br>&gt; cleanup. Imagine a coroutine or generator which walks a file or network<br>&gt; stream, returning individual lines of text. The code using .resume() may<br>&gt; stop reading once they recognize the line they need or encounter an error,<br>&gt; but the system still needs to be able to reclaim the coroutine as well as<br>&gt; close/reclaim the local/network stream resources.<br>&gt;<br>&gt; The references need to be set up in such a way that objects are reclaimed<br>&gt; in a predictable order, and defer blocks would probably be supported and<br>&gt; run, to make such control flow more obvious. This compiler support which<br>&gt; would be required whether you were doing (sequence) generator functions or<br>&gt; “full” coroutines. In the generator case, such cleanup needs to be moved to<br>&gt; the teardown of your state objects. It is possible some of the cleanup for<br>&gt; full coroutines would be shared with pre-existing thread termination<br>&gt; support.<br>&gt;<br>&gt; Finally - any calls to yield might never resume, and it is possible your<br>&gt; code will transition between processors/parent threads on the subsequent<br>&gt; resume. This pushes me toward promoting a keyword vs using Coroutine.yield,<br>&gt; and restricting use of the yield keyword to make such behavior more obvious<br>&gt; (in the same way throws must be declared and try must be used when calling<br>&gt; an error-throwing method today)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 12, 2015, at 9:43 PM, Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Personally, I am agains generators (its quite specific syntactic sugar<br>&gt; that adds a lot of complexity), but I would be all for a comprehensive<br>&gt; coroutine library*. One can model it after Lua’s coroutines (<br>&gt; http://www.lua.org/pil/9.1.html), which works well with the existing<br>&gt; syntax. Your example becomes something like:<br>&gt;<br>&gt; helloGenerator = Coroutine.create&lt;()-&gt;String&gt;({name:String -&gt; () in<br>&gt;    Coroutine.yield(“Hello”)<br>&gt;    Coroutine.yield(name ?? “World”)<br>&gt; })<br>&gt;<br>&gt; this generates a class instance with a resume ()-&gt;String? method that can<br>&gt; be used to retrieve the values. You can also pass values via resume (they<br>&gt; will be then available as results of coroutine.yield)<br>&gt;<br>&gt; One can than use helloGenerator.resume() to get the values (which can be<br>&gt; easily wrapped in a sequence etc).<br>&gt;<br>&gt; Benefits of this approach: no need for significant syntactic change<br>&gt; (although a coroutine keyword could be introduced instead of func to wrap<br>&gt; the above declaration), the coroutine functions are offloaded to a type<br>&gt; rather than syntactic construct, type safety is quite easy to preserve.<br>&gt; Still, its far from being a trivial thing to implement as it would require<br>&gt; support of continuations on the compiler level.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt;  Taras<br>&gt;<br>&gt; *Yes, current generators in Python are essentially coroutines but I think<br>&gt; it important to keep the terminology clean. Generators are intended first<br>&gt; and foremost as lazy sequence, well, generators. Coroutines are a much more<br>&gt; versatile construct.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 18:21 PM, David Waite via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Looking for feedback on crafting a proposal adding generator functions to Swift. I understand this will likely be a very involved proposal at the language level, although I actually don’t know the complexity of the change within the Swift compiler itself.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/bc979b99/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
