<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Design and performance of Vector2/3/4 and Matrix</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>I&#39;m working on a math library for OpenGL. At the core of this are, of<br>course, scalar types. The scalars are grouped into vectors of length 2, 3,<br>and 4. The vectors are used to build matrices of all variations from 2x2 to<br>4x4.<br></p><p>In order to be performant, scalars, vectors, and matrices must all be<br>values types aka structs. This way, for example, an Array&lt;Vector3&lt;Float&gt;&gt;<br>can be passed directly to OpenGL without any copying. In my testing so<br>far, Swift does this quite well.<br></p><p>Ideally, I&#39;d do something like this:<br></p><p>public struct Vector2&lt;T:ScalarType&gt; : Array&lt;T, 2&gt; {<br></p><p>    public var x:T { get {return self[0]} set {self[0] = newValue} }<br></p><p>    public var y:T { get {return self[1]} set {self[1] = newValue} }<br></p><p>}<br></p><p>But there&#39;s so much wrong with that. You can&#39;t use inheritance with<br>structs. Array isn&#39;t really a struct; the docs say it is but really it&#39;s a<br>reference to a special copy-on-write value type. Array can&#39;t be a fixed<br>size. You can&#39;t use literals with generic placeholders. Ok, fine, I accept<br>this isn&#39;t C++, let&#39;s move on to something Swifty.<br></p><p>public struct Vector2&lt;T:ScalarType&gt; {<br></p><p>    public var x:T, y:T<br></p><p><br>    public var r:T { get {return x} set {x = newValue} }<br></p><p>    public var g:T { get {return y} set {y = newValue} }<br></p><p><br>    public var s:T { get {return x} set {x = newValue} }<br></p><p>    public var t:T { get {return y} set {y = newValue} }<br></p><p><br>    public subscript(i: Int) -&gt; T {<br></p><p>        get {<br></p><p>            switch(i) {<br></p><p>            case 0: return x<br></p><p>            case 1: return y<br></p><p>            default: fatalError()<br></p><p>            }<br></p><p>        }<br></p><p>        set {<br></p><p>            switch(i) {<br></p><p>            case 0: x = newValue<br></p><p>            case 1: y = newValue<br></p><p>            default: fatalError()<br></p><p>            }<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p>Functionally, this works fine. The x and y properties are the struct data.<br>I can access vectors with subscripts, both coordinate properties, and<br>color properties  It&#39;s exactly what someone using an OpenGL vector type<br>would expect. You can make these into arrays, use them in other structs<br>which are made into arrays, and pass them to OpenGL just fine.<br></p><p>But I hit some performance issues. Let&#39;s use myvec.x as a baseline. This is<br>always inlined and as fast as C.<br></p><p>You might expect myvec.r to have the same performance. It does in other<br>languages but not Swift. The performance penalty is 20X. Yes, twenty times<br>slower than myvec.x. The performance hit comes entirely from dynamic<br>dispatch. 10X because it&#39;s not inlined, and another 10X because Vector2 is<br>a template.<br></p><p>I can get rid of 10X of that by writing my own preprocessor for the<br>template. There&#39;s only four scalar types that are valid for OpenGL so this<br>really isn&#39;t that hard. But it&#39;s not a complete solution and preprocessing<br>core languages features only to gain performance is an indication the<br>compiler isn&#39;t doing optimization as well as it could.<br></p><p>Subscript access is the same 20X slower for the same reasons. The switch<br>disappears into the noise. But I&#39;m still tempted to use a precondition and<br>cast to an UnsafePointer.<br></p><p>I&#39;m aware you can mark a class final and a method private to enable<br>inlining. Except this isn&#39;t a class and making the API private, well, it&#39;s<br>not an API then. Forcing @inline(__always) doesn&#39;t seem to do anything.<br></p><p>Perhaps I could just not make this a module and leave everything internal.<br>Supposedly it&#39;d be inlined when whole module optimization is enabled.<br>Except that doesn&#39;t happen.<br></p><p>How can I get these property aliases to be inlined? Is it possible today?<br>Will it be possible in the future? Is there a different pattern for vectors<br>that&#39;s better suited to the task?<br></p><p>-david (https://github.com/AE9RB/SwiftGL)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151218/f0a363e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Design and performance of Vector2/3/4 and Matrix</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>Do you have the optimizer enabled (using -O)? I see inlining happening as you&#39;d expect. This:<br></p><p>let x = Vector2(x: 1, y: 1)<br>foo(x.x)<br>foo(x.r)<br></p><p>optimizes down to:<br></p><p>  %15 = integer_literal $Builtin.Int64, 1         // user: %16<br>  %16 = struct $Int (%15 : $Builtin.Int64)        // users: %17, %17, %20, %21<br>  %17 = struct $Vector2&lt;Int&gt; (%16 : $Int, %16 : $Int) // user: %18<br>  // function_ref foo.foo (Swift.Int) -&gt; ()<br>  %19 = function_ref @_TF3foo3fooFSiT_ : $@convention(thin) (Int) -&gt; () // users: %20, %21<br>  %20 = apply %19(%16) : $@convention(thin) (Int) -&gt; ()<br>  %21 = apply %19(%16) : $@convention(thin) (Int) -&gt; ()<br></p><p>forwarding the constant 1 from the Vector2 constructor to foo as one would hope the optimizer would.<br></p><p>-Joe<br></p><p>&gt; On Dec 18, 2015, at 12:07 PM, David Turnbull via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m working on a math library for OpenGL. At the core of this are, of course, scalar types. The scalars are grouped into vectors of length 2, 3, and 4. The vectors are used to build matrices of all variations from 2x2 to 4x4.<br>&gt; <br>&gt; In order to be performant, scalars, vectors, and matrices must all be values types aka structs. This way, for example, an Array&lt;Vector3&lt;Float&gt;&gt; can be passed directly to OpenGL without any copying. In my testing so far, Swift does this quite well.<br>&gt; <br>&gt; Ideally, I&#39;d do something like this:<br>&gt; <br>&gt; public struct Vector2&lt;T:ScalarType&gt; : Array&lt;T, 2&gt; {<br>&gt;     public var x:T { get {return self[0]} set {self[0] = newValue} }<br>&gt;     public var y:T { get {return self[1]} set {self[1] = newValue} }<br>&gt; }<br>&gt; <br>&gt; But there&#39;s so much wrong with that. You can&#39;t use inheritance with structs. Array isn&#39;t really a struct; the docs say it is but really it&#39;s a reference to a special copy-on-write value type. Array can&#39;t be a fixed size. You can&#39;t use literals with generic placeholders. Ok, fine, I accept this isn&#39;t C++, let&#39;s move on to something Swifty.<br>&gt; <br>&gt; public struct Vector2&lt;T:ScalarType&gt; {<br>&gt;     public var x:T, y:T<br>&gt; <br>&gt;     public var r:T { get {return x} set {x = newValue} }<br>&gt;     public var g:T { get {return y} set {y = newValue} }<br>&gt; <br>&gt;     public var s:T { get {return x} set {x = newValue} }<br>&gt;     public var t:T { get {return y} set {y = newValue} }<br>&gt; <br>&gt;     public subscript(i: Int) -&gt; T {<br>&gt;         get {<br>&gt;             switch(i) {<br>&gt;             case 0: return x<br>&gt;             case 1: return y<br>&gt;             default: fatalError()<br>&gt;             }<br>&gt;         }<br>&gt;         set {<br>&gt;             switch(i) {<br>&gt;             case 0: x = newValue<br>&gt;             case 1: y = newValue<br>&gt;             default: fatalError()<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Functionally, this works fine. The x and y properties are the struct data. I can access vectors with subscripts, both coordinate properties, and color properties  It&#39;s exactly what someone using an OpenGL vector type would expect. You can make these into arrays, use them in other structs which are made into arrays, and pass them to OpenGL just fine.<br>&gt; <br>&gt; But I hit some performance issues. Let&#39;s use myvec.x as a baseline. This is always inlined and as fast as C.<br>&gt; <br>&gt; You might expect myvec.r to have the same performance. It does in other languages but not Swift. The performance penalty is 20X. Yes, twenty times slower than myvec.x. The performance hit comes entirely from dynamic dispatch. 10X because it&#39;s not inlined, and another 10X because Vector2 is a template.<br>&gt; <br>&gt; I can get rid of 10X of that by writing my own preprocessor for the template. There&#39;s only four scalar types that are valid for OpenGL so this really isn&#39;t that hard. But it&#39;s not a complete solution and preprocessing core languages features only to gain performance is an indication the compiler isn&#39;t doing optimization as well as it could.<br>&gt; <br>&gt; Subscript access is the same 20X slower for the same reasons. The switch disappears into the noise. But I&#39;m still tempted to use a precondition and cast to an UnsafePointer.<br>&gt; <br>&gt; I&#39;m aware you can mark a class final and a method private to enable inlining. Except this isn&#39;t a class and making the API private, well, it&#39;s not an API then. Forcing @inline(__always) doesn&#39;t seem to do anything.<br>&gt; <br>&gt; Perhaps I could just not make this a module and leave everything internal. Supposedly it&#39;d be inlined when whole module optimization is enabled. Except that doesn&#39;t happen.<br>&gt; <br>&gt; How can I get these property aliases to be inlined? Is it possible today? Will it be possible in the future? Is there a different pattern for vectors that&#39;s better suited to the task?<br>&gt; <br>&gt; -david (https://github.com/AE9RB/SwiftGL &lt;https://github.com/AE9RB/SwiftGL&gt;)<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151218/5a2dc6c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Design and performance of Vector2/3/4 and Matrix</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 18, 2015 at 11:00:00pm</p></header><div class="content"><p>You will also want to have this code in the same module that is using this type.<br></p><p>If you&#39;re using these types from another module you&#39;re limited to unspecialized generics which are (unsurprisingly) very slow.<br></p><p>I assume these types are intended for your SwiftGL library. If they are only for internal use then these generic types should be fine but if they should ultimately be public I would recommend you use non-generic types for now.<br></p><p>And since you probably need to drop generics anyway it might make sense to simply wrap the respective GLKit types on OS X and iOS for the GLFloat variants as they are already highly optimized. I have some wrappers for the GLKMatrix and GLKVector types lying around in my own OpenGL wrapper (incidentally also named SwiftGL ;-)) which might save you some typing if you&#39;re interested...<br></p><p>- Janosch<br></p><p><br>&gt; On 18 Dec 2015, at 22:36, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Do you have the optimizer enabled (using -O)? I see inlining happening as you&#39;d expect. This:<br>&gt; <br>&gt; let x = Vector2(x: 1, y: 1)<br>&gt; foo(x.x)<br>&gt; foo(x.r)<br>&gt; <br>&gt; optimizes down to:<br>&gt; <br>&gt;   %15 = integer_literal $Builtin.Int64, 1         // user: %16<br>&gt;   %16 = struct $Int (%15 : $Builtin.Int64)        // users: %17, %17, %20, %21<br>&gt;   %17 = struct $Vector2&lt;Int&gt; (%16 : $Int, %16 : $Int) // user: %18<br>&gt;   // function_ref foo.foo (Swift.Int) -&gt; ()<br>&gt;   %19 = function_ref @_TF3foo3fooFSiT_ : $@convention(thin) (Int) -&gt; () // users: %20, %21<br>&gt;   %20 = apply %19(%16) : $@convention(thin) (Int) -&gt; ()<br>&gt;   %21 = apply %19(%16) : $@convention(thin) (Int) -&gt; ()<br>&gt; <br>&gt; forwarding the constant 1 from the Vector2 constructor to foo as one would hope the optimizer would.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 12:07 PM, David Turnbull via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m working on a math library for OpenGL. At the core of this are, of course, scalar types. The scalars are grouped into vectors of length 2, 3, and 4. The vectors are used to build matrices of all variations from 2x2 to 4x4.<br>&gt;&gt; <br>&gt;&gt; In order to be performant, scalars, vectors, and matrices must all be values types aka structs. This way, for example, an Array&lt;Vector3&lt;Float&gt;&gt; can be passed directly to OpenGL without any copying. In my testing so far, Swift does this quite well.<br>&gt;&gt; <br>&gt;&gt; Ideally, I&#39;d do something like this:<br>&gt;&gt; <br>&gt;&gt; public struct Vector2&lt;T:ScalarType&gt; : Array&lt;T, 2&gt; {<br>&gt;&gt;     public var x:T { get {return self[0]} set {self[0] = newValue} }<br>&gt;&gt;     public var y:T { get {return self[1]} set {self[1] = newValue} }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; But there&#39;s so much wrong with that. You can&#39;t use inheritance with structs. Array isn&#39;t really a struct; the docs say it is but really it&#39;s a reference to a special copy-on-write value type. Array can&#39;t be a fixed size. You can&#39;t use literals with generic placeholders. Ok, fine, I accept this isn&#39;t C++, let&#39;s move on to something Swifty.<br>&gt;&gt; <br>&gt;&gt; public struct Vector2&lt;T:ScalarType&gt; {<br>&gt;&gt;     public var x:T, y:T<br>&gt;&gt; <br>&gt;&gt;     public var r:T { get {return x} set {x = newValue} }<br>&gt;&gt;     public var g:T { get {return y} set {y = newValue} }<br>&gt;&gt; <br>&gt;&gt;     public var s:T { get {return x} set {x = newValue} }<br>&gt;&gt;     public var t:T { get {return y} set {y = newValue} }<br>&gt;&gt; <br>&gt;&gt;     public subscript(i: Int) -&gt; T {<br>&gt;&gt;         get {<br>&gt;&gt;             switch(i) {<br>&gt;&gt;             case 0: return x<br>&gt;&gt;             case 1: return y<br>&gt;&gt;             default: fatalError()<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         set {<br>&gt;&gt;             switch(i) {<br>&gt;&gt;             case 0: x = newValue<br>&gt;&gt;             case 1: y = newValue<br>&gt;&gt;             default: fatalError()<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Functionally, this works fine. The x and y properties are the struct data. I can access vectors with subscripts, both coordinate properties, and color properties  It&#39;s exactly what someone using an OpenGL vector type would expect. You can make these into arrays, use them in other structs which are made into arrays, and pass them to OpenGL just fine.<br>&gt;&gt; <br>&gt;&gt; But I hit some performance issues. Let&#39;s use myvec.x as a baseline. This is always inlined and as fast as C.<br>&gt;&gt; <br>&gt;&gt; You might expect myvec.r to have the same performance. It does in other languages but not Swift. The performance penalty is 20X. Yes, twenty times slower than myvec.x. The performance hit comes entirely from dynamic dispatch. 10X because it&#39;s not inlined, and another 10X because Vector2 is a template.<br>&gt;&gt; <br>&gt;&gt; I can get rid of 10X of that by writing my own preprocessor for the template. There&#39;s only four scalar types that are valid for OpenGL so this really isn&#39;t that hard. But it&#39;s not a complete solution and preprocessing core languages features only to gain performance is an indication the compiler isn&#39;t doing optimization as well as it could.<br>&gt;&gt; <br>&gt;&gt; Subscript access is the same 20X slower for the same reasons. The switch disappears into the noise. But I&#39;m still tempted to use a precondition and cast to an UnsafePointer.<br>&gt;&gt; <br>&gt;&gt; I&#39;m aware you can mark a class final and a method private to enable inlining. Except this isn&#39;t a class and making the API private, well, it&#39;s not an API then. Forcing @inline(__always) doesn&#39;t seem to do anything.<br>&gt;&gt; <br>&gt;&gt; Perhaps I could just not make this a module and leave everything internal. Supposedly it&#39;d be inlined when whole module optimization is enabled. Except that doesn&#39;t happen.<br>&gt;&gt; <br>&gt;&gt; How can I get these property aliases to be inlined? Is it possible today? Will it be possible in the future? Is there a different pattern for vectors that&#39;s better suited to the task?<br>&gt;&gt; <br>&gt;&gt; -david (https://github.com/AE9RB/SwiftGL &lt;https://github.com/AE9RB/SwiftGL&gt;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151218/668dfc4d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Design and performance of Vector2/3/4 and Matrix</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 12:07 PM, David Turnbull via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; In order to be performant, scalars, vectors, and matrices must all be values types aka structs. This way, for example, an Array&lt;Vector3&lt;Float&gt;&gt; can be passed directly to OpenGL without any copying. In my testing so far, Swift does this quite well.<br></p><p>What about using tuples? You can name the elements of a tuple, and IIRC you can access them using subscripts too.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151218/c97563ce/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
