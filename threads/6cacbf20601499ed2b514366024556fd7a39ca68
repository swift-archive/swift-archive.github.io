<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here&#39;s one example:<br></p><p>let task = NSTask()<br>task.launchPath = &quot;/usr/bin/mdfind&quot;<br>task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>task.standardOutput = pipe<br></p><p>Here&#39;s another:<br></p><p>let questionLabel = UILabel()<br>questionLabel.textAlignment = .Center<br>questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>questionLabel.text = currentQuestion.questionText<br>questionLabel.numberOfLines = 0<br></p><p>You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>This code feels unnecessarily redundant <br>This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do. <br>The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br></p><p>PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br></p><p>let task = NSTask()&gt;&gt;{<br>    launchPath = &quot;/usr/bin/mdfind&quot;<br>    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>    standardOutput = pipe<br>}<br></p><p>In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br></p><p>ADVANTAGES AND DISADVANTAGES:<br></p><p>The advantages I see are as follows:<br>additional setup becomes integrated into initialization<br>code is streamlined, a general Swift ideal<br>the indented scope provides a visual emphasis of the single task being addressed<br>allows easier top-level initialization for global values, especially for Swift playgrounds.<br></p><p>The disadvantages I imagine would include:<br>the need for a new operator to disambiguate trailing closures from setup<br>compiler tweaking so `self`-references within the closure work without constant copies for value types<br></p><p>Thoughts?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/6cacca68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  4, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 1:24 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here&#39;s one example:<br>&gt; <br>&gt; let task = NSTask()<br>&gt; task.launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; task.standardOutput = pipe<br>&gt; <br>&gt; Here&#39;s another:<br>&gt; <br>&gt; let questionLabel = UILabel()<br>&gt; questionLabel.textAlignment = .Center<br>&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt; questionLabel.text = currentQuestion.questionText<br>&gt; questionLabel.numberOfLines = 0<br>&gt; <br>&gt; You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>&gt; This code feels unnecessarily redundant <br>&gt; This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do. <br>&gt; The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>&gt; Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br>&gt; <br>&gt; PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br>&gt; <br>&gt; let task = NSTask()&gt;&gt;{<br>&gt;     launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;     arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;     standardOutput = pipe<br>&gt; }<br>&gt; <br>&gt; In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br></p><p>In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39; for this:<br></p><p>let task = NSTask()<br>  ..launchPath = &quot;...&quot;<br>  ..arguments = [...]<br>  ..standardOutput = pipe<br></p><p>The nice thing about that is that it&#39;s a bit more generally applicable than just initialization.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/0ec325b3/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 3:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 1:24 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here&#39;s one example:<br>&gt;&gt; <br>&gt;&gt; let task = NSTask()<br>&gt;&gt; task.launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt; task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt; task.standardOutput = pipe<br>&gt;&gt; <br>&gt;&gt; Here&#39;s another:<br>&gt;&gt; <br>&gt;&gt; let questionLabel = UILabel()<br>&gt;&gt; questionLabel.textAlignment = .Center<br>&gt;&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;&gt; questionLabel.text = currentQuestion.questionText<br>&gt;&gt; questionLabel.numberOfLines = 0<br>&gt;&gt; <br>&gt;&gt; You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>&gt;&gt; This code feels unnecessarily redundant <br>&gt;&gt; This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do. <br>&gt;&gt; The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>&gt;&gt; Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br>&gt;&gt; <br>&gt;&gt; let task = NSTask()&gt;&gt;{<br>&gt;&gt;     launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;     arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;     standardOutput = pipe<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br>&gt; <br>&gt; In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39; for this:<br>&gt; <br>&gt; let task = NSTask()<br>&gt;   ..launchPath = &quot;...&quot;<br>&gt;   ..arguments = [...]<br>&gt;   ..standardOutput = pipe<br>&gt; <br>&gt; The nice thing about that is that it&#39;s a bit more generally applicable than just initialization.<br>&gt; <br>&gt; -Joe<br></p><p>I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br></p><p>with let task = NSTask() {<br>    launchPath = &quot;/usr/bin/mdfind&quot;<br>    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>    standardOutput = pipe<br>}<br></p><p>Also valid:<br></p><p>with someVariable {<br>    func1()<br>    func2(“etc&quot;)<br>}<br></p><p>Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>I really like both approaches, although I prefer the elegance of Sean&#39;s.<br></p><p>-- E<br></p><p><br>&gt; On Dec 4, 2015, at 2:35 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 3:27 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 1:24 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here&#39;s one example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let task = NSTask()<br>&gt;&gt;&gt; task.launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;&gt; task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;&gt; task.standardOutput = pipe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s another:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let questionLabel = UILabel()<br>&gt;&gt;&gt; questionLabel.textAlignment = .Center<br>&gt;&gt;&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;&gt;&gt; questionLabel.text = currentQuestion.questionText<br>&gt;&gt;&gt; questionLabel.numberOfLines = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>&gt;&gt;&gt; This code feels unnecessarily redundant <br>&gt;&gt;&gt; This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do. <br>&gt;&gt;&gt; The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>&gt;&gt;&gt; Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let task = NSTask()&gt;&gt;{<br>&gt;&gt;&gt;    launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;&gt;    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;&gt;    standardOutput = pipe<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br>&gt;&gt; <br>&gt;&gt; In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39; for this:<br>&gt;&gt; <br>&gt;&gt; let task = NSTask()<br>&gt;&gt;  ..launchPath = &quot;...&quot;<br>&gt;&gt;  ..arguments = [...]<br>&gt;&gt;  ..standardOutput = pipe<br>&gt;&gt; <br>&gt;&gt; The nice thing about that is that it&#39;s a bit more generally applicable than just initialization.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt; <br>&gt; with let task = NSTask() {<br>&gt;    launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;    standardOutput = pipe<br>&gt; }<br>&gt; <br>&gt; Also valid:<br>&gt; <br>&gt; with someVariable {<br>&gt;    func1()<br>&gt;    func2(“etc&quot;)<br>&gt; }<br>&gt; <br>&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; <br>&gt; l8r<br>&gt; Sean<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/40d78aea/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c638dc69b46afe03e3491dea47620cf4?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>crk at fastmail.com</string> &lt;crk at fastmail.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>Agreed, the<br>with variable {<br>statements<br>}<br>Format seems quite elegant and descriptive<br></p><p>Thanks for your time,<br>Cole Kurkowski<br></p><p>On Dec 4, 2015, 15:43 -0600, Erica Sadun&lt;erica at ericasadun.com&gt;, wrote:<br>&gt; I really like both approaches, although I prefer the elegance of Sean&#39;s.<br>&gt;  <br>&gt; -- E<br>&gt;  <br>&gt;  <br>&gt; &gt; On Dec 4, 2015, at 2:35 PM, Sean Heber&lt;sean at fifthace.com(mailto:sean at fifthace.com)&gt;wrote:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; On Dec 4, 2015, at 3:27 PM, Joe Groff&lt;jgroff at apple.com(mailto:jgroff at apple.com)&gt;wrote:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; On Dec 4, 2015, at 1:24 PM, Erica Sadun&lt;erica at ericasadun.com(mailto:erica at ericasadun.com)&lt;mailto:erica at ericasadun.com&gt;&gt;wrote:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.Here&#39;s one example:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; let task = NSTask()<br>&gt; &gt; &gt; &gt; task.launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt; &gt; &gt; task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt; &gt; &gt; task.standardOutput = pipe<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; Here&#39;s another:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; let questionLabel = UILabel()<br>&gt; &gt; &gt; &gt; questionLabel.textAlignment = .Center<br>&gt; &gt; &gt; &gt; questionLabel.font =UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt; &gt; &gt; &gt; questionLabel.text = currentQuestion.questionText<br>&gt; &gt; &gt; &gt; questionLabel.numberOfLines = 0<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>&gt; &gt; &gt; &gt; This code feels unnecessarily redundant<br>&gt; &gt; &gt; &gt; This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do.<br>&gt; &gt; &gt; &gt; The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>&gt; &gt; &gt; &gt; Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; PROPOSED SOLUTION: What do you think about creating setup closuresthat modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; let task = NSTask()&gt;&gt;{<br>&gt; &gt; &gt; &gt; launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt; &gt; &gt; arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt; &gt; &gt; standardOutput = pipe<br>&gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39; for this:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; let task = NSTask()<br>&gt; &gt; &gt; ..launchPath = &quot;...&quot;<br>&gt; &gt; &gt; ..arguments = [...]<br>&gt; &gt; &gt; ..standardOutput = pipe<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; The nice thing about that is that it&#39;s a bit more generally applicable than just initialization.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; -Joe<br>&gt; &gt;  <br>&gt; &gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt; &gt;  <br>&gt; &gt; with let task = NSTask() {<br>&gt; &gt; launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt; &gt; arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt; &gt; standardOutput = pipe<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; Also valid:<br>&gt; &gt;  <br>&gt; &gt; with someVariable {<br>&gt; &gt; func1()<br>&gt; &gt; func2(“etc&quot;)<br>&gt; &gt; }<br>&gt; &gt;  <br>&gt; &gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; &gt;  <br>&gt; &gt; l8r<br>&gt; &gt; Sean<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/563287e6/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; I would also be in favor of something more generally applicable rather than making initialization more special. <br></p><p>Initialization is inherently special - it is the only opportunity to provide an value for immutable stored properties.  IMO that means an adequate solution *must* at least consider initialization in depth and must be able to facilitate initializing immutable stored properties (which method cascade would not be able to do).<br></p><p>Matthew<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>Le 4 déc. 2015 à 16:35, Sean Heber &lt;sean at fifthace.com&gt; a écrit :<br></p><p>&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt; <br>&gt; with let task = NSTask() {<br>&gt;   launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;   arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;   standardOutput = pipe<br>&gt; }<br>&gt; <br>&gt; Also valid:<br>&gt; <br>&gt; with someVariable {<br>&gt;   func1()<br>&gt;   func2(“etc&quot;)<br>&gt; }<br>&gt; <br>&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br></p><p>The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:<br></p><p>	let launchPath = &quot;a.out&quot;<br>	let description = &quot;blah blah&quot;<br>	with let task = NSTask() {<br>		launchPath = launchPath // eh, what?<br>		arguments = [launchPath, description] // is that task.description?<br>	}<br></p><p>I think it&#39;s important that things referring to the &quot;task&quot; in the above example be syntactically distinguishable.<br></p><p>It can also lead to code breakage:<br></p><p>	let path = &quot;a.out&quot;<br>	with let task = NSTask() {<br>		launchPath = path<br>	}<br></p><p>That would work fine one day, but what if in the next OS release NSTask gets a new &quot;path&quot; property? That code breaks silently once you recompile with the newer SDK.<br>	<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December  4, 2015 at 02:00:00pm</p></header><div class="content"><p>I suspect this is an easy compiler catch requiring a forced self for disambiguation the same way as in init<br></p><p>-- E<br></p><p>&gt; On Dec 4, 2015, at 2:51 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 4 déc. 2015 à 16:35, Sean Heber &lt;sean at fifthace.com&gt; a écrit :<br>&gt; <br>&gt;&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt;&gt; <br>&gt;&gt; with let task = NSTask() {<br>&gt;&gt;  launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;  arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;  standardOutput = pipe<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Also valid:<br>&gt;&gt; <br>&gt;&gt; with someVariable {<br>&gt;&gt;  func1()<br>&gt;&gt;  func2(“etc&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; <br>&gt; The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:<br>&gt; <br>&gt; 	let launchPath = &quot;a.out&quot;<br>&gt; 	let description = &quot;blah blah&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = launchPath // eh, what?<br>&gt; 		arguments = [launchPath, description] // is that task.description?<br>&gt; 	}<br>&gt; <br>&gt; I think it&#39;s important that things referring to the &quot;task&quot; in the above example be syntactically distinguishable.<br>&gt; <br>&gt; It can also lead to code breakage:<br>&gt; <br>&gt; 	let path = &quot;a.out&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = path<br>&gt; 	}<br>&gt; <br>&gt; That would work fine one day, but what if in the next OS release NSTask gets a new &quot;path&quot; property? That code breaks silently once you recompile with the newer SDK.<br>&gt; 	<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>Yeah, that thought occurred to me as I was writing it out. One possibility would be to limit what can go inside that block - perhaps all statements must be functions called on the value you are using in the with block? Or perhaps simply prefix them with a period? (Maybe looks too much like enum?)<br></p><p>with let task = NSTask() {<br> .launchPath = path<br> .arguments = []<br> .standardOutput = pipe<br>}<br></p><p>etc. <br></p><p>l8r<br>Sean<br></p><p>&gt; On Dec 4, 2015, at 3:51 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 4 déc. 2015 à 16:35, Sean Heber &lt;sean at fifthace.com&gt; a écrit :<br>&gt; <br>&gt;&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt;&gt; <br>&gt;&gt; with let task = NSTask() {<br>&gt;&gt;  launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;  arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;  standardOutput = pipe<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Also valid:<br>&gt;&gt; <br>&gt;&gt; with someVariable {<br>&gt;&gt;  func1()<br>&gt;&gt;  func2(“etc&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; <br>&gt; The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:<br>&gt; <br>&gt; 	let launchPath = &quot;a.out&quot;<br>&gt; 	let description = &quot;blah blah&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = launchPath // eh, what?<br>&gt; 		arguments = [launchPath, description] // is that task.description?<br>&gt; 	}<br>&gt; <br>&gt; I think it&#39;s important that things referring to the &quot;task&quot; in the above example be syntactically distinguishable.<br>&gt; <br>&gt; It can also lead to code breakage:<br>&gt; <br>&gt; 	let path = &quot;a.out&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = path<br>&gt; 	}<br>&gt; <br>&gt; That would work fine one day, but what if in the next OS release NSTask gets a new &quot;path&quot; property? That code breaks silently once you recompile with the newer SDK.<br>&gt; 	<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>This seems related to my proposal to be able to bind self to a closure parameter.<br></p><p>Instead of:<br></p><p>	with let task = NSTask() {…} <br></p><p>you could just make ‘with&#39; a standard function:<br></p><p>	func with&lt;T&gt;(argument:T, apply:(T) throws-&gt;()) rethrows -&gt; T {<br> 		try apply(argument)<br>		return argument<br>	}<br></p><p>	let task =  with(NSTask()) {<br>		$0.launchPath = …<br>	}<br></p><p>Then, with my proposal:<br></p><p>	let task =  with(NSTask()) {<br>		self in<br>		launchPath = …<br>		arguments = …<br>		standardOutput = ...<br>	}<br></p><p>-DW<br></p><p>&gt; On Dec 4, 2015, at 2:51 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 4 déc. 2015 à 16:35, Sean Heber &lt;sean at fifthace.com&gt; a écrit :<br>&gt; <br>&gt;&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt;&gt; <br>&gt;&gt; with let task = NSTask() {<br>&gt;&gt;  launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;  arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;  standardOutput = pipe<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Also valid:<br>&gt;&gt; <br>&gt;&gt; with someVariable {<br>&gt;&gt;  func1()<br>&gt;&gt;  func2(“etc&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; <br>&gt; The problem with this approach is that it can become ambiguous with the outer scope pretty easily, if not to the compiler at least for the reader:<br>&gt; <br>&gt; 	let launchPath = &quot;a.out&quot;<br>&gt; 	let description = &quot;blah blah&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = launchPath // eh, what?<br>&gt; 		arguments = [launchPath, description] // is that task.description?<br>&gt; 	}<br>&gt; <br>&gt; I think it&#39;s important that things referring to the &quot;task&quot; in the above example be syntactically distinguishable.<br>&gt; <br>&gt; It can also lead to code breakage:<br>&gt; <br>&gt; 	let path = &quot;a.out&quot;<br>&gt; 	with let task = NSTask() {<br>&gt; 		launchPath = path<br>&gt; 	}<br>&gt; <br>&gt; That would work fine one day, but what if in the next OS release NSTask gets a new &quot;path&quot; property? That code breaks silently once you recompile with the newer SDK.<br>&gt; 	<br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca<br>&gt; https://michelf.ca<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ca09ab1a2a3d0d17f2c27198bf2e146e?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Gaelan Bright Steele</string> &lt;gbs at canishe.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>JavaScript had a `with` operator for a while, but it was deprecated due to some edge cases, specifically something like this:<br></p><p>    // Codebase 1 (a library)<br>    class A {}<br>    internal func foo() {<br>        print(&quot;correct result&quot;)<br>    }<br>    func doSomethingWithA(a: A) {<br>        with a {<br>            /* do something with A */<br>            foo()<br>            /* do something else with A */<br>        }<br>    }<br>    // Codebase 2 (Application code depending on CB1)<br>    class B: A {<br>        // presumably written without knowledge of the global foo<br>        func foo() {<br>            print(&quot;completely different result”)<br>        }<br>    }<br>    doSomethingWithA(B()) //What happens here? Does the foo() call the global foo or B’s foo?<br></p><p>I think that in a static programming language we could avoid this problem by having the `with` operator use the knowledge of the type it is passed at compile-time (ignoring the runtime type). Still, we need to be careful about edge cases here.<br>&gt; On Dec 4, 2015, at 1:35 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 4, 2015, at 3:27 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 4, 2015, at 1:24 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROBLEM: With many Apple-supplied classes, typical initializers fail to fully set up an instance for use.  Here&#39;s one example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let task = NSTask()<br>&gt;&gt;&gt; task.launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;&gt; task.arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;&gt; task.standardOutput = pipe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s another:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let questionLabel = UILabel()<br>&gt;&gt;&gt; questionLabel.textAlignment = .Center<br>&gt;&gt;&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;&gt;&gt; questionLabel.text = currentQuestion.questionText<br>&gt;&gt;&gt; questionLabel.numberOfLines = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You end up with stodgy repetitive code that turns into a blocky hard-to-follow clump. Here are some of my complaints:<br>&gt;&gt;&gt; This code feels unnecessarily redundant <br>&gt;&gt;&gt; This code visually stacks. The task/task/task and questionLabel/questionLabel/questionLabel blocks draw attention away from the actual set-up these lines of code are intended to do. <br>&gt;&gt;&gt; The extra symbol verbiage goes against common Swift style. For example, when the context is clear, prefer .whitespaceAndNewlineCharacterSet to NSCharacterSet.whitespaceAndNewlineCharacterSet.<br>&gt;&gt;&gt; Further, if you have many instances to set up there&#39;s no clear way to differentiate unrelated set-up groups other than inserting whitespace gaps or building custom factory functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION: What do you think about creating setup closures  that modify initializers and automatically introduce self-references. For example the NSTask() initialization might look something like this instead:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let task = NSTask()&gt;&gt;{<br>&gt;&gt;&gt;    launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;&gt;&gt;    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;&gt;&gt;    standardOutput = pipe<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example, the braces are scoped to the instance as self, enabling the properties to entirely drop their prefixes and be grouped together for set-up.<br>&gt;&gt; <br>&gt;&gt; In Smalltalk and Dart, you can do this with method cascades, which apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39; for this:<br>&gt;&gt; <br>&gt;&gt; let task = NSTask()<br>&gt;&gt;  ..launchPath = &quot;...&quot;<br>&gt;&gt;  ..arguments = [...]<br>&gt;&gt;  ..standardOutput = pipe<br>&gt;&gt; <br>&gt;&gt; The nice thing about that is that it&#39;s a bit more generally applicable than just initialization.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; I would also be in favor of something more generally applicable rather than making initialization more special. I think I prefer the block-style over Dart’s approach. Smalltalk uses semicolons for this, if I recall. I’m not sure I like using a special operator. I’m obviously a keyword guy.. :P<br>&gt; <br>&gt; with let task = NSTask() {<br>&gt;    launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;    arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;    standardOutput = pipe<br>&gt; }<br>&gt; <br>&gt; Also valid:<br>&gt; <br>&gt; with someVariable {<br>&gt;    func1()<br>&gt;    func2(“etc&quot;)<br>&gt; }<br>&gt; <br>&gt; Which would call func1() and func2() on the someVariable instance (which I think would be quite expected).<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/4e8c8b21/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;d be in favor of a solution like the &#39;..&#39; operator. Using a block-<br>based syntax for this seems like it&#39;s already close enough to defining<br>something like<br></p><p>func with&lt;T&gt;(x: T, @noescape _ f: inout T -&gt; Void) -&gt; T {    var value =<br>x    f(&amp;value)    return value }<br></p><p>that it would be better to just go with the function instead of<br>complicating the Swift syntax. But the &#39;..&#39; operator has some nice<br>properties, such as being able to say something like<br></p><p>someLayoutConstraint =<br>label.leftAnchor.constraintEqualToAnchor(view.leftAnchor)..active = true<br></p><p>(I&#39;m assuming here that &#39;..&#39; works by returning the receiver as the<br>value of the subsequent expression, rather than merely allowing several<br>&#39;..&#39; operators to be chained together, but I&#39;m not actually familiar<br>with how this works in Smalltalk and Dart)<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 01:27 PM, Joe Groff wrote:<br>&gt; In Smalltalk and Dart, you can do this with method cascades, which<br>&gt; apply multiple methods to the same &#39;self&#39;. In Dart they use &#39;..&#39;<br>&gt; for this:<br>&gt;<br>&gt; let task = NSTask()  ..launchPath = &quot;...&quot;  ..arguments = [...]<br>&gt; ..standardOutput = pipe<br>&gt;<br>&gt; The nice thing about that is that it&#39;s a bit more generally applicable<br>&gt; than just initialization.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/64b7101e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Request for Discussion: Setup closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>let task = NSTask()&gt;&gt;{<br>&gt;     launchPath = &quot;/usr/bin/mdfind&quot;<br>&gt;     arguments = [&quot;kMDItemDisplayName == *.playground&quot;]<br>&gt;     standardOutput = pipe<br>&gt; }<br>&gt; <br></p><p>I think something like this would be extremely useful, however I think the proposal as it is written is a bit more limited than I would like to see as it only applies to mutable properties.  <br></p><p>I don&#39;t have a concrete idea of exactly what I would prefer, but it would take the form of a general solution that would allow an initializer to accept initial values for some or all public stored properties from the caller.  The simplest case might look a lot like the compiler generated memberwise initializer for structs.  Slightly more complex cases might allow the caller to omit some properties if a default is specified by the type or by the initializer.  Going a step further, some initializers for a type may need to initialize some of the stored priorities directly and thus not allow those specific properties to be specified by the caller.<br></p><p>The goal is to allow flexible initialization for callers without sacrificing immutability and without requiring a ton of initializer overloads.<br></p><p>If others like this basic idea I will try to make it more concrete and write a proposal.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/abc958ae/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
