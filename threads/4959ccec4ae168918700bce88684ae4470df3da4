<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9c8c0c9d778a20862fa37ea108e9465b?s=50"></div><header><strong>[Pitch] make == more restrictive at compile time</strong> from <string>Gerd Castan</string> &lt;Gerd at GerdCastan.de&gt;<p>May  5, 2016 at 11:00:00am</p></header><div class="content"><p>Motivation:<br></p><p>The following code emits no compiler error in Swift 2.2:<br></p><p>import Foundation<br>func EQTest(lhs: NSArray, rhs: String) -&gt; Bool {<br>    return (lhs == rhs)<br>}<br></p><p><br>I can imagine no use case where this code example makes sense, so I<br>would expect an error at compile time.<br></p><p>the function that makes this code valid is<br>@warn_unused_result<br>public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br></p><p><br>Proposal:<br></p><p>find a way for the compiler to emit an error for the code example.<br></p><p><br>Discussion:<br></p><p>I can think of several ways to solve this:<br></p><p>1. remove &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; from<br>the library<br>2. annotate &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; so<br>that the compiler emits an error in the cate that there is no more<br>specific implementation.<br></p><p>I leave the way to implement this to a discussion since I&#39;m not sure<br>which one (or some completely different approach) will lead to a<br>consistent language design.<br></p><p>I have the feeling that approach 2 is easier, better and gives more<br>control since it moves the responsibility for the error handling from<br>the compiler to the library where everybody (including the compiler) can<br>read it.<br></p><p>There might be more functions like &quot;public func ==&lt;T : Equatable&gt;(lhs:<br>T?, rhs: T?) -&gt; Bool&quot; that lets the compiler accept nonsense tests for<br>equality for more specific cases. They should be handled in a similar<br>and consistent way if they exist.<br></p><p>This change is intended to let programers getting things done faster and<br>with less coding errors in Swift.<br></p><p><br>Gerd<br>https://github.com/GerdC<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Pitch] make == more restrictive at compile time</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>May  5, 2016 at 05:00:00am</p></header><div class="content"><p>Even if that were removed &quot;heterogenous&quot; equality checks are valid under the remaining typing rules because both objects are Equatable and descend from NSObject meaning Swift will upcast, invoke this &quot;nonsense&quot;, and make the comparison anyway. You can verify this by reimplementing vanilla == and invoking the comparison you give in the pitch. <br></p><p>I think you want a way of controlling (in this case, turning off) subtyping with variance annotations.<br></p><p>~Robert Widmann<br></p><p>2016/05/05 5:24、Gerd Castan via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; Motivation:<br>&gt; <br>&gt; The following code emits no compiler error in Swift 2.2:<br>&gt; <br>&gt; import Foundation<br>&gt; func EQTest(lhs: NSArray, rhs: String) -&gt; Bool {<br>&gt;    return (lhs == rhs)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I can imagine no use case where this code example makes sense, so I<br>&gt; would expect an error at compile time.<br>&gt; <br>&gt; the function that makes this code valid is<br>&gt; @warn_unused_result<br>&gt; public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; find a way for the compiler to emit an error for the code example.<br>&gt; <br>&gt; <br>&gt; Discussion:<br>&gt; <br>&gt; I can think of several ways to solve this:<br>&gt; <br>&gt; 1. remove &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; from<br>&gt; the library<br>&gt; 2. annotate &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; so<br>&gt; that the compiler emits an error in the cate that there is no more<br>&gt; specific implementation.<br>&gt; <br>&gt; I leave the way to implement this to a discussion since I&#39;m not sure<br>&gt; which one (or some completely different approach) will lead to a<br>&gt; consistent language design.<br>&gt; <br>&gt; I have the feeling that approach 2 is easier, better and gives more<br>&gt; control since it moves the responsibility for the error handling from<br>&gt; the compiler to the library where everybody (including the compiler) can<br>&gt; read it.<br>&gt; <br>&gt; There might be more functions like &quot;public func ==&lt;T : Equatable&gt;(lhs:<br>&gt; T?, rhs: T?) -&gt; Bool&quot; that lets the compiler accept nonsense tests for<br>&gt; equality for more specific cases. They should be handled in a similar<br>&gt; and consistent way if they exist.<br>&gt; <br>&gt; This change is intended to let programers getting things done faster and<br>&gt; with less coding errors in Swift.<br>&gt; <br>&gt; <br>&gt; Gerd<br>&gt; https://github.com/GerdC<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] make == more restrictive at compile time</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  5, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 5, 2016, at 2:24 AM, Gerd Castan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Motivation:<br>&gt; <br>&gt; The following code emits no compiler error in Swift 2.2:<br>&gt; <br>&gt; import Foundation<br>&gt; func EQTest(lhs: NSArray, rhs: String) -&gt; Bool {<br>&gt;    return (lhs == rhs)<br>&gt; }<br></p><p>This works because String can implicitly bridge to NSString, and both NSArray and NSString are subclasses of NSObject. SE-0072 proposes to remove the implicit bridging behavior, which would prevent this from compiling.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; <br>&gt; I can imagine no use case where this code example makes sense, so I<br>&gt; would expect an error at compile time.<br>&gt; <br>&gt; the function that makes this code valid is<br>&gt; @warn_unused_result<br>&gt; public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; find a way for the compiler to emit an error for the code example.<br>&gt; <br>&gt; <br>&gt; Discussion:<br>&gt; <br>&gt; I can think of several ways to solve this:<br>&gt; <br>&gt; 1. remove &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; from<br>&gt; the library<br>&gt; 2. annotate &quot;public func ==&lt;T : Equatable&gt;(lhs: T?, rhs: T?) -&gt; Bool&quot; so<br>&gt; that the compiler emits an error in the cate that there is no more<br>&gt; specific implementation.<br>&gt; <br>&gt; I leave the way to implement this to a discussion since I&#39;m not sure<br>&gt; which one (or some completely different approach) will lead to a<br>&gt; consistent language design.<br>&gt; <br>&gt; I have the feeling that approach 2 is easier, better and gives more<br>&gt; control since it moves the responsibility for the error handling from<br>&gt; the compiler to the library where everybody (including the compiler) can<br>&gt; read it.<br>&gt; <br>&gt; There might be more functions like &quot;public func ==&lt;T : Equatable&gt;(lhs:<br>&gt; T?, rhs: T?) -&gt; Bool&quot; that lets the compiler accept nonsense tests for<br>&gt; equality for more specific cases. They should be handled in a similar<br>&gt; and consistent way if they exist.<br>&gt; <br>&gt; This change is intended to let programers getting things done faster and<br>&gt; with less coding errors in Swift.<br>&gt; <br>&gt; <br>&gt; Gerd<br>&gt; https://github.com/GerdC<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
