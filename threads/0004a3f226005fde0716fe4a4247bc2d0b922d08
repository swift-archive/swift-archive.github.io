<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Giving functions default return values</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July 13, 2016 at 04:00:00pm</p></header><div class="content"><p>This idea is purely additive and isn’t to be considered for Swift 3.<br></p><p>Oftentimes a function has a very obvious default argument to fall back on. If the return value is optional, this is generally nil. If the return value is Bool, it’s probably `false`. Often this fallback value is returned at the end of the function, just to return something if nothing has been returned yet. For instance, consider this TreeNode class:<br></p><p>class TreeNode&lt;Element&gt; {<br>    <br>    var value: Element<br>    var children: [TreeNode]<br>    <br>    init(value: Element) {<br>        self.value = value<br>        children = []<br>    }<br>    <br>    func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool {<br>        if try predicate(value) {<br>            return true<br>        }<br>        <br>        for child in children {<br>            if try child.contains(predicate) {<br>                return true<br>            }<br>        }<br>        <br>        return false // 1<br>    }<br>    <br>    func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? {<br>        if try predicate(value) {<br>            return value<br>        }<br>        <br>        for child in children {<br>            if let result = try child.first(where: predicate) {<br>                return result<br>            }<br>        }<br>        <br>        return nil // 2<br>    }<br>    <br>    var leftMostDescendant: TreeNode? {<br>        if let child = children.first {<br>            return child.leftMostDescendant ?? child<br>        }<br></p><p>        return nil // 3<br>    }<br>    <br>}<br></p><p>These code patterns are quite usual. If we could give default return values to functions, we could get rid of the final `return` statements:<br></p><p>func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool = false {<br>    if try predicate(value) {<br>        return true<br>    }<br>    <br>    for child in children {<br>        if try child.contains(predicate) {<br>            return true<br>        }<br>    }<br>}<br></p><p>func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? = nil {<br>    if try predicate(value) {<br>        return value<br>    }<br>    <br>    for child in children {<br>        if let result = try child.first(where: predicate) {<br>            return result<br>        }<br>    }<br>}<br></p><p>var leftMostDescendant: TreeNode? = nil {<br>    if let child = children.first {<br>        return child.leftMostDescendant ?? child<br>    }<br>}<br></p><p>The default return value shouldn’t be part of the function signature (i.e. it shouldn’t appear in interface files) because it’s an implementation detail, but right after the return type is probably the most natural place to put it (similar to default function parameters).<br></p><p>Let me know what you think.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/00042d08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Giving functions default return values</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Tim,<br></p><p>the core team asked us to defer any discussion on post-Swift-3 related proposals.<br></p><p>That said, there have been several discussion around this topic (in the past few months) and I believe the general attitude towards them was negative, due to it leading to statements such as <br></p><p>guard &lt;condition&gt; else { }<br></p><p>which<br></p><p>a) doesn&#39;t express what will happen when the condition is not met, making the code hard to read<br></p><p>b) can lead to bugs in code since the compiler makes sure that the flow doesn&#39;t continue beyond the guard statement and with default returns, this would compiler without a warning or an error:<br></p><p>for obj in array {<br>	guard obj.meetsConditions() else {<br>		// Implicit return - most likely not intentional,<br>		// you most likely want &quot;continue&quot; in here<br>	}<br></p><p>	// ...<br>}<br></p><p><br>&gt; On Jul 13, 2016, at 4:57 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This idea is purely additive and isn’t to be considered for Swift 3.<br>&gt; <br>&gt; Oftentimes a function has a very obvious default argument to fall back on. If the return value is optional, this is generally nil. If the return value is Bool, it’s probably `false`. Often this fallback value is returned at the end of the function, just to return something if nothing has been returned yet. For instance, consider this TreeNode class:<br>&gt; <br>&gt; class TreeNode&lt;Element&gt; {<br>&gt;     <br>&gt;     var value: Element<br>&gt;     var children: [TreeNode]<br>&gt;     <br>&gt;     init(value: Element) {<br>&gt;         self.value = value<br>&gt;         children = []<br>&gt;     }<br>&gt;     <br>&gt;     func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool {<br>&gt;         if try predicate(value) {<br>&gt;             return true<br>&gt;         }<br>&gt;         <br>&gt;         for child in children {<br>&gt;             if try child.contains(predicate) {<br>&gt;                 return true<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         return false // 1<br>&gt;     }<br>&gt;     <br>&gt;     func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? {<br>&gt;         if try predicate(value) {<br>&gt;             return value<br>&gt;         }<br>&gt;         <br>&gt;         for child in children {<br>&gt;             if let result = try child.first(where: predicate) {<br>&gt;                 return result<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         return nil // 2<br>&gt;     }<br>&gt;     <br>&gt;     var leftMostDescendant: TreeNode? {<br>&gt;         if let child = children.first {<br>&gt;             return child.leftMostDescendant ?? child<br>&gt;         }<br>&gt; <br>&gt;         return nil // 3<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; These code patterns are quite usual. If we could give default return values to functions, we could get rid of the final `return` statements:<br>&gt; <br>&gt; func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool = false {<br>&gt;     if try predicate(value) {<br>&gt;         return true<br>&gt;     }<br>&gt;     <br>&gt;     for child in children {<br>&gt;         if try child.contains(predicate) {<br>&gt;             return true<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? = nil {<br>&gt;     if try predicate(value) {<br>&gt;         return value<br>&gt;     }<br>&gt;     <br>&gt;     for child in children {<br>&gt;         if let result = try child.first(where: predicate) {<br>&gt;             return result<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; var leftMostDescendant: TreeNode? = nil {<br>&gt;     if let child = children.first {<br>&gt;         return child.leftMostDescendant ?? child<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The default return value shouldn’t be part of the function signature (i.e. it shouldn’t appear in interface files) because it’s an implementation detail, but right after the return type is probably the most natural place to put it (similar to default function parameters).<br>&gt; <br>&gt; Let me know what you think.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/fd505e0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Giving functions default return values</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>July 13, 2016 at 08:00:00pm</p></header><div class="content"><p>I thought that was mainly about former proposals in the Github repo, but I’ll gladly bring this up again at a more appropriate time.<br></p><p>To address your message: I wouldn’t really want guard &lt;condition&gt; else { } to be valid code. The default return value is simply returned if the end of the function body is reached and nothing has been returned yet. guard &lt;condition&gt; else { return } could possibly be allowed in case of a default return value, but definitely not an empty guard body. This wouldn’t cause any problems, would it?<br></p><p>&gt; On 13 Jul 2016, at 17:47, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Hi Tim,<br>&gt; <br>&gt; the core team asked us to defer any discussion on post-Swift-3 related proposals.<br>&gt; <br>&gt; That said, there have been several discussion around this topic (in the past few months) and I believe the general attitude towards them was negative, due to it leading to statements such as <br>&gt; <br>&gt; guard &lt;condition&gt; else { }<br>&gt; <br>&gt; which<br>&gt; <br>&gt; a) doesn&#39;t express what will happen when the condition is not met, making the code hard to read<br>&gt; <br>&gt; b) can lead to bugs in code since the compiler makes sure that the flow doesn&#39;t continue beyond the guard statement and with default returns, this would compiler without a warning or an error:<br>&gt; <br>&gt; for obj in array {<br>&gt; 	guard obj.meetsConditions() else {<br>&gt; 		// Implicit return - most likely not intentional,<br>&gt; 		// you most likely want &quot;continue&quot; in here<br>&gt; 	}<br>&gt; <br>&gt; 	// ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 13, 2016, at 4:57 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This idea is purely additive and isn’t to be considered for Swift 3.<br>&gt;&gt; <br>&gt;&gt; Oftentimes a function has a very obvious default argument to fall back on. If the return value is optional, this is generally nil. If the return value is Bool, it’s probably `false`. Often this fallback value is returned at the end of the function, just to return something if nothing has been returned yet. For instance, consider this TreeNode class:<br>&gt;&gt; <br>&gt;&gt; class TreeNode&lt;Element&gt; {<br>&gt;&gt;     <br>&gt;&gt;     var value: Element<br>&gt;&gt;     var children: [TreeNode]<br>&gt;&gt;     <br>&gt;&gt;     init(value: Element) {<br>&gt;&gt;         self.value = value<br>&gt;&gt;         children = []<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool {<br>&gt;&gt;         if try predicate(value) {<br>&gt;&gt;             return true<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         for child in children {<br>&gt;&gt;             if try child.contains(predicate) {<br>&gt;&gt;                 return true<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         return false // 1<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? {<br>&gt;&gt;         if try predicate(value) {<br>&gt;&gt;             return value<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         for child in children {<br>&gt;&gt;             if let result = try child.first(where: predicate) {<br>&gt;&gt;                 return result<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         return nil // 2<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var leftMostDescendant: TreeNode? {<br>&gt;&gt;         if let child = children.first {<br>&gt;&gt;             return child.leftMostDescendant ?? child<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         return nil // 3<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; These code patterns are quite usual. If we could give default return values to functions, we could get rid of the final `return` statements:<br>&gt;&gt; <br>&gt;&gt; func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool = false {<br>&gt;&gt;     if try predicate(value) {<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     for child in children {<br>&gt;&gt;         if try child.contains(predicate) {<br>&gt;&gt;             return true<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element? = nil {<br>&gt;&gt;     if try predicate(value) {<br>&gt;&gt;         return value<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     for child in children {<br>&gt;&gt;         if let result = try child.first(where: predicate) {<br>&gt;&gt;             return result<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var leftMostDescendant: TreeNode? = nil {<br>&gt;&gt;     if let child = children.first {<br>&gt;&gt;         return child.leftMostDescendant ?? child<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The default return value shouldn’t be part of the function signature (i.e. it shouldn’t appear in interface files) because it’s an implementation detail, but right after the return type is probably the most natural place to put it (similar to default function parameters).<br>&gt;&gt; <br>&gt;&gt; Let me know what you think.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/6bc6c337/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Giving functions default return values</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 13, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Jul 13, 2016 at 1:14 PM, Tim Vermeulen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I thought that was mainly about former proposals in the Github repo, but<br>&gt; I’ll gladly bring this up again at a more appropriate time.<br>&gt;<br>&gt; To address your message: I wouldn’t really want guard &lt;condition&gt; else { }<br>&gt; to be valid code. The default return value is simply returned if the end of<br>&gt; the function body is reached and nothing has been returned yet. guard<br>&gt; &lt;condition&gt; else { return } could possibly be allowed in case of a default<br>&gt; return value, but definitely not an empty guard body. This wouldn’t cause<br>&gt; any problems, would it?<br>&gt;<br></p><p>This specific idea you&#39;re proposing has been brought up on the list<br>previously, I think maybe twice. Visual Basic was mentioned previously, in<br>case that would help you search through list archives. It has not been<br>previously received well, but if after looking through the archives you<br>feel it&#39;s still relevant to discuss, I&#39;d also mention that post-Swift 3<br>would be more appropriate.<br></p><p><br>&gt; On 13 Jul 2016, at 17:47, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hi Tim,<br>&gt;<br>&gt; the core team asked us to defer any discussion on post-Swift-3 related<br>&gt; proposals.<br>&gt;<br>&gt; That said, there have been several discussion around this topic (in the<br>&gt; past few months) and I believe the general attitude towards them was<br>&gt; negative, due to it leading to statements such as<br>&gt;<br>&gt; guard &lt;condition&gt; else { }<br>&gt;<br>&gt; which<br>&gt;<br>&gt; a) doesn&#39;t express what will happen when the condition is not met, making<br>&gt; the code hard to read<br>&gt;<br>&gt; b) can lead to bugs in code since the compiler makes sure that the flow<br>&gt; doesn&#39;t continue beyond the guard statement and with default returns, this<br>&gt; would compiler without a warning or an error:<br>&gt;<br>&gt; for obj in array {<br>&gt; guard obj.meetsConditions() else {<br>&gt; // Implicit return - most likely not intentional,<br>&gt; // you most likely want &quot;continue&quot; in here<br>&gt; }<br>&gt;<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; On Jul 13, 2016, at 4:57 PM, Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This idea is purely additive and isn’t to be considered for Swift 3.<br>&gt;<br>&gt; Oftentimes a function has a very obvious default argument to fall back on.<br>&gt; If the return value is optional, this is generally nil. If the return value<br>&gt; is Bool, it’s probably `false`. Often this fallback value is returned at<br>&gt; the end of the function, just to return something if nothing has been<br>&gt; returned yet. For instance, consider this TreeNode class:<br>&gt;<br>&gt; class TreeNode&lt;Element&gt; {<br>&gt;<br>&gt;     var value: Element<br>&gt;     var children: [TreeNode]<br>&gt;<br>&gt;     init(value: Element) {<br>&gt;         self.value = value<br>&gt;         children = []<br>&gt;     }<br>&gt;<br>&gt;     func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt; {<br>&gt;         if try predicate(value) {<br>&gt;             return true<br>&gt;         }<br>&gt;<br>&gt;         for child in children {<br>&gt;             if try child.contains(predicate) {<br>&gt;                 return true<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         return false // 1<br>&gt;     }<br>&gt;<br>&gt;     func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt;<br>&gt; Element? {<br>&gt;         if try predicate(value) {<br>&gt;             return value<br>&gt;         }<br>&gt;<br>&gt;         for child in children {<br>&gt;             if let result = try child.first(where: predicate) {<br>&gt;                 return result<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         return nil // 2<br>&gt;     }<br>&gt;<br>&gt;     var leftMostDescendant: TreeNode? {<br>&gt;         if let child = children.first {<br>&gt;             return child.leftMostDescendant ?? child<br>&gt;         }<br>&gt;<br>&gt;         return nil // 3<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; These code patterns are quite usual. If we could give default return<br>&gt; values to functions, we could get rid of the final `return` statements:<br>&gt;<br>&gt; func contains(_ predicate: (Element) throws -&gt; Bool) rethrows -&gt; Bool =<br>&gt; false {<br>&gt;     if try predicate(value) {<br>&gt;         return true<br>&gt;     }<br>&gt;<br>&gt;     for child in children {<br>&gt;         if try child.contains(predicate) {<br>&gt;             return true<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; func first(where predicate: (Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt; = nil {<br>&gt;     if try predicate(value) {<br>&gt;         return value<br>&gt;     }<br>&gt;<br>&gt;     for child in children {<br>&gt;         if let result = try child.first(where: predicate) {<br>&gt;             return result<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var leftMostDescendant: TreeNode? = nil {<br>&gt;     if let child = children.first {<br>&gt;         return child.leftMostDescendant ?? child<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The default return value shouldn’t be part of the function signature (i.e.<br>&gt; it shouldn’t appear in interface files) because it’s an implementation<br>&gt; detail, but right after the return type is probably the most natural place<br>&gt; to put it (similar to default function parameters).<br>&gt;<br>&gt; Let me know what you think.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/02517968/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
