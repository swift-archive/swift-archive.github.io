<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 12:00:00am</p></header><div class="content"><p>0. Please read the whole proposal and this whole message before replying.<br></p><p>1.<br>&gt; In short words, protocol will became a sort of class and no longer a true kind of contract to conform to.<br></p><p>There is an option to introduce &quot;mixin&quot; keyword:<br>mixin M {<br>    var storage: Int = 0<br>}<br>It won&#39;t cause confusion with today&#39;s protocols.<br>For difference from classes, see under 3.<br></p><p>2.<br>&gt; What about compatibility with Objective C ?<br></p><p>Protocols cannot inherit from classes, including NSObject.<br>[Warning: IMO ahead]<br>But I personally think that we should move from abstract classes in Obj-C, where possible. Actually, all classes in Obj-C can be instantiated, so I consider this a bad abstraction.<br></p><p>3.<br>&gt; (see David&#39;s message)<br>Firstly, what you&#39;ve shown is not a diamond problem. No dequate programming language would allow you to do what you&#39;ve shown. Secondly, please read the whole proposal, as I specifically addressed the issue there.<br></p><p>Now, to difference from classes.<br>The largest difference between classes and mixins comes in inheritance. We can allow multiple inheritance, because we can solve diamond problem with mixins.<br>Let&#39;s take the example from my proposal:<br></p><p>protocol A { var x: Int = 1 }<br>protocol B: A { }<br>protocol C: A { }<br>struct D : B, C { }<br></p><p>What really happens here is the following:<br></p><p>protocol ASelf { var x: Int = 1 }<br>protocol BSelf { }<br>protocol CSelf { }<br>struct D : ASelf, BSelf, CSelf { }<br></p><p>We can do this, because mixins are statically dispatched. The compiler will enumerate all included mixins and mix in only one version of each.<br>I said statically dispatched, but in Swift, compiler can automatically create wrappers with necessary closures inside if we need dynamic dispatch for protocols, so that is not a real concern.<br>Diamond problem is solved the same way in Python and Ruby, so I&#39;m not inventing something new here.<br>Mixins tend to &quot;mix in behaviours&quot;. Let&#39;s take an example usage of diamond pattern:<br></p><p>protocol SignalSender {<br>    private var slots: [String: [() -&gt; ()]] = []<br>    func connect(signal: String, to slot: () -&gt; ()) { ... }<br>    func fire(signal: String) { ... }<br>}<br>protocol A : SignalSender {<br>    // Use signal functionality<br>}<br>protocol B : SignalSender {<br>    // Use signal functionality<br>}<br>struct C : A, B { }<br></p><p>A and B both use a single SignalSender, incorporated within final object. If SignalSender supports its invariants through incapsulation, nothing will ever break them. If it doesn&#39;t, then, well, this mixin is not perfectly suited for multiple inheritance.<br></p><p>If you have reached this far, thank you!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 28, 2016 at 12:00:00pm</p></header><div class="content"><p>I like the proposal but would suggest you rename it Trait and not Mixin,<br>since you proposal has Trait and not Mixin behaviour. The difference is<br>that the order of inheritance is not important with Traits but is with<br>Mixins, EG:<br></p><p>    protocol A { let msg = &quot;A&quot; }<br>    protocol B { let msg = &quot;B&quot; }<br>    struct MixinAB: A, B {}<br>    MixinAB().msg // B<br></p><p>  Whereas<br></p><p>    struct MixinBA: B, A {}<br>    MixinBA().msg // A<br></p><p>With traits the order is not important, and has to be resolved by the<br>programmer when a conflict arises:<br></p><p>    struct ErrorAB: A, B {} // An error because there are two `msg`s.<br></p><p>You have to do:<br></p><p>    struct TraitAB: A, B { // Could be B, A - makes no difference<br>        let msg = A.msg // Select A&#39;s definition, could be `= B.msg`, could<br>be `= 3` (i.e. any valid Swift)<br>    }<br></p><p>As an aside I don&#39;t get what you mean by your example:<br></p><p>protocol&lt;A, B&gt;  // error<br></p><p>Protocols cannot be generic!<br></p><p>On Sunday, 28 February 2016, Anton Zhilin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; 0. Please read the whole proposal and this whole message before replying.<br>&gt;<br>&gt; 1.<br>&gt; &gt; In short words, protocol will became a sort of class and no longer a<br>&gt; true kind of contract to conform to.<br>&gt;<br>&gt; There is an option to introduce &quot;mixin&quot; keyword:<br>&gt; mixin M {<br>&gt;     var storage: Int = 0<br>&gt; }<br>&gt; It won&#39;t cause confusion with today&#39;s protocols.<br>&gt; For difference from classes, see under 3.<br>&gt;<br>&gt; 2.<br>&gt; &gt; What about compatibility with Objective C ?<br>&gt;<br>&gt; Protocols cannot inherit from classes, including NSObject.<br>&gt; [Warning: IMO ahead]<br>&gt; But I personally think that we should move from abstract classes in Obj-C,<br>&gt; where possible. Actually, all classes in Obj-C can be instantiated, so I<br>&gt; consider this a bad abstraction.<br>&gt;<br>&gt; 3.<br>&gt; &gt; (see David&#39;s message)<br>&gt; Firstly, what you&#39;ve shown is not a diamond problem. No dequate<br>&gt; programming language would allow you to do what you&#39;ve shown. Secondly,<br>&gt; please read the whole proposal, as I specifically addressed the issue there.<br>&gt;<br>&gt; Now, to difference from classes.<br>&gt; The largest difference between classes and mixins comes in inheritance. We<br>&gt; can allow multiple inheritance, because we can solve diamond problem with<br>&gt; mixins.<br>&gt; Let&#39;s take the example from my proposal:<br>&gt;<br>&gt; protocol A { var x: Int = 1 }<br>&gt; protocol B: A { }<br>&gt; protocol C: A { }<br>&gt; struct D : B, C { }<br>&gt;<br>&gt; What really happens here is the following:<br>&gt;<br>&gt; protocol ASelf { var x: Int = 1 }<br>&gt; protocol BSelf { }<br>&gt; protocol CSelf { }<br>&gt; struct D : ASelf, BSelf, CSelf { }<br>&gt;<br>&gt; We can do this, because mixins are statically dispatched. The compiler<br>&gt; will enumerate all included mixins and mix in only one version of each.<br>&gt; I said statically dispatched, but in Swift, compiler can automatically<br>&gt; create wrappers with necessary closures inside if we need dynamic dispatch<br>&gt; for protocols, so that is not a real concern.<br>&gt; Diamond problem is solved the same way in Python and Ruby, so I&#39;m not<br>&gt; inventing something new here.<br>&gt; Mixins tend to &quot;mix in behaviours&quot;. Let&#39;s take an example usage of diamond<br>&gt; pattern:<br>&gt;<br>&gt; protocol SignalSender {<br>&gt;     private var slots: [String: [() -&gt; ()]] = []<br>&gt;     func connect(signal: String, to slot: () -&gt; ()) { ... }<br>&gt;     func fire(signal: String) { ... }<br>&gt; }<br>&gt; protocol A : SignalSender {<br>&gt;     // Use signal functionality<br>&gt; }<br>&gt; protocol B : SignalSender {<br>&gt;     // Use signal functionality<br>&gt; }<br>&gt; struct C : A, B { }<br>&gt;<br>&gt; A and B both use a single SignalSender, incorporated within final object.<br>&gt; If SignalSender supports its invariants through incapsulation, nothing will<br>&gt; ever break them. If it doesn&#39;t, then, well, this mixin is not perfectly<br>&gt; suited for multiple inheritance.<br>&gt;<br>&gt; If you have reached this far, thank you!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/04ce5367/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 11:00:00am</p></header><div class="content"><p>I understand now where some misunderstandment comes from. I haven&#39;t really<br>used any languages with traits, but looking at the definition, my proposal<br>surely talks about &quot;traits with state&quot;.<br>I currently don&#39;t suggest any ways to resolve these conflicts. Adding it to<br>future directions for now.<br>protocol&lt;A, B&gt;  in Swift is the same as  protocol InlineProtocol : A, B { }<br></p><p><br>2016-02-28 4:17 GMT+03:00 Howard Lovatt &lt;howard.lovatt at gmail.com&gt;:<br></p><p>&gt; I like the proposal but would suggest you rename it Trait and not Mixin,<br>&gt; since you proposal has Trait and not Mixin behaviour. The difference is<br>&gt; that the order of inheritance is not important with Traits but is with<br>&gt; Mixins, EG:<br>&gt;<br>&gt;     protocol A { let msg = &quot;A&quot; }<br>&gt;     protocol B { let msg = &quot;B&quot; }<br>&gt;     struct MixinAB: A, B {}<br>&gt;     MixinAB().msg // B<br>&gt;<br>&gt;   Whereas<br>&gt;<br>&gt;     struct MixinBA: B, A {}<br>&gt;     MixinBA().msg // A<br>&gt;<br>&gt; With traits the order is not important, and has to be resolved by the<br>&gt; programmer when a conflict arises:<br>&gt;<br>&gt;     struct ErrorAB: A, B {} // An error because there are two `msg`s.<br>&gt;<br>&gt; You have to do:<br>&gt;<br>&gt;     struct TraitAB: A, B { // Could be B, A - makes no difference<br>&gt;         let msg = A.msg // Select A&#39;s definition, could be `= B.msg`,<br>&gt; could be `= 3` (i.e. any valid Swift)<br>&gt;     }<br>&gt;<br>&gt; As an aside I don&#39;t get what you mean by your example:<br>&gt;<br>&gt; protocol&lt;A, B&gt;  // error<br>&gt;<br>&gt; Protocols cannot be generic!<br>&gt;<br>&gt; On Sunday, 28 February 2016, Anton Zhilin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; 0. Please read the whole proposal and this whole message before replying.<br>&gt;&gt;<br>&gt;&gt; 1.<br>&gt;&gt; &gt; In short words, protocol will became a sort of class and no longer a<br>&gt;&gt; true kind of contract to conform to.<br>&gt;&gt;<br>&gt;&gt; There is an option to introduce &quot;mixin&quot; keyword:<br>&gt;&gt; mixin M {<br>&gt;&gt;     var storage: Int = 0<br>&gt;&gt; }<br>&gt;&gt; It won&#39;t cause confusion with today&#39;s protocols.<br>&gt;&gt; For difference from classes, see under 3.<br>&gt;&gt;<br>&gt;&gt; 2.<br>&gt;&gt; &gt; What about compatibility with Objective C ?<br>&gt;&gt;<br>&gt;&gt; Protocols cannot inherit from classes, including NSObject.<br>&gt;&gt; [Warning: IMO ahead]<br>&gt;&gt; But I personally think that we should move from abstract classes in<br>&gt;&gt; Obj-C, where possible. Actually, all classes in Obj-C can be instantiated,<br>&gt;&gt; so I consider this a bad abstraction.<br>&gt;&gt;<br>&gt;&gt; 3.<br>&gt;&gt; &gt; (see David&#39;s message)<br>&gt;&gt; Firstly, what you&#39;ve shown is not a diamond problem. No dequate<br>&gt;&gt; programming language would allow you to do what you&#39;ve shown. Secondly,<br>&gt;&gt; please read the whole proposal, as I specifically addressed the issue there.<br>&gt;&gt;<br>&gt;&gt; Now, to difference from classes.<br>&gt;&gt; The largest difference between classes and mixins comes in inheritance.<br>&gt;&gt; We can allow multiple inheritance, because we can solve diamond problem<br>&gt;&gt; with mixins.<br>&gt;&gt; Let&#39;s take the example from my proposal:<br>&gt;&gt;<br>&gt;&gt; protocol A { var x: Int = 1 }<br>&gt;&gt; protocol B: A { }<br>&gt;&gt; protocol C: A { }<br>&gt;&gt; struct D : B, C { }<br>&gt;&gt;<br>&gt;&gt; What really happens here is the following:<br>&gt;&gt;<br>&gt;&gt; protocol ASelf { var x: Int = 1 }<br>&gt;&gt; protocol BSelf { }<br>&gt;&gt; protocol CSelf { }<br>&gt;&gt; struct D : ASelf, BSelf, CSelf { }<br>&gt;&gt;<br>&gt;&gt; We can do this, because mixins are statically dispatched. The compiler<br>&gt;&gt; will enumerate all included mixins and mix in only one version of each.<br>&gt;&gt; I said statically dispatched, but in Swift, compiler can automatically<br>&gt;&gt; create wrappers with necessary closures inside if we need dynamic dispatch<br>&gt;&gt; for protocols, so that is not a real concern.<br>&gt;&gt; Diamond problem is solved the same way in Python and Ruby, so I&#39;m not<br>&gt;&gt; inventing something new here.<br>&gt;&gt; Mixins tend to &quot;mix in behaviours&quot;. Let&#39;s take an example usage of<br>&gt;&gt; diamond pattern:<br>&gt;&gt;<br>&gt;&gt; protocol SignalSender {<br>&gt;&gt;     private var slots: [String: [() -&gt; ()]] = []<br>&gt;&gt;     func connect(signal: String, to slot: () -&gt; ()) { ... }<br>&gt;&gt;     func fire(signal: String) { ... }<br>&gt;&gt; }<br>&gt;&gt; protocol A : SignalSender {<br>&gt;&gt;     // Use signal functionality<br>&gt;&gt; }<br>&gt;&gt; protocol B : SignalSender {<br>&gt;&gt;     // Use signal functionality<br>&gt;&gt; }<br>&gt;&gt; struct C : A, B { }<br>&gt;&gt;<br>&gt;&gt; A and B both use a single SignalSender, incorporated within final object.<br>&gt;&gt; If SignalSender supports its invariants through incapsulation, nothing will<br>&gt;&gt; ever break them. If it doesn&#39;t, then, well, this mixin is not perfectly<br>&gt;&gt; suited for multiple inheritance.<br>&gt;&gt;<br>&gt;&gt; If you have reached this far, thank you!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/e8fe2b7f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
