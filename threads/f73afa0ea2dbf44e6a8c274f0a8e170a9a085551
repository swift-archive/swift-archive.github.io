<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August 28, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Aug 26 2016, Tim Vermeulen &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is when I first wanted to pass an optional for the `first` parameter:<br>&gt;<br>&gt; extension Sequence {<br>&gt;<br>&gt;     /// Returns a sequence of pairs of consecutive elements<br>&gt;     /// of the sequence, in order.<br>&gt;     var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>&gt;         var iterator = makeIterator()<br>&gt;<br>&gt;         let firstPair = iterator.next().flatMap { first in<br>&gt;             iterator.next().map { second in (first, second) }<br>&gt;         }<br>&gt;<br>&gt;         // I can&#39;t do this, because `firstPair` is optional<br>&gt;         let seq = sequence(first: firstPair) { _, second in<br>&gt;             guard let next = iterator.next() else { return nil }<br>&gt;             return (second, next)<br>&gt;         }<br>&gt;<br>&gt;         return AnySequence(seq)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; In this particular case, finding a workaround is fairly easy (with a<br>&gt; guard and `return AnySequence([])` in the `else` block). However, this<br>&gt; becomes less elegant if you just want to iterate over it rather than<br>&gt; wrap it in AnySequence.<br></p><p>This is why we have sequence(state:next:)<br></p><p><br>  extension Sequence {<br>    /// Returns a sequence of pairs of consecutive elements<br>    /// of the sequence, in order.<br>    var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>      return AnySequence(<br>        sequence(<br>          state: makeIterator(),<br>          next: { (iter: inout Iterator) in<br>            iter.next().flatMap { first in <br>              iter.next().map { (first, $0) }<br>            }<br>          })<br>      )<br>    }<br>  }<br></p><p>  for j in 0..&lt;10 {<br>    print(Array((0..&lt;j).pairs))<br>  }<br></p><p>HTH,<br>Dave<br>&gt;<br>&gt;&gt; Hi Tim,<br>&gt;&gt; <br>&gt;&gt; After having a quick conversation with Dave, here is the question I<br>&gt;&gt; should have asked right away: can you share the typical problem you<br>&gt;&gt; are solving with your overload of the `sequence(first:next:)`<br>&gt;&gt; function?<br>&gt;&gt; <br>&gt;&gt; Max<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Aug 20, 2016, at 2:26 AM, Tim<br>&gt;&gt; &gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt; &gt; What you’re saying makes sense, and I might not have brought this<br>&gt;&gt; &gt; up in the first place if `first.map { sequence(first: $0, next:<br>&gt;&gt; &gt; next } ?? []` worked. The main annoyance is that the best solution<br>&gt;&gt; &gt; (currently) seems to be to copy the source code and make a change.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; (cc-ing Jordan Rose because of a related swift-users thread) This<br>&gt;&gt; &gt; might be a bit of a stretch, but can’t Swift upcast sequences to<br>&gt;&gt; &gt; AnySequence implicitly, like is done with AnyHashable? That would<br>&gt;&gt; &gt; make `first.map { sequence(first: $0, next: next } ?? []`<br>&gt;&gt; &gt; instantly valid, I think. There’s also something to be said for<br>&gt;&gt; &gt; consistency between type erasers. (I’m not necessarily talking<br>&gt;&gt; &gt; about Swift 3)<br>&gt;&gt; &gt; &gt; On 20 Aug 2016, at 02:22, Max<br>&gt;&gt; &gt; &gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; Hi Tim,<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; I still believe that having 2 termination conditions is<br>&gt;&gt; &gt; &gt; wrong. But I guess we need a tie breaker here, someone with a<br>&gt;&gt; &gt; &gt; strong opinion about the problem.<br>&gt;&gt; &gt; &gt; As Kevin mentioned we are very late in the release process, so<br>&gt;&gt; &gt; &gt; waiting for another opinion for a day or two won’t change<br>&gt;&gt; &gt; &gt; anything, really.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt;&gt; &gt; &gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol<br>&gt;&gt; &gt; &gt; conformance to the `UnfoldSequence`, this snippet will compile<br>&gt;&gt; &gt; &gt; just fine. One downside is that the `ExpressibleByArrayLiteral`<br>&gt;&gt; &gt; &gt; protocol allows creating non-empty sequences as well, which does<br>&gt;&gt; &gt; &gt; not make sense for the `UnfoldSequence`.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Max<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via<br>&gt;&gt; &gt; &gt; &gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; AFAIK this issue has never been discussed with<br>&gt;&gt; &gt; &gt; &gt; &gt; sequence(first:next:) before. It certainly wasn&#39;t brought up<br>&gt;&gt; &gt; &gt; &gt; &gt; during review.<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; As for my opinion, I&#39;m really not sure. I was going to point<br>&gt;&gt; &gt; &gt; &gt; &gt; out that right now sequence(first:next:) guarantees that the<br>&gt;&gt; &gt; &gt; &gt; &gt; first element of the resulting sequence is the value<br>&gt;&gt; &gt; &gt; &gt; &gt; provided as &quot;first&quot;, but it occurs to me that if you treat<br>&gt;&gt; &gt; &gt; &gt; &gt; the nil result from next() as an element, then this still<br>&gt;&gt; &gt; &gt; &gt; &gt; holds true. So I guess my biggest worry is this change will<br>&gt;&gt; &gt; &gt; &gt; &gt; make it harder to use sequence(first:next:) to produce<br>&gt;&gt; &gt; &gt; &gt; &gt; sequences of optional values.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; I don’t think producing sequences of optional values would<br>&gt;&gt; &gt; &gt; &gt; really be a problem, because type inference will figure this<br>&gt;&gt; &gt; &gt; &gt; out based on whether you treat the argument to the `next`<br>&gt;&gt; &gt; &gt; &gt; closure as an optional or not. And if you only do things in<br>&gt;&gt; &gt; &gt; &gt; `next` that work both with optionals and non-optionals (very<br>&gt;&gt; &gt; &gt; &gt; unlikely), you can always manually specify the type of the<br>&gt;&gt; &gt; &gt; &gt; sequence.<br>&gt;&gt; &gt; &gt; &gt; &gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; -Kevin Ballard<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; Do you remember the problem of non-emptiness being<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; discussed before? And if not, what’s your opinion on the<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; proposed change?<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; Thanks,<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 19, 2016, at 7:53 AM, Tim<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Max, thanks for having a look.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; A big part of why I’m not really happy with the current<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; implementation is that the function always produces a<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; nonempty sequence, though the compiler doesn’t know<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; it. `sequence(first: first, next: next).last` returns an<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; optional, even though it can’t possibly be nil. The same<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; goes for something like `sequence(first: 5, next: { $0 *<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; 3 }).first(where: { $0&gt;1000 })`, because the sequence is<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; infinite, which means `first(while:)` will either keep<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; running forever, or return a non-optional.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Default implementations for methods on sequences would<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; either return optionals or non-optionals depending on<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; their emptiness/finiteness. We just have the first kind<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; of sequence right now, so in that regard it would make<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; sense to also give `sequence(first:next)` the<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; corresponding signature.Later, when the language /<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; standard library supports the other two kinds of<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; sequences (if that ever happens), the other versions<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; could be added.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; Another reason that makes me think that the version that<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; accepts an optional `first` argument is more natural, is<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; the fact that the function body doesn’t need to be<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; changed at all. It supports optional seeds by design;<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; only the signature prevents it.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; I know these arguments might not be very convincing, but<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; I feel like Swift misses an opportunity if it<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; unnecessarily constrains the `first` parameter to be<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; non-optional. The `.lazy.flatMap({ $0 })` alternative<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; that you pointed out does work, but it makes everything<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; very unreadable: not just the `.lazy.flatMap({ $0 })`<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; part, but also the body of the `next` parameter because<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; you’re now dealing with optionals (i.e. you have to<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; `flatMap` over the closure argument). The best solution<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; I’ve come up with is to copy the `sequence(first:next)`<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; implementation from the source code and change the<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; signature. :-/<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; `sequence(state:next:)` isn’t very appropriate for this<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; task either, because naive usage with an optional seed<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; has the downside of being unnecessarily eager just like<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; a naive `sequence(first:next)` implementation (as<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; described in a comment in the source code).<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 00:18, Max<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Tim,<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for bringing this up.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; To me the type of the function as it is tells a clear<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; story of what’s going to happen: take the `first`,<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; make it a head of the resulting sequence, and then try<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to produce the tail by a series of applications of<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; `next`. The only thing that controls when the sequence<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; generation terminates is the result of `next`.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; If we change the type of `first` to an Optional&lt;T&gt;, it<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; would make the termination condition<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; non-trivial. After all, the only thing it would do is<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; try to unwrap the `first`, before doing what it needs<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to, but we already have a `map` for that. One should<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; be able to simply do the `first.map { sequence(first:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; $0, next: next) } ?? []` but that won’t work with the<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; types very well, unfortunately.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; As an alternative, `let first: Int? = ...;<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first: first, next: next).flatMap({$0})` (or<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; even `.lazy.flatMap({$0})`) will do the right thing<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; without making an API more complex.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I see the point of `sequence(first:next:)` to be<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; precisely the &quot;generate the non-empty sequence using a<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; seed and a simple producer&quot;, for anything more than<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; that, there is `sequence(state:next:)`.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; What do you think?<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first:next:) takes a non-optional first<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; argument. Is there a reason for that?<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(state:next:) allows empty sequences, and I<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; don’t see why sequence(first:next:) shouldn’t. The<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; fix would be to simply add the `?` in the function<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; signature; no other changes are required to make it<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; work.<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution-m3FHrko0VLw at public.gmane.orgg)<br>&gt;&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
