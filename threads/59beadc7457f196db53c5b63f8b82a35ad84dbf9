<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5daa1633e5f933f7901a26b0329015cd?s=50"></div><header><strong>LazyCollection.map()</strong> from <string>Aaron Bohannon</string> &lt;aaron678 at gmail.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>Does the code below have a well-defined behavior?<br></p><p><br>struct Nope: ErrorType {}<br></p><p>func f(i: Int) throws -&gt; Int {<br>  guard i &lt; 5 else { throw Nope() }<br>  return i<br>}<br></p><p>do {<br>  let _ = try Array(0 ..&lt; 10).lazy.map(f)<br>  print(&quot;lazy&quot;)<br>} catch (let e) {<br>  print(e)<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160628/59bedbf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>LazyCollection.map()</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 3:37 PM, Aaron Bohannon via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; Does the code below have a well-defined behavior?<br></p><p>It invokes the eager map() that is available on Array.lazy.<br>Array.lazy is a collection, so it has an eager map() from the<br>Collection protocol.  The lazy map() does not accept a throwing<br>closure, so it does not match and the type checker chooses the eager<br>one.<br></p><p>Arguably, in non-generic context this code should not type check.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5daa1633e5f933f7901a26b0329015cd?s=50"></div><header><strong>LazyCollection.map()</strong> from <string>Aaron Bohannon</string> &lt;aaron678 at gmail.com&gt;<p>June 28, 2016 at 07:00:00pm</p></header><div class="content"><p>AH!  I wasn&#39;t familiar enough with the LazyCollectionType protocol to<br>realize that its map() function had a different signature.<br></p><p>So, presumably, if I pass a non-throwing closure, the compiler will choose<br>the lazy map().  However, it&#39;s not immediately obvious to me why it would<br>be chosen.  Is it because the LazyCollectionType version of map() &quot;shadows&quot;<br>the CollectionType whenever either one could be chosen (since<br>LazyCollectionType extends CollectionType)?  Or is it because the function<br>with the more restrictive argument type is always chosen when more than one<br>version of the function could match?<br></p><p><br>On Tue, Jun 28, 2016 at 5:38 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Tue, Jun 28, 2016 at 3:37 PM, Aaron Bohannon via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt; Does the code below have a well-defined behavior?<br>&gt;<br>&gt; It invokes the eager map() that is available on Array.lazy.<br>&gt; Array.lazy is a collection, so it has an eager map() from the<br>&gt; Collection protocol.  The lazy map() does not accept a throwing<br>&gt; closure, so it does not match and the type checker chooses the eager<br>&gt; one.<br>&gt;<br>&gt; Arguably, in non-generic context this code should not type check.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160628/31e774f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>LazyCollection.map()</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 6:07 PM, Aaron Bohannon &lt;aaron678 at gmail.com&gt; wrote:<br>&gt; AH!  I wasn&#39;t familiar enough with the LazyCollectionType protocol to<br>&gt; realize that its map() function had a different signature.<br>&gt;<br>&gt; So, presumably, if I pass a non-throwing closure, the compiler will choose<br>&gt; the lazy map().  However, it&#39;s not immediately obvious to me why it would be<br>&gt; chosen.  Is it because the LazyCollectionType version of map() &quot;shadows&quot; the<br>&gt; CollectionType whenever either one could be chosen (since LazyCollectionType<br>&gt; extends CollectionType)?  Or is it because the function with the more<br>&gt; restrictive argument type is always chosen when more than one version of the<br>&gt; function could match?<br></p><p>LazyCollectionType.map() does not shadow Collection.map(), but the<br>type checker prefers the lazy one because LazyCollectionType refines<br>Collection.  Basically, it prefers the more refined one, but the other<br>one is still an option.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5daa1633e5f933f7901a26b0329015cd?s=50"></div><header><strong>LazyCollection.map()</strong> from <string>Aaron Bohannon</string> &lt;aaron678 at gmail.com&gt;<p>June 29, 2016 at 02:00:00am</p></header><div class="content"><p>I didn&#39;t really understand your answer, so I figured that I&#39;d just<br>experiment until I could see the pattern.  Unfortunately, I found very few<br>signs of any underlying pattern -- and I didn&#39;t even get a chance to<br>experiment with generics.  All I can see is behavior that is frighteningly<br>inexplicable.  I&#39;ve tried to explain my confusion in the inline comments<br>below.  (FYI: I&#39;m still using Swift 2.2 at the moment... if that matters.)<br></p><p>- Aaron<br></p><p><br>// Trivial class hierarchy for the examples<br>class C {}<br>class D: C {}<br>class E: D {}<br></p><p>// Trivial protocol hierarchy for the examples<br>protocol P {<br>  var a: Bool { get }<br>}<br>protocol Q: P {<br>  var b: Bool { get }<br>}<br>class R: Q {<br>  let a = true<br>  let b = true<br>}<br></p><p>// Base protocol with some default implementations<br>protocol BaseProtocol {}<br>extension BaseProtocol {<br>  // f1 has a more permissive parameter type than f2<br>  func f1(x: Int??) -&gt; String { return &quot;Base&quot; }<br>  func f2(x: Int?) -&gt; String { return &quot;Base&quot; }<br></p><p>  // g1 has a more permissive parameter type than g2<br>  func g1(x: C) -&gt; String { return &quot;Base&quot; }<br>  func g2(x: D) -&gt; String { return &quot;Base&quot; }<br></p><p>  // h1 has a more permissive parameter type than h2<br>  func h1(x: P) -&gt; String { return &quot;Base&quot; }<br>  func h2(x: Q) -&gt; String { return &quot;Base&quot; }<br></p><p>  // two functions with incomparable but overlapping parameter types<br>  func v1(x: (Int?, Int)) -&gt; String { return &quot;Base&quot; }<br>  func v2(x: (Int, Int?)) -&gt; String { return &quot;Base&quot; }<br></p><p>  // two functions with incomparable but overlapping parameter types<br>  func w1(x: () -&gt; Int?) -&gt; String { return &quot;Base&quot; }<br>  func w2(x: () throws -&gt; Int) -&gt; String { return &quot;Base&quot; }<br>}<br></p><p>// Derived protocol with some default implementations<br>protocol DerivedProtocol: BaseProtocol {}<br>extension DerivedProtocol {<br>  // f2 has a more permissive parameter type than f1<br>  func f1(x: Int?) -&gt; String { return &quot;Derived&quot; }<br>  func f2(x: Int??) -&gt; String { return &quot;Derived&quot; }<br></p><p>  // g2 has a more permissive parameter type than g1<br>  func g1(x: D) -&gt; String { return &quot;Derived&quot; }<br>  func g2(x: C) -&gt; String { return &quot;Derived&quot; }<br></p><p>  // h2 has a more permissive parameter type than h1<br>  func h1(x: Q) -&gt; String { return &quot;Derived&quot; }<br>  func h2(x: P) -&gt; String { return &quot;Derived&quot; }<br></p><p>  // two functions with incomparable but overlapping parameter types<br>  func v1(x: (Int, Int?)) -&gt; String { return &quot;Derived&quot; }<br>  func v2(x: (Int?, Int)) -&gt; String { return &quot;Derived&quot; }<br></p><p>  // two functions with incomparable but overlapping parameter types<br>  func w1(x: () throws -&gt; Int) -&gt; String { return &quot;Derived&quot; }<br>  func w2(x: () -&gt; Int?) -&gt; String { return &quot;Derived&quot; }<br>}<br></p><p>class Z: DerivedProtocol {}<br></p><p>// First we check the functions whose parameters have built-in types:<br></p><p>print(Z().f1(7))         // prints &quot;Derived&quot;<br>print(Z().f2(7))         // prints &quot;Base&quot;<br></p><p>// The outcome seems to demonstrate that the location of the function&#39;s<br>definition within the protocol hierarchy is irrelevant.  As in Java, it<br>appears that all accessible, applicable functions are being given equal<br>consideration, and then the function whose signature has a more specific<br>parameter type is chosen.  That makes sense to me.<br></p><p>// Next we check functions whose parameters have class types:<br></p><p>print(Z().g1(E()))       // prints &quot;Derived&quot;<br>print(Z().g2(E()))       // prints &quot;Derived&quot;<br></p><p>// Surprisingly, the outcome here appears to contradict the previous one: a<br>function with a less specific type is given preference.  This must be due<br>to the fact that it is defined in the derived protocol rather than the base<br>protocol.  Does that mean we should call this case &quot;overriding&quot; while the<br>previous one was &quot;overloading&quot;?  But I can&#39;t understand why there could be<br>any value in treating user-defined types different from built-in types.<br>Maybe the behavior here is a bug?<br></p><p>// Now we check the same functions again using an argument with a less<br>specific type that happens to be identical to the formal parameter type of<br>one of the functions:<br></p><p>print(Z().g1(D()))       // prints &quot;Derived&quot;<br>print(Z().g2(D()))       // prints &quot;Base&quot;<br></p><p>// And the outcome is different than before!  So, for user-defined types,<br>is there a special rule that only applies when the formal and actual<br>parameters have precisely the same type?  Of course, we wouldn&#39;t need to<br>call this a special case if the behavior in the second example had been the<br>same as the first, which lends support to the idea that the second example<br>is actually illustrating a bug... but we&#39;re not done testing yet.<br></p><p>// What happens with functions whose formal parameters have protocol types?<br></p><p>print(Z().h1(R()))       // prints &quot;Derived&quot;<br>print(Z().h2(R()))       // prints &quot;Derived&quot;<br></p><p>print(Z().h1(R() as Q))  // prints &quot;Derived&quot;<br>print(Z().h2(R() as Q))  // prints &quot;Derived&quot;<br></p><p>// Well it appears they are handled like class types rather than built-in<br>types -- except that the special-case behavior that was observed when the<br>class types are identical is not coming into effect here.  So, maybe the<br>second example was not a bug?  Are we making a deliberate decision to<br>sometimes give the function definition in the derived class precedence over<br>the first?  But what exactly would we mean by &quot;sometimes&quot;?  And why would<br>having that sometimes-different behavior be a good thing.  If we have three<br>different elementary overload resolution schemes for the different kinds of<br>types, what&#39;s going to happen when we try to combine those types?  Or<br>combine overloading with other language features?  Like generics, etc.?<br>Yikes!<br></p><p>// I also decided to test the behavior for a pair of functions, both of<br>which can be applied to the argument but neither of which can match the<br>argument&#39;s type in a more specific way than the other.  I suspected this<br>might somehow trigger a type error, but it didn&#39;t.  Instead, the definition<br>in the derived protocol was given preference:<br></p><p>print(Z().v1((0, 0)))    // prints &quot;Derived&quot;<br>print(Z().v2((0, 0)))    // prints &quot;Derived&quot;<br></p><p>// I suppose that, if a type error isn&#39;t going to be raised when neither<br>function is a better fit than the other, then it makes sense to use the<br>definition in the derived class as a default.  Unfortunately, my final<br>example demonstrates that we can&#39;t even count on that much:<br></p><p>print(Z().w1({ return 7 }))  // prints &quot;Derived&quot;<br>print(Z().w2({ return 7 }))  // prints &quot;Base&quot;<br></p><p>// Given that these last two examples exhibit different behavior, the<br>compiler really ought to define them both as type errors.  However, I&#39;m<br>even more worried by the diverging behavior of the earlier examples.<br></p><p><br></p><p>On Tue, Jun 28, 2016 at 7:09 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Tue, Jun 28, 2016 at 6:07 PM, Aaron Bohannon &lt;aaron678 at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; AH!  I wasn&#39;t familiar enough with the LazyCollectionType protocol to<br>&gt; &gt; realize that its map() function had a different signature.<br>&gt; &gt;<br>&gt; &gt; So, presumably, if I pass a non-throwing closure, the compiler will<br>&gt; choose<br>&gt; &gt; the lazy map().  However, it&#39;s not immediately obvious to me why it<br>&gt; would be<br>&gt; &gt; chosen.  Is it because the LazyCollectionType version of map() &quot;shadows&quot;<br>&gt; the<br>&gt; &gt; CollectionType whenever either one could be chosen (since<br>&gt; LazyCollectionType<br>&gt; &gt; extends CollectionType)?  Or is it because the function with the more<br>&gt; &gt; restrictive argument type is always chosen when more than one version of<br>&gt; the<br>&gt; &gt; function could match?<br>&gt;<br>&gt; LazyCollectionType.map() does not shadow Collection.map(), but the<br>&gt; type checker prefers the lazy one because LazyCollectionType refines<br>&gt; Collection.  Basically, it prefers the more refined one, but the other<br>&gt; one is still an option.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160629/170c1a60/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
