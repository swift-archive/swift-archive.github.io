<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Lo√Øc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>December 19, 2015 at 06:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I‚Äôm starting a new thread for this proposal https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br></p><p>So far, everybody agreed that using distinct keywords for type alias and associated type declarations is a good idea.<br>However, some people think that ‚Äúassociated‚Äù is not an ideal replacement because it is too vague.<br>I would like to choose a better keyword before the review, but I‚Äôm struggling to find a good replacement. <br></p><p>So, here are some keywords that were proposed by the community.<br></p><p>1. associated_type<br>This is the original proposed keyword. It is extremely clear, but snake_cases are un-Swifty.<br></p><p>2. associatedtype (or typeassociation)<br>This was the first alternative to associated_type. Its purpose is still extremely clear.<br>I like it a lot, but it is a bit long and difficult to read.<br></p><p>3. associated<br>This is the keyword I chose for the proposal because it was the most well-received initially. <br>It is quite short, very different from ‚Äútypealias&quot;, and sounds good. However, it is also vaguer.<br>Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it, and it‚Äôs unclear what it declares.<br>For example, one could think that it is an associated *value* and write <br>protocol FixedSizeCollectionProtocol {<br>	associated size : Int<br>}<br>Although honestly I doubt many people would write that. <br></p><p>4. withtype (or needstype)<br>It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some concept of association thanks to ‚Äúwith‚Äù. I like it. <br>But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br></p><p>5. type<br>This keyword was proposed by several people, but I strongly dislike it.<br>It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and ‚Äúclass‚Äù keywords for type-level members.<br>I think the fact that it was proposed for two completely different purposes shows that it is too abstract.<br>It would make searching for help more difficult because of its bad googleability.<br></p><p><br>Personally, I would like to either keep ‚Äúassociated‚Äù, or use ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br></p><p>1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>Bonus) Maybe some twitter-famous person could make a quick poll and see which one developers prefer? üòÅ (after they read this email)<br>I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake) followers will give me a lot of information.  <br></p><p>Lo√Øc<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; snake_cases are un-Swifty<br>amen.<br></p><p>My first thought for a name was &quot;placeholder&quot;, and I just saw that this was used in the description of the concept as well‚Ä¶ so maybe this would be an option?<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/97013db1005ef6260fd8f1278f37b831?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Andrew Hoos</string> &lt;andrewjhoos at gmail.com&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>I second placeholder as the most rational keyword. Every description of the distinct usage of type alias refers to is a placeholder type. placeholder is one word(circumventingCase_issues) and is more descriptive of what it is than associated*. Seems like an easy win. Is there a some reason I am missing why *type* or associated* are better keyword fits?<br></p><p>Andrew Hoos<br></p><p>&gt; On Dec 19, 2015, at 10:07, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; snake_cases are un-Swifty<br>&gt; amen.<br>&gt; <br>&gt; My first thought for a name was &quot;placeholder&quot;, and I just saw that this was used in the description of the concept as well‚Ä¶ so maybe this would be an option?<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; Is there a some reason I am missing why *type* or associated* are better keyword fits?<br></p><p>The main reason to use `associated` is because the feature is called an &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder type&quot;, then `placeholder` would be a good keyword.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>If I understand the Associated Types (I wouldn&#39;t be surprised if I have it<br>all wrong), don&#39;t they really define Types used as, in standard English,<br>&quot;components&quot;, or &quot;elements&quot; of the protocol? If so, the problem is that the<br>words &quot;component&quot; and &quot;element&quot; are already used for other things.<br></p><p>On Sun, Dec 20, 2015 at 1:18 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Is there a some reason I am missing why *type* or associated* are better<br>&gt; keyword fits?<br>&gt;<br>&gt; The main reason to use `associated` is because the feature is called an<br>&gt; &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder<br>&gt; type&quot;, then `placeholder` would be a good keyword.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/b7a33fd6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; The main reason to use `associated` is because the feature is called an &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder type&quot;, then `placeholder` would be a good keyword.<br>good point - maybe it&#39;s because I&#39;m no native speaker, but for me &quot;associated type&quot; is just a technical term with no obvious meaning.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 20, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; for me &quot;associated type&quot; is just a technical term with no obvious meaning.<br></p><p>That&#39;s not a bad thing. You get a hint that something funny is going on, and if you don&#39;t know what, you can look it up. You even have a great keyword to search for, right there.<br></p><p>Compared to that, something like ‚Äúrequired type‚Äù doesn&#39;t tell you much about the gravity of the change. If you know about required constructors, you could assume that required types are like that ‚Äî and they are like that, but they also change your protocol in a pretty spectacular way.<br></p><p>Anything is better than just ‚Äútypealias‚Äù, though.<br></p><p>A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/25d1f2d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 20, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; You even have a great keyword to search for, right there.<br>Good point - we are lucky that Apple has so much influence to make &quot;swift&quot; already a useful search term so we don&#39;t have to look for &quot;swiftlang&quot; ;-)<br>Still undecided wether this argument is a bad justification for cryptic names in general...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/7f311a81/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 3:58 , Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The main reason to use `associated` is because the feature is called an &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder type&quot;, then `placeholder` would be a good keyword.<br>&gt; good point - maybe it&#39;s because I&#39;m no native speaker, but for me &quot;associated type&quot; is just a technical term with no obvious meaning.<br></p><p>Fair enough; &quot;associated type&quot; is a fairly vacuous term. I think the implication is that when you choose a model of the protocol, the concrete type, then these other types come along with it. But that&#39;s not immediately clear, so I don&#39;t think renaming the feature is out of the question.<br></p><p>I don&#39;t like the name &quot;placeholder&quot; or &quot;placeholder type&quot; because that only describes how they&#39;re used in the protocol. When you&#39;re actually implementing a generic function, the generic parameter is a sort of placeholder, and the associated types are just as concrete as the conforming type itself.<br></p><p>Jordan<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/794a5f40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 4:57 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 20, 2015, at 3:58 , Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The main reason to use `associated` is because the feature is called an &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder type&quot;, then `placeholder` would be a good keyword.<br>&gt;&gt; good point - maybe it&#39;s because I&#39;m no native speaker, but for me &quot;associated type&quot; is just a technical term with no obvious meaning.<br>&gt; <br>&gt; Fair enough; &quot;associated type&quot; is a fairly vacuous term. I think the implication is that when you choose a model of the protocol, the concrete type, then these other types come along with it. But that&#39;s not immediately clear, so I don&#39;t think renaming the feature is out of the question.<br>&gt; <br>&gt; I don&#39;t like the name &quot;placeholder&quot; or &quot;placeholder type&quot; because that only describes how they&#39;re used in the protocol. When you&#39;re actually implementing a generic function, the generic parameter is a sort of placeholder, and the associated types are just as concrete as the conforming type itself.<br></p><p>I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/7e0baea4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>Le 21 d√©c. 2015 √† 21:34, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br></p><p>&gt; I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.<br></p><p>Could also use `typename`. But maybe that&#39;s too easy to mix with `typealias`.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 6:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 4:57 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 20, 2015, at 3:58 , Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main reason to use `associated` is because the feature is called an &quot;associated type&quot;. If we&#39;re willing to rename the feature to &quot;placeholder type&quot;, then `placeholder` would be a good keyword.<br>&gt;&gt;&gt; good point - maybe it&#39;s because I&#39;m no native speaker, but for me &quot;associated type&quot; is just a technical term with no obvious meaning.<br>&gt;&gt; <br>&gt;&gt; Fair enough; &quot;associated type&quot; is a fairly vacuous term. I think the implication is that when you choose a model of the protocol, the concrete type, then these other types come along with it. But that&#39;s not immediately clear, so I don&#39;t think renaming the feature is out of the question.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t like the name &quot;placeholder&quot; or &quot;placeholder type&quot; because that only describes how they&#39;re used in the protocol. When you&#39;re actually implementing a generic function, the generic parameter is a sort of placeholder, and the associated types are just as concrete as the conforming type itself.<br>&gt; <br>&gt; I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.<br></p><p>Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/89c5eaa7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Lo√Øc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>Agreed for requiredtype. But I am not convinced ‚Äúassociatedtype‚Äù belabors the relationship between the protocol and the requirements. <br></p><p>The word ‚Äúassociated‚Äù is never used as a replacement for ‚Äúrequirement‚Äù. It just names what the requirement is.<br>‚Äú[protocol] can only be used as a generic constraint because it has Self or __associated type requirements__‚Äù<br>‚ÄúGrammar of a protocol __associated type__ declaration‚Äù (for comparison: ‚ÄúGrammar of a protocol __subscript__ declaration‚Äù)<br></p><p>(Counterpoint: maybe ‚Äúassociated‚Äù was only used there to avoid saying ‚Äútype requirements/declaration‚Äù, which would be confusing)<br></p><p>I am now totally fine with ‚Äútype‚Äù. But I am still afraid that it will be recycled elsewhere for a completely different purpose. Maybe that‚Äôs what you alluded to with ‚Äúif we could make type work‚Äù? <br></p><p>Anyway, it‚Äôs the holidays, and I don‚Äôt want to bother people with work. I think I will modify the proposal with a link to this discussion instead of ‚ÄúCommunity Responses‚Äù, and we‚Äôll have three days right after the holidays to make a final choice :-)<br></p><p>Lo√Øc<br></p><p>PS: here is the result of a survey asking developers which keyword they prefer: https://www.surveymonkey.com/results/SM-7L7WMQ3J/<br>2 people (out of 100) chose ‚Äúother‚Äù and specified ‚Äútype‚Äù. Sadly it wasn‚Äôt presented as an option, sorry :(<br></p><p><br>&gt; On Dec 22, 2015, at 3:56 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; 2 people (out of 100) chose ‚Äúother‚Äù and specified ‚Äútype‚Äù. Sadly it wasn‚Äôt presented as an option, sorry :(<br>I&#39;m not a big fan of simple surveys in general, but isn&#39;t there a better platform than surveymonkey?<br>Sure, it has nice graphs, but doodle once had the option to add possible answers ‚Äî and I can&#39;t even see a way to read the full results, so could you publish the numbers for the &quot;other&quot;-votes?<br></p><p>Best regards,<br>Tino<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br></p><p>Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br></p><p>protocol P {<br>  parameter T<br>}<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>As SE-0011 states, the concept of typealias is overloaded. <br>In one case, it&#39;s really just typedef. <br>In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br></p><p>The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br></p><p>Some argue for raw type as the replacement:<br>Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br></p><p>Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br></p><p>-- E<br></p><p><br>&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt; <br>&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt; <br>&gt; protocol P {<br>&gt;  parameter T<br>&gt; }<br>&gt; <br>&gt; Guillaume Lessard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/aa844d00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt; In one case, it&#39;s really just typedef. <br>&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt; <br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt; <br>&gt; Some argue for raw type as the replacement:<br>&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br>&gt; <br>&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br></p><p>+1.  associatedtype seems better than any other option I‚Äôve seen thus far (including the new ones you mentioned).<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  parameter T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/0734845b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br>&gt; <br>&gt; +1.  associatedtype seems better than any other option I‚Äôve seen thus far (including the new ones you mentioned).<br></p><p>If the language construct is called an ‚Äúassociated type,‚Äù then introducing a keyword that uses any terminology other than ‚Äúassociated‚Äù is a recipe for eternal community confusion.<br></p><p>I could go for associatedtype, associated_type, or associated ‚Äî but I agree that anything else, including typealias, seems inferior.<br></p><p>P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/da2ea6c1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>How about &#39;deferred‚Äô? As in one of the following:<br></p><p>typealias MyType = deferred<br></p><p>or:<br>deferredtype MyType<br></p><p>or:<br>deferred typealias MyType<br></p><p>(apologies if this was already suggested previously)<br></p><p>&gt; On Dec 22, 2015, at 9:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt; In one case, it&#39;s really just typedef. <br>&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt; <br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt; <br>&gt; Some argue for raw type as the replacement:<br>&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br>&gt; <br>&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  parameter T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/29acf030/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>I still prefer &quot;type&quot; as &quot;associatedtype&quot; is quite a mouthful and, really being two words, quite untypical for a keyword.<br></p><p>And required functions etc. use simply &quot;func&quot; instead of &quot;requiredfunc&quot; as well.<br></p><p>-Thorsten <br></p><p>&gt; Am 22.12.2015 um 18:30 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt; In one case, it&#39;s really just typedef. <br>&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt; <br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt; <br>&gt; Some argue for raw type as the replacement:<br>&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br>&gt; <br>&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  parameter T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/f91d41ba/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>The fact that ‚Äúassociated type‚Äù is used throughout the documentation is worth making note of, but it could also be that some other replacement would make the concept more clear than it currently is in the documentation.<br></p><p>Matt<br></p><p>&gt; On Dec 22, 2015, at 09:30, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/682c82b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>December 23, 2015 at 01:00:00am</p></header><div class="content"><p>I would much prefer one of the longer terms such as &#39;associatedtype&#39; to<br>&#39;type&#39;. The simple reason why: I&#39;ve been using a lot of generics for a<br>while and I still find it tricky. I want a term I can type into a search<br>engine and expect results for, and &#39;type&#39;s too common for that.<br></p><p>On Tue, Dec 22, 2015 at 8:42 PM, Matt Whiteside via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The fact that ‚Äúassociated type‚Äù is used throughout the documentation is<br>&gt; worth making note of, but it could also be that some other replacement<br>&gt; would make the concept more clear than it currently is in the documentation.<br>&gt;<br>&gt; Matt<br>&gt;<br>&gt; On Dec 22, 2015, at 09:30, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming<br>&gt; Language book, for example: &quot;When defining a protocol, it is sometimes<br>&gt; useful to declare one or more *associated types* as part of the<br>&gt; protocol‚Äôs definition. An *associated type* gives a placeholder name (or<br>&gt; alias) to a type that is used as part of the protocol. The actual type to<br>&gt; use for that *associated type* is not specified until the protocol is<br>&gt; adopted.&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/868d55b8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt; In one case, it&#39;s really just typedef. <br>&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt; <br>&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt; <br>&gt; Some argue for raw type as the replacement:<br>&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension.<br></p><p>I don‚Äôt see how this:<br></p><p>protocol P {<br>  type/*alias*/ A<br>}<br></p><p>struct X : P {<br>  struct A {}<br>}<br></p><p>is fundamentally any different from:<br></p><p>protocol P {<br>  func f()<br>}<br></p><p>struct X : P {<br>  func f() {}<br>}<br></p><p>What am I missing?<br></p><p>&gt; They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br></p><p>The way defaults are specified is a non-uniformity that we want to fix.  There‚Äôs no reason we couldn‚Äôt be providing default implementations of required protocol methods in the protocol body either.<br></p><p>&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  parameter T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/bd3d3677/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 6:25 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt;&gt; In one case, it&#39;s really just typedef. <br>&gt;&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt;&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt;&gt; <br>&gt;&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt;&gt; <br>&gt;&gt; Some argue for raw type as the replacement:<br>&gt;&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt;&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt;&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. <br>&gt; <br>&gt; I don‚Äôt see how this:<br>&gt; protocol P {  type/*alias*/ A}<br>&gt; struct X : P {  struct A {} }<br>&gt; <br>&gt; is fundamentally any different from:<br>&gt; protocol P {  func f()}<br>&gt; struct X : P {  func f() {}}<br>&gt; <br>&gt; What am I missing?<br></p><p>You&#39;re not using func f() elsewhere as a return type, a parameter type, in generic constraints, etc.  Other member requirements are Jeff Goldblum and typealiases are Chuck Norris.<br></p><p>They provide a fundamental grammar for other tasks. <br></p><p>Quick reference I ended up generating so I could keep all of my possible expressiveness at hand. It may or may not add to your thoughts about this:<br>https://gist.githubusercontent.com/erica/c50f8f213db1be3e6390/raw/2888276fcad56d68016f864e6e0e9f689f597aac/0%2520Conformances%2520and%2520Associated%2520Types<br></p><p>&gt;&gt; They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br>&gt; <br>&gt; The way defaults are specified is a non-uniformity that we want to fix.  There‚Äôs no reason we couldn‚Äôt be providing default implementations of required protocol methods in the protocol body either.<br></p><p>Cool. Power to the protocol!<br></p><p>&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br></p><p>And bringing a point from a later email: easier to google.<br></p><p>-- E<br></p><p><br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;  parameter T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Guillaume Lessard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/e766ca6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 5:51 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 22, 2015, at 6:25 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 9:30 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As SE-0011 states, the concept of typealias is overloaded. <br>&gt;&gt;&gt; In one case, it&#39;s really just typedef. <br>&gt;&gt;&gt; In the other it&#39;s a stand-in for a deferred type that is specified by conforming classes. <br>&gt;&gt;&gt; While you could argue that the other typealias be redefined to typedef, it&#39;s pretty clear that in use, what&#39;s being described in the second case is an associated type. The word associated means related to or connected to, and type well it&#39;s a type. It  basically says &quot;this is a placeholder type that establishes a specific role in this protocol&quot;. I think associatedtype is a pretty good word to describe what a second-style typealias does: a conforming construct binds an associated type with an actual type instance. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The phrase &quot;associated type&quot; is used throughout the Swift Programming Language book, for example: &quot;When defining a protocol, it is sometimes useful to declare one or more associated types as part of the protocol‚Äôs definition. An associated type gives a placeholder name (or alias) to a type that is used as part of the protocol. The actual type to use for that associated type is not specified until the protocol is adopted.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some argue for raw type as the replacement:<br>&gt;&gt;&gt; Dave Abrahams writes, &quot;I‚Äôm actually coming around to wanting it to be just ‚Äútype‚Äù as a contextual keyword, if we can make that work.  The point is that these types aren‚Äôt ‚Äúassociated‚Äù in any way that distinguishes them from other requirements on nested declarations, i.e. funcs and vars.&quot;<br>&gt;&gt;&gt; Joe Groff writes, &quot;Yeah, if we could make &#39;type&#39; work I&#39;d prefer that too. None of our other protocol requirement declarations specifically call out the fact that they&#39;re protocol requirements, so it feels a bit weird to use a name like &#39;associatedtype&#39; or &#39;requiredsomething&#39; that belabors the relationship between the protocol and the requirement.&quot; <br>&gt;&gt;&gt; Type members are unlike the other kinds of required protocol members, like a property, method, initializer, or subscript requirement. They aren&#39;t implemented by a conforming construct or extension. <br>&gt;&gt; <br>&gt;&gt; I don‚Äôt see how this:<br>&gt;&gt; protocol P {  type/*alias*/ A}<br>&gt;&gt; struct X : P {  struct A {} }<br>&gt;&gt; <br>&gt;&gt; is fundamentally any different from:<br>&gt;&gt; protocol P {  func f()}<br>&gt;&gt; struct X : P {  func f() {}}<br>&gt;&gt; <br>&gt;&gt; What am I missing?<br>&gt; <br>&gt; You&#39;re not using func f() elsewhere as a return type, a parameter type, in generic constraints, etc.  Other member requirements are Jeff Goldblum and typealiases are Chuck Norris.<br></p><p>I‚Äôm sorry, I‚Äôm missing your metaphor.<br></p><p>&gt; They provide a fundamental grammar for other tasks. <br></p><p>Yes, other requirements may depend on associated types.  They‚Äôre still requirements.<br></p><p>&gt; Quick reference I ended up generating so I could keep all of my possible expressiveness at hand. It may or may not add to your thoughts about this:<br>&gt; https://gist.githubusercontent.com/erica/c50f8f213db1be3e6390/raw/2888276fcad56d68016f864e6e0e9f689f597aac/0%2520Conformances%2520and%2520Associated%2520Types &lt;https://gist.githubusercontent.com/erica/c50f8f213db1be3e6390/raw/2888276fcad56d68016f864e6e0e9f689f597aac/0%20Conformances%20and%20Associated%20Types&gt;<br>Sorry, I‚Äôm not sure what insight that list is supposed to spark.  Be assured, I have generated many such tables, graphs, etc. for myself in the past :-)<br></p><p>&gt;&gt;&gt; They act as stand-in or placeholder: assigned not implemented. They can even be assigned as a default in the protocol definition, for example: typealias Generator : GeneratorType = IndexingGenerator&lt;Self&gt; in CollectionType. <br>&gt;&gt; <br>&gt;&gt; The way defaults are specified is a non-uniformity that we want to fix.  There‚Äôs no reason we couldn‚Äôt be providing default implementations of required protocol methods in the protocol body either.<br>&gt; <br>&gt; Cool. Power to the protocol!<br>&gt; <br>&gt;&gt; Unless typestandin, typeplaceholder, or adoptedtype are placed on the table, I don&#39;t really see any reason to introduce a keyword other than associatedtype for this proposal. <br>&gt; <br>&gt; And bringing a point from a later email: easier to google.<br></p><p>Undeniably.<br></p><p>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:40 AM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;  parameter T<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Guillaume Lessard<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -Dave<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/1da4ad67/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; I don‚Äôt see how this:<br>&gt; <br>&gt; protocol P {<br>&gt;   type/*alias*/ A<br>&gt; }<br>&gt; <br>&gt; struct X : P {<br>&gt;   struct A {}<br>&gt; }<br>&gt; <br>&gt; is fundamentally any different from:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f()<br>&gt; }<br>&gt; <br>&gt; struct X : P {<br>&gt;   func f() {}<br>&gt; }<br>&gt; <br>&gt; What am I missing?<br></p><p>I&#39;d say it&#39;s the fact that adding an associated type turns a protocol into a frankenprotocol, and we don&#39;t want that to be cast upon innocent souls without a proper curse word (like &quot;associatedtype&quot;).<br></p><p>Also, maybe some day we&#39;ll have normal type requirements ‚Äî something that has to be defined in a protocol, but does not turn it into a frankenprotocol than nobody can use anymore. That would be an appropriate use of the normal-looking keywords.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/913137f7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>‚Äúparameter‚Äù is a good thought.  On it‚Äôs own it seems like it‚Äôs missing something though.  But it gives me other ideas: ‚Äútypeparam‚Äù, ‚Äútype param&quot;, ‚Äútypeparameter‚Äù, or ‚Äútype parameter‚Äù.<br></p><p>Matt<br></p><p>&gt; On Dec 22, 2015, at 07:40, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 21 d√©c. 2015, at 17:57, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When you&#39;re actually implementing a generic function, the generic parameter is [snip]<br>&gt; <br>&gt; Here&#39;s a word with meaning: parameter. Everything else I&#39;ve seen sounds vague or approximate. Using the idea of a parameter would solidify the conceptual relationship between protocols-with-associated-types and generics.<br>&gt; <br>&gt; protocol P {<br>&gt;  parameter T<br>&gt; }<br>&gt; <br>&gt; Guillaume Lessard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:05 AM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ‚Äúparameter‚Äù is a good thought.  On it‚Äôs own it seems like it‚Äôs missing something though.  But it gives me other ideas: ‚Äútypeparam‚Äù, ‚Äútype param&quot;, ‚Äútypeparameter‚Äù, or ‚Äútype parameter‚Äù.<br></p><p><br>It‚Äôs not a parameter, though, because it does not vary the way a parameter does: a given type X cannot conform to a protocol with two different bindings for a given associated type.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On 22 d√©c. 2015, at 19:01, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 11:05 AM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ‚Äúparameter‚Äù is a good thought.  On it‚Äôs own it seems like it‚Äôs missing something though.  But it gives me other ideas: ‚Äútypeparam‚Äù, ‚Äútype param&quot;, ‚Äútypeparameter‚Äù, or ‚Äútype parameter‚Äù.<br>&gt; <br>&gt; <br>&gt; It‚Äôs not a parameter, though, because it does not vary the way a parameter does: a given type X cannot conform to a protocol with two different bindings for a given associated type.<br></p><p>Well, in the context of a generic function or generic type, we have ‚Äútype parameter‚Äù and ‚Äúgeneric parameter clauses‚Äù. Is a protocol&#39;s associated type truly so different that it requires a different name? Note that many people out there are calling a protocol-with-associated-type a ‚Äúgeneric protocol‚Äù.<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>Yes, true, it‚Äôs not quite a parameter because it can‚Äôt vary.  But in the sense that it‚Äôs a slot that you have to provide a value for, you might call it a parameter.  Having the syntax be ‚Äútype parameter‚Äù gives a further hint that there‚Äôs more to it than a regular parameter.<br></p><p>But having said that, everything in a protocol is a slot that you have to provide a value for, so that makes me think that just plain ‚Äútype‚Äù may be better after all, which is the way I‚Äôm now leaning.<br></p><p>‚Äúassociated type‚Äù has some good points too, e.g., that is what the feature is called.  It just seems a little redundant, and verbose.  We already know it‚Äôs associated because it‚Äôs inside the braces.  It doesn‚Äôt say anything about the nature of the association, which is: ‚Äúthis is something you have to fill in‚Äù.  I don‚Äôt see any problem in referring to the feature as associated types, but then having the syntax be just plain ‚Äútype‚Äù.<br></p><p>Matt<br></p><p><br>&gt; On Dec 22, 2015, at 18:01, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 11:05 AM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ‚Äúparameter‚Äù is a good thought.  On it‚Äôs own it seems like it‚Äôs missing something though.  But it gives me other ideas: ‚Äútypeparam‚Äù, ‚Äútype param&quot;, ‚Äútypeparameter‚Äù, or ‚Äútype parameter‚Äù.<br>&gt; <br>&gt; <br>&gt; It‚Äôs not a parameter, though, because it does not vary the way a parameter does: a given type X cannot conform to a protocol with two different bindings for a given associated type.<br>&gt; <br>&gt; 	- Doug<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; I don‚Äôt see any problem in referring to the feature as associated types, but then having the syntax be just plain ‚Äútype‚Äù.<br></p><p>I think it&#39;s been said before, but the problem with using a `type` keyword is that if you type &quot;swift type&quot; into Google (or any other search feature you might use for documentation), you&#39;re probably not going to get information about this feature specifically. &quot;swift associated&quot; or &quot;swift associatedtype&quot; are more likely to give you what you want.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities.  I think people will probably figure out that they need to search for ‚Äúswift protocol type‚Äù or whatever the final choice ends up being.<br></p><p>&gt; On Dec 22, 2015, at 20:54, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I don‚Äôt see any problem in referring to the feature as associated types, but then having the syntax be just plain ‚Äútype‚Äù.<br>&gt; <br>&gt; I think it&#39;s been said before, but the problem with using a `type` keyword is that if you type &quot;swift type&quot; into Google (or any other search feature you might use for documentation), you&#39;re probably not going to get information about this feature specifically. &quot;swift associated&quot; or &quot;swift associatedtype&quot; are more likely to give you what you want.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities. <br>+1<br>Choosing cryptic names because it&#39;s easier to find information about them is bad. With this argument, you can not only fight against removal of the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also demand that the language should be spelled &quot;Sweeft&quot;, and that framework functions should loose their meaningful names and get called by a UUID instead.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>&gt;&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities. <br>&gt; +1<br>&gt; Choosing cryptic names because it&#39;s easier to find information about them is bad. With this argument, you can not only fight against removal of the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also demand that the language should be spelled &quot;Sweeft&quot;, and that framework functions should loose their meaningful names and get called by a UUID instead.<br></p><p>I don&#39;t think the `associated` keyword is cryptic; I think it&#39;s *specific*. &quot;Associated type&quot; is the name of this feature. We tried bikeshedding it upthread, and didn&#39;t come up with anything better. If you&#39;re going to use a keyword related to the name &quot;associated type&quot;, that leaves you with `associated`, `type`, or `associatedtype`. Of these three, `type` is extremely vague (and also something we&#39;ve resisted taking as a keyword‚Äîsee the discussion about `SomeType.self` last week), `associatedtype` is an overlong, awkward concatenation of two words, and `associated` has neither of those failings. That&#39;s why I favor it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>+1 for associated<br></p><p>On Wed, Dec 23, 2015 at 10:08 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced<br>&gt; that design for googleability is the right ordering of priorities.<br>&gt; &gt; +1<br>&gt; &gt; Choosing cryptic names because it&#39;s easier to find information about<br>&gt; them is bad. With this argument, you can not only fight against removal of<br>&gt; the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also<br>&gt; demand that the language should be spelled &quot;Sweeft&quot;, and that framework<br>&gt; functions should loose their meaningful names and get called by a UUID<br>&gt; instead.<br>&gt;<br>&gt; I don&#39;t think the `associated` keyword is cryptic; I think it&#39;s<br>&gt; *specific*. &quot;Associated type&quot; is the name of this feature. We tried<br>&gt; bikeshedding it upthread, and didn&#39;t come up with anything better. If<br>&gt; you&#39;re going to use a keyword related to the name &quot;associated type&quot;, that<br>&gt; leaves you with `associated`, `type`, or `associatedtype`. Of these three,<br>&gt; `type` is extremely vague (and also something we&#39;ve resisted taking as a<br>&gt; keyword‚Äîsee the discussion about `SomeType.self` last week),<br>&gt; `associatedtype` is an overlong, awkward concatenation of two words, and<br>&gt; `associated` has neither of those failings. That&#39;s why I favor it.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/ada6964e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; &quot;Associated type&quot; is the name of this feature<br>The name of the concept is highly inexpressive, and I guess it&#39;s far easier to change the docs than to change the language‚Ä¶<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>Maybe you could use the phrase &quot;placeholder&quot; type. If you think about it.<br>typealias is a way of &quot;aliasing&quot; the type. i.e &quot;Type B is just another name<br>for Type C&quot;<br></p><p>Associated type I always found a bit confusing, associated with what ? A<br>placeholder type I feel explains it more plainly. Associated types are<br>nothing but placeholders.<br></p><p>So this is my example:<br></p><p>protocol Collection<br>{<br>    typeplaceholder T<br></p><p>    func first() -&gt; T?<br>}<br></p><p>class IntCollection: Collection<br>{<br>   typeplaceholder T = Int<br>}<br></p><p>potentially you could provide some sort of syntax for setting it in the<br>subclass part of the code.<br></p><p><br>protocol Collection<br>{<br>    typeplaceholder T<br></p><p>    func first() -&gt; T?<br>}<br></p><p>class IntCollection: Collection&lt;T:Int&gt; //The T type placeholder is now an<br>Int<br>{<br></p><p>}<br></p><p>class GenericCollection&lt;F&gt;: Collection&lt;T:F&gt; //The T type placeholder is now<br>what ever the generic F is set to.<br>{<br></p><p>}<br></p><p>On Wed, Dec 23, 2015 at 11:00 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; &quot;Associated type&quot; is the name of this feature<br>&gt; The name of the concept is highly inexpressive, and I guess it&#39;s far<br>&gt; easier to change the docs than to change the language‚Ä¶<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/8412b81e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>In fact why not just use the generics syntax with protocols ?  Anybody<br>implementing a &quot;Generic&quot; Protocol has to specify the types.<br></p><p>protocol Collection&lt;Key, Value &gt;<br>{<br></p><p>    func get(key: Key) -&gt; Value?<br>}<br></p><p>class StringCollection: Collection&lt;Key: String, Value: String&gt;<br>{<br></p><p>}<br></p><p>class GenericCollection&lt;Type&gt;: Collection&lt;Key: Type, Value: Type&gt;<br>{<br></p><p>}<br></p><p>On Wed, Dec 23, 2015 at 11:18 AM, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; Maybe you could use the phrase &quot;placeholder&quot; type. If you think about it.<br>&gt; typealias is a way of &quot;aliasing&quot; the type. i.e &quot;Type B is just another name<br>&gt; for Type C&quot;<br>&gt;<br>&gt; Associated type I always found a bit confusing, associated with what ? A<br>&gt; placeholder type I feel explains it more plainly. Associated types are<br>&gt; nothing but placeholders.<br>&gt;<br>&gt; So this is my example:<br>&gt;<br>&gt; protocol Collection<br>&gt; {<br>&gt;     typeplaceholder T<br>&gt;<br>&gt;     func first() -&gt; T?<br>&gt; }<br>&gt;<br>&gt; class IntCollection: Collection<br>&gt; {<br>&gt;    typeplaceholder T = Int<br>&gt; }<br>&gt;<br>&gt; potentially you could provide some sort of syntax for setting it in the<br>&gt; subclass part of the code.<br>&gt;<br>&gt;<br>&gt; protocol Collection<br>&gt; {<br>&gt;     typeplaceholder T<br>&gt;<br>&gt;     func first() -&gt; T?<br>&gt; }<br>&gt;<br>&gt; class IntCollection: Collection&lt;T:Int&gt; //The T type placeholder is now an<br>&gt; Int<br>&gt; {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; class GenericCollection&lt;F&gt;: Collection&lt;T:F&gt; //The T type placeholder is<br>&gt; now what ever the generic F is set to.<br>&gt; {<br>&gt;<br>&gt; }<br>&gt;<br>&gt; On Wed, Dec 23, 2015 at 11:00 AM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; &quot;Associated type&quot; is the name of this feature<br>&gt;&gt; The name of the concept is highly inexpressive, and I guess it&#39;s far<br>&gt;&gt; easier to change the docs than to change the language‚Ä¶<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ô£ø Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br></p><p><br></p><p>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/225c22c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; In fact why not just use the generics syntax with protocols ?  Anybody implementing a &quot;Generic&quot; Protocol has to specify the types.<br>That&#39;s a simple solution, but inconvenient:<br>One use case for placeholders (I don&#39;t use the official name here to propagate an alternative ;-) is when you have a types that depend on a parameter.<br>I&#39;m to lazy to look up a real example, but Array&lt;Int&gt; is naturally associated with an enumerator for Int ‚Äî and it is no fun to be forced to include such relationships all over the place.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;<br>&gt; &gt; In fact why not just use the generics syntax with protocols ?  Anybody<br>&gt; implementing a &quot;Generic&quot; Protocol has to specify the types.<br>&gt; That&#39;s a simple solution, but inconvenient:<br>&gt; One use case for placeholders (I don&#39;t use the official name here to<br>&gt; propagate an alternative ;-) is when you have a types that depend on a<br>&gt; parameter.<br>&gt; I&#39;m to lazy to look up a real example, but Array&lt;Int&gt; is naturally<br>&gt; associated with an enumerator for Int ‚Äî and it is no fun to be forced to<br>&gt; include such relationships all over the place.<br></p><p><br>So in my example with placeholders.<br></p><p>class GenericCollection&lt;Type&gt;: Collection&lt;Key: Type, Value: Type&gt;<br>{<br></p><p>}<br></p><p>Has already specified the type of the placeholder :) so subclasses don&#39;t<br>need to specify it. In this example the Key and Value type placeholders are<br>bound to whatever the Type is.<br></p><p>So in these examples<br></p><p>let items: GenericCollection&lt;Int&gt; = GenericCollection()<br></p><p>or<br></p><p>let items: [Int] = []<br></p><p>the Key and Value type placeholders would be Ints :) since the generic type<br>is an Int.<br></p><p><br>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/de60879f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 2:08 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities. <br>&gt;&gt; +1<br>&gt;&gt; Choosing cryptic names because it&#39;s easier to find information about them is bad. With this argument, you can not only fight against removal of the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also demand that the language should be spelled &quot;Sweeft&quot;, and that framework functions should loose their meaningful names and get called by a UUID instead.<br>&gt; <br>&gt; I don&#39;t think the `associated` keyword is cryptic; I think it&#39;s *specific*. &quot;Associated type&quot; is the name of this feature. We tried bikeshedding it upthread, and didn&#39;t come up with anything better. If you&#39;re going to use a keyword related to the name &quot;associated type&quot;, that leaves you with `associated`, `type`, or `associatedtype`. <br></p><p>Of the three, I prefer ‚Äúassociatedtype‚Äù.<br></p><p>We already have precedent for concatenated names in a very related sort of decl (typealias), and this will be a real keyword.<br></p><p><br>Here are how I see the pros and cons I see of these options:<br></p><p>type:<br>- Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br>- Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br>- Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br></p><p>associated:<br> - Vacuous: doesn‚Äôt mean anything on its own:  ‚Äúassociated Element‚Äù.<br> - Somewhat unfortunate as a keyword, but much less so than type.<br></p><p>associatedtype:<br> - Clean in context: ‚Äúassociatedtype Element‚Äù<br> - Obvious you wouldn‚Äôt want to use it in another context.<br> - Googlable, unambiguous<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:34 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here are how I see the pros and cons I see of these options:<br>&gt; <br>&gt; type:<br>&gt; - Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br>&gt; - Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br>&gt; - Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br>&gt; <br>&gt; associated:<br>&gt; - Vacuous: doesn‚Äôt mean anything on its own:  ‚Äúassociated Element‚Äù.<br>&gt; - Somewhat unfortunate as a keyword, but much less so than type.<br>&gt; <br>&gt; associatedtype:<br>&gt; - Clean in context: ‚Äúassociatedtype Element‚Äù<br>&gt; - Obvious you wouldn‚Äôt want to use it in another context.<br>&gt; - Googlable, unambiguous<br></p><p>Add to the ‚Äúassociatedtype‚Äù advantages that, unlike the other two, it passes the ‚Äúunfortunate keyword‚Äù test with flying colors. I don‚Äôt often want to name a variable ‚Äúassociatedtype‚Äù.<br></p><p>Cheers, P<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>And what are your feelings about: typestandin, typeplaceholder, or adoptedtype? How would you describe the functionality of these members if you weren&#39;t looking for a keyword?<br></p><p>-- E<br></p><p>&gt; On Dec 23, 2015, at 9:34 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:08 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities. <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; Choosing cryptic names because it&#39;s easier to find information about them is bad. With this argument, you can not only fight against removal of the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also demand that the language should be spelled &quot;Sweeft&quot;, and that framework functions should loose their meaningful names and get called by a UUID instead.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the `associated` keyword is cryptic; I think it&#39;s *specific*. &quot;Associated type&quot; is the name of this feature. We tried bikeshedding it upthread, and didn&#39;t come up with anything better. If you&#39;re going to use a keyword related to the name &quot;associated type&quot;, that leaves you with `associated`, `type`, or `associatedtype`. <br>&gt; <br>&gt; Of the three, I prefer ‚Äúassociatedtype‚Äù.<br>&gt; <br>&gt; We already have precedent for concatenated names in a very related sort of decl (typealias), and this will be a real keyword.<br>&gt; <br>&gt; <br>&gt; Here are how I see the pros and cons I see of these options:<br>&gt; <br>&gt; type:<br>&gt; - Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br>&gt; - Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br>&gt; - Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br>&gt; <br>&gt; associated:<br>&gt; - Vacuous: doesn‚Äôt mean anything on its own:  ‚Äúassociated Element‚Äù.<br>&gt; - Somewhat unfortunate as a keyword, but much less so than type.<br>&gt; <br>&gt; associatedtype:<br>&gt; - Clean in context: ‚Äúassociatedtype Element‚Äù<br>&gt; - Obvious you wouldn‚Äôt want to use it in another context.<br>&gt; - Googlable, unambiguous<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 9:59 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; And what are your feelings about: typestandin, typeplaceholder, or adoptedtype? How would you describe the functionality of these members if you weren&#39;t looking for a keyword?<br></p><p>These don‚Äôt really speak to me, just because they aren‚Äôt the terminology that people use to refer to these.  ‚Äústandin‚Äù and ‚Äúplaceholder‚Äù are also pretty vacuous.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>The thing is associated type means nothing to me, it&#39;s too technical. Placeholder type I think would be better even if it&#39;s only what we called it in the documentation <br></p><p>Sent from my iPhone<br></p><p>&gt; On 23 Dec 2015, at 20:35, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 9:59 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And what are your feelings about: typestandin, typeplaceholder, or adoptedtype? How would you describe the functionality of these members if you weren&#39;t looking for a keyword?<br>&gt; <br>&gt; These don‚Äôt really speak to me, just because they aren‚Äôt the terminology that people use to refer to these.  ‚Äústandin‚Äù and ‚Äúplaceholder‚Äù are also pretty vacuous.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 23, 2015, at 2:42 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The thing is associated type means nothing to me, it&#39;s too technical. Placeholder type I think would be better even if it&#39;s only what we called it in the documentation <br></p><p>Programming languages are technical and it has a very clear meaning in Swift.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 23 Dec 2015, at 20:35, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 9:59 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And what are your feelings about: typestandin, typeplaceholder, or adoptedtype? How would you describe the functionality of these members if you weren&#39;t looking for a keyword?<br>&gt;&gt; <br>&gt;&gt; These don‚Äôt really speak to me, just because they aren‚Äôt the terminology that people use to refer to these.  ‚Äústandin‚Äù and ‚Äúplaceholder‚Äù are also pretty vacuous.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>James or Erica (or someone else), can you explain what makes these types &quot;placeholders&quot;? I don&#39;t think of the other requirements in a protocol as &quot;placeholder properties&quot; or &quot;placeholder methods&quot;.<br></p><p>My explanation of these things is &quot;When a particular type X conforms to a protocol, you can ask about the types that X uses to implement the requirements of the protocol&quot;. I guess we could call them &quot;related types&quot; instead of &quot;associated types&quot;, but that doesn&#39;t seem significantly different.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 23, 2015, at 12:42, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The thing is associated type means nothing to me, it&#39;s too technical. Placeholder type I think would be better even if it&#39;s only what we called it in the documentation <br>&gt; <br>&gt; Sent from my iPhone<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 10:00:00pm</p></header><div class="content"><p>They are placeholders because in the protocol:<br></p><p>prtocotol Collection<br>{<br>  placeholder Item<br></p><p>  func first() -&gt; Item?<br> {<br> }<br>}<br></p><p>Item is a placeholder for a concrete type, at this moment this is a concept<br>&quot;A collection should return an item of a type&quot; but we don&#39;t know what that<br>type is as its a plaeholder for a type.<br></p><p>therefore in:<br></p><p>class IntCollection: Collection<br>{<br>   placeholder Item = Int<br>}<br></p><p>We are saying that the placeholder should now become a concrete type. In my<br>eyes associated types are nothing more than generics for protocols which in<br>turn could be argued is some kind of placeholder.<br></p><p>Associated type means nothing to me, associated to what ? A type could be<br>associated to many things like a variable, or a generic or whatever. A<br>placeholder to mean does what it says on the tin. If we moved to protocols<br>using a syntax closer to generics for classes then I think it would be<br>simpilar to grasp for beginners .<br></p><p>On Wed, Dec 23, 2015 at 9:35 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; James or Erica (or someone else), can you explain what makes these types<br>&gt; &quot;placeholders&quot;? I don&#39;t think of the other requirements in a protocol as<br>&gt; &quot;placeholder properties&quot; or &quot;placeholder methods&quot;.<br>&gt;<br>&gt; My explanation of these things is &quot;When a particular type X conforms to a<br>&gt; protocol, you can ask about the types that X uses to implement the<br>&gt; requirements of the protocol&quot;. I guess we could call them &quot;related types&quot;<br>&gt; instead of &quot;associated types&quot;, but that doesn&#39;t seem significantly<br>&gt; different.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; &gt; On Dec 23, 2015, at 12:42, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The thing is associated type means nothing to me, it&#39;s too technical.<br>&gt; Placeholder type I think would be better even if it&#39;s only what we called<br>&gt; it in the documentation<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/e7ff4369/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>If we made class, structs, protocols and functions use the same generics<br>syntax then I think it would make it more consistent rather than arguing<br>about which keyword to use. I am for-ever being tripped up by lack of<br>generics in the language.<br></p><p>class Array&lt;T&gt;<br>{<br>func first() -&gt; T?<br>}<br></p><p>struct Node&lt;Value&gt;<br>{<br>var value: Value<br>}<br></p><p>Array&lt;Int&gt;()<br>Node&lt;Int&gt;()<br></p><p>or<br></p><p>func makeACell&lt;T&gt;() -&gt; T<br>{<br>}<br></p><p>makeACell&lt;MyCell&gt;()<br></p><p>or<br></p><p>protocol Collection&lt;Item&gt;<br>{<br>func first() -&gt; Item?<br>}<br></p><p>class IntBag : Collection&lt;Int&gt; //We bind protocol &quot;associated type&quot; using<br>generic syntax when subclassing. In this case we are saying Item should be<br>type Int<br>{<br>}<br></p><p>class Array&lt;Item&gt;: Collection&lt;Item&gt; //We bind protocol &quot;associated type&quot;<br>using generic syntax when subclassing. In this case we are saying Item<br>should be the same type as the generic type for Array<br>{<br>}<br></p><p>IntBag()<br>Array&lt;Int&gt;()<br></p><p><br>On Wed, Dec 23, 2015 at 10:58 PM, James Campbell &lt;james at supmenow.com&gt; wrote:<br></p><p>&gt; They are placeholders because in the protocol:<br>&gt;<br>&gt; prtocotol Collection<br>&gt; {<br>&gt;   placeholder Item<br>&gt;<br>&gt;   func first() -&gt; Item?<br>&gt;  {<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; Item is a placeholder for a concrete type, at this moment this is a<br>&gt; concept &quot;A collection should return an item of a type&quot; but we don&#39;t know<br>&gt; what that type is as its a plaeholder for a type.<br>&gt;<br>&gt; therefore in:<br>&gt;<br>&gt; class IntCollection: Collection<br>&gt; {<br>&gt;    placeholder Item = Int<br>&gt; }<br>&gt;<br>&gt; We are saying that the placeholder should now become a concrete type. In<br>&gt; my eyes associated types are nothing more than generics for protocols which<br>&gt; in turn could be argued is some kind of placeholder.<br>&gt;<br>&gt; Associated type means nothing to me, associated to what ? A type could be<br>&gt; associated to many things like a variable, or a generic or whatever. A<br>&gt; placeholder to mean does what it says on the tin. If we moved to protocols<br>&gt; using a syntax closer to generics for classes then I think it would be<br>&gt; simpilar to grasp for beginners .<br>&gt;<br>&gt; On Wed, Dec 23, 2015 at 9:35 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; James or Erica (or someone else), can you explain what makes these types<br>&gt;&gt; &quot;placeholders&quot;? I don&#39;t think of the other requirements in a protocol as<br>&gt;&gt; &quot;placeholder properties&quot; or &quot;placeholder methods&quot;.<br>&gt;&gt;<br>&gt;&gt; My explanation of these things is &quot;When a particular type X conforms to a<br>&gt;&gt; protocol, you can ask about the types that X uses to implement the<br>&gt;&gt; requirements of the protocol&quot;. I guess we could call them &quot;related types&quot;<br>&gt;&gt; instead of &quot;associated types&quot;, but that doesn&#39;t seem significantly<br>&gt;&gt; different.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 23, 2015, at 12:42, James Campbell via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The thing is associated type means nothing to me, it&#39;s too technical.<br>&gt;&gt; Placeholder type I think would be better even if it&#39;s only what we called<br>&gt;&gt; it in the documentation<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ô£ø Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br></p><p><br></p><p>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/a2e206dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>December 26, 2015 at 03:00:00pm</p></header><div class="content"><p>There&#39;s a problem here because associated types aren&#39;t the same as generics.<br></p><p>I&#39;ve been looking this up a lot recently because I&#39;ve been trying to create<br>a delegate protocol for a generic type. The GenericType&lt;X&gt; requires a<br>GenericTypeDelegate&lt;X&gt; and Swift 2 protocols just don&#39;t support those yet;<br>the best workaround of the moment seems to be a wrapper type which wraps<br>the delegate&#39;s functions in closures.<br></p><p>This is a different concept to associated types. I&#39;ve seen a couple of<br>examples around; the one I&#39;m remembering at the moment involves a protocol<br>for Animals requiring them to have an associated Food type. A Cow could<br>thus be defined as a type implementing the Animal protocol, with an<br>associated type of Grass; this would be very different to an Animal being a<br>generic type, and a Cow being (perhaps typealiased as) an Animal&lt;Grass&gt;.<br>With the associated type, the Cow is known to always eat Grass; with the<br>generic type, every function is written to handle all foodstuffs.<br></p><p>So, no, the two different syntaxes are required - but protocols with<br>generic parameters (is that the right term for e.g. Grass in<br>Animal&lt;Grass&gt;?) would be a good addition to the language.<br></p><p><br>On Wed, Dec 23, 2015 at 11:06 PM, James Campbell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If we made class, structs, protocols and functions use the same generics<br>&gt; syntax then I think it would make it more consistent rather than arguing<br>&gt; about which keyword to use. I am for-ever being tripped up by lack of<br>&gt; generics in the language.<br>&gt;<br>&gt; class Array&lt;T&gt;<br>&gt; {<br>&gt; func first() -&gt; T?<br>&gt; }<br>&gt;<br>&gt; struct Node&lt;Value&gt;<br>&gt; {<br>&gt; var value: Value<br>&gt; }<br>&gt;<br>&gt; Array&lt;Int&gt;()<br>&gt; Node&lt;Int&gt;()<br>&gt;<br>&gt; or<br>&gt;<br>&gt; func makeACell&lt;T&gt;() -&gt; T<br>&gt; {<br>&gt; }<br>&gt;<br>&gt; makeACell&lt;MyCell&gt;()<br>&gt;<br>&gt; or<br>&gt;<br>&gt; protocol Collection&lt;Item&gt;<br>&gt; {<br>&gt; func first() -&gt; Item?<br>&gt; }<br>&gt;<br>&gt; class IntBag : Collection&lt;Int&gt; //We bind protocol &quot;associated type&quot; using<br>&gt; generic syntax when subclassing. In this case we are saying Item should be<br>&gt; type Int<br>&gt; {<br>&gt; }<br>&gt;<br>&gt; class Array&lt;Item&gt;: Collection&lt;Item&gt; //We bind protocol &quot;associated type&quot;<br>&gt; using generic syntax when subclassing. In this case we are saying Item<br>&gt; should be the same type as the generic type for Array<br>&gt; {<br>&gt; }<br>&gt;<br>&gt; IntBag()<br>&gt; Array&lt;Int&gt;()<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 23, 2015 at 10:58 PM, James Campbell &lt;james at supmenow.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; They are placeholders because in the protocol:<br>&gt;&gt;<br>&gt;&gt; prtocotol Collection<br>&gt;&gt; {<br>&gt;&gt;   placeholder Item<br>&gt;&gt;<br>&gt;&gt;   func first() -&gt; Item?<br>&gt;&gt;  {<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Item is a placeholder for a concrete type, at this moment this is a<br>&gt;&gt; concept &quot;A collection should return an item of a type&quot; but we don&#39;t know<br>&gt;&gt; what that type is as its a plaeholder for a type.<br>&gt;&gt;<br>&gt;&gt; therefore in:<br>&gt;&gt;<br>&gt;&gt; class IntCollection: Collection<br>&gt;&gt; {<br>&gt;&gt;    placeholder Item = Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; We are saying that the placeholder should now become a concrete type. In<br>&gt;&gt; my eyes associated types are nothing more than generics for protocols which<br>&gt;&gt; in turn could be argued is some kind of placeholder.<br>&gt;&gt;<br>&gt;&gt; Associated type means nothing to me, associated to what ? A type could be<br>&gt;&gt; associated to many things like a variable, or a generic or whatever. A<br>&gt;&gt; placeholder to mean does what it says on the tin. If we moved to protocols<br>&gt;&gt; using a syntax closer to generics for classes then I think it would be<br>&gt;&gt; simpilar to grasp for beginners .<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 23, 2015 at 9:35 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; James or Erica (or someone else), can you explain what makes these types<br>&gt;&gt;&gt; &quot;placeholders&quot;? I don&#39;t think of the other requirements in a protocol as<br>&gt;&gt;&gt; &quot;placeholder properties&quot; or &quot;placeholder methods&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My explanation of these things is &quot;When a particular type X conforms to<br>&gt;&gt;&gt; a protocol, you can ask about the types that X uses to implement the<br>&gt;&gt;&gt; requirements of the protocol&quot;. I guess we could call them &quot;related types&quot;<br>&gt;&gt;&gt; instead of &quot;associated types&quot;, but that doesn&#39;t seem significantly<br>&gt;&gt;&gt; different.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 23, 2015, at 12:42, James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The thing is associated type means nothing to me, it&#39;s too technical.<br>&gt;&gt;&gt; Placeholder type I think would be better even if it&#39;s only what we called<br>&gt;&gt;&gt; it in the documentation<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ô£ø Wizard<br>&gt;&gt; james at supmenow.com<br>&gt;&gt; +44 7523 279 698<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ô£ø Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/011b030a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 26, 2015 at 03:00:00pm</p></header><div class="content"><p>What about templatetype ? This could also work if we started referring<br>generics as Templates :) and extended them to protocols and functions.<br></p><p><br>On Sat, Dec 26, 2015 at 3:15 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt;<br>wrote:<br></p><p>&gt; There&#39;s a problem here because associated types aren&#39;t the same as<br>&gt; generics.<br>&gt;<br>&gt; I&#39;ve been looking this up a lot recently because I&#39;ve been trying to<br>&gt; create a delegate protocol for a generic type. The GenericType&lt;X&gt; requires<br>&gt; a GenericTypeDelegate&lt;X&gt; and Swift 2 protocols just don&#39;t support those<br>&gt; yet; the best workaround of the moment seems to be a wrapper type which<br>&gt; wraps the delegate&#39;s functions in closures.<br>&gt;<br>&gt; This is a different concept to associated types. I&#39;ve seen a couple of<br>&gt; examples around; the one I&#39;m remembering at the moment involves a protocol<br>&gt; for Animals requiring them to have an associated Food type. A Cow could<br>&gt; thus be defined as a type implementing the Animal protocol, with an<br>&gt; associated type of Grass; this would be very different to an Animal being a<br>&gt; generic type, and a Cow being (perhaps typealiased as) an Animal&lt;Grass&gt;.<br>&gt; With the associated type, the Cow is known to always eat Grass; with the<br>&gt; generic type, every function is written to handle all foodstuffs.<br>&gt;<br>&gt; So, no, the two different syntaxes are required - but protocols with<br>&gt; generic parameters (is that the right term for e.g. Grass in<br>&gt; Animal&lt;Grass&gt;?) would be a good addition to the language.<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 23, 2015 at 11:06 PM, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; If we made class, structs, protocols and functions use the same generics<br>&gt;&gt; syntax then I think it would make it more consistent rather than arguing<br>&gt;&gt; about which keyword to use. I am for-ever being tripped up by lack of<br>&gt;&gt; generics in the language.<br>&gt;&gt;<br>&gt;&gt; class Array&lt;T&gt;<br>&gt;&gt; {<br>&gt;&gt; func first() -&gt; T?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Node&lt;Value&gt;<br>&gt;&gt; {<br>&gt;&gt; var value: Value<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Array&lt;Int&gt;()<br>&gt;&gt; Node&lt;Int&gt;()<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt; func makeACell&lt;T&gt;() -&gt; T<br>&gt;&gt; {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; makeACell&lt;MyCell&gt;()<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt; protocol Collection&lt;Item&gt;<br>&gt;&gt; {<br>&gt;&gt; func first() -&gt; Item?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class IntBag : Collection&lt;Int&gt; //We bind protocol &quot;associated type&quot; using<br>&gt;&gt; generic syntax when subclassing. In this case we are saying Item should be<br>&gt;&gt; type Int<br>&gt;&gt; {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Array&lt;Item&gt;: Collection&lt;Item&gt; //We bind protocol &quot;associated type&quot;<br>&gt;&gt; using generic syntax when subclassing. In this case we are saying Item<br>&gt;&gt; should be the same type as the generic type for Array<br>&gt;&gt; {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; IntBag()<br>&gt;&gt; Array&lt;Int&gt;()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 23, 2015 at 10:58 PM, James Campbell &lt;james at supmenow.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; They are placeholders because in the protocol:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; prtocotol Collection<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   placeholder Item<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   func first() -&gt; Item?<br>&gt;&gt;&gt;  {<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Item is a placeholder for a concrete type, at this moment this is a<br>&gt;&gt;&gt; concept &quot;A collection should return an item of a type&quot; but we don&#39;t know<br>&gt;&gt;&gt; what that type is as its a plaeholder for a type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; therefore in:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class IntCollection: Collection<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;    placeholder Item = Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We are saying that the placeholder should now become a concrete type. In<br>&gt;&gt;&gt; my eyes associated types are nothing more than generics for protocols which<br>&gt;&gt;&gt; in turn could be argued is some kind of placeholder.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Associated type means nothing to me, associated to what ? A type could<br>&gt;&gt;&gt; be associated to many things like a variable, or a generic or whatever. A<br>&gt;&gt;&gt; placeholder to mean does what it says on the tin. If we moved to protocols<br>&gt;&gt;&gt; using a syntax closer to generics for classes then I think it would be<br>&gt;&gt;&gt; simpilar to grasp for beginners .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 23, 2015 at 9:35 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; James or Erica (or someone else), can you explain what makes these<br>&gt;&gt;&gt;&gt; types &quot;placeholders&quot;? I don&#39;t think of the other requirements in a protocol<br>&gt;&gt;&gt;&gt; as &quot;placeholder properties&quot; or &quot;placeholder methods&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My explanation of these things is &quot;When a particular type X conforms to<br>&gt;&gt;&gt;&gt; a protocol, you can ask about the types that X uses to implement the<br>&gt;&gt;&gt;&gt; requirements of the protocol&quot;. I guess we could call them &quot;related types&quot;<br>&gt;&gt;&gt;&gt; instead of &quot;associated types&quot;, but that doesn&#39;t seem significantly<br>&gt;&gt;&gt;&gt; different.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Dec 23, 2015, at 12:42, James Campbell via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The thing is associated type means nothing to me, it&#39;s too technical.<br>&gt;&gt;&gt;&gt; Placeholder type I think would be better even if it&#39;s only what we called<br>&gt;&gt;&gt;&gt; it in the documentation<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ô£ø Wizard<br>&gt;&gt;&gt; james at supmenow.com<br>&gt;&gt;&gt; +44 7523 279 698<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ô£ø Wizard<br>&gt;&gt; james at supmenow.com<br>&gt;&gt; +44 7523 279 698<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/842847be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 8:34 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:08 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I did see that point made earlier in the thread, but I‚Äôm not convinced that design for googleability is the right ordering of priorities. <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; Choosing cryptic names because it&#39;s easier to find information about them is bad. With this argument, you can not only fight against removal of the NextStep prefix (Data, Number, Date‚Ä¶ try googling that), but also demand that the language should be spelled &quot;Sweeft&quot;, and that framework functions should loose their meaningful names and get called by a UUID instead.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the `associated` keyword is cryptic; I think it&#39;s *specific*. &quot;Associated type&quot; is the name of this feature. We tried bikeshedding it upthread, and didn&#39;t come up with anything better. If you&#39;re going to use a keyword related to the name &quot;associated type&quot;, that leaves you with `associated`, `type`, or `associatedtype`. <br>&gt; <br>&gt; Of the three, I prefer ‚Äúassociatedtype‚Äù.<br>&gt; <br>&gt; We already have precedent for concatenated names in a very related sort of decl (typealias), and this will be a real keyword.<br>&gt; <br>&gt; <br>&gt; Here are how I see the pros and cons I see of these options:<br>&gt; <br>&gt; type:<br>&gt; - Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br></p><p>I don‚Äôt understand how that‚Äôs different from, e.g.<br></p><p>	init()<br></p><p>or<br></p><p>        var x: Int<br></p><p>which will both show up in protocol declarations.  Could you explain?<br></p><p>&gt; - Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br></p><p>Could you explain what you mean by this?  If anything I see this exactly opposite.  It‚Äôs a requirement for a type, *any* kind of type, be it struct, class, enum, non-nominal type such as tuple or function, whatever‚Äîso long as it satisfies the constraints placed it.  That‚Äôs about as generic as one can get.<br></p><p>&gt; - Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br></p><p>I don‚Äôt see how this would actually cause a problem if it was contextual.  There‚Äôs no reason one couldn‚Äôt name a property ‚Äútype‚Äù if one wanted to.  These two things will appear in *very* different contexts, so I don‚Äôt think humans would have a hard time de-contextualizing.<br></p><p>&gt; associated:<br>&gt; - Vacuous: doesn‚Äôt mean anything on its own:  ‚Äúassociated Element‚Äù.<br></p><p>Heh, now that I look at that, provided we can be consistent about only UpperCamelCasing type names it actually might be sufficiently communicative.  Just a thought.<br></p><p>&gt; - Somewhat unfortunate as a keyword, but much less so than type.<br>&gt; <br>&gt; associatedtype:<br>&gt; - Clean in context: ‚Äúassociatedtype Element‚Äù<br>&gt; - Obvious you wouldn‚Äôt want to use it in another context.<br>&gt; - Googlable, unambiguous<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>On Dec 23, 2015, at 10:25 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; Of the three, I prefer ‚Äúassociatedtype‚Äù.<br>&gt;&gt; <br>&gt;&gt; We already have precedent for concatenated names in a very related sort of decl (typealias), and this will be a real keyword.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here are how I see the pros and cons I see of these options:<br>&gt;&gt; <br>&gt;&gt; type:<br>&gt;&gt; - Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br>&gt; <br>&gt; I don‚Äôt understand how that‚Äôs different from, e.g.<br>&gt; <br>&gt; 	init()<br>&gt; <br>&gt; or<br>&gt; <br>&gt;        var x: Int<br>&gt; <br>&gt; which will both show up in protocol declarations.  Could you explain?<br></p><p>It follows from the same logic that makes ‚Äútypealias‚Äù have a long name, instead of being named ‚Äútype‚Äù or ‚Äútyp‚Äù ;-)<br></p><p>typealiases and associated types are both *much* less frequently used than variables or functions.  var and func make sense to keep very short because of their frequency, and because every swift programmer is expected to memorize what they do.  ‚Äúinit‚Äù is less defensible on these terms, because it is more rare, but is clear, and shares commonality with some ObjC heritage.<br></p><p>If you compare typealiases and associated types, these are *much* more infrequently used than any of these three, they are effectively a advanced generics feature.  Because they are less frequent, people shouldn‚Äôt be expected to memorize what they are, and googlability does matter.<br></p><p><br>&gt;&gt; - Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br>&gt; <br>&gt; Could you explain what you mean by this?  If anything I see this exactly opposite.  It‚Äôs a requirement for a type, *any* kind of type, be it struct, class, enum, non-nominal type such as tuple or function, whatever‚Äîso long as it satisfies the constraints placed it.  That‚Äôs about as generic as one can get.<br></p><p>This is a declaration of a requirement of a type.  This is not declaring a type.  This keyword cannot be used in any other place in the grammar.  People would reasonably expect to use a keyword like ‚Äútype‚Äù elsewhere.  This keyword is completely different than init/var/func in that sense.<br></p><p>&gt;&gt; - Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br>&gt; <br>&gt; I don‚Äôt see how this would actually cause a problem if it was contextual.  <br></p><p>Besides the parser ambiguities?  We could probably force it to work, but it would be unnecessary complexity.  All statements and decls should start with a keyword.  This enables attributes and declmodifiers to ‚Äújust work‚Äù, you lose that if you play games with context sensitive keywords.<br></p><p>&gt; There‚Äôs no reason one couldn‚Äôt name a property ‚Äútype‚Äù if one wanted to.  These two things will appear in *very* different contexts, so I don‚Äôt think humans would have a hard time de-contextualizing.<br></p><p>I agree, that‚Äôs exactly why I don‚Äôt think it should be called ‚Äútype‚Äù.  They are very different things.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 23, 2015, at 10:25 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; Of the three, I prefer ‚Äúassociatedtype‚Äù.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We already have precedent for concatenated names in a very related sort of decl (typealias), and this will be a real keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are how I see the pros and cons I see of these options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type:<br>&gt;&gt;&gt; - Overly short, particularly given the infrequency of these decls, the common case of ‚Äútype Element‚Äù will be weird floating around given its lack of weight.<br>&gt;&gt; <br>&gt;&gt; I don‚Äôt understand how that‚Äôs different from, e.g.<br>&gt;&gt; <br>&gt;&gt; 	init()<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt;       var x: Int<br>&gt;&gt; <br>&gt;&gt; which will both show up in protocol declarations.  Could you explain?<br>&gt; <br>&gt; It follows from the same logic that makes ‚Äútypealias‚Äù have a long name, instead of being named ‚Äútype‚Äù or ‚Äútyp‚Äù ;-)<br>&gt; <br>&gt; typealiases and associated types are both *much* less frequently used than variables or functions.  var and func make sense to keep very short because of their frequency, and because every swift programmer is expected to memorize what they do.  ‚Äúinit‚Äù is less defensible on these terms, because it is more rare, but is clear, and shares commonality with some ObjC heritage.<br>&gt; <br>&gt; If you compare typealiases and associated types, these are *much* more infrequently used than any of these three, they are effectively a advanced generics feature.  Because they are less frequent, people shouldn‚Äôt be expected to memorize what they are, and googlability does matter.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; - Overly unclear.  This is a very specific kind of type, not a generic type you can use in other contexts.<br>&gt;&gt; <br>&gt;&gt; Could you explain what you mean by this?  If anything I see this exactly opposite.  It‚Äôs a requirement for a type, *any* kind of type, be it struct, class, enum, non-nominal type such as tuple or function, whatever‚Äîso long as it satisfies the constraints placed it.  That‚Äôs about as generic as one can get.<br>&gt; <br>&gt; This is a declaration of a requirement of a type.  This is not declaring a type.  This keyword cannot be used in any other place in the grammar.  People would reasonably expect to use a keyword like ‚Äútype‚Äù elsewhere.  This keyword is completely different than init/var/func in that sense.<br>&gt; <br>&gt;&gt;&gt; - Unfortunate keyword.  Among other things it would make writing compilers in swift a pain :-), but again, people would want to use this in other places.<br>&gt;&gt; <br>&gt;&gt; I don‚Äôt see how this would actually cause a problem if it was contextual.  <br>&gt; <br>&gt; Besides the parser ambiguities?  We could probably force it to work, but it would be unnecessary complexity.  All statements and decls should start with a keyword.  This enables attributes and declmodifiers to ‚Äújust work‚Äù, you lose that if you play games with context sensitive keywords.<br>&gt; <br>&gt;&gt; There‚Äôs no reason one couldn‚Äôt name a property ‚Äútype‚Äù if one wanted to.  These two things will appear in *very* different contexts, so I don‚Äôt think humans would have a hard time de-contextualizing.<br>&gt; <br>&gt; I agree, that‚Äôs exactly why I don‚Äôt think it should be called ‚Äútype‚Äù.  They are very different things.<br></p><p>Thanks for explaining, Chris.<br></p><p>-Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>I don‚Äôt understand this argument about googleability of ‚Äútype‚Äù being a problem. All of the errors and documentation talk about ‚Äúassociated type‚Äù and having the word ‚Äútype‚Äù literally visually associated with the word ‚Äúprotocol‚Äù right there in the code I‚Äôm looking at makes perfect sense to me.<br></p><p>Since all of the error messages say ‚Äúassociated type‚Äù, I‚Äôd be googling a phrase that includes the error message somehow such as ‚Äúswift associated type‚Äù or ‚Äúswift protocol type‚Äù or something else and I‚Äôd almost certainly land on the right documentation no matter what the keyword is.<br></p><p>The keyword doesn‚Äôt matter much as long as the error messages can be searched for.<br></p><p>All that said, though, the single most confusing aspect of associated types, for me, was that ‚Äútypealias‚Äù allowed me to specify a default type - and because of that *one* thing, I initially thought it behaved exactly like ‚Äútypealias‚Äù when outside of a protocol and did not understand the relationship for quite awhile. Frankly, I think this whole mess *could* be solved simply by not allowing ‚Äúdefault‚Äù types when using the typealias keyword in a protocol. In that case, attempting to do so would generate an error, and then searching for that error would lead to an explanation of what ‚Äútypealias‚Äù really means when inside of a protocol and a whole ton of confusion could be avoided from the start - without changing any keywords.<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Dec 22, 2015, at 10:54 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I don‚Äôt see any problem in referring to the feature as associated types, but then having the syntax be just plain ‚Äútype‚Äù.<br>&gt; <br>&gt; I think it&#39;s been said before, but the problem with using a `type` keyword is that if you type &quot;swift type&quot; into Google (or any other search feature you might use for documentation), you&#39;re probably not going to get information about this feature specifically. &quot;swift associated&quot; or &quot;swift associatedtype&quot; are more likely to give you what you want.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Lo√Øc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>I like placeholder too.<br>However, it also suffers from the lack of ‚Äútype‚Äù in it.<br></p><p>So, the real comparison is between:<br>placeholder ‚Äî associated<br>placholdertype ‚Äî associatedtype <br></p><p>&gt; On Dec 20, 2015, at 10:06 AM, Andrew Hoos &lt;andrewjhoos at gmail.com&gt; wrote:<br>&gt; <br>&gt; I second placeholder as the most rational keyword. Every description of the distinct usage of type alias refers to is a placeholder type. placeholder is one word(circumventingCase_issues) and is more descriptive of what it is than associated*. Seems like an easy win. Is there a some reason I am missing why *type* or associated* are better keyword fits?<br>&gt; <br>&gt; Andrew Hoos<br>&gt; <br>&gt;&gt; On Dec 19, 2015, at 10:07, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; snake_cases are un-Swifty<br>&gt;&gt; amen.<br>&gt;&gt; <br>&gt;&gt; My first thought for a name was &quot;placeholder&quot;, and I just saw that this was used in the description of the concept as well‚Ä¶ so maybe this would be an option?<br>&gt;&gt; <br>&gt;&gt; Tino<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On 19 Dec 2015, at 18:46, Lo√Øc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br></p><p>I would be fine with either &quot;associatedtype&quot;, &quot;typeassociation&quot; or &quot;associated&quot; but &quot;associatedtype&quot; is my favorite.<br></p><p>&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br></p><p>Not sure if that has been proposed before but &quot;assoctype&quot; might be another option that still includes the word &quot;type&quot; but is a bit shorter.<br>But personally I&#39;d prefer &quot;associatedtype&quot; since it&#39;s clearer and it&#39;s not a keyword that is used often enough for the shortening to be worth it.<br></p><p>- Janosch<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>Another spontaneous idea (not sure weather I actually like it ‚Äî take it as brainstorming):<br>Variable deklarations have the form<br>thatIsTheName: ThatIsWhatIAm<br>so the ambiguity could be resolved by<br>ElementType: typealias<br>which would say &quot;ElementType is a associated type&quot;, like<br>let i: Int<br>says &quot;i is an integer&quot;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Lo√Øc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>December 20, 2015 at 11:00:00am</p></header><div class="content"><p>-1<br>I understand the idea. But we would still need a replacement for ‚Äútypealias‚Äù because ‚ÄúElement: typealias‚Äù says ‚ÄúElement is a type alias‚Äù and not ‚ÄúElement is an associated type‚Äù. <br>Also, it would be difficult to add inheritance clauses and default values. <br>‚ÄúElement is an associated type that conforms to SequenceType, and is an Array of Int by default‚Äù<br>is currently<br>typealias Element : SequenceType = Array&lt;Int&gt;<br>but I don‚Äôt see how it could be written with your proposed syntax.<br></p><p>- Lo√Øc<br></p><p>&gt; On Dec 19, 2015, at 11:52 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Another spontaneous idea (not sure weather I actually like it ‚Äî take it as brainstorming):<br>&gt; Variable deklarations have the form<br>&gt; thatIsTheName: ThatIsWhatIAm<br>&gt; so the ambiguity could be resolved by<br>&gt; ElementType: typealias<br>&gt; which would say &quot;ElementType is a associated type&quot;, like<br>&gt; let i: Int<br>&gt; says &quot;i is an integer&quot;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 19, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; Maybe [some person] could make a quick poll and see which one developers prefer? üòÅ (after they read this email)<br></p><p>Ask. Receive.<br></p><p>https://www.surveymonkey.com/r/S8F59XF &lt;https://www.surveymonkey.com/r/S8F59XF&gt;<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/06f6efbb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 20, 2015 at 05:00:00pm</p></header><div class="content"><p>Aren&#39;t we bikeshedding here? These are all good names; I think we can pick one, and leave the final choice to the core team.<br></p><p>My personal preference is for something like ‚Äúassociated type X‚Äù or ‚Äúassociated typealias X‚Äù ‚Äî no need for an underscore when you can require a space. Right now ‚Äútypealias‚Äù is probably the word to use, although if Swift later introduces ‚Äútype‚Äù, that would be a better choice. And I see ‚Äúassociated‚Äù as a context-specific modifier anyway; could even be spelled ‚Äú@associated‚Äù (I&#39;m still unclear about the rules about @/no-@).<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccbc60826cca6a6f9c527b671cdad531?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Lo√Øc Lecrenier</string> &lt;loiclecrenier at icloud.com&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Aren&#39;t we bikeshedding here? These are all good names; I think we can pick one, and leave the final choice to the core team.<br></p><p>Yes, we are :(<br>I was reluctant to start this thread, but I think it‚Äôs worse if the core team has this debate during the review.<br>I promise I‚Äôll choose a keyword before the end of the week (and it will most likely be requiredtype)<br></p><p>Lo√Øc<br></p><p>&gt; My personal preference is for something like ‚Äúassociated type X‚Äù or ‚Äúassociated typealias X‚Äù ‚Äî no need for an underscore when you can require a space. Right now ‚Äútypealias‚Äù is probably the word to use, although if Swift later introduces ‚Äútype‚Äù, that would be a better choice. And I see ‚Äúassociated‚Äù as a context-specific modifier anyway; could even be spelled ‚Äú@associated‚Äù (I&#39;m still unclear about the rules about @/no-@).<br>&gt; <br>&gt; A.<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>+1 for `type`, it is consistent with `func`, `var` and `init`. It looks good to me.<br></p><p>eg:<br></p><p>protocol Stream {<br>    type Payload<br>    var ready: Bool { get }<br>    func read() -&gt; Payload?<br>}<br></p><p>protocol Collection {<br>    type Element<br>    var count: Int { get }<br>    func contains(element: Element) -&gt; Bool<br>}<br></p><p><br>-- <br>Pierre<br></p><p>&gt; Le 19 d√©c. 2015 √† 18:46, Lo√Øc Lecrenier via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I‚Äôm starting a new thread for this proposal https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br>&gt; <br>&gt; So far, everybody agreed that using distinct keywords for type alias and associated type declarations is a good idea.<br>&gt; However, some people think that ‚Äúassociated‚Äù is not an ideal replacement because it is too vague.<br>&gt; I would like to choose a better keyword before the review, but I‚Äôm struggling to find a good replacement. <br>&gt; <br>&gt; So, here are some keywords that were proposed by the community.<br>&gt; <br>&gt; 1. associated_type<br>&gt; This is the original proposed keyword. It is extremely clear, but snake_cases are un-Swifty.<br>&gt; <br>&gt; 2. associatedtype (or typeassociation)<br>&gt; This was the first alternative to associated_type. Its purpose is still extremely clear.<br>&gt; I like it a lot, but it is a bit long and difficult to read.<br>&gt; <br>&gt; 3. associated<br>&gt; This is the keyword I chose for the proposal because it was the most well-received initially. <br>&gt; It is quite short, very different from ‚Äútypealias&quot;, and sounds good. However, it is also vaguer.<br>&gt; Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it, and it‚Äôs unclear what it declares.<br>&gt; For example, one could think that it is an associated *value* and write <br>&gt; protocol FixedSizeCollectionProtocol {<br>&gt; 	associated size : Int<br>&gt; }<br>&gt; Although honestly I doubt many people would write that. <br>&gt; <br>&gt; 4. withtype (or needstype)<br>&gt; It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some concept of association thanks to ‚Äúwith‚Äù. I like it. <br>&gt; But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br>&gt; <br>&gt; 5. type<br>&gt; This keyword was proposed by several people, but I strongly dislike it.<br>&gt; It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and ‚Äúclass‚Äù keywords for type-level members.<br>&gt; I think the fact that it was proposed for two completely different purposes shows that it is too abstract.<br>&gt; It would make searching for help more difficult because of its bad googleability.<br>&gt; <br>&gt; <br>&gt; Personally, I would like to either keep ‚Äúassociated‚Äù, or use ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br>&gt; <br>&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>&gt; Bonus) Maybe some twitter-famous person could make a quick poll and see which one developers prefer? üòÅ (after they read this email)<br>&gt; I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake) followers will give me a lot of information.  <br>&gt; <br>&gt; Lo√Øc<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/3e086285/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>I think we should use &quot;placeholder&quot; it more accurately describes what it<br>does. For a bigger change then I would propose my protocol generics idea.<br></p><p>On Wed, Dec 23, 2015 at 12:50 PM, Pierre Monod-Broca via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for `type`, it is consistent with `func`, `var` and `init`. It looks<br>&gt; good to me.<br>&gt;<br>&gt; eg:<br>&gt;<br>&gt; protocol Stream {<br>&gt;     type Payload<br>&gt;     var ready: Bool { get }<br>&gt;     func read() -&gt; Payload?<br>&gt; }<br>&gt;<br>&gt; protocol Collection {<br>&gt;     type Element<br>&gt;     var count: Int { get }<br>&gt;     func contains(element: Element) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Pierre<br>&gt;<br>&gt; Le 19 d√©c. 2015 √† 18:46, Lo√Øc Lecrenier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a √©crit :<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I‚Äôm starting a new thread for this proposal<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br>&gt;<br>&gt; So far, everybody agreed that using distinct keywords for type alias and<br>&gt; associated type declarations is a good idea.<br>&gt; However, some people think that ‚Äúassociated‚Äù is not an ideal replacement<br>&gt; because it is too vague.<br>&gt; I would like to choose a better keyword before the review, but I‚Äôm<br>&gt; struggling to find a good replacement.<br>&gt;<br>&gt; So, here are some keywords that were proposed by the community.<br>&gt;<br>&gt; 1. associated_type<br>&gt; This is the original proposed keyword. It is extremely clear, but<br>&gt; snake_cases are un-Swifty.<br>&gt;<br>&gt; 2. associatedtype (or typeassociation)<br>&gt; This was the first alternative to associated_type. Its purpose is still<br>&gt; extremely clear.<br>&gt; I like it a lot, but it is a bit long and difficult to read.<br>&gt;<br>&gt; 3. associated<br>&gt; This is the keyword I chose for the proposal because it was the most<br>&gt; well-received initially.<br>&gt; It is quite short, very different from ‚Äútypealias&quot;, and sounds good.<br>&gt; However, it is also vaguer.<br>&gt; Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it,<br>&gt; and it‚Äôs unclear what it declares.<br>&gt; For example, one could think that it is an associated *value* and write<br>&gt; protocol FixedSizeCollectionProtocol {<br>&gt; associated size : Int<br>&gt; }<br>&gt; Although honestly I doubt many people would write that.<br>&gt;<br>&gt; 4. withtype (or needstype)<br>&gt; It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some<br>&gt; concept of association thanks to ‚Äúwith‚Äù. I like it.<br>&gt; But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br>&gt;<br>&gt; 5. type<br>&gt; This keyword was proposed by several people, but I strongly dislike it.<br>&gt; It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and<br>&gt; ‚Äúclass‚Äù keywords for type-level members.<br>&gt; I think the fact that it was proposed for two completely different<br>&gt; purposes shows that it is too abstract.<br>&gt; It would make searching for help more difficult because of its bad<br>&gt; googleability.<br>&gt;<br>&gt;<br>&gt; Personally, I would like to either keep ‚Äúassociated‚Äù, or use<br>&gt; ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br>&gt;<br>&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce<br>&gt; a new one)<br>&gt; Bonus) Maybe some twitter-famous person could make a quick poll and see<br>&gt; which one developers prefer? üòÅ (after they read this email)<br>&gt; I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake)<br>&gt; followers will give me a lot of information.<br>&gt;<br>&gt; Lo√Øc<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/eb9fb8a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>I would agree to stop talking about associated types and start talking about placeholder types instead.<br>But as a keyword, IMO the problem is that `placeholder` is not appropriate to define the implementation.<br></p><p>eg<br>class Foo: Stream {<br>    placeholder Payload = String // IMO doesn&#39;t feel right<br>    type Payload = String // IMO feels good<br>}<br></p><p>-- <br>Pierre<br></p><p>&gt; Le 23 d√©c. 2015 √† 13:59, James Campbell &lt;james at supmenow.com&gt; a √©crit :<br>&gt; <br>&gt; I think we should use &quot;placeholder&quot; it more accurately describes what it does. For a bigger change then I would propose my protocol generics idea.<br>&gt; <br>&gt; On Wed, Dec 23, 2015 at 12:50 PM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1 for `type`, it is consistent with `func`, `var` and `init`. It looks good to me.<br>&gt; <br>&gt; eg:<br>&gt; <br>&gt; protocol Stream {<br>&gt;     type Payload<br>&gt;     var ready: Bool { get }<br>&gt;     func read() -&gt; Payload?<br>&gt; }<br>&gt; <br>&gt; protocol Collection {<br>&gt;     type Element<br>&gt;     var count: Int { get }<br>&gt;     func contains(element: Element) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Pierre<br>&gt; <br>&gt;&gt; Le 19 d√©c. 2015 √† 18:46, Lo√Øc Lecrenier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I‚Äôm starting a new thread for this proposal https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt;<br>&gt;&gt; <br>&gt;&gt; So far, everybody agreed that using distinct keywords for type alias and associated type declarations is a good idea.<br>&gt;&gt; However, some people think that ‚Äúassociated‚Äù is not an ideal replacement because it is too vague.<br>&gt;&gt; I would like to choose a better keyword before the review, but I‚Äôm struggling to find a good replacement. <br>&gt;&gt; <br>&gt;&gt; So, here are some keywords that were proposed by the community.<br>&gt;&gt; <br>&gt;&gt; 1. associated_type<br>&gt;&gt; This is the original proposed keyword. It is extremely clear, but snake_cases are un-Swifty.<br>&gt;&gt; <br>&gt;&gt; 2. associatedtype (or typeassociation)<br>&gt;&gt; This was the first alternative to associated_type. Its purpose is still extremely clear.<br>&gt;&gt; I like it a lot, but it is a bit long and difficult to read.<br>&gt;&gt; <br>&gt;&gt; 3. associated<br>&gt;&gt; This is the keyword I chose for the proposal because it was the most well-received initially. <br>&gt;&gt; It is quite short, very different from ‚Äútypealias&quot;, and sounds good. However, it is also vaguer.<br>&gt;&gt; Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it, and it‚Äôs unclear what it declares.<br>&gt;&gt; For example, one could think that it is an associated *value* and write <br>&gt;&gt; protocol FixedSizeCollectionProtocol {<br>&gt;&gt; 	associated size : Int<br>&gt;&gt; }<br>&gt;&gt; Although honestly I doubt many people would write that. <br>&gt;&gt; <br>&gt;&gt; 4. withtype (or needstype)<br>&gt;&gt; It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some concept of association thanks to ‚Äúwith‚Äù. I like it. <br>&gt;&gt; But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br>&gt;&gt; <br>&gt;&gt; 5. type<br>&gt;&gt; This keyword was proposed by several people, but I strongly dislike it.<br>&gt;&gt; It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and ‚Äúclass‚Äù keywords for type-level members.<br>&gt;&gt; I think the fact that it was proposed for two completely different purposes shows that it is too abstract.<br>&gt;&gt; It would make searching for help more difficult because of its bad googleability.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Personally, I would like to either keep ‚Äúassociated‚Äù, or use ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br>&gt;&gt; <br>&gt;&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>&gt;&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>&gt;&gt; Bonus) Maybe some twitter-famous person could make a quick poll and see which one developers prefer? üòÅ (after they read this email)<br>&gt;&gt; I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake) followers will give me a lot of information.  <br>&gt;&gt; <br>&gt;&gt; Lo√Øc<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Ô£ø Wizard<br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt; +44 7523 279 698<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/131d2af1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>I prefer ‚Äútype‚Äù.<br></p><p><br>&gt; On 2015-12-23, at 20:05:46, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would agree to stop talking about associated types and start talking about placeholder types instead.<br>&gt; But as a keyword, IMO the problem is that `placeholder` is not appropriate to define the implementation.<br>&gt; <br>&gt; eg<br>&gt; class Foo: Stream {<br>&gt;     placeholder Payload = String // IMO doesn&#39;t feel right<br>&gt;     type Payload = String // IMO feels good<br>&gt; }<br>&gt; <br>&gt; -- <br>&gt; Pierre<br>&gt; <br>&gt;&gt; Le 23 d√©c. 2015 √† 13:59, James Campbell &lt;james at supmenow.com &lt;mailto:james at supmenow.com&gt;&gt; a √©crit :<br>&gt;&gt; <br>&gt;&gt; I think we should use &quot;placeholder&quot; it more accurately describes what it does. For a bigger change then I would propose my protocol generics idea.<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 23, 2015 at 12:50 PM, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1 for `type`, it is consistent with `func`, `var` and `init`. It looks good to me.<br>&gt;&gt; <br>&gt;&gt; eg:<br>&gt;&gt; <br>&gt;&gt; protocol Stream {<br>&gt;&gt;     type Payload<br>&gt;&gt;     var ready: Bool { get }<br>&gt;&gt;     func read() -&gt; Payload?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Collection {<br>&gt;&gt;     type Element<br>&gt;&gt;     var count: Int { get }<br>&gt;&gt;     func contains(element: Element) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Pierre<br>&gt;&gt; <br>&gt;&gt;&gt; Le 19 d√©c. 2015 √† 18:46, Lo√Øc Lecrenier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I‚Äôm starting a new thread for this proposal https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So far, everybody agreed that using distinct keywords for type alias and associated type declarations is a good idea.<br>&gt;&gt;&gt; However, some people think that ‚Äúassociated‚Äù is not an ideal replacement because it is too vague.<br>&gt;&gt;&gt; I would like to choose a better keyword before the review, but I‚Äôm struggling to find a good replacement. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, here are some keywords that were proposed by the community.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. associated_type<br>&gt;&gt;&gt; This is the original proposed keyword. It is extremely clear, but snake_cases are un-Swifty.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. associatedtype (or typeassociation)<br>&gt;&gt;&gt; This was the first alternative to associated_type. Its purpose is still extremely clear.<br>&gt;&gt;&gt; I like it a lot, but it is a bit long and difficult to read.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. associated<br>&gt;&gt;&gt; This is the keyword I chose for the proposal because it was the most well-received initially. <br>&gt;&gt;&gt; It is quite short, very different from ‚Äútypealias&quot;, and sounds good. However, it is also vaguer.<br>&gt;&gt;&gt; Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it, and it‚Äôs unclear what it declares.<br>&gt;&gt;&gt; For example, one could think that it is an associated *value* and write <br>&gt;&gt;&gt; protocol FixedSizeCollectionProtocol {<br>&gt;&gt;&gt; 	associated size : Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Although honestly I doubt many people would write that. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. withtype (or needstype)<br>&gt;&gt;&gt; It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some concept of association thanks to ‚Äúwith‚Äù. I like it. <br>&gt;&gt;&gt; But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. type<br>&gt;&gt;&gt; This keyword was proposed by several people, but I strongly dislike it.<br>&gt;&gt;&gt; It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and ‚Äúclass‚Äù keywords for type-level members.<br>&gt;&gt;&gt; I think the fact that it was proposed for two completely different purposes shows that it is too abstract.<br>&gt;&gt;&gt; It would make searching for help more difficult because of its bad googleability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I would like to either keep ‚Äúassociated‚Äù, or use ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>&gt;&gt;&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce a new one)<br>&gt;&gt;&gt; Bonus) Maybe some twitter-famous person could make a quick poll and see which one developers prefer? üòÅ (after they read this email)<br>&gt;&gt;&gt; I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake) followers will give me a lot of information.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lo√Øc<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Ô£ø Wizard<br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;<br>&gt;&gt; +44 7523 279 698<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/9f2a288b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>If part of this proposal is to update documentation to refer to it as<br>&quot;placeholder&quot; typed then I am okay with &quot;type&quot;<br></p><p>On Wed, Dec 23, 2015 at 1:15 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br></p><p>&gt; I prefer ‚Äútype‚Äù.<br>&gt;<br>&gt;<br>&gt; On 2015-12-23, at 20:05:46, Pierre Monod-Broca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I would agree to stop talking about associated types and start talking<br>&gt; about placeholder types instead.<br>&gt; But as a keyword, IMO the problem is that `placeholder` is not appropriate<br>&gt; to define the implementation.<br>&gt;<br>&gt; eg<br>&gt; class Foo: Stream {<br>&gt;     placeholder Payload = String // IMO doesn&#39;t feel right<br>&gt;     type Payload = String // IMO feels good<br>&gt; }<br>&gt;<br>&gt; --<br>&gt; Pierre<br>&gt;<br>&gt; Le 23 d√©c. 2015 √† 13:59, James Campbell &lt;james at supmenow.com&gt; a √©crit :<br>&gt;<br>&gt; I think we should use &quot;placeholder&quot; it more accurately describes what it<br>&gt; does. For a bigger change then I would propose my protocol generics idea.<br>&gt;<br>&gt; On Wed, Dec 23, 2015 at 12:50 PM, Pierre Monod-Broca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1 for `type`, it is consistent with `func`, `var` and `init`. It looks<br>&gt;&gt; good to me.<br>&gt;&gt;<br>&gt;&gt; eg:<br>&gt;&gt;<br>&gt;&gt; protocol Stream {<br>&gt;&gt;     type Payload<br>&gt;&gt;     var ready: Bool { get }<br>&gt;&gt;     func read() -&gt; Payload?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; protocol Collection {<br>&gt;&gt;     type Element<br>&gt;&gt;     var count: Int { get }<br>&gt;&gt;     func contains(element: Element) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Pierre<br>&gt;&gt;<br>&gt;&gt; Le 19 d√©c. 2015 √† 18:46, Lo√Øc Lecrenier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I‚Äôm starting a new thread for this proposal<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br>&gt;&gt;<br>&gt;&gt; So far, everybody agreed that using distinct keywords for type alias and<br>&gt;&gt; associated type declarations is a good idea.<br>&gt;&gt; However, some people think that ‚Äúassociated‚Äù is not an ideal replacement<br>&gt;&gt; because it is too vague.<br>&gt;&gt; I would like to choose a better keyword before the review, but I‚Äôm<br>&gt;&gt; struggling to find a good replacement.<br>&gt;&gt;<br>&gt;&gt; So, here are some keywords that were proposed by the community.<br>&gt;&gt;<br>&gt;&gt; 1. associated_type<br>&gt;&gt; This is the original proposed keyword. It is extremely clear, but<br>&gt;&gt; snake_cases are un-Swifty.<br>&gt;&gt;<br>&gt;&gt; 2. associatedtype (or typeassociation)<br>&gt;&gt; This was the first alternative to associated_type. Its purpose is still<br>&gt;&gt; extremely clear.<br>&gt;&gt; I like it a lot, but it is a bit long and difficult to read.<br>&gt;&gt;<br>&gt;&gt; 3. associated<br>&gt;&gt; This is the keyword I chose for the proposal because it was the most<br>&gt;&gt; well-received initially.<br>&gt;&gt; It is quite short, very different from ‚Äútypealias&quot;, and sounds good.<br>&gt;&gt; However, it is also vaguer.<br>&gt;&gt; Because the word ‚Äútype‚Äù is not in it, it‚Äôs unclear what should follow it,<br>&gt;&gt; and it‚Äôs unclear what it declares.<br>&gt;&gt; For example, one could think that it is an associated *value* and write<br>&gt;&gt; protocol FixedSizeCollectionProtocol {<br>&gt;&gt; associated size : Int<br>&gt;&gt; }<br>&gt;&gt; Although honestly I doubt many people would write that.<br>&gt;&gt;<br>&gt;&gt; 4. withtype (or needstype)<br>&gt;&gt; It is short, somewhat easy to read, has the word ‚Äútype‚Äù in it, and some<br>&gt;&gt; concept of association thanks to ‚Äúwith‚Äù. I like it.<br>&gt;&gt; But it doesn‚Äôt sound very good, and is still vaguer than ‚Äúassociatedtype‚Äù.<br>&gt;&gt;<br>&gt;&gt; 5. type<br>&gt;&gt; This keyword was proposed by several people, but I strongly dislike it.<br>&gt;&gt; It conflicts with an other proposal about unifying the ‚Äústatic‚Äù and<br>&gt;&gt; ‚Äúclass‚Äù keywords for type-level members.<br>&gt;&gt; I think the fact that it was proposed for two completely different<br>&gt;&gt; purposes shows that it is too abstract.<br>&gt;&gt; It would make searching for help more difficult because of its bad<br>&gt;&gt; googleability.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Personally, I would like to either keep ‚Äúassociated‚Äù, or use<br>&gt;&gt; ‚Äúassociatedtype‚Äù because they are the most obvious choices.<br>&gt;&gt;<br>&gt;&gt; 1) Do you agree about using ‚Äúassociatedtype‚Äù?<br>&gt;&gt; 2) If not, which keyword would you prefer to use? why? (you can introduce<br>&gt;&gt; a new one)<br>&gt;&gt; Bonus) Maybe some twitter-famous person could make a quick poll and see<br>&gt;&gt; which one developers prefer? üòÅ (after they read this email)<br>&gt;&gt; I would gladly do it myself, but I don‚Äôt think my twenty (mostly fake)<br>&gt;&gt; followers will give me a lot of information.<br>&gt;&gt;<br>&gt;&gt; Lo√Øc<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ô£ø Wizard<br>&gt; james at supmenow.com<br>&gt; +44 7523 279 698<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ô£ø Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/2e0b36d8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 23, 2015 at 04:00:00pm</p></header><div class="content"><p>inferredtype<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 1:53 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; inferredtype<br></p><p>It‚Äôs not always inferred, though.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>Just want to put 2 other ideas out there for completeness:<br></p><p>`relatedtype`<br></p><p>`componenttype`<br></p><p><br>&gt; On Dec 23, 2015, at 14:30, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 1:53 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; inferredtype<br>&gt; <br>&gt; It‚Äôs not always inferred, though.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 2:51 PM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just want to put 2 other ideas out there for completeness:<br>&gt; <br>&gt; `relatedtype`<br>&gt; <br>&gt; `componenttype`<br></p><p>My 2c: if we‚Äôre tack something onto ‚Äútype‚Äù, the only appropriate modifier is ‚Äúassociated.‚Äù  ‚ÄúAssociated type‚Äù isn‚Äôt a term we invented; it‚Äôs the correct accepted technical term for the role these declarations play in generic programming.<br></p><p>&gt; <br>&gt;&gt; On Dec 23, 2015, at 14:30, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 1:53 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; inferredtype<br>&gt;&gt; <br>&gt;&gt; It‚Äôs not always inferred, though.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[SE-0011] Re-considering the replacement keyword for &quot;typealias&quot;</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 23, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:08 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 2:51 PM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just want to put 2 other ideas out there for completeness:<br>&gt;&gt; <br>&gt;&gt; `relatedtype`<br>&gt;&gt; <br>&gt;&gt; `componenttype`<br>&gt; <br>&gt; My 2c: if we‚Äôre tack something onto ‚Äútype‚Äù, the only appropriate modifier is ‚Äúassociated.‚Äù  ‚ÄúAssociated type‚Äù isn‚Äôt a term we invented; it‚Äôs the correct accepted technical term for the role these declarations play in generic programming.<br></p><p>Agreed.<br></p><p>	- Doug<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
