<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0005 Better Translation of Objective-C APIs Into Swift</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  2, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Feb 02 2016, Radosław Pietruszewski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;&gt; Ah, interesting!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely see the rationale for this. Calling a method like<br>&gt;&gt;&gt; `tracks` seems a bit confusing, it doesn’t capture the intent at<br>&gt;&gt;&gt; all. The ObjC-convention version, say, `tracksWithMediaType(…)`,<br>&gt;<br>&gt;&gt;&gt; though less clear, makes a better job at this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can see more methods of this kind in the diff, and they seem to benefit the most.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mentioned this before, but the way I would prefer this named is<br>&gt;&gt;&gt; `findTracks(…)`, and skip the “with” in the name. The intent is<br>&gt;&gt;&gt; captured better than the original, we start with a verb, and the<br>&gt;&gt;&gt; method name is separated from its parameters. But obviously this is<br>&gt;&gt;&gt; unlikely to work as an automated translation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having said that, a lot of the changes seem like a step back:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    func highlight(level val: CGFloat) -&gt; NSColor?  func<br>&gt;&gt;&gt;&gt; highlight(level val: CGFloat) -&gt; NSColor?<br>&gt;&gt;&gt;&gt; - func shadow(level val: CGFloat) -&gt; NSColor?  + func<br>&gt;&gt;&gt;&gt; shadowWithLevel(val: CGFloat) -&gt; NSColor?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Inconsistency. Highlight analyzed as as a verb, shadow as a noun,<br>&gt;&gt;&gt; even though those are obviously related.<br>&gt;&gt; <br>&gt;&gt; Yes, this is an inconsistency we would need to deal with via<br>&gt;&gt; NS_SWIFT_NAME. “highlight” is acting as an adjective here, although<br>&gt;&gt; it’s predominantly a verb in Cocoa APIs.<br>&gt;<br>&gt; True, but it would seem preferable to me to choose an approach for<br>&gt; which having to fix up a name with NS_SWIFT_NAME is a rare occurrence.<br></p><p>The basic philosophy here is that we want to improve Cocoa&#39;s conformance<br>with the guidelines while doing as little damage as possible to names<br>that might be well-chosen.  It&#39;s sort of a “trust humans first”<br>approach.  That means we very well might leave some improvements on the<br>floor in the importer in order to avoid destroying the value of<br>carefully-chosen names.  Before applying the verb criterion, we were<br>finding too many places where the loss of &quot;With&quot; significantly degraded<br>understandability.  <br></p><p>You&#39;re comparing the results of the more aggressive (verb-less) criteria<br>with those of the verb-considering criteria, so it&#39;s not surprising that<br>you see a few things that could be better.<br></p><p>&gt;&gt;&gt;&gt; - func blendedColor(fraction fraction: CGFloat, of color: NSColor)<br>&gt;&gt;&gt;&gt; -&gt; NSColor?  + func blendedColorWithFraction(fraction: CGFloat, of<br>&gt;&gt;&gt;&gt; color: NSColor) -&gt; NSColor?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn’t seem like an improvement. “fraction” and “color” seem<br>&gt;&gt;&gt; very much like parameters to be separated from the name.<br>&gt;&gt; <br>&gt;&gt; Note that this is the intent of the change, however: blendedColor is<br>&gt;&gt; a noun phrase describing the result, and “withFraction” is a<br>&gt;&gt; characteristic of the resulting color.<br>&gt;<br>&gt; I understand; I just find it a much less compelling example for<br>&gt; Jordan’s approach than something like the previously mentioned<br>&gt; “tracks”.<br>&gt;<br>&gt; Perhaps the way to differentiate further cases where “with” in the<br>&gt; name is useful is: methods that you can imagine being called<br>&gt; “findFoo”, and take some argument as a search condition, but without<br>&gt; it, only a single noun remains.<br></p><p>Yes, the working guideline I&#39;ve been considering is: when you&#39;re<br>describing an aspect of an already-existing thing, such as the media<br>type of a track, you do so in the base name, and don&#39;t use a label.<br></p><p>&gt; Looking through the diff, methods like these:<br>&gt;<br>&gt; track(trackID trackID: CMPersistentTrackID) -&gt; AVAssetTrack?<br>&gt; func tracks(mediaCharacteristic mediaCharacteristic: String) -&gt;<br>&gt; [AVFragmentedAssetTrack]<br>&gt; class func devices(mediaType mediaType: String!) -&gt; [AnyObject]!<br>&gt; class func defaultDevice(mediaType mediaType: String!) -&gt; AVCaptureDevice!<br>&gt; func connection(mediaType mediaType: String!) -&gt; AVCaptureConnection!<br>&gt; func mutableTrack(compatibleWith track: AVAssetTrack) -&gt;<br>&gt; AVMutableCompositionTrack?<br>&gt;<br>&gt; Bother me the most. But a lot others, I feel like they’re worse off<br>&gt; for having “with” back in the name<br></p><p>Some are worse off than with the more-aggressive (verb-less) criterion,<br>but no worse than what we have today, which is important.<br></p><p>&gt;&gt;&gt;&gt; - class func availableColorSpaces(model model: NSColorSpaceModel)<br>&gt;&gt;&gt;&gt; -&gt; [NSColorSpace] + class func availableColorSpacesWith(model:<br>&gt;&gt;&gt;&gt; NSColorSpaceModel) -&gt; [NSColorSpace]<br>&gt;&gt;&gt;&gt;  func indexOfItem(objectValue object: AnyObject) -&gt; Int + func<br>&gt;&gt;&gt;&gt; indexOfItemWithObjectValue(object: AnyObject) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same…<br>&gt;&gt; <br>&gt;&gt; With the same answer: both start with noun phrases describing the<br>&gt;&gt; result, so the “with” is acting more like “having”, indicating that<br>&gt;&gt; the parameter is describing the characteristics of the result.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - func reviewUnsavedDocuments(alertTitle title: String?,<br>&gt;&gt;&gt;&gt; cancellable: Bool, delegate: AnyObject?, didReviewAllSelector:<br>&gt;&gt;&gt;&gt; Selector, contextInfo: UnsafeMutablePointer&lt;Void&gt;) + func<br>&gt;&gt;&gt;&gt; reviewUnsavedDocumentsWithAlertTitle(title: String?, cancellable:<br>&gt;&gt;&gt;&gt; Bool, delegate: AnyObject?, didReviewAllSelector: Selector,<br>&gt;&gt;&gt;&gt; contextInfo: UnsafeMutablePointer&lt;Void&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This definitely seem like a step back, “reviewUnsavedDocuments”<br>&gt;&gt;&gt; works really well as a name, without the sort of confusion that the<br>&gt;&gt;&gt; “tracks” mentioned above has.<br>&gt;&gt; <br>&gt;&gt; Somehow, “review” wasn’t in my list of verbs. I’ll fix this.<br>&gt;<br>&gt; Another one:<br>&gt;<br>&gt; func invalidateLayoutWith(context: NSCollectionViewLayoutInvalidationContext)<br>&gt; +  func swapWithMark(sender: AnyObject?)<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; - class func mouseEvent(type type: NSEventType, location: Point,<br>&gt;&gt;&gt;&gt; modifierFlags flags: NSEventModifierFlags, timestamp time:<br>&gt;&gt;&gt;&gt; TimeInterval, windowNumber wNum: Int, context: NSGraphicsContext?,<br>&gt;&gt;&gt;&gt; eventNumber eNum: Int, clickCount cNum: Int, pressure: Float) -&gt;<br>&gt;&gt;&gt;&gt; NSEvent?<br>&gt;&gt;&gt;&gt; + class func mouseEventWith(type: NSEventType, location: Point,<br>&gt;&gt;&gt;&gt; modifierFlags flags: NSEventModifierFlags, timestamp time:<br>&gt;&gt;&gt;&gt; TimeInterval, windowNumber wNum: Int, context: NSGraphicsContext?,<br>&gt;&gt;&gt;&gt; eventNumber eNum: Int, clickCount cNum: Int, pressure: Float) -&gt;<br>&gt;&gt;&gt;&gt; NSEvent?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one’s weird. “With” was added, but without “type” in the name.<br>&gt;&gt; <br>&gt;&gt; “type” is redundant with the type info, so it has been pruned.<br>&gt;<br>&gt; But is “mouseEventWith” as a name actually desirable?<br></p><p>This one might just be an outlier.<br></p><p>&gt; * * *<br>&gt;<br>&gt; Another thing that bothers me is how this makes method families have different names:<br>&gt;<br>&gt;&gt; - func indexOfItem(title aTitle: String) -&gt; Int + func<br>&gt;&gt; indexOfItemWithTitle(aTitle: String) -&gt; Int<br>&gt;&gt; - func indexOfItem(tag aTag: Int) -&gt; Int + func<br>&gt;&gt; indexOfItemWithTag(aTag: Int) -&gt; Int<br>&gt;&gt; - func indexOfItem(representedObject object: AnyObject) -&gt; Int +<br>&gt;&gt; func indexOfItemWithRepresentedObject(object: AnyObject) -&gt; Int<br>&gt;&gt; - func indexOfItem(submenu submenu: NSMenu?) -&gt; Int + func<br>&gt;&gt; indexOfItemWithSubmenu(submenu: NSMenu?) -&gt; Int<br>&gt;&gt; - func indexOfItem(target target: AnyObject?, andAction<br>&gt;&gt; actionSelector: Selector) -&gt; Int + func<br>&gt;&gt; indexOfItemWithTarget(target: AnyObject?, andAction actionSelector:<br>&gt;&gt; Selector) -&gt; Int<br>&gt;<br>&gt; I think it would be desirable for this, being essentially a few<br>&gt; versions of the same method, just taking different arguments, to have<br>&gt; a single name.<br></p><p>Technically, the text of the argument labels are part of the method<br>name, but I understand what you mean: it would be really nice to be able<br>to group these under a single *base* name.  I think this particular<br>family might be better expressed as something like:<br></p><p>  func indexOfItemWhere(attributes: ViewAttributes) -&gt; Int<br></p><p>where ViewAttributes is a type that can be built with expressions like:<br></p><p>  .submenu == mySubmenu &amp;&amp; .tag == someTag<br></p><p>or maybe is just replaced with a closure.  <br></p><p>   indexOf { $0.subMenu == mySubMenu &amp;&amp; $0.tag == someTag }<br></p><p>I am generally wary of bending over backward in the guidelines or<br>importer to accomodate method families, as understanding them creates a<br>lot of avoidable mental overhead for the programmer.<br></p><p>&gt; This also passes the “you could imagine the name starting with ‘find’” test.<br>&gt;<br>&gt; * * *<br>&gt;<br>&gt;&gt;   func smartMagnify(event event: NSEvent)		<br>&gt;&gt; +  func smartMagnifyWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.6, *)		   @available(OSX 10.6, *)<br>&gt;&gt; -  func touchesBegan(event event: NSEvent)		<br>&gt;&gt; +  func touchesBeganWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.6, *)		   @available(OSX 10.6, *)<br>&gt;&gt; -  func touchesMoved(event event: NSEvent)		<br>&gt;&gt; +  func touchesMovedWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.6, *)		   @available(OSX 10.6, *)<br>&gt;&gt; -  func touchesEnded(event event: NSEvent)		<br>&gt;&gt; +  func touchesEndedWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.6, *)		   @available(OSX 10.6, *)<br>&gt;&gt; -  func touchesCancelled(event event: NSEvent)		<br>&gt;&gt; +  func touchesCancelledWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.8, *)		   @available(OSX 10.8, *)<br>&gt;&gt; -  func quickLook(event event: NSEvent)		<br>&gt;&gt; +  func quickLookWith(event: NSEvent)<br>&gt;&gt;    @available(OSX 10.10.3, *)		   @available(OSX 10.10.3, *)<br>&gt;&gt; -  func pressureChange(event event: NSEvent)		<br>&gt;&gt; +  func pressureChangeWith(event: NSEvent)<br>&gt;<br>&gt; Not digging this either. Passing NSEvent here feels like passing<br>&gt; “sender” — an idiom that seems in no need of adding a “With” suffix to<br>&gt; the method name…<br></p><p>I suspect we&#39;re going to find lots of individual places where we can<br>afford to do more than the importer will do, but we can&#39;t afford to let<br>the importer go so far in transforming APIs that it creates significant<br>damage.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
