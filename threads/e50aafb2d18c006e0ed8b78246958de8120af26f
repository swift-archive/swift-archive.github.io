<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  4, 2016 at 12:00:00am</p></header><div class="content"><p>on Wed Feb 03 2016, Jessy Catterwaul &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’ve found that good external parameter names are typically just prepositions. <br>&gt;<br>&gt; Sometimes the noun that comes after the prepositions doesn’t benefit<br>&gt; from a real name. I’ve been naming those _$0 to minimize cognitive<br>&gt; load. (I don’t think about the name when writing, and when reading, I<br>&gt; know that the name would be useless to commit to my short-term<br>&gt; memory.)<br>&gt;<br>&gt; func move&lt;Point&gt;(to _$0: Point) {<br>&gt;    // argument is accessible as _$0<br>&gt; }<br></p><p>Try to write a documentation comment summary for this without mentioning<br>_$0.  The parameter names actually matter.<br></p><p>&gt; Currently, this also compiles:<br>&gt;<br>&gt; func move&lt;Point&gt;(to _: Point) {<br>&gt;    // argument is inaccessible<br>&gt; }<br>&gt;<br>&gt; Is that useless? I think it’s useless but I might be missing something.<br>&gt;<br>&gt; I propose that, when external parameter names are used, but internal<br>&gt; ones use underscores, the arguments are accessible as $0, $1, etc. (I<br>&gt; use $0 a lot, and $1 a little, but have not yet needed $2,<br>&gt; personally.)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  4, 2016 at 08:00:00am</p></header><div class="content"><p>Sometimes they matter. Sometimes they don’t. You must believe in the former idea, or not be using Swift, but regardless of if you believe in the latter, the example that I showed compiles. Perhaps it only exists now for protocol conformance? I see it as a good place to start getting shorthand argument names integrated outside of closures.<br></p><p>I’ll chime back in when I find a good case, in production, for using external but not internal names. Most of the times that names don’t matter is in generic operator signatures. <br></p><p>e.g. Here’s an operator I use (I saw something very similar recently called “then”).<br></p><p>/// Useful for initializing something and doing <br>/// things with it immediately thereafter.<br>///<br>///- Returns: `$0`<br>///<br>/// Example:<br>///```<br>/// var instance = Type()…{<br>///    $0.property = newValue<br>///    $0.doSomething()<br>/// }<br>///```<br>///- Remark: Hold option, press ;<br>public func …&lt;Type&gt;(<br>   _$0: Type,<br>   @noescape ƒ0: Type -&gt; ()<br>) -&gt; Type {<br>   ƒ0(_$0)<br>   return _$0<br>}<br></p><p>In the future, I’d prefer to keep the documentation the same, but have the code be this:<br></p><p>public let …&lt;Type&gt;(Type, @noescape Type -&gt; ()) {<br>   ƒ0(.0)<br>   return .0<br>}<br></p><p>1. The distinction between immutable closures and functions should dissolve, hence “let&quot; <br>2. Trailing closures should be known by default as ƒ0, ƒ1, etc.<br>3. $ is ugly and should be changed to .<br>4. Return type should be implicit<br></p><p><br>&gt; On Feb 4, 2016, at 3:26 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Feb 03 2016, Jessy Catterwaul &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I’ve found that good external parameter names are typically just prepositions. <br>&gt;&gt; <br>&gt;&gt; Sometimes the noun that comes after the prepositions doesn’t benefit<br>&gt;&gt; from a real name. I’ve been naming those _$0 to minimize cognitive<br>&gt;&gt; load. (I don’t think about the name when writing, and when reading, I<br>&gt;&gt; know that the name would be useless to commit to my short-term<br>&gt;&gt; memory.)<br>&gt;&gt; <br>&gt;&gt; func move&lt;Point&gt;(to _$0: Point) {<br>&gt;&gt;   // argument is accessible as _$0<br>&gt;&gt; }<br>&gt; <br>&gt; Try to write a documentation comment summary for this without mentioning<br>&gt; _$0.  The parameter names actually matter.<br>&gt; <br>&gt;&gt; Currently, this also compiles:<br>&gt;&gt; <br>&gt;&gt; func move&lt;Point&gt;(to _: Point) {<br>&gt;&gt;   // argument is inaccessible<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is that useless? I think it’s useless but I might be missing something.<br>&gt;&gt; <br>&gt;&gt; I propose that, when external parameter names are used, but internal<br>&gt;&gt; ones use underscores, the arguments are accessible as $0, $1, etc. (I<br>&gt;&gt; use $0 a lot, and $1 a little, but have not yet needed $2,<br>&gt;&gt; personally.)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/63013013/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; e.g. Here’s an operator I use (I saw something very similar recently called “then”).<br>&gt; <br>&gt; public func …&lt;Type&gt;(<br>&gt;    _$0: Type,<br>&gt;    @noescape ƒ0: Type -&gt; ()<br>&gt; ) -&gt; Type {<br>&gt;    ƒ0(_$0)<br>&gt;    return _$0<br>&gt; }<br>&gt; <br>&gt; In the future, I’d prefer to keep the documentation the same, but have the code be this:<br>&gt; <br>&gt; public let …&lt;Type&gt;(Type, @noescape Type -&gt; ()) {<br>&gt;    ƒ0(.0)<br>&gt;    return .0<br>&gt; }<br></p><p>Both of these examples seem strictly less readable than this:<br></p><p>	public func … &lt;Value&gt;(value: Value, accessor: @noescape Value -&gt; ()) -&gt; Value {<br>		accessor(value)<br>		return value<br>	}<br></p><p>They&#39;re shorter, but brevity is not a virtue if it makes your code less clear. Swift is not APL.<br></p><p>&gt; 1. The distinction between immutable closures and functions should dissolve, hence “let&quot; <br></p><p>How do you handle overloading? `let` shadows, while `func` overloads.<br></p><p>Also, what is actually gained by eliminating the keyword marking functions as different from constants?<br></p><p>&gt; 2. Trailing closures should be known by default as ƒ0, ƒ1, etc.<br></p><p>So, how many people know how to type ƒ? I sure don&#39;t.<br></p><p>&gt; 3. $ is ugly and should be changed to .<br></p><p>Which already has a different meaning, looking up a static property or method on the contextually expected type.<br></p><p>&gt; 4. Return type should be implicit<br></p><p>Eliminating the one rock—function signatures—that Swift&#39;s type inference system, which already can easily get into serious computational complexity, has to cling to.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; How do you handle overloading? `let` shadows, while `func` overloads.<br>It does now, but closures can’t currently be overloaded, which doesn’t make sense. You can’t store two overloads in closures that have the same names as those functions. This must end at some point.<br></p><p>&gt; Also, what is actually gained by eliminating the keyword marking functions as different from constants?<br></p><p>Simplicity. Having both functions and closures in the language is complexity. I doubt it’s needed but haven’t heard otherwise.<br>https://forums.developer.apple.com/thread/16594<br></p><p>&gt; So, how many people know how to type ƒ? I sure don’t.<br>There aren’t that many keys on a keyboard and only using them leads to nonsense like $0. Hold option and type F. It’s easier to learn than making any Swift compile.<br></p><p>&gt;&gt; 3. $ is ugly and should be changed to .<br>&gt; <br>&gt; Which already has a different meaning, looking up a static property or method on the contextually expected type.<br>No, you can’t have a static property named with a number.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 5 févr. 2016 à 20:18, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; How do you handle overloading? `let` shadows, while `func` overloads.<br>&gt; It does now, but closures can’t currently be overloaded, which doesn’t make sense. You can’t store two overloads in closures that have the same names as those functions. This must end at some point.<br>&gt; <br>&gt;&gt; Also, what is actually gained by eliminating the keyword marking functions as different from constants?<br>&gt; <br>&gt; Simplicity. Having both functions and closures in the language is complexity. I doubt it’s needed but haven’t heard otherwise.<br>&gt; https://forums.developer.apple.com/thread/16594<br>&gt; <br>&gt;&gt; So, how many people know how to type ƒ? I sure don’t.<br>&gt; There aren’t that many keys on a keyboard and only using them leads to nonsense like $0. Hold option and type F. It’s easier to learn than making any Swift compile.<br></p><p>And where does one find the option key on standard PC running Linux or Windows (when using for example the IBM Swift Sandbox). It have been a few time I see people suggest using some fancy unicode character easily accessible on my preferred device keyboard but which are nearly impossible to type on typical no Apple devices. Call me old fashion but the standard keywords and symbols provided by the language should be limited to plain ASCII which can be used from any standard QWERTY keyboard without any fancy Apple-ism. I know not everyone use QWERTY; And from limited experience (I switch the mapping on the first swear), I know that it’s a pain to write code on a keyboard like French-Canadian, on which I can never find those dreadful curly-braces or even the slash. I do not want to bring this pain with me (and to others) when playing with Swift on a non-Apple device.<br></p><p>Sorry for the ranting,<br>Dany<br></p><p>&gt;&gt;&gt; 3. $ is ugly and should be changed to .<br>&gt;&gt; <br>&gt;&gt; Which already has a different meaning, looking up a static property or method on the contextually expected type.<br>&gt; No, you can’t have a static property named with a number.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 5, 2016, at 17:58, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 5 févr. 2016 à 20:18, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; How do you handle overloading? `let` shadows, while `func` overloads.<br>&gt;&gt; It does now, but closures can’t currently be overloaded, which doesn’t make sense. You can’t store two overloads in closures that have the same names as those functions. This must end at some point.<br>&gt;&gt; <br>&gt;&gt;&gt; Also, what is actually gained by eliminating the keyword marking functions as different from constants?<br>&gt;&gt; <br>&gt;&gt; Simplicity. Having both functions and closures in the language is complexity. I doubt it’s needed but haven’t heard otherwise.<br>&gt;&gt; https://forums.developer.apple.com/thread/16594<br>&gt;&gt; <br>&gt;&gt;&gt; So, how many people know how to type ƒ? I sure don’t.<br>&gt;&gt; There aren’t that many keys on a keyboard and only using them leads to nonsense like $0. Hold option and type F. It’s easier to learn than making any Swift compile.<br>&gt; <br>&gt; And where does one find the option key on standard PC running Linux or Windows (when using for example the IBM Swift Sandbox). It have been a few time I see people suggest using some fancy unicode character easily accessible on my preferred device keyboard but which are nearly impossible to type on typical no Apple devices. Call me old fashion but the standard keywords and symbols provided by the language should be limited to plain ASCII which can be used from any standard QWERTY keyboard without any fancy Apple-ism. I know not everyone use QWERTY; And from limited experience (I switch the mapping on the first swear), I know that it’s a pain to write code on a keyboard like French-Canadian, on which I can never find those dreadful curly-braces or even the slash. I do not want to bring this pain with me (and to others) when playing with Swift on a non-Apple device.<br>&gt; <br>&gt; Sorry for the ranting,<br>&gt; Dany<br></p><p>Let&#39;s make sure we keep the conversation polite and respectful. I don&#39;t think any lines have been crossed yet but I can hear the voices rising. Let&#39;s keep it :-).<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Utilizing arguments without meaningful internal names</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  5, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 5 févr. 2016 à 21:10, Jordan Rose &lt;jordan_rose at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 5, 2016, at 17:58, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 5 févr. 2016 à 20:18, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do you handle overloading? `let` shadows, while `func` overloads.<br>&gt;&gt;&gt; It does now, but closures can’t currently be overloaded, which doesn’t make sense. You can’t store two overloads in closures that have the same names as those functions. This must end at some point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, what is actually gained by eliminating the keyword marking functions as different from constants?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simplicity. Having both functions and closures in the language is complexity. I doubt it’s needed but haven’t heard otherwise.<br>&gt;&gt;&gt; https://forums.developer.apple.com/thread/16594<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, how many people know how to type ƒ? I sure don’t.<br>&gt;&gt;&gt; There aren’t that many keys on a keyboard and only using them leads to nonsense like $0. Hold option and type F. It’s easier to learn than making any Swift compile.<br>&gt;&gt; <br>&gt;&gt; And where does one find the option key on standard PC running Linux or Windows (when using for example the IBM Swift Sandbox). It have been a few time I see people suggest using some fancy unicode character easily accessible on my preferred device keyboard but which are nearly impossible to type on typical no Apple devices. Call me old fashion but the standard keywords and symbols provided by the language should be limited to plain ASCII which can be used from any standard QWERTY keyboard without any fancy Apple-ism. I know not everyone use QWERTY; And from limited experience (I switch the mapping on the first swear), I know that it’s a pain to write code on a keyboard like French-Canadian, on which I can never find those dreadful curly-braces or even the slash. I do not want to bring this pain with me (and to others) when playing with Swift on a non-Apple device.<br>&gt;&gt; <br>&gt;&gt; Sorry for the ranting,<br>&gt;&gt; Dany<br>&gt; <br>&gt; Let&#39;s make sure we keep the conversation polite and respectful. I don&#39;t think any lines have been crossed yet but I can hear the voices rising. Let&#39;s keep it :-).<br>&gt; <br>&gt; Jordan<br></p><p>Words can be seen as harsher that they were meant to be, as information is lost when converting thoughts to words, translating some of them to English, and removing the movement of the hands and the expression on the face. I see that my first sentence could be read back as some kind of aggressive barking back, but it was not. It was more a &quot;did you think of&quot; with an edge (not sure of the proper that)<br></p><p><br>Dany<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
