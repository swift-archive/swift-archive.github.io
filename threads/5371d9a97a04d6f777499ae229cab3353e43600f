<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Discussion][Pre-Proposal] diverges/converges methods for Collection</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jul 07 2016, Daryle Walker &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I doesn’t seem that anyone noticed the previous post.  Here’s an inline copy:<br>&gt;<br>&gt; Implement a mismatch algorithm, equivalent to std::mismatch() in C++<br></p><p>I definitely want this algorithm in the standard library, someday soon.<br>It&#39;s out of scope for Swift 3, though.<br></p><p>&gt; Proposal: SE-NNNN &lt;https://gist.github.com/CTMacUser/NNNN-filename.md&gt;<br>&gt; Author: Daryle Walker &lt;https://github.com/CTMacUser&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#introduction&gt;Introduction<br>&gt;<br>&gt; This proposal is to add difference detection to Swift&#39;s standard library collections.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#motivation&gt;Motivation<br>&gt;<br>&gt; Finding where two similar collections differ is needed in algorithms that have different policies on handling the common part versus the uncommon parts. Similar tests already exist in the standard library: the elementsEqual methods in Sequence for instance; the methods can indicate two sequences are different but not where they diverged. Flipping it around, it means that sequence equivalence, and several other sequence methods, can be expressed in terms of mismatch-finding. However, returning the divergence point means returning references to the diverging elements, which means an index, which means that collections are required instead of plain sequences.<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#proposed-solution&gt;Proposed solution<br>&gt;<br>&gt; The Swift standard library should provide generic implementations of the &quot;mismatch&quot; algorithm for forward searches on prefixes and backward searches on suffixes. The forward/prefix form is called diverges(from: isEquivalent:). The backward/suffix form is called converges(with: isEquivalent:), and is present only when the collection type supports bidirectional indexing. If the collection&#39;s element type conforms to Equatable, there variants of the method(s) that drop the second argument and instead use == for the equivalency test.<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#detailed-design&gt;Detailed design<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#divergesfromisequivalent-and-divergesfrom&gt;diverges(from:isEquivalent:) and diverges(from:)<br>&gt;<br>&gt; Forward mismatching on prefixes will be added to the Collection protocol requirements with a default implementation. Its variant will extend Collection with a default implementation. These methods will have the following declarations:<br>&gt;<br>&gt; protocol Collection {<br>&gt;     // existing declarations<br>&gt;<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise until either corresponding elements are no longer equivalent, using the given predicate as the equivalence test, or at least one collection reaches its end index.<br>&gt;<br>&gt;         The predicate must be an equivalence relation over the elements.<br>&gt;<br>&gt;         - parameter from: A collection to compare to this one.<br>&gt;         - parameter isEquivalent: A predicate the returns `true` if and only if its two arguments are equivalent.<br>&gt;         - returns: A pair of indices, indicating where the two collections mismatched.  The first member is the index of the element that mismatched in this collection, the second is the index of the element that mismatched in the given collection.  If the testing stopped because the collections were of different lengths, but were equivalent until that point, then exactly one member of the tuple will be at its collection&#39;s end index.  If both tuple members are at their respective collection&#39;s end index, then the collections were equivalent.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;         - throws: Whatever `isEquivalent` may throw.<br>&gt;     */<br>&gt;     func diverges&lt;PossiblePrefix: Collection where PossiblePrefix.Iterator.Element == Iterator.Element&gt;(from possiblePrefix: PossiblePrefix, isEquivalent: (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; (Index, PossiblePrefix.Index)<br>&gt; }<br>&gt;<br>&gt; extension Collection {<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise until either corresponding elements are no longer equivalent, using the given predicate as the equivalence test, or at least one collection reaches its end index.<br>&gt;<br>&gt;         The predicate must be an equivalence relation over the elements.<br>&gt;<br>&gt;         - parameter from: A collection to compare to this one.<br>&gt;         - parameter isEquivalent: A predicate the returns `true` if and only if its two arguments are equivalent.<br>&gt;         - returns: A pair of indices, indicating where the two collections mismatched.  The first member is the index of the element that mismatched in this collection, the second is the index of the element that mismatched in the given collection.  If the testing stopped because the collections were of different lengths, but were equivalent until that point, then exactly one member of the tuple will be at its collection&#39;s end index.  If both tuple members are at their respective collection&#39;s end index, then the collections were equivalent.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;         - throws: Whatever `isEquivalent` may throw.<br>&gt;     */<br>&gt;     func diverges&lt;PossiblePrefix: Collection where PossiblePrefix.Iterator.Element == Iterator.Element&gt;(from possiblePrefix: PossiblePrefix, isEquivalent: (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; (Index, PossiblePrefix.Index)<br>&gt; }<br>&gt;<br>&gt; extension Collection where Iterator.Element: Equatable {<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise until either corresponding elements are no longer equal, or at least one collection reaches its end index.<br>&gt;<br>&gt;         - parameter from: A collection to compare to this one.<br>&gt;         - returns: A pair of indices, indicating where the two collections mismatched.  The first member is the index of the element that mismatched in this collection, the second is the index of the element that mismatched in the given collection.  If the testing stopped because the collections were of different lengths, but were equal until that point, then exactly one member of the tuple will be at its collection&#39;s end index.  If both tuple members are at their respective collection&#39;s end index, then the collections were equal.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;     */<br>&gt;     func diverges&lt;PossiblePrefix: Collection where PossiblePrefix.Iterator.Element == Iterator.Element&gt;(from possiblePrefix: PossiblePrefix) -&gt; (Index, PossiblePrefix.Index)<br>&gt; }<br>&gt; I don&#39;t know if we should insist that at least one (or both) of the collections tested should be finite. I don&#39;t know if the results should be discardable.<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#convergeswithisequivalent-and-convergeswith&gt;converges(with:isEquivalent:) and converges(with:)<br>&gt;<br>&gt; Backward mismatching on suffixes will be added to the BidirectionalCollection protocol requirements with a default implementation. Its variant will extend BidirectionalCollection with a default implementation. These methods will have the following declarations:<br>&gt;<br>&gt; protocol BidirectionalCollection {<br>&gt;     // existing declarations<br>&gt;<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise and backwards until either corresponding elements are no longer equivalent, using the given predicate as the equivalence test, or at least one collection reaches its start index.<br>&gt;<br>&gt;         Both collections must be finite.<br>&gt;<br>&gt;         The predicate must be an equivalence relation over the elements.<br>&gt;<br>&gt;         - parameter with: A collection to compare to this one.<br>&gt;         - parameter isEquivalent: A predicate the returns `true` if and only if its two arguments are equivalent.<br>&gt;         - returns: A pair of indices, indicating where the two collections started to match.  The first member is the index of the element that suffix-matched in this collection, the second is the index of the element that suffix-matched in the given collection.  If the testing stopped because the collections were of different lengths, but were equivalent until that point, then exactly one member of the tuple will be at its collection&#39;s start index.  If both tuple members are at their respective collection&#39;s start index, then the collections were equivalent.  If both tuple members are at their respective collection&#39;s end index, then either the collections&#39; last elements differ or at least one collection was empty.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;         - throws: Whatever `isEquivalent` may throw.<br>&gt;     */<br>&gt;     func converges&lt;PossibleSuffix: BidirectionalCollection where PossibleSuffix.Iterator.Element == Iterator.Element&gt;(with possibleSuffix: PossibleSuffix, isEquivalent: (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; (Index, PossibleSuffix.Index)<br>&gt; }<br>&gt;<br>&gt; extension BidirectionalCollection {<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise and backwards until either corresponding elements are no longer equivalent, using the given predicate as the equivalence test, or at least one collection reaches its start index.<br>&gt;<br>&gt;         Both collections must be finite.<br>&gt;<br>&gt;         The predicate must be an equivalence relation over the elements.<br>&gt;<br>&gt;         - parameter with: A collection to compare to this one.<br>&gt;         - parameter isEquivalent: A predicate the returns `true` if and only if its two arguments are equivalent.<br>&gt;         - returns: A pair of indices, indicating where the two collections started to match.  The first member is the index of the element that suffix-matched in this collection, the second is the index of the element that suffix-matched in the given collection.  If the testing stopped because the collections were of different lengths, but were equivalent until that point, then exactly one member of the tuple will be at its collection&#39;s start index.  If both tuple members are at their respective collection&#39;s start index, then the collections were equivalent.  If both tuple members are at their respective collection&#39;s end index, then either the collections&#39; last elements differ or at least one collection was empty.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;         - throws: Whatever `isEquivalent` may throw.<br>&gt;     */<br>&gt;     func converges&lt;PossibleSuffix: BidirectionalCollection where PossibleSuffix.Iterator.Element == Iterator.Element&gt;(with possibleSuffix: PossibleSuffix, isEquivalent: (Iterator.Element, Iterator.Element) throws -&gt; Bool) rethrows -&gt; (Index, PossibleSuffix.Index)<br>&gt; }<br>&gt;<br>&gt; extension BidirectionalCollection where Iterator.Element: Equatable {<br>&gt;     /**<br>&gt;         Compares the collection against a given collection element-wise and backwards until either corresponding elements are no longer equal, or at least one collection reaches its start index.<br>&gt;<br>&gt;         Both collections must be finite.<br>&gt;<br>&gt;         - parameter with: A collection to compare to this one.<br>&gt;         - returns: A pair of indices, indicating where the two collections started to match.  The first member is the index of the element that suffix-matched in this collection, the second is the index of the element that suffix-matched in the given collection.  If the testing stopped because the collections were of different lengths, but were equivalent until that point, then exactly one member of the tuple will be at its collection&#39;s start index.  If both tuple members are at their respective collection&#39;s start index, then the collections were equivalent.  If both tuple members are at their respective collection&#39;s end index, then either the collections&#39; last elements differ or at least one collection was empty.<br>&gt;         - complexity: `min(count, from.count)` comparisons.<br>&gt;     */<br>&gt;     func converges&lt;PossibleSuffix: BidirectionalCollection where PossibleSuffix.Iterator.Element == Iterator.Element&gt;(with possibleSuffix: PossibleSuffix) -&gt; (Index, PossibleSuffix.Index)<br>&gt; }<br>&gt; I don&#39;t know if the results should be discardable.<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#impact-on-existing-code&gt;Impact on existing code<br>&gt;<br>&gt; The comparison methods are an additive feature that doesn’t impact existing code.<br>&gt;<br>&gt;  &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc#alternatives-considered&gt;Alternatives considered<br>&gt;<br>&gt; The alternative is to not include these methods in the standard library, but the user will need to develop their custom implementation of the mismatch algorithms tailored for their needs.<br>&gt;<br>&gt; — <br>&gt; Daryle Walker<br>&gt; Mac, Internet, and Video Game Junkie<br>&gt; darylew AT mac DOT com <br>&gt;<br>&gt;&gt; On Jul 6, 2016, at 5:01 AM, Daryle Walker &lt;darylew at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I mentioned in other messages about adding permutations and<br>&gt;&gt; combinations (probably as generators/iterators) to the standard<br>&gt;&gt; library.  I tried making sample implementations and a proposal, but<br>&gt;&gt; it transitioned to adapting C++’s “is_permutation,”<br>&gt;&gt; “next_permutation,” and “prev_permutation” instead.  The sample<br>&gt;&gt; implementation of “is_permutation” I saw at<br>&gt;&gt; &lt;http://en.cppreference.com/w/cpp/algorithm/is_permutation<br>&gt;&gt; &lt;http://en.cppreference.com/w/cpp/algorithm/is_permutation&gt;&gt;<br>&gt;&gt; involves the “mismatch” function, which we also don’t seem to have.<br>&gt;&gt; Since that function seems like a small enough bite the chew, I<br>&gt;&gt; finally made a proposal at<br>&gt;&gt; &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc<br>&gt;&gt; &lt;https://gist.github.com/CTMacUser/c1a0d7ac60cf827184c33e8768a23dfc&gt;&gt;.<br>&gt;&gt; (The Gist is currently flagged as secret.)<br>&gt;&gt; <br>&gt;&gt; Oh, it seems that everyone here has moved on to Swift 3, and so has<br>&gt;&gt; my third-party documentation program.  Unfortunately, I still on<br>&gt;&gt; non-beta code, which means Swift 2.2.  So I took some time having to<br>&gt;&gt; translate concepts between the versions, including new names.<br>&gt;&gt; <br>&gt;&gt; The name “mismatch” didn’t seem Swift-y enough since it doesn’t describe what’s happening from a Swift programming perspective.  I tried:<br>&gt;&gt; <br>&gt;&gt; * commonPrefixUntil / commonSuffixUntil<br>&gt;&gt; * elementsEqualUntil / elementsEqualSince<br>&gt;&gt; * elementsShared(until:) / elementsShared(since:)<br>&gt;&gt; * elementsDiverge / elementsConverge<br>&gt;&gt; <br>&gt;&gt; No, those parameters on the third one don’t make sense.  The last<br>&gt;&gt; one inspired me to trim the fat and just use “diverge(from:)”.<br>&gt;&gt; Since we use indexes here like C++’s iterators, that was the best<br>&gt;&gt; choice for a return type that allows the users to take the results<br>&gt;&gt; in an inspecting manner or mutating manner.  But Swift’s model<br>&gt;&gt; doesn’t handle reversed collections like C++ does, so I need a<br>&gt;&gt; separate routine for mismatching with reverse iterators,<br>&gt;&gt; i.e. searching backwards with indexes.  Since I used the “diverge”<br>&gt;&gt; name for the forward search, I flipped it to “converge(with:)” for<br>&gt;&gt; the reverse/suffix search.  The returns aren’t used in quite the<br>&gt;&gt; same manner since I have to avoid needing a before-the-start index.<br>&gt;&gt; <br>&gt;&gt; A lot of the format was badly copied from the rotate/reverse<br>&gt;&gt; proposal<br>&gt;&gt; (&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0078-rotate-algorithm.md<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0078-rotate-algorithm.md&gt;&gt;).<br>&gt;&gt; Looking for opinions, mistakes/clean-up, anything major missing?...<br>&gt;&gt; <br>&gt;&gt; — <br>&gt;&gt; Daryle Walker<br>&gt;&gt; Mac, Internet, and Video Game Junkie<br>&gt;&gt; darylew AT mac DOT com <br>&gt;&gt; <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
