<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>on Sun Feb 14 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 13, 2016, at 1:32 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Feb 13 2016, plx<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On a skim, if there’s a specific explanation as to *why* `inPlace` is<br>&gt;&gt;&gt; a now a no-go, I don’t see it. <br>&gt;&gt; <br>&gt;&gt; Several justifications were given:<br>&gt;&gt; <br>&gt;&gt; * Several people have an “ick” reaction when they see it.<br>&gt;&gt; <br>&gt;&gt; * It&#39;s not in the guidelines.<br>&gt;&gt; <br>&gt;&gt; * If we add it to the guidelines, it will only be as fallback<br>&gt;&gt;  last-resort alternative.<br>&gt;&gt; <br>&gt;&gt; * If one of the three main collection types can&#39;t conform to the<br>&gt;&gt;  recommendations of the non-last-resort guidelines, the guidelines are<br>&gt;&gt;  a failure.<br>&gt;<br>&gt; As a devil’s advocate, why wouldn’t the existing names be justifiable<br>&gt; under “Use terminology well” guideline?<br></p><p>I&#39;m afraid you&#39;ll have to ask someone who understands the decision :-).<br>I&#39;ve asked someone else to explain it; hopefully that will happen soon.<br></p><p>&gt; I’d consider making up new terminology for a well-established domain<br>&gt; much worse than simply not following the naming conventions.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; I can’t say I like the proposed changes<br>&gt;&gt;&gt; very much, and I definitely don’t like some of the more-creative<br>&gt;&gt;&gt; suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s hard to offer help when it’s not clear what was deemed<br>&gt;&gt;&gt; problematic about the existing (and “perfectly fine with me”!) names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Separately, can I ask here why SetAlgebra protocol doesn’t contain an<br>&gt;&gt;&gt; *overridable* method like `func intersects(other: Self) -&gt; Bool`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Note: I am *well-aware* that `a intersects b &lt;=&gt; !(a and b are disjoint)`).<br>&gt;&gt; <br>&gt;&gt; There&#39;s no point in providing an override if there&#39;s no chance of it<br>&gt;&gt; being better than the default implementation.<br>&gt;<br>&gt; But again, cf `isSupersetOf` and `isSubsetOf`...which are both<br>&gt; overridable unless I’m misunderstanding. (Especially as there’s risk<br>&gt; of a performance “gotcha” if you only override “the wrong one”).<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; That absence has been puzzling me ever whichever release of Swift<br>&gt;&gt;&gt; first introduced this protocol, particularly since e.g. both<br>&gt;&gt;&gt; `isSubsetOf` and `isSupersetOf` are individually-overridable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Likewise, but less so, I do wonder why the protocol doesn’t contain<br>&gt;&gt;&gt; *overridable* `isStrictSubset` and `isStrictSuperset` functions,<br>&gt;&gt;&gt; either...).<br>&gt;&gt; <br>&gt;&gt; Same reasoning, but we may have mistakenly decided there was no chance<br>&gt;&gt; of optimization.  If so, please open a ticket.<br>&gt;<br>&gt; There are definitely examples of such; https://bugs.swift.org/browse/SR-735 . <br>&gt;<br>&gt; After looking at what’s in github, there really ought to be a few more<br>&gt; families of default implementations, e.g. `extension SetAlgebraType<br>&gt; where Self:CollectionType` and `extension SetAlgebraType where<br>&gt; Self:CollectionType, Index: RandomAccessIndexType` (where we can<br>&gt; assume O(1) count).<br>&gt;<br>&gt; Is that better as just a ticket or as a discussion on one of the<br>&gt; lists?<br></p><p>On the surface they seem like clear bugs/missed optimizations to me, so<br>I think tickets are the right medium.<br></p><p>&gt;<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:52 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt;&gt; under development.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comments welcome as usual,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February 15, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>First - I want to thank all of the contributors on this discussion for helping us with this obviously tricky naming problem.<br></p><p>Dave has already described some of the thinking that has gone into the iterations of the API for Set. You’ve seen stages of that evolution here.<br></p><p>We’re at the point where we need to make a decision and move on. Not because it’s impossible to come up with better ideas, but because we want to continue to work on the remaining aspects of the naming proposals that we’ve put forth on this list. <br></p><p>In the future, there is always the opportunity for members of the community and members of the core team to propose ideas like newly discovered names, improvements to the language like keywords for mutation-in-place or special operators, or whatever great thing comes next. If we decide to do those, then we will be sure to consider the impact on the APIs we choose today. There are many tools in our toolbox for rolling out those improvements (deprecation and replacement being the one we’ve used countless times for framework and library API).<br></p><p>So: by incorporating your ideas in this thread, along with those from other members of the API naming working group, and by adhering to the proposed guidelines as closely as possible, we’re going to go with the following API changes for SetAlgebra for Swift 3:<br></p><p>    /// Returns the set of elements contained in `self`, in `other`, or in both `self` and `other`.<br>    /// EXISTING: union<br>    @warn_unused_result<br>    func insertingContentsOf(other: Self) -&gt; Self<br>    <br>    /// Insert all elements of `other` into `self`.<br>    /// EXISTING: unionInPlace<br>    mutating func insertContentsOf(other: Self)<br>    <br>    /// Returns the set of elements contained in both `self` and `other`.<br>    /// EXISTING: intersect<br>    @warn_unused_result<br>    func intersection(other: Self) -&gt; Self<br></p><p>    /// Removes all elements of `self` that are not also present in `other`.<br>    /// EXISTING: intersectInPlace<br>    mutating func intersect(other: Self)<br></p><p>    /// Returns the set of elements contained in `self` or in `other`, but not in both `self` and `other`.<br>    /// EXISTING: exclusiveOr<br>    @warn_unused_result<br>    func invertingIntersection(other: Self) -&gt; Self<br>    <br>    /// Replaces `self` with a set containing all elements contained in either `self` or `other`, but not both.<br>    /// EXISTING: exclusiveOrInPlace<br>    mutating func invertIntersection(other: Self)<br>    <br>    /// Returns the set of elements contained in `self` but not in `other`.<br>    /// EXISTING: subtract<br>    @warn_unused_result<br>    func removingContentsOf(other: Self) -&gt; Self<br>    <br>    /// Removes all elements of `other` from `self`.<br>    /// EXISTING: subtractInPlace<br>    mutating func removeContentsOf(other: Self)<br></p><p>Here is a summary of the reasons behind the decision:<br></p><p>1. As Dave said, it is important that we are able to apply our guidelines without an exception to such a core type. It’s not just about one particular Set type either, as these methods appear on many places in API (for example — all options are now Sets as well), thanks to Swift support for protocol-oriented-programming.<br></p><p>2. Using ‘insert’ instead of ‘union’ makes the method part of a family with the existing API on SetAlgebra: mutating func insert(member:). Indeed - the language of ‘insert’ has been in the markdown comment since the beginning. The same justification applies to using ‘remove’ instead of ‘subtract’.<br></p><p>3. The ContentsOf suffix is precedented by RangeReplaceableCollection, as a way to disambiguate inserting the contents of some collection vs the collection itself. It makes sense to reuse it here instead of using new terminology.<br></p><p>4. With the decision to use ‘insert’ and ‘remove’, we have built a very succinct vocabulary of operations on set: <br>	operations which add content (insert)<br>	operations which remove content (remove). <br></p><p>That leaves us with operations which both add and remove content. Intersect is straightforward enough and does not have significant naming challenges, so we keep it and apply the noun-phrase rule to the non-mutating function to distinguish it from the mutating function. exclusiveOr is trickier. However, I believe the suggestion made here of using invert leads us to a succinct name that conveys the right meaning, without putting two verbs in the base name.<br></p><p>We will also add additional documentation to each of these methods to describe their mathematical underpinnings. I hope that will aid developers in finding the right method, if they are not already familiar with the terminology we choose.<br></p><p>Again, sincere thanks for all of your input here.<br></p><p>- Tony<br></p><p>&gt; On Feb 14, 2016, at 12:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Feb 14 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 1:32 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Feb 13 2016, plx<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On a skim, if there’s a specific explanation as to *why* `inPlace` is<br>&gt;&gt;&gt;&gt; a now a no-go, I don’t see it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Several justifications were given:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Several people have an “ick” reaction when they see it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * It&#39;s not in the guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If we add it to the guidelines, it will only be as fallback<br>&gt;&gt;&gt; last-resort alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If one of the three main collection types can&#39;t conform to the<br>&gt;&gt;&gt; recommendations of the non-last-resort guidelines, the guidelines are<br>&gt;&gt;&gt; a failure.<br>&gt;&gt; <br>&gt;&gt; As a devil’s advocate, why wouldn’t the existing names be justifiable<br>&gt;&gt; under “Use terminology well” guideline?<br>&gt; <br>&gt; I&#39;m afraid you&#39;ll have to ask someone who understands the decision :-).<br>&gt; I&#39;ve asked someone else to explain it; hopefully that will happen soon.<br>&gt; <br>&gt;&gt; I’d consider making up new terminology for a well-established domain<br>&gt;&gt; much worse than simply not following the naming conventions.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can’t say I like the proposed changes<br>&gt;&gt;&gt;&gt; very much, and I definitely don’t like some of the more-creative<br>&gt;&gt;&gt;&gt; suggestions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s hard to offer help when it’s not clear what was deemed<br>&gt;&gt;&gt;&gt; problematic about the existing (and “perfectly fine with me”!) names.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Separately, can I ask here why SetAlgebra protocol doesn’t contain an<br>&gt;&gt;&gt;&gt; *overridable* method like `func intersects(other: Self) -&gt; Bool`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Note: I am *well-aware* that `a intersects b &lt;=&gt; !(a and b are disjoint)`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s no point in providing an override if there&#39;s no chance of it<br>&gt;&gt;&gt; being better than the default implementation.<br>&gt;&gt; <br>&gt;&gt; But again, cf `isSupersetOf` and `isSubsetOf`...which are both<br>&gt;&gt; overridable unless I’m misunderstanding. (Especially as there’s risk<br>&gt;&gt; of a performance “gotcha” if you only override “the wrong one”).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That absence has been puzzling me ever whichever release of Swift<br>&gt;&gt;&gt;&gt; first introduced this protocol, particularly since e.g. both<br>&gt;&gt;&gt;&gt; `isSubsetOf` and `isSupersetOf` are individually-overridable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Likewise, but less so, I do wonder why the protocol doesn’t contain<br>&gt;&gt;&gt;&gt; *overridable* `isStrictSubset` and `isStrictSuperset` functions,<br>&gt;&gt;&gt;&gt; either...).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Same reasoning, but we may have mistakenly decided there was no chance<br>&gt;&gt;&gt; of optimization.  If so, please open a ticket.<br>&gt;&gt; <br>&gt;&gt; There are definitely examples of such; https://bugs.swift.org/browse/SR-735 . <br>&gt;&gt; <br>&gt;&gt; After looking at what’s in github, there really ought to be a few more<br>&gt;&gt; families of default implementations, e.g. `extension SetAlgebraType<br>&gt;&gt; where Self:CollectionType` and `extension SetAlgebraType where<br>&gt;&gt; Self:CollectionType, Index: RandomAccessIndexType` (where we can<br>&gt;&gt; assume O(1) count).<br>&gt;&gt; <br>&gt;&gt; Is that better as just a ticket or as a discussion on one of the<br>&gt;&gt; lists?<br>&gt; <br>&gt; On the surface they seem like clear bugs/missed optimizations to me, so<br>&gt; I think tickets are the right medium.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 11, 2016, at 10:52 AM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi All,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The API guidelines working group took up the issue of the InPlace suffix<br>&gt;&gt;&gt;&gt;&gt; yesterday, and decided that it was not to be used anywhere in the<br>&gt;&gt;&gt;&gt;&gt; standard library.  We are planning to apply the changes shown here<br>&gt;&gt;&gt;&gt;&gt; &lt;https://gist.github.com/dabrahams/d872556291a3cb797bd5&gt; to the API of<br>&gt;&gt;&gt;&gt;&gt; SetAlgebra (and consequently Set) to make it conform to the guidelines<br>&gt;&gt;&gt;&gt;&gt; under development.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comments welcome as usual,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/e09052fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>ed/ing, InPlace, Set/SetAlgebra naming resolution</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 15, 2016 at 11:00:00pm</p></header><div class="content"><p>I think you&#39;ve ended up with the right approach, and I understand the need to move on, but...<br></p><p>&gt;     /// Returns the set of elements contained in `self` or in `other`, but not in both `self` and `other`.<br>&gt;     /// EXISTING: exclusiveOr<br>&gt;     @warn_unused_result<br>&gt;     func invertingIntersection(other: Self) -&gt; Self<br>&gt;     <br>&gt;     /// Replaces `self` with a set containing all elements contained in either `self` or `other`, but not both.<br>&gt;     /// EXISTING: exclusiveOrInPlace<br>&gt;     mutating func invertIntersection(other: Self)<br></p><p>I&#39;m not quite happy with these. I don&#39;t like that the mutating form of `intersection` is `intersect`, but the mutating form of `invertingIntersection` is `invertIntersection`—it seems like both methods should change the &quot;intersection&quot; part.<br></p><p>Have you considered going the opposite direction and combining the verb &quot;intersect&quot; with the adjective &quot;inverse&quot;?<br></p><p>    /// Returns the set of elements contained in `self` or in `other`, but not in both `self` and `other`.<br>    /// EXISTING: exclusiveOr<br>    @warn_unused_result<br>    func inverseIntersection(other: Self) -&gt; Self<br>    <br>    /// Replaces `self` with a set containing all elements contained in either `self` or `other`, but not both.<br>    /// EXISTING: exclusiveOrInPlace<br>    mutating func inverseIntersect(other: Self)<br>    // or perhaps even `inverselyIntersect` so it&#39;s an adverb<br></p><p>I wouldn&#39;t be surprised if you did, because I could see you trying to dodge the adverb problem, but I thought it was worth asking.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
