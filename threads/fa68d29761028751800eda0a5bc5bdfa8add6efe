<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 12:00:00am</p></header><div class="content"><p>Hey guys,<br></p><p>I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br></p><p>Is there any info yet if and how we will be able to refer to instances of<br>protocols that have associated types?<br>What is the difficulty in supporting this?<br></p><p>Simple examples:<br>var list = [Hashable]()<br>var hashable: Hashable = 2<br></p><p>Right now all we get is<br></p><p>&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it<br>&gt; has Self or associated type requirements<br></p><p><br>Thanks,<br>  Marc<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/fa686efe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 13, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey guys,<br>&gt; <br>&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt; <br>&gt; Is there any info yet if and how we will be able to refer to instances of protocols that have associated types?<br></p><p>As far as I know, this isn&#39;t a solvable problem.<br></p><p>&gt; What is the difficulty in supporting this?<br></p><p>Here&#39;s a simple example:<br></p><p>protocol P {<br>  typealias A<br>  var x: A { get set }<br>}<br></p><p>struct Y : P {<br>  var x: Int<br>}<br></p><p>struct Z : P {<br>  var x: String<br>}<br></p><p>func f(p1: P, p2: P) {<br>  p1.x = p2.x // assigning an Int to a String?<br>}<br>  <br>&gt; Simple examples:<br>&gt; var list = [Hashable]()<br>&gt; var hashable: Hashable = 2<br>&gt; <br>&gt; Right now all we get is<br>&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it has Self or associated type requirements<br></p><p><br>In this case it&#39;s &quot;self requirements&quot; inherited from Equatable that make instances of Hashable impossible.<br>That said, providing for sets/dictionaries of heterogeneous values is a problem we&#39;re interested in solving in the standard library.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/771fa34c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 14, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 11:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Is there any info yet if and how we will be able to refer to instances of protocols that have associated types?<br>&gt;&gt; <br>&gt;&gt; As far as I know, this isn&#39;t a solvable problem.<br></p><p>&gt;&gt; <br>&gt;&gt; What is the difficulty in supporting this?<br>&gt; <br>&gt; Here&#39;s a simple example:<br>&gt; <br>&gt; protocol P {<br>&gt;   typealias A<br>&gt;   var x: A { get set }<br>&gt; }<br>&gt; <br>&gt; struct Y : P {<br>&gt;   var x: Int<br>&gt; }<br>&gt; <br>&gt; struct Z : P {<br>&gt;   var x: String<br>&gt; }<br>&gt; <br>&gt; func f(p1: P, p2: P) {<br>&gt;   p1.x = p2.x // assigning an Int to a String?<br>&gt; }<br></p><p>p1.x = p2.x should be a compiler error, because there’s not enough type information. But that shouldn’t stop a programmer from doing this:<br></p><p>protocol P {<br>  typealias A<br>  var x: A { get set }<br>  var y: Int<br>}<br></p><p>struct Y : P {<br>  var x: Int<br>  var y: Int<br>}<br></p><p>struct Z : P {<br>  var x: String<br>  var y: Int<br>}<br></p><p>func maxY(p1: P, p2: P) -&gt; Int {<br>  return max(p1.y, p2.y)   // No problems here!<br>}<br></p><p>…right?<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b91d4d3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 13, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 11:03 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 11:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Is there any info yet if and how we will be able to refer to instances of protocols that have associated types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I know, this isn&#39;t a solvable problem.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is the difficulty in supporting this?<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a simple example:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   typealias A<br>&gt;&gt;   var x: A { get set }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Y : P {<br>&gt;&gt;   var x: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Z : P {<br>&gt;&gt;   var x: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func f(p1: P, p2: P) {<br>&gt;&gt;   p1.x = p2.x // assigning an Int to a String?<br>&gt;&gt; }<br>&gt; <br>&gt; p1.x = p2.x should be a compiler error, because there’s not enough type information.<br></p><p>&gt; But that shouldn’t stop a programmer from doing this:<br>&gt; <br>&gt; protocol P {<br>&gt;   typealias A<br>&gt;   var x: A { get set }<br>&gt;   var y: Int<br>&gt; }<br>&gt; <br>&gt; struct Y : P {<br>&gt;   var x: Int<br>&gt;   var y: Int<br>&gt; }<br>&gt; <br>&gt; struct Z : P {<br>&gt;   var x: String<br>&gt;   var y: Int<br>&gt; }<br>&gt; <br>&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br>&gt; <br>&gt; …right?<br></p><p>Ah, but then you have the situation that P doesn&#39;t conform to P (it doesn&#39;t have an x that you can access).  In my opinion that is just too weird an idea to be usable.<br>Personally, I have always thought that protocols intended to be used as unbound existentials (not P&lt;A: Int&gt;, just plain P) are different beasts entirely from the kind used as generic constraints and should be explicitly declared as such—I don&#39;t think I&#39;ve ever seen a protocol that is well-used in both ways; if you have counterexamples I&#39;d love to see them.  In &quot;existential protocols,&quot; declaring an associated type or creating a self requirement would be an error at the point of declaration.  <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/ea54ef9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 12:37 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &lt;snip&gt;<br>&gt; Personally, I have always thought that protocols intended to be used as unbound existentials (not P&lt;A: Int&gt;, just plain P) are different beasts entirely from the kind used as generic constraints and should be explicitly declared as such—I don&#39;t think I&#39;ve ever seen a protocol that is well-used in both ways; if you have counterexamples I&#39;d love to see them.  In &quot;existential protocols,&quot; declaring an associated type or creating a self requirement would be an error at the point of declaration.  <br></p><p>I recently gave a talk on protocols and protocol oriented programming, and while writing it I came up with three kinds of protocols:<br></p><p>- Basic protocols, without type aliases or parents with type aliases, usable against any value or class type<br>- Objective-C protocols, without the possibility of type aliases, restricted to being implemented by Objective-C classes and supporting optional methods<br>- “Deferred Type” protocols, with type aliases or a parent with a type alias, where conformance is too flexible for the protocol to be used safely without the compiler knowing the implementing type. These protocols are only usable in a context where the compiler can figure out the conforming type, which it then uses statically<br></p><p>I lamented that protocol is used to describe the third type as well as the first two.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/682103f9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>You can achieve the same result more cleanly with<br></p><p>func maxY&lt;T:P, U:P&gt;(p1:T, p2: U) -&gt; Int {<br>  return max(p1.y, p2.y)   // No problems here!<br>}<br></p><p>On Mon, Dec 14, 2015 at 10:03 AM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 13, 2015, at 11:56 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Is there any info yet if and how we will be able to refer to instances of<br>&gt; protocols that have associated types?<br>&gt;<br>&gt;<br>&gt; As far as I know, this isn&#39;t a solvable problem.<br>&gt;<br>&gt;<br>&gt; What is the difficulty in supporting this?<br>&gt;<br>&gt;<br>&gt; Here&#39;s a simple example:<br>&gt;<br>&gt; protocol P {<br>&gt;   typealias A<br>&gt;   var x: A { get set }<br>&gt; }<br>&gt;<br>&gt; struct Y : P {<br>&gt;   var x: Int<br>&gt; }<br>&gt;<br>&gt; struct Z : P {<br>&gt;   var x: String<br>&gt; }<br>&gt;<br>&gt; func f(p1: P, p2: P) {<br>&gt;   p1.x = p2.x // assigning an Int to a String?<br>&gt; }<br>&gt;<br>&gt;<br>&gt; p1.x = p2.x should be a compiler error, because there’s not enough type<br>&gt; information. But that shouldn’t stop a programmer from doing this:<br>&gt;<br>&gt; protocol P {<br>&gt;   typealias A<br>&gt;   var x: A { get set }<br>&gt;   var y: Int<br>&gt; }<br>&gt;<br>&gt; struct Y : P {<br>&gt;   var x: Int<br>&gt;   var y: Int<br>&gt; }<br>&gt;<br>&gt; struct Z : P {<br>&gt;   var x: String<br>&gt;   var y: Int<br>&gt; }<br>&gt;<br>&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br>&gt;<br>&gt; …right?<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/deddc060/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>A protocol X could fulfill conformance to a protocol Y.<br></p><p>protocol SomeProtocol: Equatable {}<br>enum SomeType1: SomeProtocol { case Case }<br>enum SomeType2: SomeProtocol { case Case }<br></p><p>func == (a: SomeProtocol, b: SomeProtocol) -&gt; Bool { // should be allowed<br>to use protocol directly<br>  switch (a, b) {<br>  case let (a, b) as (SomeType1, SomeType1): return a == b<br>  case let (a, b) as (SomeType2, SomeType2): return a == b<br>  default: return false<br>  }<br>}<br></p><p>// Equatable requirement is fulfilled for SomeProtocol<br>let a: SomeProtocol = SomeType1.Case // should be allowed to use protocol<br>directly<br>let b: SomeProtocol = SomeType2.Case<br>print(a == b) // should print &quot;false&quot;<br></p><p>var array = [SomeProtocol]() // should be allowed to use protocol directly<br></p><p>That kind of conformance fulfillment should not be inherited though or else<br>this could cause a recursion, i.e. types implementing the protocol must<br>still conform to<br></p><p>Since SomeProtocol has internal visibility all types and protocols<br>explicitly declaring conformance are even known at compile-time.<br>For that reason implementing the equality operator for the protocol<br>wouldn&#39;t even be necessary. The compiler does already know that all types<br>conforming to the protocol are equatable and could even generate the<br>equality operator.<br></p><p><br>I find the suggestion from Paul Cantrell very useful where you can use all<br>properties and methods of the protocol which do not depend on an associated<br>type or Self.<br></p><p>var array = [Hashable]()<br>// …<br>for element in array {<br>    print(element.hashValue)<br>}<br></p><p>Who cares that it doesn&#39;t fulfill Equatable conformance yet?<br></p><p><br>On Mon, Dec 14, 2015 at 8:40 AM, ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You can achieve the same result more cleanly with<br>&gt;<br>&gt; func maxY&lt;T:P, U:P&gt;(p1:T, p2: U) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 10:03 AM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 13, 2015, at 11:56 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Is there any info yet if and how we will be able to refer to instances of<br>&gt;&gt; protocols that have associated types?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As far as I know, this isn&#39;t a solvable problem.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What is the difficulty in supporting this?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Here&#39;s a simple example:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   typealias A<br>&gt;&gt;   var x: A { get set }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Y : P {<br>&gt;&gt;   var x: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Z : P {<br>&gt;&gt;   var x: String<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func f(p1: P, p2: P) {<br>&gt;&gt;   p1.x = p2.x // assigning an Int to a String?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; p1.x = p2.x should be a compiler error, because there’s not enough type<br>&gt;&gt; information. But that shouldn’t stop a programmer from doing this:<br>&gt;&gt;<br>&gt;&gt; protocol P {<br>&gt;&gt;   typealias A<br>&gt;&gt;   var x: A { get set }<br>&gt;&gt;   var y: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Y : P {<br>&gt;&gt;   var x: Int<br>&gt;&gt;   var y: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct Z : P {<br>&gt;&gt;   var x: String<br>&gt;&gt;   var y: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …right?<br>&gt;&gt;<br>&gt;&gt; Cheers, P<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/81257783/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/661c58274e3f437234236553e2dc156f?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Martin Kühl</string> &lt;martin.kuehl at gmail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>On 14 December 2015 at 14:20, Marc Knaup via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I find the suggestion from Paul Cantrell very useful where you can use all properties and methods of the protocol which do not depend on an associated type or Self.<br>&gt;<br>&gt; var array = [Hashable]()<br>&gt; // …<br>&gt; for element in array {<br>&gt;     print(element.hashValue)<br>&gt; }<br>&gt;<br>&gt; Who cares that it doesn&#39;t fulfill Equatable conformance yet?<br>&gt;<br></p><p>Exactly. This would let us write a function like<br></p><p>    func hash(Hashable... values) -&gt; Int {<br>        // calculate combined hashValue from all hashable values<br>    }<br></p><p>analogous to Guava&#39;s Objects.hashCode to help implement hashValue in<br>custom structs.<br></p><p>Martin<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 1:37 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …right?<br>&gt; <br>&gt; Ah, but then you have the situation that P doesn&#39;t conform to P (it doesn&#39;t have an x that you can access).  In my opinion that is just too weird an idea to be usable.<br>&gt; Personally, I have always thought that protocols intended to be used as unbound existentials (not P&lt;A: Int&gt;, just plain P) are different beasts entirely from the kind used as generic constraints and should be explicitly declared as such—I don&#39;t think I&#39;ve ever seen a protocol that is well-used in both ways; if you have counterexamples I&#39;d love to see them.  In &quot;existential protocols,&quot; declaring an associated type or creating a self requirement would be an error at the point of declaration.  <br></p><p>IMHO, it’s an artificial distinction that makes sense only if you’re acclimated to Swift’s current behavior.<br></p><p>There are plenty of situations where you really do want a generic type in the protocol, but you nonetheless find yourself in situations where you care only about the parts of the protocol that don’t depend on that generic type.<br></p><p>Here’s an example, pared down a lot but taken from an actual project:<br></p><p>    protocol Request<br>        {<br>        typealias ContentType<br>        <br>        func onCompletion(callback: (ContentType?, ErrorType?) -&gt; Void)<br>        func onSuccess(callback: ContentType -&gt; Void)<br>        func onNewData(callback: ContentType -&gt; Void)<br>        func onFailure(callback: ErrorType -&gt; Void)<br>        <br>        func cancel()<br>        }<br></p><p>    struct RequestBatch<br>        {<br>        var requests: [Request]  // Sadness. Despair. DOOOOM.<br>        <br>        func cancelAll()<br>            {<br>            for request in requests<br>                { request.cancel() }<br>            }<br>        }<br></p><p>The current Swift solution is either to ditch the type safety of ContentType, or split Request into two protocols. The latter makes the API hard to read, and may decouple related protocol requirements that don’t make sense independently.<br></p><p>&gt; On Dec 14, 2015, at 1:40 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; You can achieve the same result more cleanly with <br>&gt; <br>&gt; func maxY&lt;T:P, U:P&gt;(p1:T, p2: U) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br></p><p>True, but this doesn’t generalize to other contexts, e.g. RequestBatch.requests above.<br></p><p>Conceptually, at least to me, a protocol describes a set of related capabilities that together add up to a meaningful behavior. Whether some of those capabilities share a generic type is incidental, and does not fundamentally change the nature of a protocol. Protocols should be protocols.<br></p><p>Java can do this via the &lt;?&gt; syntax:<br></p><p>    interface Request&lt;ContentType&gt;<br>        {<br>        void onCompletion(CompletionCallback&lt;ContentType&gt; callback);<br>        void onSuccess(SuccessCallback&lt;ContentType&gt; callback);<br>        void onNewData(SuccessCallback&lt;ContentType&gt; callback);<br>        void onFailure(FailureCallback&lt;ContentType&gt; callback);<br>        <br>        void cancel();<br>        }<br></p><p>    class RequestBatch<br>        {<br>        private List&lt;Request&lt;?&gt;&gt; requests;<br>        <br>        public void cancelAll()<br>            {<br>            for(Request&lt;?&gt; request: requests)<br>                { request.cancel(); }<br>            }<br>        }<br></p><p>And yes, “Java can do it” is a deliberate provocation! :P<br></p><p>Cheers,<br></p><p>Paul<br></p><p>–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––<br>https://innig.net • @inthehands • http://siestaframework.com/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/d9e8e172/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>Isn&#39;t this issue related to what Kotlin tries to solve with in/out<br>variances (and star-projection)?<br>https://kotlinlang.org/docs/reference/generics.html<br></p><p>Btw. what was the reason again that protocols use a typealias syntax<br>instead of &quot;protocol Protocol&lt;T&gt;&quot;?<br></p><p>On Mon, Dec 14, 2015 at 4:47 PM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 14, 2015, at 1:37 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br>&gt;<br>&gt; …right?<br>&gt;<br>&gt;<br>&gt; Ah, but then you have the situation that P doesn&#39;t conform to P (it<br>&gt; doesn&#39;t have an x that you can access).  In my opinion that is just too<br>&gt; weird an idea to be usable.<br>&gt; Personally, I have always thought that protocols intended to be used as<br>&gt; unbound existentials (not P&lt;A: Int&gt;, just plain P) are different beasts<br>&gt; entirely from the kind used as generic constraints and should be explicitly<br>&gt; declared as such—I don&#39;t think I&#39;ve ever seen a protocol that is well-used<br>&gt; in both ways; if you have counterexamples I&#39;d love to see them.  In<br>&gt; &quot;existential protocols,&quot; declaring an associated type or creating a self<br>&gt; requirement would be an error at the point of declaration.<br>&gt;<br>&gt;<br>&gt; IMHO, it’s an artificial distinction that makes sense only if you’re<br>&gt; acclimated to Swift’s current behavior.<br>&gt;<br>&gt; There are plenty of situations where you really do want a generic type in<br>&gt; the protocol, but you nonetheless find yourself in situations where you<br>&gt; care only about the parts of the protocol that don’t depend on that generic<br>&gt; type.<br>&gt;<br>&gt; Here’s an example, pared down a lot but taken from an actual project:<br>&gt;<br>&gt;     protocol Request<br>&gt;         {<br>&gt;         typealias ContentType<br>&gt;<br>&gt;<br>&gt;         func onCompletion(callback: (ContentType?, ErrorType?) -&gt; Void)<br>&gt;         func onSuccess(callback: ContentType -&gt; Void)<br>&gt;         func onNewData(callback: ContentType -&gt; Void)<br>&gt;<br>&gt;         func onFailure(callback: ErrorType -&gt; Void)<br>&gt;<br>&gt;<br>&gt;         func cancel()<br>&gt;         }<br>&gt;<br>&gt;     struct RequestBatch<br>&gt;         {<br>&gt;         var requests: [Request]  // Sadness. Despair. DOOOOM.<br>&gt;<br>&gt;<br>&gt;         func cancelAll()<br>&gt;             {<br>&gt;             for request in requests<br>&gt;                 { request.cancel() }<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; The current Swift solution is either to ditch the type safety of<br>&gt; ContentType, or split Request into two protocols. The latter makes the API<br>&gt; hard to read, and may decouple related protocol requirements that don’t<br>&gt; make sense independently.<br>&gt;<br>&gt; On Dec 14, 2015, at 1:40 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; You can achieve the same result more cleanly with<br>&gt;<br>&gt; func maxY&lt;T:P, U:P&gt;(p1:T, p2: U) -&gt; Int {<br>&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt; }<br>&gt;<br>&gt;<br>&gt; True, but this doesn’t generalize to other contexts, e.g.<br>&gt; RequestBatch.requests above.<br>&gt;<br>&gt; Conceptually, at least to me, a protocol describes a set of related<br>&gt; capabilities that together add up to a meaningful behavior. Whether some of<br>&gt; those capabilities share a generic type is incidental, and does not<br>&gt; fundamentally change the nature of a protocol. Protocols should be<br>&gt; protocols.<br>&gt;<br>&gt; Java can do this via the &lt;?&gt; syntax:<br>&gt;<br>&gt;     interface Request&lt;ContentType&gt;<br>&gt;         {<br>&gt;         void onCompletion(CompletionCallback&lt;ContentType&gt; callback);<br>&gt;         void onSuccess(SuccessCallback&lt;ContentType&gt; callback);<br>&gt;         void onNewData(SuccessCallback&lt;ContentType&gt; callback);<br>&gt;         void onFailure(FailureCallback&lt;ContentType&gt; callback);<br>&gt;<br>&gt;<br>&gt;         void cancel();<br>&gt;         }<br>&gt;<br>&gt;     class RequestBatch<br>&gt;         {<br>&gt;         private List&lt;Request&lt;?&gt;&gt; requests;<br>&gt;<br>&gt;<br>&gt;         public void cancelAll()<br>&gt;             {<br>&gt;             for(Request&lt;?&gt; request: requests)<br>&gt;                 { request.cancel(); }<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; And yes, “Java can do it” is a deliberate provocation! :P<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––<br>&gt; https://innig.net • @inthehands • http://siestaframework.com/<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f0788350/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:47 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 1:37 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; func maxY(p1: P, p2: P) -&gt; Int {<br>&gt;&gt;&gt;   return max(p1.y, p2.y)   // No problems here!<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …right?<br>&gt;&gt; <br>&gt;&gt; Ah, but then you have the situation that P doesn&#39;t conform to P (it doesn&#39;t have an x that you can access).  In my opinion that is just too weird an idea to be usable.<br>&gt;&gt; Personally, I have always thought that protocols intended to be used as unbound existentials (not P&lt;A: Int&gt;, just plain P) are different beasts entirely from the kind used as generic constraints and should be explicitly declared as such—I don&#39;t think I&#39;ve ever seen a protocol that is well-used in both ways; if you have counterexamples I&#39;d love to see them.  In &quot;existential protocols,&quot; declaring an associated type or creating a self requirement would be an error at the point of declaration.  <br>&gt; <br>&gt; IMHO, it’s an artificial distinction that makes sense only if you’re acclimated to Swift’s current behavior.<br>&gt; <br>&gt; There are plenty of situations where you really do want a generic type in the protocol, but you nonetheless find yourself in situations where you care only about the parts of the protocol that don’t depend on that generic type.<br>&gt; <br>&gt; Here’s an example, pared down a lot but taken from an actual project:<br>&gt; <br>&gt;     protocol Request<br>&gt;         {<br>&gt;         typealias ContentType<br>&gt;         <br>&gt;         func onCompletion(callback: (ContentType?, ErrorType?) -&gt; Void)<br>&gt;         func onSuccess(callback: ContentType -&gt; Void)<br>&gt;         func onNewData(callback: ContentType -&gt; Void)<br>&gt;         func onFailure(callback: ErrorType -&gt; Void)<br>&gt;         <br>&gt;         func cancel()<br>&gt;         }<br>&gt; <br>&gt;     struct RequestBatch<br>&gt;         {<br>&gt;         var requests: [Request]  // Sadness. Despair. DOOOOM.<br>&gt;         <br>&gt;         func cancelAll()<br>&gt;             {<br>&gt;             for request in requests<br>&gt;                 { request.cancel() }<br>&gt;             }<br>&gt;         }<br>&gt; <br>&gt; The current Swift solution is either to ditch the type safety of ContentType, or split Request into two protocols. The latter makes the API hard to read, and may decouple related protocol requirements that don’t make sense independently.<br></p><p>IMO the fact that you created an a array of requests and wrote cancelAll above *demonstrates* that the cancel requirement makes sense independently from the others.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/718d9f18/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 10:01 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;     struct RequestBatch<br>&gt;&gt;         {<br>&gt;&gt;         var requests: [Request]  // Sadness. Despair. DOOOOM.<br>&gt;&gt;         <br>&gt;&gt;         func cancelAll()<br>&gt;&gt;             {<br>&gt;&gt;             for request in requests<br>&gt;&gt;                 { request.cancel() }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; The current Swift solution is either to ditch the type safety of ContentType, or split Request into two protocols. The latter makes the API hard to read, and may decouple related protocol requirements that don’t make sense independently.<br>&gt; <br>&gt; IMO the fact that you created an a array of requests and wrote cancelAll above *demonstrates* that the cancel requirement makes sense independently from the others.<br></p><p>…and therein lies the danger of small examples trimmer from larger projects. In the actual project, I end up with a family of related behaviors where the “cancel / everything else” separation no longer makes sense.<br></p><p>Here’s a little more context — still a super pared down toy example, but hopefully enough to demonstrate. What I want:<br></p><p>    protocol Resource<br>        {<br>        typealias ContentType<br>        <br>        var allRequests: [Request&lt;ContentType&gt;] { get }<br>        var latestData: ContentType? { get }<br>        func load() -&gt; Request&lt;ContentType&gt;<br>        }<br></p><p>    protocol Request<br>        {<br>        typealias ContentType<br>        <br>        func onSuccess(callback: ContentType -&gt; Void)<br>        func onFailure(callback: ErrorType -&gt; Void)<br>        func cancel()<br>        }<br></p><p>    struct ResourceBatch<br>        {<br>        var observedResources: [Resource]<br>        var reloadsInProgress: Int = 0<br>        <br>        func reloadAll()<br>            {<br>            for resource in observedResources<br>                {<br>                reloadsInProgress += 1<br>                resource.load().onSuccess<br>                    { _ in self.reloadsInProgress -= 1 }<br>                }<br>            }<br>        <br>        func cancelAll()<br>            {<br>            for resource in observedResources<br>                {<br>                for request in resource.allRequests<br>                    { request.cancel() }<br>                }<br>            }<br>        }<br></p><p>And here’s the nonsense I have to engage in to make this work with Swift as it stands:<br></p><p>    protocol AnyResource<br>        {<br>        var allRequests: [AnyRequest] { get }<br>        var anyLatestData: Any? { get }<br>        func load() -&gt; AnyRequest<br>        }<br></p><p>    protocol Resource: AnyResource<br>        {<br>        typealias ContentType<br>        <br>        var allRequests: [AnyRequest] { get }  // ← Still no way to make this typesafe<br>        var latestData: ContentType? { get }<br>        <br>        func load&lt;RequestType: Request where RequestType.ContentType == Self.ContentType&gt;() -&gt; RequestType<br>        }<br></p><p>    protocol AnyRequest<br>        {<br>        func onSuccess(callback: Any -&gt; Void)<br>        func onFailure(callback: ErrorType -&gt; Void)<br>        func cancel()<br>        }<br></p><p>    protocol Request: AnyRequest<br>        {<br>        typealias ContentType<br>        <br>        func onSuccess(callback: ContentType -&gt; Void)<br>        }<br></p><p>    struct ResourceBatch<br>        {<br>        var observedResources: [AnyResource]<br>        var reloadsInProgress: Int = 0<br>        <br>        mutating func reloadAll()<br>            {<br>            for resource in observedResources<br>                {<br>                reloadsInProgress += 1<br>                resource.load().onSuccess<br>                    { _ in self.reloadsInProgress -= 1 }<br>                }<br>            }<br>        <br>        func cancelAll()<br>            {<br>            for resource in observedResources<br>                {<br>                for request in resource.allRequests<br>                    { request.cancel() }<br>                }<br>            }<br>        }<br></p><p>Still just a sketch, but already the problems abound.<br></p><p>This Resource / AnyResource and Request / AnyRequest distinction makes no useful sense to the user of this library; it’s just there to satisfy Swift’s type system. “Resource whose ContentType is known at compile time” and “Resource whose ContentType is unknown at compile time” are still the same construct, conceptually and semantically, just with varying degrees of type information. They should not be two types.<br></p><p>I tried playing out this approach in Siesta, and it lead to a combinatorial explosion of duplicated methods, and numerous type inference problems related to the collision of methods that differed only by Any vs. ContentType. I wasn’t willing to inflict the resulting API on my users.<br></p><p>Maybe I’m missing something big. David, you certainly know Swift better than I do. If there’s a better way to do this, I would love to hear about it!<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/504b5173/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 9:56 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 3:55 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey guys,<br>&gt;&gt; <br>&gt;&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt;&gt; <br>&gt;&gt; Is there any info yet if and how we will be able to refer to instances of protocols that have associated types?<br>&gt; <br>&gt; As far as I know, this isn&#39;t a solvable problem.<br></p><p>There are solutions to common patterns that we can and should support. If there are only associated types, then the dynamic type &#39;protocol&lt;Fooable where Foo == SomeSpecificType&gt; is often useful; the standard library itself fakes dynamic type containers for SequenceType and GeneratorType that do this.<br></p><p>For protocols like Equatable and Hashable with Self parameter requirements, it&#39;s true that the compiler can&#39;t implicitly produce an Equatable dynamic type that conforms to Equatable. There are a couple possible solutions to this. There&#39;s a fairly obvious generalized implementation that could be provided manually:<br></p><p>extension Equatable: Equatable {}<br>func ==(x: Equatable, y: Equatable) -&gt; Bool {<br>  // If the values are the same type, use that type&#39;s == operator.<br>  // Pretend that &#39;as? dynamicType&#39; works<br>  if let yAsX = y as? x.dynamicType {<br>    return x == yAsX<br>  }<br>  // Values of different type aren&#39;t ==.<br>  return false<br>}<br></p><p>We&#39;d want to tweak the language rules for implicit promotion so that things like `1 == 1.0` don&#39;t implicitly choose the heterogeneous Equatable implementation of `==`, but this would otherwise allow for protocols to require Equatable and Hashable without forgoing the ability to be useful dynamic types.<br></p><p>Another possibility is to generalize Equatable so that a conforming type or refining protocol can control how dynamic its equatability is:<br></p><p>protocol Equatable {<br>  // The upper bound of type that this type can be equated with. Defaults to `Self`.<br>  typealias EquatesWith = Self<br></p><p>  // `EquatesWith` must be `Self` or a supertype of `Self`.<br>  where Self: EquatesWith<br></p><p>  func ==(_: EquatesWith, _: EquatesWith) -&gt; Bool<br>}<br></p><p>A dynamic protocol can then refine Equatable or Hashable by equating with its own dynamic type, rather than defaulting to strict equatability:<br></p><p>protocol Drawable: Hashable {<br>  // All Drawables must be equatable with all other Drawables.<br>  where EquatesWith == Drawable<br></p><p>  func draw()<br>}<br></p><p>-Joe<br></p><p>&gt;&gt; What is the difficulty in supporting this?<br>&gt; <br>&gt; Here&#39;s a simple example:<br>&gt; <br>&gt; protocol P {<br>&gt;   typealias A<br>&gt;   var x: A { get set }<br>&gt; }<br>&gt; <br>&gt; struct Y : P {<br>&gt;   var x: Int<br>&gt; }<br>&gt; <br>&gt; struct Z : P {<br>&gt;   var x: String<br>&gt; }<br>&gt; <br>&gt; func f(p1: P, p2: P) {<br>&gt;   p1.x = p2.x // assigning an Int to a String?<br>&gt; }<br>&gt;   <br>&gt;&gt; Simple examples:<br>&gt;&gt; var list = [Hashable]()<br>&gt;&gt; var hashable: Hashable = 2<br>&gt;&gt; <br>&gt;&gt; Right now all we get is<br>&gt;&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; <br>&gt; In this case it&#39;s &quot;self requirements&quot; inherited from Equatable that make instances of Hashable impossible.<br>&gt; That said, providing for sets/dictionaries of heterogeneous values is a problem we&#39;re interested in solving in the standard library.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/17d64118/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a03106b2fbee9e0ada822057dfd0b6d3?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Tal Atlas</string> &lt;me at tal.by&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>This is the error that gets in my way the most when trying to do protocol<br>oriented programming. It can be super frustrating. That lead me to make a<br>proposal a few weeks back for having generic protocols.<br></p><p>In that proposal some swift core people expressed that they were keenly<br>aware of said pain. And while they didn&#39;t deliver details in time or<br>implementation they expressed that there were efforts ongoing to solve it.<br></p><p>On Sun, Dec 13, 2015 at 6:55 PM Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hey guys,<br>&gt;<br>&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt;<br>&gt; Is there any info yet if and how we will be able to refer to instances of<br>&gt; protocols that have associated types?<br>&gt; What is the difficulty in supporting this?<br>&gt;<br>&gt; Simple examples:<br>&gt; var list = [Hashable]()<br>&gt; var hashable: Hashable = 2<br>&gt;<br>&gt; Right now all we get is<br>&gt;<br>&gt;&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it<br>&gt;&gt; has Self or associated type requirements<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt;   Marc<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/180c2d68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 15, 2015 at 01:00:00am</p></header><div class="content"><p>I agree that this is an issue, I&#39;d really like to see a language feature to<br>address it.<br></p><p>In some circumstances you can work around the issue with type-erasure. You<br>implement a generic wrapper (like AnySequence) that can take anything<br>conforming to that protocol and expose it with a single concrete interface.<br></p><p>I learnt a lot implementing a few of these. There&#39;s a good article on it<br>here:<br>https://realm.io/news/type-erased-wrappers-in-swift/<br></p><p>I wouldn&#39;t be too surprised if Apple formalises type erasure somehow, the<br>implementation is very mechanical and could be automated. For example: If<br>you have a protocol MyProtocol that has type requirements then perhaps<br>MyProtocol.Any would refer to an automatically generated type erased<br>concrete type. I suppose you could also do:<br></p><p>typealias AB = protocol&lt;A,B&gt;<br>AB.Any<br></p><p>The main problem with current implementations seems to be, for example:<br>ZipSequence is a SequenceType, but ZipSequence is not an AnySequence.<br></p><p>Also you cannot necessarily conform to a protocol if it has things like<br>initialiser requirements.<br></p><p><br></p><p><br></p><p>On Tue, Dec 15, 2015 at 12:45 AM, Tal Atlas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is the error that gets in my way the most when trying to do protocol<br>&gt; oriented programming. It can be super frustrating. That lead me to make a<br>&gt; proposal a few weeks back for having generic protocols.<br>&gt;<br>&gt; In that proposal some swift core people expressed that they were keenly<br>&gt; aware of said pain. And while they didn&#39;t deliver details in time or<br>&gt; implementation they expressed that there were efforts ongoing to solve it.<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 6:55 PM Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hey guys,<br>&gt;&gt;<br>&gt;&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt;&gt;<br>&gt;&gt; Is there any info yet if and how we will be able to refer to instances of<br>&gt;&gt; protocols that have associated types?<br>&gt;&gt; What is the difficulty in supporting this?<br>&gt;&gt;<br>&gt;&gt; Simple examples:<br>&gt;&gt; var list = [Hashable]()<br>&gt;&gt; var hashable: Hashable = 2<br>&gt;&gt;<br>&gt;&gt; Right now all we get is<br>&gt;&gt;<br>&gt;&gt;&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it<br>&gt;&gt;&gt; has Self or associated type requirements<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;   Marc<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/b3d911ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>@Andrew sure you could provide an init implementation for a protocol. It<br>would be like a factory for that protocol similar to class clusters in<br>Objective-C.<br>Actually a proposal I&#39;m working on depends on that being possible somehow :)<br></p><p>On Mon, Dec 14, 2015 at 3:02 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; I agree that this is an issue, I&#39;d really like to see a language feature<br>&gt; to address it.<br>&gt;<br>&gt; In some circumstances you can work around the issue with type-erasure. You<br>&gt; implement a generic wrapper (like AnySequence) that can take anything<br>&gt; conforming to that protocol and expose it with a single concrete interface.<br>&gt;<br>&gt; I learnt a lot implementing a few of these. There&#39;s a good article on it<br>&gt; here:<br>&gt; https://realm.io/news/type-erased-wrappers-in-swift/<br>&gt;<br>&gt; I wouldn&#39;t be too surprised if Apple formalises type erasure somehow, the<br>&gt; implementation is very mechanical and could be automated. For example: If<br>&gt; you have a protocol MyProtocol that has type requirements then perhaps<br>&gt; MyProtocol.Any would refer to an automatically generated type erased<br>&gt; concrete type. I suppose you could also do:<br>&gt;<br>&gt; typealias AB = protocol&lt;A,B&gt;<br>&gt; AB.Any<br>&gt;<br>&gt; The main problem with current implementations seems to be, for example:<br>&gt; ZipSequence is a SequenceType, but ZipSequence is not an AnySequence.<br>&gt;<br>&gt; Also you cannot necessarily conform to a protocol if it has things like<br>&gt; initialiser requirements.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 15, 2015 at 12:45 AM, Tal Atlas via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is the error that gets in my way the most when trying to do protocol<br>&gt;&gt; oriented programming. It can be super frustrating. That lead me to make a<br>&gt;&gt; proposal a few weeks back for having generic protocols.<br>&gt;&gt;<br>&gt;&gt; In that proposal some swift core people expressed that they were keenly<br>&gt;&gt; aware of said pain. And while they didn&#39;t deliver details in time or<br>&gt;&gt; implementation they expressed that there were efforts ongoing to solve it.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 13, 2015 at 6:55 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hey guys,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there any info yet if and how we will be able to refer to instances<br>&gt;&gt;&gt; of protocols that have associated types?<br>&gt;&gt;&gt; What is the difficulty in supporting this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Simple examples:<br>&gt;&gt;&gt; var list = [Hashable]()<br>&gt;&gt;&gt; var hashable: Hashable = 2<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right now all we get is<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it<br>&gt;&gt;&gt;&gt; has Self or associated type requirements<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;   Marc<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/05914114/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>It is definitely possible to solve this problem for associated types by binding or constraining them.  The ML module system has a feature that is roughly analogous to this.  <br></p><p>I think Self is quite a bit trickier, although there is effectively a implicit constraint that Self conforms to the protocol in question so it may be possible to make use of that information.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 14, 2015, at 8:02 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that this is an issue, I&#39;d really like to see a language feature to address it.<br>&gt; <br>&gt; In some circumstances you can work around the issue with type-erasure. You implement a generic wrapper (like AnySequence) that can take anything conforming to that protocol and expose it with a single concrete interface.<br>&gt; <br>&gt; I learnt a lot implementing a few of these. There&#39;s a good article on it here:<br>&gt; https://realm.io/news/type-erased-wrappers-in-swift/<br>&gt; <br>&gt; I wouldn&#39;t be too surprised if Apple formalises type erasure somehow, the implementation is very mechanical and could be automated. For example: If you have a protocol MyProtocol that has type requirements then perhaps MyProtocol.Any would refer to an automatically generated type erased concrete type. I suppose you could also do:<br>&gt; <br>&gt; typealias AB = protocol&lt;A,B&gt;<br>&gt; AB.Any<br>&gt; <br>&gt; The main problem with current implementations seems to be, for example: ZipSequence is a SequenceType, but ZipSequence is not an AnySequence.<br>&gt; <br>&gt; Also you cannot necessarily conform to a protocol if it has things like initialiser requirements.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 12:45 AM, Tal Atlas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; This is the error that gets in my way the most when trying to do protocol oriented programming. It can be super frustrating. That lead me to make a proposal a few weeks back for having generic protocols.<br>&gt;&gt; <br>&gt;&gt; In that proposal some swift core people expressed that they were keenly aware of said pain. And while they didn&#39;t deliver details in time or implementation they expressed that there were efforts ongoing to solve it. <br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 13, 2015 at 6:55 PM Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hey guys,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m looking at Swift 3.0&#39;s goal to improve generics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any info yet if and how we will be able to refer to instances of protocols that have associated types?<br>&gt;&gt;&gt; What is the difficulty in supporting this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Simple examples:<br>&gt;&gt;&gt; var list = [Hashable]()<br>&gt;&gt;&gt; var hashable: Hashable = 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now all we get is<br>&gt;&gt;&gt;&gt; protocol &#39;Hashable&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;   Marc<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/d63e7a3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 14, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 6:23 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It is definitely possible to solve this problem for associated types by binding or constraining them.  The ML module system has a feature that is roughly analogous to this.  <br></p><p>Keep in mind that a language feature like binding/constraining associated types is not a complete solution for real use-cases, so we would still need AnySequence&lt;Element&gt; in the library.  Otherwise it would be SequenceType&lt;Generator: SomeGenerator&gt;, which binds a type that you don&#39;t actually want to expose.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/3c8ebb0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; It is definitely possible to solve this problem for associated types by binding or constraining them.  The ML module system has a feature that is roughly analogous to this.  <br>&gt; <br>&gt; Keep in mind that a language feature like binding/constraining associated types is not a complete solution for real use-cases, so we would still need AnySequence&lt;Element&gt; in the library.  Otherwise it would be SequenceType&lt;Generator: SomeGenerator&gt;, which binds a type that you don&#39;t actually want to expose.<br>&gt; <br></p><p>Wouldn’t we get a lot of utility by binding / constraining Generator.Element?  Something like:<br></p><p>protocol&lt;SequenceType where Generator.Element == Int&gt;<br>or<br>protocol&lt;SequenceType where Generator.Element: Equatable&gt;<br></p><p>In that case we don’t know the specific binding of SequenceType’s Generator but we do know what constraints or binding its Element must have.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/56f9a64a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 7:40 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 6:23 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is definitely possible to solve this problem for associated types by binding or constraining them.  The ML module system has a feature that is roughly analogous to this.  <br>&gt; <br>&gt; Keep in mind that a language feature like binding/constraining associated types is not a complete solution for real use-cases, so we would still need AnySequence&lt;Element&gt; in the library.  Otherwise it would be SequenceType&lt;Generator: SomeGenerator&gt;, which binds a type that you don&#39;t actually want to expose.<br></p><p>With generic typealiases, you could say something like this:<br></p><p>typealias AnySequence&lt;Element&gt; =<br>  protocol&lt;SequenceType where Generator.Element == Element&gt;<br></p><p>However, once we add &#39;where&#39; requirements to protocols, it seems to me &#39;Element&#39; really ought to be a direct requirement of SequenceType, like this:<br></p><p>protocol SequenceType {<br>  typealias Element<br>  typealias Generator: GeneratorType<br>    where Element == Generator.Element<br>}<br></p><p>which would save generic code from having to splatter &#39;.Generator.Element&#39; everywhere, and make unspecialized code more efficient, since the type metadata for Element would be directly available from the SequenceType protocol witness table instead of needing an extra indirection through to its Generator&#39;s GeneratorType table.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/72f28003/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>Shouldn’t we just narrow the type of protocols with associated types and/or Self types when the protocol is used as a type?<br></p><p><br>// (1) Associated types<br></p><p>protocol Bounds {<br>    func doSomething()<br>}<br></p><p>protocol Foo {<br>    <br>    // associated type with bounds<br>    typealias T where T: Bounds<br></p><p>    // getter is covariant, setter is contravariant<br>    var value: T { get set }<br>    <br>    // result is covariant<br>    func foo() -&gt; T<br>    <br>    // arg is contravariant<br>    func bar(arg: T)<br>    func baz(arg: T) -&gt; T<br>    <br>    // arg of arg is covariant<br>    func f(g: T -&gt; Void)<br>}<br></p><p><br>var foo: Foo<br></p><p>// Covariant places of associated type T<br>// are ok and use bounds of T <br>// (i.e. Any if no bounds are given).<br>// In our example the bounds are &quot;Bounds&quot;<br>let x: Bounds = foo.value<br>let y: Bounds = foo.foo()<br>foo.f { (z: Bounds) in z.doSomething() }<br></p><p>// Contravariant places of associated type T<br>// are forbidden, i.e. methods containing T<br>// as argument or setters of variables of type T<br>// are not allowed. In effect they are not part<br>// of the type Foo.<br>foo.value = x // ERROR: calling setter not allowed<br>foo.bar(x) // ERROR: not allowed<br>let z: Bounds = foo.baz(x) // ERROR: not allowed<br></p><p><br>// (2) Self types<br></p><p>protocol Bar {<br>    <br>    var value: Self { get set }<br>    func foo() -&gt; Self<br>    func bar(arg: Self)<br>    func baz(arg: Self) -&gt; Self<br>    func f(g: Self -&gt; Void)<br>}<br></p><p>// Same as for associated types, just<br>// that the bounds for Self are the protocol<br>// itself, i.e. in this example: Bar<br></p><p><br>// (3) Constraining protocols with associated types or self types<br></p><p>protocol Child : Bounds {}<br></p><p>let foo2: Foo where T: Child // would work like above with narrower bounds Child<br>let foo3: Foo where T == Child // would make all methods and setters available with T == Child<br></p><p><br>// (4) Equatable and Set<br></p><p>// Equatable with associated type EquatableWith like suggested by Joe Groff<br>public protocol Equatable {<br>    typealias EquatesWith = Self where Self: EquatesWith<br>    func ==(lhs: EquatesWith, rhs: EquatesWith) -&gt; Bool<br>}<br></p><p>protocol P : Hashable {<br>    typealias EquatesWith = P // fixing the associated type of Equatable<br>    typealias T where T: Bounds<br>    func foo() -&gt; T<br>    var id: Int<br>}<br></p><p>func ==(lhs: P, rhs: P) -&gt; Bool {<br>    return lhs.id == rhs.id // accessing id is ok<br>}<br></p><p>var p1: P<br>var p2: P<br>if p1 == p2 { // ok, because EquatableWith has been fixed to be of type P<br>    print(&quot;Ok!&quot;)<br>}<br></p><p>var ps: Set&lt;P&gt; // now ok, because == can be used on variables of type p<br>ps.insert(p1)<br>ps.insert(p2)<br>var bs: [Bounds] = ps.map { $0.foo() } // ok<br></p><p><br>With the proposed change of  <br>-Thorsten<br></p><p><br></p><p>&gt; Am 14.12.2015 um 19:32 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 14, 2015, at 7:40 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 6:23 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is definitely possible to solve this problem for associated types by binding or constraining them.  The ML module system has a feature that is roughly analogous to this.  <br>&gt;&gt; <br>&gt;&gt; Keep in mind that a language feature like binding/constraining associated types is not a complete solution for real use-cases, so we would still need AnySequence&lt;Element&gt; in the library.  Otherwise it would be SequenceType&lt;Generator: SomeGenerator&gt;, which binds a type that you don&#39;t actually want to expose.<br>&gt; <br>&gt; With generic typealiases, you could say something like this:<br>&gt; <br>&gt; typealias AnySequence&lt;Element&gt; =<br>&gt;   protocol&lt;SequenceType where Generator.Element == Element&gt;<br>&gt; <br>&gt; However, once we add &#39;where&#39; requirements to protocols, it seems to me &#39;Element&#39; really ought to be a direct requirement of SequenceType, like this:<br>&gt; <br>&gt; protocol SequenceType {<br>&gt;   typealias Element<br>&gt;   typealias Generator: GeneratorType<br>&gt;     where Element == Generator.Element<br>&gt; }<br>&gt; <br>&gt; which would save generic code from having to splatter &#39;.Generator.Element&#39; everywhere, and make unspecialized code more efficient, since the type metadata for Element would be directly available from the SequenceType protocol witness table instead of needing an extra indirection through to its Generator&#39;s GeneratorType table.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/2206d41b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 11:02 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Shouldn’t we just narrow the type of protocols with associated types and/or Self types when the protocol is used as a type?<br>&gt; <br>&gt; <br>&lt;snip&gt;<br></p><p>&gt; foo.value = x // ERROR: calling setter not allowed<br>&gt; foo.bar(x) // ERROR: not allowed<br>&gt; let z: Bounds = foo.baz(x) // ERROR: not allowed<br></p><p><br>The problem is that you are implicitly defining a fixed type protocol off of your “deferred type” protocol, but the designer of the protocol may have not understood the restrictions of use that will come from those using the implicit fixed-type protocol.  By having this narrowed version of the protocol, you may be using the protocol “out of warranty”, e.g. in a way that the original designer never intended.<br></p><p>I’ve spent significant time refactoring code after the fact which has had similar behavior by using wildcards.  Java makes this worse by having unreified generics, which may result in the problem being deferred  until someone actually pays attention that the type system is fundamentally inconsistent.<br></p><p>Still, I feel anything that defers the fixed type protocol design from being considered as part of the API design of the protocol is penalizing the users of the library, not the creator. Without fixing the protocol, my only choice with the above code is to switch to using generic constraints, potentially “all the way up”<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/f067ce18/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 10:02 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Shouldn’t we just narrow the type of protocols with associated types and/or Self types when the protocol is used as a type?<br>&gt; <br></p><p><br>Then you have the “P doesn’t conform to P” problem, which is too crazy to live.  A recent internal discussion led to the idea that we should have notation for the existentially-viable subset of a protocol, so you could always make Array&lt;existential P&gt; but not necessarily Array&lt;P&gt; for an arbitrary protocol P.  Just one way to address this use-case, of course.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/b50fc112/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>protocol can only be used as a generic constraint because it has Self or associated type requirements</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 16.12.2015 um 02:06 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 10:02 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Shouldn’t we just narrow the type of protocols with associated types and/or Self types when the protocol is used as a type?<br>&gt; <br>&gt; <br>&gt; Then you have the “P doesn’t conform to P” problem, which is too crazy to live.  A recent internal discussion led to the idea that we should have notation for the existentially-viable subset of a protocol, so you could always make Array&lt;existential P&gt; but not necessarily Array&lt;P&gt; for an arbitrary protocol P.  <br></p><p>Making this narrowing explicit is a good idea!<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d10b7f7d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
