<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c39b1b9fb5c560660591fa757bbafd2a?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>donny wals</string> &lt;donnywals at gmail.com&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>When we’re using defer we write some code that we want to execute the moment a scope exits.<br>This leads to code that could read like:<br></p><p>let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>    defer { pair = (pair.1, pair.0 + pair.1) }<br>    return pair.0<br>}<br></p><p>What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br></p><p>I’d like to propose a change to defer that would allow the above code to be written as:<br></p><p>let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>    return pair.0<br>    defer { pair = (pair.1, pair.0 + pair.1) }<br>}<br></p><p>This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br></p><p>A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br></p><p>What do you all think?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>you may think of `defer` as a function that pushes a block onto an implicit cleanup stack that is part of every lexical closure. On each scope exit, all blocks from its cleanup stack are popped and executed.<br></p><p>E.g.:<br></p><p>func f(x: Int) {<br>    defer { print(&quot;A&quot;); }<br>    defer { print(&quot;B&quot;); }<br>    if x == 3 {<br>        return<br>    }<br>    defer { print(&quot;C&quot;); }<br>}<br></p><p>So, f(2) will print &quot;CBA&quot;, but f(3) will print &quot;BA&quot; instead. Furthermore, this will change semantics and break the following code:<br></p><p>func g(x: Int) {<br>    defer { print(&quot;A&quot;); }<br>    let b: Int<br>    if x == 3 {<br>        return<br>    } else {<br>        b = x<br>    }<br>    defer { print(&quot;b is \(b)&quot;) }<br>}<br></p><p>In the code above, b is only defined if x is not 3. If x is 3, the last `defer` block cannot be called, and that code would no longer compile.<br></p><p>So I think the current language behavior is more powerful. `defer` is usually used to do cleanup work, and it is called near the place where some resource is initialized. Putting a `defer` block to the end of a function kinda defeats its purpose. And simple functions like fibonacci I would just write without using `defer` at all - it&#39;s just confusing to use `defer` and `inout` in this case IMO.<br></p><p>/// Calculates the n&#39;th fibonacci number. (n &gt;= 1)<br>func fibonacci(n: Int) -&gt; Int {<br>    var a = 0<br>    var b = 1<br>    for _ in 1...n {<br>        (a,b)=(b, a+b)<br>    }<br>    return a<br>}<br></p><p>Regards,<br>Michael<br></p><p><br>&gt; Am 06.06.2016 um 21:50 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt; This leads to code that could read like:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;    return pair.0<br>&gt; }<br>&gt; <br>&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt; <br>&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    return pair.0<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt; }<br>&gt; <br>&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt; <br>&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt; <br>&gt; What do you all think?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c39b1b9fb5c560660591fa757bbafd2a?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>donny wals</string> &lt;donnywals at gmail.com&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Michael,<br></p><p>How would this proposal break your snippet?<br></p><p>&gt; func g(x: Int) {<br>&gt;    defer { print(&quot;A&quot;); }<br>&gt;    let b: Int<br>&gt;    if x == 3 {<br>&gt;        return<br>&gt;    } else {<br>&gt;        b = x<br>&gt;    }<br>&gt;    defer { print(&quot;b is \(b)&quot;) }<br>&gt; }<br></p><p>In this case if x==3 the function should return without executing the final defer. The reason I think it should work like that is that the if statement creates a scope of it’s own. You’re using a return inside of that scope, so only if you’re adding a defer inside of that scope it should be executed even if it’s after the return. The important part here is that the return and the defer should be in the same scope for this proposal to apply.<br></p><p>&gt; On 06 Jun 2016, at 22:07, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; you may think of `defer` as a function that pushes a block onto an implicit cleanup stack that is part of every lexical closure. On each scope exit, all blocks from its cleanup stack are popped and executed.<br>&gt; <br>&gt; E.g.:<br>&gt; <br>&gt; func f(x: Int) {<br>&gt;    defer { print(&quot;A&quot;); }<br>&gt;    defer { print(&quot;B&quot;); }<br>&gt;    if x == 3 {<br>&gt;        return<br>&gt;    }<br>&gt;    defer { print(&quot;C&quot;); }<br>&gt; }<br>&gt; <br>&gt; So, f(2) will print &quot;CBA&quot;, but f(3) will print &quot;BA&quot; instead. Furthermore, this will change semantics and break the following code:<br>&gt; <br>&gt; func g(x: Int) {<br>&gt;    defer { print(&quot;A&quot;); }<br>&gt;    let b: Int<br>&gt;    if x == 3 {<br>&gt;        return<br>&gt;    } else {<br>&gt;        b = x<br>&gt;    }<br>&gt;    defer { print(&quot;b is \(b)&quot;) }<br>&gt; }<br>&gt; <br>&gt; In the code above, b is only defined if x is not 3. If x is 3, the last `defer` block cannot be called, and that code would no longer compile.<br>&gt; <br>&gt; So I think the current language behavior is more powerful. `defer` is usually used to do cleanup work, and it is called near the place where some resource is initialized. Putting a `defer` block to the end of a function kinda defeats its purpose. And simple functions like fibonacci I would just write without using `defer` at all - it&#39;s just confusing to use `defer` and `inout` in this case IMO.<br>&gt; <br>&gt; /// Calculates the n&#39;th fibonacci number. (n &gt;= 1)<br>&gt; func fibonacci(n: Int) -&gt; Int {<br>&gt;    var a = 0<br>&gt;    var b = 1<br>&gt;    for _ in 1...n {<br>&gt;        (a,b)=(b, a+b)<br>&gt;    }<br>&gt;    return a<br>&gt; }<br>&gt; <br>&gt; Regards,<br>&gt; Michael<br>&gt; <br>&gt; <br>&gt;&gt; Am 06.06.2016 um 21:50 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt;&gt; This leads to code that could read like:<br>&gt;&gt; <br>&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;   defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;   return pair.0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt;&gt; <br>&gt;&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt;&gt; <br>&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;   return pair.0<br>&gt;&gt;   defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt;&gt; <br>&gt;&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt;&gt; <br>&gt;&gt; What do you all think?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I think that&#39;s an awful idea. I can already tell you that this will never be accepted. It just complicates the design and the semantics of the `defer` statement, and I don&#39;t see any advantage. Sorry.<br></p><p>-Michael<br></p><p>&gt; Am 06.06.2016 um 22:14 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Michael,<br>&gt; <br>&gt; How would this proposal break your snippet?<br>&gt; <br>&gt;&gt; func g(x: Int) {<br>&gt;&gt;   defer { print(&quot;A&quot;); }<br>&gt;&gt;   let b: Int<br>&gt;&gt;   if x == 3 {<br>&gt;&gt;       return<br>&gt;&gt;   } else {<br>&gt;&gt;       b = x<br>&gt;&gt;   }<br>&gt;&gt;   defer { print(&quot;b is \(b)&quot;) }<br>&gt;&gt; }<br>&gt; <br>&gt; In this case if x==3 the function should return without executing the final defer. The reason I think it should work like that is that the if statement creates a scope of it’s own. You’re using a return inside of that scope, so only if you’re adding a defer inside of that scope it should be executed even if it’s after the return. The important part here is that the return and the defer should be in the same scope for this proposal to apply.<br>&gt; <br>&gt;&gt; On 06 Jun 2016, at 22:07, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; you may think of `defer` as a function that pushes a block onto an implicit cleanup stack that is part of every lexical closure. On each scope exit, all blocks from its cleanup stack are popped and executed.<br>&gt;&gt; <br>&gt;&gt; E.g.:<br>&gt;&gt; <br>&gt;&gt; func f(x: Int) {<br>&gt;&gt;   defer { print(&quot;A&quot;); }<br>&gt;&gt;   defer { print(&quot;B&quot;); }<br>&gt;&gt;   if x == 3 {<br>&gt;&gt;       return<br>&gt;&gt;   }<br>&gt;&gt;   defer { print(&quot;C&quot;); }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So, f(2) will print &quot;CBA&quot;, but f(3) will print &quot;BA&quot; instead. Furthermore, this will change semantics and break the following code:<br>&gt;&gt; <br>&gt;&gt; func g(x: Int) {<br>&gt;&gt;   defer { print(&quot;A&quot;); }<br>&gt;&gt;   let b: Int<br>&gt;&gt;   if x == 3 {<br>&gt;&gt;       return<br>&gt;&gt;   } else {<br>&gt;&gt;       b = x<br>&gt;&gt;   }<br>&gt;&gt;   defer { print(&quot;b is \(b)&quot;) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the code above, b is only defined if x is not 3. If x is 3, the last `defer` block cannot be called, and that code would no longer compile.<br>&gt;&gt; <br>&gt;&gt; So I think the current language behavior is more powerful. `defer` is usually used to do cleanup work, and it is called near the place where some resource is initialized. Putting a `defer` block to the end of a function kinda defeats its purpose. And simple functions like fibonacci I would just write without using `defer` at all - it&#39;s just confusing to use `defer` and `inout` in this case IMO.<br>&gt;&gt; <br>&gt;&gt; /// Calculates the n&#39;th fibonacci number. (n &gt;= 1)<br>&gt;&gt; func fibonacci(n: Int) -&gt; Int {<br>&gt;&gt;   var a = 0<br>&gt;&gt;   var b = 1<br>&gt;&gt;   for _ in 1...n {<br>&gt;&gt;       (a,b)=(b, a+b)<br>&gt;&gt;   }<br>&gt;&gt;   return a<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Regards,<br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 06.06.2016 um 21:50 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt;&gt;&gt; This leads to code that could read like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;&gt;  defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;&gt;  return pair.0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;&gt;  return pair.0<br>&gt;&gt;&gt;  defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you all think?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c39b1b9fb5c560660591fa757bbafd2a?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>donny wals</string> &lt;donnywals at gmail.com&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>That’s fair enough. IMO structuring code so it reads in the same order it executes is an opportunity to simplify code rather than complicate it. However, I do agree that the fibonacci example I mentioned earlier might not be the best use case and it’s probably the best use case for this proposal. Since in terms of using defer as cleanup code the order doesn’t matter as much. But still.. it feels a bit weird to be forced to write the “after return” code before the actual return. On the other hand, defer has a pretty clear meaning already and if you and others think that this proposal would break semantics, it’s probably not the best idea<br></p><p>D<br></p><p><br>&gt; On 06 Jun 2016, at 22:25, michael.peternell at gmx.at wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I think that&#39;s an awful idea. I can already tell you that this will never be accepted. It just complicates the design and the semantics of the `defer` statement, and I don&#39;t see any advantage. Sorry.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 06.06.2016 um 22:14 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Michael,<br>&gt;&gt; <br>&gt;&gt; How would this proposal break your snippet?<br>&gt;&gt; <br>&gt;&gt;&gt; func g(x: Int) {<br>&gt;&gt;&gt;  defer { print(&quot;A&quot;); }<br>&gt;&gt;&gt;  let b: Int<br>&gt;&gt;&gt;  if x == 3 {<br>&gt;&gt;&gt;      return<br>&gt;&gt;&gt;  } else {<br>&gt;&gt;&gt;      b = x<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  defer { print(&quot;b is \(b)&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this case if x==3 the function should return without executing the final defer. The reason I think it should work like that is that the if statement creates a scope of it’s own. You’re using a return inside of that scope, so only if you’re adding a defer inside of that scope it should be executed even if it’s after the return. The important part here is that the return and the defer should be in the same scope for this proposal to apply.<br>&gt;&gt; <br>&gt;&gt;&gt; On 06 Jun 2016, at 22:07, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you may think of `defer` as a function that pushes a block onto an implicit cleanup stack that is part of every lexical closure. On each scope exit, all blocks from its cleanup stack are popped and executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(x: Int) {<br>&gt;&gt;&gt;  defer { print(&quot;A&quot;); }<br>&gt;&gt;&gt;  defer { print(&quot;B&quot;); }<br>&gt;&gt;&gt;  if x == 3 {<br>&gt;&gt;&gt;      return<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  defer { print(&quot;C&quot;); }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, f(2) will print &quot;CBA&quot;, but f(3) will print &quot;BA&quot; instead. Furthermore, this will change semantics and break the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func g(x: Int) {<br>&gt;&gt;&gt;  defer { print(&quot;A&quot;); }<br>&gt;&gt;&gt;  let b: Int<br>&gt;&gt;&gt;  if x == 3 {<br>&gt;&gt;&gt;      return<br>&gt;&gt;&gt;  } else {<br>&gt;&gt;&gt;      b = x<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  defer { print(&quot;b is \(b)&quot;) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the code above, b is only defined if x is not 3. If x is 3, the last `defer` block cannot be called, and that code would no longer compile.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I think the current language behavior is more powerful. `defer` is usually used to do cleanup work, and it is called near the place where some resource is initialized. Putting a `defer` block to the end of a function kinda defeats its purpose. And simple functions like fibonacci I would just write without using `defer` at all - it&#39;s just confusing to use `defer` and `inout` in this case IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Calculates the n&#39;th fibonacci number. (n &gt;= 1)<br>&gt;&gt;&gt; func fibonacci(n: Int) -&gt; Int {<br>&gt;&gt;&gt;  var a = 0<br>&gt;&gt;&gt;  var b = 1<br>&gt;&gt;&gt;  for _ in 1...n {<br>&gt;&gt;&gt;      (a,b)=(b, a+b)<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  return a<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 06.06.2016 um 21:50 schrieb donny wals via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt;&gt;&gt;&gt; This leads to code that could read like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;&gt;&gt; defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;&gt;&gt; return pair.0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;&gt;&gt; return pair.0<br>&gt;&gt;&gt;&gt; defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you all think?<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  6, 2016 at 02:00:00pm</p></header><div class="content"><p>This is problematic. You may want to defer code at different points with different reasons. For example, you might not want to trigger defer until after some preconditions have been met.:<br></p><p>guard something <br>guard something<br>allocate memory; defer {release memory}<br></p><p>-- E<br></p><p><br></p><p>&gt; On Jun 6, 2016, at 1:50 PM, donny wals via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt; This leads to code that could read like:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;    return pair.0<br>&gt; }<br>&gt; <br>&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt; <br>&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    return pair.0<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt; }<br>&gt; <br>&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt; <br>&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt; <br>&gt; What do you all think?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c39b1b9fb5c560660591fa757bbafd2a?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>donny wals</string> &lt;donnywals at gmail.com&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Erica,<br></p><p>Maybe my phrasing was a bit off, but in my proposal it’s really important that the return and the defer are in the same scope. In your example the allocate memory line is in a different scope that the guard/else statements. Therefor, the defer { release memory } shouldn’t be executed if the guards don’t hold.<br></p><p>D<br></p><p>&gt; On 06 Jun 2016, at 22:09, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; This is problematic. You may want to defer code at different points with different reasons. For example, you might not want to trigger defer until after some preconditions have been met.:<br>&gt; <br>&gt; guard something <br>&gt; guard something<br>&gt; allocate memory; defer {release memory}<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 6, 2016, at 1:50 PM, donny wals via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt;&gt; This leads to code that could read like:<br>&gt;&gt; <br>&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;   defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt;   return pair.0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt;&gt; <br>&gt;&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt;&gt; <br>&gt;&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;&gt;   return pair.0<br>&gt;&gt;   defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt;&gt; <br>&gt;&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt;&gt; <br>&gt;&gt; What do you all think?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Not sure I see how they&#39;re in different scopes. Can you explain that to me?<br></p><p>-- E<br></p><p>&gt; On Jun 6, 2016, at 2:18 PM, donny wals &lt;donnywals at gmail.com&gt; wrote:<br>&gt; <br>&gt; Erica,<br>&gt; <br>&gt; Maybe my phrasing was a bit off, but in my proposal it’s really important that the return and the defer are in the same scope. In your example the allocate memory line is in a different scope that the guard/else statements. Therefor, the defer { release memory } shouldn’t be executed if the guards don’t hold.<br>&gt; <br>&gt; D<br>&gt; <br>&gt;&gt; On 06 Jun 2016, at 22:09, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is problematic. You may want to defer code at different points with different reasons. For example, you might not want to trigger defer until after some preconditions have been met.:<br>&gt;&gt; <br>&gt;&gt; guard something <br>&gt;&gt; guard something<br>&gt;&gt; allocate memory; defer {release memory}<br>&gt;&gt; <br>&gt;&gt; -- E<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  6, 2016 at 11:00:00pm</p></header><div class="content"><p>While I can kind of see where you’re coming from I’m not sure about the change; the key thing about defer is that it doesn’t just execute in the cases you explicitly define, but can also occur if exceptions are thrown and other exit cases that could be all over the scope.<br></p><p>To compare with other languages, I’ve used several that achieve this with a finally block instead, usually as part of a try/catch like so:<br></p><p>try { doSomethingThatCanThrow(); return 1; }<br>catch (Exception e) { print(e); return 0; }<br>finally { doSomeCleanup(); }<br></p><p>Here you have two possible exit points, and in both cases the code in the finally block is executed. But it’s pretty rigid.<br></p><p>This is fine in cases like you suggest where it makes a bit more sense visually, but the cool thing about Swift is that you can declare defer blocks all over the place, build upon them and so-on. It means you can group your cleanup code with the statements that actually require the cleanup, even if there is a ton of extra code that comes afterwards. For example, opening a TCP connection may use a defer block right away to ensure the connection is closed cleanly and any buffers are cleared regardless of how the method ends (normally, IO error etc.), but before that happens there may be a whole load of parsing and other operations before you hit the final return statement.<br></p><p>It’s also pretty clear from the keyword defer; putting it after the return statement actually makes less sense, as there is nothing for it to be deferred in relation to (as there’s nothing else left to do).<br></p><p><br>I’d say that if you want cleanup to appear visually afterwards you’d be better off promising a finally block, this could be nice to have, especially if it could be applied to most blocks like so:<br></p><p>	do {<br>		somethingThatCouldThrow()<br>		if someCondition { return }<br>	} finally { someCleanup() } // Executed whether the block throws, returns or completes normally<br></p><p>	for eachValue in theValues {<br>		if doSomethingTo(eachValue) { break }<br>		if someCondition { return }<br>		else { throw SomeError() }<br>	} finally { doSomeCleanup() } // Executes regardless of whether the loop ends normally, breaks, returns or throws<br></p><p>And so-on. I’d say that defer is more flexible overall, but there could be some cause for this visually so you can move simpler deferred code away from the main method body.<br></p><p>&gt; On 6 Jun 2016, at 20:50, donny wals via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt; This leads to code that could read like:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;    return pair.0<br>&gt; }<br>&gt; <br>&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt; <br>&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    return pair.0<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt; }<br>&gt; <br>&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt; <br>&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt; <br>&gt; What do you all think?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/44e6ab4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d2a6dc9b1ae925320d253a48b6fa775?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Hignite, Jamie</string> &lt;Jamie.Hignite at kindred.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>I like the idea of having a finally and a defer.<br></p><p>Jamie<br></p><p><br></p><p>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Haravikk via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Haravikk &lt;swift-evolution at haravikk.me&lt;mailto:swift-evolution at haravikk.me&gt;&gt;<br>Date: Monday, June 6, 2016 at 6:44 PM<br>To: donny wals &lt;donnywals at gmail.com&lt;mailto:donnywals at gmail.com&gt;&gt;<br>Cc: &quot;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&quot; &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Subject: [EXTERNAL] Re: [swift-evolution] [Proposal] A more liberal placement of defer<br></p><p>While I can kind of see where you’re coming from I’m not sure about the change; the key thing about defer is that it doesn’t just execute in the cases you explicitly define, but can also occur if exceptions are thrown and other exit cases that could be all over the scope.<br></p><p>To compare with other languages, I’ve used several that achieve this with a finally block instead, usually as part of a try/catch like so:<br></p><p>try { doSomethingThatCanThrow(); return 1; }<br>catch (Exception e) { print(e); return 0; }<br>finally { doSomeCleanup(); }<br></p><p>Here you have two possible exit points, and in both cases the code in the finally block is executed. But it’s pretty rigid.<br></p><p>This is fine in cases like you suggest where it makes a bit more sense visually, but the cool thing about Swift is that you can declare defer blocks all over the place, build upon them and so-on. It means you can group your cleanup code with the statements that actually require the cleanup, even if there is a ton of extra code that comes afterwards. For example, opening a TCP connection may use a defer block right away to ensure the connection is closed cleanly and any buffers are cleared regardless of how the method ends (normally, IO error etc.), but before that happens there may be a whole load of parsing and other operations before you hit the final return statement.<br></p><p>It’s also pretty clear from the keyword defer; putting it after the return statement actually makes less sense, as there is nothing for it to be deferred in relation to (as there’s nothing else left to do).<br></p><p><br>I’d say that if you want cleanup to appear visually afterwards you’d be better off promising a finally block, this could be nice to have, especially if it could be applied to most blocks like so:<br></p><p>do {<br>somethingThatCouldThrow()<br>if someCondition { return }<br>} finally { someCleanup() } // Executed whether the block throws, returns or completes normally<br></p><p>for eachValue in theValues {<br>if doSomethingTo(eachValue) { break }<br>if someCondition { return }<br>else { throw SomeError() }<br>} finally { doSomeCleanup() } // Executes regardless of whether the loop ends normally, breaks, returns or throws<br></p><p>And so-on. I’d say that defer is more flexible overall, but there could be some cause for this visually so you can move simpler deferred code away from the main method body.<br></p><p>On 6 Jun 2016, at 20:50, donny wals via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>Hi,<br></p><p>When we’re using defer we write some code that we want to execute the moment a scope exits.<br>This leads to code that could read like:<br></p><p>let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>   defer { pair = (pair.1, pair.0 + pair.1) }<br>   return pair.0<br>}<br></p><p>What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br></p><p>I’d like to propose a change to defer that would allow the above code to be written as:<br></p><p>let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>   return pair.0<br>   defer { pair = (pair.1, pair.0 + pair.1) }<br>}<br></p><p>This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br></p><p>A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br></p><p>What do you all think?<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Proposal] A more liberal placement of defer</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>June  6, 2016 at 04:00:00pm</p></header><div class="content"><p>This proposal runs counter to the spirit of what defer seems to be meant for in the first place. It’s to save you forgetting to do something (like closing a stream) before you exit a block of code. If you push it down in the code to after the return, then you might as well have just put the code in *before* the return without the defer.<br></p><p>public func doMyThing() {<br>	let theStream = openStream()<br>	defer {<br>		closeStream()<br>	}<br>	<br>	…<br>	…<br>	…<br>	&lt;enough code that it’s off the bottom of the screen&gt;<br>	return<br>}<br></p><p>In this case, putting closeStream() after the return would defeat the purpose.<br></p><p>-Kenny<br></p><p><br>&gt; On Jun 6, 2016, at 12:50 PM, donny wals via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; When we’re using defer we write some code that we want to execute the moment a scope exits.<br>&gt; This leads to code that could read like:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt;    return pair.0<br>&gt; }<br>&gt; <br>&gt; What I find strange about this is that we have to write the code that we want to execute after the return before the return.<br>&gt; <br>&gt; I’d like to propose a change to defer that would allow the above code to be written as:<br>&gt; <br>&gt; let fibonacci = sequence(state: (0, 1)) { (pair: inout (Int, Int)) -&gt; Int in<br>&gt;    return pair.0<br>&gt;    defer { pair = (pair.1, pair.0 + pair.1) }<br>&gt; }<br>&gt; <br>&gt; This would make the intent of the code more clear (return first, then mutate state). Not all cases can benefit from this change, but anytime you exit a scope using a return I think it might be more clear to define the defer after the return. The code would more closely mirror the intent of the code.<br>&gt; <br>&gt; A rule of thumb I’ve come up with for this is that whenever you’re using return to exit a scope, any defer in that same scope should be executed regardless of it’s position in that same scope. This proposal would supplement the way defer currently works.<br>&gt; <br>&gt; What do you all think?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
