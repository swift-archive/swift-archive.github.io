<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Beef up Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 27, 2015 at 12:00:00am</p></header><div class="content"><p>I opened a radar a while ago about improving the import syntax in Swift and haven’t received much of a response, so I’ll try to expand on my thoughts in there here.<br></p><p>I’ve always been in love with the way Agda does Modules and imports.  The syntax is wonderfully natural, and the features it provides are surprisingly useful given their simplicity.  Because Swift forbids the redeclaration of names between structs, enums, classes, and typealiases, I don’t believe that the existing qualified import syntax is needed.  Therefore, I propose the introduction of 3 agda-esque operations for imports to replace the usual `import {func|typealias|struct|class|enum|etc.}` syntax:<br></p><p>	• import Foo using (bar, Baz, qux, corge, …)<br>	• import Foo hiding (bar, baz, qux, corge, …)<br>	• import Foo renaming (grault to garply, waldo to fred, …)<br></p><p>The first of these is used to introduce a limited set of identifiers into scope, the second to import all but the given identifiers, and the third to rename identifiers at the module level.  Again, it should be obvious by uniqueness of identifiers what each one is referencing, so qualification of each identifier is unnecessary.  If more context is needed, or more granularity, a Haskell-esque <br></p><p>import Foo {using|hiding|renaming} (Baz(..) [to Graft(..)])<br></p><p>could be in order for structs, classes, and enums, but I don’t anticipate it will be of much use because individual members are already qualified by their containing structure or instance variable anyway. <br></p><p>What do you think?<br></p><p>~Robert Widmann<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Beef up Imports</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>December 27, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On 27 Dec 2015, at 07:12, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Therefore, I propose the introduction of 3 agda-esque operations for imports to replace the usual `import {func|typealias|struct|class|enum|etc.}` syntax:<br>&gt; <br>&gt; 	• import Foo using (bar, Baz, qux, corge, …)<br>&gt; 	• import Foo hiding (bar, baz, qux, corge, …)<br>&gt; 	• import Foo renaming (grault to garply, waldo to fred, …)<br></p><p>+1, but why not just…?<br></p><p>import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br></p><p>I&#39;ve been able to work around identifier conflicts with the present import syntax but it gets clumsy with larger modules. I think both import-using and import-hiding would be very welcome in Swift, but the third notation made me double check its semantics from The Agda Wiki. Turns out &lt;http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Modules#mods&gt; the renaming (...) syntax is actually an extension to the other two and is often used as a part of the one or the other:<br></p><p>import Foo using (bar, Baz, qux) renaming (waldo to fred)<br>import Foo hiding (bar, Baz, qux) renaming (waldo to fred)<br></p><p>Why not do without renaming? Just allow both import-using and import-hiding to optionally rename imported identifiers. Further, while these keywords can and should be made context-specific, I think it&#39;s simplest to reuse &quot;as&quot; as the associating keyword.<br></p><p>That would lead us to the proposed syntax:<br></p><p>import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br></p><p>where the tuple-like parentheses enclose a potentially empty list of identifiers or &quot;identifier as identifier&quot; mappings. The examples below should clarify the meaning and intended use of these two statements.<br></p><p>&gt; Again, it should be obvious by uniqueness of identifiers what each one is referencing, so qualification of each identifier is unnecessary.<br></p><p><br>Agreed. In addition, extending the import statement to class/enum/struct members doesn&#39;t make sense to me. Those don&#39;t conflict with the global scope at all.<br></p><p>— Pyry Jahkola<br></p><p><br>P.S. If this turns into a formal proposal, should we also address how imported operators should be dealt with? Can operators be selectively imported, hidden, or renamed? If renaming is made possible, we should be explicit on how the renamed operator inherits its associativity and precedence from the original one.<br></p><p><br>Examples<br></p><p>Suppose the module Foo contains the following identifiers:<br></p><p>// module Foo:<br>// - bar, Baz, qux, waldo<br></p><p>The &quot;import-all&quot; remains as it is in Swift 2:<br></p><p>import Foo<br></p><p>_ = (bar, Baz.self, qux, waldo) // All identifiers can be unqualified.<br></p><p>The &quot;import-all&quot; is synonymous with the longer &quot;hide-nothing&quot;:<br></p><p>import Foo hiding ()<br></p><p>To hide or rename an identifier, fill in the parentheses:<br></p><p>import Foo hiding (Baz, waldo as fred)<br></p><p>_ = (bar, qux, fred)            // These names can be unqualified.<br>_ = (Foo.Baz.self, Foo.waldo)   // These names must be qualified.<br>_ = Foo.fred                    // Compiler error!<br></p><p>To import selectively, potentially renaming identifiers, use the import-using syntax:<br></p><p>import Foo using (Baz as FooBaz, qux, waldo as fred)<br></p><p>_ = (FooBaz.self, qux, fred)    // These names can be unqualified.<br>_ = (Foo.Baz.self, Foo.bar)     // These names must be qualified.<br></p><p>Finally, it&#39;s possible to require qualified use of the Foo module:<br></p><p>import Foo using ()<br></p><p>_ = (Foo.bar, Foo.Baz.self, Foo.qux, Foo.waldo) // OK.<br>_ = (bar, Baz.self, qux, waldo) // Compiler error x 4!<br></p><p>End.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/591d5e59/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/591d5e59/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Beef up Imports</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 27, 2015 at 09:00:00am</p></header><div class="content"><p>*import* Foo *using* (bar, Baz, qux, waldo *as* fred)  // a &quot;whitelist<br>import&quot;<br>*import* Foo *hiding* (bar, Baz, qux, waldo *as* fred) // a &quot;blacklist<br>import&quot;<br></p><p><br></p><p>Is nice but `hiding… (waldo as fred)` is confusing. Am I hiding waldo? It<br>is also strange to look in that list for things that I am hiding and things<br>that I am importing. Context switches after the item that I am importing<br>because `as` follows the item in question.<br></p><p><br>*import* Foo (waldo *as* fred) *using* (bar, Baz, qux)  // a &quot;whitelist<br>import&quot;<br>*import* Foo (waldo *as* fred) *hiding* (bar, Baz, qux) // a &quot;blacklist<br>import&quot;<br></p><p><br>`using` didn&#39;t actually need the syntax change but maintaining one<br>consistent form might be worth it. If not, `import Foo using (bar, Baz,<br>waldo as fred)` is fine.<br></p><p>On Sun, Dec 27, 2015 at 7:44 AM, Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 27 Dec 2015, at 07:12, Developer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Therefore, I propose the introduction of 3 agda-esque operations for<br>&gt; imports to replace the usual `import<br>&gt; {func|typealias|struct|class|enum|etc.}` syntax:<br>&gt;<br>&gt; • import Foo using (bar, Baz, qux, corge, …)<br>&gt; • import Foo hiding (bar, baz, qux, corge, …)<br>&gt; • import Foo renaming (grault to garply, waldo to fred, …)<br>&gt;<br>&gt;<br>&gt; +1, but why not just…?<br>&gt;<br>&gt; *import* Foo *using* (bar, Baz, qux, waldo *as* fred)  // a &quot;whitelist<br>&gt; import&quot;<br>&gt;<br>&gt; *import* Foo *hiding* (bar, Baz, qux, waldo *as* fred) // a &quot;blacklist<br>&gt; import&quot;<br>&gt;<br>&gt;<br>&gt; I&#39;ve been able to work around identifier conflicts with the present<br>&gt; *import* syntax but it gets clumsy with larger modules. I think both<br>&gt; *import*-*using* and *import*-*hiding* would be very welcome in Swift,<br>&gt; but the third notation made me double check its semantics from The Agda<br>&gt; Wiki. Turns out<br>&gt; &lt;http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Modules#mods&gt;<br>&gt;  the *renaming* (...) syntax is actually an extension to the other two<br>&gt; and is often used as a part of the one or the other:<br>&gt;<br>&gt; *import* Foo *using* (bar, Baz, qux) *renaming* (waldo *to* fred)<br>&gt; *import* Foo *hiding* (bar, Baz, qux) *renaming* (waldo *to* fred)<br>&gt;<br>&gt;<br>&gt; Why not do without *renaming*? Just allow both *import*-*using* and<br>&gt; *import*-*hiding* to optionally *rename* imported identifiers. Further,<br>&gt; while these keywords can and should be made context-specific, I think it&#39;s<br>&gt; simplest to reuse &quot;*as*&quot; as the associating keyword.<br>&gt;<br>&gt; That would lead us to the *proposed syntax*:<br>&gt;<br>&gt; *import* Foo *using* (bar, Baz, qux, waldo *as* fred)  // a &quot;whitelist<br>&gt; import&quot;<br>&gt;<br>&gt; *import* Foo *hiding* (bar, Baz, qux, waldo *as* fred) // a &quot;blacklist<br>&gt; import&quot;<br>&gt;<br>&gt;<br>&gt; where the tuple-like parentheses enclose a potentially empty list of<br>&gt; identifiers or &quot;identifier *as* identifier&quot; mappings. The examples below<br>&gt; should clarify the meaning and intended use of these two statements.<br>&gt;<br>&gt; Again, it should be obvious by uniqueness of identifiers what each one is<br>&gt; referencing, so qualification of each identifier is unnecessary.<br>&gt;<br>&gt;<br>&gt; Agreed. In addition, extending the import statement to class/enum/struct<br>&gt; members doesn&#39;t make sense to me. Those don&#39;t conflict with the global<br>&gt; scope at all.<br>&gt;<br>&gt; — Pyry Jahkola<br>&gt;<br>&gt;<br>&gt; P.S. If this turns into a formal proposal, should we also address how<br>&gt; imported operators should be dealt with? Can operators be selectively<br>&gt; imported, hidden, or renamed? If renaming is made possible, we should be<br>&gt; explicit on how the renamed operator inherits its associativity and<br>&gt; precedence from the original one.<br>&gt;<br>&gt;<br>&gt; *Examples*<br>&gt;<br>&gt; Suppose the module Foo contains the following identifiers:<br>&gt;<br>&gt; // module Foo:<br>&gt; // - bar, Baz, qux, waldo<br>&gt;<br>&gt;<br>&gt; The &quot;import-all&quot; remains as it is in Swift 2:<br>&gt;<br>&gt; *import* Foo<br>&gt;<br>&gt; _ = (bar, Baz.self, qux, waldo) // All identifiers can be unqualified.<br>&gt;<br>&gt;<br>&gt; The &quot;import-all&quot; is synonymous with the longer &quot;hide-nothing&quot;:<br>&gt;<br>&gt; *import* Foo *hiding* ()<br>&gt;<br>&gt;<br>&gt; To hide or rename an identifier, fill in the parentheses:<br>&gt;<br>&gt; *import* Foo *hiding* (Baz, waldo *as* fred)<br>&gt;<br>&gt; _ = (bar, qux, fred)            // These names can be unqualified.<br>&gt; _ = (Foo.Baz.self, Foo.waldo)   // These names must be qualified.<br>&gt; _ = Foo.fred                    // Compiler error!<br>&gt;<br>&gt;<br>&gt; To import selectively, potentially renaming identifiers, use the *import*-<br>&gt; *using* syntax:<br>&gt;<br>&gt; *import* Foo *using* (Baz *as* FooBaz, qux, waldo *as* fred)<br>&gt;<br>&gt; _ = (FooBaz.self, qux, fred)    // These names can be unqualified.<br>&gt; _ = (Foo.Baz.self, Foo.bar)     // These names must be qualified.<br>&gt;<br>&gt;<br>&gt; Finally, it&#39;s possible to require qualified use of the Foo module:<br>&gt;<br>&gt; *import* Foo *using* ()<br>&gt;<br>&gt; _ = (Foo.bar, Foo.Baz.self, Foo.qux, Foo.waldo) // OK.<br>&gt; _ = (bar, Baz.self, qux, waldo) // Compiler error x 4!<br>&gt;<br>&gt;<br>&gt; End.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/9cdb18b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Beef up Imports</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>December 27, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>&gt; import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br>&gt; <br>&gt; Is nice but `hiding… (waldo as fred)` is confusing. Am I hiding waldo?<br></p><p>You&#39;re right That&#39;s also what Robert pointed out in his reply. The way I thought it is &quot;hide waldo, naming it as fred instead.&quot; I like the symmetry of it with the `import-using` statement, but true, it doesn&#39;t read well.<br></p><p>Hmm, given that keywords are still up in the air, why not s/hiding/except/? Then we&#39;d have:<br></p><p>import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>import Foo except (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br></p><p>The double meaning of &quot;except&quot; in the phrases &quot;except X&quot; (without X) and &quot;except X as Y&quot; (everything else as is, but X as Y) would work.<br></p><p>And no one would write the silly sounding empty `import Foo except ()` anyway because the plain `import Foo` works too.<br></p><p>&gt; It is also strange to look in that list for things that I am hiding and things that I am importing. Context switches after the item that I am importing because `as` follows the item in question.<br></p><p>I&#39;d say that&#39;s entirely ok. You could by convention e.g. keep a habit of listing all renames together (in the end of the list, or in another import-except statement), which could be checked by a linter if someone wanted.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/19dcdbde/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Beef up Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 27, 2015 at 03:00:00pm</p></header><div class="content"><p>The &#39;except&#39; change is interesting, but it&#39;s still a context switch that can wind up confusing people.  I think that&#39;s partly why Agda has the &#39;renaming&#39; operation separate in the first place.<br></p><p>~Robert Widmann<br></p><p>2015/12/27 10:30、T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>&gt; import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br>&gt; <br>&gt; <br>&gt; Is nice but `hiding… (waldo as fred)` is confusing. Am I hiding waldo? It is also strange to look in that list for things that I am hiding and things that I am importing. Context switches after the item that I am importing because `as` follows the item in question.<br>&gt; <br>&gt; import Foo (waldo as fred) using (bar, Baz, qux)  // a &quot;whitelist import&quot;<br>&gt; import Foo (waldo as fred) hiding (bar, Baz, qux) // a &quot;blacklist import&quot;<br>&gt; <br>&gt; `using` didn&#39;t actually need the syntax change but maintaining one consistent form might be worth it. If not, `import Foo using (bar, Baz, waldo as fred)` is fine. <br>&gt; <br>&gt; On Sun, Dec 27, 2015 at 7:44 AM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On 27 Dec 2015, at 07:12, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Therefore, I propose the introduction of 3 agda-esque operations for imports to replace the usual `import {func|typealias|struct|class|enum|etc.}` syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• import Foo using (bar, Baz, qux, corge, …)<br>&gt;&gt;&gt; 	• import Foo hiding (bar, baz, qux, corge, …)<br>&gt;&gt;&gt; 	• import Foo renaming (grault to garply, waldo to fred, …)<br>&gt;&gt; <br>&gt;&gt; +1, but why not just…?<br>&gt;&gt; <br>&gt;&gt; import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>&gt;&gt; import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been able to work around identifier conflicts with the present import syntax but it gets clumsy with larger modules. I think both import-using and import-hiding would be very welcome in Swift, but the third notation made me double check its semantics from The Agda Wiki. Turns out the renaming (...) syntax is actually an extension to the other two and is often used as a part of the one or the other:<br>&gt;&gt; <br>&gt;&gt; import Foo using (bar, Baz, qux) renaming (waldo to fred)<br>&gt;&gt; import Foo hiding (bar, Baz, qux) renaming (waldo to fred)<br>&gt;&gt; <br>&gt;&gt; Why not do without renaming? Just allow both import-using and import-hiding to optionally rename imported identifiers. Further, while these keywords can and should be made context-specific, I think it&#39;s simplest to reuse &quot;as&quot; as the associating keyword.<br>&gt;&gt; <br>&gt;&gt; That would lead us to the proposed syntax:<br>&gt;&gt; <br>&gt;&gt; import Foo using (bar, Baz, qux, waldo as fred)  // a &quot;whitelist import&quot;<br>&gt;&gt; import Foo hiding (bar, Baz, qux, waldo as fred) // a &quot;blacklist import&quot;<br>&gt;&gt; <br>&gt;&gt; where the tuple-like parentheses enclose a potentially empty list of identifiers or &quot;identifier as identifier&quot; mappings. The examples below should clarify the meaning and intended use of these two statements.<br>&gt;&gt; <br>&gt;&gt;&gt; Again, it should be obvious by uniqueness of identifiers what each one is referencing, so qualification of each identifier is unnecessary.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Agreed. In addition, extending the import statement to class/enum/struct members doesn&#39;t make sense to me. Those don&#39;t conflict with the global scope at all.<br>&gt;&gt; <br>&gt;&gt; — Pyry Jahkola<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; P.S. If this turns into a formal proposal, should we also address how imported operators should be dealt with? Can operators be selectively imported, hidden, or renamed? If renaming is made possible, we should be explicit on how the renamed operator inherits its associativity and precedence from the original one.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Examples<br>&gt;&gt; <br>&gt;&gt; Suppose the module Foo contains the following identifiers:<br>&gt;&gt; <br>&gt;&gt; // module Foo:<br>&gt;&gt; // - bar, Baz, qux, waldo<br>&gt;&gt; <br>&gt;&gt; The &quot;import-all&quot; remains as it is in Swift 2:<br>&gt;&gt; <br>&gt;&gt; import Foo<br>&gt;&gt; <br>&gt;&gt; _ = (bar, Baz.self, qux, waldo) // All identifiers can be unqualified.<br>&gt;&gt; <br>&gt;&gt; The &quot;import-all&quot; is synonymous with the longer &quot;hide-nothing&quot;:<br>&gt;&gt; <br>&gt;&gt; import Foo hiding ()<br>&gt;&gt; <br>&gt;&gt; To hide or rename an identifier, fill in the parentheses:<br>&gt;&gt; <br>&gt;&gt; import Foo hiding (Baz, waldo as fred)<br>&gt;&gt; <br>&gt;&gt; _ = (bar, qux, fred)            // These names can be unqualified.<br>&gt;&gt; _ = (Foo.Baz.self, Foo.waldo)   // These names must be qualified.<br>&gt;&gt; _ = Foo.fred                    // Compiler error!<br>&gt;&gt; <br>&gt;&gt; To import selectively, potentially renaming identifiers, use the import-using syntax:<br>&gt;&gt; <br>&gt;&gt; import Foo using (Baz as FooBaz, qux, waldo as fred)<br>&gt;&gt; <br>&gt;&gt; _ = (FooBaz.self, qux, fred)    // These names can be unqualified.<br>&gt;&gt; _ = (Foo.Baz.self, Foo.bar)     // These names must be qualified.<br>&gt;&gt; <br>&gt;&gt; Finally, it&#39;s possible to require qualified use of the Foo module:<br>&gt;&gt; <br>&gt;&gt; import Foo using ()<br>&gt;&gt; <br>&gt;&gt; _ = (Foo.bar, Foo.Baz.self, Foo.qux, Foo.waldo) // OK.<br>&gt;&gt; _ = (bar, Baz.self, qux, waldo) // Compiler error x 4!<br>&gt;&gt; <br>&gt;&gt; End.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/0043bea6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Beef up Imports</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 28, 2015 at 04:00:00pm</p></header><div class="content"><p>I like the idea here, but I&#39;m not sold on the syntax. I also do<br>explicitly want an `import qualified`. And with qualified imports, I<br>question whether we really need to support renaming in the import<br>syntax here.<br></p><p>I&#39;m tempted to say we should just crib Haskell&#39;s import rules<br>(https://wiki.haskell.org/Import), with the minor change that importing<br>members by name still makes them accessible via the module name too (in<br>Haskell `import Mod (x, y)` makes `x` and `y` visible but does not make<br>`Mod.x` or `Mod.y` visible). This lets you say things like<br></p><p>*import* Mod // imports Mod and all its members *import* Mod () // only<br>provides access to protocol conformances declared in Mod, doesn&#39;t<br>actually *import* anything *import* Mod *(*x,y*)* // imports `x` and<br>`y`, which are also accessible as e.g. `Mod.x`, but does not provide `z`<br>or `Mod.z` *import qualified* Mod // imports Mod but all access to<br>members has to go through it, e.g. `Mod.x` *import qualified* Mod<br>*(*x,y*)* // imports Mod but only provides access to `Mod.x` and `Mod.y`<br>but not e.g. `Mod.z` *import *Mod *hiding* *(*x,y*)* // imports Mod and<br>its members except for `x` or `y` *import qualified* Mod *hiding*<br>*(*x,y*)* // imports e.g. `Mod.z` but not `Mod.x` or `Mod.y`* * *import*<br>Mod *as* Foo // imports Mod and renames the module to Foo, so e.g. `x`<br>and `Foo.x` are accessible *import* Mod *as* Foo *(*x,y*)* // renames<br>Mod to Foo, provides `x`, `y`, `Foo.x`, and `Foo.y` *import qualified*<br>Mod *as* Foo // renames Mod to Foo, all members are accessible via the<br>module e.g. `Foo.x` *import qualified* Mod *as* Foo *(*x,y*)* // renames<br>Mod to Foo, provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br></p><p>Furthermore, you can have multiple import statements from the same<br>module, so you can say something like<br></p><p>*import qualified* Mod *import* Mod *(*x,y*)*<br></p><p>to provide access to all of Mod qualified with the name, and<br>additionally import `x` and `y` as unqualified identifiers.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/ec390235/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Beef up Imports</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 30, 2015 at 05:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten<br></p><p>&gt; Am 29.12.2015 um 01:47 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I like the idea here, but I&#39;m not sold on the syntax. I also do explicitly want an `import qualified`. And with qualified imports, I question whether we really need to support renaming in the import syntax here.<br>&gt;  <br>&gt; I&#39;m tempted to say we should just crib Haskell&#39;s import rules (https://wiki.haskell.org/Import), with the minor change that importing members by name still makes them accessible via the module name too (in Haskell `import Mod (x, y)` makes `x` and `y` visible but does not make `Mod.x` or `Mod.y` visible). This lets you say things like<br>&gt;  <br>&gt; import Mod // imports Mod and all its members<br>&gt; import Mod () // only provides access to protocol conformances declared in Mod, doesn&#39;t actually import anything<br>&gt; import Mod (x,y) // imports `x` and `y`, which are also accessible as e.g. `Mod.x`, but does not provide `z` or `Mod.z`<br>&gt; import qualified Mod // imports Mod but all access to members has to go through it, e.g. `Mod.x`<br>&gt; import qualified Mod (x,y) // imports Mod but only provides access to `Mod.x` and `Mod.y` but not e.g. `Mod.z`<br>&gt; import Mod hiding (x,y) // imports Mod and its members except for `x` or `y`<br>&gt; import qualified Mod hiding (x,y) // imports e.g. `Mod.z` but not `Mod.x` or `Mod.y`<br>&gt; import Mod as Foo // imports Mod and renames the module to Foo, so e.g. `x` and `Foo.x` are accessible<br>&gt; import Mod as Foo (x,y) // renames Mod to Foo, provides `x`, `y`, `Foo.x`, and `Foo.y`<br>&gt; import qualified Mod as Foo // renames Mod to Foo, all members are accessible via the module e.g. `Foo.x`<br>&gt; import qualified Mod as Foo (x,y) // renames Mod to Foo, provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br>&gt;  <br>&gt; Furthermore, you can have multiple import statements from the same module, so you can say something like<br>&gt;  <br>&gt; import qualified Mod<br>&gt; import Mod (x,y)<br>&gt;  <br>&gt; to provide access to all of Mod qualified with the name, and additionally import `x` and `y` as unqualified identifiers.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/b8c310ea/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Beef up Imports</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m (personally) not such a fan of saying &quot;import just this one thing&quot; or &quot;import everything except this one thing&quot;—you end up trying to use UIImage(named:), and then realizing you haven&#39;t imported any of the top-level names. But &quot;import qualified&quot; seems great to me, and &quot;import Foo as Bar&quot; also seems reasonable.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 28, 2015, at 16:47, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea here, but I&#39;m not sold on the syntax. I also do explicitly want an `import qualified`. And with qualified imports, I question whether we really need to support renaming in the import syntax here.<br>&gt;  <br>&gt; I&#39;m tempted to say we should just crib Haskell&#39;s import rules (https://wiki.haskell.org/Import &lt;https://wiki.haskell.org/Import&gt;), with the minor change that importing members by name still makes them accessible via the module name too (in Haskell `import Mod (x, y)` makes `x` and `y` visible but does not make `Mod.x` or `Mod.y` visible). This lets you say things like<br>&gt;  <br>&gt; import Mod // imports Mod and all its members<br>&gt; import Mod () // only provides access to protocol conformances declared in Mod, doesn&#39;t actually import anything<br>&gt; import Mod (x,y) // imports `x` and `y`, which are also accessible as e.g. `Mod.x`, but does not provide `z` or `Mod.z`<br>&gt; import qualified Mod // imports Mod but all access to members has to go through it, e.g. `Mod.x`<br>&gt; import qualified Mod (x,y) // imports Mod but only provides access to `Mod.x` and `Mod.y` but not e.g. `Mod.z`<br>&gt; import Mod hiding (x,y) // imports Mod and its members except for `x` or `y`<br>&gt; import qualified Mod hiding (x,y) // imports e.g. `Mod.z` but not `Mod.x` or `Mod.y`<br>&gt; import Mod as Foo // imports Mod and renames the module to Foo, so e.g. `x` and `Foo.x` are accessible<br>&gt; import Mod as Foo (x,y) // renames Mod to Foo, provides `x`, `y`, `Foo.x`, and `Foo.y`<br>&gt; import qualified Mod as Foo // renames Mod to Foo, all members are accessible via the module e.g. `Foo.x`<br>&gt; import qualified Mod as Foo (x,y) // renames Mod to Foo, provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br>&gt;  <br>&gt; Furthermore, you can have multiple import statements from the same module, so you can say something like<br>&gt;  <br>&gt; import qualified Mod<br>&gt; import Mod (x,y)<br>&gt;  <br>&gt; to provide access to all of Mod qualified with the name, and additionally import `x` and `y` as unqualified identifiers.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/c9b9d3ab/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Beef up Imports</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>I like the fact that this would retain simplicity for basic uses - developers could continue to use &#39;import Mod&#39; and not even know about the more advanced syntax unless they need that power. The additional syntax seems like a natural progression from the base case.<br></p><p>Kevin, I understand the motivation for not really needed renaming for qualified imports but it feels like we would still need them for unqualified/global ones.  Do you think this is a valid use case? As suggested previously I think this would be least confusing/ambiguous by using a seperate renaming syntax -<br>import Mod hiding (x,y) renaming (z as zz)<br></p><p>An import statement such as above could equally be handled by seperate imports - one for hiding and one for renaming - and it might be worth being flexible and support both styles.<br></p><p>+1 to submodules as well, particularly if integrated into SPM to help optimise/reduce compile times when a module depends only on part of an otherwise related group of functionality that should be vended/consumed/versioned together.<br></p><p>-Simon<br></p><p>&gt; On 29 Dec 2015, at 11:47 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the idea here, but I&#39;m not sold on the syntax. I also do explicitly want an `import qualified`. And with qualified imports, I question whether we really need to support renaming in the import syntax here.<br>&gt;  <br>&gt; I&#39;m tempted to say we should just crib Haskell&#39;s import rules (https://wiki.haskell.org/Import &lt;https://wiki.haskell.org/Import&gt;), with the minor change that importing members by name still makes them accessible via the module name too (in Haskell `import Mod (x, y)` makes `x` and `y` visible but does not make `Mod.x` or `Mod.y` visible). This lets you say things like<br>&gt;  <br>&gt; import Mod // imports Mod and all its members<br>&gt; import Mod () // only provides access to protocol conformances declared in Mod, doesn&#39;t actually import anything<br>&gt; import Mod (x,y) // imports `x` and `y`, which are also accessible as e.g. `Mod.x`, but does not provide `z` or `Mod.z`<br>&gt; import qualified Mod // imports Mod but all access to members has to go through it, e.g. `Mod.x`<br>&gt; import qualified Mod (x,y) // imports Mod but only provides access to `Mod.x` and `Mod.y` but not e.g. `Mod.z`<br>&gt; import Mod hiding (x,y) // imports Mod and its members except for `x` or `y`<br>&gt; import qualified Mod hiding (x,y) // imports e.g. `Mod.z` but not `Mod.x` or `Mod.y`<br>&gt; import Mod as Foo // imports Mod and renames the module to Foo, so e.g. `x` and `Foo.x` are accessible<br>&gt; import Mod as Foo (x,y) // renames Mod to Foo, provides `x`, `y`, `Foo.x`, and `Foo.y`<br>&gt; import qualified Mod as Foo // renames Mod to Foo, all members are accessible via the module e.g. `Foo.x`<br>&gt; import qualified Mod as Foo (x,y) // renames Mod to Foo, provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br>&gt;  <br>&gt; Furthermore, you can have multiple import statements from the same module, so you can say something like<br>&gt;  <br>&gt; import qualified Mod<br>&gt; import Mod (x,y)<br>&gt;  <br>&gt; to provide access to all of Mod qualified with the name, and additionally import `x` and `y` as unqualified identifiers.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/254e0519/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Beef up Imports</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  7, 2016 at 12:00:00am</p></header><div class="content"><p>The reason why I say that we don&#39;t really need renaming is because you<br>only need renaming in order to avoid conflicts, and you can avoid<br>conflicts just by using a qualified import instead. As an example, if I<br>want to import some library that declares its own Result type, but I of<br>course have my own Result type as well, then I might say something like<br></p><p>import FrobLib hiding (Result) import qualified FrobLib (Result)<br></p><p>This will get me all of FrobLib except for Result, and also let me use<br>`FrobLib.Result` whenever I do need to reference that library&#39;s Result<br>type. Or if I need to reference it frequently I might even say<br></p><p>import qualified FrobLib as F (Result)<br></p><p>so I can just use `F.Result`.<br></p><p>In my experience, there&#39;s not much need for renaming once you can do<br>this with qualified imports.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 5, 2016, at 05:44 PM, Simon Pilkington wrote:<br>&gt; I like the fact that this would retain simplicity for basic uses -<br>&gt; developers could continue to use &#39;*import* Mod&#39; and not even know<br>&gt; about the more advanced syntax unless they need that power. The<br>&gt; additional syntax seems like a natural progression from the base case.<br>&gt;<br>&gt; Kevin, I understand the motivation for not really needed renaming for<br>&gt; qualified imports but it feels like we would still need them for<br>&gt; unqualified/global ones.  Do you think this is a valid use case? As<br>&gt; suggested previously I think this would be least confusing/ambiguous<br>&gt; by using a seperate *renaming* syntax - *import* Mod *hiding* (x,y)<br>&gt; *renaming* (z as zz)<br>&gt;<br>&gt; An import statement such as above could equally be handled by seperate<br>&gt; imports - one for hiding and one for renaming - and it might be worth<br>&gt; being flexible and support both styles.<br>&gt;<br>&gt; +1 to submodules as well, particularly if integrated into SPM to help<br>&gt; optimise/reduce compile times when a module depends only on part of an<br>&gt; otherwise related group of functionality that should be<br>&gt; vended/consumed/versioned together.<br>&gt;<br>&gt; -Simon<br>&gt;<br>&gt;&gt; On 29 Dec 2015, at 11:47 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like the idea here, but I&#39;m not sold on the syntax. I also do<br>&gt;&gt; explicitly want an `import qualified`. And with qualified imports, I<br>&gt;&gt; question whether we really need to support renaming in the import<br>&gt;&gt; syntax here.<br>&gt;&gt;<br>&gt;&gt; I&#39;m tempted to say we should just crib Haskell&#39;s import rules<br>&gt;&gt; (https://wiki.haskell.org/Import), with the minor change that<br>&gt;&gt; importing members by name still makes them accessible via the module<br>&gt;&gt; name too (in Haskell `import Mod (x, y)` makes `x` and `y` visible<br>&gt;&gt; but does not make `Mod.x` or `Mod.y` visible). This lets you say<br>&gt;&gt; things like<br>&gt;&gt;<br>&gt;&gt; *import* Mod // imports Mod and all its members *import* Mod () //<br>&gt;&gt; only provides access to protocol conformances declared in Mod,<br>&gt;&gt; doesn&#39;t actually *import* anything *import* Mod *(*x,y*)* // imports<br>&gt;&gt; `x` and `y`, which are also accessible as e.g. `Mod.x`, but does not<br>&gt;&gt; provide `z` or `Mod.z` *import qualified* Mod // imports Mod but all<br>&gt;&gt; access to members has to go through it, e.g. `Mod.x` *import<br>&gt;&gt; qualified* Mod *(*x,y*)* // imports Mod but only provides access to<br>&gt;&gt; `Mod.x` and `Mod.y` but not e.g. `Mod.z` *import *Mod *hiding*<br>&gt;&gt; *(*x,y*)* // imports Mod and its members except for `x` or `y`<br>&gt;&gt; *import qualified* Mod *hiding* *(*x,y*)* // imports e.g. `Mod.z` but<br>&gt;&gt; not `Mod.x` or `Mod.y`** *import* Mod *as* Foo // imports Mod and<br>&gt;&gt; renames the module to Foo, so e.g. `x` and `Foo.x` are accessible<br>&gt;&gt; *import* Mod *as* Foo *(*x,y*)* // renames Mod to Foo, provides `x`,<br>&gt;&gt; `y`, `Foo.x`, and `Foo.y` *import qualified* Mod *as* Foo // renames<br>&gt;&gt; Mod to Foo, all members are accessible via the module e.g. `Foo.x`<br>&gt;&gt; *import qualified* Mod *as* Foo *(*x,y*)* // renames Mod to Foo,<br>&gt;&gt; provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br>&gt;&gt;<br>&gt;&gt; Furthermore, you can have multiple import statements from the same<br>&gt;&gt; module, so you can say something like<br>&gt;&gt;<br>&gt;&gt; *import qualified* Mod *import* Mod *(*x,y*)*<br>&gt;&gt;<br>&gt;&gt; to provide access to all of Mod qualified with the name, and<br>&gt;&gt; additionally import `x` and `y` as unqualified identifiers.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/0a4f1e3f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Beef up Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January  7, 2016 at 02:00:00am</p></header><div class="content"><p>I&#39;ll admit, Agda does seem to use &#39;renaming&#39; to enable notational preference first and foremost.  I&#39;m not sure of too many Swift authors who would put something like that too high on their list of concerns, so +1.  Drop renaming.<br></p><p>~Robert Widmann<br></p><p>2016/01/07 1:53、Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; The reason why I say that we don&#39;t really need renaming is because you only need renaming in order to avoid conflicts, and you can avoid conflicts just by using a qualified import instead. As an example, if I want to import some library that declares its own Result type, but I of course have my own Result type as well, then I might say something like<br>&gt;  <br>&gt; import FrobLib hiding (Result)<br>&gt; import qualified FrobLib (Result)<br>&gt;  <br>&gt; This will get me all of FrobLib except for Result, and also let me use `FrobLib.Result` whenever I do need to reference that library&#39;s Result type. Or if I need to reference it frequently I might even say<br>&gt;  <br>&gt; import qualified FrobLib as F (Result)<br>&gt;  <br>&gt; so I can just use `F.Result`.<br>&gt;  <br>&gt; In my experience, there&#39;s not much need for renaming once you can do this with qualified imports.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt; On Tue, Jan 5, 2016, at 05:44 PM, Simon Pilkington wrote:<br>&gt;&gt; I like the fact that this would retain simplicity for basic uses - developers could continue to use &#39;import Mod&#39; and not even know about the more advanced syntax unless they need that power. The additional syntax seems like a natural progression from the base case.<br>&gt;&gt;  <br>&gt;&gt; Kevin, I understand the motivation for not really needed renaming for qualified imports but it feels like we would still need them for unqualified/global ones.  Do you think this is a valid use case? As suggested previously I think this would be least confusing/ambiguous by using a seperate renaming syntax -<br>&gt;&gt; import Mod hiding (x,y) renaming (z as zz)<br>&gt;&gt;  <br>&gt;&gt; An import statement such as above could equally be handled by seperate imports - one for hiding and one for renaming - and it might be worth being flexible and support both styles.<br>&gt;&gt;  <br>&gt;&gt; +1 to submodules as well, particularly if integrated into SPM to help optimise/reduce compile times when a module depends only on part of an otherwise related group of functionality that should be vended/consumed/versioned together.<br>&gt;&gt;  <br>&gt;&gt; -Simon<br>&gt;&gt;  <br>&gt;&gt;&gt; On 29 Dec 2015, at 11:47 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I like the idea here, but I&#39;m not sold on the syntax. I also do explicitly want an `import qualified`. And with qualified imports, I question whether we really need to support renaming in the import syntax here.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I&#39;m tempted to say we should just crib Haskell&#39;s import rules (https://wiki.haskell.org/Import), with the minor change that importing members by name still makes them accessible via the module name too (in Haskell `import Mod (x, y)` makes `x` and `y` visible but does not make `Mod.x` or `Mod.y` visible). This lets you say things like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; import Mod // imports Mod and all its members<br>&gt;&gt;&gt; import Mod () // only provides access to protocol conformances declared in Mod, doesn&#39;t actually import anything<br>&gt;&gt;&gt; import Mod (x,y) // imports `x` and `y`, which are also accessible as e.g. `Mod.x`, but does not provide `z` or `Mod.z`<br>&gt;&gt;&gt; import qualified Mod // imports Mod but all access to members has to go through it, e.g. `Mod.x`<br>&gt;&gt;&gt; import qualified Mod (x,y) // imports Mod but only provides access to `Mod.x` and `Mod.y` but not e.g. `Mod.z`<br>&gt;&gt;&gt; import Mod hiding (x,y) // imports Mod and its members except for `x` or `y`<br>&gt;&gt;&gt; import qualified Mod hiding (x,y) // imports e.g. `Mod.z` but not `Mod.x` or `Mod.y`<br>&gt;&gt;&gt; import Mod as Foo // imports Mod and renames the module to Foo, so e.g. `x` and `Foo.x` are accessible<br>&gt;&gt;&gt; import Mod as Foo (x,y) // renames Mod to Foo, provides `x`, `y`, `Foo.x`, and `Foo.y`<br>&gt;&gt;&gt; import qualified Mod as Foo // renames Mod to Foo, all members are accessible via the module e.g. `Foo.x`<br>&gt;&gt;&gt; import qualified Mod as Foo (x,y) // renames Mod to Foo, provides access to `Foo.x` and `Foo.y` but not e.g. `Foo.z`<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Furthermore, you can have multiple import statements from the same module, so you can say something like<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; import qualified Mod<br>&gt;&gt;&gt; import Mod (x,y)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; to provide access to all of Mod qualified with the name, and additionally import `x` and `y` as unqualified identifiers.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/151674c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Beef up Imports</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 07 Jan 2016, at 11:59, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ll admit, Agda does seem to use &#39;renaming&#39; to enable notational preference first and foremost.  I&#39;m not sure of too many Swift authors who would put something like that too high on their list of concerns, so +1.  Drop renaming.<br></p><p><br>I tend to also agree. One more reason not to rename imported identifiers is that it makes them less googleable at call site; there&#39;s an extra human indirection (looking up the respective import statement) before being successfully at searching with the commonly known name.<br></p><p>But is there more we could prune away from this proposal? When would you really want to hide or selectively choose any qualified imports? If qualified imports always imported all identifiers, with the restriction that they must be qualified, would there (should there) ever be conflicts with anything else imported or locally defined?<br></p><p>It seems to me we could simplify it all down to just:<br></p><p>import Lib              // Works just like in Swift 2, qualified or not.<br>import Lib (Foo, bar)   // Only Foo and bar unqualified, others like Lib.qux.<br>import Lib ()           // Everything must be qualified: Lib.Foo etc.<br>import Lib hiding (qux) // Everything but baz works unqualified, and all like Lib.qux.<br>import Lib as L         // Import all unqualified, allow qualification under L like L.Foo.<br>import Lib as L (Foo)   // Only Foo unqualified, others under L like L.bar.<br>import Lib as L ()      // Everything must be qualified under L like L.Foo etc.<br>import Lib as L hiding (qux) // ..., qux must be qualified like L.qux.<br></p><p>Wouldn&#39;t that work pretty nicely, with minimal additions to syntax?<br></p><p>— Pyry<br></p><p>P.S. Okay, I can come up with a somewhat contrived corner case: What to do with modules whose names collide with type names imported unqualified, e.g. https://github.com/robrix/Either &lt;https://github.com/robrix/Either&gt; ?<br></p><p>import Lib // defines bar like above (1)<br></p><p>struct Lib {<br>    static func bar() {} // (2)<br>}<br></p><p>Lib.bar() // Which one gets called, (1) or (2)?<br></p><p>One might suggest the above call resolved to the locally defined function. How about if struct Lib was defined in another module that was also imported?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/7ec255f8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Beef up Imports</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 28, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 9:12 PM, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I opened a radar a while ago about improving the import syntax in Swift and haven’t received much of a response, so I’ll try to expand on my thoughts in there here.<br>&gt; <br>&gt; I’ve always been in love with the way Agda does Modules and imports.  The syntax is wonderfully natural, and the features it provides are surprisingly useful given their simplicity.  Because Swift forbids the redeclaration of names between structs, enums, classes, and typealiases, I don’t believe that the existing qualified import syntax is needed.  Therefore, I propose the introduction of 3 agda-esque operations for imports to replace the usual `import {func|typealias|struct|class|enum|etc.}` syntax:<br>&gt; <br>&gt; 	• import Foo using (bar, Baz, qux, corge, …)<br>&gt; 	• import Foo hiding (bar, baz, qux, corge, …)<br>&gt; 	• import Foo renaming (grault to garply, waldo to fred, …)<br>&gt; <br>&gt; The first of these is used to introduce a limited set of identifiers into scope, the second to import all but the given identifiers, and the third to rename identifiers at the module level.  Again, it should be obvious by uniqueness of identifiers what each one is referencing, so qualification of each identifier is unnecessary.  If more context is needed, or more granularity, a Haskell-esque <br></p><p>+1 for this general direction, if not this specific syntax.  It would also be great to have import integrate with SPM so you can import a package from an SCM URL.  This would be pretty handy in particular for #! scripts.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Beef up Imports</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 28, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 5:07 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for this general direction, if not this specific syntax.  It would also be great to have import integrate with SPM so you can import a package from an SCM URL.  This would be pretty handy in particular for #! scripts.<br>&gt; <br>This seems like it would strongly motivate toward a (possibly directory-scoped or system-scoped) package cache. Not saying thats a bad thing, just that it seems different than the executable packaging Swift has today with “Apps&quot;.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/edd7f848/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Beef up Imports</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 28, 2015 at 07:00:00pm</p></header><div class="content"><p>+1 in general.<br></p><p>As an aside (In response to David), I have wanted the ability to import<br>&#39;submodules&#39; from a framework since Swift 1.0. Being able to group related<br>functionality to import is a desirable feature, IMO<br>TJ<br></p><p>On Mon, Dec 28, 2015 at 7:01 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 28, 2015, at 5:07 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 for this general direction, if not this specific syntax.  It would also<br>&gt; be great to have import integrate with SPM so you can import a package from<br>&gt; an SCM URL.  This would be pretty handy in particular for #! scripts.<br>&gt;<br>&gt; This seems like it would strongly motivate toward a (possibly<br>&gt; directory-scoped or system-scoped) package cache. Not saying thats a bad<br>&gt; thing, just that it seems different than the executable packaging Swift has<br>&gt; today with “Apps&quot;.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/05661cde/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Beef up Imports</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>How is this done for things like the Darwin module?<br></p><p>~Robert Widmann<br></p><p>2015/12/28 20:19、T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; +1 in general. <br>&gt; <br>&gt; As an aside (In response to David), I have wanted the ability to import &#39;submodules&#39; from a framework since Swift 1.0. Being able to group related functionality to import is a desirable feature, IMO<br>&gt; TJ<br>&gt; <br>&gt;&gt; On Mon, Dec 28, 2015 at 7:01 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 5:07 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for this general direction, if not this specific syntax.  It would also be great to have import integrate with SPM so you can import a package from an SCM URL.  This would be pretty handy in particular for #! scripts.<br>&gt;&gt; This seems like it would strongly motivate toward a (possibly directory-scoped or system-scoped) package cache. Not saying thats a bad thing, just that it seems different than the executable packaging Swift has today with “Apps&quot;.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/85080f40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Beef up Imports</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 01:00:00pm</p></header><div class="content"><p>Clang modules have always supported submodules, and in fact when you<br>import an Obj-C framework (that doesn&#39;t use a completely custom<br>module.modulemap), each header from the framework is automatically a<br>submodule (and importing the framework automatically imports all the<br>submodules).<br></p><p>All Swift is missing is a way to express a submodule hierarchy in Swift<br>code. It already supports the idea of importing submodules, just not<br>declaring them.<br></p><p>-Kevin<br></p><p>On Tue, Dec 29, 2015, at 12:29 PM, Developer via swift-evolution wrote:<br>&gt; How is this done for things like the Darwin module?<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2015/12/28 20:19、T.J. Usiyan via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; +1 in general.<br>&gt;&gt;<br>&gt;&gt; As an aside (In response to David), I have wanted the ability to<br>&gt;&gt; import &#39;submodules&#39; from a framework since Swift 1.0. Being able to<br>&gt;&gt; group related functionality to import is a desirable feature, IMO TJ<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 28, 2015 at 7:01 PM, David Waite via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 5:07 PM, Chris Lattner via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 for this general direction, if not this specific syntax.  It<br>&gt;&gt;&gt;&gt; would also be great to have import integrate with SPM so you can<br>&gt;&gt;&gt;&gt; import a package from an SCM URL.  This would be pretty handy in<br>&gt;&gt;&gt;&gt; particular for #! scripts.<br>&gt;&gt;&gt; This seems like it would strongly motivate toward a (possibly directory-<br>&gt;&gt;&gt; scoped or system-scoped) package cache. Not saying thats a bad<br>&gt;&gt;&gt; thing, just that it seems different than the executable packaging<br>&gt;&gt;&gt; Swift has today with “Apps&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/5eb573d3/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
