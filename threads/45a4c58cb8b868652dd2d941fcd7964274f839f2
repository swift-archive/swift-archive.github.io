<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi swift-evolution,<br></p><p>Dave, Max and I have compiled a list of open issues in the standard<br>library for which the resolutions could result non-additive API<br>changes.  Having a resolution (and an implementation of the<br>resolution!) for these issues is blocking API stability.<br></p><p>https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br></p><p>This is not an exhaustive list.  The first two sections (&quot;Low-Hanging<br>Fruit&quot; and &quot;Moderate&quot;) list issues with low and moderate difficulty.<br>It should be possible to resolve them with minimal design work.<br></p><p>**We are strongly encouraging the community to pick up these issues.<br>Please do not reply to this thread.  Instead, start a new thread for<br>the issue you would like to discuss, and include the original<br>description and the bugs.swift.org link in your email.**<br></p><p>For the issues in the &quot;Hard&quot; section, we would like to post the<br>following commentary:<br></p><p>- The issue about algorithms not marked mutating consuming a<br>single-pass Sequences.  We have figured out a design that we think is<br>a good trade-off.  We will post it for public discussion within a few<br>days.<br></p><p><br>- An extension to the collections subsystem that would allow us to<br>model infinite data streams.  We think that the answer to this problem<br>should try hard to handle both single- and multi-pass collections, or<br>provide a very convincing explanation why it is desired to enable only<br>one of them (only multi-pass or only single-pass) to be infinite.<br></p><p>We see four possible solutions to this problem:<br></p><p>1. No change (disallow infinite data streams).<br></p><p>2. Allow infinite single-pass streams (as Iterators) and infinite<br>multi-pass streams (as Collections).<br></p><p>3. #2, and, for QoI, to catch mistakes in a non-guaranteed,<br>best-effort fashion, add a property &#39;isKnownToBeInfinite&#39; or<br>&#39;isKnownToBeFinite&#39; that would be checked before the whole dataset is<br>iterated.  If the dataset is known to be infinite, issue a trap.<br></p><p>4. #2, and introduce new protocols for finite iterators and finite collections.<br></p><p>Unfortunately we don&#39;t have time to investigate the question about<br>infinite collections further.  We suggest interested community members<br>to drive the discussion on this topic.<br></p><p><br>- Dave Abrahams has been investigating whether it would be an<br>improvement to remove Comparable requirement from collection indices,<br>he will post an update separately.<br></p><p><br>- Naming of algorithms on sequences and collections is important, and<br>we are thankful for the community for working on these issues.  We<br>hope that these efforts would result in proposals!<br></p><p><br>- The spaceship &lt;=&gt; operator is an important, but also complex topic.<br>If someone wants to work on this item, we think that writing a<br>prototype and showing how it integrates with existing code,<br>investigating whether it solves issues with floating point min() and<br>NaNs, figuring out what the migration experience is etc. is critical<br>before opening a discussion.<br></p><p>The general design direction is clear -- we want to require users to<br>define just one operator, &lt;=&gt;, to conform to Comparable, but there are<br>many details that would only be found in a prototype implementation.<br>These small issues need concrete answers.<br></p><p><br></p><p>I&#39;d like to thank the community again for all work that you are doing,<br>and encourage to pick up the issues from the list, and start<br>discussions in new threads.  I&#39;d like to emphasize low and moderate<br>difficulty items.  We believe that for these issues the design space<br>is small, and consensus can be reached without a lot of discussion.<br>The associated API changes have a good chance to land in Swift 3.x.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt; library for which the resolutions could result non-additive API<br>&gt; changes.  Having a resolution (and an implementation of the<br>&gt; resolution!) for these issues is blocking API stability.<br>&gt; <br>&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br></p><p>Thank you for collecting this Dmitri!  For the issues in the “low hanging fruit” list, are the changes all sufficiently &quot;obvious”?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  5, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt;<br>&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;<br>&gt; Thank you for collecting this Dmitri!  For the issues in the “low hanging fruit” list, are the changes all sufficiently &quot;obvious”?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br></p><p>My subjective assessment:<br></p><p>&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label “to”.<br>Obvious.<br></p><p>&gt; UnicodeScalar.init(Int) should be failable.<br>Obvious.<br></p><p>&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br></p><p>&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>Obvious, unless someone comes up with use cases during the review period.<br></p><p>&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>Debatable.<br></p><p>&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>Obvious.<br></p><p>&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>Obvious.<br></p><p>&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>A separate review.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  6, 2016 at 01:00:00pm</p></header><div class="content"><p>I’m quite interested in this point:<br></p><p>&gt; Figure out whether RangeReplaceableCollection.replaceRange should accept a Sequence as its argument, and if so implement it.<br></p><p>At the moment `replaceSubrange` takes a sequence, and lots of methods on RangeReplaceableCollection use that to perform their mutation operations. That means that Collections gets iterated item-by-item; for example, a String will get parsed out in to Characters and added individually to the existing string. In general, depending on which methods you use to mutate a RRC, you can expect wildly different performance characteristics. So it’s more important to fix than the name might suggest.<br></p><p>I had a PR open for this which added a Collection specialisation, but you said this could be handled in a more general way which allows for more optimised mutations. I’m curious how this would work; how does `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)` call a more optimised implementation if S also conforms to Collection, if not by adding a specialisation?<br></p><p><br>Karl<br></p><p>&gt; On 6 Jul 2016, at 07:50, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt; <br>&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the “low hanging fruit” list, are the changes all sufficiently &quot;obvious”?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br>&gt; <br>&gt; My subjective assessment:<br>&gt; <br>&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label “to”.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br>&gt; <br>&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>&gt; Debatable.<br>&gt; <br>&gt;&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt; A separate review.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/031cc53d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jul 06 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt; I’m quite interested in this point:<br>&gt;<br>&gt;&gt; Figure out whether RangeReplaceableCollection.replaceRange should accept a Sequence as its argument, and if so implement it.<br>&gt;<br>&gt; At the moment `replaceSubrange` takes a sequence, <br></p><p>No, actually at the moment it takes a Collection.<br></p><p>&gt; and lots of methods on RangeReplaceableCollection use that to perform<br>&gt; their mutation operations. That means that Collections gets iterated<br>&gt; item-by-item; for example, a String will get parsed out in to<br>&gt; Characters and added individually to the existing string. <br></p><p>And a String is neither a Sequence nor a Collection.<br></p><p>&gt; In general, depending on which methods you use to mutate a RRC, you<br>&gt; can expect wildly different performance characteristics. So it’s more<br>&gt; important to fix than the name might suggest.<br></p><p>It depends on the RRC.  Some RRCs can be restructured at the front or<br>back more cheaply than in the middle.<br></p><p>&gt; I had a PR open for this which added a Collection specialisation, but<br>&gt; you said this could be handled in a more general way which allows for<br>&gt; more optimised mutations. I’m curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with:<br>&gt; S)` call a more optimised implementation if S also conforms to<br>&gt; Collection, if not by adding a specialisation?<br></p><p>I&#39;m sorry, I don&#39;t know what you&#39;re referring to here.  If you have<br>specific questions about a response to a PR, could you ask them in the<br>PR?  (It doesn&#39;t have to be open)<br></p><p>&gt;&gt; On 6 Jul 2016, at 07:50, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the “low<br>&gt;&gt;&gt; hanging fruit” list, are the changes all sufficiently &quot;obvious”?<br>&gt;&gt;&gt; If so, having one proposal tackle all of them in one sweep would be<br>&gt;&gt;&gt; preferable to reduce process overhead.<br>&gt;&gt; <br>&gt;&gt; My subjective assessment:<br>&gt;&gt; <br>&gt;&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label “to”.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt;&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br>&gt;&gt; <br>&gt;&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for<br>&gt;&gt;&gt; it. If there are any, it should be renamed to unsafeAddress(of:) to<br>&gt;&gt;&gt; follow the guidelines.<br>&gt;&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;&gt; <br>&gt;&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an<br>&gt;&gt;&gt; extra bit of type safety inside of the closure passed to<br>&gt;&gt;&gt; ManagedBuffer.create().<br>&gt;&gt; Debatable.<br>&gt;&gt; <br>&gt;&gt;&gt; String.CharacterView.Iterator should be a custom type rather than<br>&gt;&gt;&gt; the default, to allow performance optimizations. Audit all other<br>&gt;&gt;&gt; collections for such opportunities.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt;&gt; A separate review.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt; said this could be handled in a more general way which allows for more<br>&gt; optimised mutations. I’m curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt; not by adding a specialisation?<br></p><p>The RRC can call into S.someCustomizationPoint(), which will<br>initialize a region of memory in the most efficient way possible,<br>since it has complete knowledge about the memory layout of S.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt;&gt; said this could be handled in a more general way which allows for more<br>&gt;&gt; optimised mutations. I’m curious how this would work; how does<br>&gt;&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt;&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt;&gt; not by adding a specialisation?<br>&gt; <br>&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt; initialize a region of memory in the most efficient way possible,<br>&gt; since it has complete knowledge about the memory layout of S.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>Sorry, it’s been a little while since I looked at it (https://github.com/apple/swift/pull/3067 &lt;https://github.com/apple/swift/pull/3067&gt;). Actually, the issue is with the append() function specifically - it only has a Sequence specialisation. That’s the point; we were losing type information and not calling the more optimised replaceSubrange — which is exactly the specialisation point you are talking about, Dmitry (I think everything funnels down in to replaceSubrange).<br></p><p>I must have misunderstood what you were saying at the time. I’ll have to test, but I think it’s still an issue. I thought there was some more general work on RRC planned, so when I saw the bullet I thought maybe that was it.<br></p><p>@Dave:<br></p><p>I was trying to initialise a String.CharacterView - depending on whether I initialised it with another CharacterView, or created it empty and appended the other CharacterView, I would get huge performance differences, as the other CharacterView would get split up and a new Character created and appended for every character in the string (which had like 10,000 characters). It’s a subtle bug and a bit nasty when it hits you.<br></p><p>Karl<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/0919ce98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 6:15 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt; said this could be handled in a more general way which allows for more<br>&gt; optimised mutations. I’m curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt; not by adding a specialisation?<br>&gt;<br>&gt;<br>&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt; initialize a region of memory in the most efficient way possible,<br>&gt; since it has complete knowledge about the memory layout of S.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br>&gt; Sorry, it’s been a little while since I looked at it<br>&gt; (https://github.com/apple/swift/pull/3067). Actually, the issue is with the<br>&gt; append() function specifically - it only has a Sequence specialisation.<br>&gt; That’s the point; we were losing type information and not calling the more<br>&gt; optimised replaceSubrange — which is exactly the specialisation point you<br>&gt; are talking about, Dmitry (I think everything funnels down in to<br>&gt; replaceSubrange).<br></p><p>I&#39;m talking about a different customization point.  RRC.append() calls<br>RRC.replaceSubrange(), which, in our thinking, would call<br>S._copyContents(initializing: RRC.getInnerPointer()).  _copyContents()<br>is the customization point on the argument that would initialize<br>memory with the contents of the sequence.<br></p><p>&gt; I must have misunderstood what you were saying at the time. I’ll have to<br>&gt; test, but I think it’s still an issue. I thought there was some more general<br>&gt; work on RRC planned, so when I saw the bullet I thought maybe that was it.<br></p><p>I will be sending a draft proposal soon that will indirectly fix this<br>performance issue.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 03:15, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt;&gt;&gt; said this could be handled in a more general way which allows for more<br>&gt;&gt;&gt; optimised mutations. I’m curious how this would work; how does<br>&gt;&gt;&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt;&gt;&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt;&gt;&gt; not by adding a specialisation?<br>&gt;&gt; <br>&gt;&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt;&gt; initialize a region of memory in the most efficient way possible,<br>&gt;&gt; since it has complete knowledge about the memory layout of S.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; Sorry, it’s been a little while since I looked at it (https://github.com/apple/swift/pull/3067 &lt;https://github.com/apple/swift/pull/3067&gt;). Actually, the issue is with the append() function specifically - it only has a Sequence specialisation. That’s the point; we were losing type information and not calling the more optimised replaceSubrange — which is exactly the specialisation point you are talking about, Dmitry (I think everything funnels down in to replaceSubrange).<br>&gt; <br>&gt; I must have misunderstood what you were saying at the time. I’ll have to test, but I think it’s still an issue. I thought there was some more general work on RRC planned, so when I saw the bullet I thought maybe that was it.<br>&gt; <br>&gt; @Dave:<br>&gt; <br>&gt; I was trying to initialise a String.CharacterView - depending on whether I initialised it with another CharacterView, or created it empty and appended the other CharacterView, I would get huge performance differences, as the other CharacterView would get split up and a new Character created and appended for every character in the string (which had like 10,000 characters). It’s a subtle bug and a bit nasty when it hits you.<br>&gt; <br>&gt; Karl<br></p><p>Ah no, my memory’s coming back - it wasn’t the overhead in the standard library that was the biggest problem, as much as the 10,000 calls to replaceSubrange with a single element being appended. We had to do some additional processing, and it was just killer doing it so many times.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/509f2097/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  6, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 11:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt; <br>&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the “low hanging fruit” list, are the changes all sufficiently &quot;obvious”?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br>&gt; <br>&gt; My subjective assessment:<br>&gt; <br>&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label “to”.<br>&gt; Obvious.<br>&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>&gt; Debatable.<br>&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956 &lt;https://bugs.swift.org/browse/SR-1956&gt;<br></p><p>These batch together but I&#39;m thinking the latter three will have much more debate. (The first one can be a quick hit.) I&#39;ll get these topics started in a separate thread.<br></p><p>&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt; Obvious.<br></p><p>These string items  naturally batch together<br></p><p><br>&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt; A separate review.<br></p><p><br>I think Matthew Johnson has this under control<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/60cdeaf2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If<br>&gt; there are any, it should be renamed to unsafeAddress(of:) to follow the<br>&gt; guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;<br>&gt;<br>It&#39;s minor, but I use unsafeAddressOf regularly for writing `description`<br>methods:<br></p><p>    var description: String {<br>        return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info<br>here... }&quot;<br>    }<br></p><p>I guess this would be covered by some generalized solution for format<br>specifiers in string interpolations, but I gather that won&#39;t happen for<br>quite a while...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/bd85db89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>I’ve also seen unsafeAddressOf(_:) used when interfacing with C function pointers when the lifetime of an object is guaranteed. Many C APIs vend an API like:<br></p><p>void perform_action(void (*callback)(void *data), void *initial_data);<br></p><p>For which it is expected to use unsafeAddressOf on a class instance, like:<br></p><p>perform_action({ data in<br>  let _self = unsafeBitCast(data, to: MyClass.self)<br>  _self.foo()<br>}, data: unsafeAddressOf(self))<br></p><p>It’s unsafe and error-prone, sure, but that’s why we have `unsafe` in the name 😅 — I’ve had to use this to interface with libclang.<br></p><p>(For an existing example of this, see SwiftGtk: https://github.com/TomasLinhart/SwiftGtk/blob/master/Sources/Application.swift &lt;https://github.com/TomasLinhart/SwiftGtk/blob/master/Sources/Application.swift&gt;)<br></p><p>— Harlan<br></p><p>&gt; On Jul 6, 2016, at 11:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt; <br>&gt; It&#39;s minor, but I use unsafeAddressOf regularly for writing `description` methods:<br>&gt; <br>&gt;     var description: String {<br>&gt;         return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info here... }&quot;<br>&gt;     }<br>&gt; <br>&gt; I guess this would be covered by some generalized solution for format specifiers in string interpolations, but I gather that won&#39;t happen for quite a while...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/816b3670/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 11:30 AM, Harlan Haskins &lt;harlan at harlanhaskins.com&gt;<br>wrote:<br></p><p>&gt; I’ve also seen unsafeAddressOf(_:) used when interfacing with C function<br>&gt; pointers when the lifetime of an object is guaranteed. Many C APIs vend an<br>&gt; API like:<br>&gt;<br>&gt; void perform_action(void (*callback)(void *data), void *initial_data);<br>&gt;<br>&gt; For which it is expected to use unsafeAddressOf on a class instance, like:<br>&gt;<br>&gt; perform_action({ data in<br>&gt;   let _self = unsafeBitCast(data, to: MyClass.self)<br>&gt;   _self.foo()<br>&gt; }, data: unsafeAddressOf(self))<br>&gt;<br>&gt; It’s unsafe and error-prone, sure, but that’s why we have `unsafe` in the<br>&gt; name 😅 — I’ve had to use this to interface with libclang.<br>&gt;<br></p><p>Hi Harlan,<br></p><p>For this case, Unmanaged is the recommended API.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/089f3e1d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jul 06 2016, Jacob Bandes-Storch &lt;jtbandes-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If<br>&gt;&gt; there are any, it should be renamed to unsafeAddress(of:) to follow the<br>&gt;&gt; guidelines.<br>&gt;&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; It&#39;s minor, but I use unsafeAddressOf regularly for writing `description`<br>&gt; methods:<br>&gt;<br>&gt;     var description: String {<br>&gt;         return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info<br>&gt; here... }&quot;<br>&gt;     }<br></p><p>You can do that, but there&#39;s no guarantee that the address is<br>meaningful.  The compiler is free to copy self into a writeback buffer<br>whose address gets printed.<br></p><p>&gt; I guess this would be covered by some generalized solution for format<br>&gt; specifiers in string interpolations, but I gather that won&#39;t happen for<br>&gt; quite a while...<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
