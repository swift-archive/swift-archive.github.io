<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi swift-evolution,<br></p><p>Dave, Max and I have compiled a list of open issues in the standard<br>library for which the resolutions could result non-additive API<br>changes.  Having a resolution (and an implementation of the<br>resolution!) for these issues is blocking API stability.<br></p><p>https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br></p><p>This is not an exhaustive list.  The first two sections (&quot;Low-Hanging<br>Fruit&quot; and &quot;Moderate&quot;) list issues with low and moderate difficulty.<br>It should be possible to resolve them with minimal design work.<br></p><p>**We are strongly encouraging the community to pick up these issues.<br>Please do not reply to this thread.  Instead, start a new thread for<br>the issue you would like to discuss, and include the original<br>description and the bugs.swift.org link in your email.**<br></p><p>For the issues in the &quot;Hard&quot; section, we would like to post the<br>following commentary:<br></p><p>- The issue about algorithms not marked mutating consuming a<br>single-pass Sequences.  We have figured out a design that we think is<br>a good trade-off.  We will post it for public discussion within a few<br>days.<br></p><p><br>- An extension to the collections subsystem that would allow us to<br>model infinite data streams.  We think that the answer to this problem<br>should try hard to handle both single- and multi-pass collections, or<br>provide a very convincing explanation why it is desired to enable only<br>one of them (only multi-pass or only single-pass) to be infinite.<br></p><p>We see four possible solutions to this problem:<br></p><p>1. No change (disallow infinite data streams).<br></p><p>2. Allow infinite single-pass streams (as Iterators) and infinite<br>multi-pass streams (as Collections).<br></p><p>3. #2, and, for QoI, to catch mistakes in a non-guaranteed,<br>best-effort fashion, add a property &#39;isKnownToBeInfinite&#39; or<br>&#39;isKnownToBeFinite&#39; that would be checked before the whole dataset is<br>iterated.  If the dataset is known to be infinite, issue a trap.<br></p><p>4. #2, and introduce new protocols for finite iterators and finite collections.<br></p><p>Unfortunately we don&#39;t have time to investigate the question about<br>infinite collections further.  We suggest interested community members<br>to drive the discussion on this topic.<br></p><p><br>- Dave Abrahams has been investigating whether it would be an<br>improvement to remove Comparable requirement from collection indices,<br>he will post an update separately.<br></p><p><br>- Naming of algorithms on sequences and collections is important, and<br>we are thankful for the community for working on these issues.  We<br>hope that these efforts would result in proposals!<br></p><p><br>- The spaceship &lt;=&gt; operator is an important, but also complex topic.<br>If someone wants to work on this item, we think that writing a<br>prototype and showing how it integrates with existing code,<br>investigating whether it solves issues with floating point min() and<br>NaNs, figuring out what the migration experience is etc. is critical<br>before opening a discussion.<br></p><p>The general design direction is clear -- we want to require users to<br>define just one operator, &lt;=&gt;, to conform to Comparable, but there are<br>many details that would only be found in a prototype implementation.<br>These small issues need concrete answers.<br></p><p><br></p><p>I&#39;d like to thank the community again for all work that you are doing,<br>and encourage to pick up the issues from the list, and start<br>discussions in new threads.  I&#39;d like to emphasize low and moderate<br>difficulty items.  We believe that for these issues the design space<br>is small, and consensus can be reached without a lot of discussion.<br>The associated API changes have a good chance to land in Swift 3.x.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi swift-evolution,<br>&gt; <br>&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt; library for which the resolutions could result non-additive API<br>&gt; changes.  Having a resolution (and an implementation of the<br>&gt; resolution!) for these issues is blocking API stability.<br>&gt; <br>&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br></p><p>Thank you for collecting this Dmitri!  For the issues in the ‚Äúlow hanging fruit‚Äù list, are the changes all sufficiently &quot;obvious‚Äù?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  5, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi swift-evolution,<br>&gt;&gt;<br>&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;<br>&gt; Thank you for collecting this Dmitri!  For the issues in the ‚Äúlow hanging fruit‚Äù list, are the changes all sufficiently &quot;obvious‚Äù?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br></p><p>My subjective assessment:<br></p><p>&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label ‚Äúto‚Äù.<br>Obvious.<br></p><p>&gt; UnicodeScalar.init(Int) should be failable.<br>Obvious.<br></p><p>&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br></p><p>&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>Obvious, unless someone comes up with use cases during the review period.<br></p><p>&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>Debatable.<br></p><p>&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>Obvious.<br></p><p>&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>Obvious.<br></p><p>&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>A separate review.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  6, 2016 at 01:00:00pm</p></header><div class="content"><p>I‚Äôm quite interested in this point:<br></p><p>&gt; Figure out whether RangeReplaceableCollection.replaceRange should accept a Sequence as its argument, and if so implement it.<br></p><p>At the moment `replaceSubrange` takes a sequence, and lots of methods on RangeReplaceableCollection use that to perform their mutation operations. That means that Collections gets iterated item-by-item; for example, a String will get parsed out in to Characters and added individually to the existing string. In general, depending on which methods you use to mutate a RRC, you can expect wildly different performance characteristics. So it‚Äôs more important to fix than the name might suggest.<br></p><p>I had a PR open for this which added a Collection specialisation, but you said this could be handled in a more general way which allows for more optimised mutations. I‚Äôm curious how this would work; how does `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)` call a more optimised implementation if S also conforms to Collection, if not by adding a specialisation?<br></p><p><br>Karl<br></p><p>&gt; On 6 Jul 2016, at 07:50, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt; <br>&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the ‚Äúlow hanging fruit‚Äù list, are the changes all sufficiently &quot;obvious‚Äù?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br>&gt; <br>&gt; My subjective assessment:<br>&gt; <br>&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label ‚Äúto‚Äù.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br>&gt; <br>&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>&gt; Debatable.<br>&gt; <br>&gt;&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt; A separate review.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/031cc53d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jul 06 2016, Karl &lt;razielim-AT-gmail.com&gt; wrote:<br></p><p>&gt; I‚Äôm quite interested in this point:<br>&gt;<br>&gt;&gt; Figure out whether RangeReplaceableCollection.replaceRange should accept a Sequence as its argument, and if so implement it.<br>&gt;<br>&gt; At the moment `replaceSubrange` takes a sequence, <br></p><p>No, actually at the moment it takes a Collection.<br></p><p>&gt; and lots of methods on RangeReplaceableCollection use that to perform<br>&gt; their mutation operations. That means that Collections gets iterated<br>&gt; item-by-item; for example, a String will get parsed out in to<br>&gt; Characters and added individually to the existing string. <br></p><p>And a String is neither a Sequence nor a Collection.<br></p><p>&gt; In general, depending on which methods you use to mutate a RRC, you<br>&gt; can expect wildly different performance characteristics. So it‚Äôs more<br>&gt; important to fix than the name might suggest.<br></p><p>It depends on the RRC.  Some RRCs can be restructured at the front or<br>back more cheaply than in the middle.<br></p><p>&gt; I had a PR open for this which added a Collection specialisation, but<br>&gt; you said this could be handled in a more general way which allows for<br>&gt; more optimised mutations. I‚Äôm curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with:<br>&gt; S)` call a more optimised implementation if S also conforms to<br>&gt; Collection, if not by adding a specialisation?<br></p><p>I&#39;m sorry, I don&#39;t know what you&#39;re referring to here.  If you have<br>specific questions about a response to a PR, could you ask them in the<br>PR?  (It doesn&#39;t have to be open)<br></p><p>&gt;&gt; On 6 Jul 2016, at 07:50, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the ‚Äúlow<br>&gt;&gt;&gt; hanging fruit‚Äù list, are the changes all sufficiently &quot;obvious‚Äù?<br>&gt;&gt;&gt; If so, having one proposal tackle all of them in one sweep would be<br>&gt;&gt;&gt; preferable to reduce process overhead.<br>&gt;&gt; <br>&gt;&gt; My subjective assessment:<br>&gt;&gt; <br>&gt;&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label ‚Äúto‚Äù.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt;&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956<br>&gt;&gt; <br>&gt;&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for<br>&gt;&gt;&gt; it. If there are any, it should be renamed to unsafeAddress(of:) to<br>&gt;&gt;&gt; follow the guidelines.<br>&gt;&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;&gt; <br>&gt;&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an<br>&gt;&gt;&gt; extra bit of type safety inside of the closure passed to<br>&gt;&gt;&gt; ManagedBuffer.create().<br>&gt;&gt; Debatable.<br>&gt;&gt; <br>&gt;&gt;&gt; String.CharacterView.Iterator should be a custom type rather than<br>&gt;&gt;&gt; the default, to allow performance optimizations. Audit all other<br>&gt;&gt;&gt; collections for such opportunities.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt;&gt; Obvious.<br>&gt;&gt; <br>&gt;&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt;&gt; A separate review.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt; said this could be handled in a more general way which allows for more<br>&gt; optimised mutations. I‚Äôm curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt; not by adding a specialisation?<br></p><p>The RRC can call into S.someCustomizationPoint(), which will<br>initialize a region of memory in the most efficient way possible,<br>since it has complete knowledge about the memory layout of S.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt;&gt; said this could be handled in a more general way which allows for more<br>&gt;&gt; optimised mutations. I‚Äôm curious how this would work; how does<br>&gt;&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt;&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt;&gt; not by adding a specialisation?<br>&gt; <br>&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt; initialize a region of memory in the most efficient way possible,<br>&gt; since it has complete knowledge about the memory layout of S.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>Sorry, it‚Äôs been a little while since I looked at it (https://github.com/apple/swift/pull/3067 &lt;https://github.com/apple/swift/pull/3067&gt;). Actually, the issue is with the append() function specifically - it only has a Sequence specialisation. That‚Äôs the point; we were losing type information and not calling the more optimised replaceSubrange ‚Äî which is exactly the specialisation point you are talking about, Dmitry (I think everything funnels down in to replaceSubrange).<br></p><p>I must have misunderstood what you were saying at the time. I‚Äôll have to test, but I think it‚Äôs still an issue. I thought there was some more general work on RRC planned, so when I saw the bullet I thought maybe that was it.<br></p><p>@Dave:<br></p><p>I was trying to initialise a String.CharacterView - depending on whether I initialised it with another CharacterView, or created it empty and appended the other CharacterView, I would get huge performance differences, as the other CharacterView would get split up and a new Character created and appended for every character in the string (which had like 10,000 characters). It‚Äôs a subtle bug and a bit nasty when it hits you.<br></p><p>Karl<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/0919ce98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 6:15 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt; said this could be handled in a more general way which allows for more<br>&gt; optimised mutations. I‚Äôm curious how this would work; how does<br>&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt; not by adding a specialisation?<br>&gt;<br>&gt;<br>&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt; initialize a region of memory in the most efficient way possible,<br>&gt; since it has complete knowledge about the memory layout of S.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br>&gt; Sorry, it‚Äôs been a little while since I looked at it<br>&gt; (https://github.com/apple/swift/pull/3067). Actually, the issue is with the<br>&gt; append() function specifically - it only has a Sequence specialisation.<br>&gt; That‚Äôs the point; we were losing type information and not calling the more<br>&gt; optimised replaceSubrange ‚Äî which is exactly the specialisation point you<br>&gt; are talking about, Dmitry (I think everything funnels down in to<br>&gt; replaceSubrange).<br></p><p>I&#39;m talking about a different customization point.  RRC.append() calls<br>RRC.replaceSubrange(), which, in our thinking, would call<br>S._copyContents(initializing: RRC.getInnerPointer()).  _copyContents()<br>is the customization point on the argument that would initialize<br>memory with the contents of the sequence.<br></p><p>&gt; I must have misunderstood what you were saying at the time. I‚Äôll have to<br>&gt; test, but I think it‚Äôs still an issue. I thought there was some more general<br>&gt; work on RRC planned, so when I saw the bullet I thought maybe that was it.<br></p><p>I will be sending a draft proposal soon that will indirectly fix this<br>performance issue.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 03:15, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Jul 2016, at 02:06, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jul 6, 2016 at 4:21 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I had a PR open for this which added a Collection specialisation, but you<br>&gt;&gt;&gt; said this could be handled in a more general way which allows for more<br>&gt;&gt;&gt; optimised mutations. I‚Äôm curious how this would work; how does<br>&gt;&gt;&gt; `RangeReplaceableCollection.replaceSubrange&lt;S:Sequence&gt;(range:, with: S)`<br>&gt;&gt;&gt; call a more optimised implementation if S also conforms to Collection, if<br>&gt;&gt;&gt; not by adding a specialisation?<br>&gt;&gt; <br>&gt;&gt; The RRC can call into S.someCustomizationPoint(), which will<br>&gt;&gt; initialize a region of memory in the most efficient way possible,<br>&gt;&gt; since it has complete knowledge about the memory layout of S.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; <br>&gt; Sorry, it‚Äôs been a little while since I looked at it (https://github.com/apple/swift/pull/3067 &lt;https://github.com/apple/swift/pull/3067&gt;). Actually, the issue is with the append() function specifically - it only has a Sequence specialisation. That‚Äôs the point; we were losing type information and not calling the more optimised replaceSubrange ‚Äî which is exactly the specialisation point you are talking about, Dmitry (I think everything funnels down in to replaceSubrange).<br>&gt; <br>&gt; I must have misunderstood what you were saying at the time. I‚Äôll have to test, but I think it‚Äôs still an issue. I thought there was some more general work on RRC planned, so when I saw the bullet I thought maybe that was it.<br>&gt; <br>&gt; @Dave:<br>&gt; <br>&gt; I was trying to initialise a String.CharacterView - depending on whether I initialised it with another CharacterView, or created it empty and appended the other CharacterView, I would get huge performance differences, as the other CharacterView would get split up and a new Character created and appended for every character in the string (which had like 10,000 characters). It‚Äôs a subtle bug and a bit nasty when it hits you.<br>&gt; <br>&gt; Karl<br></p><p>Ah no, my memory‚Äôs coming back - it wasn‚Äôt the overhead in the standard library that was the biggest problem, as much as the 10,000 calls to replaceSubrange with a single element being appended. We had to do some additional processing, and it was just killer doing it so many times.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/509f2097/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  6, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 11:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 9:24 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jul 5, 2016, at 6:57 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dave, Max and I have compiled a list of open issues in the standard<br>&gt;&gt;&gt; library for which the resolutions could result non-additive API<br>&gt;&gt;&gt; changes.  Having a resolution (and an implementation of the<br>&gt;&gt;&gt; resolution!) for these issues is blocking API stability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/gribozavr/37e811f12b27c6365fc88e6f9645634d<br>&gt;&gt; <br>&gt;&gt; Thank you for collecting this Dmitri!  For the issues in the ‚Äúlow hanging fruit‚Äù list, are the changes all sufficiently &quot;obvious‚Äù?  If so, having one proposal tackle all of them in one sweep would be preferable to reduce process overhead.<br>&gt; <br>&gt; My subjective assessment:<br>&gt; <br>&gt;&gt; The global function withUnsafe[Mutable]Pointer(&amp;x) should have an argument label ‚Äúto‚Äù.<br>&gt; Obvious.<br>&gt;&gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt;&gt; Consider renaming or eliminating ManagedProtoBuffer.<br>&gt;&gt; The reason why ManagedProtoBuffer exists is to give the users an extra bit of type safety inside of the closure passed to ManagedBuffer.create().<br>&gt; Debatable.<br>&gt;&gt; withUnsafePointer shouldn&#39;t take its argument as inout.<br>&gt; Jordan has objections, see https://bugs.swift.org/browse/SR-1956 &lt;https://bugs.swift.org/browse/SR-1956&gt;<br></p><p>These batch together but I&#39;m thinking the latter three will have much more debate. (The first one can be a quick hit.) I&#39;ll get these topics started in a separate thread.<br></p><p>&gt;&gt; UnicodeScalar.init(Int) should be failable.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String.CharacterView.Iterator should be a custom type rather than the default, to allow performance optimizations. Audit all other collections for such opportunities.<br>&gt; Obvious.<br>&gt; <br>&gt;&gt; String(count:, repeatedValue:) and String.append() are ambiguous without an explicit cast to Character.<br>&gt; Obvious.<br></p><p>These string items  naturally batch together<br></p><p><br>&gt;&gt; Rename the ~LiteralConvertible protocols according to the resolution of the proposal currently under review.<br>&gt; A separate review.<br></p><p><br>I think Matthew Johnson has this under control<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/60cdeaf2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If<br>&gt; there are any, it should be renamed to unsafeAddress(of:) to follow the<br>&gt; guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;<br>&gt;<br>It&#39;s minor, but I use unsafeAddressOf regularly for writing `description`<br>methods:<br></p><p>    var description: String {<br>        return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info<br>here... }&quot;<br>    }<br></p><p>I guess this would be covered by some generalized solution for format<br>specifiers in string interpolations, but I gather that won&#39;t happen for<br>quite a while...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/bd85db89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>I‚Äôve also seen unsafeAddressOf(_:) used when interfacing with C function pointers when the lifetime of an object is guaranteed. Many C APIs vend an API like:<br></p><p>void perform_action(void (*callback)(void *data), void *initial_data);<br></p><p>For which it is expected to use unsafeAddressOf on a class instance, like:<br></p><p>perform_action({ data in<br>  let _self = unsafeBitCast(data, to: MyClass.self)<br>  _self.foo()<br>}, data: unsafeAddressOf(self))<br></p><p>It‚Äôs unsafe and error-prone, sure, but that‚Äôs why we have `unsafe` in the name üòÖ ‚Äî I‚Äôve had to use this to interface with libclang.<br></p><p>(For an existing example of this, see SwiftGtk: https://github.com/TomasLinhart/SwiftGtk/blob/master/Sources/Application.swift &lt;https://github.com/TomasLinhart/SwiftGtk/blob/master/Sources/Application.swift&gt;)<br></p><p>‚Äî Harlan<br></p><p>&gt; On Jul 6, 2016, at 11:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If there are any, it should be renamed to unsafeAddress(of:) to follow the guidelines.<br>&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt; <br>&gt; <br>&gt; It&#39;s minor, but I use unsafeAddressOf regularly for writing `description` methods:<br>&gt; <br>&gt;     var description: String {<br>&gt;         return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info here... }&quot;<br>&gt;     }<br>&gt; <br>&gt; I guess this would be covered by some generalized solution for format specifiers in string interpolations, but I gather that won&#39;t happen for quite a while...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/816b3670/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 11:30 AM, Harlan Haskins &lt;harlan at harlanhaskins.com&gt;<br>wrote:<br></p><p>&gt; I‚Äôve also seen unsafeAddressOf(_:) used when interfacing with C function<br>&gt; pointers when the lifetime of an object is guaranteed. Many C APIs vend an<br>&gt; API like:<br>&gt;<br>&gt; void perform_action(void (*callback)(void *data), void *initial_data);<br>&gt;<br>&gt; For which it is expected to use unsafeAddressOf on a class instance, like:<br>&gt;<br>&gt; perform_action({ data in<br>&gt;   let _self = unsafeBitCast(data, to: MyClass.self)<br>&gt;   _self.foo()<br>&gt; }, data: unsafeAddressOf(self))<br>&gt;<br>&gt; It‚Äôs unsafe and error-prone, sure, but that‚Äôs why we have `unsafe` in the<br>&gt; name üòÖ ‚Äî I‚Äôve had to use this to interface with libclang.<br>&gt;<br></p><p>Hi Harlan,<br></p><p>For this case, Unmanaged is the recommended API.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/089f3e1d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Open Issues Affecting Standard Library API Stability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Jul 06 2016, Jacob Bandes-Storch &lt;jtbandes-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Tue, Jul 5, 2016 at 10:50 PM, Dmitri Gribenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Remove unsafeAddressOf. We are not aware of any real usecases for it. If<br>&gt;&gt; there are any, it should be renamed to unsafeAddress(of:) to follow the<br>&gt;&gt; guidelines.<br>&gt;&gt; Obvious, unless someone comes up with use cases during the review period.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; It&#39;s minor, but I use unsafeAddressOf regularly for writing `description`<br>&gt; methods:<br>&gt;<br>&gt;     var description: String {<br>&gt;         return &quot;&lt;\(self.dynamicType): \(unsafeAddressOf(self))&gt;{ more info<br>&gt; here... }&quot;<br>&gt;     }<br></p><p>You can do that, but there&#39;s no guarantee that the address is<br>meaningful.  The compiler is free to copy self into a writeback buffer<br>whose address gets printed.<br></p><p>&gt; I guess this would be covered by some generalized solution for format<br>&gt; specifiers in string interpolations, but I gather that won&#39;t happen for<br>&gt; quite a while...<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
