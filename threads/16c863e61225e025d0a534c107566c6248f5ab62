<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 30, 2016 at 11:00:00pm</p></header><div class="content"><p>Currently there are three types of operator: prefix, infix and postfix <br>and most of the Swift operations can be defined using these and <br>implemented for additional types and they cover most use cases but there <br>are features in the Swift language which cannot be replicated and <br>customised with these.<br></p><p>In particular there is the optional chaining use of `?` for which I can <br>see no way of producing customised versions of or adapting to types <br>other than optionals (e.g. custom Either types or other monadic types).<br></p><p>I’m not sure about the feasibility of this change or what knockon <br>effects might be. This is meant as exploratory suggestion that may not <br>reach proposal stage.<br></p><p>Would be interested to know:<br>1) If this is feasible.<br>2) If it is interesting to people.<br>3) What if anything should be possible for l-values (optional chaining <br>works on them but what should be possible.<br>4) Any other good alternatives.<br></p><p>I picture that the chaining operator function would be called with the <br>left hand side value and could be required to return a value of a type <br>such as this ChainValueResult:<br></p><p>enum ChainValueResult&lt;A,C,D&gt; {<br>   case continue(A, C-&gt;D),<br>   case stop(D)<br>}<br></p><p>The logic then applied to this enum would be in case of continue to <br>apply the C-&gt;D function to the result of continuing the chain which is <br>applied to the A value. In the case of stop it is to simply return the <br>value of type D.<br></p><p>I have used this enum in the draft code below. Please note that the code <br>below doesn&#39;t compile and that if really being used the inference system <br>would need to account for the return type of the ongoing chain.<br></p><p>Use case 1 - Custom optional chaining behaviour<br></p><p>The particular thing that I would like use this for is to make a custom <br>asserting variant of the optional chaining operator. I already do this <br>with nil coalescing (it is currently the only custom operator in my <br>code) but a shorthand for this would be good:<br></p><p>assert(foo != nil)<br>foo?.bar()<br></p><p>I would only want to do:<br></p><p>foo±.bar()<br></p><p>func ± &lt;A, C&gt;(lhs: A?)-&gt;ChainValueResult&lt;A, C-&gt;C? ,C?&gt; {<br>	if let lhs = lhs {<br>		return .continue(lhs, { $0 })<br>  	} else {<br>		assertionFailure()<br>	        return .stop(nil)<br>	}<br>}<br></p><p>Use case 2 - Chaining on custom types<br></p><p>And this especially may not be feasible and I may be out of my depth <br>describing the requirement but it feels like a more general case so at <br>least worth airing):<br></p><p>It would be good for code like the following to be possible (hopefully <br>with a little more type inference).<br></p><p>let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br></p><p>Now the user’s definition of the operator would probably have to look <br>something like this:<br></p><p>func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C, Either&lt;C,B&gt;&gt;   {<br>   	switch lhs {<br>   	case .Left(let a):<br>     		return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>  	 case .Right(let b):<br>     		return .stop( Either&lt;C, B&gt;(.Right(b))<br>	}<br>}<br></p><p>I couldn&#39;t find any significant discussion of optional chaining in the <br>mailing list so far.<br></p><p>Joseph<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 12:00:00pm</p></header><div class="content"><p>What is wrong with flatMap returning an Optional? Like Scala does.<br></p><p>On Sunday, 31 January 2016, Joseph Lord via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Currently there are three types of operator: prefix, infix and postfix and<br>&gt; most of the Swift operations can be defined using these and implemented for<br>&gt; additional types and they cover most use cases but there are features in<br>&gt; the Swift language which cannot be replicated and customised with these.<br>&gt;<br>&gt; In particular there is the optional chaining use of `?` for which I can<br>&gt; see no way of producing customised versions of or adapting to types other<br>&gt; than optionals (e.g. custom Either types or other monadic types).<br>&gt;<br>&gt; I’m not sure about the feasibility of this change or what knockon effects<br>&gt; might be. This is meant as exploratory suggestion that may not reach<br>&gt; proposal stage.<br>&gt;<br>&gt; Would be interested to know:<br>&gt; 1) If this is feasible.<br>&gt; 2) If it is interesting to people.<br>&gt; 3) What if anything should be possible for l-values (optional chaining<br>&gt; works on them but what should be possible.<br>&gt; 4) Any other good alternatives.<br>&gt;<br>&gt; I picture that the chaining operator function would be called with the<br>&gt; left hand side value and could be required to return a value of a type such<br>&gt; as this ChainValueResult:<br>&gt;<br>&gt; enum ChainValueResult&lt;A,C,D&gt; {<br>&gt;   case continue(A, C-&gt;D),<br>&gt;   case stop(D)<br>&gt; }<br>&gt;<br>&gt; The logic then applied to this enum would be in case of continue to apply<br>&gt; the C-&gt;D function to the result of continuing the chain which is applied to<br>&gt; the A value. In the case of stop it is to simply return the value of type D.<br>&gt;<br>&gt; I have used this enum in the draft code below. Please note that the code<br>&gt; below doesn&#39;t compile and that if really being used the inference system<br>&gt; would need to account for the return type of the ongoing chain.<br>&gt;<br>&gt; Use case 1 - Custom optional chaining behaviour<br>&gt;<br>&gt; The particular thing that I would like use this for is to make a custom<br>&gt; asserting variant of the optional chaining operator. I already do this with<br>&gt; nil coalescing (it is currently the only custom operator in my code) but a<br>&gt; shorthand for this would be good:<br>&gt;<br>&gt; assert(foo != nil)<br>&gt; foo?.bar()<br>&gt;<br>&gt; I would only want to do:<br>&gt;<br>&gt; foo±.bar()<br>&gt;<br>&gt; func ± &lt;A, C&gt;(lhs: A?)-&gt;ChainValueResult&lt;A, C-&gt;C? ,C?&gt; {<br>&gt;         if let lhs = lhs {<br>&gt;                 return .continue(lhs, { $0 })<br>&gt;         } else {<br>&gt;                 assertionFailure()<br>&gt;                 return .stop(nil)<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; Use case 2 - Chaining on custom types<br>&gt;<br>&gt; And this especially may not be feasible and I may be out of my depth<br>&gt; describing the requirement but it feels like a more general case so at<br>&gt; least worth airing):<br>&gt;<br>&gt; It would be good for code like the following to be possible (hopefully<br>&gt; with a little more type inference).<br>&gt;<br>&gt; let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt;<br>&gt; Now the user’s definition of the operator would probably have to look<br>&gt; something like this:<br>&gt;<br>&gt; func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C, Either&lt;C,B&gt;&gt;   {<br>&gt;         switch lhs {<br>&gt;         case .Left(let a):<br>&gt;                 return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt;          case .Right(let b):<br>&gt;                 return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; I couldn&#39;t find any significant discussion of optional chaining in the<br>&gt; mailing list so far.<br>&gt;<br>&gt; Joseph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/5ccd34bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 31, 2016 at 02:00:00am</p></header><div class="content"><p>On 31/01/2016 01:14, Howard Lovatt via swift-evolution wrote:<br> &gt; What is wrong with flatMap returning an Optional? Like Scala does.<br> &gt;<br></p><p>Using map or a function taking a closure is less clear to read than an <br>chaining mechanism.<br></p><p>For the first usecase (which is really the most trivial case of optional <br>chaining:<br></p><p> &gt;     assert(foo != nil)<br> &gt;     foo?.bar()<br> &gt;<br> &gt;     I would only want to do:<br> &gt;<br> &gt;     foo±.bar()<br> &gt;<br></p><p>_ = foo.aMap { $0.bar() }<br></p><p>If you can image a multiple step chain it could clearly get more <br>complicated.<br></p><p>I don&#39;t think that there is a way to avoid the closures within current <br>Swift and any map/flatMap based approach.<br></p><p>I&#39;m not familiar with Scala so I may have misunderstood exactly what you <br>meant.<br></p><p>Joseph<br></p><p><br>&gt; On Sunday, 31 January 2016, Joseph Lord via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Currently there are three types of operator: prefix, infix and<br>&gt;     postfix and most of the Swift operations can be defined using these<br>&gt;     and implemented for additional types and they cover most use cases<br>&gt;     but there are features in the Swift language which cannot be<br>&gt;     replicated and customised with these.<br>&gt;<br>&gt;     In particular there is the optional chaining use of `?` for which I<br>&gt;     can see no way of producing customised versions of or adapting to<br>&gt;     types other than optionals (e.g. custom Either types or other<br>&gt;     monadic types).<br>&gt;<br>&gt;     I’m not sure about the feasibility of this change or what knockon<br>&gt;     effects might be. This is meant as exploratory suggestion that may<br>&gt;     not reach proposal stage.<br>&gt;<br>&gt;     Would be interested to know:<br>&gt;     1) If this is feasible.<br>&gt;     2) If it is interesting to people.<br>&gt;     3) What if anything should be possible for l-values (optional<br>&gt;     chaining works on them but what should be possible.<br>&gt;     4) Any other good alternatives.<br>&gt;<br>&gt;     I picture that the chaining operator function would be called with<br>&gt;     the left hand side value and could be required to return a value of<br>&gt;     a type such as this ChainValueResult:<br>&gt;<br>&gt;     enum ChainValueResult&lt;A,C,D&gt; {<br>&gt;        case continue(A, C-&gt;D),<br>&gt;        case stop(D)<br>&gt;     }<br>&gt;<br>&gt;     The logic then applied to this enum would be in case of continue to<br>&gt;     apply the C-&gt;D function to the result of continuing the chain which<br>&gt;     is applied to the A value. In the case of stop it is to simply<br>&gt;     return the value of type D.<br>&gt;<br>&gt;     I have used this enum in the draft code below. Please note that the<br>&gt;     code below doesn&#39;t compile and that if really being used the<br>&gt;     inference system would need to account for the return type of the<br>&gt;     ongoing chain.<br>&gt;<br>&gt;     Use case 1 - Custom optional chaining behaviour<br>&gt;<br>&gt;     The particular thing that I would like use this for is to make a<br>&gt;     custom asserting variant of the optional chaining operator. I<br>&gt;     already do this with nil coalescing (it is currently the only custom<br>&gt;     operator in my code) but a shorthand for this would be good:<br>&gt;<br>&gt;     assert(foo != nil)<br>&gt;     foo?.bar()<br>&gt;<br>&gt;     I would only want to do:<br>&gt;<br>&gt;     foo±.bar()<br>&gt;<br>&gt;     func ± &lt;A, C&gt;(lhs: A?)-&gt;ChainValueResult&lt;A, C-&gt;C? ,C?&gt; {<br>&gt;              if let lhs = lhs {<br>&gt;                      return .continue(lhs, { $0 })<br>&gt;              } else {<br>&gt;                      assertionFailure()<br>&gt;                      return .stop(nil)<br>&gt;              }<br>&gt;     }<br>&gt;<br>&gt;     Use case 2 - Chaining on custom types<br>&gt;<br>&gt;     And this especially may not be feasible and I may be out of my depth<br>&gt;     describing the requirement but it feels like a more general case so<br>&gt;     at least worth airing):<br>&gt;<br>&gt;     It would be good for code like the following to be possible<br>&gt;     (hopefully with a little more type inference).<br>&gt;<br>&gt;     let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt;<br>&gt;     Now the user’s definition of the operator would probably have to<br>&gt;     look something like this:<br>&gt;<br>&gt;     func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C,<br>&gt;     Either&lt;C,B&gt;&gt;   {<br>&gt;              switch lhs {<br>&gt;              case .Left(let a):<br>&gt;                      return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt;               case .Right(let b):<br>&gt;                      return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt;              }<br>&gt;     }<br>&gt;<br>&gt;     I couldn&#39;t find any significant discussion of optional chaining in<br>&gt;     the mailing list so far.<br>&gt;<br>&gt;     Joseph<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;    -- Howard.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>Human Friendly Ltd.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 31, 2016 at 09:00:00am</p></header><div class="content"><p>My interest is in expressions more than functions (i.e. n? + 5)…. but <br></p><p>IF... Swift implemented a protocol of maybe MonadOps that indicated that a function/option supported <br>monadic-like operations (instead of ad-hoc separate implementations) which would then be used  <br>to implement syntactic for-comprehension sugar for maps and flatMaps it would make the chaining <br>of options much more readable without getting overly fancy.  <br></p><p>i.e.<br></p><p>= for {<br>   o1 &lt;- optional1<br>   o2 &lt;- optional2<br>   o3 &lt;- optional3<br>   …<br>} yield { foo.bar(o1, o2, o3) }<br></p><p><br></p><p>&gt; On 2016-01-31, at 9:23:36, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 31/01/2016 01:14, Howard Lovatt via swift-evolution wrote:<br>&gt; &gt; What is wrong with flatMap returning an Optional? Like Scala does.<br>&gt; &gt;<br>&gt; <br>&gt; Using map or a function taking a closure is less clear to read than an chaining mechanism.<br>&gt; <br>&gt; For the first usecase (which is really the most trivial case of optional chaining:<br>&gt; <br>&gt; &gt;     assert(foo != nil)<br>&gt; &gt;     foo?.bar()<br>&gt; &gt;<br>&gt; &gt;     I would only want to do:<br>&gt; &gt;<br>&gt; &gt;     foo±.bar()<br>&gt; &gt;<br>&gt; <br>&gt; _ = foo.aMap { $0.bar() }<br>&gt; <br>&gt; If you can image a multiple step chain it could clearly get more complicated.<br>&gt; <br>&gt; I don&#39;t think that there is a way to avoid the closures within current Swift and any map/flatMap based approach.<br>&gt; <br>&gt; I&#39;m not familiar with Scala so I may have misunderstood exactly what you meant.<br>&gt; <br>&gt; Joseph<br>&gt; <br>&gt; <br>&gt;&gt; On Sunday, 31 January 2016, Joseph Lord via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    Currently there are three types of operator: prefix, infix and<br>&gt;&gt;    postfix and most of the Swift operations can be defined using these<br>&gt;&gt;    and implemented for additional types and they cover most use cases<br>&gt;&gt;    but there are features in the Swift language which cannot be<br>&gt;&gt;    replicated and customised with these.<br>&gt;&gt; <br>&gt;&gt;    In particular there is the optional chaining use of `?` for which I<br>&gt;&gt;    can see no way of producing customised versions of or adapting to<br>&gt;&gt;    types other than optionals (e.g. custom Either types or other<br>&gt;&gt;    monadic types).<br>&gt;&gt; <br>&gt;&gt;    I’m not sure about the feasibility of this change or what knockon<br>&gt;&gt;    effects might be. This is meant as exploratory suggestion that may<br>&gt;&gt;    not reach proposal stage.<br>&gt;&gt; <br>&gt;&gt;    Would be interested to know:<br>&gt;&gt;    1) If this is feasible.<br>&gt;&gt;    2) If it is interesting to people.<br>&gt;&gt;    3) What if anything should be possible for l-values (optional<br>&gt;&gt;    chaining works on them but what should be possible.<br>&gt;&gt;    4) Any other good alternatives.<br>&gt;&gt; <br>&gt;&gt;    I picture that the chaining operator function would be called with<br>&gt;&gt;    the left hand side value and could be required to return a value of<br>&gt;&gt;    a type such as this ChainValueResult:<br>&gt;&gt; <br>&gt;&gt;    enum ChainValueResult&lt;A,C,D&gt; {<br>&gt;&gt;       case continue(A, C-&gt;D),<br>&gt;&gt;       case stop(D)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    The logic then applied to this enum would be in case of continue to<br>&gt;&gt;    apply the C-&gt;D function to the result of continuing the chain which<br>&gt;&gt;    is applied to the A value. In the case of stop it is to simply<br>&gt;&gt;    return the value of type D.<br>&gt;&gt; <br>&gt;&gt;    I have used this enum in the draft code below. Please note that the<br>&gt;&gt;    code below doesn&#39;t compile and that if really being used the<br>&gt;&gt;    inference system would need to account for the return type of the<br>&gt;&gt;    ongoing chain.<br>&gt;&gt; <br>&gt;&gt;    Use case 1 - Custom optional chaining behaviour<br>&gt;&gt; <br>&gt;&gt;    The particular thing that I would like use this for is to make a<br>&gt;&gt;    custom asserting variant of the optional chaining operator. I<br>&gt;&gt;    already do this with nil coalescing (it is currently the only custom<br>&gt;&gt;    operator in my code) but a shorthand for this would be good:<br>&gt;&gt; <br>&gt;&gt;    assert(foo != nil)<br>&gt;&gt;    foo?.bar()<br>&gt;&gt; <br>&gt;&gt;    I would only want to do:<br>&gt;&gt; <br>&gt;&gt;    foo±.bar()<br>&gt;&gt; <br>&gt;&gt;    func ± &lt;A, C&gt;(lhs: A?)-&gt;ChainValueResult&lt;A, C-&gt;C? ,C?&gt; {<br>&gt;&gt;             if let lhs = lhs {<br>&gt;&gt;                     return .continue(lhs, { $0 })<br>&gt;&gt;             } else {<br>&gt;&gt;                     assertionFailure()<br>&gt;&gt;                     return .stop(nil)<br>&gt;&gt;             }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    Use case 2 - Chaining on custom types<br>&gt;&gt; <br>&gt;&gt;    And this especially may not be feasible and I may be out of my depth<br>&gt;&gt;    describing the requirement but it feels like a more general case so<br>&gt;&gt;    at least worth airing):<br>&gt;&gt; <br>&gt;&gt;    It would be good for code like the following to be possible<br>&gt;&gt;    (hopefully with a little more type inference).<br>&gt;&gt; <br>&gt;&gt;    let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt;&gt; <br>&gt;&gt;    Now the user’s definition of the operator would probably have to<br>&gt;&gt;    look something like this:<br>&gt;&gt; <br>&gt;&gt;    func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C,<br>&gt;&gt;    Either&lt;C,B&gt;&gt;   {<br>&gt;&gt;             switch lhs {<br>&gt;&gt;             case .Left(let a):<br>&gt;&gt;                     return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt;&gt;              case .Right(let b):<br>&gt;&gt;                     return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt;&gt;             }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    I couldn&#39;t find any significant discussion of optional chaining in<br>&gt;&gt;    the mailing list so far.<br>&gt;&gt; <br>&gt;&gt;    Joseph<br>&gt;&gt;    _______________________________________________<br>&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Human Friendly Ltd.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>I am probably completely mis-understanding what you want. Your 1st example,<br>isn&#39;t it equivalent to:<br></p><p>    foo!.bar()<br></p><p>On Sunday, 31 January 2016, Joseph Lord via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 31/01/2016 01:14, Howard Lovatt via swift-evolution wrote:<br>&gt; &gt; What is wrong with flatMap returning an Optional? Like Scala does.<br>&gt; &gt;<br>&gt;<br>&gt; Using map or a function taking a closure is less clear to read than an<br>&gt; chaining mechanism.<br>&gt;<br>&gt; For the first usecase (which is really the most trivial case of optional<br>&gt; chaining:<br>&gt;<br>&gt; &gt;     assert(foo != nil)<br>&gt; &gt;     foo?.bar()<br>&gt; &gt;<br>&gt; &gt;     I would only want to do:<br>&gt; &gt;<br>&gt; &gt;     foo±.bar()<br>&gt; &gt;<br>&gt;<br>&gt; _ = foo.aMap { $0.bar() }<br>&gt;<br>&gt; If you can image a multiple step chain it could clearly get more<br>&gt; complicated.<br>&gt;<br>&gt; I don&#39;t think that there is a way to avoid the closures within current<br>&gt; Swift and any map/flatMap based approach.<br>&gt;<br>&gt; I&#39;m not familiar with Scala so I may have misunderstood exactly what you<br>&gt; meant.<br>&gt;<br>&gt; Joseph<br>&gt;<br>&gt;<br>&gt; On Sunday, 31 January 2016, Joseph Lord via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Currently there are three types of operator: prefix, infix and<br>&gt;&gt;     postfix and most of the Swift operations can be defined using these<br>&gt;&gt;     and implemented for additional types and they cover most use cases<br>&gt;&gt;     but there are features in the Swift language which cannot be<br>&gt;&gt;     replicated and customised with these.<br>&gt;&gt;<br>&gt;&gt;     In particular there is the optional chaining use of `?` for which I<br>&gt;&gt;     can see no way of producing customised versions of or adapting to<br>&gt;&gt;     types other than optionals (e.g. custom Either types or other<br>&gt;&gt;     monadic types).<br>&gt;&gt;<br>&gt;&gt;     I’m not sure about the feasibility of this change or what knockon<br>&gt;&gt;     effects might be. This is meant as exploratory suggestion that may<br>&gt;&gt;     not reach proposal stage.<br>&gt;&gt;<br>&gt;&gt;     Would be interested to know:<br>&gt;&gt;     1) If this is feasible.<br>&gt;&gt;     2) If it is interesting to people.<br>&gt;&gt;     3) What if anything should be possible for l-values (optional<br>&gt;&gt;     chaining works on them but what should be possible.<br>&gt;&gt;     4) Any other good alternatives.<br>&gt;&gt;<br>&gt;&gt;     I picture that the chaining operator function would be called with<br>&gt;&gt;     the left hand side value and could be required to return a value of<br>&gt;&gt;     a type such as this ChainValueResult:<br>&gt;&gt;<br>&gt;&gt;     enum ChainValueResult&lt;A,C,D&gt; {<br>&gt;&gt;        case continue(A, C-&gt;D),<br>&gt;&gt;        case stop(D)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     The logic then applied to this enum would be in case of continue to<br>&gt;&gt;     apply the C-&gt;D function to the result of continuing the chain which<br>&gt;&gt;     is applied to the A value. In the case of stop it is to simply<br>&gt;&gt;     return the value of type D.<br>&gt;&gt;<br>&gt;&gt;     I have used this enum in the draft code below. Please note that the<br>&gt;&gt;     code below doesn&#39;t compile and that if really being used the<br>&gt;&gt;     inference system would need to account for the return type of the<br>&gt;&gt;     ongoing chain.<br>&gt;&gt;<br>&gt;&gt;     Use case 1 - Custom optional chaining behaviour<br>&gt;&gt;<br>&gt;&gt;     The particular thing that I would like use this for is to make a<br>&gt;&gt;     custom asserting variant of the optional chaining operator. I<br>&gt;&gt;     already do this with nil coalescing (it is currently the only custom<br>&gt;&gt;     operator in my code) but a shorthand for this would be good:<br>&gt;&gt;<br>&gt;&gt;     assert(foo != nil)<br>&gt;&gt;     foo?.bar()<br>&gt;&gt;<br>&gt;&gt;     I would only want to do:<br>&gt;&gt;<br>&gt;&gt;     foo±.bar()<br>&gt;&gt;<br>&gt;&gt;     func ± &lt;A, C&gt;(lhs: A?)-&gt;ChainValueResult&lt;A, C-&gt;C? ,C?&gt; {<br>&gt;&gt;              if let lhs = lhs {<br>&gt;&gt;                      return .continue(lhs, { $0 })<br>&gt;&gt;              } else {<br>&gt;&gt;                      assertionFailure()<br>&gt;&gt;                      return .stop(nil)<br>&gt;&gt;              }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     Use case 2 - Chaining on custom types<br>&gt;&gt;<br>&gt;&gt;     And this especially may not be feasible and I may be out of my depth<br>&gt;&gt;     describing the requirement but it feels like a more general case so<br>&gt;&gt;     at least worth airing):<br>&gt;&gt;<br>&gt;&gt;     It would be good for code like the following to be possible<br>&gt;&gt;     (hopefully with a little more type inference).<br>&gt;&gt;<br>&gt;&gt;     let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt;&gt;<br>&gt;&gt;     Now the user’s definition of the operator would probably have to<br>&gt;&gt;     look something like this:<br>&gt;&gt;<br>&gt;&gt;     func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C,<br>&gt;&gt;     Either&lt;C,B&gt;&gt;   {<br>&gt;&gt;              switch lhs {<br>&gt;&gt;              case .Left(let a):<br>&gt;&gt;                      return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt;&gt;               case .Right(let b):<br>&gt;&gt;                      return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt;&gt;              }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     I couldn&#39;t find any significant discussion of optional chaining in<br>&gt;&gt;     the mailing list so far.<br>&gt;&gt;<br>&gt;&gt;     Joseph<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;    -- Howard.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Human Friendly Ltd.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/65db46a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>January 31, 2016 at 10:00:00am</p></header><div class="content"><p>On 31/01/2016 02:51, Howard Lovatt via swift-evolution wrote:<br>&gt; I am probably completely mis-understanding what you want. Your 1st<br>&gt; example, isn&#39;t it equivalent to:<br>&gt;<br>&gt;      foo!.bar()<br>&gt;<br></p><p>I probably wasn&#39;t very clear. The 1st example is equivalent to the force <br>unwrap but only in debug builds. In release builds it becomes equivalent to:<br></p><p>foo?.bar()<br></p><p>This gives the strict checking in development and allows you to check <br>that assumptions of non-nilness are correct but still provides compiler <br>proven nil safe handling in production.<br></p><p>I already use a similar approach for nil-coalescing in places where that <br>is a suitable option: <br>http://blog.human-friendly.com/theanswer-equals-maybeanswer-or-a-good-alternative<br></p><p>Joseph<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Use case 2 - Chaining on custom types<br>&gt; <br>&gt; And this especially may not be feasible and I may be out of my depth describing the requirement but it feels like a more general case so at least worth airing):<br></p><p>I’m not certain I understand the problem you’re looking to solve here, but I think it would be great (though probably very low priority) to open up the functionality of the postfix optional chaining operator to other types.  This could allow its monadic binding (aka railroad short circuiting) behavior to be extended to other types like Result, a left-biased-either, or an arbitrary type defined by the user.  A natural approach would be to capture this behavior in an “chainable” protocol of some sort.<br></p><p>This is low priority because I don’t know a lot of killer applications of it, I’m motivated by my ivory tower desire to push compiler magic into the standard library.  It bugs me that optional has sugar and other behavior that other types can’t participate in.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; It would be good for code like the following to be possible (hopefully with a little more type inference).<br>&gt; <br>&gt; let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt; <br>&gt; Now the user’s definition of the operator would probably have to look something like this:<br>&gt; <br>&gt; func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C, Either&lt;C,B&gt;&gt;   {<br>&gt;  	switch lhs {<br>&gt;  	case .Left(let a):<br>&gt;    		return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt; 	 case .Right(let b):<br>&gt;    		return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; I couldn&#39;t find any significant discussion of optional chaining in the mailing list so far.<br>&gt; <br>&gt; Joseph<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>January 31, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sat, Jan 30, 2016 at 9:20 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Use case 2 - Chaining on custom types<br>&gt; &gt;<br>&gt; &gt; And this especially may not be feasible and I may be out of my depth<br>&gt; describing the requirement but it feels like a more general case so at<br>&gt; least worth airing):<br>&gt;<br>&gt; I’m not certain I understand the problem you’re looking to solve here, but<br>&gt; I think it would be great (though probably very low priority) to open up<br>&gt; the functionality of the postfix optional chaining operator to other<br>&gt; types.  This could allow its monadic binding (aka railroad short<br>&gt; circuiting) behavior to be extended to other types like Result, a<br>&gt; left-biased-either, or an arbitrary type defined by the user.  A natural<br>&gt; approach would be to capture this behavior in an “chainable” protocol of<br>&gt; some sort.<br>&gt;<br>&gt;<br>BTW, chainable monadic behavior is already available via .method() calls on<br>an object that returns Self and maintains some internal state.  This is<br>widely used across a number of other languages, eg.<br></p><p>1. JQuery, where the state is a selection of DOM elements and each method<br>call is an operation on the DOM.<br>2. Builder pattern in Java, where the Builder holds the internal state of<br>the object and each method call validates that it&#39;s a legal transformation.<br>3. SwiftyJSON, where the state is whether every key along the chain exists<br>and has the proper type, and then .stringValue/.intValue/.boolValue returns<br>the final result or nil if there was an error at any point.<br>4. Django&#39;s ORM, where the state is the current clauses of the SQL query,<br>each method adds a clause, and then subscripting/iterating/etc. force<br>query-building and execution of the query.<br>5. BeautifulSoup, where the state is your current position in the DOM tree<br>and selection of nodes.<br></p><p>Swift is already a huge leap forward from Objective-C in this regard,<br>because the latter&#39;s syntax didn&#39;t really allow method chaining.<br></p><p>What optional chaining gives us is the ability to invoke an arbitrary<br>method of the &quot;contained&quot; object, without needing to know what type it is.<br>So for example, foo?.bar()?.baz() will invoke .bar() on Optional&lt;Foo&gt;<br>without Optional having to explicitly say that it supports a method bar().<br>It just forwards all operations on, providing nil if the Optional contained<br>nil.  Sorta like a type-safe version of #doesNotUnderstand in SmallTalk.<br></p><p>I see this as being much more related to generics than protocols, though I<br>guess you&#39;d need a protocol to specify the behavior of ? in terms of the<br>container type.  Use-cases I can think of:<br></p><p>1. Implicit mapping over collections, like JQuery.  myArray?.foo() would<br>invoke foo() on every object contained in myArray.<br>2. RPCs.  You could imagine RPCStub&lt;RemoteObject&gt; be an object that wraps<br>RemoteObject, and then stub?.foo(1, &quot;two&quot;) marshals the parameters, passes<br>them along to the remove server, invokes them, and returns them, maybe<br>wrapped in a Promise.  Assuming the remote object is written in Swift too,<br>you&#39;d get a lot more type-safety than stub.call(&quot;foo&quot;, 1, &quot;two&quot;).<br>3. Logging/tracing/performance monitoring, where you might want to record<br>the fact that the call was made without worrying about what call it is.<br>4. Type erasure.  Right now, if Foo is a protocol with an associated type,<br>you can&#39;t have an array of Foo where each element might be a different<br>concrete type adopting Foo.  The typical workaround is a struct AnyFoo<br>which wraps the concrete instance, adopts Foo, and forwards all calls on to<br>the wrapped instance.  A chaining operator would let you avoid having to<br>explicitly adopt the protocol and write all the forwarding message calls.<br>5. Anything that you&#39;d use ES6 proxy objects for.  I had a use-case for<br>these a couple months ago that involved tracking everything that was stored<br>in a container so the container could be automatically persisted.<br>6. CoreData could possibly benefit from this - imagine being able to define<br>CoreData objects as ordinary Swift structs, intercept all property setting,<br>and use this to build the appropriate ManagedObjectModels.   A lot of the<br>current model-editing GUI in XCode might be able to be replaced.<br></p><p>Now that I&#39;ve listed them out, it&#39;s basically aspect-oriented programming,<br>which means it&#39;d have the same use-cases as AOP and also the same pitfalls.<br></p><p><br>&gt; This is low priority because I don’t know a lot of killer applications of<br>&gt; it, I’m motivated by my ivory tower desire to push compiler magic into the<br>&gt; standard library.  It bugs me that optional has sugar and other behavior<br>&gt; that other types can’t participate in.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &gt;<br>&gt; &gt; It would be good for code like the following to be possible (hopefully<br>&gt; with a little more type inference).<br>&gt; &gt;<br>&gt; &gt; let c:Either&lt;Int, Error&gt; = Either&lt;String, Error&gt;(.Left(“boo&quot;))^^.count<br>&gt; &gt;<br>&gt; &gt; Now the user’s definition of the operator would probably have to look<br>&gt; something like this:<br>&gt; &gt;<br>&gt; &gt; func ^^&lt;A,B, C&gt;(lhs: Either&lt;A,B&gt;)-&gt;(ChainValueResult&lt;A, C, Either&lt;C,B&gt;&gt;<br>&gt;  {<br>&gt; &gt;       switch lhs {<br>&gt; &gt;       case .Left(let a):<br>&gt; &gt;               return .continue(a, { Either&lt;C,B&gt;(.Left($0) })<br>&gt; &gt;        case .Right(let b):<br>&gt; &gt;               return .stop( Either&lt;C, B&gt;(.Right(b))<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I couldn&#39;t find any significant discussion of optional chaining in the<br>&gt; mailing list so far.<br>&gt; &gt;<br>&gt; &gt; Joseph<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/06943dc5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 9:20 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Use case 2 - Chaining on custom types<br>&gt;&gt; <br>&gt;&gt; And this especially may not be feasible and I may be out of my depth describing the requirement but it feels like a more general case so at least worth airing):<br>&gt; <br>&gt; I’m not certain I understand the problem you’re looking to solve here, but I think it would be great (though probably very low priority) to open up the functionality of the postfix optional chaining operator to other types.  This could allow its monadic binding (aka railroad short circuiting) behavior to be extended to other types like Result, a left-biased-either, or an arbitrary type defined by the user.  A natural approach would be to capture this behavior in an “chainable” protocol of some sort.<br>&gt; <br>&gt; This is low priority because I don’t know a lot of killer applications of it, I’m motivated by my ivory tower desire to push compiler magic into the standard library.  It bugs me that optional has sugar and other behavior that other types can’t participate in.<br></p><p>I’m admittedly a novice in functional programming, but couldn’t this be accomplished with Higher Kinded Types? Forgive me if I misunderstand, but it strikes me that Optional Chaining raises the chained operation into the optional context, such that “failed&quot; operations propagate the current .None optional context. Isn’t the purpose of Applicative Functors to define this type of behavior for all such types that have this property?<br></p><p>Tyler<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/57791887/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January 31, 2016 at 05:00:00pm</p></header><div class="content"><p>And by Applicative Functor, I believe I actually intend Monad.<br></p><p>Tyler<br></p><p><br>&gt; On Jan 31, 2016, at 5:07 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 30, 2016, at 9:20 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Use case 2 - Chaining on custom types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And this especially may not be feasible and I may be out of my depth describing the requirement but it feels like a more general case so at least worth airing):<br>&gt;&gt; <br>&gt;&gt; I’m not certain I understand the problem you’re looking to solve here, but I think it would be great (though probably very low priority) to open up the functionality of the postfix optional chaining operator to other types.  This could allow its monadic binding (aka railroad short circuiting) behavior to be extended to other types like Result, a left-biased-either, or an arbitrary type defined by the user.  A natural approach would be to capture this behavior in an “chainable” protocol of some sort.<br>&gt;&gt; <br>&gt;&gt; This is low priority because I don’t know a lot of killer applications of it, I’m motivated by my ivory tower desire to push compiler magic into the standard library.  It bugs me that optional has sugar and other behavior that other types can’t participate in.<br>&gt; <br>&gt; I’m admittedly a novice in functional programming, but couldn’t this be accomplished with Higher Kinded Types? Forgive me if I misunderstand, but it strikes me that Optional Chaining raises the chained operation into the optional context, such that “failed&quot; operations propagate the current .None optional context. Isn’t the purpose of Applicative Functors to define this type of behavior for all such types that have this property?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/16cd16c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 31, 2016 at 05:00:00pm</p></header><div class="content"><p>I think HKTs would be required to allow a generic implementation to serve all monadic instances, but even today there&#39;s no way AFAIK to replicate the &quot;?.&quot; style chaining operator for any type of arguments in user code.<br></p><p>I would be +1 for the original proposal. Just as we have &quot;if let actualThing = thing&quot; syntax for the common case of optional unwrapping, and &quot;if case let .Foo(x) = y&quot; syntax that is more generally applicable, it would be great to have &quot;?.&quot; used to chain optionals and a similar syntax allowing for other types (like a Result&lt;T, ErrorType&gt; or a Promise) to be chained. The chaining method calls on optionals make using them a lot less onerous than if only (e.g.) nested explicit if-let unwrapping were available.<br> <br>Best,<br>Austin<br></p><p>&gt; On Jan 31, 2016, at 5:14 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And by Applicative Functor, I believe I actually intend Monad.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 31, 2016, at 5:07 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 9:20 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Use case 2 - Chaining on custom types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And this especially may not be feasible and I may be out of my depth describing the requirement but it feels like a more general case so at least worth airing):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not certain I understand the problem you’re looking to solve here, but I think it would be great (though probably very low priority) to open up the functionality of the postfix optional chaining operator to other types.  This could allow its monadic binding (aka railroad short circuiting) behavior to be extended to other types like Result, a left-biased-either, or an arbitrary type defined by the user.  A natural approach would be to capture this behavior in an “chainable” protocol of some sort.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is low priority because I don’t know a lot of killer applications of it, I’m motivated by my ivory tower desire to push compiler magic into the standard library.  It bugs me that optional has sugar and other behavior that other types can’t participate in.<br>&gt;&gt; <br>&gt;&gt; I’m admittedly a novice in functional programming, but couldn’t this be accomplished with Higher Kinded Types? Forgive me if I misunderstand, but it strikes me that Optional Chaining raises the chained operation into the optional context, such that “failed&quot; operations propagate the current .None optional context. Isn’t the purpose of Applicative Functors to define this type of behavior for all such types that have this property?<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/831cc62e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Brainstorming: New operator type - chaining</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt; On 31/01/2016 05:20, Chris Lattner via swift-evolution wrote:<br>&gt;&gt; On Jan 30, 2016, at 3:06 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Use case 2 - Chaining on custom types<br>&gt;&gt; <br>&gt;&gt; And this especially may not be feasible and I may be out of my depth describing the requirement but it feels like a more general case so at least worth airing):<br>&gt; <br>&gt; I’m not certain I understand the problem you’re looking to solve here, but I think it would be great (though probably very low priority) to open up the functionality of the postfix optional chaining operator to other types.  This could allow its monadic binding (aka railroad short circuiting) behavior to be extended to other types like Result, a left-biased-either, or an arbitrary type defined by the user.  A natural approach would be to capture this behavior in an “chainable” protocol of some sort.<br>&gt; <br>&gt; This is low priority because I don’t know a lot of killer applications of it, I’m motivated by my ivory tower desire to push compiler magic into the standard library.  It bugs me that optional has sugar and other behavior that other types can’t participate in.<br>&gt; <br>&gt; -Chris<br></p><p>Thanks,<br></p><p>I can understand that it is low priority and know that you have a huge amount on your plate before 3.0. I don&#39;t really have a killer application because I think it is really syntactic sugar for a map like function with the benefit of removing the explicit closure. If I&#39;m right and it is just syntactic sugar then there is no urgency but I did want to mention the idea at this stage in case there were any potential impacts on the ABI so that at least it could be considered and allowed for if necessary. <br></p><p>Especially if the academic issue of the special treatment of optionals bothers you as it does me a little I&#39;m hopeful that this will be addressed at some point (4.0 or 5.0 maybe) but don&#39;t want to add additional pressure to the Core Team. <br></p><p>The personal use case is the first one I mentioned in the original message, wanting an asserting variant of optional chaining. That it is not currently possible led me to consider a more general possible solution and what else could be done with it. The Either use case was a bigger stretch for me as I don&#39;t usually use that style but it felt like the thing missing to enable alternatives to optionals being used as first class citizens with the powers of optionals in projects that choose to use them. <br></p><p>To elaborate on the relationship between optional chaining and map which reassures me it is syntactic sugar and is unlikely to be an ABI issue I looked at how to do the equivalent operations (I&#39;m sure this is obvious to Chris and many others of you but I thought it worth sharing as it helped me think about things)<br></p><p>The current optional chaining is equivalent to this on an rvalue:<br></p><p>foo?.bar()<br></p><p>foo.map { $0.bar() } // except this warns about unused results<br></p><p>And this on a lvalue version:<br></p><p>foo?.bar = 1<br></p><p>foo.map { $0.bar = 1 }<br></p><p>As always in these most simple examples the sugar doesn&#39;t feel that worthwhile but the benefits are shown in more complex or repeated use. An example of an assignment to a property that is accessed through two levels of optional would look quite ugly as I think it would need a double map but an `if let` with two binds would be the better option without optional chaining.<br></p><p>Joseph<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
