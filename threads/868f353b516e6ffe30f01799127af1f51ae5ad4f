<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 10, 2016 at 10:00:00am</p></header><div class="content"><p>on Sun Apr 10 2016, Michel Fortin &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Le 10 avr. 2016 à 6:17, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt;&gt; Remember, conditional branches are relatively slow, and we want to<br>&gt; avoid them where we can. If this is, for instance, the test of a loop,<br>&gt; the extra branch is not a good thing.<br>&gt;<br>&gt; Perhaps it&#39;s a bit extreme, but my idea for stride is that it should<br>&gt; only have one branch in the loop condition and absolutely no other<br>&gt; branch. <br></p><p>I agree that would be ideal.  When the stride is statically known, I am<br>confident that the optimizer can eliminate the branch.  When the stride<br>is not statically known, presumably you need the branch anyway, though<br>one might have to hope for the optimizer to copy and split the loop<br>(i.e. create two specializations based on sign).<br></p><p>&gt; The primitive stride could be defined like this:<br>&gt;<br>&gt; 	stride(from: 0, compare: &lt;, to: 10, by: 2)<br></p><p>Now you&#39;re adding a function call in lieu of a branch.  We could easily<br>build stride so it stores a comparison function based on the sign of the<br>stride, if we thought this would be better.  Would it?<br></p><p>&gt; and on top you could add some convenience functions for the &lt;, &gt;, &lt;=, and &gt;= cases:<br>&gt;<br>&gt; 	stride(from: 0, to: 10, by: 2) // stride(from: 0, compare: &lt;, to: 10, by: 2)<br>&gt; 	stride(from: 10, downTo: 0, by: -2) // stride(from: 10, compare: &gt;, to: 0, by -2)<br>&gt;<br>&gt; 	stride(from: 0, through: 10, by: 2) // stride(from: 10, compare: &lt;=, to: 10, by 2)<br>&gt; 	stride(from: 10, downThrough: 0, by: -2) // stride(from: 10, compare: &gt;=, to: 0, by -2)<br>&gt;<br>&gt; None of these should try to prevent you from making an infinite<br>&gt; sequence, so no trap for `by: 0` or one that moves the value in the<br>&gt; wrong direction. And certainly no extra loop branch based on the sign<br>&gt; of the stride (that&#39;s the most important part).<br>&gt;<br>&gt; Based on that, you could add some convenience for ranges:<br>&gt;<br>&gt; 	(0 ..&lt; 10).striding(by: 2) // shortcut for: stride(from: 0, to: 10, by 2)<br>&gt; 	(0 ..&lt; 10).stridingDown(by: -2) // shortcut for: stride(from: 10, to: 0, by -2)<br>&gt;<br>&gt; I guess in this case it&#39;d be fine to add a precondition to check that<br>&gt; `by` is not in the reverse direction so we can preserve the semantics<br>&gt; of iterating over a collection. But because of this precondition and<br>&gt; the other one in Range, I would actually prefer the non-range forms if<br>&gt; I was using a `stride` in a nested loop.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Le 10 avr. 2016 à 13:06, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; on Sun Apr 10 2016, Michel Fortin &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Le 10 avr. 2016 à 6:17, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; Remember, conditional branches are relatively slow, and we want to<br>&gt;&gt; avoid them where we can. If this is, for instance, the test of a loop,<br>&gt;&gt; the extra branch is not a good thing.<br>&gt;&gt; <br>&gt;&gt; Perhaps it&#39;s a bit extreme, but my idea for stride is that it should<br>&gt;&gt; only have one branch in the loop condition and absolutely no other<br>&gt;&gt; branch. <br>&gt; <br>&gt; I agree that would be ideal.  When the stride is statically known, I am<br>&gt; confident that the optimizer can eliminate the branch.  When the stride<br>&gt; is not statically known, presumably you need the branch anyway, though<br>&gt; one might have to hope for the optimizer to copy and split the loop<br>&gt; (i.e. create two specializations based on sign).<br>&gt; <br>&gt;&gt; The primitive stride could be defined like this:<br>&gt;&gt; <br>&gt;&gt; 	stride(from: 0, compare: &lt;, to: 10, by: 2)<br>&gt; <br>&gt; Now you&#39;re adding a function call in lieu of a branch.  We could easily<br>&gt; build stride so it stores a comparison function based on the sign of the<br>&gt; stride, if we thought this would be better.  Would it?<br></p><p>In the best case scenario the optimiser inlines everything and you have a straightforward loop with no indirect jump through a function pointer. We&#39;re already counting on most of the `stride` mechanics being inlined anyway, so I don&#39;t think it&#39;s a stretch to assume inlining will work correctly for this. To improve likelihood of inlining, don&#39;t make that function depend on a runtime value such as the sign of the stride.<br></p><p>But there&#39;s no guaranty with the optimizer. In the worse case we store a function pointer on the stack and do an indirect jump to that function at every loop iteration to do the comparison. I think that&#39;s better than adding a branch at every iteration, but that could depend on the CPU cache and branch prediction and various other factors (code locality, etc.). I won&#39;t try to predict if the worse case is worse or better than with what we have now since I&#39;m not even sure how to benchmark this.<br></p><p>But let&#39;s go back to the current implementation for a minute.<br></p><p>`stride` should work with any integer type. That should include custom ones such as an implementation of BigInt. If for some reason the optimizer cannot inline the `stride &lt; 0` comparison in the `next()` function (where stride is of the generic type Element), it will not be able to deduce that the result is always the same (there&#39;s no `pure` annotation in the language). So it will pessimistically evaluate `stride &lt; 0` at every iteration. In itself that comparison could be costly if we&#39;re talking about BigInt. And to that you add the cost of branching on the result of that comparison.<br></p><p>So if you take this into account, storing the comparator as part of the stride makes the cost more predictable: not only there is one branch less in `next()`, but you avoid evaluating the condition which has an unknown cost: the `stride &lt; 0` part.<br></p><p>And ideally you should make sure the optimizer can replace the indirect call with a direct call to the comparator. You do that by not making the comparator choice dependent on a runtime value, hence why I suggested having distinct &quot;down&quot; variants for the convenience functions: `stride(from:downTo:by:)` and `stride(from:downThrough:by:)` and `Range.strindingDown(by:)`.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>on Sun Apr 10 2016, Michel Fortin &lt;michel.fortin-AT-michelf.ca&gt; wrote:<br></p><p>&gt; So if you take this into account, storing the comparator as part of<br>&gt; the stride makes the cost more predictable: not only there is one<br>&gt; branch less in `next()`, but you avoid evaluating the condition which<br>&gt; has an unknown cost: the `stride &lt; 0` part.<br>&gt;<br>&gt; And ideally you should make sure the optimizer can replace the<br>&gt; indirect call with a direct call to the comparator. You do that by not<br>&gt; making the comparator choice dependent on a runtime value, hence why I<br>&gt; suggested having distinct &quot;down&quot; variants for the convenience<br>&gt; functions: `stride(from:downTo:by:)` and<br>&gt; `stride(from:downThrough:by:)` and `Range.strindingDown(by:)`.<br></p><p>A few points:<br></p><p>1. There&#39;s a balance to be struck between making sure the optimizer can<br>   do a good job under *absolutely all circumstances*, and keeping the<br>   API surface area small and simple.  That makes me somewhat reluctant<br>   to add “down” variants, if as I suspect the optimizer does well in<br>   the vast majority of cases without them.<br></p><p>2. Similarly, I view r.striding(by: x) as redundant with stride(from: x,<br>   to: y, by: z).  I&#39;d rather not have them both.<br></p><p>3. The fact that we&#39;re migrating C-style for loops to<br>   uses of stride, as noted in https://github.com/apple/swift/pull/2125,<br>   has convinced me that, sadly, we may need an answer that doesn&#39;t<br>   involve ranges.  But maybe something like<br></p><p>     for x in loop(from: 0.1, while: { $0 &lt; 10 }, next: { $0 + .2 })<br></p><p>   is sufficient for this purpose.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>April 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Le 11 avr. 2016 à 14:36, Dave Abrahams &lt;dabrahams at apple.com&gt; a écrit :<br></p><p>&gt; 3. The fact that we&#39;re migrating C-style for loops to<br>&gt;   uses of stride, as noted in https://github.com/apple/swift/pull/2125,<br>&gt;   has convinced me that, sadly, we may need an answer that doesn&#39;t<br>&gt;   involve ranges.  But maybe something like<br>&gt; <br>&gt;     for x in loop(from: 0.1, while: { $0 &lt; 10 }, next: { $0 + .2 })<br>&gt; <br>&gt;   is sufficient for this purpose.<br></p><p>Please add that. First, it would relieve `stride` from some of the pressure of excelling at replacing existing C-style for loops. But it would also become pretty easy to write custom sequences like this one:<br></p><p>func uniform(start: Double, end: Double, numberOfSteps totalSteps: Int) -&gt; Sequence {<br>	var currentStep = 0<br>	return loop(from: start, while: { _ in<br>		currentStep &lt; totalSteps<br>	}, next: { _ in<br>		currentStep += 1<br>		return start * (Double(totalSteps-currentStep) / Double(totalSteps)) +<br>			end * (Double(currentStep) / Double(totalSteps))<br>	})<br>}<br></p><p>Just don&#39;t call the function `loop`, as it does not return a loop.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 11, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Apr 11 2016, Michel Fortin &lt;michel.fortin-AT-michelf.ca&gt; wrote:<br></p><p>&gt; Le 11 avr. 2016 à 14:36, Dave Abrahams &lt;dabrahams at apple.com&gt; a écrit :<br>&gt;<br>&gt;&gt; 3. The fact that we&#39;re migrating C-style for loops to<br>&gt;&gt;   uses of stride, as noted in https://github.com/apple/swift/pull/2125,<br>&gt;&gt;   has convinced me that, sadly, we may need an answer that doesn&#39;t<br>&gt;&gt;   involve ranges.  But maybe something like<br>&gt;&gt; <br>&gt;&gt;     for x in loop(from: 0.1, while: { $0 &lt; 10 }, next: { $0 + .2 })<br>&gt;&gt; <br>&gt;&gt;   is sufficient for this purpose.<br>&gt;<br>&gt; Please add that. <br></p><p>Please write a proposal and ideally, submit a patch :-).<br></p><p>Seriously, if this is something you believe in, we could really use the<br>help.<br></p><p>&gt; First, it would relieve `stride` from some of the pressure of<br>&gt; excelling at replacing existing C-style for loops. But it would also<br>&gt; become pretty easy to write custom sequences like this one:<br>&gt;<br>&gt; func uniform(start: Double, end: Double, numberOfSteps totalSteps: Int) -&gt; Sequence {<br>&gt; 	var currentStep = 0<br>&gt; 	return loop(from: start, while: { _ in<br>&gt; 		currentStep &lt; totalSteps<br>&gt; 	}, next: { _ in<br>&gt; 		currentStep += 1<br>&gt; 		return start * (Double(totalSteps-currentStep) / Double(totalSteps)) +<br>&gt; 			end * (Double(currentStep) / Double(totalSteps))<br>&gt; 	})<br>&gt; }<br></p><p>Aside from the fact that you can&#39;t return Sequence, this seems like a<br>much better way to do that in Swift 3.0:<br></p><p>func uniform(<br>  start: Double, end: Double, numberOfSteps totalSteps: Int<br>) -&gt; LazyMapRandomAccessCollection&lt;CountableRange&lt;Int&gt;, Double&gt; {<br>  return (0..&lt;totalSteps).lazy.map { <br>     start * (Double(totalSteps-$0) / Double(totalSteps)) +<br>     end * (Double($0) / Double(totalSteps)) <br>  }<br>}<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Draft]: Introducing a striding(by:) method on 3.0 ranges</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April 12, 2016 at 12:00:00am</p></header><div class="content"><p>I think I&#39;d like to +1 a &#39;for x in loop(from: while: next:)&#39;. (Possibly<br>&#39;iterate&#39; rather than &#39;loop&#39;?)<br></p><p>I&#39;ve not missed the C-style for-loop so I&#39;ve not argued to keep it, but<br>recently I was refactoring a function which started with a UIView and<br>iterated up the hierarchy through the superview property, and it occurred<br>to me recently that neither stride nor sequences/generators handle<br>recursive iterations well.<br></p><p>So, I imagine that would look like this:<br>for view in loop(from: startingSubview, while: { $0 != nil }, next: { $0 =<br>$0.superview })<br></p><p><br>On Mon, Apr 11, 2016 at 11:31 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon Apr 11 2016, Michel Fortin &lt;michel.fortin-AT-michelf.ca&gt; wrote:<br>&gt;<br>&gt; &gt; Le 11 avr. 2016 à 14:36, Dave Abrahams &lt;dabrahams at apple.com&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;&gt; 3. The fact that we&#39;re migrating C-style for loops to<br>&gt; &gt;&gt;   uses of stride, as noted in https://github.com/apple/swift/pull/2125,<br>&gt; &gt;&gt;   has convinced me that, sadly, we may need an answer that doesn&#39;t<br>&gt; &gt;&gt;   involve ranges.  But maybe something like<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;     for x in loop(from: 0.1, while: { $0 &lt; 10 }, next: { $0 + .2 })<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   is sufficient for this purpose.<br>&gt; &gt;<br>&gt; &gt; Please add that.<br>&gt;<br>&gt; Please write a proposal and ideally, submit a patch :-).<br>&gt;<br>&gt; Seriously, if this is something you believe in, we could really use the<br>&gt; help.<br>&gt;<br>&gt; &gt; First, it would relieve `stride` from some of the pressure of<br>&gt; &gt; excelling at replacing existing C-style for loops. But it would also<br>&gt; &gt; become pretty easy to write custom sequences like this one:<br>&gt; &gt;<br>&gt; &gt; func uniform(start: Double, end: Double, numberOfSteps totalSteps: Int)<br>&gt; -&gt; Sequence {<br>&gt; &gt;       var currentStep = 0<br>&gt; &gt;       return loop(from: start, while: { _ in<br>&gt; &gt;               currentStep &lt; totalSteps<br>&gt; &gt;       }, next: { _ in<br>&gt; &gt;               currentStep += 1<br>&gt; &gt;               return start * (Double(totalSteps-currentStep) /<br>&gt; Double(totalSteps)) +<br>&gt; &gt;                       end * (Double(currentStep) / Double(totalSteps))<br>&gt; &gt;       })<br>&gt; &gt; }<br>&gt;<br>&gt; Aside from the fact that you can&#39;t return Sequence, this seems like a<br>&gt; much better way to do that in Swift 3.0:<br>&gt;<br>&gt; func uniform(<br>&gt;   start: Double, end: Double, numberOfSteps totalSteps: Int<br>&gt; ) -&gt; LazyMapRandomAccessCollection&lt;CountableRange&lt;Int&gt;, Double&gt; {<br>&gt;   return (0..&lt;totalSteps).lazy.map {<br>&gt;      start * (Double(totalSteps-$0) / Double(totalSteps)) +<br>&gt;      end * (Double($0) / Double(totalSteps))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/49ecb30e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
