<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 06:00:00am</p></header><div class="content"><p>Oftentimes I want to have multiple parameterless constructors. In the immediate case, I want a Key for various different cryptographic algorithms:<br></p><p>    let a = Key(forRSA: true) //2048-bits<br>    let b = Key(forCurve25519: true) //256-bits<br>    let c = Key(forAES: true) //128-bits<br></p><p>There is no &quot;parameter&quot; to pass here; in particular the user should not be expected to know off the top of their head what the key size for Curve25519 is.<br></p><p>With the current limits of the language, I am generally forced to vend a parameter and associated label (I typically use type Bool) and pass a &quot;dontcare&quot; value in, e.g. `true` in the above.<br></p><p>I propose to eliminate this, so I can write<br></p><p>    Key {<br>        init(forRSA) { /* */ }<br>    }<br>    let a = Key(forRSA)<br></p><p>This eliminates the parameter, and the associated mystery about what happens if you pass `false` to one of these constructors.<br></p><p>FAQ:<br></p><p>Q: Can&#39;t you have one constructor that takes an enum parameter?<br>A: Enum parameters cannot have cases with distinct access modifiers, as constructors often are.  Also, combining unrelated code into one constructor makes me sad.<br></p><p>Q: Can&#39;t you create subclasses RSAKey, Curve25519Key etc. with distinct constructors?<br>A: Well first of all, Key is probably a `struct`, so no, you can&#39;t create subclasses of it.  Also, the only thing differentiating them is the constructor, not e.g. other overridden methods or variables, so subclassing feels an unnecessarily heavy abstraction.<br></p><p>Q: Can we extend this to support arbitrary labels e.g. `init(random length: 2000)` vs `init(zeroed length: 2000)`, `mkdir(path, creatingIntermediateDirectoriesIfRequired)` and many more?<br>A: Yes, although these are probably more controversial proposals than simply supporting multiple parameterless constructors.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>(1) Isn&#39;t using a class function just one more symbol?<br></p><p>let a = Key.forRSA()<br></p><p>(2) Wouldn&#39;t this syntax be more logical:<br>Key {<br>init(forRSA: Void) { /* */ }<br>}<br></p><p>Key(forRSA:)<br>The only change compared to what we have now would be auto-generation of<br>().<br></p><p>On Sun, Dec 13, 2015 at 15:50 Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oftentimes I want to have multiple parameterless constructors. In the<br>&gt; immediate case, I want a Key for various different cryptographic algorithms:<br>&gt;<br>&gt;     let a = Key(forRSA: true) //2048-bits<br>&gt;     let b = Key(forCurve25519: true) //256-bits<br>&gt;     let c = Key(forAES: true) //128-bits<br>&gt;<br>&gt; There is no &quot;parameter&quot; to pass here; in particular the user should not be<br>&gt; expected to know off the top of their head what the key size for Curve25519<br>&gt; is.<br>&gt;<br>&gt; With the current limits of the language, I am generally forced to vend a<br>&gt; parameter and associated label (I typically use type Bool) and pass a<br>&gt; &quot;dontcare&quot; value in, e.g. `true` in the above.<br>&gt;<br>&gt; I propose to eliminate this, so I can write<br>&gt;<br>&gt;     Key {<br>&gt;         init(forRSA) { /* */ }<br>&gt;     }<br>&gt;     let a = Key(forRSA)<br>&gt;<br>&gt; This eliminates the parameter, and the associated mystery about what<br>&gt; happens if you pass `false` to one of these constructors.<br>&gt;<br>&gt; FAQ:<br>&gt;<br>&gt; Q: Can&#39;t you have one constructor that takes an enum parameter?<br>&gt; A: Enum parameters cannot have cases with distinct access modifiers, as<br>&gt; constructors often are.  Also, combining unrelated code into one<br>&gt; constructor makes me sad.<br>&gt;<br>&gt; Q: Can&#39;t you create subclasses RSAKey, Curve25519Key etc. with distinct<br>&gt; constructors?<br>&gt; A: Well first of all, Key is probably a `struct`, so no, you can&#39;t create<br>&gt; subclasses of it.  Also, the only thing differentiating them is the<br>&gt; constructor, not e.g. other overridden methods or variables, so subclassing<br>&gt; feels an unnecessarily heavy abstraction.<br>&gt;<br>&gt; Q: Can we extend this to support arbitrary labels e.g. `init(random<br>&gt; length: 2000)` vs `init(zeroed length: 2000)`, `mkdir(path,<br>&gt; creatingIntermediateDirectoriesIfRequired)` and many more?<br>&gt; A: Yes, although these are probably more controversial proposals than<br>&gt; simply supporting multiple parameterless constructors.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/6a32891a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 7:03 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; (1) Isn&#39;t using a class function just one more symbol? <br></p><p><br>No, a class/static function is not the same as an initializer.  e.g., a class function cannot assign to a let ivar.<br></p><p>&gt; (2) Wouldn&#39;t this syntax be more logical:<br>&gt; Key {<br>&gt; init(forRSA: Void) { /* */ }<br>&gt; }<br>&gt; <br>&gt; Key(forRSA:)<br></p><p>Maybe.  The trailing colon gives me some anxiety; I feel like it wants something to follow it.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/e7257cad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; There is no &quot;parameter&quot; to pass here; in particular the user should not<br>be expected to know off the top of their head what the key size for<br>Curve25519 is.<br></p><p>You can easily call a private parametrized init from a class function<br>though.<br></p><p><br>&gt; The trailing colon gives me some anxiety; I feel like it wants something<br>to follow it.<br></p><p>Sure, it&#39;s not the most beautiful construct, but it unambiguously<br>identifies the preceding token as a label name.<br></p><p>On Sun, Dec 13, 2015 at 16:09 Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 13, 2015, at 7:03 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; (1) Isn&#39;t using a class function just one more symbol?<br>&gt;<br>&gt;<br>&gt; No, a class/static function is not the same as an initializer.  e.g., a<br>&gt; class function cannot assign to a let ivar.<br>&gt;<br>&gt; (2) Wouldn&#39;t this syntax be more logical:<br>&gt; Key {<br>&gt; init(forRSA: Void) { /* */ }<br>&gt; }<br>&gt;<br>&gt; Key(forRSA:)<br>&gt;<br>&gt;<br>&gt; Maybe.  The trailing colon gives me some anxiety; I feel like it wants<br>&gt; something to follow it.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/2837af6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; You can easily call a private parametrized init from a class function though. <br></p><p><br>Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API to a bad private API.<br></p><p>Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad public API.  There is a reason that NSData.dataWithData(...) is a Swift compile error.<br></p><p>The (ab)use of class functions as constructors is a holdover from ObjC times.  If you want to make an instance in Swift, you should type ClassName( and see what autocomplete suggests; you should not have to read through the documentation of class functions to see if they are secretly constructors that have been filed at the wrong shelf in the library.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/85ba808f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 13, 2015 at 02:00:00pm</p></header><div class="content"><p>Using a static/class function would make subclassing difficult<br></p><p>   - you cannot hide them in subclasses (they&#39;re always inherited unlike<br>   initializers)<br>   - you can&#39;t call them from subclass initializers to properly initialize<br>   superclasses<br></p><p><br>On Sun, Dec 13, 2015 at 2:21 PM, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; You can easily call a private parametrized init from a class function<br>&gt; though.<br>&gt;<br>&gt;<br>&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API<br>&gt; to a bad private API.<br>&gt;<br>&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad<br>&gt; public API.  There is a reason that NSData.dataWithData(...) is a Swift<br>&gt; compile error.<br>&gt;<br>&gt; The (ab)use of class functions as constructors is a holdover from ObjC<br>&gt; times.  If you want to make an instance in Swift, you should type<br>&gt; ClassName( and see what autocomplete suggests; you should not have to read<br>&gt; through the documentation of class functions to see if they are secretly<br>&gt; constructors that have been filed at the wrong shelf in the library.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/beaec5c1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 13, 2015 at 07:00:00pm</p></header><div class="content"><p>Good point on that. I still think the best solution is to take the existing<br>syntax of<br></p><p><br>struct Key {<br>    init(forRSA:Void) { /* */ }<br>    init(forCurve25519:Void) { /* */ }<br>    init(forAES:Void) { /* */ }<br>}<br></p><p>let a = Key(forRSA: ())<br></p><p>or<br></p><p>let empty: Void = ()<br>let c = Key(forAES: empty)<br></p><p>and make it somewhat easier to read.  Perhaps<br></p><p>let b = Key(forCurve25519: _ )<br></p><p>I think many people will read Key(forAES) as Key.init(_: forAES), so that<br>may be not the best expression here.<br></p><p><br></p><p>On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; You can easily call a private parametrized init from a class function<br>&gt; though.<br>&gt;<br>&gt;<br>&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API<br>&gt; to a bad private API.<br>&gt;<br>&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad<br>&gt; public API.  There is a reason that NSData.dataWithData(...) is a Swift<br>&gt; compile error.<br>&gt;<br>&gt; The (ab)use of class functions as constructors is a holdover from ObjC<br>&gt; times.  If you want to make an instance in Swift, you should type<br>&gt; ClassName( and see what autocomplete suggests; you should not have to read<br>&gt; through the documentation of class functions to see if they are secretly<br>&gt; constructors that have been filed at the wrong shelf in the library.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/f4519d2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 13, 2015 at 10:00:00am</p></header><div class="content"><p>In this particular example, perhaps Key should be an enum instead of a struct.<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 13, 2015, at 10:07 AM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good point on that. I still think the best solution is to take the existing syntax of<br>&gt; <br>&gt; <br>&gt; struct Key {<br>&gt;     init(forRSA:Void) { /* */ }<br>&gt;     init(forCurve25519:Void) { /* */ }<br>&gt;     init(forAES:Void) { /* */ }<br>&gt; }<br>&gt; <br>&gt; let a = Key(forRSA: ())<br>&gt; <br>&gt; or <br>&gt; <br>&gt; let empty: Void = ()<br>&gt; let c = Key(forAES: empty)<br>&gt; <br>&gt; and make it somewhat easier to read.  Perhaps<br>&gt; <br>&gt; let b = Key(forCurve25519: _ )<br>&gt; <br>&gt; I think many people will read Key(forAES) as Key.init(_: forAES), so that may be not the best expression here.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can easily call a private parametrized init from a class function though. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API to a bad private API.<br>&gt;&gt; <br>&gt;&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad public API.  There is a reason that NSData.dataWithData(...) is a Swift compile error.<br>&gt;&gt; <br>&gt;&gt; The (ab)use of class functions as constructors is a holdover from ObjC times.  If you want to make an instance in Swift, you should type ClassName( and see what autocomplete suggests; you should not have to read through the documentation of class functions to see if they are secretly constructors that have been filed at the wrong shelf in the library.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/73d6ecf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ae34e6aaf28c0e1fe929f36897d107e?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Harlan Haskins</string> &lt;harlan at harlanhaskins.com&gt;<p>December 13, 2015 at 11:00:00am</p></header><div class="content"><p>Also I think it’d be cleaner to just accept an enum in one initializer<br></p><p>enum KeyType {<br>    case RSA<br>    case Curve25519<br>    case AES<br>}<br></p><p>Then you get that semantic niceness of:<br></p><p>init(keyType: .RSA)<br>init(keyType: .Curve25519)<br>init(keyType: .AES)<br></p><p>— Harlan<br></p><p>&gt; On Dec 13, 2015, at 11:41 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In this particular example, perhaps Key should be an enum instead of a struct.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 13, 2015, at 10:07 AM, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Good point on that. I still think the best solution is to take the existing syntax of<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; struct Key {<br>&gt;&gt;     init(forRSA:Void) { /* */ }<br>&gt;&gt;     init(forCurve25519:Void) { /* */ }<br>&gt;&gt;     init(forAES:Void) { /* */ }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Key(forRSA: ())<br>&gt;&gt; <br>&gt;&gt; or <br>&gt;&gt; <br>&gt;&gt; let empty: Void = ()<br>&gt;&gt; let c = Key(forAES: empty)<br>&gt;&gt; <br>&gt;&gt; and make it somewhat easier to read.  Perhaps<br>&gt;&gt; <br>&gt;&gt; let b = Key(forCurve25519: _ )<br>&gt;&gt; <br>&gt;&gt; I think many people will read Key(forAES) as Key.init(_: forAES), so that may be not the best expression here.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can easily call a private parametrized init from a class function though. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API to a bad private API.<br>&gt;&gt; <br>&gt;&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad public API.  There is a reason that NSData.dataWithData(...) is a Swift compile error.<br>&gt;&gt; <br>&gt;&gt; The (ab)use of class functions as constructors is a holdover from ObjC times.  If you want to make an instance in Swift, you should type ClassName( and see what autocomplete suggests; you should not have to read through the documentation of class functions to see if they are secretly constructors that have been filed at the wrong shelf in the library.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/98f2801a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 13, 2015 at 12:00:00pm</p></header><div class="content"><p>Agreed. It&#39;s also likely that you&#39;ll be setting some internal flag with this information already. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 13, 2015, at 8:55 AM, Harlan Haskins via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also I think it’d be cleaner to just accept an enum in one initializer<br>&gt; <br>&gt; enum KeyType {<br>&gt;     case RSA<br>&gt;     case Curve25519<br>&gt;     case AES<br>&gt; }<br>&gt; <br>&gt; Then you get that semantic niceness of:<br>&gt; <br>&gt; init(keyType: .RSA)<br>&gt; init(keyType: .Curve25519)<br>&gt; init(keyType: .AES)<br>&gt; <br>&gt; — Harlan<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 11:41 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In this particular example, perhaps Key should be an enum instead of a struct.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 10:07 AM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good point on that. I still think the best solution is to take the existing syntax of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Key {<br>&gt;&gt;&gt;     init(forRSA:Void) { /* */ }<br>&gt;&gt;&gt;     init(forCurve25519:Void) { /* */ }<br>&gt;&gt;&gt;     init(forAES:Void) { /* */ }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = Key(forRSA: ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let empty: Void = ()<br>&gt;&gt;&gt; let c = Key(forAES: empty)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and make it somewhat easier to read.  Perhaps<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let b = Key(forCurve25519: _ )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think many people will read Key(forAES) as Key.init(_: forAES), so that may be not the best expression here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can easily call a private parametrized init from a class function though. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API to a bad private API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad public API.  There is a reason that NSData.dataWithData(...) is a Swift compile error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The (ab)use of class functions as constructors is a holdover from ObjC times.  If you want to make an instance in Swift, you should type ClassName( and see what autocomplete suggests; you should not have to read through the documentation of class functions to see if they are secretly constructors that have been filed at the wrong shelf in the library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/9a0a833d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 03:00:00pm</p></header><div class="content"><p>The problems with enums as parameters were explained in the proposal.  I don&#39;t see how these responses address any of the concerns that were initially raised.<br></p><p><br>&gt; On Dec 13, 2015, at 2:25 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Agreed. It&#39;s also likely that you&#39;ll be setting some internal flag with this information already. <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 13, 2015, at 8:55 AM, Harlan Haskins via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Also I think it’d be cleaner to just accept an enum in one initializer<br>&gt;&gt; <br>&gt;&gt; enum KeyType {<br>&gt;&gt;     case RSA<br>&gt;&gt;     case Curve25519<br>&gt;&gt;     case AES<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then you get that semantic niceness of:<br>&gt;&gt; <br>&gt;&gt; init(keyType: .RSA)<br>&gt;&gt; init(keyType: .Curve25519)<br>&gt;&gt; init(keyType: .AES)<br>&gt;&gt; <br>&gt;&gt; — Harlan<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 11:41 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this particular example, perhaps Key should be an enum instead of a struct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 13, 2015, at 10:07 AM, ilya via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good point on that. I still think the best solution is to take the existing syntax of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Key {<br>&gt;&gt;&gt;&gt;     init(forRSA:Void) { /* */ }<br>&gt;&gt;&gt;&gt;     init(forCurve25519:Void) { /* */ }<br>&gt;&gt;&gt;&gt;     init(forAES:Void) { /* */ }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = Key(forRSA: ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let empty: Void = ()<br>&gt;&gt;&gt;&gt; let c = Key(forAES: empty)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and make it somewhat easier to read.  Perhaps<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let b = Key(forCurve25519: _ )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think many people will read Key(forAES) as Key.init(_: forAES), so that may be not the best expression here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can easily call a private parametrized init from a class function though. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public API to a bad private API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a bad public API.  There is a reason that NSData.dataWithData(...) is a Swift compile error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The (ab)use of class functions as constructors is a holdover from ObjC times.  If you want to make an instance in Swift, you should type ClassName( and see what autocomplete suggests; you should not have to read through the documentation of class functions to see if they are secretly constructors that have been filed at the wrong shelf in the library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/64ea3cbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 13, 2015 at 11:00:00pm</p></header><div class="content"><p>Is this equivalent to having &quot;flags&quot; for functions? Like `--rsa`, `--aes`?<br>On Sun, 13 Dec 2015 at 13:56, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The problems with enums as parameters were explained in the proposal.  I<br>&gt; don&#39;t see how these responses address any of the concerns that were<br>&gt; initially raised.<br>&gt;<br>&gt;<br>&gt; On Dec 13, 2015, at 2:25 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Agreed. It&#39;s also likely that you&#39;ll be setting some internal flag with<br>&gt; this information already.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Dec 13, 2015, at 8:55 AM, Harlan Haskins via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Also I think it’d be cleaner to just accept an enum in one initializer<br>&gt;<br>&gt; enum KeyType {<br>&gt;     case RSA<br>&gt;     case Curve25519<br>&gt;     case AES<br>&gt; }<br>&gt;<br>&gt; Then you get that semantic niceness of:<br>&gt;<br>&gt; init(keyType: .RSA)<br>&gt; init(keyType: .Curve25519)<br>&gt; init(keyType: .AES)<br>&gt;<br>&gt; — Harlan<br>&gt;<br>&gt; On Dec 13, 2015, at 11:41 AM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; In this particular example, perhaps Key should be an enum instead of a<br>&gt; struct.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 13, 2015, at 10:07 AM, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Good point on that. I still think the best solution is to take the<br>&gt; existing syntax of<br>&gt;<br>&gt;<br>&gt; struct Key {<br>&gt;     init(forRSA:Void) { /* */ }<br>&gt;     init(forCurve25519:Void) { /* */ }<br>&gt;     init(forAES:Void) { /* */ }<br>&gt; }<br>&gt;<br>&gt; let a = Key(forRSA: ())<br>&gt;<br>&gt; or<br>&gt;<br>&gt; let empty: Void = ()<br>&gt; let c = Key(forAES: empty)<br>&gt;<br>&gt; and make it somewhat easier to read.  Perhaps<br>&gt;<br>&gt; let b = Key(forCurve25519: _ )<br>&gt;<br>&gt; I think many people will read Key(forAES) as Key.init(_: forAES), so that<br>&gt; may be not the best expression here.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 13, 2015 at 4:21 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 13, 2015, at 7:13 AM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You can easily call a private parametrized init from a class function<br>&gt;&gt; though.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, but we&#39;re just shuffling the deck.  We&#39;ve gone from a bad public<br>&gt;&gt; API to a bad private API.<br>&gt;&gt;<br>&gt;&gt; Actually, it&#39;s worse, because we now have BOTH a bad private API AND a<br>&gt;&gt; bad public API.  There is a reason that NSData.dataWithData(...) is a Swift<br>&gt;&gt; compile error.<br>&gt;&gt;<br>&gt;&gt; The (ab)use of class functions as constructors is a holdover from ObjC<br>&gt;&gt; times.  If you want to make an instance in Swift, you should type<br>&gt;&gt; ClassName( and see what autocomplete suggests; you should not have to read<br>&gt;&gt; through the documentation of class functions to see if they are secretly<br>&gt;&gt; constructors that have been filed at the wrong shelf in the library.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/7ffdcbe6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 13, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 1:56 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; The problems with enums as parameters were explained in the proposal.  I don&#39;t see how these responses address any of the concerns that were initially raised.<br></p><p>Granted. I think it’s just sadly one of those things that are lost when we combine the allocation and the initialization phase. I don’t like the labels as you’ve proposed because they are yet another special thing about initialization. For example, to solve this problem with functions, we could simply change the name of them.<br></p><p>Your problem also reminds me of the cluster cluster problem. While they are not quite the same, they share many of the same concerns. It’s not a stretch to return different types from the Key initializer so that you don’t need to waste 1024bits with a 128bit key is all that’s needed. Of course, this requires sized arrays that Swift doesn’t have yet or some other construct to get a fixed size, but I think the point is clear.<br></p><p>Unfortunately, I think Dave’s workaround is probably the best for your specific use case.<br></p><p>&gt; struct Key {<br>&gt;  enum RSA_ { case RSA }<br>&gt;  init(_: RSA_) { ... }<br>&gt; <br>&gt;  enum AES_ { case AES }<br>&gt;  init(_: AES_) { ... }<br>&gt; }<br>&gt; <br>&gt;  Key(.RSA)<br>&gt;  Key(.AES)<br></p><p><br>Then you have this:<br></p><p>&gt; Q: Can we extend this to support arbitrary labels e.g. `init(random length: 2000)` vs `init(zeroed length: 2000)`, `mkdir(path, creatingIntermediateDirectoriesIfRequired)` and many more?<br>&gt; A: Yes, although these are probably more controversial proposals than simply supporting multiple parameterless constructors.<br></p><p>I’m not sure this really applies generally. What if I want a mkdir() that doesn’t create the directories if required? This seems to fall right into the strong house of default parameters. <br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>Interesting suggestion :)<br>Perhaps, try doing the work outside the constructor, then the static<br>function suggestions work:<br></p><p>struct Key {<br>    public static func createRSA() {<br>        var data: String<br>        // calculate RSA<br>        ...<br>        return Key(bitLength: 2048, data: data)<br>    }<br>    private init(bitLength: Int, data: String) {<br>        self.bitLength = bitLength<br>        self.data = data<br>    }<br>}<br></p><p>var myKey = Key.createRSA()<br></p><p>In my opinion this is much less ambiguous to the compiler and programmer. I<br>personally wouldn&#39;t be sure which of these &#39;Key(withRSA)&#39; was:<br></p><p>let withRSA: Int<br>init(_ something: Int)<br></p><p>Or:<br></p><p>init(withRSA _ _)<br></p><p><br></p><p><br></p><p>On Mon, Dec 14, 2015 at 6:22 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 13, 2015, at 1:56 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The problems with enums as parameters were explained in the proposal.  I<br>&gt; don&#39;t see how these responses address any of the concerns that were<br>&gt; initially raised.<br>&gt;<br>&gt; Granted. I think it’s just sadly one of those things that are lost when we<br>&gt; combine the allocation and the initialization phase. I don’t like the<br>&gt; labels as you’ve proposed because they are yet another special thing about<br>&gt; initialization. For example, to solve this problem with functions, we could<br>&gt; simply change the name of them.<br>&gt;<br>&gt; Your problem also reminds me of the cluster cluster problem. While they<br>&gt; are not quite the same, they share many of the same concerns. It’s not a<br>&gt; stretch to return different types from the Key initializer so that you<br>&gt; don’t need to waste 1024bits with a 128bit key is all that’s needed. Of<br>&gt; course, this requires sized arrays that Swift doesn’t have yet or some<br>&gt; other construct to get a fixed size, but I think the point is clear.<br>&gt;<br>&gt; Unfortunately, I think Dave’s workaround is probably the best for your<br>&gt; specific use case.<br>&gt;<br>&gt; &gt; struct Key {<br>&gt; &gt;  enum RSA_ { case RSA }<br>&gt; &gt;  init(_: RSA_) { ... }<br>&gt; &gt;<br>&gt; &gt;  enum AES_ { case AES }<br>&gt; &gt;  init(_: AES_) { ... }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;  Key(.RSA)<br>&gt; &gt;  Key(.AES)<br>&gt;<br>&gt;<br>&gt; Then you have this:<br>&gt;<br>&gt; &gt; Q: Can we extend this to support arbitrary labels e.g. `init(random<br>&gt; length: 2000)` vs `init(zeroed length: 2000)`, `mkdir(path,<br>&gt; creatingIntermediateDirectoriesIfRequired)` and many more?<br>&gt; &gt; A: Yes, although these are probably more controversial proposals than<br>&gt; simply supporting multiple parameterless constructors.<br>&gt;<br>&gt; I’m not sure this really applies generally. What if I want a mkdir() that<br>&gt; doesn’t create the directories if required? This seems to fall right into<br>&gt; the strong house of default parameters.<br>&gt;<br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/5827663c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: label-only constructors</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 13, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 4:49 AM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Oftentimes I want to have multiple parameterless constructors. In the immediate case, I want a Key for various different cryptographic algorithms:<br>&gt; <br>&gt;    let a = Key(forRSA: true) //2048-bits<br>&gt;    let b = Key(forCurve25519: true) //256-bits<br>&gt;    let c = Key(forAES: true) //128-bits<br>&gt; <br>&gt; There is no &quot;parameter&quot; to pass here; in particular the user should not be expected to know off the top of their head what the key size for Curve25519 is.<br>&gt; <br>&gt; With the current limits of the language, I am generally forced to vend a parameter and associated label (I typically use type Bool) and pass a &quot;dontcare&quot; value in, e.g. `true` in the above.<br>&gt; <br>&gt; I propose to eliminate this, so I can write<br>&gt; <br>&gt;    Key {<br>&gt;        init(forRSA) { /* */ }<br>&gt;    }<br>&gt;    let a = Key(forRSA)<br>&gt; <br>&gt; This eliminates the parameter, and the associated mystery about what happens if you pass `false` to one of these constructors.<br>&gt; <br>&gt; FAQ:<br>&gt; <br>&gt; Q: Can&#39;t you have one constructor that takes an enum parameter?<br>&gt; A: Enum parameters cannot have cases with distinct access modifiers, as constructors often are.  Also, combining unrelated code into one constructor makes me sad.<br></p><p>Doesn&#39;t this work?<br></p><p>struct Key {<br>  enum RSA_ { case RSA }<br>  init(_: RSA_) { ... }<br></p><p>  enum AES_ { case AES }<br>  init(_: AES_) { ... }<br></p><p>  // etc.<br>}<br></p><p>It&#39;s admittedly awkward at the declaration site but it still looks good at the use-site:<br></p><p>  Key(.RSA)<br>  Key(.AES)<br></p><p>etc.<br></p><p>&gt; <br>&gt; Q: Can&#39;t you create subclasses RSAKey, Curve25519Key etc. with distinct constructors?<br>&gt; A: Well first of all, Key is probably a `struct`, so no, you can&#39;t create subclasses of it.  Also, the only thing differentiating them is the constructor, not e.g. other overridden methods or variables, so subclassing feels an unnecessarily heavy abstraction.<br>&gt; <br>&gt; Q: Can we extend this to support arbitrary labels e.g. `init(random length: 2000)` vs `init(zeroed length: 2000)`, `mkdir(path, creatingIntermediateDirectoriesIfRequired)` and many more?<br>&gt; A: Yes, although these are probably more controversial proposals than simply supporting multiple parameterless constructors.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
