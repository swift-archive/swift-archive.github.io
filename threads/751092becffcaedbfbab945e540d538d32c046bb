<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  6, 2015 at 10:00:00pm</p></header><div class="content"><p>One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br></p><p>Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br></p><p>    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br></p><p>The upshot is that when we see this:<br></p><p>    foo.bar()<br></p><p>…it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br></p><p>The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br></p><p>Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br></p><p>A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br></p><p>Thus:<br></p><p><br>PROPOSAL<br></p><p>Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br></p><p><br>I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8ccacafa7f3e7f6a07cdc8d9f1f30471?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Roy Fu</string> &lt;lingoerer at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Hmmmm…. interesting point.<br>I probably didn’t catch the point quite well<br>when writing obj-c or ruby or etc (I mean smalltalk), we used to focus on the Instances at runtime.<br>however, now, we should rather focus on the Types at declaration much much more. (yes, I mean inheritance is not a good idea most of the time)<br>so, I’d rather prefer to just unify simple Protocol as Types and the Protocols with associated Types when higher order Types is added (<br>e.g.<br> extension SequenceType&lt;T&gt;:Functor {<br> } <br>)<br></p><p>&gt; On Dec 7, 2015, at 12:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt; <br>&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt; <br>&gt;    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; <br>&gt; The upshot is that when we see this:<br>&gt; <br>&gt;    foo.bar()<br>&gt; <br>&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt; <br>&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt; <br>&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt; <br>&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; <br>&gt; Thus:<br>&gt; <br>&gt; <br>&gt; PROPOSAL<br>&gt; <br>&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt; <br>&gt; <br>&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>The main reason to constrain dynamic dispatch is modularity. The problems of interfering categories or monkey-patches in languages like ObjC and Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s model, it isn&#39;t possible for an extension in one module to interfere with existing protocol conformances or class hierarchies at runtime (except with @objc of course). Modules need to be compiled together to be aware of each other to interact with each other&#39;s interfaces.<br></p><p>The particular example Alexandros brings up is more an artifact of our existing implementation than desirable behavior. Two key things are missing:<br></p><p>- the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>- compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br></p><p>There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br></p><p>-Joe<br></p><p>&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt; <br>&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt; <br>&gt;    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; <br>&gt; The upshot is that when we see this:<br>&gt; <br>&gt;    foo.bar()<br>&gt; <br>&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt; <br>&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt; <br>&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt; <br>&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; <br>&gt; Thus:<br>&gt; <br>&gt; <br>&gt; PROPOSAL<br>&gt; <br>&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt; <br>&gt; <br>&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>Thanks, Joe, this is helpful. Thinking through the problem of extensions from separate modules more carefully, I see where my strawman proposal falls apart.<br></p><p>Thinking more carefully about my concerns, they boil down to two separate things:<br></p><p>1. The current static dispatch behavior is confusing, a likely source of unintended behavior &amp; thus of bugs.<br></p><p>2. Even with perfect understanding of the language, it’s (I think?) currently not possible to introduce a new extension method at multiple places the protocol hierarchy and make guarantees about subtype-appropriate behavior.<br></p><p>&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br></p><p>This would completely address my concern #1. It would make it possible to fix Alexandros’s example.<br></p><p>But doesn’t this reintroduce the “monkey collision” problem? Couldn’t two modules independently add new dynamically dispatched methods that collide when both modules are imported?<br></p><p>&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br></p><p>That would be a nice thing to have in Swift 2.2.<br></p><p>&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br></p><p>That seems entirely sensible.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 7, 2015, at 2:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; The main reason to constrain dynamic dispatch is modularity. The problems of interfering categories or monkey-patches in languages like ObjC and Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s model, it isn&#39;t possible for an extension in one module to interfere with existing protocol conformances or class hierarchies at runtime (except with @objc of course). Modules need to be compiled together to be aware of each other to interact with each other&#39;s interfaces.<br>&gt; <br>&gt; The particular example Alexandros brings up is more an artifact of our existing implementation than desirable behavior. Two key things are missing:<br>&gt; <br>&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br>&gt; <br>&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt; <br>&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt;&gt; <br>&gt;&gt;   http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt; <br>&gt;&gt; The upshot is that when we see this:<br>&gt;&gt; <br>&gt;&gt;   foo.bar()<br>&gt;&gt; <br>&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt;&gt; <br>&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt;&gt; <br>&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt; <br>&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt; <br>&gt;&gt; Thus:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; PROPOSAL<br>&gt;&gt; <br>&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 1:16 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; Thanks, Joe, this is helpful. Thinking through the problem of extensions from separate modules more carefully, I see where my strawman proposal falls apart.<br>&gt; <br>&gt; Thinking more carefully about my concerns, they boil down to two separate things:<br>&gt; <br>&gt; 1. The current static dispatch behavior is confusing, a likely source of unintended behavior &amp; thus of bugs.<br>&gt; <br>&gt; 2. Even with perfect understanding of the language, it’s (I think?) currently not possible to introduce a new extension method at multiple places the protocol hierarchy and make guarantees about subtype-appropriate behavior.<br></p><p>This is true today. I don&#39;t think it&#39;s a fundamental constraint we intend to keep in place forever.<br></p><p>&gt; <br>&gt;&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt; <br>&gt; This would completely address my concern #1. It would make it possible to fix Alexandros’s example.<br>&gt; <br>&gt; But doesn’t this reintroduce the “monkey collision” problem? Couldn’t two modules independently add new dynamically dispatched methods that collide when both modules are imported?<br></p><p>It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br>&gt; <br>&gt; That would be a nice thing to have in Swift 2.2.<br>&gt; <br>&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br>&gt; <br>&gt; That seems entirely sensible.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 2:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The main reason to constrain dynamic dispatch is modularity. The problems of interfering categories or monkey-patches in languages like ObjC and Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s model, it isn&#39;t possible for an extension in one module to interfere with existing protocol conformances or class hierarchies at runtime (except with @objc of course). Modules need to be compiled together to be aware of each other to interact with each other&#39;s interfaces.<br>&gt;&gt; <br>&gt;&gt; The particular example Alexandros brings up is more an artifact of our existing implementation than desirable behavior. Two key things are missing:<br>&gt;&gt; <br>&gt;&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br>&gt;&gt; <br>&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The upshot is that when we see this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  foo.bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSAL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt;&gt; <br>&gt;&gt; This would completely address my concern #1. It would make it possible to fix Alexandros’s example.<br>&gt;&gt; <br>&gt;&gt; But doesn’t this reintroduce the “monkey collision” problem? Couldn’t two modules independently add new dynamically dispatched methods that collide when both modules are imported?<br>&gt; <br>&gt; It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.<br></p><p>That seems like exactly how it should work. I even start typing up some thoughts on per-module namespacing, but then decided to wait for your response. Glad I did.<br></p><p>Given this, if Swift _were_ to allow extensions to protocols to add new dynamically dispatched methods, would there still be any reason left to provide static dispatch as an option (except as a compiler optimization, of course)?<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 7, 2015, at 3:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 1:16 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks, Joe, this is helpful. Thinking through the problem of extensions from separate modules more carefully, I see where my strawman proposal falls apart.<br>&gt;&gt; <br>&gt;&gt; Thinking more carefully about my concerns, they boil down to two separate things:<br>&gt;&gt; <br>&gt;&gt; 1. The current static dispatch behavior is confusing, a likely source of unintended behavior &amp; thus of bugs.<br>&gt;&gt; <br>&gt;&gt; 2. Even with perfect understanding of the language, it’s (I think?) currently not possible to introduce a new extension method at multiple places the protocol hierarchy and make guarantees about subtype-appropriate behavior.<br>&gt; <br>&gt; This is true today. I don&#39;t think it&#39;s a fundamental constraint we intend to keep in place forever.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt;&gt; <br>&gt;&gt; This would completely address my concern #1. It would make it possible to fix Alexandros’s example.<br>&gt;&gt; <br>&gt;&gt; But doesn’t this reintroduce the “monkey collision” problem? Couldn’t two modules independently add new dynamically dispatched methods that collide when both modules are imported?<br>&gt; <br>&gt; It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br>&gt;&gt; <br>&gt;&gt; That would be a nice thing to have in Swift 2.2.<br>&gt;&gt; <br>&gt;&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br>&gt;&gt; <br>&gt;&gt; That seems entirely sensible.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 2:14 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main reason to constrain dynamic dispatch is modularity. The problems of interfering categories or monkey-patches in languages like ObjC and Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s model, it isn&#39;t possible for an extension in one module to interfere with existing protocol conformances or class hierarchies at runtime (except with @objc of course). Modules need to be compiled together to be aware of each other to interact with each other&#39;s interfaces.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The particular example Alexandros brings up is more an artifact of our existing implementation than desirable behavior. Two key things are missing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - the ability for extensions to protocols to add new dynamically-dispatched methods, and<br>&gt;&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types obviously shadow non-dynamic protocol extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on for classes, to have conforming to a protocol implicitly re-declare all the protocol&#39;s methods as class methods, so that they can be overridden by subclasses in the expected way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The upshot is that when we see this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo.bar()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thus:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PROPOSAL<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>I&#39;d love to see these two key things that Joe mentioned get added.<br>Diagnostics around confusing situations is a good idea (although there<br>needs to be a way to disable it too; what if I intentionally need to use<br>the same name in a type and in an extension to one of the conformed-to<br>protocols, for various reasons?).<br></p><p>I can&#39;t support the original proposal though, of making foo.bar() use<br>dynamic dispatch. The ability to use static dispatch in most cases is<br>one of the great features of Swift, and it&#39;s something that needs to be<br>preserved, not relegated to being an optimization that can be done<br>occasionally.<br></p><p>It&#39;s also worth noting that the current behavior, where methods defined<br>in protocol extensions can&#39;t be overridden by the implementing type, may<br>actually be the desired behavior in many cases. Heck, the ability to<br>trigger this different behavior is one of the three reasons to even<br>define methods in protocol extensions instead of in the protocol (the<br>others being when you&#39;re defining it for a subset of protocol<br>implementations, and when you&#39;re defining extensions on protocols<br>imported from other modules). Removing this functionality (by making<br>foo.bar() always dynamic) means reverting back to the Swift 1.x<br>convention of having global functions to provide this behavior.<br></p><p>I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>concrete types to override these protocol extension methods (although<br>`dynamic` in this case would not imply @objc, like it does today, which<br>may be a little confusing), but that would be opt-in behavior.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt; The main reason to constrain dynamic dispatch is modularity. The problems<br>&gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt; Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s<br>&gt; model, it isn&#39;t possible for an extension in one module to interfere with<br>&gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt; of each other to interact with each other&#39;s interfaces.<br>&gt; <br>&gt; The particular example Alexandros brings up is more an artifact of our<br>&gt; existing implementation than desirable behavior. Two key things are<br>&gt; missing:<br>&gt; <br>&gt; - the ability for extensions to protocols to add new<br>&gt; dynamically-dispatched methods, and<br>&gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt; obviously shadow non-dynamic protocol extensions.<br>&gt; <br>&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on<br>&gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt; by subclasses in the expected way.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt; &gt; <br>&gt; &gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt; &gt; <br>&gt; &gt;    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; &gt; <br>&gt; &gt; The upshot is that when we see this:<br>&gt; &gt; <br>&gt; &gt;    foo.bar()<br>&gt; &gt; <br>&gt; &gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt; &gt; <br>&gt; &gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt; &gt; <br>&gt; &gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt; &gt; <br>&gt; &gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; &gt; <br>&gt; &gt; Thus:<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; PROPOSAL<br>&gt; &gt; <br>&gt; &gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt; &gt; <br>&gt; &gt; Cheers,<br>&gt; &gt; <br>&gt; &gt; Paul<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 01:00:00am</p></header><div class="content"><p>On Tue, Dec 8, 2015 at 1:11 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d love to see these two key things that Joe mentioned get added.<br>&gt; Diagnostics around confusing situations is a good idea (although there<br>&gt; needs to be a way to disable it too; what if I intentionally need to use<br>&gt; the same name in a type and in an extension to one of the conformed-to<br>&gt; protocols, for various reasons?).<br>&gt;<br>&gt; I can&#39;t support the original proposal though, of making foo.bar() use<br>&gt; dynamic dispatch. The ability to use static dispatch in most cases is<br>&gt; one of the great features of Swift, and it&#39;s something that needs to be<br>&gt; preserved, not relegated to being an optimization that can be done<br>&gt; occasionally.<br>&gt;<br>&gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; actually be the desired behavior in many cases.<br></p><p><br>It is indeed the only logical choice; for example I could make a private<br>protocol extension - obviously, a class that has no access to it won&#39;t be<br>able to override it.<br></p><p><br>&gt; Heck, the ability to<br>&gt; trigger this different behavior is one of the three reasons to even<br>&gt; define methods in protocol extensions instead of in the protocol (the<br>&gt; others being when you&#39;re defining it for a subset of protocol<br>&gt; implementations, and when you&#39;re defining extensions on protocols<br>&gt; imported from other modules). Removing this functionality (by making<br>&gt; foo.bar() always dynamic) means reverting back to the Swift 1.x<br>&gt; convention of having global functions to provide this behavior.<br>&gt;<br>&gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; concrete types to override these protocol extension methods (although<br>&gt;<br></p><p>You currently allow it by declaring method to be part of protocol, which<br>means that an entry for some method is reserved in the protocol witness<br>table. This entry will be filled either by concrete method, if present, or<br>by protocol default implementation.<br></p><p><br>&gt; `dynamic` in this case would not imply @objc, like it does today, which<br>&gt; may be a little confusing), but that would be opt-in behavior.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt; &gt; The main reason to constrain dynamic dispatch is modularity. The problems<br>&gt; &gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt; &gt; Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s<br>&gt; &gt; model, it isn&#39;t possible for an extension in one module to interfere with<br>&gt; &gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt; &gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt; &gt; of each other to interact with each other&#39;s interfaces.<br>&gt; &gt;<br>&gt; &gt; The particular example Alexandros brings up is more an artifact of our<br>&gt; &gt; existing implementation than desirable behavior. Two key things are<br>&gt; &gt; missing:<br>&gt; &gt;<br>&gt; &gt; - the ability for extensions to protocols to add new<br>&gt; &gt; dynamically-dispatched methods, and<br>&gt; &gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt; &gt; obviously shadow non-dynamic protocol extensions.<br>&gt; &gt;<br>&gt; &gt; There is a related behavior change proposal Doug Gregor&#39;s been working on<br>&gt; &gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt; &gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt; &gt; by subclasses in the expected way.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt; &gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; One of the few things in Swift 2 that feels to me like a design flaw<br>&gt; is the way Swift mixes static and dynamic method dispatch.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Alexandros Salazar gives an excellent explanation of this problem —<br>&gt; and I agree wholeheartedly with his title for the article:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;    http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The upshot is that when we see this:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;    foo.bar()<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; …it’s very hard to know how the compiler will determine which<br>&gt; implementation of bar() to use. It might use static dispatch; it might use<br>&gt; dynamic dispatch.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The rules that govern this are arcane, and hard to remember. They have<br>&gt; the feeling of being a “gotcha” question for job interviews — always a red<br>&gt; flag for language features.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Even if you remember the rules, the information needed to determine<br>&gt; whether dispatch is static or dynamic is hard to track down. It depends on<br>&gt; whether bar()’s implementation comes from an extension, whether the<br>&gt; extension method appeared on the extended protocol, and whether the<br>&gt; inferred type of foo is the protocol itself or an implementing type.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to<br>&gt; determine. This runs contrary to Swift’s stated goal of prioritizing<br>&gt; clarity at the point of API use, and its general pattern of making intent<br>&gt; explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Thus:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; PROPOSAL<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always<br>&gt; use _only_ the runtime type of foo to determine which implementation of<br>&gt; bar() to use. If an extension method collision occurs when a type<br>&gt; implements multiple protocols, require the type to explicitly specify which<br>&gt; one to use (as Swift already requires the caller to do at the point of<br>&gt; invocation).<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I mean this proposal somewhat as a strawman. It’s such an obvious<br>&gt; choice, I’m sure there were good reasons not to do it. But I’d like to<br>&gt; propose the obvious solution in order to understand what’s wrong with it. I<br>&gt; realize static dispatch precludes some optimizations, but I doubt that this<br>&gt; alone drove the design choice. I see no safety or expressiveness upside to<br>&gt; the way it works now.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Cheers,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Paul<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/2bcec9f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015, at 02:18 PM, ilya wrote:<br>&gt;<br>&gt;&gt;<br>I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt;&gt;<br>concrete types to override these protocol extension methods (although<br>&gt;<br>&gt; You currently allow it by declaring method to be part of protocol,<br>&gt; which means that an entry for some method is reserved in the protocol<br>&gt; witness table. This entry will be filled either by concrete method, if<br>&gt; present, or by protocol default implementation.<br></p><p>Sure, if you define the protocol yourself, and you want the method to be<br>available for all instances of the protocol. My `dynamic` suggestion is<br>meant to cover the cases of a) you didn&#39;t define the protocol yourself,<br>but you want to define a method that can be overridden by any class that<br>can see your protocol extension, or b) you want to define the method<br>only for a subset of protocol implementations (e.g. with a `where`<br>clause) but still want to allow for overriding.<br></p><p>That said, I think `dynamic` is the wrong keyword here, because it means<br>runtime dynamic dispatch, and what I&#39;m really talking about is just the<br>ability to have a separate protocol witness table for the extension.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/8447d67e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 01:00:00am</p></header><div class="content"><p>On Tue, Dec 8, 2015 at 1:22 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br></p><p>&gt; On Mon, Dec 7, 2015, at 02:18 PM, ilya wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; concrete types to override these protocol extension methods (although<br>&gt;<br>&gt;<br>&gt; You currently allow it by declaring method to be part of protocol, which<br>&gt; means that an entry for some method is reserved in the protocol witness<br>&gt; table. This entry will be filled either by concrete method, if present, or<br>&gt; by protocol default implementation.<br>&gt;<br>&gt;<br>&gt; Sure, if you define the protocol yourself, and you want the method to be<br>&gt; available for all instances of the protocol. My `dynamic` suggestion is<br>&gt; meant to cover the cases of a) you didn&#39;t define the protocol yourself, but<br>&gt; you want to define a method that can be overridden by any class that can<br>&gt; see your protocol extension, or b) you want to define the method only for a<br>&gt; subset of protocol implementations (e.g. with a `where` clause) but still<br>&gt; want to allow for overriding.<br>&gt;<br></p><p>Interesting. I think your use case a) could work like this<br></p><p>protocol PP1 :P1 {<br>    func overrideable() -&gt; Int<br>}<br></p><p>extension P1 :PP1 { // doesn&#39;t currently compile with :PP1 inheritance<br>clause<br>    func overrideable() -&gt; Int {<br>        return 1<br>    }<br>}<br></p><p>extension C1 {<br>    func overrideable() -&gt; Int {<br>        return 0<br>    }<br>}<br></p><p>(C1() as P1).overrideable()<br></p><p><br>&gt; That said, I think `dynamic` is the wrong keyword here, because it means<br>&gt; runtime dynamic dispatch, and what I&#39;m really talking about is just the<br>&gt; ability to have a separate protocol witness table for the extension.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6dd386c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; The ability to use static dispatch in most cases is one of the great features of Swift, and it&#39;s something that needs to be preserved, not relegated to being an optimization that can be done occasionally.<br></p><p>Can you think of a situation where that’s the desired semantics, as opposed to either a desirable optimization or a confusing workaround for the “monkey collision” problem? (I can’t see the use case, but I’m open to hearing it!)<br></p><p>&gt; It&#39;s also worth noting that the current behavior, where methods defined in protocol extensions can&#39;t be overridden by the implementing type, may actually be the desired behavior in many cases.<br></p><p>If you don’t want a method to be overridable, that’s what “final” is for.<br></p><p>The current behavior, in which a method is silently shadowed, does not seem to be to be a desirable behavior in any situation. The compiler warnings/errors Joe Groff proposed seem like a bare minimum, but I’d prefer to eliminate the situation that needs to be warned about in the first place.<br></p><p>Cheers, P<br></p><p>&gt; On Dec 7, 2015, at 4:11 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d love to see these two key things that Joe mentioned get added.<br>&gt; Diagnostics around confusing situations is a good idea (although there<br>&gt; needs to be a way to disable it too; what if I intentionally need to use<br>&gt; the same name in a type and in an extension to one of the conformed-to<br>&gt; protocols, for various reasons?).<br>&gt; <br>&gt; I can&#39;t support the original proposal though, of making foo.bar() use<br>&gt; dynamic dispatch. The ability to use static dispatch in most cases is<br>&gt; one of the great features of Swift, and it&#39;s something that needs to be<br>&gt; preserved, not relegated to being an optimization that can be done<br>&gt; occasionally.<br>&gt; <br>&gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; actually be the desired behavior in many cases. Heck, the ability to<br>&gt; trigger this different behavior is one of the three reasons to even<br>&gt; define methods in protocol extensions instead of in the protocol (the<br>&gt; others being when you&#39;re defining it for a subset of protocol<br>&gt; implementations, and when you&#39;re defining extensions on protocols<br>&gt; imported from other modules). Removing this functionality (by making<br>&gt; foo.bar() always dynamic) means reverting back to the Swift 1.x<br>&gt; convention of having global functions to provide this behavior.<br>&gt; <br>&gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; concrete types to override these protocol extension methods (although<br>&gt; `dynamic` in this case would not imply @objc, like it does today, which<br>&gt; may be a little confusing), but that would be opt-in behavior.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt;&gt; The main reason to constrain dynamic dispatch is modularity. The problems<br>&gt;&gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt;&gt; Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s<br>&gt;&gt; model, it isn&#39;t possible for an extension in one module to interfere with<br>&gt;&gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt;&gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt;&gt; of each other to interact with each other&#39;s interfaces.<br>&gt;&gt; <br>&gt;&gt; The particular example Alexandros brings up is more an artifact of our<br>&gt;&gt; existing implementation than desirable behavior. Two key things are<br>&gt;&gt; missing:<br>&gt;&gt; <br>&gt;&gt; - the ability for extensions to protocols to add new<br>&gt;&gt; dynamically-dispatched methods, and<br>&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt;&gt; obviously shadow non-dynamic protocol extensions.<br>&gt;&gt; <br>&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on<br>&gt;&gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt;&gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt;&gt; by subclasses in the expected way.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The upshot is that when we see this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  foo.bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSAL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 02:00:00am</p></header><div class="content"><p>On Tuesday, December 8, 2015, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; The ability to use static dispatch in most cases is one of the great<br>&gt; features of Swift, and it&#39;s something that needs to be preserved, not<br>&gt; relegated to being an optimization that can be done occasionally.<br>&gt;<br>&gt; Can you think of a situation where that’s the desired semantics, as<br>&gt; opposed to either a desirable optimization or a confusing workaround for<br>&gt; the “monkey collision” problem? (I can’t see the use case, but I’m open to<br>&gt; hearing it!)<br>&gt;<br>&gt;<br>Sure, private protocol extension. For example,<br></p><p>public protocol Animal {<br>  func greet()<br>  func sit()<br>  func run()<br>}<br></p><p>private extension Animal {<br>  func compete() { greet(); sit(); run()}<br>}<br></p><p>// we are provided with animal<br>... animal.compete()...<br></p><p><br>&gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; actually be the desired behavior in many cases.<br>&gt;<br>&gt; If you don’t want a method to be overridable, that’s what “final” is for.<br>&gt;<br>&gt; The current behavior, in which a method is silently shadowed, does not<br>&gt; seem to be to be a desirable behavior in any situation. The compiler<br>&gt; warnings/errors Joe Groff proposed seem like a bare minimum, but I’d prefer<br>&gt; to eliminate the situation that needs to be warned about in the first place.<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt; &gt; On Dec 7, 2015, at 4:11 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;d love to see these two key things that Joe mentioned get added.<br>&gt; &gt; Diagnostics around confusing situations is a good idea (although there<br>&gt; &gt; needs to be a way to disable it too; what if I intentionally need to use<br>&gt; &gt; the same name in a type and in an extension to one of the conformed-to<br>&gt; &gt; protocols, for various reasons?).<br>&gt; &gt;<br>&gt; &gt; I can&#39;t support the original proposal though, of making foo.bar() use<br>&gt; &gt; dynamic dispatch. The ability to use static dispatch in most cases is<br>&gt; &gt; one of the great features of Swift, and it&#39;s something that needs to be<br>&gt; &gt; preserved, not relegated to being an optimization that can be done<br>&gt; &gt; occasionally.<br>&gt; &gt;<br>&gt; &gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; &gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; &gt; actually be the desired behavior in many cases. Heck, the ability to<br>&gt; &gt; trigger this different behavior is one of the three reasons to even<br>&gt; &gt; define methods in protocol extensions instead of in the protocol (the<br>&gt; &gt; others being when you&#39;re defining it for a subset of protocol<br>&gt; &gt; implementations, and when you&#39;re defining extensions on protocols<br>&gt; &gt; imported from other modules). Removing this functionality (by making<br>&gt; &gt; foo.bar() always dynamic) means reverting back to the Swift 1.x<br>&gt; &gt; convention of having global functions to provide this behavior.<br>&gt; &gt;<br>&gt; &gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; &gt; concrete types to override these protocol extension methods (although<br>&gt; &gt; `dynamic` in this case would not imply @objc, like it does today, which<br>&gt; &gt; may be a little confusing), but that would be opt-in behavior.<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt;<br>&gt; &gt; On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt; &gt;&gt; The main reason to constrain dynamic dispatch is modularity. The<br>&gt; problems<br>&gt; &gt;&gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt; &gt;&gt; Ruby with late-bound dispatch and open classes are well-known. In<br>&gt; Swift&#39;s<br>&gt; &gt;&gt; model, it isn&#39;t possible for an extension in one module to interfere<br>&gt; with<br>&gt; &gt;&gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt; &gt;&gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt; &gt;&gt; of each other to interact with each other&#39;s interfaces.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The particular example Alexandros brings up is more an artifact of our<br>&gt; &gt;&gt; existing implementation than desirable behavior. Two key things are<br>&gt; &gt;&gt; missing:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - the ability for extensions to protocols to add new<br>&gt; &gt;&gt; dynamically-dispatched methods, and<br>&gt; &gt;&gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt; &gt;&gt; obviously shadow non-dynamic protocol extensions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working<br>&gt; on<br>&gt; &gt;&gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt; &gt;&gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt; &gt;&gt; by subclasses in the expected way.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Joe<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw<br>&gt; is the way Swift mixes static and dynamic method dispatch.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem —<br>&gt; and I agree wholeheartedly with his title for the article:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The upshot is that when we see this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  foo.bar()<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; …it’s very hard to know how the compiler will determine which<br>&gt; implementation of bar() to use. It might use static dispatch; it might use<br>&gt; dynamic dispatch.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have<br>&gt; the feeling of being a “gotcha” question for job interviews — always a red<br>&gt; flag for language features.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Even if you remember the rules, the information needed to determine<br>&gt; whether dispatch is static or dynamic is hard to track down. It depends on<br>&gt; whether bar()’s implementation comes from an extension, whether the<br>&gt; extension method appeared on the extended protocol, and whether the<br>&gt; inferred type of foo is the protocol itself or an implementing type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to<br>&gt; determine. This runs contrary to Swift’s stated goal of prioritizing<br>&gt; clarity at the point of API use, and its general pattern of making intent<br>&gt; explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thus:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; PROPOSAL<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always<br>&gt; use _only_ the runtime type of foo to determine which implementation of<br>&gt; bar() to use. If an extension method collision occurs when a type<br>&gt; implements multiple protocols, require the type to explicitly specify which<br>&gt; one to use (as Swift already requires the caller to do at the point of<br>&gt; invocation).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious<br>&gt; choice, I’m sure there were good reasons not to do it. But I’d like to<br>&gt; propose the obvious solution in order to understand what’s wrong with it. I<br>&gt; realize static dispatch precludes some optimizations, but I doubt that this<br>&gt; alone drove the design choice. I see no safety or expressiveness upside to<br>&gt; the way it works now.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Paul<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/04079c06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>There’s no semantic difference between static &amp; dynamic dispatch here. Static dispatch is an optimization the compiler can make.<br></p><p>(I’m assuming that compete() is secretly module-scoped, as Joe said it would be.)<br></p><p>P<br></p><p><br>&gt; On Dec 7, 2015, at 5:04 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tuesday, December 8, 2015, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; The ability to use static dispatch in most cases is one of the great features of Swift, and it&#39;s something that needs to be preserved, not relegated to being an optimization that can be done occasionally.<br>&gt; <br>&gt; Can you think of a situation where that’s the desired semantics, as opposed to either a desirable optimization or a confusing workaround for the “monkey collision” problem? (I can’t see the use case, but I’m open to hearing it!)<br>&gt; <br>&gt; Sure, private protocol extension. For example, <br>&gt; <br>&gt; public protocol Animal {<br>&gt;   func greet()<br>&gt;   func sit()<br>&gt;   func run()<br>&gt; }<br>&gt; <br>&gt; private extension Animal {<br>&gt;   func compete() { greet(); sit(); run()}<br>&gt; }<br>&gt; <br>&gt; // we are provided with animal <br>&gt; ... animal.compete()...<br>&gt; <br>&gt; <br>&gt; &gt; It&#39;s also worth noting that the current behavior, where methods defined in protocol extensions can&#39;t be overridden by the implementing type, may actually be the desired behavior in many cases.<br>&gt; <br>&gt; If you don’t want a method to be overridable, that’s what “final” is for.<br>&gt; <br>&gt; The current behavior, in which a method is silently shadowed, does not seem to be to be a desirable behavior in any situation. The compiler warnings/errors Joe Groff proposed seem like a bare minimum, but I’d prefer to eliminate the situation that needs to be warned about in the first place.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; &gt; On Dec 7, 2015, at 4:11 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;d love to see these two key things that Joe mentioned get added.<br>&gt; &gt; Diagnostics around confusing situations is a good idea (although there<br>&gt; &gt; needs to be a way to disable it too; what if I intentionally need to use<br>&gt; &gt; the same name in a type and in an extension to one of the conformed-to<br>&gt; &gt; protocols, for various reasons?).<br>&gt; &gt;<br>&gt; &gt; I can&#39;t support the original proposal though, of making foo.bar() use<br>&gt; &gt; dynamic dispatch. The ability to use static dispatch in most cases is<br>&gt; &gt; one of the great features of Swift, and it&#39;s something that needs to be<br>&gt; &gt; preserved, not relegated to being an optimization that can be done<br>&gt; &gt; occasionally.<br>&gt; &gt;<br>&gt; &gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; &gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; &gt; actually be the desired behavior in many cases. Heck, the ability to<br>&gt; &gt; trigger this different behavior is one of the three reasons to even<br>&gt; &gt; define methods in protocol extensions instead of in the protocol (the<br>&gt; &gt; others being when you&#39;re defining it for a subset of protocol<br>&gt; &gt; implementations, and when you&#39;re defining extensions on protocols<br>&gt; &gt; imported from other modules). Removing this functionality (by making<br>&gt; &gt; foo.bar() always dynamic) means reverting back to the Swift 1.x<br>&gt; &gt; convention of having global functions to provide this behavior.<br>&gt; &gt;<br>&gt; &gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; &gt; concrete types to override these protocol extension methods (although<br>&gt; &gt; `dynamic` in this case would not imply @objc, like it does today, which<br>&gt; &gt; may be a little confusing), but that would be opt-in behavior.<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt;<br>&gt; &gt; On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt; &gt;&gt; The main reason to constrain dynamic dispatch is modularity. The problems<br>&gt; &gt;&gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt; &gt;&gt; Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s<br>&gt; &gt;&gt; model, it isn&#39;t possible for an extension in one module to interfere with<br>&gt; &gt;&gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt; &gt;&gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt; &gt;&gt; of each other to interact with each other&#39;s interfaces.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The particular example Alexandros brings up is more an artifact of our<br>&gt; &gt;&gt; existing implementation than desirable behavior. Two key things are<br>&gt; &gt;&gt; missing:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - the ability for extensions to protocols to add new<br>&gt; &gt;&gt; dynamically-dispatched methods, and<br>&gt; &gt;&gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt; &gt;&gt; obviously shadow non-dynamic protocol extensions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on<br>&gt; &gt;&gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt; &gt;&gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt; &gt;&gt; by subclasses in the expected way.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Joe<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future &lt;http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The upshot is that when we see this:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  foo.bar()<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thus:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; PROPOSAL<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Cheers,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Paul<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt;  &lt;&gt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/b86af428/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fb5a6986048ff63d65b0f34fd1ecd1a9?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;paul at innig.net&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; The ability to use static dispatch in most cases is one of the great features of Swift, and it&#39;s something that needs to be preserved, not relegated to being an optimization that can be done occasionally.<br></p><p>Can you think of a situation where that’s the desired semantics, as opposed to either a desirable optimization or a confusing workaround for the “monkey collision” problem? (I can’t see the use case, but I’m open to hearing it!)<br></p><p>&gt; It&#39;s also worth noting that the current behavior, where methods defined in protocol extensions can&#39;t be overridden by the implementing type, may actually be the desired behavior in many cases.<br></p><p>If you don’t want a method to be overridable, that’s what “final” is for.<br></p><p>The current behavior, in which a method is silently shadowed, does not seem to be to be a desirable behavior in any situation. The compiler warnings/errors Joe Groff proposed seem like a bare minimum, but I’d prefer to eliminate the situation that needs to be warned about in the first place.<br></p><p>Cheers, P<br></p><p>&gt; On Dec 7, 2015, at 4:11 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d love to see these two key things that Joe mentioned get added.<br>&gt; Diagnostics around confusing situations is a good idea (although there<br>&gt; needs to be a way to disable it too; what if I intentionally need to use<br>&gt; the same name in a type and in an extension to one of the conformed-to<br>&gt; protocols, for various reasons?).<br>&gt; <br>&gt; I can&#39;t support the original proposal though, of making foo.bar() use<br>&gt; dynamic dispatch. The ability to use static dispatch in most cases is<br>&gt; one of the great features of Swift, and it&#39;s something that needs to be<br>&gt; preserved, not relegated to being an optimization that can be done<br>&gt; occasionally.<br>&gt; <br>&gt; It&#39;s also worth noting that the current behavior, where methods defined<br>&gt; in protocol extensions can&#39;t be overridden by the implementing type, may<br>&gt; actually be the desired behavior in many cases. Heck, the ability to<br>&gt; trigger this different behavior is one of the three reasons to even<br>&gt; define methods in protocol extensions instead of in the protocol (the<br>&gt; others being when you&#39;re defining it for a subset of protocol<br>&gt; implementations, and when you&#39;re defining extensions on protocols<br>&gt; imported from other modules). Removing this functionality (by making<br>&gt; foo.bar() always dynamic) means reverting back to the Swift 1.x<br>&gt; convention of having global functions to provide this behavior.<br>&gt; <br>&gt; I wouldn&#39;t mind seeing something like the `dynamic` keyword to allow<br>&gt; concrete types to override these protocol extension methods (although<br>&gt; `dynamic` in this case would not imply @objc, like it does today, which<br>&gt; may be a little confusing), but that would be opt-in behavior.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Mon, Dec 7, 2015, at 12:14 PM, Joe Groff via swift-evolution wrote:<br>&gt;&gt; The main reason to constrain dynamic dispatch is modularity. The problems<br>&gt;&gt; of interfering categories or monkey-patches in languages like ObjC and<br>&gt;&gt; Ruby with late-bound dispatch and open classes are well-known. In Swift&#39;s<br>&gt;&gt; model, it isn&#39;t possible for an extension in one module to interfere with<br>&gt;&gt; existing protocol conformances or class hierarchies at runtime (except<br>&gt;&gt; with @objc of course). Modules need to be compiled together to be aware<br>&gt;&gt; of each other to interact with each other&#39;s interfaces.<br>&gt;&gt; <br>&gt;&gt; The particular example Alexandros brings up is more an artifact of our<br>&gt;&gt; existing implementation than desirable behavior. Two key things are<br>&gt;&gt; missing:<br>&gt;&gt; <br>&gt;&gt; - the ability for extensions to protocols to add new<br>&gt;&gt; dynamically-dispatched methods, and<br>&gt;&gt; - compiler quality work to diagnose confusing cases where concrete types<br>&gt;&gt; obviously shadow non-dynamic protocol extensions.<br>&gt;&gt; <br>&gt;&gt; There is a related behavior change proposal Doug Gregor&#39;s been working on<br>&gt;&gt; for classes, to have conforming to a protocol implicitly re-declare all<br>&gt;&gt; the protocol&#39;s methods as class methods, so that they can be overridden<br>&gt;&gt; by subclasses in the expected way.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 8:17 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The upshot is that when we see this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   foo.bar()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine. This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSAL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  7, 2015 at 11:00:00pm</p></header><div class="content"><p>Could you provide an example? I tried playing with protocol extensions,<br>modelling this situation:<br></p><p>&gt; If an extension method collision occurs when a type implements multiple<br>protocols,<br></p><p>but so far all examples I found where one would see a collision are<br>disallowed by compiler, e.g.<br></p><p><br>protocol P1 {<br>    func something() -&gt; Int<br>}<br></p><p>protocol P2 {<br>    func something() -&gt; Int<br>    func another() -&gt; Int<br>}<br></p><p>extension P1 {<br></p><p>    func something() -&gt; Int {<br>        return 1<br>    }<br></p><p>    func another() -&gt; Int {<br>        return 1<br>    }<br>}<br></p><p>extension P2 {<br></p><p>    func something() -&gt; Int {<br>        return 2<br>    }<br></p><p>    func another() -&gt; Int {<br>        return 2<br>    }<br>}<br></p><p>class C1: P1 { // &lt;- P1, P2 here doesn&#39;t compile<br></p><p>    func something() -&gt; Int {<br>        return 0<br>    }<br></p><p>}<br></p><p>class C2: P2 {<br></p><p>}<br></p><p>class C3: P1, P2 {<br></p><p>    func something() -&gt; Int {<br>        return 0<br>    }<br></p><p>    func another() -&gt; Int {<br>        return 0<br>    }<br></p><p>}<br></p><p>On Mon, Dec 7, 2015 at 7:17 AM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One of the few things in Swift 2 that feels to me like a design flaw is<br>&gt; the way Swift mixes static and dynamic method dispatch.<br>&gt;<br>&gt; Alexandros Salazar gives an excellent explanation of this problem — and I<br>&gt; agree wholeheartedly with his title for the article:<br>&gt;<br>&gt;     http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;<br>&gt; The upshot is that when we see this:<br>&gt;<br>&gt;     foo.bar()<br>&gt;<br>&gt; …it’s very hard to know how the compiler will determine which<br>&gt; implementation of bar() to use. It might use static dispatch; it might use<br>&gt; dynamic dispatch.<br>&gt;<br>&gt; The rules that govern this are arcane, and hard to remember. They have the<br>&gt; feeling of being a “gotcha” question for job interviews — always a red flag<br>&gt; for language features.<br>&gt;<br>&gt; Even if you remember the rules, the information needed to determine<br>&gt; whether dispatch is static or dynamic is hard to track down. It depends on<br>&gt; whether bar()’s implementation comes from an extension, whether the<br>&gt; extension method appeared on the extended protocol, and whether the<br>&gt; inferred type of foo is the protocol itself or an implementing type.<br>&gt;<br>&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to<br>&gt; determine. This runs contrary to Swift’s stated goal of prioritizing<br>&gt; clarity at the point of API use, and its general pattern of making intent<br>&gt; explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt;<br>&gt; Thus:<br>&gt;<br>&gt;<br>&gt; PROPOSAL<br>&gt;<br>&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use<br>&gt; _only_ the runtime type of foo to determine which implementation of bar()<br>&gt; to use. If an extension method collision occurs when a type implements<br>&gt; multiple protocols, require the type to explicitly specify which one to use<br>&gt; (as Swift already requires the caller to do at the point of invocation).<br>&gt;<br>&gt;<br>&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice,<br>&gt; I’m sure there were good reasons not to do it. But I’d like to propose the<br>&gt; obvious solution in order to understand what’s wrong with it. I realize<br>&gt; static dispatch precludes some optimizations, but I doubt that this alone<br>&gt; drove the design choice. I see no safety or expressiveness upside to the<br>&gt; way it works now.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c38f1b91/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 12:00:00am</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 7:17 AM, Paul Cantrell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One of the few things in Swift 2 that feels to me like a design flaw is<br>&gt; the way Swift mixes static and dynamic method dispatch.<br>&gt;<br>&gt; Alexandros Salazar gives an excellent explanation of this problem — and I<br>&gt; agree wholeheartedly with his title for the article:<br>&gt;<br>&gt;     http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;<br>&gt; The upshot is that when we see this:<br>&gt;<br>&gt;     foo.bar()<br>&gt;<br>&gt; …it’s very hard to know how the compiler will determine which<br>&gt; implementation of bar() to use. It might use static dispatch; it might use<br>&gt; dynamic dispatch.<br>&gt;<br>&gt; The rules that govern this are arcane, and hard to remember. They have the<br>&gt; feeling of being a “gotcha” question for job interviews — always a red flag<br>&gt; for language features.<br>&gt;<br>&gt; Even if you remember the rules, the information needed to determine<br>&gt; whether dispatch is static or dynamic is hard to track down. It depends on<br>&gt; whether bar()’s implementation comes from an extension, whether the<br>&gt; extension method appeared on the extended protocol, and whether the<br>&gt; inferred type of foo is the protocol itself or an implementing type.<br>&gt;<br>&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to<br>&gt; determine.<br></p><p><br>I must admit I&#39;m having difficulty understanding why it&#39;s a big deal<br>whether the dispatch will be static or dynamic. This seems like an<br>implementation detail; any &quot;dynamic dispatch&quot; in the aforementioned sense<br>can actually became static for a final class.<br></p><p>I understand there can be a confusion about the method called when the<br>protocol contains a method implementation, but there are some simple ways<br>to understand why things work as they do. Just think about function defined<br>as having a &quot;magic prefix&quot; that corresponds technically to vtable where<br>they can be located:<br></p><p>class C {<br>   func C_f // declares C.C_f<br>}<br></p><p>protocol P {<br>  func P_f<br>}<br></p><p>// implementation of P.P_f<br></p><p>extension C:P {<br>  // declares that C.C_f = C.P_f<br>}<br></p><p>(C() as C).f -&gt; calls C.C_f = C.P_f<br>(C() as P).f -&gt; calls P.P_f<br></p><p><br>&gt; This runs contrary to Swift’s stated goal of prioritizing clarity at the<br>&gt; point of API use, and its general pattern of making intent explicit. And it<br>&gt; feels dangerous — a wellspring of insidious bugs.<br>&gt;<br>&gt; Thus:<br>&gt;<br>&gt;<br>&gt; PROPOSAL<br>&gt;<br>&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use<br>&gt; _only_ the runtime type of foo to determine which implementation of bar()<br>&gt; to use. If an extension method collision occurs when a type implements<br>&gt; multiple protocols, require the type to explicitly specify which one to use<br>&gt; (as Swift already requires the caller to do at the point of invocation).<br>&gt;<br>&gt;<br>&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice,<br>&gt; I’m sure there were good reasons not to do it. But I’d like to propose the<br>&gt; obvious solution in order to understand what’s wrong with it. I realize<br>&gt; static dispatch precludes some optimizations, but I doubt that this alone<br>&gt; drove the design choice. I see no safety or expressiveness upside to the<br>&gt; way it works now.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/b0a48fd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; I must admit I&#39;m having difficulty understanding why it&#39;s a big deal whether the dispatch will be static or dynamic. This seems like an implementation detail; any &quot;dynamic dispatch&quot; in the aforementioned sense can actually became static for a final class.<br></p><p><br>It’s not just an implementation detail. The original article demonstrates this compellingly, I think.<br></p><p>Yes, it’s true that, as an optimization, the compiler can choose to use static dispatch in situations where doing so makes no difference (e.g. calling a final method, calling a private method with no overrides, etc.).<br></p><p>However, there are situations where static dispatch changes the behavior of the code. At that point, it’s a semantic difference. It’s those cases I’m concerned about.<br></p><p>&gt; Just think about function defined as having a &quot;magic prefix&quot; that corresponds technically to vtable where they can be located:<br></p><p><br>It’s not that it’s hard to understand what’s happening if you already know that a call uses static dispatch. The problem is that it’s difficult to determine whether it does.<br></p><p>• • •<br></p><p>Note that your example code with C_f and P_f does not demonstrate the problem at hand. It’s worth working through why.<br></p><p>Translating your pseudocode into actual Swift, this does not compile:<br></p><p>    class C {<br>        func f() {<br>            print(&quot;C_f&quot;)<br>        }<br>    }<br></p><p>    protocol P {<br>        func f()<br>    }<br></p><p>    extension C: P {<br>        func f() {  // compiler error here<br>            print(&quot;P_f&quot;)<br>        }<br>    }<br></p><p>I imagine that you were thinking of something along these lines:<br></p><p>    class C {<br>        func f() {<br>            print(&quot;C_f&quot;)<br>        }<br>    }<br></p><p>    protocol P {<br>        func f()  // remember this line<br>    }<br></p><p>    extension P {<br>        func f() {<br>            print(&quot;P_f&quot;)<br>        }<br>    }<br></p><p>    extension C: P { }  // C: P now separate from extension impl of f()<br></p><p>However, this does not behave as you think it does:<br></p><p>    (C() as C).f()  // C_f<br>    (C() as P).f()  // C_f<br></p><p>However again, if you remove the line marked “remember this line,” then the code does do what you think it does:<br></p><p>    (C() as C).f()  // C_f<br>    (C() as P).f()  // P_f<br></p><p>I’d say that if you got confused in the course of explaining how it&#39;s not confusing … well, that’s pretty good evidence that it is indeed confusing.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 7, 2015, at 3:56 PM, ilya &lt;ilya.nikokoshev at gmail.com &lt;mailto:ilya.nikokoshev at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 7:17 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; One of the few things in Swift 2 that feels to me like a design flaw is the way Swift mixes static and dynamic method dispatch.<br>&gt; <br>&gt; Alexandros Salazar gives an excellent explanation of this problem — and I agree wholeheartedly with his title for the article:<br>&gt; <br>&gt;     http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future &lt;http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future&gt;<br>&gt; <br>&gt; The upshot is that when we see this:<br>&gt; <br>&gt;     foo.bar()<br>&gt; <br>&gt; …it’s very hard to know how the compiler will determine which implementation of bar() to use. It might use static dispatch; it might use dynamic dispatch.<br>&gt; <br>&gt; The rules that govern this are arcane, and hard to remember. They have the feeling of being a “gotcha” question for job interviews — always a red flag for language features.<br>&gt; <br>&gt; Even if you remember the rules, the information needed to determine whether dispatch is static or dynamic is hard to track down. It depends on whether bar()’s implementation comes from an extension, whether the extension method appeared on the extended protocol, and whether the inferred type of foo is the protocol itself or an implementing type.<br>&gt; <br>&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to determine.<br>&gt; <br>&gt; I must admit I&#39;m having difficulty understanding why it&#39;s a big deal whether the dispatch will be static or dynamic. This seems like an implementation detail; any &quot;dynamic dispatch&quot; in the aforementioned sense can actually became static for a final class.<br>&gt; <br>&gt; I understand there can be a confusion about the method called when the protocol contains a method implementation, but there are some simple ways to understand why things work as they do. Just think about function defined as having a &quot;magic prefix&quot; that corresponds technically to vtable where they can be located:<br>&gt; <br>&gt; class C {<br>&gt;    func C_f // declares C.C_f<br>&gt; }<br>&gt; <br>&gt; protocol P {<br>&gt;   func P_f<br>&gt; }<br>&gt; <br>&gt; // implementation of P.P_f<br>&gt; <br>&gt; extension C:P {<br>&gt;   // declares that C.C_f = C.P_f<br>&gt; }<br>&gt; <br>&gt; (C() as C).f -&gt; calls C.C_f = C.P_f<br>&gt; (C() as P).f -&gt; calls P.P_f<br>&gt;  <br>&gt; This runs contrary to Swift’s stated goal of prioritizing clarity at the point of API use, and its general pattern of making intent explicit. And it feels dangerous — a wellspring of insidious bugs.<br>&gt; <br>&gt; Thus:<br>&gt; <br>&gt; <br>&gt; PROPOSAL<br>&gt; <br>&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use _only_ the runtime type of foo to determine which implementation of bar() to use. If an extension method collision occurs when a type implements multiple protocols, require the type to explicitly specify which one to use (as Swift already requires the caller to do at the point of invocation).<br>&gt; <br>&gt; <br>&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice, I’m sure there were good reasons not to do it. But I’d like to propose the obvious solution in order to understand what’s wrong with it. I realize static dispatch precludes some optimizations, but I doubt that this alone drove the design choice. I see no safety or expressiveness upside to the way it works now.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/d2d47073/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: Universal dynamic dispatch for method calls</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 01:00:00am</p></header><div class="content"><p>Yep, my example contains an empty extension C:P - as you correctly notes,<br>that way it compiles.<br></p><p>I did make a mistake when writing the original email, but corrected it a<br>couple of seconds later, so I stand by the idea that this logic is<br>deduceable :)<br></p><p>In both cases the last line is calling something that can be denoted as  (C()<br>as P).P_f<br>Now, if we write the effects of the line marked &quot;remember this line&quot; in<br>pseudocode as<br></p><p>class C:P {<br>override P_f = C_f // effect of C:P if &quot;remember&quot; is present<br>}<br></p><p>the difference between cases is rather logical.<br>On Tue, Dec 8, 2015 at 01:42 Paul Cantrell &lt;cantrell at pobox.com<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cantrell at pobox.com&#39;);&gt;&gt; wrote:<br></p><p>&gt; I must admit I&#39;m having difficulty understanding why it&#39;s a big deal<br>&gt; whether the dispatch will be static or dynamic. This seems like an<br>&gt; implementation detail; any &quot;dynamic dispatch&quot; in the aforementioned sense<br>&gt; can actually became static for a final class.<br>&gt;<br>&gt;<br>&gt; It’s not just an implementation detail. The original article demonstrates<br>&gt; this compellingly, I think.<br>&gt;<br>&gt; Yes, it’s true that, as an optimization, the compiler can choose to use<br>&gt; static dispatch in situations where doing so makes no difference (e.g.<br>&gt; calling a final method, calling a private method with no overrides, etc.).<br>&gt;<br>&gt; However, there are situations where static dispatch changes the behavior<br>&gt; of the code. At that point, it’s a semantic difference. It’s those cases<br>&gt; I’m concerned about.<br>&gt;<br>&gt; Just think about function defined as having a &quot;magic prefix&quot; that<br>&gt; corresponds technically to vtable where they can be located:<br>&gt;<br>&gt;<br>&gt; It’s not that it’s hard to understand what’s happening if you *already<br>&gt; know* that a call uses static dispatch. The problem is that it’s<br>&gt; difficult to determine *whether it does*.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; Note that your example code with C_f and P_f does not demonstrate the<br>&gt; problem at hand. It’s worth working through why.<br>&gt;<br>&gt; Translating your pseudocode into actual Swift, this does not compile:<br>&gt;<br>&gt;     class C {<br>&gt;         func f() {<br>&gt;             print(&quot;C_f&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     protocol P {<br>&gt;         func f()<br>&gt;     }<br>&gt;<br>&gt;     extension C: P {<br>&gt;         func f() {  // compiler error here<br>&gt;             print(&quot;P_f&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; I imagine that you were thinking of something along these lines:<br>&gt;<br>&gt;     class C {<br>&gt;         func f() {<br>&gt;             print(&quot;C_f&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     protocol P {<br>&gt;         func f()  // remember this line<br>&gt;     }<br>&gt;<br>&gt;     extension P {<br>&gt;         func f() {<br>&gt;             print(&quot;P_f&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     extension C: P { }  // C: P now separate from extension impl of f()<br>&gt;<br>&gt;<br>&gt; However, this does not behave as you think it does:<br>&gt;<br>&gt;     (C() as C).f()  // C_f<br>&gt;     (C() as P).f()  // C_f<br>&gt;<br>&gt; However *again*, if you remove the line marked “remember this line,”<br>&gt; *then* the code does do what you think it does:<br>&gt;<br>&gt;     (C() as C).f()  // C_f<br>&gt;     (C() as P).f()  // P_f<br>&gt;<br>&gt; I’d say that if you got confused in the course of explaining how it&#39;s not<br>&gt; confusing … well, that’s pretty good evidence that it is indeed confusing.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 3:56 PM, ilya &lt;ilya.nikokoshev at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;ilya.nikokoshev at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 7:17 AM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; One of the few things in Swift 2 that feels to me like a design flaw is<br>&gt;&gt; the way Swift mixes static and dynamic method dispatch.<br>&gt;&gt;<br>&gt;&gt; Alexandros Salazar gives an excellent explanation of this problem — and I<br>&gt;&gt; agree wholeheartedly with his title for the article:<br>&gt;&gt;<br>&gt;&gt;     http://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future<br>&gt;&gt;<br>&gt;&gt; The upshot is that when we see this:<br>&gt;&gt;<br>&gt;&gt;     foo.bar()<br>&gt;&gt;<br>&gt;&gt; …it’s very hard to know how the compiler will determine which<br>&gt;&gt; implementation of bar() to use. It might use static dispatch; it might use<br>&gt;&gt; dynamic dispatch.<br>&gt;&gt;<br>&gt;&gt; The rules that govern this are arcane, and hard to remember. They have<br>&gt;&gt; the feeling of being a “gotcha” question for job interviews — always a red<br>&gt;&gt; flag for language features.<br>&gt;&gt;<br>&gt;&gt; Even if you remember the rules, the information needed to determine<br>&gt;&gt; whether dispatch is static or dynamic is hard to track down. It depends on<br>&gt;&gt; whether bar()’s implementation comes from an extension, whether the<br>&gt;&gt; extension method appeared on the extended protocol, and whether the<br>&gt;&gt; inferred type of foo is the protocol itself or an implementing type.<br>&gt;&gt;<br>&gt;&gt; A crucial part of the meaning of “foo.bar()” is implicit, and hard to<br>&gt;&gt; determine.<br>&gt;<br>&gt;<br>&gt; I must admit I&#39;m having difficulty understanding why it&#39;s a big deal<br>&gt; whether the dispatch will be static or dynamic. This seems like an<br>&gt; implementation detail; any &quot;dynamic dispatch&quot; in the aforementioned sense<br>&gt; can actually became static for a final class.<br>&gt;<br>&gt; I understand there can be a confusion about the method called when the<br>&gt; protocol contains a method implementation, but there are some simple ways<br>&gt; to understand why things work as they do. Just think about function defined<br>&gt; as having a &quot;magic prefix&quot; that corresponds technically to vtable where<br>&gt; they can be located:<br>&gt;<br>&gt; class C {<br>&gt;    func C_f // declares C.C_f<br>&gt; }<br>&gt;<br>&gt; protocol P {<br>&gt;   func P_f<br>&gt; }<br>&gt;<br>&gt; // implementation of P.P_f<br>&gt;<br>&gt; extension C:P {<br>&gt;   // declares that C.C_f = C.P_f<br>&gt; }<br>&gt;<br>&gt; (C() as C).f -&gt; calls C.C_f = C.P_f<br>&gt; (C() as P).f -&gt; calls P.P_f<br>&gt;<br>&gt;<br>&gt;&gt; This runs contrary to Swift’s stated goal of prioritizing clarity at the<br>&gt;&gt; point of API use, and its general pattern of making intent explicit. And it<br>&gt;&gt; feels dangerous — a wellspring of insidious bugs.<br>&gt;&gt;<br>&gt;&gt; Thus:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; PROPOSAL<br>&gt;&gt;<br>&gt;&gt; Make the syntax “foo.bar()” always use dynamic dispatch, i.e. always use<br>&gt;&gt; _only_ the runtime type of foo to determine which implementation of bar()<br>&gt;&gt; to use. If an extension method collision occurs when a type implements<br>&gt;&gt; multiple protocols, require the type to explicitly specify which one to use<br>&gt;&gt; (as Swift already requires the caller to do at the point of invocation).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I mean this proposal somewhat as a strawman. It’s such an obvious choice,<br>&gt;&gt; I’m sure there were good reasons not to do it. But I’d like to propose the<br>&gt;&gt; obvious solution in order to understand what’s wrong with it. I realize<br>&gt;&gt; static dispatch precludes some optimizations, but I doubt that this alone<br>&gt;&gt; drove the design choice. I see no safety or expressiveness upside to the<br>&gt;&gt; way it works now.<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt;<br>&gt;&gt; Paul<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/32a62d30/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
