<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 13, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;ve drafted a proposal to allow property and subscript accessors to throw errors:<br></p><p>	&lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md&gt;<br></p><p>I&#39;ve left a lot of the rationale for particular design decisions for the &quot;Alternatives considered&quot; section, so please take a look at that before you ask, for instance, why this proposal doesn&#39;t import any Objective-C methods as throwing subscript accessors.<br></p><p><br></p><p>Throwing Properties and Subscripts<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#introduction&gt;Introduction<br></p><p>Functions, methods, and initializers can be marked throws to indicate that they can fail by throwing an error, but properties and subscripts cannot. This proposal extends properties and subscripts to support throws and rethrows accessors, and also specifies logic for bridging these accessors to and from Objective-C.<br></p><p>Swift-evolution thread: Proposal: Allow Getters and Setters to Throw &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001165.html&gt;<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#motivation&gt;Motivation<br></p><p>Sometimes, something that is genuinely getter- or setter-like needs to be able to throw an error. This is particularly common with properties which convert between formats:<br></p><p>var image: UIImage<br></p><p>var imageData: NSData {<br>    get {<br>        return UIImagePNGRepresentation(image)<br>    }<br>    set {<br>        image = UIImage(data: newValue) ?? throw OopsICantThrowHere<br>    }<br>}<br>Or which access some external resource which may not be able to perform the operation:<br></p><p>var avatar: UIImage {<br>    get {<br>        let data = try NSData(contentsOfURL: avatarURL, options: [])    /* can&#39;t try here! */<br>        return UIImage(data: data)<br>    }<br>}<br>The current best solution to this problem is to write a method instead of a property. This can lead to unnatural API designs; the class AVAudioSession alone, for instance, has no less than ten mismatched property/setter method pairs:<br></p><p>var category: String { get }<br>func setCategory(_ category: String) throws<br></p><p>var mode: String { get }<br>func setMode(_ mode: String) throws<br></p><p>var inputGain: Float { get }<br>func setInputGain(_ gain: Float) throws<br></p><p>var preferredSampleRate: Double { get }<br>func setPreferredSampleRate(_ sampleRate: Double) throws<br></p><p>var preferredIOBufferDuration: NSTimeInterval { get }<br>func setPreferredIOBufferDuration(_ duration: NSTimeInterval) throws<br></p><p>var preferredInputNumberOfChannels: Int { get }<br>func setPreferredInputNumberOfChannels(_ count: Int) throws<br></p><p>var preferredOutputNumberOfChannels: Int { get }<br>func setPreferredOutputNumberOfChannels(_ count: Int) throws<br></p><p>var preferredInput: AVAudioSessionPortDescription? { get }<br>func setPreferredInput(_ inPort: AVAudioSessionPortDescription?) throws<br></p><p>var inputDataSource: AVAudioSessionDataSourceDescription? { get }<br>func setInputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br></p><p>var outputDataSource: AVAudioSessionDataSourceDescription? { get }<br>func setOutputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>While most classes aren&#39;t nearly this bad, you see the same problem elsewhere in the frameworks. The Mac-only CoreWLAN framework has similar mismatched property/setter method pairs (though it also has other bridging issues; I suspect it&#39;s too obscure to have been audited yet):<br></p><p>func wlanChannel() -&gt; CWChannel!<br>func setWLANChannel(_ channel: CWChannel!, error error: NSErrorPointer) -&gt; Bool<br></p><p>func powerOn() -&gt; Bool<br>func setPower(_ power: Bool, error error: NSErrorPointer) -&gt; Bool<br>When the getter can throw, it gets even worse. NSURL has an awkward pair of methods to get &quot;resource values&quot; which would be better expressed as a throwing read-write subscript:<br></p><p>func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#proposed-solution&gt;Proposed solution<br></p><p>Swift can handle these cases better by allowing getters and setters to throw.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-computed-properties&gt;Throwing computed properties<br></p><p>You can mark a computed property accessor as throwing by putting throws after the get or set keyword:<br></p><p>var property: Int {<br>    get throws { ... }<br>    set throws { ... }<br>}<br></p><p>subscript(index: Int) -&gt; Bool {<br>    get throws { ... }<br>    set throws { ... }<br>}<br>The throwing behavior of the getter and setter are completely independent; a throwing getter can be paired with a non-throwing setter, or vice versa.<br></p><p>var property: Int {<br>    get throws { ... }<br>    set { ... }<br>}<br></p><p>subscript(index: Int) -&gt; Bool {<br>    get { ... }<br>    set throws { ... }<br>}<br>A protocol (or, if added later, an abstract class) can specify the throwing behavior of properties and subscripts it requires:<br></p><p>protocol MyProtocol {<br>    var property: Int { get throws set throws }<br>    subscript(index: Int) -&gt; Bool { get throws set throws }<br>}<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-stored-properties&gt;Throwing stored properties<br></p><p>A stored property can also be given a throwing setter by giving it a willSet accessor that throws:<br></p><p>var property: Int {<br>    willSet throws {<br>        guard newValue &gt;= 0 else {<br>            throw MyError.PropertyOutOfRange (newValue)<br>        }<br>    }<br>}<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#importing-throwing-property-accessors-from-objective-c&gt;Importing throwing property accessors from Objective-C<br></p><p>When a readonly property foo of type T is imported from Objective-C, but a method like this exists on the same type:<br></p><p>- (BOOL)setFoo:(T)value error:(NSError**)error;<br>Swift will import foo as a readwrite property with a throwing setter.<br></p><p>If SE-0044 Import as member &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; is accepted, we should also be able to apply the swift_name attribute to methods of these forms to create properties with throwing getters:<br></p><p>- (nullable T)foo:(NSError**)error;     // property is not optional<br>- (BOOL)getFoo:(T*)outValue error:(NSError**)error;<br>No imports for throwing subscript accessors are specified.<br></p><p>These transformations should be applied to both classes and protocols.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#exporting-throwing-property-and-subscript-accessors-to-objective-c&gt;Exporting throwing property and subscript accessors to Objective-C<br></p><p>A throwing setter for a property foo of type T should be exposed to Objective-C as:<br></p><p>- (void)setFoo:(T)value error:(NSError**)error;<br>A throwing getter for a property foo of type T, where T is not optional but can be nullable in Objective-C, should be exposed to Objective-C as:<br></p><p>- (nullable T)foo:(NSError**)error;<br>Otherwise, the getter should be exposed as:<br></p><p>- (BOOL)getFoo:(nonnull T*)outValue error:(NSError**)error;<br>A throwing setter for a subscript of type T with an index of type I, if marked with @objc(name), should be compatible with this signature:<br></p><p>- (BOOL)setFoo:(T)value atIndex:(I)index error:(NSError**)error;<br>A throwing getter for a subscript of type T with index I, where T is not optional but can be nullable in Objective-C, should be compatible with this signature:<br></p><p>- (nullable T)fooAtIndex:(I)index error:(NSError**)error;<br>Otherwise, the getter should be have a name compatible with this signature:<br></p><p>- (BOOL)getFoo:(nonnull T*)outValue atIndex:(I)index error:(NSError**)error;<br>Throwing subscript accessors which are not marked with @objc(name) will not be exposed to Objective-C.<br></p><p>These transformations should be applied to both classes and @objc protocols.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#detailed-design&gt;Detailed design<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#subscripts-with-rethrows&gt;Subscripts with rethrows<br></p><p>rethrows is not supported on properties, but it is supported on subscripts. The rethrowing behavior depends only on the subscript&#39;s parameters, not the setter&#39;s newValue; that is, a particular subscript access can throw iff at least one of the functions inside the square brackets can throw.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-accessors-and-inout-parameters&gt;Throwing accessors and inout parameters<br></p><p>A throwing property or subscript access can be passed as an inout parameter. The call it is passed to must be marked with the try keyword.<br></p><p>To avoid unpredictable interactions between inout and throwing accessors, Swift will guarantee the getter is invoked once before the call and the setter once after the call. The compiler will not apply optimizations which might cause errors to be thrown in the middle of the function.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-requirement-compatibility&gt;Throwing requirement compatibility<br></p><p>An implementation can be &quot;less&quot; throwing than a requirement it is intended to satisfy. That is:<br></p><p>A throwing accessor requirement can be fulfilled by a throwing, rethrowing, or non-throwing accessor.<br>A rethrowing accessor requirement can be fulfilled by a rethrowing or non-throwing accessor.<br>A non-throwing accessor requirement can be fulfilled only by a non-throwing accessor.<br>These definitions apply to protocol (and abstract class) conformance, subclass overrides, and library resilience. (Note that last point: Swift must permit an accessor to be made less throwing without breaking binary compatibility.)<br></p><p>When overriding a throwing accessor, the override must explicitly state the expected level of throwing behavior; omitting the keyword means the accessor is non-throwing. That is, in this example, Subclass.foo&#39;s setter is not automatically throws:<br></p><p>class Superclass {<br>    var foo: Int {<br>        willSet throws { ... }<br>    }<br>}<br></p><p>class Subclass: Superclass {<br>    override var foo: Int {<br>        set { try super.foo = newValue }<br>        // Error: nonthrowing setter includes throwing statement<br>    }<br>}<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#implementation&gt;Implementation<br></p><p>The internal materializeForSet is as throwing as the &quot;most&quot; throwing of get and set.<br></p><p>FIXME: Beyond that, I have no idea. Sorry. Please help me fill this out.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#impact-on-existing-code&gt;Impact on existing code<br></p><p>Some APIs will be imported differently, breaking call sites. The Swift compiler will need to provide fix-it and migration support for these cases.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#require-setters-to-be-at-least-as-throwing-as-getters&gt;Require setters to be at least as throwing as getters<br></p><p>Calling a setter often implicitly involves calling a getter, so it may make sense to require the setter to be at least as throwing as the getter. Absent feedback to this effect from implementors, however, my instinct is to leave them independent, as there may be use cases where a get can throw but a set cannot. (For instance, if an instance faults in data from an external source on demand, but only writes that data back when a save() call is invoked, get may throw if it&#39;s unable to fault in the data, but set would never need to throw.)<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#make-rethrows-setters-throwing-if-newvalue-is-throwing&gt;Make rethrows setters throwing if newValue is throwing<br></p><p>newValue is sort of like a parameter to the setter, so it might technically be more consistent for rethrows to consider newValue when deciding if a particular invocation throws or not. However, I can&#39;t imagine a case where this would be appropriate behavior, and considering only the subscript parameters makes the getter and setter work better together.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#dont-include-willset-throws&gt;Don&#39;t include willSet throws<br></p><p>The use of willSet throws to make a stored property throwing is a bit funky and could be omitted. I decided to include it because, if it does not exist, people will fake it with private properties anyway.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#include-didset-throws&gt;Include didSet throws<br></p><p>There is no technical reason not to support didSet throws accessors, which would allow stored properties to be made throwing. However, this would usually be the wrong thing to do because it would leave the errant value in the property. If compelling use cases for it were cited, however, didSet throws could be added.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#permit-try-on-foo-itself-rather-than-the-call-using-it&gt;Permit try on &amp;foo itself, rather than the call using it<br></p><p>As specified, if foo has a throwing accessor and you want to pass it to a function bar with an inout parameter, you have to write this:<br></p><p>try bar(&amp;foo)<br>In theory, we could instead allow you to mark only the &amp; operator, leaving the rest of the expression uncovered by the try:<br></p><p>bar(try &amp;foo)<br>This would make the source of the potential error more obvious, but it might make the semantics less clear, because try &amp;foo can throw after the call is finished in addition to before. I judge the latter issue to be more serious.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#try-to-convert-keyed-gettersetter-methods-to-subscripts&gt;Try to convert keyed getter/setter methods to subscripts<br></p><p>Swift could conceivably apply heuristics to discover Objective-C method pairs that can be expressed as subscripts. For instance, the NSURL method pair cited in the Motivation section:<br></p><p>func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>Could be imported like this:<br></p><p>subscript (resourceValueFor key: String) -&gt; AnyObject? {<br>    get throws<br>    set throws<br>}<br>There are several reasons not to do this:<br></p><p>There is no established pattern for throwing subscripts in Objective-C, so any we might establish would be mistake-prone.<br>SE-0044 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; does not currently include subscripts, so there is no proposal pending which would allow the heuristic to be tweaked or the import logic to be invoked manually. (This is arguably an oversight in SE-0044.)<br>Many such cases would benefit from a human looking at the design. In the NSURL case, for instance, a human looking at the broader type might prefer a design like this:<br>var resourceValues: ResourceValues { get } <br></p><p>struct ResourceValues {<br>    subscript (key: String) -&gt; AnyObject? {<br>        get throws { ... }<br>        set throws { ... }<br>    }<br></p><p>    func get(for keys: [String]) throws -&gt; [String: AnyObject] { ... }<br>    func set(from dict: [String: AnyObject]) throws { ... }<br></p><p>    func removeCachedKeys() { ... }<br>    func removeCachedKey(key: String) { ... }<br>    func setTemporaryValue(_ value: AnyObject?, for key: String) { ... }<br>}<br> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#automatically-export-throwing-subscript-accessors-to-objective-c&gt;Automatically export throwing subscript accessors to Objective-C<br></p><p>Throwing subscript accessors can only be exported by specifying a name using an @objc property. It might be nice to export them by default, but Objective-C doesn&#39;t have an established pattern for throwing subscript accessors, so it&#39;s not clear how these methods would be named.<br></p><p> &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#add-a-nothrows-keyword&gt;Add a nothrows keyword<br></p><p>Leaving an accessor&#39;s throwing behavior unspecified could make it automatically take on the behavior required by the type&#39;s superclass or conformed protocols. However, this would require a way to explicitly state that an accessor could notthrow, along the lines of the rarely-used but necessary nonmutating keyword.<br></p><p>I have chosen not to do this because Swift generally does not allow you to infer parts of a member&#39;s signature, and because I cannot come up with a way to spell this keyword that isn&#39;t ugly as sin.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/cc2aea06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>March 14, 2016 at 01:00:00pm</p></header><div class="content"><p>Nicely written!<br></p><p>I wonder if it would help to document the grammar changes necessary in the proposal.<br></p><p>I also wonder how it could affect the getter shorthand? Couldn&#39;t the following work for subscripts?<br></p><p>    subscript(idx: Int) throws -&gt; Element { ... }<br></p><p>    // the above is shorthand for<br>    subscript(idx: Int) -&gt; Element {<br>        get throws { ... }<br>    }<br></p><p>Not sure how this could be extended to work with general computed vars. This doesn&#39;t feel right:<br></p><p>    var x throws: Int { ... }<br></p><p>Stephen<br></p><p>&gt; On Mar 13, 2016, at 11:07 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve drafted a proposal to allow property and subscript accessors to throw errors:<br>&gt; <br>&gt; 	&lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md&gt;<br>&gt; <br>&gt; I&#39;ve left a lot of the rationale for particular design decisions for the &quot;Alternatives considered&quot; section, so please take a look at that before you ask, for instance, why this proposal doesn&#39;t import any Objective-C methods as throwing subscript accessors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Throwing Properties and Subscripts<br>&gt; <br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Author(s): Brent Royal-Gordon<br>&gt; 	• Status: Draft<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Functions, methods, and initializers can be marked throws to indicate that they can fail by throwing an error, but properties and subscripts cannot. This proposal extends properties and subscripts to support throws and rethrows accessors, and also specifies logic for bridging these accessors to and from Objective-C.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Allow Getters and Setters to Throw<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Sometimes, something that is genuinely getter- or setter-like needs to be able to throw an error. This is particularly common with properties which convert between formats:<br>&gt; <br>&gt; var<br>&gt;  image: UIImage<br>&gt; <br>&gt; <br>&gt; var<br>&gt;  imageData: NSData {<br>&gt;     <br>&gt; get<br>&gt;  {<br>&gt;         <br>&gt; return<br>&gt;  UIImagePNGRepresentation(image)<br>&gt;     }<br>&gt;     <br>&gt; set<br>&gt;  {<br>&gt;         image <br>&gt; = UIImage(data: newValue) ?? throw<br>&gt;  OopsICantThrowHere<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Or which access some external resource which may not be able to perform the operation:<br>&gt; <br>&gt; var<br>&gt;  avatar: UIImage {<br>&gt;     <br>&gt; get<br>&gt;  {<br>&gt;         <br>&gt; let data = try NSData(contentsOfURL: avatarURL, options: [])    /* can&#39;t try here! */<br>&gt; <br>&gt;         <br>&gt; return<br>&gt;  UIImage(data: data)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The current best solution to this problem is to write a method instead of a property. This can lead to unnatural API designs; the class AVAudioSession alone, for instance, has no less than ten mismatched property/setter method pairs:<br>&gt; <br>&gt; var category: String { get<br>&gt;  }<br>&gt; <br>&gt; func setCategory(_ category: String<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var mode: String { get<br>&gt;  }<br>&gt; <br>&gt; func setMode(_ mode: String<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var inputGain: Float { get<br>&gt;  }<br>&gt; <br>&gt; func setInputGain(_ gain: Float<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var preferredSampleRate: Double { get<br>&gt;  }<br>&gt; <br>&gt; func setPreferredSampleRate(_ sampleRate: Double<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var preferredIOBufferDuration: NSTimeInterval { get<br>&gt;  }<br>&gt; <br>&gt; func setPreferredIOBufferDuration(_ duration<br>&gt; : NSTimeInterval) throws<br>&gt; <br>&gt; <br>&gt; var preferredInputNumberOfChannels: Int { get<br>&gt;  }<br>&gt; <br>&gt; func setPreferredInputNumberOfChannels(_ count: Int<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var preferredOutputNumberOfChannels: Int { get<br>&gt;  }<br>&gt; <br>&gt; func setPreferredOutputNumberOfChannels(_ count: Int<br>&gt; ) throws<br>&gt; <br>&gt; <br>&gt; var preferredInput: AVAudioSessionPortDescription? { get<br>&gt;  }<br>&gt; <br>&gt; func setPreferredInput(_ inPort<br>&gt; : AVAudioSessionPortDescription?) throws<br>&gt; <br>&gt; <br>&gt; var inputDataSource: AVAudioSessionDataSourceDescription? { get<br>&gt;  }<br>&gt; <br>&gt; func setInputDataSource(_ dataSource<br>&gt; : AVAudioSessionDataSourceDescription?) throws<br>&gt; <br>&gt; <br>&gt; var outputDataSource: AVAudioSessionDataSourceDescription? { get<br>&gt;  }<br>&gt; <br>&gt; func setOutputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>&gt; While most classes aren&#39;t nearly this bad, you see the same problem elsewhere in the frameworks. The Mac-only CoreWLAN framework has similar mismatched property/setter method pairs (though it also has other bridging issues; I suspect it&#39;s too obscure to have been audited yet):<br>&gt; <br>&gt; func wlanChannel() -&gt;<br>&gt;  CWChannel!<br>&gt; <br>&gt; func setWLANChannel(_ channel: CWChannel!, error error: NSErrorPointer) -&gt; Bool<br>&gt; <br>&gt; <br>&gt; <br>&gt; func powerOn() -&gt; Bool<br>&gt; func setPower(_ power: Bool, error error: NSErrorPointer) -&gt; Bool<br>&gt; When the getter can throw, it gets even worse. NSURL has an awkward pair of methods to get &quot;resource values&quot; which would be better expressed as a throwing read-write subscript:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String<br>&gt; ) throws<br>&gt; <br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt; Proposed solution<br>&gt; <br>&gt; Swift can handle these cases better by allowing getters and setters to throw.<br>&gt; <br>&gt; Throwing computed properties<br>&gt; <br>&gt; You can mark a computed property accessor as throwing by putting throws after the get or set keyword:<br>&gt; <br>&gt; var property: Int<br>&gt;  {<br>&gt;     <br>&gt; get throws { ...<br>&gt;  }<br>&gt;     <br>&gt; set throws { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool<br>&gt;  {<br>&gt;     <br>&gt; get throws { ...<br>&gt;  }<br>&gt;     <br>&gt; set throws { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; The throwing behavior of the getter and setter are completely independent; a throwing getter can be paired with a non-throwing setter, or vice versa.<br>&gt; <br>&gt; var property: Int<br>&gt;  {<br>&gt;     <br>&gt; get throws { ...<br>&gt;  }<br>&gt;     <br>&gt; set { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool<br>&gt;  {<br>&gt;     <br>&gt; get { ...<br>&gt;  }<br>&gt;     <br>&gt; set throws { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; A protocol (or, if added later, an abstract class) can specify the throwing behavior of properties and subscripts it requires:<br>&gt; <br>&gt; protocol<br>&gt;  MyProtocol {<br>&gt;     <br>&gt; var property: Int { get throws set throws<br>&gt;  }<br>&gt;     <br>&gt; subscript(index: Int) -&gt; Bool { get throws set throws<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Throwing stored properties<br>&gt; <br>&gt; A stored property can also be given a throwing setter by giving it a willSet accessor that throws:<br>&gt; <br>&gt; var property: Int<br>&gt;  {<br>&gt;     <br>&gt; willSet throws<br>&gt;  {<br>&gt;         <br>&gt; guard newValue &gt;= 0 else<br>&gt;  {<br>&gt;             <br>&gt; throw MyError.<br>&gt; PropertyOutOfRange (newValue)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Importing throwing property accessors from Objective-C<br>&gt; <br>&gt; When a readonly property foo of type T is imported from Objective-C, but a method like this exists on the same type:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value error:(NSError**)error;<br>&gt; Swift will import foo as a readwrite property with a throwing setter.<br>&gt; <br>&gt; If SE-0044 Import as member is accepted, we should also be able to apply the swift_name attribute to methods of these forms to create properties with throwing getters:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;     // property is not optional<br>&gt; <br>&gt; - (<br>&gt; BOOL)getFoo:(T*)outValue error:(NSError**)error;<br>&gt; No imports for throwing subscript accessors are specified.<br>&gt; <br>&gt; These transformations should be applied to both classes and protocols.<br>&gt; <br>&gt; Exporting throwing property and subscript accessors to Objective-C<br>&gt; <br>&gt; A throwing setter for a property foo of type T should be exposed to Objective-C as:<br>&gt; <br>&gt; - (void)setFoo:(T)value error:(NSError**)error;<br>&gt; A throwing getter for a property foo of type T, where T is not optional but can be nullable in Objective-C, should be exposed to Objective-C as:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;<br>&gt; Otherwise, the getter should be exposed as:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue error:(NSError**)error;<br>&gt; A throwing setter for a subscript of type T with an index of type I, if marked with @objc(name), should be compatible with this signature:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value atIndex:(I)index error:(NSError**)error;<br>&gt; A throwing getter for a subscript of type T with index I, where T is not optional but can be nullable in Objective-C, should be compatible with this signature:<br>&gt; <br>&gt; - (nullable T)fooAtIndex:(I)index error:(NSError**)error;<br>&gt; Otherwise, the getter should be have a name compatible with this signature:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue atIndex:(I)index error:(NSError**)error;<br>&gt; Throwing subscript accessors which are not marked with @objc(name) will not be exposed to Objective-C.<br>&gt; <br>&gt; These transformations should be applied to both classes and @objc protocols.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Subscripts with rethrows<br>&gt; <br>&gt; rethrows is not supported on properties, but it is supported on subscripts. The rethrowing behavior depends only on the subscript&#39;s parameters, not the setter&#39;s newValue; that is, a particular subscript access can throw iff at least one of the functions inside the square brackets can throw.<br>&gt; <br>&gt; Throwing accessors and inout parameters<br>&gt; <br>&gt; A throwing property or subscript access can be passed as an inout parameter. The call it is passed to must be marked with the try keyword.<br>&gt; <br>&gt; To avoid unpredictable interactions between inout and throwing accessors, Swift will guarantee the getter is invoked once before the call and the setter once after the call. The compiler will not apply optimizations which might cause errors to be thrown in the middle of the function.<br>&gt; <br>&gt; Throwing requirement compatibility<br>&gt; <br>&gt; An implementation can be &quot;less&quot; throwing than a requirement it is intended to satisfy. That is:<br>&gt; <br>&gt; 	• A throwing accessor requirement can be fulfilled by a throwing, rethrowing, or non-throwing accessor.<br>&gt; 	• A rethrowing accessor requirement can be fulfilled by a rethrowing or non-throwing accessor.<br>&gt; 	• A non-throwing accessor requirement can be fulfilled only by a non-throwing accessor.<br>&gt; These definitions apply to protocol (and abstract class) conformance, subclass overrides, and library resilience. (Note that last point: Swift must permit an accessor to be made less throwing without breaking binary compatibility.)<br>&gt; <br>&gt; When overriding a throwing accessor, the override must explicitly state the expected level of throwing behavior; omitting the keyword means the accessor is non-throwing. That is, in this example, Subclass.foo&#39;s setter is not automatically throws:<br>&gt; <br>&gt; class Superclass {<br>&gt;     var foo: Int {<br>&gt;         willSet throws { ... }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Subclass: Superclass {<br>&gt;     override var foo: Int {<br>&gt;         set { try super.foo = newValue }<br>&gt;         // Error: nonthrowing setter includes throwing statement<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Implementation<br>&gt; <br>&gt; The internal materializeForSet is as throwing as the &quot;most&quot; throwing of get and set.<br>&gt; <br>&gt; FIXME: Beyond that, I have no idea. Sorry. Please help me fill this out.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Some APIs will be imported differently, breaking call sites. The Swift compiler will need to provide fix-it and migration support for these cases.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Require setters to be at least as throwing as getters<br>&gt; <br>&gt; Calling a setter often implicitly involves calling a getter, so it may make sense to require the setter to be at least as throwing as the getter. Absent feedback to this effect from implementors, however, my instinct is to leave them independent, as there may be use cases where a get can throw but a set cannot. (For instance, if an instance faults in data from an external source on demand, but only writes that data back when a save() call is invoked, get may throw if it&#39;s unable to fault in the data, but set would never need to throw.)<br>&gt; <br>&gt; Make rethrows setters throwing if newValue is throwing<br>&gt; <br>&gt; newValue is sort of like a parameter to the setter, so it might technically be more consistent for rethrows to consider newValue when deciding if a particular invocation throws or not. However, I can&#39;t imagine a case where this would be appropriate behavior, and considering only the subscript parameters makes the getter and setter work better together.<br>&gt; <br>&gt; Don&#39;t include willSet throws<br>&gt; <br>&gt; The use of willSet throws to make a stored property throwing is a bit funky and could be omitted. I decided to include it because, if it does not exist, people will fake it with private properties anyway.<br>&gt; <br>&gt; Include didSet throws<br>&gt; <br>&gt; There is no technical reason not to support didSet throws accessors, which would allow stored properties to be made throwing. However, this would usually be the wrong thing to do because it would leave the errant value in the property. If compelling use cases for it were cited, however, didSet throws could be added.<br>&gt; <br>&gt; Permit try on &amp;foo itself, rather than the call using it<br>&gt; <br>&gt; As specified, if foo has a throwing accessor and you want to pass it to a function bar with an inout parameter, you have to write this:<br>&gt; <br>&gt; try bar(&amp;foo)<br>&gt; <br>&gt; In theory, we could instead allow you to mark only the &amp; operator, leaving the rest of the expression uncovered by the try:<br>&gt; <br>&gt; bar(try &amp;foo)<br>&gt; <br>&gt; This would make the source of the potential error more obvious, but it might make the semantics less clear, because try &amp;foo can throw after the call is finished in addition to before. I judge the latter issue to be more serious.<br>&gt; <br>&gt; Try to convert keyed getter/setter methods to subscripts<br>&gt; <br>&gt; Swift could conceivably apply heuristics to discover Objective-C method pairs that can be expressed as subscripts. For instance, the NSURL method pair cited in the Motivation section:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String<br>&gt; ) throws<br>&gt; <br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt; Could be imported like this:<br>&gt; <br>&gt; subscript (resourceValueFor key: String) -&gt; AnyObject<br>&gt; ? {<br>&gt;     <br>&gt; get throws<br>&gt; <br>&gt;     <br>&gt; set throws<br>&gt; <br>&gt; }<br>&gt; <br>&gt; There are several reasons not to do this:<br>&gt; <br>&gt; 	• There is no established pattern for throwing subscripts in Objective-C, so any we might establish would be mistake-prone.<br>&gt; 	• SE-0044 does not currently include subscripts, so there is no proposal pending which would allow the heuristic to be tweaked or the import logic to be invoked manually. (This is arguably an oversight in SE-0044.)<br>&gt; 	• Many such cases would benefit from a human looking at the design. In the NSURL case, for instance, a human looking at the broader type might prefer a design like this:<br>&gt; var resourceValues: ResourceValues { get<br>&gt;  } <br>&gt; <br>&gt; <br>&gt; struct<br>&gt;  ResourceValues {<br>&gt;     <br>&gt; subscript (key: String) -&gt; AnyObject<br>&gt; ? {<br>&gt;         <br>&gt; get throws { ...<br>&gt;  }<br>&gt;         <br>&gt; set throws { ...<br>&gt;  }<br>&gt;     }<br>&gt; <br>&gt;     <br>&gt; func get(for keys: [String]) throws -&gt; [String: AnyObject] { ...<br>&gt;  }<br>&gt;     <br>&gt; func set(from dict: [String: AnyObject]) throws { ...<br>&gt;  }<br>&gt; <br>&gt;     <br>&gt; func removeCachedKeys() { ...<br>&gt;  }<br>&gt;     <br>&gt; func removeCachedKey(key: String) { ...<br>&gt;  }<br>&gt;     <br>&gt; func setTemporaryValue(_ value: AnyObject?, for key: String) { ...<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Automatically export throwing subscript accessors to Objective-C<br>&gt; <br>&gt; Throwing subscript accessors can only be exported by specifying a name using an @objc property. It might be nice to export them by default, but Objective-C doesn&#39;t have an established pattern for throwing subscript accessors, so it&#39;s not clear how these methods would be named.<br>&gt; <br>&gt; Add a nothrows keyword<br>&gt; <br>&gt; Leaving an accessor&#39;s throwing behavior unspecified could make it automatically take on the behavior required by the type&#39;s superclass or conformed protocols. However, this would require a way to explicitly state that an accessor could notthrow, along the lines of the rarely-used but necessary nonmutating keyword.<br>&gt; <br>&gt; I have chosen not to do this because Swift generally does not allow you to infer parts of a member&#39;s signature, and because I cannot come up with a way to spell this keyword that isn&#39;t ugly as sin.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; I wonder if it would help to document the grammar changes necessary in the proposal.<br></p><p>I&#39;m preparing a revision with that information.<br></p><p>&gt; I also wonder how it could affect the getter shorthand? Couldn&#39;t the following work for subscripts?<br>&gt; <br>&gt;    subscript(idx: Int) throws -&gt; Element { ... }<br>&gt; <br>&gt;    // the above is shorthand for<br>&gt;    subscript(idx: Int) -&gt; Element {<br>&gt;        get throws { ... }<br>&gt;    }<br></p><p>A shorthand is a definite possibility, especially for subscripts where both accessors might need to throw because of an invalid index, but I decided to keep it simple. I&#39;m also worried that it might encourage people to mark accessors as throwing when only one actually needs it.<br></p><p>&gt; Not sure how this could be extended to work with general computed vars. This doesn&#39;t feel right:<br>&gt; <br>&gt;    var x throws: Int { ... }<br></p><p>Yeah, that&#39;s another problem.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 14, 2016 at 11:00:00am</p></header><div class="content"><p>Do you have an imagined use for throwing getters? Allowing the getter or setter to throw independently greatly complicates the abstract model for properties. While we don&#39;t have much in the way of abstraction tools over properties yet, it would be important to consider the impact this might have on &quot;lens&quot; functions that can perform mutable projections. Right now, you can more or less categorize mutable properties into two groups:<br></p><p>- &quot;reference-like&quot;, projecting mutable storage indirectly through a reference, which you could think of as having a type (Base) -&gt; inout Property. This includes not only class properties but `nonmutating` struct properties like `UnsafeMutablePointer.memory`.<br>- &quot;value-like&quot;, projecting mutable storage that is part of a larger mutable value, which you could think of as having type (inout Base) -&gt; inout Property. This includes most mutable struct properties that aren&#39;t explicitly `nonmutating`.<br></p><p>If properties can throw, we&#39;d want to be able to represent that in the type system for projection functions. If there are four different ways a property can throw (no throws, only reads can throw, only writes can throw, or both reads and writes can throw), that gets really complicated.<br></p><p>-Joe<br></p><p>&gt; On Mar 13, 2016, at 8:07 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve drafted a proposal to allow property and subscript accessors to throw errors:<br>&gt; <br>&gt; 	&lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md &lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md&gt;&gt;<br>&gt; <br>&gt; I&#39;ve left a lot of the rationale for particular design decisions for the &quot;Alternatives considered&quot; section, so please take a look at that before you ask, for instance, why this proposal doesn&#39;t import any Objective-C methods as throwing subscript accessors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Throwing Properties and Subscripts<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#introduction&gt;Introduction<br>&gt; <br>&gt; Functions, methods, and initializers can be marked throws to indicate that they can fail by throwing an error, but properties and subscripts cannot. This proposal extends properties and subscripts to support throws and rethrows accessors, and also specifies logic for bridging these accessors to and from Objective-C.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Allow Getters and Setters to Throw &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001165.html&gt;<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#motivation&gt;Motivation<br>&gt; <br>&gt; Sometimes, something that is genuinely getter- or setter-like needs to be able to throw an error. This is particularly common with properties which convert between formats:<br>&gt; <br>&gt; var image: UIImage<br>&gt; <br>&gt; var imageData: NSData {<br>&gt;     get {<br>&gt;         return UIImagePNGRepresentation(image)<br>&gt;     }<br>&gt;     set {<br>&gt;         image = UIImage(data: newValue) ?? throw OopsICantThrowHere<br>&gt;     }<br>&gt; }<br>&gt; Or which access some external resource which may not be able to perform the operation:<br>&gt; <br>&gt; var avatar: UIImage {<br>&gt;     get {<br>&gt;         let data = try NSData(contentsOfURL: avatarURL, options: [])    /* can&#39;t try here! */<br>&gt;         return UIImage(data: data)<br>&gt;     }<br>&gt; }<br>&gt; The current best solution to this problem is to write a method instead of a property. This can lead to unnatural API designs; the class AVAudioSession alone, for instance, has no less than ten mismatched property/setter method pairs:<br>&gt; <br>&gt; var category: String { get }<br>&gt; func setCategory(_ category: String) throws<br>&gt; <br>&gt; var mode: String { get }<br>&gt; func setMode(_ mode: String) throws<br>&gt; <br>&gt; var inputGain: Float { get }<br>&gt; func setInputGain(_ gain: Float) throws<br>&gt; <br>&gt; var preferredSampleRate: Double { get }<br>&gt; func setPreferredSampleRate(_ sampleRate: Double) throws<br>&gt; <br>&gt; var preferredIOBufferDuration: NSTimeInterval { get }<br>&gt; func setPreferredIOBufferDuration(_ duration: NSTimeInterval) throws<br>&gt; <br>&gt; var preferredInputNumberOfChannels: Int { get }<br>&gt; func setPreferredInputNumberOfChannels(_ count: Int) throws<br>&gt; <br>&gt; var preferredOutputNumberOfChannels: Int { get }<br>&gt; func setPreferredOutputNumberOfChannels(_ count: Int) throws<br>&gt; <br>&gt; var preferredInput: AVAudioSessionPortDescription? { get }<br>&gt; func setPreferredInput(_ inPort: AVAudioSessionPortDescription?) throws<br>&gt; <br>&gt; var inputDataSource: AVAudioSessionDataSourceDescription? { get }<br>&gt; func setInputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>&gt; <br>&gt; var outputDataSource: AVAudioSessionDataSourceDescription? { get }<br>&gt; func setOutputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>&gt; While most classes aren&#39;t nearly this bad, you see the same problem elsewhere in the frameworks. The Mac-only CoreWLAN framework has similar mismatched property/setter method pairs (though it also has other bridging issues; I suspect it&#39;s too obscure to have been audited yet):<br>&gt; <br>&gt; func wlanChannel() -&gt; CWChannel!<br>&gt; func setWLANChannel(_ channel: CWChannel!, error error: NSErrorPointer) -&gt; Bool<br>&gt; <br>&gt; func powerOn() -&gt; Bool<br>&gt; func setPower(_ power: Bool, error error: NSErrorPointer) -&gt; Bool<br>&gt; When the getter can throw, it gets even worse. NSURL has an awkward pair of methods to get &quot;resource values&quot; which would be better expressed as a throwing read-write subscript:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift can handle these cases better by allowing getters and setters to throw.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-computed-properties&gt;Throwing computed properties<br>&gt; <br>&gt; You can mark a computed property accessor as throwing by putting throws after the get or set keyword:<br>&gt; <br>&gt; var property: Int {<br>&gt;     get throws { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool {<br>&gt;     get throws { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; The throwing behavior of the getter and setter are completely independent; a throwing getter can be paired with a non-throwing setter, or vice versa.<br>&gt; <br>&gt; var property: Int {<br>&gt;     get throws { ... }<br>&gt;     set { ... }<br>&gt; }<br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool {<br>&gt;     get { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; A protocol (or, if added later, an abstract class) can specify the throwing behavior of properties and subscripts it requires:<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;     var property: Int { get throws set throws }<br>&gt;     subscript(index: Int) -&gt; Bool { get throws set throws }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-stored-properties&gt;Throwing stored properties<br>&gt; <br>&gt; A stored property can also be given a throwing setter by giving it a willSet accessor that throws:<br>&gt; <br>&gt; var property: Int {<br>&gt;     willSet throws {<br>&gt;         guard newValue &gt;= 0 else {<br>&gt;             throw MyError.PropertyOutOfRange (newValue)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#importing-throwing-property-accessors-from-objective-c&gt;Importing throwing property accessors from Objective-C<br>&gt; <br>&gt; When a readonly property foo of type T is imported from Objective-C, but a method like this exists on the same type:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value error:(NSError**)error;<br>&gt; Swift will import foo as a readwrite property with a throwing setter.<br>&gt; <br>&gt; If SE-0044 Import as member &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; is accepted, we should also be able to apply the swift_name attribute to methods of these forms to create properties with throwing getters:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;     // property is not optional<br>&gt; - (BOOL)getFoo:(T*)outValue error:(NSError**)error;<br>&gt; No imports for throwing subscript accessors are specified.<br>&gt; <br>&gt; These transformations should be applied to both classes and protocols.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#exporting-throwing-property-and-subscript-accessors-to-objective-c&gt;Exporting throwing property and subscript accessors to Objective-C<br>&gt; <br>&gt; A throwing setter for a property foo of type T should be exposed to Objective-C as:<br>&gt; <br>&gt; - (void)setFoo:(T)value error:(NSError**)error;<br>&gt; A throwing getter for a property foo of type T, where T is not optional but can be nullable in Objective-C, should be exposed to Objective-C as:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;<br>&gt; Otherwise, the getter should be exposed as:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue error:(NSError**)error;<br>&gt; A throwing setter for a subscript of type T with an index of type I, if marked with @objc(name), should be compatible with this signature:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value atIndex:(I)index error:(NSError**)error;<br>&gt; A throwing getter for a subscript of type T with index I, where T is not optional but can be nullable in Objective-C, should be compatible with this signature:<br>&gt; <br>&gt; - (nullable T)fooAtIndex:(I)index error:(NSError**)error;<br>&gt; Otherwise, the getter should be have a name compatible with this signature:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue atIndex:(I)index error:(NSError**)error;<br>&gt; Throwing subscript accessors which are not marked with @objc(name) will not be exposed to Objective-C.<br>&gt; <br>&gt; These transformations should be applied to both classes and @objc protocols.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#subscripts-with-rethrows&gt;Subscripts with rethrows<br>&gt; <br>&gt; rethrows is not supported on properties, but it is supported on subscripts. The rethrowing behavior depends only on the subscript&#39;s parameters, not the setter&#39;s newValue; that is, a particular subscript access can throw iff at least one of the functions inside the square brackets can throw.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-accessors-and-inout-parameters&gt;Throwing accessors and inout parameters<br>&gt; <br>&gt; A throwing property or subscript access can be passed as an inout parameter. The call it is passed to must be marked with the try keyword.<br>&gt; <br>&gt; To avoid unpredictable interactions between inout and throwing accessors, Swift will guarantee the getter is invoked once before the call and the setter once after the call. The compiler will not apply optimizations which might cause errors to be thrown in the middle of the function.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-requirement-compatibility&gt;Throwing requirement compatibility<br>&gt; <br>&gt; An implementation can be &quot;less&quot; throwing than a requirement it is intended to satisfy. That is:<br>&gt; <br>&gt; A throwing accessor requirement can be fulfilled by a throwing, rethrowing, or non-throwing accessor.<br>&gt; A rethrowing accessor requirement can be fulfilled by a rethrowing or non-throwing accessor.<br>&gt; A non-throwing accessor requirement can be fulfilled only by a non-throwing accessor.<br>&gt; These definitions apply to protocol (and abstract class) conformance, subclass overrides, and library resilience. (Note that last point: Swift must permit an accessor to be made less throwing without breaking binary compatibility.)<br>&gt; <br>&gt; When overriding a throwing accessor, the override must explicitly state the expected level of throwing behavior; omitting the keyword means the accessor is non-throwing. That is, in this example, Subclass.foo&#39;s setter is not automatically throws:<br>&gt; <br>&gt; class Superclass {<br>&gt;     var foo: Int {<br>&gt;         willSet throws { ... }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Subclass: Superclass {<br>&gt;     override var foo: Int {<br>&gt;         set { try super.foo = newValue }<br>&gt;         // Error: nonthrowing setter includes throwing statement<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#implementation&gt;Implementation<br>&gt; <br>&gt; The internal materializeForSet is as throwing as the &quot;most&quot; throwing of get and set.<br>&gt; <br>&gt; FIXME: Beyond that, I have no idea. Sorry. Please help me fill this out.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Some APIs will be imported differently, breaking call sites. The Swift compiler will need to provide fix-it and migration support for these cases.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#require-setters-to-be-at-least-as-throwing-as-getters&gt;Require setters to be at least as throwing as getters<br>&gt; <br>&gt; Calling a setter often implicitly involves calling a getter, so it may make sense to require the setter to be at least as throwing as the getter. Absent feedback to this effect from implementors, however, my instinct is to leave them independent, as there may be use cases where a get can throw but a set cannot. (For instance, if an instance faults in data from an external source on demand, but only writes that data back when a save() call is invoked, get may throw if it&#39;s unable to fault in the data, but set would never need to throw.)<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#make-rethrows-setters-throwing-if-newvalue-is-throwing&gt;Make rethrows setters throwing if newValue is throwing<br>&gt; <br>&gt; newValue is sort of like a parameter to the setter, so it might technically be more consistent for rethrows to consider newValue when deciding if a particular invocation throws or not. However, I can&#39;t imagine a case where this would be appropriate behavior, and considering only the subscript parameters makes the getter and setter work better together.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#dont-include-willset-throws&gt;Don&#39;t include willSet throws<br>&gt; <br>&gt; The use of willSet throws to make a stored property throwing is a bit funky and could be omitted. I decided to include it because, if it does not exist, people will fake it with private properties anyway.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#include-didset-throws&gt;Include didSet throws<br>&gt; <br>&gt; There is no technical reason not to support didSet throws accessors, which would allow stored properties to be made throwing. However, this would usually be the wrong thing to do because it would leave the errant value in the property. If compelling use cases for it were cited, however, didSet throws could be added.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#permit-try-on-foo-itself-rather-than-the-call-using-it&gt;Permit try on &amp;foo itself, rather than the call using it<br>&gt; <br>&gt; As specified, if foo has a throwing accessor and you want to pass it to a function bar with an inout parameter, you have to write this:<br>&gt; <br>&gt; try bar(&amp;foo)<br>&gt; In theory, we could instead allow you to mark only the &amp; operator, leaving the rest of the expression uncovered by the try:<br>&gt; <br>&gt; bar(try &amp;foo)<br>&gt; This would make the source of the potential error more obvious, but it might make the semantics less clear, because try &amp;foo can throw after the call is finished in addition to before. I judge the latter issue to be more serious.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#try-to-convert-keyed-gettersetter-methods-to-subscripts&gt;Try to convert keyed getter/setter methods to subscripts<br>&gt; <br>&gt; Swift could conceivably apply heuristics to discover Objective-C method pairs that can be expressed as subscripts. For instance, the NSURL method pair cited in the Motivation section:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt; Could be imported like this:<br>&gt; <br>&gt; subscript (resourceValueFor key: String) -&gt; AnyObject? {<br>&gt;     get throws<br>&gt;     set throws<br>&gt; }<br>&gt; There are several reasons not to do this:<br>&gt; <br>&gt; There is no established pattern for throwing subscripts in Objective-C, so any we might establish would be mistake-prone.<br>&gt; SE-0044 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; does not currently include subscripts, so there is no proposal pending which would allow the heuristic to be tweaked or the import logic to be invoked manually. (This is arguably an oversight in SE-0044.)<br>&gt; Many such cases would benefit from a human looking at the design. In the NSURL case, for instance, a human looking at the broader type might prefer a design like this:<br>&gt; var resourceValues: ResourceValues { get } <br>&gt; <br>&gt; struct ResourceValues {<br>&gt;     subscript (key: String) -&gt; AnyObject? {<br>&gt;         get throws { ... }<br>&gt;         set throws { ... }<br>&gt;     }<br>&gt; <br>&gt;     func get(for keys: [String]) throws -&gt; [String: AnyObject] { ... }<br>&gt;     func set(from dict: [String: AnyObject]) throws { ... }<br>&gt; <br>&gt;     func removeCachedKeys() { ... }<br>&gt;     func removeCachedKey(key: String) { ... }<br>&gt;     func setTemporaryValue(_ value: AnyObject?, for key: String) { ... }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#automatically-export-throwing-subscript-accessors-to-objective-c&gt;Automatically export throwing subscript accessors to Objective-C<br>&gt; <br>&gt; Throwing subscript accessors can only be exported by specifying a name using an @objc property. It might be nice to export them by default, but Objective-C doesn&#39;t have an established pattern for throwing subscript accessors, so it&#39;s not clear how these methods would be named.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#add-a-nothrows-keyword&gt;Add a nothrows keyword<br>&gt; <br>&gt; Leaving an accessor&#39;s throwing behavior unspecified could make it automatically take on the behavior required by the type&#39;s superclass or conformed protocols. However, this would require a way to explicitly state that an accessor could notthrow, along the lines of the rarely-used but necessary nonmutating keyword.<br>&gt; <br>&gt; I have chosen not to do this because Swift generally does not allow you to infer parts of a member&#39;s signature, and because I cannot come up with a way to spell this keyword that isn&#39;t ugly as sin.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/d9fa2680/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>March 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Beautiful! Big +1 here<br></p><p>&gt; On Mar 13, 2016, at 11:07 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve drafted a proposal to allow property and subscript accessors to throw errors:<br>&gt; <br>&gt; 	&lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md &lt;https://github.com/brentdax/swift-evolution/blob/throwing-properties-draft/proposals/0000-throwing-properties.md&gt;&gt;<br>&gt; <br>&gt; I&#39;ve left a lot of the rationale for particular design decisions for the &quot;Alternatives considered&quot; section, so please take a look at that before you ask, for instance, why this proposal doesn&#39;t import any Objective-C methods as throwing subscript accessors.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Throwing Properties and Subscripts<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#introduction&gt;Introduction<br>&gt; <br>&gt; Functions, methods, and initializers can be marked throws to indicate that they can fail by throwing an error, but properties and subscripts cannot. This proposal extends properties and subscripts to support throws and rethrows accessors, and also specifies logic for bridging these accessors to and from Objective-C.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Allow Getters and Setters to Throw &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001165.html&gt;<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#motivation&gt;Motivation<br>&gt; <br>&gt; Sometimes, something that is genuinely getter- or setter-like needs to be able to throw an error. This is particularly common with properties which convert between formats:<br>&gt; <br>&gt; var image: UIImage<br>&gt; <br>&gt; var imageData: NSData {<br>&gt;     get {<br>&gt;         return UIImagePNGRepresentation(image)<br>&gt;     }<br>&gt;     set {<br>&gt;         image = UIImage(data: newValue) ?? throw OopsICantThrowHere<br>&gt;     }<br>&gt; }<br>&gt; Or which access some external resource which may not be able to perform the operation:<br>&gt; <br>&gt; var avatar: UIImage {<br>&gt;     get {<br>&gt;         let data = try NSData(contentsOfURL: avatarURL, options: [])    /* can&#39;t try here! */<br>&gt;         return UIImage(data: data)<br>&gt;     }<br>&gt; }<br>&gt; The current best solution to this problem is to write a method instead of a property. This can lead to unnatural API designs; the class AVAudioSession alone, for instance, has no less than ten mismatched property/setter method pairs:<br>&gt; <br>&gt; var category: String { get }<br>&gt; func setCategory(_ category: String) throws<br>&gt; <br>&gt; var mode: String { get }<br>&gt; func setMode(_ mode: String) throws<br>&gt; <br>&gt; var inputGain: Float { get }<br>&gt; func setInputGain(_ gain: Float) throws<br>&gt; <br>&gt; var preferredSampleRate: Double { get }<br>&gt; func setPreferredSampleRate(_ sampleRate: Double) throws<br>&gt; <br>&gt; var preferredIOBufferDuration: NSTimeInterval { get }<br>&gt; func setPreferredIOBufferDuration(_ duration: NSTimeInterval) throws<br>&gt; <br>&gt; var preferredInputNumberOfChannels: Int { get }<br>&gt; func setPreferredInputNumberOfChannels(_ count: Int) throws<br>&gt; <br>&gt; var preferredOutputNumberOfChannels: Int { get }<br>&gt; func setPreferredOutputNumberOfChannels(_ count: Int) throws<br>&gt; <br>&gt; var preferredInput: AVAudioSessionPortDescription? { get }<br>&gt; func setPreferredInput(_ inPort: AVAudioSessionPortDescription?) throws<br>&gt; <br>&gt; var inputDataSource: AVAudioSessionDataSourceDescription? { get }<br>&gt; func setInputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>&gt; <br>&gt; var outputDataSource: AVAudioSessionDataSourceDescription? { get }<br>&gt; func setOutputDataSource(_ dataSource: AVAudioSessionDataSourceDescription?) throws<br>&gt; While most classes aren&#39;t nearly this bad, you see the same problem elsewhere in the frameworks. The Mac-only CoreWLAN framework has similar mismatched property/setter method pairs (though it also has other bridging issues; I suspect it&#39;s too obscure to have been audited yet):<br>&gt; <br>&gt; func wlanChannel() -&gt; CWChannel!<br>&gt; func setWLANChannel(_ channel: CWChannel!, error error: NSErrorPointer) -&gt; Bool<br>&gt; <br>&gt; func powerOn() -&gt; Bool<br>&gt; func setPower(_ power: Bool, error error: NSErrorPointer) -&gt; Bool<br>&gt; When the getter can throw, it gets even worse. NSURL has an awkward pair of methods to get &quot;resource values&quot; which would be better expressed as a throwing read-write subscript:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; Swift can handle these cases better by allowing getters and setters to throw.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-computed-properties&gt;Throwing computed properties<br>&gt; <br>&gt; You can mark a computed property accessor as throwing by putting throws after the get or set keyword:<br>&gt; <br>&gt; var property: Int {<br>&gt;     get throws { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool {<br>&gt;     get throws { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; The throwing behavior of the getter and setter are completely independent; a throwing getter can be paired with a non-throwing setter, or vice versa.<br>&gt; <br>&gt; var property: Int {<br>&gt;     get throws { ... }<br>&gt;     set { ... }<br>&gt; }<br>&gt; <br>&gt; subscript(index: Int) -&gt; Bool {<br>&gt;     get { ... }<br>&gt;     set throws { ... }<br>&gt; }<br>&gt; A protocol (or, if added later, an abstract class) can specify the throwing behavior of properties and subscripts it requires:<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;     var property: Int { get throws set throws }<br>&gt;     subscript(index: Int) -&gt; Bool { get throws set throws }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-stored-properties&gt;Throwing stored properties<br>&gt; <br>&gt; A stored property can also be given a throwing setter by giving it a willSet accessor that throws:<br>&gt; <br>&gt; var property: Int {<br>&gt;     willSet throws {<br>&gt;         guard newValue &gt;= 0 else {<br>&gt;             throw MyError.PropertyOutOfRange (newValue)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#importing-throwing-property-accessors-from-objective-c&gt;Importing throwing property accessors from Objective-C<br>&gt; <br>&gt; When a readonly property foo of type T is imported from Objective-C, but a method like this exists on the same type:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value error:(NSError**)error;<br>&gt; Swift will import foo as a readwrite property with a throwing setter.<br>&gt; <br>&gt; If SE-0044 Import as member &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; is accepted, we should also be able to apply the swift_name attribute to methods of these forms to create properties with throwing getters:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;     // property is not optional<br>&gt; - (BOOL)getFoo:(T*)outValue error:(NSError**)error;<br>&gt; No imports for throwing subscript accessors are specified.<br>&gt; <br>&gt; These transformations should be applied to both classes and protocols.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#exporting-throwing-property-and-subscript-accessors-to-objective-c&gt;Exporting throwing property and subscript accessors to Objective-C<br>&gt; <br>&gt; A throwing setter for a property foo of type T should be exposed to Objective-C as:<br>&gt; <br>&gt; - (void)setFoo:(T)value error:(NSError**)error;<br>&gt; A throwing getter for a property foo of type T, where T is not optional but can be nullable in Objective-C, should be exposed to Objective-C as:<br>&gt; <br>&gt; - (nullable T)foo:(NSError**)error;<br>&gt; Otherwise, the getter should be exposed as:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue error:(NSError**)error;<br>&gt; A throwing setter for a subscript of type T with an index of type I, if marked with @objc(name), should be compatible with this signature:<br>&gt; <br>&gt; - (BOOL)setFoo:(T)value atIndex:(I)index error:(NSError**)error;<br>&gt; A throwing getter for a subscript of type T with index I, where T is not optional but can be nullable in Objective-C, should be compatible with this signature:<br>&gt; <br>&gt; - (nullable T)fooAtIndex:(I)index error:(NSError**)error;<br>&gt; Otherwise, the getter should be have a name compatible with this signature:<br>&gt; <br>&gt; - (BOOL)getFoo:(nonnull T*)outValue atIndex:(I)index error:(NSError**)error;<br>&gt; Throwing subscript accessors which are not marked with @objc(name) will not be exposed to Objective-C.<br>&gt; <br>&gt; These transformations should be applied to both classes and @objc protocols.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#subscripts-with-rethrows&gt;Subscripts with rethrows<br>&gt; <br>&gt; rethrows is not supported on properties, but it is supported on subscripts. The rethrowing behavior depends only on the subscript&#39;s parameters, not the setter&#39;s newValue; that is, a particular subscript access can throw iff at least one of the functions inside the square brackets can throw.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-accessors-and-inout-parameters&gt;Throwing accessors and inout parameters<br>&gt; <br>&gt; A throwing property or subscript access can be passed as an inout parameter. The call it is passed to must be marked with the try keyword.<br>&gt; <br>&gt; To avoid unpredictable interactions between inout and throwing accessors, Swift will guarantee the getter is invoked once before the call and the setter once after the call. The compiler will not apply optimizations which might cause errors to be thrown in the middle of the function.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#throwing-requirement-compatibility&gt;Throwing requirement compatibility<br>&gt; <br>&gt; An implementation can be &quot;less&quot; throwing than a requirement it is intended to satisfy. That is:<br>&gt; <br>&gt; A throwing accessor requirement can be fulfilled by a throwing, rethrowing, or non-throwing accessor.<br>&gt; A rethrowing accessor requirement can be fulfilled by a rethrowing or non-throwing accessor.<br>&gt; A non-throwing accessor requirement can be fulfilled only by a non-throwing accessor.<br>&gt; These definitions apply to protocol (and abstract class) conformance, subclass overrides, and library resilience. (Note that last point: Swift must permit an accessor to be made less throwing without breaking binary compatibility.)<br>&gt; <br>&gt; When overriding a throwing accessor, the override must explicitly state the expected level of throwing behavior; omitting the keyword means the accessor is non-throwing. That is, in this example, Subclass.foo&#39;s setter is not automatically throws:<br>&gt; <br>&gt; class Superclass {<br>&gt;     var foo: Int {<br>&gt;         willSet throws { ... }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Subclass: Superclass {<br>&gt;     override var foo: Int {<br>&gt;         set { try super.foo = newValue }<br>&gt;         // Error: nonthrowing setter includes throwing statement<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#implementation&gt;Implementation<br>&gt; <br>&gt; The internal materializeForSet is as throwing as the &quot;most&quot; throwing of get and set.<br>&gt; <br>&gt; FIXME: Beyond that, I have no idea. Sorry. Please help me fill this out.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Some APIs will be imported differently, breaking call sites. The Swift compiler will need to provide fix-it and migration support for these cases.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#require-setters-to-be-at-least-as-throwing-as-getters&gt;Require setters to be at least as throwing as getters<br>&gt; <br>&gt; Calling a setter often implicitly involves calling a getter, so it may make sense to require the setter to be at least as throwing as the getter. Absent feedback to this effect from implementors, however, my instinct is to leave them independent, as there may be use cases where a get can throw but a set cannot. (For instance, if an instance faults in data from an external source on demand, but only writes that data back when a save() call is invoked, get may throw if it&#39;s unable to fault in the data, but set would never need to throw.)<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#make-rethrows-setters-throwing-if-newvalue-is-throwing&gt;Make rethrows setters throwing if newValue is throwing<br>&gt; <br>&gt; newValue is sort of like a parameter to the setter, so it might technically be more consistent for rethrows to consider newValue when deciding if a particular invocation throws or not. However, I can&#39;t imagine a case where this would be appropriate behavior, and considering only the subscript parameters makes the getter and setter work better together.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#dont-include-willset-throws&gt;Don&#39;t include willSet throws<br>&gt; <br>&gt; The use of willSet throws to make a stored property throwing is a bit funky and could be omitted. I decided to include it because, if it does not exist, people will fake it with private properties anyway.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#include-didset-throws&gt;Include didSet throws<br>&gt; <br>&gt; There is no technical reason not to support didSet throws accessors, which would allow stored properties to be made throwing. However, this would usually be the wrong thing to do because it would leave the errant value in the property. If compelling use cases for it were cited, however, didSet throws could be added.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#permit-try-on-foo-itself-rather-than-the-call-using-it&gt;Permit try on &amp;foo itself, rather than the call using it<br>&gt; <br>&gt; As specified, if foo has a throwing accessor and you want to pass it to a function bar with an inout parameter, you have to write this:<br>&gt; <br>&gt; try bar(&amp;foo)<br>&gt; In theory, we could instead allow you to mark only the &amp; operator, leaving the rest of the expression uncovered by the try:<br>&gt; <br>&gt; bar(try &amp;foo)<br>&gt; This would make the source of the potential error more obvious, but it might make the semantics less clear, because try &amp;foo can throw after the call is finished in addition to before. I judge the latter issue to be more serious.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#try-to-convert-keyed-gettersetter-methods-to-subscripts&gt;Try to convert keyed getter/setter methods to subscripts<br>&gt; <br>&gt; Swift could conceivably apply heuristics to discover Objective-C method pairs that can be expressed as subscripts. For instance, the NSURL method pair cited in the Motivation section:<br>&gt; <br>&gt; func getResourceValue(_ value: AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey key: String) throws<br>&gt; func setResourceValue(_ value: AnyObject?, forKey key: String) throws<br>&gt; Could be imported like this:<br>&gt; <br>&gt; subscript (resourceValueFor key: String) -&gt; AnyObject? {<br>&gt;     get throws<br>&gt;     set throws<br>&gt; }<br>&gt; There are several reasons not to do this:<br>&gt; <br>&gt; There is no established pattern for throwing subscripts in Objective-C, so any we might establish would be mistake-prone.<br>&gt; SE-0044 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md&gt; does not currently include subscripts, so there is no proposal pending which would allow the heuristic to be tweaked or the import logic to be invoked manually. (This is arguably an oversight in SE-0044.)<br>&gt; Many such cases would benefit from a human looking at the design. In the NSURL case, for instance, a human looking at the broader type might prefer a design like this:<br>&gt; var resourceValues: ResourceValues { get } <br>&gt; <br>&gt; struct ResourceValues {<br>&gt;     subscript (key: String) -&gt; AnyObject? {<br>&gt;         get throws { ... }<br>&gt;         set throws { ... }<br>&gt;     }<br>&gt; <br>&gt;     func get(for keys: [String]) throws -&gt; [String: AnyObject] { ... }<br>&gt;     func set(from dict: [String: AnyObject]) throws { ... }<br>&gt; <br>&gt;     func removeCachedKeys() { ... }<br>&gt;     func removeCachedKey(key: String) { ... }<br>&gt;     func setTemporaryValue(_ value: AnyObject?, for key: String) { ... }<br>&gt; }<br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#automatically-export-throwing-subscript-accessors-to-objective-c&gt;Automatically export throwing subscript accessors to Objective-C<br>&gt; <br>&gt; Throwing subscript accessors can only be exported by specifying a name using an @objc property. It might be nice to export them by default, but Objective-C doesn&#39;t have an established pattern for throwing subscript accessors, so it&#39;s not clear how these methods would be named.<br>&gt; <br>&gt;  &lt;https://github.com/brentdax/swift-evolution/tree/throwing-properties-draft#add-a-nothrows-keyword&gt;Add a nothrows keyword<br>&gt; <br>&gt; Leaving an accessor&#39;s throwing behavior unspecified could make it automatically take on the behavior required by the type&#39;s superclass or conformed protocols. However, this would require a way to explicitly state that an accessor could notthrow, along the lines of the rarely-used but necessary nonmutating keyword.<br>&gt; <br>&gt; I have chosen not to do this because Swift generally does not allow you to infer parts of a member&#39;s signature, and because I cannot come up with a way to spell this keyword that isn&#39;t ugly as sin.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160314/50f5780d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Draft] Throwing Properties and Subscripts</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>March 16, 2016 at 08:00:00am</p></header><div class="content"><p>This is an interesting proposal.<br></p><p>I have a couple of throwing `setSomething` methods in my code that could be expressed as throwing property setters. That said, I don&#39;t really mind them being methods. Methods having a verb in their names makes them fit well with `try` at the call site.<br></p><p>I also have a getter returning nil when it fails to retrieve its data, in which case an error becomes available in a separate `error` property. That would seem like an ideal case for a throwing getter... but I&#39;m not too sure I&#39;d use the feature in this case because if an error occurs in this part of the code I actually want to make that error become part of the state of the object, stored and available separately for use at a later point. Basically a non-interrupting error. So I find my current approach is actually quite fitting and I don&#39;t feel a throwing getter is something I really need. Perhaps this is something particular to my use case, but if I needed it to throw I&#39;d use a method and it&#39;d be perfectly fine.<br></p><p>All that to say I&#39;m pretty much neutral on this feature. To me it does not really add capabilities to the language, it just makes possible to do with properties certain things you can already do with methods, and I&#39;m perfectly willing to use methods for things that can throw. But if properties could throw, especially the setter, I&#39;d probably use the feature at some places.<br></p><p>And whatever we end up with for properties, I feel subscripts should work the same. Subscripts are just parametrized properties.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
