<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 23, 2016 at 03:00:00pm</p></header><div class="content"><p>I am trying to run some Swift code that relies on Foundation on Linux<br>(it is thoughtbot&#39;s Argo library if anyone wants to know the exact<br>code).<br></p><p>There is a fairly simple extension to NSNumber that looks like:<br></p><p>import Foundation<br></p><p>extension NSNumber {<br>  var isBool: Bool {<br>    return CFBooleanGetTypeID() == CFGetTypeID(self)<br>  }<br>}<br></p><p>However it seems that Foundation on Linux has neither<br>`CFBooleanGetTypeID` or `CFGetTypeID`.<br></p><p>Is this expected?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; However it seems that Foundation on Linux has neither<br>&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br></p><p>Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br></p><p>But I think you’re using the in-development Swift Foundation? That’s a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160523/bdc21f84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 23, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;<br>&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-<br>&gt;&gt; users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;<br>&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS<br>&gt; Foundation framework is built. The two have a complicated<br>&gt; relationship; Foundation exposes most but not all of the<br>&gt; CoreFoundation APIs as Objective-C, but there are still some features<br>&gt; you have to drop down to C to use. This is one.<br>&gt;<br>&gt; But I think you’re using the in-development Swift Foundation? That’s a<br>&gt; different implementation entirely. Presumably it will have some API of<br>&gt; its own to determine the type of a number.<br> <br>Yes I&#39;m using the in-development Swift Foundation. From what I can tell<br>this version is the one that will be used on non-Darwin platforms.<br> <br>Assuming that such an API does not currently exist on NSNumber, I&#39;m<br>reasonably confident that it does not, does this mean that a Swift<br>Evolution thread has to be started to add it?<br> <br>&gt;<br>&gt; —Jens<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160523/52185fe7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Ryan,<br></p><p>NSNumber basically exists to hide the underlying number type.<br></p><p>Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>- Tony<br></p><p>&gt; On May 23, 2016, at 2:01 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br>&gt;&gt;  <br>&gt;&gt; But I think you’re using the in-development Swift Foundation? That’s a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br>&gt;  <br>&gt; Yes I&#39;m using the in-development Swift Foundation. From what I can tell this version is the one that will be used on non-Darwin platforms.<br>&gt;  <br>&gt; Assuming that such an API does not currently exist on NSNumber, I&#39;m reasonably confident that it does not, does this mean that a Swift Evolution thread has to be started to add it?<br>&gt;  <br>&gt;&gt;  <br>&gt;&gt; —Jens<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/bc498412/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 11:03 AM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>I don’t remember the original code snippet, but there are cases where you need to know what type of number is stored in an NSNumber. An example is encoding to JSON, where a boolean value should be written as “true” or “false”, not “1” or “0”.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/9c61d1df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:49 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 11:03 AM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br>&gt; <br>&gt; I don’t remember the original code snippet, but there are cases where you need to know what type of number is stored in an NSNumber. An example is encoding to JSON, where a boolean value should be written as “true” or “false”, not “1” or “0”.<br>&gt; <br>&gt; —Jens<br></p><p>Fair enough, and we do use this trick in NSJSONSerialization(.m).<br></p><p>One other possibility is using the objCType property on NSNumber’s superclass NSValue to check. I haven’t seen how much of this is implemented in corelibs-foundation yet. We did redefine Boolean to _Bool in Swift CF, so we’ll have to see if that accidentally resulted in a runtime difference between platforms here that we didn’t consider.<br></p><p>- Tony<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/c6ea738f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; One other possibility is using the objCType property on NSNumber’s superclass NSValue to check.<br></p><p>That doesn’t work, unfortunately, at least not with Apple’s Foundation. NSNumbers initialized with booleans have objcType “c” because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br></p><p>Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br></p><p>    char ctype = self.objCType[0];<br>    switch (ctype) {<br>        case &#39;c&#39;: {<br>            // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>            // compare it against the singleton kCFBoolean objects:<br>            if (self == (id)kCFBooleanTrue)<br>                return yajl_gen_bool(gen, true);<br>            else if (self == (id)kCFBooleanFalse)<br>                return yajl_gen_bool(gen, false);<br>            else<br>                return yajl_gen_integer(gen, self.longLongValue);<br>        }<br></p><p>&gt; I haven’t seen how much of this is implemented in corelibs-foundation yet. <br></p><p>I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn’t seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/56ac66e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Let’s get a bug into JIRA, then we’ll figure out what we should do here.<br></p><p>- Tony<br></p><p>&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One other possibility is using the objCType property on NSNumber’s superclass NSValue to check.<br>&gt; <br>&gt; That doesn’t work, unfortunately, at least not with Apple’s Foundation. NSNumbers initialized with booleans have objcType “c” because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt; <br>&gt; Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt; <br>&gt;     char ctype = self.objCType[0];<br>&gt;     switch (ctype) {<br>&gt;         case &#39;c&#39;: {<br>&gt;             // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;             // compare it against the singleton kCFBoolean objects:<br>&gt;             if (self == (id)kCFBooleanTrue)<br>&gt;                 return yajl_gen_bool(gen, true);<br>&gt;             else if (self == (id)kCFBooleanFalse)<br>&gt;                 return yajl_gen_bool(gen, false);<br>&gt;             else<br>&gt;                 return yajl_gen_integer(gen, self.longLongValue);<br>&gt;         }<br>&gt; <br>&gt;&gt; I haven’t seen how much of this is implemented in corelibs-foundation yet. <br>&gt; <br>&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn’t seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt; <br>&gt; —Jens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/1795b4f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt; Let’s get a bug into JIRA, then we’ll figure out what we should<br>&gt; do here.<br> <br>That&#39;s the problem for me. What is the bug? Based on the code example I<br>provided in this thread. I&#39;m somewhat convinced that the bug is that<br>Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the<br>behavior of Foundation on Darwin, yet it has the desired behavior.<br> <br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber’s<br>&gt;&gt;&gt; superclass NSValue to check.<br>&gt;&gt;<br>&gt;&gt; That doesn’t work, unfortunately, at least not with Apple’s<br>&gt;&gt; Foundation. NSNumbers initialized with booleans have objcType “c”<br>&gt;&gt; because `BOOL` is just a typedef for `char`. So the only way to tell<br>&gt;&gt; a boolean apart from an 8-bit int is to compare the object pointer<br>&gt;&gt; against the singleton true and false objects.<br>&gt;&gt;<br>&gt;&gt; Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;<br>&gt;&gt; *char* ctype = *self*.*objCType*[];<br>&gt;&gt;  *switch* (ctype) {<br>&gt;&gt;  *case* &#39;c&#39;: {<br>&gt;&gt;  *// The only way to tell whether an NSNumber with &#39;char&#39; type is a<br>&gt;&gt;  boolean is to*<br>&gt;&gt;  *// compare it against the singleton kCFBoolean objects:*<br>&gt;&gt;  *if* (*self* == (*id*)*kCFBooleanTrue*)<br>&gt;&gt;  *return* yajl_gen_bool(gen, *true*);<br>&gt;&gt;  *else* *if* (*self* == (*id*)*kCFBooleanFalse*)<br>&gt;&gt;  *return* yajl_gen_bool(gen, *false*);<br>&gt;&gt;  *else*<br>&gt;&gt;  *return* yajl_gen_integer(gen, *self*.*longLongValue*);<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;&gt; I haven’t seen how much of this is implemented in corelibs-<br>&gt;&gt;&gt; foundation yet.<br>&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on<br>&gt;&gt; Github, and the objcType stuff doesn’t seem to be functional. It<br>&gt;&gt; looks like objcType will only have a value if the object was<br>&gt;&gt; initialized as an NSValue with the type code passed in, not if the<br>&gt;&gt; typical NSNumber initializers were used.<br>&gt;&gt;<br>&gt;&gt; —Jens<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/74dea257/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt; Let’s get a bug into JIRA, then we’ll figure out what we should do here.<br>&gt;  <br>&gt; That&#39;s the problem for me. What is the bug? Based on the code example I provided in this thread. I&#39;m somewhat convinced that the bug is that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the behavior of Foundation on Darwin, yet it has the desired behavior.<br></p><p>What I mean is that I want to track the issue in JIRA so we don’t lose it, and so we can find it later when looking for issues that prevent fully cross-platform behavior. We can look into fixing these in several ways, including adding new API in both frameworks, changing implementations, etc.<br></p><p>- Tony<br></p><p>&gt;  <br>&gt;&gt;  <br>&gt;&gt; - Tony<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber’s superclass NSValue to check.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That doesn’t work, unfortunately, at least not with Apple’s Foundation. NSNumbers initialized with booleans have objcType “c” because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     char ctype = self.objCType[0];<br>&gt;&gt;&gt; switch (ctype) {<br>&gt;&gt;&gt; case &#39;c&#39;: {<br>&gt;&gt;&gt; // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;&gt;&gt; // compare it against the singleton kCFBoolean objects:<br>&gt;&gt;&gt; if (self == (id)kCFBooleanTrue)<br>&gt;&gt;&gt; return yajl_gen_bool(gen, true);<br>&gt;&gt;&gt; else if (self == (id)kCFBooleanFalse)<br>&gt;&gt;&gt; return yajl_gen_bool(gen, false);<br>&gt;&gt;&gt; else<br>&gt;&gt;&gt; return yajl_gen_integer(gen, self.longLongValue);<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I haven’t seen how much of this is implemented in corelibs-foundation yet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn’t seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; —Jens<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/815ca135/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:19 PM, Tony Parker wrote:<br>&gt;<br>&gt;&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-<br>&gt;&gt; dev at ryan.lovelett.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt;&gt; Let’s get a bug into JIRA, then we’ll figure out what we should<br>&gt;&gt;&gt; do here.<br>&gt;&gt;<br>&gt;&gt; That&#39;s the problem for me. What is the bug? Based on the code example<br>&gt;&gt; I provided in this thread. I&#39;m somewhat convinced that the bug is<br>&gt;&gt; that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match<br>&gt;&gt; the behavior of Foundation on Darwin, yet it has the desired<br>&gt;&gt; behavior.<br>&gt;<br>&gt; What I mean is that I want to track the issue in JIRA so we don’t lose<br>&gt; it, and so we can find it later when looking for issues that prevent<br>&gt; fully cross-platform behavior. We can look into fixing these in<br>&gt; several ways, including adding new API in both frameworks, changing<br>&gt; implementations, etc.<br> <br>I have filed a bug https://bugs.swift.org/browse/SR-1610<br> <br>Obviously please reformat/update accordingly. This was the best I could<br>come up with.<br> <br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker<br>&gt;&gt;&gt;&gt;&gt; &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber’s<br>&gt;&gt;&gt;&gt;&gt; superclass NSValue to check.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That doesn’t work, unfortunately, at least not with Apple’s<br>&gt;&gt;&gt;&gt; Foundation. NSNumbers initialized with booleans have objcType “c”<br>&gt;&gt;&gt;&gt; because `BOOL` is just a typedef for `char`. So the only way to<br>&gt;&gt;&gt;&gt; tell a boolean apart from an 8-bit int is to compare the object<br>&gt;&gt;&gt;&gt; pointer against the singleton true and false objects.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *char* ctype = *self*.*objCType*[];<br>&gt;&gt;&gt;&gt; *switch* (ctype) {<br>&gt;&gt;&gt;&gt; *case* &#39;c&#39;: {<br>&gt;&gt;&gt;&gt; *// The only way to tell whether an NSNumber with &#39;char&#39; type is a<br>&gt;&gt;&gt;&gt; boolean is to*<br>&gt;&gt;&gt;&gt; *// compare it against the singleton kCFBoolean objects:*<br>&gt;&gt;&gt;&gt; *if* (*self* == (*id*)*kCFBooleanTrue*)<br>&gt;&gt;&gt;&gt; *return* yajl_gen_bool(gen, *true*);<br>&gt;&gt;&gt;&gt; *else* *if* (*self* == (*id*)*kCFBooleanFalse*)<br>&gt;&gt;&gt;&gt; *return* yajl_gen_bool(gen, *false*);<br>&gt;&gt;&gt;&gt; *else*<br>&gt;&gt;&gt;&gt; *return* yajl_gen_integer(gen, *self*.*longLongValue*);<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I haven’t seen how much of this is implemented in corelibs-<br>&gt;&gt;&gt;&gt;&gt; foundation yet.<br>&gt;&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on<br>&gt;&gt;&gt;&gt; Github, and the objcType stuff doesn’t seem to be functional. It<br>&gt;&gt;&gt;&gt; looks like objcType will only have a value if the object was<br>&gt;&gt;&gt;&gt; initialized as an NSValue with the type code passed in, not if the<br>&gt;&gt;&gt;&gt; typical NSNumber initializers were used.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; —Jens<br>&gt;&gt;<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/bb709799/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>That’s perfect, thanks Ryan.<br></p><p>- Tony<br></p><p>&gt; On May 24, 2016, at 1:39 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; On Tue, May 24, 2016, at 04:19 PM, Tony Parker wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt;&gt;&gt; Let’s get a bug into JIRA, then we’ll figure out what we should do here.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That&#39;s the problem for me. What is the bug? Based on the code example I provided in this thread. I&#39;m somewhat convinced that the bug is that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the behavior of Foundation on Darwin, yet it has the desired behavior.<br>&gt;&gt;  <br>&gt;&gt; What I mean is that I want to track the issue in JIRA so we don’t lose it, and so we can find it later when looking for issues that prevent fully cross-platform behavior. We can look into fixing these in several ways, including adding new API in both frameworks, changing implementations, etc.<br>&gt;  <br>&gt; I have filed a bug https://bugs.swift.org/browse/SR-1610 &lt;https://bugs.swift.org/browse/SR-1610&gt;<br>&gt;  <br>&gt; Obviously please reformat/update accordingly. This was the best I could come up with.<br>&gt;  <br>&gt;&gt;  <br>&gt;&gt; - Tony<br>&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber’s superclass NSValue to check.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; That doesn’t work, unfortunately, at least not with Apple’s Foundation. NSNumbers initialized with booleans have objcType “c” because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Here’s a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;     char ctype = self.objCType[0];<br>&gt;&gt;&gt;&gt;&gt; switch (ctype) {<br>&gt;&gt;&gt;&gt;&gt; case &#39;c&#39;: {<br>&gt;&gt;&gt;&gt;&gt; // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;&gt;&gt;&gt;&gt; // compare it against the singleton kCFBoolean objects:<br>&gt;&gt;&gt;&gt;&gt; if (self == (id)kCFBooleanTrue)<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_bool(gen, true);<br>&gt;&gt;&gt;&gt;&gt; else if (self == (id)kCFBooleanFalse)<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_bool(gen, false);<br>&gt;&gt;&gt;&gt;&gt; else<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_integer(gen, self.longLongValue);<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I haven’t seen how much of this is implemented in corelibs-foundation yet. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn’t seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; —Jens<br>&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/f69780dd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 1:39 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; I have filed a bug https://bugs.swift.org/browse/SR-1610 &lt;https://bugs.swift.org/browse/SR-1610&gt;<br>&gt;  <br>&gt; Obviously please reformat/update accordingly. This was the best I could come up with.<br></p><p>Your issue seems to be with the implicit conversion of NSNumber to a numeric type like Bool. This only happens on Apple platforms, and I think it’s going away in Swift 3. You should be able to work around it by casting to NSNumber, not Bool.<br></p><p>The problems I described with determining the type of the internal number, seem to be covered already as SR-72 &lt;https://bugs.swift.org/browse/SR-72&gt;.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/8b2ef6f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>For completeness I should add that there are other cases where you need to know the exact type:<br></p><p>* When formatting a floating-point number, you should use 6 decimal places if it&#39;s a float, 16 if it&#39;s a double. (If you use all 15 for a float, you end up with results like “0.999999999999999” instead of “0.1”.)<br>* There’s an edge case in converting an NSNumber to an integer. Most of the time you can use longLongValue. But if the number is an unsigned 64-bit int (objcType == “Q”) you have to use unsignedLongLongValue, otherwise it may overflow and appear negative.<br></p><p>—Jens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:18 PM, Jens Alfke via swift-users wrote:<br>&gt; For completeness I should add that there are other cases where you need<br>&gt; to know the exact type:<br>&gt; <br>&gt; * When formatting a floating-point number, you should use 6 decimal<br>&gt; places if it&#39;s a float, 16 if it&#39;s a double. (If you use all 15 for a<br>&gt; float, you end up with results like “0.999999999999999” instead of<br>&gt; “0.1”.)<br>&gt; * There’s an edge case in converting an NSNumber to an integer. Most of<br>&gt; the time you can use longLongValue. But if the number is an unsigned<br>&gt; 64-bit int (objcType == “Q”) you have to use unsignedLongLongValue,<br>&gt; otherwise it may overflow and appear negative.<br></p><p>I don&#39;t know you think these should be in their own bug or as a part of<br>https://bugs.swift.org/browse/SR-1610. I will defer to you.<br></p><p>&gt; <br>&gt; —Jens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 02:03 PM, Tony Parker wrote:<br>&gt; Hi Ryan,<br>&gt; <br>&gt; NSNumber basically exists to hide the underlying number type.<br>&gt; <br>&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>It&#39;s not so much that I need a bool _answer_. Its more that I need to<br>know what _type_ the NSNumber represents.<br></p><p>I started playing around with this as a stand alone quandary. I tried to<br>come up with portable code that ran on _both_ Darwin and Glibc (i.e.,<br>OSX and Linux). And think I&#39;m even more perplexed than I was before.<br></p><p>Ok so the goal. To turn JSON into Swift base types (e.g., Int, Bool,<br>String, etc...). For example, given the JSON below I&#39;d like to end up<br>with two variables `bool` and `number` that are both correctly typed<br>(e.g., `bool: Bool` and `number: Int`).<br></p><p>{<br>  &quot;number&quot;: 1234567890,<br>  &quot;bool&quot;: false<br>}<br></p><p>I came up with the following code.<br></p><p>import Foundation<br></p><p>let jsonStr = &quot;{\&quot;number\&quot;: 1234567890, \&quot;bool\&quot;: false}&quot;<br>let jsonData = jsonStr.data(using: NSUTF8StringEncoding)<br>let obj = jsonData.flatMap({ try? NSJSONSerialization.jsonObject(with:<br>$0) })!<br>let v = obj as! [String : Any]<br>let bool = v[&quot;bool&quot;] as? Bool<br>let number = v[&quot;number&quot;] as? Bool<br></p><p>This is the closest to a &quot;portable&quot; solution as I could get in an hour<br>of trying. And to top it off: it isn&#39;t portable. The biggest portability<br>issue is that on Glibc `obj` is `[String : Any]` where on Darwin it is<br>`[String : AnyObject]`. But the real head scratcher is:<br></p><p>let number = v[&quot;number&quot;] as? Bool<br></p><p>On Glibc `number` is `Bool? = nil` 🎉<br>On Darwin `number` is `Bool? = true` 😤<br></p><p>The rub is that the way Glibc worked in that example is what I was<br>trying to achieve `CFBooleanGetTypeID` and `CFGetTypeID` originally. I<br>was _expecting_ the Darwin behavior since that has always been the<br>behavior. I was _not expecting_ the Glibc behavior as this is different<br>than Darwin. All that having been said: I prefer the Glibc behavior.<br></p><p>I&#39;m not sure if this is expected behavior a bug. Or something else<br>entirely.<br></p><p>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt; On May 23, 2016, at 2:01 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt;&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; But I think you’re using the in-development Swift Foundation? That’s a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br>&gt;&gt;  <br>&gt;&gt; Yes I&#39;m using the in-development Swift Foundation. From what I can tell this version is the one that will be used on non-Darwin platforms.<br>&gt;&gt;  <br>&gt;&gt; Assuming that such an API does not currently exist on NSNumber, I&#39;m reasonably confident that it does not, does this mean that a Swift Evolution thread has to be started to add it?<br>&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; —Jens<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
