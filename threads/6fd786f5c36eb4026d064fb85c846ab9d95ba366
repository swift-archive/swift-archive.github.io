<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 23, 2016 at 03:00:00pm</p></header><div class="content"><p>I am trying to run some Swift code that relies on Foundation on Linux<br>(it is thoughtbot&#39;s Argo library if anyone wants to know the exact<br>code).<br></p><p>There is a fairly simple extension to NSNumber that looks like:<br></p><p>import Foundation<br></p><p>extension NSNumber {<br>  var isBool: Bool {<br>    return CFBooleanGetTypeID() == CFGetTypeID(self)<br>  }<br>}<br></p><p>However it seems that Foundation on Linux has neither<br>`CFBooleanGetTypeID` or `CFGetTypeID`.<br></p><p>Is this expected?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; However it seems that Foundation on Linux has neither<br>&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br></p><p>Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br></p><p>But I think you‚Äôre using the in-development Swift Foundation? That‚Äôs a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br></p><p>‚ÄîJens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160523/bdc21f84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 23, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;<br>&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-<br>&gt;&gt; users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;<br>&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS<br>&gt; Foundation framework is built. The two have a complicated<br>&gt; relationship; Foundation exposes most but not all of the<br>&gt; CoreFoundation APIs as Objective-C, but there are still some features<br>&gt; you have to drop down to C to use. This is one.<br>&gt;<br>&gt; But I think you‚Äôre using the in-development Swift Foundation? That‚Äôs a<br>&gt; different implementation entirely. Presumably it will have some API of<br>&gt; its own to determine the type of a number.<br> <br>Yes I&#39;m using the in-development Swift Foundation. From what I can tell<br>this version is the one that will be used on non-Darwin platforms.<br> <br>Assuming that such an API does not currently exist on NSNumber, I&#39;m<br>reasonably confident that it does not, does this mean that a Swift<br>Evolution thread has to be started to add it?<br> <br>&gt;<br>&gt; ‚ÄîJens<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160523/52185fe7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Ryan,<br></p><p>NSNumber basically exists to hide the underlying number type.<br></p><p>Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>- Tony<br></p><p>&gt; On May 23, 2016, at 2:01 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br>&gt;&gt;  <br>&gt;&gt; But I think you‚Äôre using the in-development Swift Foundation? That‚Äôs a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br>&gt;  <br>&gt; Yes I&#39;m using the in-development Swift Foundation. From what I can tell this version is the one that will be used on non-Darwin platforms.<br>&gt;  <br>&gt; Assuming that such an API does not currently exist on NSNumber, I&#39;m reasonably confident that it does not, does this mean that a Swift Evolution thread has to be started to add it?<br>&gt;  <br>&gt;&gt;  <br>&gt;&gt; ‚ÄîJens<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/bc498412/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 11:03 AM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>I don‚Äôt remember the original code snippet, but there are cases where you need to know what type of number is stored in an NSNumber. An example is encoding to JSON, where a boolean value should be written as ‚Äútrue‚Äù or ‚Äúfalse‚Äù, not ‚Äú1‚Äù or ‚Äú0‚Äù.<br></p><p>‚ÄîJens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/9c61d1df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:49 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 11:03 AM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br>&gt; <br>&gt; I don‚Äôt remember the original code snippet, but there are cases where you need to know what type of number is stored in an NSNumber. An example is encoding to JSON, where a boolean value should be written as ‚Äútrue‚Äù or ‚Äúfalse‚Äù, not ‚Äú1‚Äù or ‚Äú0‚Äù.<br>&gt; <br>&gt; ‚ÄîJens<br></p><p>Fair enough, and we do use this trick in NSJSONSerialization(.m).<br></p><p>One other possibility is using the objCType property on NSNumber‚Äôs superclass NSValue to check. I haven‚Äôt seen how much of this is implemented in corelibs-foundation yet. We did redefine Boolean to _Bool in Swift CF, so we‚Äôll have to see if that accidentally resulted in a runtime difference between platforms here that we didn‚Äôt consider.<br></p><p>- Tony<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/c6ea738f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; One other possibility is using the objCType property on NSNumber‚Äôs superclass NSValue to check.<br></p><p>That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br></p><p>Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br></p><p>    char ctype = self.objCType[0];<br>    switch (ctype) {<br>        case &#39;c&#39;: {<br>            // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>            // compare it against the singleton kCFBoolean objects:<br>            if (self == (id)kCFBooleanTrue)<br>                return yajl_gen_bool(gen, true);<br>            else if (self == (id)kCFBooleanFalse)<br>                return yajl_gen_bool(gen, false);<br>            else<br>                return yajl_gen_integer(gen, self.longLongValue);<br>        }<br></p><p>&gt; I haven‚Äôt seen how much of this is implemented in corelibs-foundation yet. <br></p><p>I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn‚Äôt seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br></p><p>‚ÄîJens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/56ac66e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Let‚Äôs get a bug into JIRA, then we‚Äôll figure out what we should do here.<br></p><p>- Tony<br></p><p>&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One other possibility is using the objCType property on NSNumber‚Äôs superclass NSValue to check.<br>&gt; <br>&gt; That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt; <br>&gt; Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt; <br>&gt;     char ctype = self.objCType[0];<br>&gt;     switch (ctype) {<br>&gt;         case &#39;c&#39;: {<br>&gt;             // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;             // compare it against the singleton kCFBoolean objects:<br>&gt;             if (self == (id)kCFBooleanTrue)<br>&gt;                 return yajl_gen_bool(gen, true);<br>&gt;             else if (self == (id)kCFBooleanFalse)<br>&gt;                 return yajl_gen_bool(gen, false);<br>&gt;             else<br>&gt;                 return yajl_gen_integer(gen, self.longLongValue);<br>&gt;         }<br>&gt; <br>&gt;&gt; I haven‚Äôt seen how much of this is implemented in corelibs-foundation yet. <br>&gt; <br>&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn‚Äôt seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt; <br>&gt; ‚ÄîJens<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/1795b4f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt; Let‚Äôs get a bug into JIRA, then we‚Äôll figure out what we should<br>&gt; do here.<br> <br>That&#39;s the problem for me. What is the bug? Based on the code example I<br>provided in this thread. I&#39;m somewhat convinced that the bug is that<br>Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the<br>behavior of Foundation on Darwin, yet it has the desired behavior.<br> <br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber‚Äôs<br>&gt;&gt;&gt; superclass NSValue to check.<br>&gt;&gt;<br>&gt;&gt; That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs<br>&gt;&gt; Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù<br>&gt;&gt; because `BOOL` is just a typedef for `char`. So the only way to tell<br>&gt;&gt; a boolean apart from an 8-bit int is to compare the object pointer<br>&gt;&gt; against the singleton true and false objects.<br>&gt;&gt;<br>&gt;&gt; Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;<br>&gt;&gt; *char* ctype = *self*.*objCType*[];<br>&gt;&gt;  *switch* (ctype) {<br>&gt;&gt;  *case* &#39;c&#39;: {<br>&gt;&gt;  *// The only way to tell whether an NSNumber with &#39;char&#39; type is a<br>&gt;&gt;  boolean is to*<br>&gt;&gt;  *// compare it against the singleton kCFBoolean objects:*<br>&gt;&gt;  *if* (*self* == (*id*)*kCFBooleanTrue*)<br>&gt;&gt;  *return* yajl_gen_bool(gen, *true*);<br>&gt;&gt;  *else* *if* (*self* == (*id*)*kCFBooleanFalse*)<br>&gt;&gt;  *return* yajl_gen_bool(gen, *false*);<br>&gt;&gt;  *else*<br>&gt;&gt;  *return* yajl_gen_integer(gen, *self*.*longLongValue*);<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;&gt; I haven‚Äôt seen how much of this is implemented in corelibs-<br>&gt;&gt;&gt; foundation yet.<br>&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on<br>&gt;&gt; Github, and the objcType stuff doesn‚Äôt seem to be functional. It<br>&gt;&gt; looks like objcType will only have a value if the object was<br>&gt;&gt; initialized as an NSValue with the type code passed in, not if the<br>&gt;&gt; typical NSNumber initializers were used.<br>&gt;&gt;<br>&gt;&gt; ‚ÄîJens<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/74dea257/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt; Let‚Äôs get a bug into JIRA, then we‚Äôll figure out what we should do here.<br>&gt;  <br>&gt; That&#39;s the problem for me. What is the bug? Based on the code example I provided in this thread. I&#39;m somewhat convinced that the bug is that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the behavior of Foundation on Darwin, yet it has the desired behavior.<br></p><p>What I mean is that I want to track the issue in JIRA so we don‚Äôt lose it, and so we can find it later when looking for issues that prevent fully cross-platform behavior. We can look into fixing these in several ways, including adding new API in both frameworks, changing implementations, etc.<br></p><p>- Tony<br></p><p>&gt;  <br>&gt;&gt;  <br>&gt;&gt; - Tony<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber‚Äôs superclass NSValue to check.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     char ctype = self.objCType[0];<br>&gt;&gt;&gt; switch (ctype) {<br>&gt;&gt;&gt; case &#39;c&#39;: {<br>&gt;&gt;&gt; // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;&gt;&gt; // compare it against the singleton kCFBoolean objects:<br>&gt;&gt;&gt; if (self == (id)kCFBooleanTrue)<br>&gt;&gt;&gt; return yajl_gen_bool(gen, true);<br>&gt;&gt;&gt; else if (self == (id)kCFBooleanFalse)<br>&gt;&gt;&gt; return yajl_gen_bool(gen, false);<br>&gt;&gt;&gt; else<br>&gt;&gt;&gt; return yajl_gen_integer(gen, self.longLongValue);<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I haven‚Äôt seen how much of this is implemented in corelibs-foundation yet. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn‚Äôt seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; ‚ÄîJens<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/815ca135/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:19 PM, Tony Parker wrote:<br>&gt;<br>&gt;&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-<br>&gt;&gt; dev at ryan.lovelett.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt;&gt; Let‚Äôs get a bug into JIRA, then we‚Äôll figure out what we should<br>&gt;&gt;&gt; do here.<br>&gt;&gt;<br>&gt;&gt; That&#39;s the problem for me. What is the bug? Based on the code example<br>&gt;&gt; I provided in this thread. I&#39;m somewhat convinced that the bug is<br>&gt;&gt; that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match<br>&gt;&gt; the behavior of Foundation on Darwin, yet it has the desired<br>&gt;&gt; behavior.<br>&gt;<br>&gt; What I mean is that I want to track the issue in JIRA so we don‚Äôt lose<br>&gt; it, and so we can find it later when looking for issues that prevent<br>&gt; fully cross-platform behavior. We can look into fixing these in<br>&gt; several ways, including adding new API in both frameworks, changing<br>&gt; implementations, etc.<br> <br>I have filed a bug¬†https://bugs.swift.org/browse/SR-1610<br> <br>Obviously please reformat/update accordingly. This was the best I could<br>come up with.<br> <br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker<br>&gt;&gt;&gt;&gt;&gt; &lt;anthony.parker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber‚Äôs<br>&gt;&gt;&gt;&gt;&gt; superclass NSValue to check.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs<br>&gt;&gt;&gt;&gt; Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù<br>&gt;&gt;&gt;&gt; because `BOOL` is just a typedef for `char`. So the only way to<br>&gt;&gt;&gt;&gt; tell a boolean apart from an 8-bit int is to compare the object<br>&gt;&gt;&gt;&gt; pointer against the singleton true and false objects.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *char* ctype = *self*.*objCType*[];<br>&gt;&gt;&gt;&gt; *switch* (ctype) {<br>&gt;&gt;&gt;&gt; *case* &#39;c&#39;: {<br>&gt;&gt;&gt;&gt; *// The only way to tell whether an NSNumber with &#39;char&#39; type is a<br>&gt;&gt;&gt;&gt; boolean is to*<br>&gt;&gt;&gt;&gt; *// compare it against the singleton kCFBoolean objects:*<br>&gt;&gt;&gt;&gt; *if* (*self* == (*id*)*kCFBooleanTrue*)<br>&gt;&gt;&gt;&gt; *return* yajl_gen_bool(gen, *true*);<br>&gt;&gt;&gt;&gt; *else* *if* (*self* == (*id*)*kCFBooleanFalse*)<br>&gt;&gt;&gt;&gt; *return* yajl_gen_bool(gen, *false*);<br>&gt;&gt;&gt;&gt; *else*<br>&gt;&gt;&gt;&gt; *return* yajl_gen_integer(gen, *self*.*longLongValue*);<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I haven‚Äôt seen how much of this is implemented in corelibs-<br>&gt;&gt;&gt;&gt;&gt; foundation yet.<br>&gt;&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on<br>&gt;&gt;&gt;&gt; Github, and the objcType stuff doesn‚Äôt seem to be functional. It<br>&gt;&gt;&gt;&gt; looks like objcType will only have a value if the object was<br>&gt;&gt;&gt;&gt; initialized as an NSValue with the type code passed in, not if the<br>&gt;&gt;&gt;&gt; typical NSNumber initializers were used.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ‚ÄîJens<br>&gt;&gt;<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/bb709799/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>That‚Äôs perfect, thanks Ryan.<br></p><p>- Tony<br></p><p>&gt; On May 24, 2016, at 1:39 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; On Tue, May 24, 2016, at 04:19 PM, Tony Parker wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On May 24, 2016, at 1:11 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Tue, May 24, 2016, at 04:07 PM, Tony Parker wrote:<br>&gt;&gt;&gt;&gt; Let‚Äôs get a bug into JIRA, then we‚Äôll figure out what we should do here.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That&#39;s the problem for me. What is the bug? Based on the code example I provided in this thread. I&#39;m somewhat convinced that the bug is that Foundation on Linux/Glibc is &quot;broken&quot;. In that it does not match the behavior of Foundation on Darwin, yet it has the desired behavior.<br>&gt;&gt;  <br>&gt;&gt; What I mean is that I want to track the issue in JIRA so we don‚Äôt lose it, and so we can find it later when looking for issues that prevent fully cross-platform behavior. We can look into fixing these in several ways, including adding new API in both frameworks, changing implementations, etc.<br>&gt;  <br>&gt; I have filed a bug https://bugs.swift.org/browse/SR-1610 &lt;https://bugs.swift.org/browse/SR-1610&gt;<br>&gt;  <br>&gt; Obviously please reformat/update accordingly. This was the best I could come up with.<br>&gt;  <br>&gt;&gt;  <br>&gt;&gt; - Tony<br>&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; - Tony<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 1:03 PM, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 12:52 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; One other possibility is using the objCType property on NSNumber‚Äôs superclass NSValue to check.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; That doesn‚Äôt work, unfortunately, at least not with Apple‚Äôs Foundation. NSNumbers initialized with booleans have objcType ‚Äúc‚Äù because `BOOL` is just a typedef for `char`. So the only way to tell a boolean apart from an 8-bit int is to compare the object pointer against the singleton true and false objects.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Here‚Äôs a snippet of Obj-C code I use for this in my JSON encoder:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;     char ctype = self.objCType[0];<br>&gt;&gt;&gt;&gt;&gt; switch (ctype) {<br>&gt;&gt;&gt;&gt;&gt; case &#39;c&#39;: {<br>&gt;&gt;&gt;&gt;&gt; // The only way to tell whether an NSNumber with &#39;char&#39; type is a boolean is to<br>&gt;&gt;&gt;&gt;&gt; // compare it against the singleton kCFBoolean objects:<br>&gt;&gt;&gt;&gt;&gt; if (self == (id)kCFBooleanTrue)<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_bool(gen, true);<br>&gt;&gt;&gt;&gt;&gt; else if (self == (id)kCFBooleanFalse)<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_bool(gen, false);<br>&gt;&gt;&gt;&gt;&gt; else<br>&gt;&gt;&gt;&gt;&gt; return yajl_gen_integer(gen, self.longLongValue);<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I haven‚Äôt seen how much of this is implemented in corelibs-foundation yet. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I took a peek at the Swift NSNumber and NSValue implementations on Github, and the objcType stuff doesn‚Äôt seem to be functional. It looks like objcType will only have a value if the object was initialized as an NSValue with the type code passed in, not if the typical NSNumber initializers were used.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; ‚ÄîJens<br>&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/f69780dd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 1:39 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; I have filed a bug https://bugs.swift.org/browse/SR-1610 &lt;https://bugs.swift.org/browse/SR-1610&gt;<br>&gt;  <br>&gt; Obviously please reformat/update accordingly. This was the best I could come up with.<br></p><p>Your issue seems to be with the implicit conversion of NSNumber to a numeric type like Bool. This only happens on Apple platforms, and I think it‚Äôs going away in Swift 3. You should be able to work around it by casting to NSNumber, not Bool.<br></p><p>The problems I described with determining the type of the internal number, seem to be covered already as SR-72 &lt;https://bugs.swift.org/browse/SR-72&gt;.<br></p><p>‚ÄîJens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160524/8b2ef6f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>For completeness I should add that there are other cases where you need to know the exact type:<br></p><p>* When formatting a floating-point number, you should use 6 decimal places if it&#39;s a float, 16 if it&#39;s a double. (If you use all 15 for a float, you end up with results like ‚Äú0.999999999999999‚Äù instead of ‚Äú0.1‚Äù.)<br>* There‚Äôs an edge case in converting an NSNumber to an integer. Most of the time you can use longLongValue. But if the number is an unsigned 64-bit int (objcType == ‚ÄúQ‚Äù) you have to use unsignedLongLongValue, otherwise it may overflow and appear negative.<br></p><p>‚ÄîJens<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 04:18 PM, Jens Alfke via swift-users wrote:<br>&gt; For completeness I should add that there are other cases where you need<br>&gt; to know the exact type:<br>&gt; <br>&gt; * When formatting a floating-point number, you should use 6 decimal<br>&gt; places if it&#39;s a float, 16 if it&#39;s a double. (If you use all 15 for a<br>&gt; float, you end up with results like ‚Äú0.999999999999999‚Äù instead of<br>&gt; ‚Äú0.1‚Äù.)<br>&gt; * There‚Äôs an edge case in converting an NSNumber to an integer. Most of<br>&gt; the time you can use longLongValue. But if the number is an unsigned<br>&gt; 64-bit int (objcType == ‚ÄúQ‚Äù) you have to use unsignedLongLongValue,<br>&gt; otherwise it may overflow and appear negative.<br></p><p>I don&#39;t know you think these should be in their own bug or as a part of<br>https://bugs.swift.org/browse/SR-1610. I will defer to you.<br></p><p>&gt; <br>&gt; ‚ÄîJens<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Foundation on Linux `CFBooleanGetTypeID`/`CFGetTypeID`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016, at 02:03 PM, Tony Parker wrote:<br>&gt; Hi Ryan,<br>&gt; <br>&gt; NSNumber basically exists to hide the underlying number type.<br>&gt; <br>&gt; Why not use `func boolValue` instead, if you need a true/false answer?<br></p><p>It&#39;s not so much that I need a bool _answer_. Its more that I need to<br>know what _type_ the NSNumber represents.<br></p><p>I started playing around with this as a stand alone quandary. I tried to<br>come up with portable code that ran on _both_ Darwin and Glibc (i.e.,<br>OSX and Linux). And think I&#39;m even more perplexed than I was before.<br></p><p>Ok so the goal. To turn JSON into Swift base types (e.g., Int, Bool,<br>String, etc...). For example, given the JSON below I&#39;d like to end up<br>with two variables `bool` and `number` that are both correctly typed<br>(e.g., `bool: Bool` and `number: Int`).<br></p><p>{<br>¬† &quot;number&quot;: 1234567890,<br>¬† &quot;bool&quot;: false<br>}<br></p><p>I came up with the following code.<br></p><p>import Foundation<br></p><p>let jsonStr = &quot;{\&quot;number\&quot;: 1234567890, \&quot;bool\&quot;: false}&quot;<br>let jsonData = jsonStr.data(using: NSUTF8StringEncoding)<br>let obj = jsonData.flatMap({ try? NSJSONSerialization.jsonObject(with:<br>$0) })!<br>let v = obj as! [String : Any]<br>let bool = v[&quot;bool&quot;] as? Bool<br>let number = v[&quot;number&quot;] as? Bool<br></p><p>This is the closest to a &quot;portable&quot; solution as I could get in an hour<br>of trying. And to top it off: it isn&#39;t portable. The biggest portability<br>issue is that on Glibc `obj` is `[String : Any]` where on Darwin it is<br>`[String : AnyObject]`. But the real head scratcher is:<br></p><p>let number = v[&quot;number&quot;] as? Bool<br></p><p>On Glibc `number` is `Bool? = nil` üéâ<br>On Darwin `number` is `Bool? = true` üò§<br></p><p>The rub is that the way Glibc worked in that example is what I was<br>trying to achieve `CFBooleanGetTypeID` and `CFGetTypeID` originally. I<br>was _expecting_ the Darwin behavior since that has always been the<br>behavior. I was _not expecting_ the Glibc behavior as this is different<br>than Darwin. All that having been said: I prefer the Glibc behavior.<br></p><p>I&#39;m not sure if this is expected behavior a bug. Or something else<br>entirely.<br></p><p>&gt; <br>&gt; - Tony<br>&gt; <br>&gt;&gt; On May 23, 2016, at 2:01 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, May 23, 2016, at 04:33 PM, Jens Alfke wrote:<br>&gt;&gt;&gt; ¬†<br>&gt;&gt;&gt;&gt; On May 23, 2016, at 12:25 PM, Ryan Lovelett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; ¬†<br>&gt;&gt;&gt;&gt; However it seems that Foundation on Linux has neither<br>&gt;&gt;&gt;&gt; `CFBooleanGetTypeID` or `CFGetTypeID`.<br>&gt;&gt;&gt; ¬†<br>&gt;&gt;&gt; Those are part of CoreFoundation, the C library on which the Mac/iOS Foundation framework is built. The two have a complicated relationship; Foundation exposes most but not all of the CoreFoundation APIs as Objective-C, but there are still some features you have to drop down to C to use. This is one.<br>&gt;&gt;&gt; ¬†<br>&gt;&gt;&gt; But I think you‚Äôre using the in-development Swift Foundation? That‚Äôs a different implementation entirely. Presumably it will have some API of its own to determine the type of a number.<br>&gt;&gt; ¬†<br>&gt;&gt; Yes I&#39;m using the in-development Swift Foundation. From what I can tell this version is the one that will be used on non-Darwin platforms.<br>&gt;&gt; ¬†<br>&gt;&gt; Assuming that such an API does not currently exist on NSNumber, I&#39;m reasonably confident that it does not, does this mean that a Swift Evolution thread has to be started to add it?<br>&gt;&gt; ¬†<br>&gt;&gt;&gt; ¬†<br>&gt;&gt;&gt; ‚ÄîJens<br>&gt;&gt; ¬†<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
