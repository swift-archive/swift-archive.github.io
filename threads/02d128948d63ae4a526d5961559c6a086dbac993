<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be	non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p><br></p><p><br>Sent from my iPad<br></p><p>On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br></p><p><br></p><p>Making classes harder to work with is not a specific goal, no. :)<br></p><p><br>I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br></p><p><br>I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br></p><p><br>Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br></p><p><br></p><p><br>Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br></p><p><br>What about<br></p><p><br></p><p>   public internal(open) class Foo { ... }<br></p><p><br></p><p>similar to<br></p><p><br></p><p>   public private(set) var foo: Foo<br></p><p><br></p><p>This would also allow e.g.<br></p><p><br></p><p>   public fileprivate(open) class Foo { ... }<br></p><p><br></p><p>-Thorsten<br></p><p><br></p><p> <br></p><p><br>It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br></p><p><br>1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br></p><p><br>2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br></p><p><br>In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br></p><p><br>-Matthew<br></p><p><br>John.<br></p><p><br></p><p><br>Seriously though<br></p><p><br>Mine is the opinion of a library-maker,<br>yours of the user of poorly designed/developed libraries.<br></p><p><br>this kind of attitude on this list got to stop.<br></p><p>Sent from my iPhone<br></p><p>On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>Jean, IMO marking every class as subclassable means the creator does<br>not care for you to design and develop a great library because s/he is<br>not caring for the library at all. I right now have to go through the<br>burdensome activity of marking too many classes/methods as final to<br>prevent misuse of my libraries and find good design workarounds when I<br>need to subclass internally what I don&#39;t want you to subclass.<br></p><p>IMO the usage of a library is to be crafted/planned/designed by their<br>developers not their users. Mine is the opinion of a library-maker,<br>yours of the user of poorly designed/developed libraries. By pushing<br>this proposal, developer of such libraries will have much burden to<br>make/keep a poor library or will have to work on better<br>design/implementation for it to suit its purpose.<br></p><p>L<br></p><p>On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br></p><p>* What is your evaluation of the proposal?<br></p><p><br></p><p>Strong -1 too.<br></p><p><br></p><p>I can’t count the number of times it save my hours tone able to override<br></p><p>arbitrary classes and methods.<br></p><p><br></p><p>Sometimes to simply add log point to understand how the API work. Other<br></p><p>times to workaround bugs in the library. Or even to extends the library in a<br></p><p>way that the author did not intent in the first place, but that was<br></p><p>perfectly supported anyway.<br></p><p><br></p><p>I already see how libraries author will react to that new default. They will<br></p><p>either don’t care and mark all classes as subclassable, or find to<br></p><p>burdensome to get subclassability right and prohibit subclassing all<br></p><p>classes.<br></p><p><br></p><p><br></p><p>Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br></p><p>&lt;swift-evolution at swift.org&gt; a écrit :<br></p><p><br></p><p>* What is your evaluation of the proposal?<br></p><p><br></p><p>A **strong** -1<br></p><p><br></p><p>First, I have often found that you can’t always predict the way which<br></p><p>something will need to be extended.  You think you know, but are then<br></p><p>surprised by creative uses.  My favorite features of Swift/Cocoa involve<br></p><p>retroactive modeling.<br></p><p><br></p><p>Second, I don’t think this proposal will achieve its stated objective of<br></p><p>forcing people to think about subclassing more.  It will just add confusing<br></p><p>boilerplate.<br></p><p><br></p><p>Things like Swift optionals work well because they make the (often<br></p><p>forgotten) choices explicit in the context that they are used.  In the world<br></p><p>of Human Factors, we call it a forcing function.  This proposal has the<br></p><p>inverse structure, and will be ineffective, because the “forcing” part of it<br></p><p>shows up in a different context (i.e. trying to use a framework) than the<br></p><p>decision is being made in (writing the framework).  This type of thinking<br></p><p>leads to things like Java and the DMV.<br></p><p><br></p><p>As Tino said:<br></p><p><br></p><p>No matter what the defaults are, good libraries are hard to build, so I<br></p><p>predict this proposal would not only fail in increasing framework quality,<br></p><p>but also will make it much harder for users of those frameworks to work<br></p><p>around their flaws, which are just a natural part of every software.<br></p><p><br></p><p>I think he is right on here.  Those who were prone to be thoughtful about<br></p><p>their design would have been anyway.  Those who are not thoughtful about<br></p><p>their design will just leave these annotations off… leaving us with no<br></p><p>recourse to extend/modify classes.  When people complain, they will add the<br></p><p>annotations without actually thinking about the meaning (i.e. stack overflow<br></p><p>/ the fixit tells me I need to add this word to make the compiler happy).<br></p><p>All this does is put framework users at the mercy of the framework writers.<br></p><p><br></p><p><br></p><p>Finally, this proposal is missing important aspects of the problem space.<br></p><p>If we truly want to solve the issue of subclassing, we need to consider all<br></p><p>of the common issues which arise.  Looking at the cocoa documentation you<br></p><p>will see several types of annotations:<br></p><p>1) This method MUST be overridden<br></p><p>2) This method should NOT be overridden<br></p><p>3) This method MUST be called<br></p><p>3) This method should NOT be called except by subclasses<br></p><p>4) This method should NOT be called except by a method override calling<br></p><p>super<br></p><p>5) This method MUST call super<br></p><p>6) Overrides of this method should NOT call super<br></p><p><br></p><p>If we are attempting to bring thoughtfulness to the design of classes, I<br></p><p>would like to see things be extendable by default, but with annotations that<br></p><p>thoughtful framework designers can use to designate how a particular method<br></p><p>should be used.  In most cases, it should not explicitly forbid the end user<br></p><p>from subclassing, but require them to acknowledge that what they are doing<br></p><p>is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br></p><p>would feel 1000x more swifty to me.  Opt-out safety.<br></p><p><br></p><p>* Is the problem being addressed significant enough to warrant a change to<br></p><p>Swift?<br></p><p><br></p><p>No. It doesn’t actually solve the problem... and I haven’t actually run into<br></p><p>this problem in the real world.<br></p><p><br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br></p><p><br></p><p>No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br></p><p>while failing to achieve its objective.  It goes against the retroactive<br></p><p>modeling allowed by other areas of Swift.<br></p><p><br></p><p>* If you have used other languages or libraries with a similar feature, how<br></p><p>do you feel that this proposal compares to those?<br></p><p><br></p><p>I tend to avoid languages which require this sort of thing.  In other<br></p><p>languages that lock things down, there is a need to unlock things soon after<br></p><p>(e.g. friend classes).<br></p><p><br></p><p>I predict the same thing will happen here.  People will quickly be asking<br></p><p>for the ability to patch/override in cases where the framework designer was<br></p><p>wrong.  That shows a problem inherent with the design...<br></p><p><br></p><p>* How much effort did you put into your review? A glance, a quick reading,<br></p><p>or an in-depth study?<br></p><p><br></p><p>Read the proposal &amp; discussion.  Read earlier discussions around access<br></p><p>control that touched on this subject as well.  I have been designing<br></p><p>frameworks for years.<br></p><p><br></p><p>Thanks,<br></p><p>Jon<br></p><p><br></p><p>Hello Swift community,<br></p><p><br></p><p>The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br></p><p>begins now and runs through July 11. The proposal is available here:<br></p><p><br></p><p>   https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p><br></p><p>Reviews are an important part of the Swift evolution process. All reviews<br></p><p>should be sent to the swift-evolution mailing list at<br></p><p><br></p><p>   https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>or, if you would like to keep your feedback private, directly to the review<br></p><p>manager.<br></p><p><br></p><p>What goes into a review?<br></p><p><br></p><p>The goal of the review process is to improve the proposal under review<br></p><p>through constructive criticism and contribute to the direction of Swift.<br></p><p>When writing your review, here are some questions you might want to answer<br></p><p>in your review:<br></p><p><br></p><p>   * What is your evaluation of the proposal?<br></p><p>   * Is the problem being addressed significant enough to warrant a change to<br></p><p>Swift?<br></p><p>   * Does this proposal fit well with the feel and direction of Swift?<br></p><p>   * If you have used other languages or libraries with a similar feature, how<br></p><p>do you feel that this proposal compares to those?<br></p><p>   * How much effort did you put into your review? A glance, a quick reading,<br></p><p>or an in-depth study?<br></p><p><br></p><p>More information about the Swift evolution process is available at<br></p><p><br></p><p>   https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p><br></p><p>Thank you,<br></p><p><br></p><p>-Chris Lattner<br></p><p>Review Manager<br></p><p><br></p><p><br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/02d1c993/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt; <br>&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt; <br>&gt; <br>&gt; What about<br>&gt; <br>&gt;    public internal(open) class Foo { ... }<br>&gt; <br>&gt; similar to<br>&gt; <br>&gt;    public private(set) var foo: Foo<br>&gt; <br>&gt; This would also allow e.g.<br>&gt; <br>&gt;    public fileprivate(open) class Foo { ... }<br></p><p>This is an interesting idea.<br></p><p>However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br></p><p>If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br></p><p>It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt;  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt; <br>&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt; <br>&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt; <br>&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/7b48762e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What about<br>&gt;&gt; <br>&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt; <br>&gt;&gt; similar to<br>&gt;&gt; <br>&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt; <br>&gt;&gt; This would also allow e.g.<br>&gt;&gt; <br>&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt; <br>&gt; This is an interesting idea.<br>&gt; <br>&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br></p><p>True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br> <br>-Thorsten <br></p><p>&gt; <br>&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt; <br>&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/e632907a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; similar to<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt; <br>&gt;&gt; This is an interesting idea.<br>&gt;&gt; <br>&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt; <br>&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br></p><p>Actually the main point of the proposal is to change the default.  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br></p><p>It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br></p><p>&gt;  <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; <br>&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt; <br>&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/6cb6ce3c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 8, 2016, at 8:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt; <br>&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt; <br>&gt; Actually the main point of the proposal is to change the default.  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br>&gt; <br>&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br></p><p>I would say that the opponents so far have been split about whether they would like this as an opt-in feature.<br></p><p>&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br></p><p>I&#39;ve thought about this, but overall I think the current behavior is right here.  It&#39;s reasonable for API authors to understand that making a property public means making it publicly settable.<br></p><p>John.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/160485b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  8, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 8, 2016, at 12:32 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 8, 2016, at 8:24 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt;&gt; <br>&gt;&gt; Actually the main point of the proposal is to change the default.  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br>&gt;&gt; <br>&gt;&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br>&gt; <br>&gt; I would say that the opponents so far have been split about whether they would like this as an opt-in feature.<br></p><p>Maybe.  I admit this was just my impression and not a careful analysis.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt; <br>&gt; I&#39;ve thought about this, but overall I think the current behavior is right here.  It&#39;s reasonable for API authors to understand that making a property public means making it publicly settable.<br></p><p>That&#39;s reasonable.  <br></p><p>My primary point is that if go in this direction I would prefer consistent behavior of &#39;open&#39; and &#39;set&#39;.  I really want sealed to be the default so I would argue against this syntax is we aren&#39;t willing to change how &#39;set&#39; works.  <br></p><p>The idea of changing &#39;set&#39; is a secondary point demonstrating how to make the syntax suggestion work in a consistent manner.  I wouldn&#39;t be opposed to it and a supporting argument is possible, but I don&#39;t think this a critical change.<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/318f3d9d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 08.07.2016 um 17:24 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt; <br>&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt; <br>&gt; Actually the main point of the proposal is to change the default.<br></p><p>I don’t understand? Just changing the default would mean introducing something like final by default (which was another proposal).<br></p><p><br>&gt;  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br></p><p>Hmm, not sure about that.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/aa051e3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 10, 2016, at 12:26 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 08.07.2016 um 17:24 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt;&gt; <br>&gt;&gt; Actually the main point of the proposal is to change the default.<br>&gt; <br>&gt; I don’t understand? Just changing the default would mean introducing something like final by default (which was another proposal).<br></p><p>No, the point is to make sealed the default (not final).  Final by default never reached proposal status, it was only a discussion.  I think I would be happier with final as the default but sealed is a reasonable balance and is well aligned with the rest of the defaults in Swift.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br>&gt; <br>&gt; Hmm, not sure about that.<br></p><p>Any ecosystem advantages derived from requiring explicit opt-in to external subclasses  (and presumably at least some thoughtfulness behind the choice) would be nullified if sealed as an opt-in and the default remains the same.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/02659bfd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 10.07.2016 um 19:34 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jul 10, 2016, at 12:26 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 08.07.2016 um 17:24 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually the main point of the proposal is to change the default.<br>&gt;&gt; <br>&gt;&gt; I don’t understand? Just changing the default would mean introducing something like final by default (which was another proposal).<br>&gt; <br>&gt; No, the point is to make sealed the default (not final).  Final by default never reached proposal status, it was only a discussion.  I think I would be happier with final as the default but sealed is a reasonable balance and is well aligned with the rest of the defaults in Swift.<br></p><p>&quot;sealed“ is a new concept in Swift, isn’t it (I only know &quot;final“)? So this is not about changing a default but about introducing the separation of visibility and subclassability.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br>&gt;&gt; <br>&gt;&gt; Hmm, not sure about that.<br>&gt; <br>&gt; Any ecosystem advantages derived from requiring explicit opt-in to external subclasses  (and presumably at least some thoughtfulness behind the choice) would be nullified if sealed as an opt-in and the default remains the same.<br></p><p>I think the advantages arise from being able to make a class public without allowing subclassing it. The default does not IMO factor into the quality of a library. It might just as well be the wrong default for using a library just because the library author did forget to opt-in.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/78dac994/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 10, 2016, at 7:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jul 10, 2016, at 12:26 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 08.07.2016 um 17:24 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 8, 2016, at 10:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 08.07.2016 um 15:59 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 8, 2016, at 8:48 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 08. Juli 2016 um 15:11 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 7, 2016, at 5:15 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; n Jul 7, 2016, at 9:39 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree that a stable for over 30 years of every OOP language that I know is equivalent to lack of care for good library design, but if we want to push value types by making working with classes harder so be it :P. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Making classes harder to work with is not a specific goal, no. :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t expect that this will be a significant burden for most Swift programmers.  Mainly, that&#39;s because this only affects classes that are exposed outside of a module, and the great majority of non-system classes in a typical Cocoa program are single-purpose leaf classes that — at most — expose a few methods to other subsystems.  Swift doesn&#39;t really encourage you write complex classes that are primarily customized with subclassing; it encourages the heavy use of value types, and it encourages customization through protocols and functions.  In fact, that&#39;s not really new to Swift, it&#39;s a general lesson from the last few decades of software development: composing smaller, independent systems through well-defined interfaces leads to better software than building monolithic systems whose behavior can only be defined in reference to the whole.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I sympathize with the argument about wanting to fix bugs and add features via override, but that&#39;s never been maintainable in the long term; you always just end up with superclasses that everyone is terrified to touch because every subclass has its own invasive &quot;fixes&quot;, and that&#39;s even when working within a single codebase.  With libraries, you can pretty quickly get locked in to a specific version because your customizations don&#39;t work with new releases; either that, or the maintainer just decides that they can&#39;t fix of their mistakes and so goes off to rewrite it from scratch.  Either way, it&#39;s not good for the ecosystem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plus, as others have mentioned, Swift already provides a lot of features that don&#39;t allow overriding: structs, final, etc.  You simply cannot rely on overriding to fix upstream bugs the way that you can in most traditional OO languages because not enough code flows through calls to overridable methods.  We should not compromise the goal of promoting stronger and more maintainable library designs just to maintain this illusion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for continuing to make the case for this John.  I really, really hope the core team will accept the proposal (with revisions - the problems with the keyword names are real).  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What about<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public internal(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; similar to<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public private(set) var foo: Foo<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would also allow e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    public fileprivate(open) class Foo { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an interesting idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However it appears to have a problem in that it does not make internal(open) the default for a public class or method if it behaves consistently with private(set) (where the setter defaults to the same visibility as the getter unless it is restricts further).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True, but the main feature of the proposal is being able to separate control over visibility from control over the ability to subclass. This would still be possible, just the default would be different.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually the main point of the proposal is to change the default.<br>&gt;&gt; <br>&gt;&gt; I don’t understand? Just changing the default would mean introducing something like final by default (which was another proposal).<br>&gt; <br>&gt; No, the point is to make sealed the default (not final).  Final by default never reached proposal status, it was only a discussion.  I think I would be happier with final as the default but sealed is a reasonable balance and is well aligned with the rest of the defaults in Swift.<br></p><p>I was wondering if &quot;reasonable&quot; is a word I would use when having to make a choice between bad and worse. It is a concept I try to teach my 9 y/o: that between a number of unreasonable choices, the seamingly least unreasonable may still not be a reasonable one, even if selected. She is much too young to whatch Sophie&#39;s choice, which makes a too extreme depiction of this notion.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  It would still be useful without a new default but would have a significantly smaller impact.  The ecosystem advantages of the change in default would not be realized.<br>&gt;&gt; <br>&gt;&gt; Hmm, not sure about that.<br>&gt; <br>&gt; Any ecosystem advantages derived from requiring explicit opt-in to external subclasses  (and presumably at least some thoughtfulness behind the choice) would be nullified if sealed as an opt-in and the default remains the same.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me like most supporters of the proposal favor changing the default and most opponents wouldn&#39;t view the additional control worth the complexity it would introduce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we wanted to adopt this approach it would be good to also make setters internal even when the property is marked public unless it is explicitly marked public(set).  This would behave consistently with the default of sealed public classes and methods which would only become open if they are explicit marked public(open).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would also tighten up another area of public API which arguably isn&#39;t explicitly opted-in to today.  Setters are automatically public for any public property.  API authors aren&#39;t required to explicitly state that consumer should be able to mutate the property and are currently required to opt-out if they do not want to allow that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It will clearly ruffle a lot of feathers but is worth doing in this case IMO.  Especially since many commenters who are opposed do not seem to grasp a couple of crucial points:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. As you point out, the majority of the surface area of idiomatic Swift APIs are unlikely to be impacted (value types, protocols, and final classes).  This is very likely to apply to future Swift-native APIs from Apple regardless of the outcome of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. There is no impact on users of Apple&#39;s Objective-C APIs (AFAICT).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the context of these facts, this proposal is not nearly as dramatic a change as many seem to be suggesting.  It just tightens up an inconsistency in the language (the one area where public API contracts are not explicitly opted-in to).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Seriously though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this kind of attitude on this list got to stop.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 Jul 2016, at 17:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jean, IMO marking every class as subclassable means the creator does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not care for you to design and develop a great library because s/he is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not caring for the library at all. I right now have to go through the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome activity of marking too many classes/methods as final to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prevent misuse of my libraries and find good design workarounds when I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to subclass internally what I don&#39;t want you to subclass.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the usage of a library is to be crafted/planned/designed by their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developers not their users. Mine is the opinion of a library-maker,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; yours of the user of poorly designed/developed libraries. By pushing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this proposal, developer of such libraries will have much burden to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make/keep a poor library or will have to work on better<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design/implementation for it to suit its purpose.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; L<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 7 July 2016 at 13:08, Jean-Daniel Dupas via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Strong -1 too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can’t count the number of times it save my hours tone able to override<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; arbitrary classes and methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sometimes to simply add log point to understand how the API work. Other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; times to workaround bugs in the library. Or even to extends the library in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; way that the author did not intent in the first place, but that was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; perfectly supported anyway.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I already see how libraries author will react to that new default. They will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either don’t care and mark all classes as subclassable, or find to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; burdensome to get subclassability right and prohibit subclassing all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; classes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 7 juil. 2016 à 02:27, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A **strong** -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; First, I have often found that you can’t always predict the way which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something will need to be extended.  You think you know, but are then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised by creative uses.  My favorite features of Swift/Cocoa involve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; retroactive modeling.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Second, I don’t think this proposal will achieve its stated objective of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forcing people to think about subclassing more.  It will just add confusing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; boilerplate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Things like Swift optionals work well because they make the (often<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; forgotten) choices explicit in the context that they are used.  In the world<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of Human Factors, we call it a forcing function.  This proposal has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; inverse structure, and will be ineffective, because the “forcing” part of it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; shows up in a different context (i.e. trying to use a framework) than the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; decision is being made in (writing the framework).  This type of thinking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leads to things like Java and the DMV.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Tino said:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No matter what the defaults are, good libraries are hard to build, so I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; predict this proposal would not only fail in increasing framework quality,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but also will make it much harder for users of those frameworks to work<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around their flaws, which are just a natural part of every software.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think he is right on here.  Those who were prone to be thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design would have been anyway.  Those who are not thoughtful about<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their design will just leave these annotations off… leaving us with no<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; recourse to extend/modify classes.  When people complain, they will add the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; annotations without actually thinking about the meaning (i.e. stack overflow<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; / the fixit tells me I need to add this word to make the compiler happy).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; All this does is put framework users at the mercy of the framework writers.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, this proposal is missing important aspects of the problem space.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we truly want to solve the issue of subclassing, we need to consider all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the common issues which arise.  Looking at the cocoa documentation you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will see several types of annotations:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) This method MUST be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) This method should NOT be overridden<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method MUST be called<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) This method should NOT be called except by subclasses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4) This method should NOT be called except by a method override calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 5) This method MUST call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 6) Overrides of this method should NOT call super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we are attempting to bring thoughtfulness to the design of classes, I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would like to see things be extendable by default, but with annotations that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thoughtful framework designers can use to designate how a particular method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be used.  In most cases, it should not explicitly forbid the end user<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from subclassing, but require them to acknowledge that what they are doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not intended by the framework. (e.g. &quot;unsafe override func&quot;…).  That<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would feel 1000x more swifty to me.  Opt-out safety.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No. It doesn’t actually solve the problem... and I haven’t actually run into<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this problem in the real world.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, it gives Swift more of a feeling of busywork and unnecessary boilerplate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; while failing to achieve its objective.  It goes against the retroactive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; modeling allowed by other areas of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I tend to avoid languages which require this sort of thing.  In other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; languages that lock things down, there is a need to unlock things soon after<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g. friend classes).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I predict the same thing will happen here.  People will quickly be asking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for the ability to patch/override in cases where the framework designer was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong.  That shows a problem inherent with the design...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal &amp; discussion.  Read earlier discussions around access<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; control that touched on this subject as well.  I have been designing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks for years.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; begins now and runs through July 11. The proposal is available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * If you have used other languages or libraries with a similar feature, how<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/f345e17b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
