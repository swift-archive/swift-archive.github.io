<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case for the ability to refer to an enum case generically without reference to any of its associated values.<br></p><p>Let me give you an example:<br></p><p>In our app, we have an enum that represents all the different screens to which the user can navigate. (A screen in our case usually means a view controller or hierarchy thereof.)<br></p><p>Because each screen might require specific view model object(s) to render their content, some of our enum cases have associated values to store the required view model objects.<br></p><p>This allows an enum value to contain all the information needed to present any screen to the user, fully populated with content.<br></p><p>However, in a few instances I&#39;ve found it would be helpful to be able to refer to a screen in the abstract and be able to &#39;switch&#39; against it without any associated values. (This would allow me to be able to refer to, say, &quot;the User Account screen&quot; in the abstract, whereas now I can only refer to &quot;the User Account screen displaying details for this particular user&quot;.)<br></p><p>We&#39;ve identified two possible solutions to this issue and have implemented one of them, but it is still sub-optimal:<br></p><p>• One option involves maintaining a parallel enum with the same case names but without any associated values. These parallel structures need to be manually maintained, which is something the compiler cannot enforce.<br></p><p>• Another option involves removing the associated values from the enum and passing around objects to contain the necessary view model objects. At various points, we assert that the view model container object is of the expected type for the enum case, but again, that now moves to runtime an error that otherwise would&#39;ve been caught by the compiler.<br></p><p>---<br></p><p>When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br></p><p>I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br></p><p>enum Foo<br>{<br>    case Bar(String)<br>    case Baz(Int, Int)<br></p><p>    // generated by the compiler; returns the parallel FooType<br>    // with cases that don&#39;t have associated values<br>    var enumType: FooType<br>}<br></p><p>// generated by the compiler when an enum<br>// has at least one associated value<br>enum FooType<br>{<br>    case Bar<br>    case Baz<br>}<br></p><p>This would make it possible to be able to refer to cases in the abstract.<br></p><p>Perhaps there&#39;s a totally different solution to this class of problem, but that&#39;s what I came up with. Would love to hear your thoughts.<br></p><p>E.<br></p><p><br></p><p>&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt; <br>&gt; @synthesize_case_enum<br>&gt; enum Example {<br>&gt; <br>&gt;  case Foo(X)<br>&gt;  case Bar<br>&gt;  case Baz(Y)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which would then by default expand to something like this:<br>&gt; <br>&gt; enum ExampleCase : Int {<br>&gt; <br>&gt;  case Foo<br>&gt;  case Bar<br>&gt;  case Baz<br>&gt; <br>&gt; }<br>&gt; <br>&gt; extension Example {<br>&gt; <br>&gt;  var enumerationCase: ExampleCase {<br>&gt;    get {<br>&gt;      switch self {<br>&gt;        case .Foo(_): return .Foo<br>&gt;        case .Bar(_): return .Bar<br>&gt;        case .Baz(_): return .Baz<br>&gt;      }<br>&gt;    }<br>&gt;  }  <br>&gt; <br>&gt; }<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/cc74e3a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 4:05 PM, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case for the ability to refer to an enum case generically without reference to any of its associated values.<br>&gt; <br>&gt; Let me give you an example:<br>&gt; <br>&gt; In our app, we have an enum that represents all the different screens to which the user can navigate. (A screen in our case usually means a view controller or hierarchy thereof.)<br>&gt; <br>&gt; Because each screen might require specific view model object(s) to render their content, some of our enum cases have associated values to store the required view model objects.<br>&gt; <br>&gt; This allows an enum value to contain all the information needed to present any screen to the user, fully populated with content.<br>&gt; <br>&gt; However, in a few instances I&#39;ve found it would be helpful to be able to refer to a screen in the abstract and be able to &#39;switch&#39; against it without any associated values. (This would allow me to be able to refer to, say, &quot;the User Account screen&quot; in the abstract, whereas now I can only refer to &quot;the User Account screen displaying details for this particular user&quot;.)<br>&gt; <br>&gt; We&#39;ve identified two possible solutions to this issue and have implemented one of them, but it is still sub-optimal:<br>&gt; <br>&gt; • One option involves maintaining a parallel enum with the same case names but without any associated values. These parallel structures need to be manually maintained, which is something the compiler cannot enforce.<br></p><p>^ this is what I have been doing by hand when needed (mainly to support serialization); as you say, the compiler doesn’t do anything enforce the two &quot;parallel enums&quot; stay in sync with each other.<br></p><p>&gt; • Another option involves removing the associated values from the enum and passing around objects to contain the necessary view model objects. At various points, we assert that the view model container object is of the expected type for the enum case, but again, that now moves to runtime an error that otherwise would&#39;ve been caught by the compiler.<br></p><p>^ in your use case I’d probably do something analogous, but even this isn’t necessarily always workable (sometimes multiple cases have the same type of associated value, and aside from *being* a runtime check you risk having the wrong value even if the types match; wouldn’t usually be a risk for view models, but you might have e.g. different “types” of image URLs that need different HTTP headers added to their requests...).<br></p><p>But yes, this is exactly the situation I’m driving at. <br></p><p>If compiler support to synthesize these enums is added I’d prefer it be opt-in, if only to have a natural place in the syntax to customize some of the details (e.g. maybe UInt vs Int, maybe you want @objc on it, and for serialization support starting the “parallel enum” from 1 instead of 0 smooths over a mild annoyance with the `NSCoder` API).<br></p><p>But these are definitely the kinds of things I had in mind.<br></p><p>&gt; <br>&gt; ---<br>&gt; <br>&gt; When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br>&gt; <br>&gt; I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br>&gt; <br>&gt; enum Foo<br>&gt; {<br>&gt;     case Bar(String)<br>&gt;     case Baz(Int, Int)<br>&gt; <br>&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;     // with cases that don&#39;t have associated values<br>&gt;     var enumType: FooType<br>&gt; }<br>&gt; <br>&gt; // generated by the compiler when an enum<br>&gt; // has at least one associated value<br>&gt; enum FooType<br>&gt; {<br>&gt;     case Bar<br>&gt;     case Baz<br>&gt; }<br>&gt; <br>&gt; This would make it possible to be able to refer to cases in the abstract.<br>&gt; <br>&gt; Perhaps there&#39;s a totally different solution to this class of problem, but that&#39;s what I came up with. Would love to hear your thoughts.<br>&gt; <br>&gt; E.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt; <br>&gt;&gt; @synthesize_case_enum<br>&gt;&gt; enum Example {<br>&gt;&gt; <br>&gt;&gt;  case Foo(X)<br>&gt;&gt;  case Bar<br>&gt;&gt;  case Baz(Y)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt; <br>&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt; <br>&gt;&gt;  case Foo<br>&gt;&gt;  case Bar<br>&gt;&gt;  case Baz<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Example {<br>&gt;&gt; <br>&gt;&gt;  var enumerationCase: ExampleCase {<br>&gt;&gt;    get {<br>&gt;&gt;      switch self {<br>&gt;&gt;        case .Foo(_): return .Foo<br>&gt;&gt;        case .Bar(_): return .Bar<br>&gt;&gt;        case .Baz(_): return .Baz<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt;  }  <br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/7228288b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>Maybe I’m misunderstanding your use case, but I believe what you require is already possible. When switching through enum cases, there’s no obligation to bind to the associated values if they’re not needed.<br></p><p>enum Foo {<br>  case Bar(String)<br>  case Baz(Int, Int)<br>}<br></p><p>let baz = Foo.Baz(1, 2)<br></p><p>switch baz {<br>case .Bar: print(&quot;Bar&quot;)<br>case .Baz: print(&quot;Baz&quot;)<br>}<br></p><p>Al<br></p><p><br>&gt; On 10 Dec 2015, at 22:05, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br>&gt; <br>&gt; I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br>&gt; <br>&gt; enum Foo<br>&gt; {<br>&gt;     case Bar(String)<br>&gt;     case Baz(Int, Int)<br>&gt; <br>&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;     // with cases that don&#39;t have associated values<br>&gt;     var enumType: FooType<br>&gt; }<br>&gt; <br>&gt; // generated by the compiler when an enum<br>&gt; // has at least one associated value<br>&gt; enum FooType<br>&gt; {<br>&gt;     case Bar<br>&gt;     case Baz<br>&gt; }<br>&gt; <br>&gt; This would make it possible to be able to refer to cases in the abstract.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/3dfefda3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 2:05 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case for the ability to refer to an enum case generically without reference to any of its associated values.<br>&gt; <br>&gt; Let me give you an example:<br>&gt; <br>&gt; In our app, we have an enum that represents all the different screens to which the user can navigate. (A screen in our case usually means a view controller or hierarchy thereof.)<br>&gt; <br>&gt; Because each screen might require specific view model object(s) to render their content, some of our enum cases have associated values to store the required view model objects.<br>&gt; <br>&gt; This allows an enum value to contain all the information needed to present any screen to the user, fully populated with content.<br>&gt; <br>&gt; However, in a few instances I&#39;ve found it would be helpful to be able to refer to a screen in the abstract and be able to &#39;switch&#39; against it without any associated values. (This would allow me to be able to refer to, say, &quot;the User Account screen&quot; in the abstract, whereas now I can only refer to &quot;the User Account screen displaying details for this particular user&quot;.)<br></p><p>I might be missing something, but you can do this already. &#39;case .CaseWithPayload:&#39; matches any CaseWithPayload regardless of its payload.<br></p><p>-Joe<br></p><p>&gt; We&#39;ve identified two possible solutions to this issue and have implemented one of them, but it is still sub-optimal:<br>&gt; <br>&gt; • One option involves maintaining a parallel enum with the same case names but without any associated values. These parallel structures need to be manually maintained, which is something the compiler cannot enforce.<br>&gt; <br>&gt; • Another option involves removing the associated values from the enum and passing around objects to contain the necessary view model objects. At various points, we assert that the view model container object is of the expected type for the enum case, but again, that now moves to runtime an error that otherwise would&#39;ve been caught by the compiler.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br>&gt; <br>&gt; I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br>&gt; <br>&gt; enum Foo<br>&gt; {<br>&gt;     case Bar(String)<br>&gt;     case Baz(Int, Int)<br>&gt; <br>&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;     // with cases that don&#39;t have associated values<br>&gt;     var enumType: FooType<br>&gt; }<br>&gt; <br>&gt; // generated by the compiler when an enum<br>&gt; // has at least one associated value<br>&gt; enum FooType<br>&gt; {<br>&gt;     case Bar<br>&gt;     case Baz<br>&gt; }<br>&gt; <br>&gt; This would make it possible to be able to refer to cases in the abstract.<br>&gt; <br>&gt; Perhaps there&#39;s a totally different solution to this class of problem, but that&#39;s what I came up with. Would love to hear your thoughts.<br>&gt; <br>&gt; E.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt; <br>&gt;&gt; @synthesize_case_enum<br>&gt;&gt; enum Example {<br>&gt;&gt; <br>&gt;&gt;  case Foo(X)<br>&gt;&gt;  case Bar<br>&gt;&gt;  case Baz(Y)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt; <br>&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt; <br>&gt;&gt;  case Foo<br>&gt;&gt;  case Bar<br>&gt;&gt;  case Baz<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Example {<br>&gt;&gt; <br>&gt;&gt;  var enumerationCase: ExampleCase {<br>&gt;&gt;    get {<br>&gt;&gt;      switch self {<br>&gt;&gt;        case .Foo(_): return .Foo<br>&gt;&gt;        case .Bar(_): return .Bar<br>&gt;&gt;        case .Baz(_): return .Baz<br>&gt;&gt;      }<br>&gt;&gt;    }<br>&gt;&gt;  }  <br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/d24b12e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>//Swift version 2.2-dev<br>enum case &#39;CaseWithPayload&#39; not found<br></p><p><br></p><p><br>On Thu, Dec 10, 2015 at 3:31 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 10, 2015, at 2:05 PM, Evan Maloney via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case<br>&gt; for the ability to refer to an enum case generically without reference to<br>&gt; any of its associated values.<br>&gt;<br>&gt; Let me give you an example:<br>&gt;<br>&gt; In our app, we have an enum that represents all the different *screens* to<br>&gt; which the user can navigate. (A *screen* in our case usually means a view<br>&gt; controller or hierarchy thereof.)<br>&gt;<br>&gt; Because each screen might require specific view model object(s) to render<br>&gt; their content, some of our enum cases have associated values to store the<br>&gt; required view model objects.<br>&gt;<br>&gt; This allows an enum value to contain all the information needed to present<br>&gt; any screen to the user, fully populated with content.<br>&gt;<br>&gt; However, in a few instances I&#39;ve found it would be helpful to be able to<br>&gt; refer to a screen in the abstract and be able to &#39;switch&#39; against it<br>&gt; without any associated values. (This would allow me to be able to refer to,<br>&gt; say, &quot;the User Account screen&quot; in the abstract, whereas now I can only<br>&gt; refer to &quot;the User Account screen displaying details for this particular<br>&gt; user&quot;.)<br>&gt;<br>&gt;<br>&gt; I might be missing something, but you can do this already. &#39;case<br>&gt; .CaseWithPayload:&#39; matches any CaseWithPayload regardless of its payload.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; We&#39;ve identified two possible solutions to this issue and have implemented<br>&gt; one of them, but it is still sub-optimal:<br>&gt;<br>&gt; • One option involves maintaining a parallel enum with the same case names<br>&gt; but without any associated values. These parallel structures need to be<br>&gt; manually maintained, which is something the compiler cannot enforce.<br>&gt;<br>&gt; • Another option involves removing the associated values from the enum and<br>&gt; passing around objects to contain the necessary view model objects. At<br>&gt; various points, we assert that the view model container object is of the<br>&gt; expected type for the enum case, but again, that now moves to runtime an<br>&gt; error that otherwise would&#39;ve been caught by the compiler.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; When an enum case takes one or more associated values, it acts more like a<br>&gt; *type* than a *value* because it specifies a format for storing<br>&gt; information without specifying the exact informations stored. We&#39;re able to<br>&gt; refer to other types as such in Swift, but not in this case.<br>&gt;<br>&gt; I think it would be helpful if any enum with at least one case had a<br>&gt; parallel representation containing the same cases but without associated<br>&gt; values. It might look like:<br>&gt;<br>&gt; enum Foo<br>&gt; {<br>&gt;     case Bar(String)<br>&gt;     case Baz(Int, Int)<br>&gt;<br>&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;     // with cases that don&#39;t have associated values<br>&gt;     var enumType: FooType<br>&gt; }<br>&gt;<br>&gt; // generated by the compiler when an enum<br>&gt; // has at least one associated value<br>&gt; enum FooType<br>&gt; {<br>&gt;     case Bar<br>&gt;     case Baz<br>&gt; }<br>&gt;<br>&gt; This would make it possible to be able to refer to cases in the abstract.<br>&gt;<br>&gt; Perhaps there&#39;s a totally different solution to this class of problem, but<br>&gt; that&#39;s what I came up with. Would love to hear your thoughts.<br>&gt;<br>&gt; E.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; FWIW, as long as we’re asking for some compiler assistance generating<br>&gt; useful enumeration-related boilerplate, I’d like to request that something<br>&gt; along these lines be possible in some version of Swift:<br>&gt;<br>&gt; @synthesize_case_enum<br>&gt; enum Example {<br>&gt;<br>&gt;  case Foo(X)<br>&gt;  case Bar<br>&gt;  case Baz(Y)<br>&gt;<br>&gt; }<br>&gt;<br>&gt; …which would then by default expand to something like this:<br>&gt;<br>&gt; enum ExampleCase : Int {<br>&gt;<br>&gt;  case Foo<br>&gt;  case Bar<br>&gt;  case Baz<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension Example {<br>&gt;<br>&gt;  var enumerationCase: ExampleCase {<br>&gt;    get {<br>&gt;      switch self {<br>&gt;        case .Foo(_): return .Foo<br>&gt;        case .Bar(_): return .Bar<br>&gt;        case .Baz(_): return .Baz<br>&gt;      }<br>&gt;    }<br>&gt;  }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/68d4a274/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 5:19 PM, J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt; wrote:<br>&gt; <br>&gt; //Swift version 2.2-dev<br>&gt; enum case &#39;CaseWithPayload&#39; not found<br></p><p>Sorry, &#39;.CaseWithPayload&#39; was intended as a stand-in for whatever your specific case with payload is named:<br></p><p>enum Foo {<br>  case A(Int)<br>  case B<br>}<br></p><p>let foo = Foo.A(0)<br></p><p>switch foo {<br>case .A: print(&quot;hi&quot;)<br>case .B: print(&quot;bye&quot;)<br>}<br></p><p>-Joe<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; On Thu, Dec 10, 2015 at 3:31 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 2:05 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case for the ability to refer to an enum case generically without reference to any of its associated values.<br>&gt;&gt; <br>&gt;&gt; Let me give you an example:<br>&gt;&gt; <br>&gt;&gt; In our app, we have an enum that represents all the different screens to which the user can navigate. (A screen in our case usually means a view controller or hierarchy thereof.)<br>&gt;&gt; <br>&gt;&gt; Because each screen might require specific view model object(s) to render their content, some of our enum cases have associated values to store the required view model objects.<br>&gt;&gt; <br>&gt;&gt; This allows an enum value to contain all the information needed to present any screen to the user, fully populated with content.<br>&gt;&gt; <br>&gt;&gt; However, in a few instances I&#39;ve found it would be helpful to be able to refer to a screen in the abstract and be able to &#39;switch&#39; against it without any associated values. (This would allow me to be able to refer to, say, &quot;the User Account screen&quot; in the abstract, whereas now I can only refer to &quot;the User Account screen displaying details for this particular user&quot;.)<br>&gt; <br>&gt; I might be missing something, but you can do this already. &#39;case .CaseWithPayload:&#39; matches any CaseWithPayload regardless of its payload.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; We&#39;ve identified two possible solutions to this issue and have implemented one of them, but it is still sub-optimal:<br>&gt;&gt; <br>&gt;&gt; • One option involves maintaining a parallel enum with the same case names but without any associated values. These parallel structures need to be manually maintained, which is something the compiler cannot enforce.<br>&gt;&gt; <br>&gt;&gt; • Another option involves removing the associated values from the enum and passing around objects to contain the necessary view model objects. At various points, we assert that the view model container object is of the expected type for the enum case, but again, that now moves to runtime an error that otherwise would&#39;ve been caught by the compiler.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br>&gt;&gt; <br>&gt;&gt; I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br>&gt;&gt; <br>&gt;&gt; enum Foo<br>&gt;&gt; {<br>&gt;&gt;     case Bar(String)<br>&gt;&gt;     case Baz(Int, Int)<br>&gt;&gt; <br>&gt;&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;&gt;     // with cases that don&#39;t have associated values<br>&gt;&gt;     var enumType: FooType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // generated by the compiler when an enum<br>&gt;&gt; // has at least one associated value<br>&gt;&gt; enum FooType<br>&gt;&gt; {<br>&gt;&gt;     case Bar<br>&gt;&gt;     case Baz<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would make it possible to be able to refer to cases in the abstract.<br>&gt;&gt; <br>&gt;&gt; Perhaps there&#39;s a totally different solution to this class of problem, but that&#39;s what I came up with. Would love to hear your thoughts.<br>&gt;&gt; <br>&gt;&gt; E.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @synthesize_case_enum<br>&gt;&gt;&gt; enum Example {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  case Foo(X)<br>&gt;&gt;&gt;  case Bar<br>&gt;&gt;&gt;  case Baz(Y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  case Foo<br>&gt;&gt;&gt;  case Bar<br>&gt;&gt;&gt;  case Baz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Example {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var enumerationCase: ExampleCase {<br>&gt;&gt;&gt;    get {<br>&gt;&gt;&gt;      switch self {<br>&gt;&gt;&gt;        case .Foo(_): return .Foo<br>&gt;&gt;&gt;        case .Bar(_): return .Bar<br>&gt;&gt;&gt;        case .Baz(_): return .Baz<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/37600357/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 5:23 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 10, 2015, at 5:19 PM, J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; //Swift version 2.2-dev<br>&gt;&gt; enum case &#39;CaseWithPayload&#39; not found<br>&gt; <br>&gt; Sorry, &#39;.CaseWithPayload&#39; was intended as a stand-in for whatever your specific case with payload is named:<br>&gt; <br>&gt; enum Foo {<br>&gt;   case A(Int)<br>&gt;   case B<br>&gt; }<br>&gt; <br>&gt; let foo = Foo.A(0)<br>&gt; <br>&gt; switch foo {<br>&gt; case .A: print(&quot;hi&quot;)<br>&gt; case .B: print(&quot;bye&quot;)<br>&gt; }<br>&gt; <br>&gt; -Joe<br></p><p>This discussion and the ‘List of all enum values’ thread makes me think of a related feature that most people probably aren’t aware of — referring to an enum case constructor for a case with a payload, without actually applying it, yields a function value that you can pass around, eg in the above code ‘Foo.A’ has type Int -&gt; Foo.<br></p><p>In the past we’ve also talked about adding ‘projections’ which test for that enum case and wrap the payload in an optional, where Foo.A would have two overloads, the constructor Int -&gt; Foo and a projection Foo -&gt; Int?.<br></p><p>It might be useful for enum cases to witness protocol requirements, too — has anyone wanted this?<br></p><p>Just food for thought,<br></p><p>Slava<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 10, 2015 at 3:31 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 2:05 PM, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure if this is what you&#39;re driving at, but I&#39;ve found a use-case for the ability to refer to an enum case generically without reference to any of its associated values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me give you an example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In our app, we have an enum that represents all the different screens to which the user can navigate. (A screen in our case usually means a view controller or hierarchy thereof.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because each screen might require specific view model object(s) to render their content, some of our enum cases have associated values to store the required view model objects.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This allows an enum value to contain all the information needed to present any screen to the user, fully populated with content.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, in a few instances I&#39;ve found it would be helpful to be able to refer to a screen in the abstract and be able to &#39;switch&#39; against it without any associated values. (This would allow me to be able to refer to, say, &quot;the User Account screen&quot; in the abstract, whereas now I can only refer to &quot;the User Account screen displaying details for this particular user&quot;.)<br>&gt;&gt; <br>&gt;&gt; I might be missing something, but you can do this already. &#39;case .CaseWithPayload:&#39; matches any CaseWithPayload regardless of its payload.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; We&#39;ve identified two possible solutions to this issue and have implemented one of them, but it is still sub-optimal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • One option involves maintaining a parallel enum with the same case names but without any associated values. These parallel structures need to be manually maintained, which is something the compiler cannot enforce.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • Another option involves removing the associated values from the enum and passing around objects to contain the necessary view model objects. At various points, we assert that the view model container object is of the expected type for the enum case, but again, that now moves to runtime an error that otherwise would&#39;ve been caught by the compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When an enum case takes one or more associated values, it acts more like a type than a value because it specifies a format for storing information without specifying the exact informations stored. We&#39;re able to refer to other types as such in Swift, but not in this case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be helpful if any enum with at least one case had a parallel representation containing the same cases but without associated values. It might look like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Foo<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     case Bar(String)<br>&gt;&gt;&gt;     case Baz(Int, Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // generated by the compiler; returns the parallel FooType<br>&gt;&gt;&gt;     // with cases that don&#39;t have associated values<br>&gt;&gt;&gt;     var enumType: FooType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // generated by the compiler when an enum<br>&gt;&gt;&gt; // has at least one associated value<br>&gt;&gt;&gt; enum FooType<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     case Bar<br>&gt;&gt;&gt;     case Baz<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would make it possible to be able to refer to cases in the abstract.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps there&#39;s a totally different solution to this class of problem, but that&#39;s what I came up with. Would love to hear your thoughts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:24 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, as long as we’re asking for some compiler assistance generating useful enumeration-related boilerplate, I’d like to request that something along these lines be possible in some version of Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @synthesize_case_enum<br>&gt;&gt;&gt;&gt; enum Example {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  case Foo(X)<br>&gt;&gt;&gt;&gt;  case Bar<br>&gt;&gt;&gt;&gt;  case Baz(Y)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …which would then by default expand to something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ExampleCase : Int {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  case Foo<br>&gt;&gt;&gt;&gt;  case Bar<br>&gt;&gt;&gt;&gt;  case Baz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Example {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  var enumerationCase: ExampleCase {<br>&gt;&gt;&gt;&gt;    get {<br>&gt;&gt;&gt;&gt;      switch self {<br>&gt;&gt;&gt;&gt;        case .Foo(_): return .Foo<br>&gt;&gt;&gt;&gt;        case .Bar(_): return .Bar<br>&gt;&gt;&gt;&gt;        case .Baz(_): return .Baz<br>&gt;&gt;&gt;&gt;      }<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;  }  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/7cf186c3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; I might be missing something, but you can do this already. &#39;case .CaseWithPayload:&#39; matches any CaseWithPayload regardless of its payload.<br>&gt;&gt; <br>&gt;&gt; -Joe<br></p><p>Hi Joe,<br></p><p>Thanks for the reply.<br></p><p>You&#39;re referring to the ability to test whether an existing enum value is of a given case regardless of the contents of its associated values. In other words, after a value has been created, you can test for whether it is of a specific case while ignoring any associated values.<br></p><p>I&#39;m talking about the ability to create a value that represents the generic concept of an enum case that has associated values, but without actually specifying any associated values.<br></p><p>In Swift right now, you can programmatically represent an enum case that has associated values only by first supplying those associated values.<br></p><p>I think of it like the difference between a class and an instance. A class defines a type and it defines storage. An instance is of a certain type and puts specific values in the storage. An instance or value is a realization of a class or type. If I have an instance or value, I can ask it to tell me its type. I can store that type in a variable. There is also a notation to allow me to specify any such type as a literal.<br></p><p>Just as I can programmatically refer to the type of an value (or the class of an object instance), I&#39;d like to be able to refer to a case in the abstract without also needing to supply associated values.  But that&#39;s not possible; an enum case that is declared with associated values can&#39;t exist in any form unless and until those values are specified.<br></p><p>Perhaps an example will help. Assume the following enum representing the universe of screens that can be displayed in an app:<br></p><p>enum Screens<br>{<br>    case Splash<br>    case Landing<br>    case UserPreferences(User)<br>    case StoreView(Store)<br>    case SaleView(Sale)<br>    case ProductView(Product)<br>}<br></p><p>Some of the cases have associated values, some do not. The ones that have associated values represent screens that require certain input in order to display content.<br></p><p>Now say I want to populate a debug menu that lets testers navigate anywhere in the app. I&#39;d like a way to represent each screen in the app, but without any specific content.<br></p><p>I have an enum of Screens right here, but I can&#39;t actually use it for that purpose because I can&#39;t create values from it without supplying the associated values right then and there. So I can&#39;t add a &quot;func allScreens() -&gt; [Screens]&quot; to the enum to allow me to query for this information.<br></p><p>The simplest work-around for this use case seems to be creating a parallel enum like:<br></p><p>enum ScreenTypes<br>{<br>    case Splash<br>    case Landing<br>    case UserPreferences<br>    case StoreView<br>    case SaleView<br>    case ProductView<br></p><p>    func allScreens() -&gt; [ScreenTypes]<br>}<br></p><p>With such an enum, I could populate a debug menu.<br></p><p>Several times now when I&#39;ve used enums that have associated values, I&#39;ve wished for a parallel enum that had the same cases, but without associated values, so I could do things like that. I usually end of creating one, but then I lose the ability to have the compiler flag a whole class of errors.<br></p><p>Does my explanation make sense?<br></p><p>All the best,<br>E.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/faeef86e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>I don’t think this suggestion would work in practice. It’s the equivalent of trying to construct a struct value with non-optional properties, but without providing any init parameters, it would result in an invalid value. If your proposal were possible I think it would cause trouble with pattern matching enums too. In a switch statement that expects to bind to associated values, what happens when it receives an enum that should have associated values, but they are not present?<br></p><p><br>&gt; On 11 Dec 2015, at 04:53, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; You&#39;re referring to the ability to test whether an existing enum value is of a given case regardless of the contents of its associated values. In other words, after a value has been created, you can test for whether it is of a specific case while ignoring any associated values.<br>&gt; <br>&gt; I&#39;m talking about the ability to create a value that represents the generic concept of an enum case that has associated values, but without actually specifying any associated values.<br>&gt; <br>&gt; In Swift right now, you can programmatically represent an enum case that has associated values only by first supplying those associated values.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/457c97d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cf416f0dacd159a3e77dc03cbe0a4670?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Sandy Chapman</string> &lt;schapman at lixar.com&gt;<p>December 11, 2015 at 09:00:00am</p></header><div class="content"><p>You can already do something like this as well. Sure it&#39;s a bit verbose,<br>but for the cases where you need to ignore the associated value you can do<br>a one-to-one mapping. You can then simply do a switch(enumVar.type()) { ...<br>}.<br></p><p>enum EnumType {<br></p><p>    enum EnumTypeType {<br>        case TypeA<br>        case TypeB<br>        case TypeC<br>        case TypeD<br>    }<br></p><p>    case TypeA(String)<br>    case TypeB(Bool)<br>    case TypeC()<br>    case TypeD(String)<br></p><p>    func type() -&gt; EnumTypeType {<br>        switch(self) {<br>        case .TypeA(_):<br>            return .TypeA<br>        case .TypeB(_):<br>            return .TypeB<br>        case .TypeC():<br>            return .TypeC<br>        case TypeD(_):<br>            return .TypeD<br>        }<br>    }<br>}<br></p><p>*Sandy Chapman*<br>*Technical Team Lead*<br></p><p><br>*Lixar I.T. Inc.*T: 902.405.4443<br>F: 902.405.4435<br></p><p>schapman at lixar.com<br>www.lixar.com<br></p><p>[image: Description: cid:image003.gif at 01CB115A.001B0250]<br></p><p>On Fri, Dec 11, 2015 at 8:51 AM, Al Skipp via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don’t think this suggestion would work in practice. It’s the equivalent<br>&gt; of trying to construct a struct value with non-optional properties, but<br>&gt; without providing any init parameters, it would result in an invalid value.<br>&gt; If your proposal were possible I think it would cause trouble with pattern<br>&gt; matching enums too. In a switch statement that expects to bind to<br>&gt; associated values, what happens when it receives an enum that should have<br>&gt; associated values, but they are not present?<br>&gt;<br>&gt;<br>&gt; On 11 Dec 2015, at 04:53, Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt;<br>&gt; You&#39;re referring to the ability to test whether an existing enum value is<br>&gt; of a given case regardless of the contents of its associated values. In<br>&gt; other words, *after* a value has been created, you can test for whether<br>&gt; it is of a specific case while ignoring any associated values.<br>&gt;<br>&gt; I&#39;m talking about the ability to create a value that represents the<br>&gt; generic concept of an enum case that has associated values, but without<br>&gt; actually specifying any associated values.<br>&gt;<br>&gt; In Swift right now, you can programmatically represent an enum case that<br>&gt; has associated values *only by first supplying those associated values*.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p>-- <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8129d62c/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: image001.jpg<br>Type: image/jpeg<br>Size: 1631 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/8129d62c/attachment.jpg&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; You can already do something like this as well. Sure it&#39;s a bit verbose, but for the cases where you need to ignore the associated value you can do a one-to-one mapping. You can then simply do a switch(enumVar.type()) { ... }.<br>&gt; <br>&gt; enum EnumType {<br>&gt;     <br>&gt;     enum EnumTypeType {<br>&gt;         case TypeA<br>&gt;         case TypeB<br>&gt;         case TypeC<br>&gt;         case TypeD<br>&gt;     }<br>&gt;     <br>&gt;     case TypeA(String)<br>&gt;     case TypeB(Bool)<br>&gt;     case TypeC()<br>&gt;     case TypeD(String)<br>&gt;     <br>&gt;     func type() -&gt; EnumTypeType {<br>&gt;         switch(self) {<br>&gt;         case .TypeA(_):<br>&gt;             return .TypeA<br>&gt;         case .TypeB(_):<br>&gt;             return .TypeB<br>&gt;         case .TypeC():<br>&gt;             return .TypeC<br>&gt;         case TypeD(_):<br>&gt;             return .TypeD<br>&gt;         }<br>&gt;     }<br>&gt; }<br></p><p><br>I initially considered this option too, but it doesn’t address the question:<br></p><p>&gt; I&#39;m talking about the ability to create a value that represents the generic concept of an enum case that has associated values, but without actually specifying any associated values.<br></p><p>The request was the ability to create enums without supplying the associated parameters, the above implementation doesn’t allow that (it’s simply not feasible). Also, it’s possible to pattern match an enum without binding it’s associated values, so there’s no need to create an internal ‘shadow’ enum without the parameters.<br></p><p>A very ugly approach would be to make the associated values Optionals, but that’s quite a hacky thing to do for the use case.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/0d2187b5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; I don’t think this suggestion would work in practice. It’s the equivalent of trying to construct a struct value with non-optional properties, but without providing any init parameters, it would result in an invalid value. If your proposal were possible I think it would cause trouble with pattern matching enums too. In a switch statement that expects to bind to associated values, what happens when it receives an enum that should have associated values, but they are not present?<br></p><p>I am definitely not proposing any change in the current behavior of enums, cases, pattern matching, or anything like that.<br></p><p>I&#39;m proposing adding a way of representing something that currently can&#39;t be represented in Swift.<br></p><p>You can match an enum case by ignoring the associated values it contains, but that&#39;s matching against a value that has *already been created with associated values*.<br></p><p>There&#39;s no way to create a value in Swift that represents the general form of an enum case when that case is declared with associated values. You can only create a value in the specific form, i.e. the form of the case that actually contains the associated values. There&#39;s no way to represent the general form.<br></p><p>Bear with my inaccurate analogy here, because it might provide a better explanation of what I&#39;m talking about:<br></p><p>In an enum, when a case has no associated values, you can think of values of that case behaving like a type in that there&#39;s only one version of it that can exist: the thing itself. There&#39;s no range of values that can be represented by such an enum case; there&#39;s just one value.<br></p><p>Now, once you introduce associated values, the concept of an enum case suddenly changes: it no longer represents a single thing, it represents a potential range of things. In other words, realized versions of those case values stop acting like types and start acting like instances of a type.<br></p><p>Anywhere else in Swift where something acts like a value, there&#39;s an equivalent metavalue type that can also be represented in a Swift variable.<br></p><p>Why would I want to do this?<br></p><p>It seems to me it&#39;s quite common in software development that when you model specific instances of things, you also need a way to represent the general form of those specific things.<br></p><p>In my case, I want to model a set of screens with specific content, I might do that with an enum containing associated values. The case represents the screen, and the associated values represent the content.<br></p><p>However, in addition to representing the specific, I also need to model the general. Instead of modeling screens with specific content, I also need to programmatically model just the screens themselves, without any specific content.<br></p><p>My solution was to allow such enums to opt-in to a protocol that would cause the compiler to generate a parallel enum that contains the same cases, minus the associated values.<br></p><p>This parallel enum would be an entirely different type, and it would not affect the current semantics of the original enum (with the associated values) that it &quot;shadows&quot;.<br></p><p>I&#39;ve run into several use cases for this in about a year of Swift coding, and each time I&#39;ve come up with a manual work-around (just as others have suggested various ways to work around this) but in each case, I lose the compiler&#39;s ability to enforce the conditions that I must now assert at runtime.<br></p><p>E.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 06:00:00am</p></header><div class="content"><p>&gt; With such an enum, I could populate a debug menu.<br></p><p>If you just want this for debugging, have you looked at the reflection APIs?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Request: Ability to refer to an enum case in abstract (without its associated value)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 06:00:00am</p></header><div class="content"><p>&gt; If you just want this for debugging, have you looked at the reflection APIs?<br></p><p>Sorry, that’s probably not suitable for your specific use case.<br></p><p>Honestly, I really do think you’re confusing two separate issues: testing which screen you’re on, and navigating to a particular screen. You can test which screen you’re on without paying attention to the specific associated values. But if you then want to navigate to a screen, you’re going to need the associated values anyway. Why would you want a version of your enum which didn’t have them?<br></p><p>(By the way, if your answer is “I want to map meta-enum values to the enum value I’m currently using”, then write a Hashable conformance which ignores the associated values. Then looking up .Foo(a) in a Dictionary will give you .Foo(b) if that’s present instead.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
