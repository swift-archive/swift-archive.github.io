<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>Fwd: [Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>Joe, <br></p><p>I’m wondering if you missed my comments.  I had a few questions I haven’t seen answered yet so I’m bumping them. <br></p><p>-Matthew<br></p><p>The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br></p><p>var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>var [initializerReqt] y // no initializer, error because of the initializer requirement?<br></p><p>Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br></p><p>struct S {<br>  var [observed] s: String<br>  init(s: String) {<br>    // What happens here?  Is the behavior’s “set” accessor called?  <br>    // This may not always be desirable, as in the case of “observed&quot;<br>    self.s = s<br>  }<br>}<br></p><p>One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br></p><p>This would also allow us to support a variant `delayedImmutable` that *must* be assigned during initialization of the containing type, but not necessarily during phase 1.  That behavior would facilitate maximum safety when we must pass `self` to the initializer when constructing an instance to assign to a property (not an uncommon use case).  <br></p><p>If the compiler could enforce slightly relaxed initialization rules that require initialization of the property before the initializer exits and before the property is read in the initializer body, but not necessarily during phase 1, then we could achieve nearly complete static safety.  The only window for error would be any uses of self that happen outside the initializer body before the property is initialized.  <br></p><p>The behavior might look like this:<br></p><p>public var behavior phase2Immutable&lt;Value&gt;: Value {<br>  private var value: Value? = nil<br></p><p>  get {<br>    guard let value = value else {<br>      fatalError(&quot;property accessed before being initialized&quot;)<br>    }<br>    return value<br>  }<br>  <br>  init {<br>    value = initialValue<br>  }<br>}<br></p><p>This would be a significant improvement over delayedImmutable in many use cases IMO.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/62a831bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:31 AM, Matthew Johnson &lt;musical.matthew at mac.com&gt; wrote:<br>&gt; <br>&gt; Joe, <br>&gt; <br>&gt; I’m wondering if you missed my comments.  I had a few questions I haven’t seen answered yet so I’m bumping them. <br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br>&gt; <br>&gt; var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>&gt; var [initializerReqt] y // no initializer, error because of the initializer requirement?<br></p><p>Sorry, I thought I explained this. The default stored property that gets instantiated for a base property can be initialized out-of-line, so the inline initializer expression is optional, yes.<br></p><p>&gt; <br>&gt; Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br>&gt; <br>&gt; struct S {<br>&gt;   var [observed] s: String<br>&gt;   init(s: String) {<br>&gt;     // What happens here?  Is the behavior’s “set” accessor called?  <br>&gt;     // This may not always be desirable, as in the case of “observed&quot;<br>&gt;     self.s = s<br>&gt;   }<br>&gt; }<br></p><p>Just like today, assignments within the initializer would bypass the behavior and directly initialize the storage.<br></p><p>&gt; <br>&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br></p><p>That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br></p><p>-Joe<br></p><p>&gt; <br>&gt; This would also allow us to support a variant `delayedImmutable` that *must* be assigned during initialization of the containing type, but not necessarily during phase 1.  That behavior would facilitate maximum safety when we must pass `self` to the initializer when constructing an instance to assign to a property (not an uncommon use case).  <br>&gt; <br>&gt; If the compiler could enforce slightly relaxed initialization rules that require initialization of the property before the initializer exits and before the property is read in the initializer body, but not necessarily during phase 1, then we could achieve nearly complete static safety.  The only window for error would be any uses of self that happen outside the initializer body before the property is initialized.  <br>&gt; <br>&gt; The behavior might look like this:<br>&gt; <br>&gt; public var behavior phase2Immutable&lt;Value&gt;: Value {<br>&gt;   private var value: Value? = nil<br>&gt; <br>&gt;   get {<br>&gt;     guard let value = value else {<br>&gt;       fatalError(&quot;property accessed before being initialized&quot;)<br>&gt;     }<br>&gt;     return value<br>&gt;   }<br>&gt;   <br>&gt;   init {<br>&gt;     value = initialValue<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This would be a significant improvement over delayedImmutable in many use cases IMO.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/2d5f2c53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 9:31 AM, Matthew Johnson &lt;musical.matthew at mac.com &lt;mailto:musical.matthew at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Joe, <br>&gt;&gt; <br>&gt;&gt; I’m wondering if you missed my comments.  I had a few questions I haven’t seen answered yet so I’m bumping them. <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br>&gt;&gt; <br>&gt;&gt; var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>&gt;&gt; var [initializerReqt] y // no initializer, error because of the initializer requirement?<br>&gt; <br>&gt; Sorry, I thought I explained this. The default stored property that gets instantiated for a base property can be initialized out-of-line, so the inline initializer expression is optional, yes.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var [observed] s: String<br>&gt;&gt;   init(s: String) {<br>&gt;&gt;     // What happens here?  Is the behavior’s “set” accessor called?  <br>&gt;&gt;     // This may not always be desirable, as in the case of “observed&quot;<br>&gt;&gt;     self.s = s<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Just like today, assignments within the initializer would bypass the behavior and directly initialize the storage.<br></p><p>Thanks for clarifying.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt; <br>&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br></p><p>Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This would also allow us to support a variant `delayedImmutable` that *must* be assigned during initialization of the containing type, but not necessarily during phase 1.  That behavior would facilitate maximum safety when we must pass `self` to the initializer when constructing an instance to assign to a property (not an uncommon use case).  <br>&gt;&gt; <br>&gt;&gt; If the compiler could enforce slightly relaxed initialization rules that require initialization of the property before the initializer exits and before the property is read in the initializer body, but not necessarily during phase 1, then we could achieve nearly complete static safety.  The only window for error would be any uses of self that happen outside the initializer body before the property is initialized.  <br>&gt;&gt; <br>&gt;&gt; The behavior might look like this:<br>&gt;&gt; <br>&gt;&gt; public var behavior phase2Immutable&lt;Value&gt;: Value {<br>&gt;&gt;   private var value: Value? = nil<br>&gt;&gt; <br>&gt;&gt;   get {<br>&gt;&gt;     guard let value = value else {<br>&gt;&gt;       fatalError(&quot;property accessed before being initialized&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     return value<br>&gt;&gt;   }<br>&gt;&gt;   <br>&gt;&gt;   init {<br>&gt;&gt;     value = initialValue<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would be a significant improvement over delayedImmutable in many use cases IMO.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/d3aa1349/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:48 AM, Matthew Johnson &lt;musical.matthew at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 9:31 AM, Matthew Johnson &lt;musical.matthew at mac.com &lt;mailto:musical.matthew at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m wondering if you missed my comments.  I had a few questions I haven’t seen answered yet so I’m bumping them. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>&gt;&gt;&gt; var [initializerReqt] y // no initializer, error because of the initializer requirement?<br>&gt;&gt; <br>&gt;&gt; Sorry, I thought I explained this. The default stored property that gets instantiated for a base property can be initialized out-of-line, so the inline initializer expression is optional, yes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;   var [observed] s: String<br>&gt;&gt;&gt;   init(s: String) {<br>&gt;&gt;&gt;     // What happens here?  Is the behavior’s “set” accessor called?  <br>&gt;&gt;&gt;     // This may not always be desirable, as in the case of “observed&quot;<br>&gt;&gt;&gt;     self.s = s<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Just like today, assignments within the initializer would bypass the behavior and directly initialize the storage.<br>&gt; <br>&gt; Thanks for clarifying.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt; <br>&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br></p><p>I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/404e7d11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>January 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 4:08 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 9:48 AM, Matthew Johnson &lt;musical.matthew at mac.com &lt;mailto:musical.matthew at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 11:39 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 9:31 AM, Matthew Johnson &lt;musical.matthew at mac.com &lt;mailto:musical.matthew at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m wondering if you missed my comments.  I had a few questions I haven’t seen answered yet so I’m bumping them. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The proposal makes it clear when an initializer is required but is a little bit less clear about when it may be left off.  Is this correct?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var [baseProp] x // no initializer, ok as long as base doesn&#39;t have init req?<br>&gt;&gt;&gt;&gt; var [initializerReqt] y // no initializer, error because of the initializer requirement?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I thought I explained this. The default stored property that gets instantiated for a base property can be initialized out-of-line, so the inline initializer expression is optional, yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another thing that isn’t clear is what happens when a property with a behavior is set within the initializer of the containing type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   var [observed] s: String<br>&gt;&gt;&gt;&gt;   init(s: String) {<br>&gt;&gt;&gt;&gt;     // What happens here?  Is the behavior’s “set” accessor called?  <br>&gt;&gt;&gt;&gt;     // This may not always be desirable, as in the case of “observed&quot;<br>&gt;&gt;&gt;&gt;     self.s = s<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just like today, assignments within the initializer would bypass the behavior and directly initialize the storage.<br>&gt;&gt; <br>&gt;&gt; Thanks for clarifying.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt;&gt; <br>&gt;&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br>&gt; <br>&gt; I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br></p><p>Sure, that’s an important use case.  But I think the use case where you only need to delay initialization until phase 2 due to a back reference, etc is also important and the added safety of guaranteeing initialization *must* happen during phase 2 is highly desirable.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/1cab6a69/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 2:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt;&gt; <br>&gt;&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br>&gt; <br>&gt; I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br></p><p>I don’t really consider that to be initialization in the current sense.  IMO, without extending our DI model, a “delayed” behavior for a property of type T is best modeled with storage for T?, which is implicitly initialized to nil.  The getter would do a force unwrap of the optional, and the setter would check that the storage is nil before assigning over it.<br></p><p>If/when we have support for a more dynamic initialization (e.g. dynamic typestate) then we could expand this to use it, but I don’t see how it would provide a functionally different model.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/8c14e804/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 3:17 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 2:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br>&gt; <br>&gt; I don’t really consider that to be initialization in the current sense.  IMO, without extending our DI model, a “delayed” behavior for a property of type T is best modeled with storage for T?, which is implicitly initialized to nil.  The getter would do a force unwrap of the optional, and the setter would check that the storage is nil before assigning over it.<br>&gt; <br>&gt; If/when we have support for a more dynamic initialization (e.g. dynamic typestate) then we could expand this to use it, but I don’t see how it would provide a functionally different model.<br></p><p>This is pretty much what I mean, and what the [delayed] example from the proposal provides. Matthew&#39;s making a case for a more constrained form of &#39;delayed&#39; that still prevents you from exiting &#39;init&#39; without having initialized everything.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/3f95a05e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 3:19 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 3:17 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 2:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br>&gt;&gt; <br>&gt;&gt; I don’t really consider that to be initialization in the current sense.  IMO, without extending our DI model, a “delayed” behavior for a property of type T is best modeled with storage for T?, which is implicitly initialized to nil.  The getter would do a force unwrap of the optional, and the setter would check that the storage is nil before assigning over it.<br>&gt;&gt; <br>&gt;&gt; If/when we have support for a more dynamic initialization (e.g. dynamic typestate) then we could expand this to use it, but I don’t see how it would provide a functionally different model.<br>&gt; <br>&gt; This is pretty much what I mean, and what the [delayed] example from the proposal provides. Matthew&#39;s making a case for a more constrained form of &#39;delayed&#39; that still prevents you from exiting &#39;init&#39; without having initialized everything.<br></p><p>Ah ok.  Well, such a thing could be built.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/481225fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>January 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 5:21 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 3:19 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 3:17 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 2:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it&#39;s important that delayed initialization also accommodate initialization *after* init() returns. There are many cases where full initialization depends on a process outside of init&#39;s control, especially in Cocoa with objects and outlets set up from nib files.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t really consider that to be initialization in the current sense.  IMO, without extending our DI model, a “delayed” behavior for a property of type T is best modeled with storage for T?, which is implicitly initialized to nil.  The getter would do a force unwrap of the optional, and the setter would check that the storage is nil before assigning over it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If/when we have support for a more dynamic initialization (e.g. dynamic typestate) then we could expand this to use it, but I don’t see how it would provide a functionally different model.<br>&gt;&gt; <br>&gt;&gt; This is pretty much what I mean, and what the [delayed] example from the proposal provides. Matthew&#39;s making a case for a more constrained form of &#39;delayed&#39; that still prevents you from exiting &#39;init&#39; without having initialized everything.<br>&gt; <br>&gt; Ah ok.  Well, such a thing could be built.<br></p><p>Yes, the use case for this is when you need to pass `self` to the initializer of one of your members.  You can’t do this until phase 2, but it would be best if the compiler can still provide as much safety guarantee as possible.<br></p><p>-Matthew <br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/c0ce1d74/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Property behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:48 AM, Matthew Johnson &lt;musical.matthew at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thought is that it might be good to allow behaviors to have `init` accessor that is used if the property is assigned by an initializer of the containing type (only the first time the property is assigned).  This would clarify what happens during initialization of the containing type and allow for different init and set code paths when necessary.   It would be distinguished from the behavior initializer by the lack of parens.  If that is too subtle we could use a different name for the initialization accessor.<br>&gt;&gt; <br>&gt;&gt; That&#39;s a possibility, but inserting initializer calls is a bit more heroic than what our current definite initialization implementation can do. That&#39;s not necessarily a showstopper, but it was a goal of the current design to avoid inserting accessor calls within inits at hard-to-predict places. (cc&#39;ing ChrisL, to get his opinion on this as DI owner)<br>&gt; <br>&gt; Makes sense.  Getting the behavior I would like to see out of a `phase2Immutable` behavior would definitely require updates to the DI rules.  I think the added safety makes it worth doing something in this area eventually, but it could be added later.  I’m interested to hear what Chris thinks.<br></p><p>Swift’s semantics have a big (but largely invisible/unknown to developers) divide between initialization and reassignment.  I agree that it makes sense to expose this different out of a behavior because they may want to do something interesting.<br></p><p>That said, the divide shouldn’t be “assigned in an containing initializer” vs “assigned to somewhere else”. You should be able to have a behavior on a local variable for example.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/b3f9d460/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
