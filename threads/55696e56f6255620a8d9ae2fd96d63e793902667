<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 30, 2016 at 11:00:00pm</p></header><div class="content"><p>The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br></p><p>An html rendered version of this markdown document is available at the following URL:<br></p><p>https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br></p><p>----<br></p><p># Summary<br></p><p>This document proposes:<br></p><p>1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>   be used with memory locations of `non-trivial` type.<br>2. banning the use of `load`, `store` on values of `non-trivial` type.<br></p><p>This will allow for:<br></p><p>1. eliminating optimizer miscompiles that occur due to releases being moved into<br>   the region in between a `load`/`retain`, `load`/`release`,<br>   `store`/`release`. (For a specific example, see the appendix).<br>2. modeling `load`/`store` as having `unsafe unowned` ownership semantics. This<br>   will be enforced via the verifier.<br>3. more aggressive ARC code motion.<br></p><p># Definitions<br></p><p>## load_strong<br></p><p>We propose three different forms of load_strong differentiated via flags. First<br>define `load_strong` as follows:<br></p><p>    %x = load_strong %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br>    retain_value %x : $C<br></p><p>Then define `load_strong [take]` as:<br></p><p>    %x = load_strong [take] %x_ptr : $*Builtin.NativeObject<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br></p><p>**NOTE** `load_strong [take]` implies that the loaded from memory location no<br>longer owns the result object (i.e. a take is a move). Loading from the memory<br>location again without reinitialization is illegal.<br></p><p>Next we provide `load_strong [guaranteed]`:<br></p><p>    %x = load_strong [guaranteed] %x_ptr : $*Builtin.NativeObject<br>    ...<br>    fixLifetime(%x)<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br>    ...<br>    fixLifetime(%x)<br></p><p>`load_strong [guaranteed]` implies that in the region before the fixLifetime,<br>the loaded object is guaranteed semantically to remain alive. The fixLifetime<br>communicates to the optimizer the location up to which the value&#39;s lifetime is<br>guaranteed to live. An example of where this construct is useful is when one has<br>a let binding to a class instance `c` that contains a let field `f`. In that<br>case `c`&#39;s lifetime guarantees `f`&#39;s lifetime.<br></p><p>## store_strong<br></p><p>Define a store_strong as follows:<br></p><p>    store_strong %x to %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    %old_x = load %x_ptr : $*C<br>    store %new_x to %x_ptr : $*C<br>    release_value %old_x : $C<br></p><p>*NOTE* store_strong is defined as a consuming operation. We also provide<br>`store_strong [init]` in the case where we know statically that there is no<br>previous value in the memory location:<br></p><p>    store_strong %x to [init] %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    store %new_x to %x_ptr : $*C<br></p><p># Implementation<br></p><p>## Goals<br></p><p>Our implementation strategy goals are:<br></p><p>1. zero impact on other compiler developers until the feature is fully<br>   developed. This implies all work will be done behind a flag.<br>2. separation of feature implementation from updating passes.<br></p><p>Goal 2 will be implemented via a pass that blows up `load_strong`/`store_strong`<br>right after SILGen.<br></p><p>## Plan<br></p><p>We begin by adding initial infrastructure for our development. This means:<br></p><p>1. Adding to SILOptions a disabled by default flag called<br> &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br> option called &quot;-enable-sil-ownership-mode&quot;.<br></p><p>2. Bots will be brought up to test the compiler with<br>   &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br></p><p>   * RA-OSX+simulators<br>   * RA-Device<br>   * RA-Linux.<br></p><p>   The bots will run once a day until the feature is close to completion. Then a<br>   polling model will be followed.<br></p><p>Now that change isolation is guaranteed, we develop building blocks for the<br>optimization:<br></p><p>1. load_strong, store_strong will be added to SIL and IRGen, serialization,<br>printing, SIL parsing support will be implemented. SILGen will not be modified<br>at this stage.<br></p><p>2. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>(initially) blow up load_strong/store_strong instructions into their constituent<br>operations.<br></p><p>3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>the option is set, the verifier will assert if unsafe unowned loads, stores are<br>used to load from non-trivial memory locations.<br></p><p>Finally, we wire up the building blocks:<br></p><p>1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>   verification will be performed with EnforceSILOwnershipModel set to true.<br>2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>   the OwnershipModelEliminator pass right after SILGen before the normal pass<br>   pipeline starts.<br>3. SILGen will be changed to emit load_strong, store_strong instructions when<br>   the EnableSILOwnershipModel flag is set. We will use the verifier throwing to<br>   guarantee that we are not missing any specific cases.<br></p><p>Then once all fo the bots are green, we change SILOption.EnableSILOwnershipModel<br>to be true by default. After a cooling off period, we move all of the code<br>behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>reuse that flag for further SILOwnershipModel changes.<br></p><p>## Optimizer Changes<br></p><p>Since the SILOwnershipModel eliminator will eliminate the load_strong,<br>store_strong instructions right after ownership verification, there will be no<br>immediate affects on the optimizer and thus the optimizer changes can be done in<br>parallel with the rest of the ARC optimization work.<br></p><p>But, in the long run, we need IRGen to eliminate the load_strong, store_strong<br>instructions, not the SILOwnershipModel eliminator, so that we can enforce<br>Ownership invariants all through the SIL pipeline. Thus we will need to update<br>passes to handle these new instructions. The main optimizer changes can be<br>separated into the following areas: memory forwarding, dead stores, ARC<br>optimization. In all of these cases, the necessary changes are relatively<br>trivial to respond to. We give a quick taste of two of them: store-&gt;load<br>forwarding and ARC Code Motion.<br></p><p>### store-&gt;load forwarding<br></p><p>Currently we perform store-&gt;load forwarding as follows:<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    use(%x)<br></p><p>In a world, where we are using load_strong, store_strong, we have to also<br>consider the ownership implications. *NOTE* Since we are not modifying the<br>store_strong, `store_strong` and `store_strong [init]` are treated the<br>same. Thus without any loss of generality, lets consider solely `store_strong`.<br></p><p>    store_strong %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load_strong %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store_strong %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    strong_retain %x<br>    use(%x)<br></p><p>### ARC Code Motion<br></p><p>If ARC Code Motion wishes to move `load_strong`, `store_strong` instructions, it<br>must now consider read/write effects. On the other hand, it will be able to now<br>not consider the side-effects of destructors when moving retain/release<br>operations.<br></p><p>### Normal Code Motion<br></p><p>Normal code motion will lose some effectiveness since many of the load/store<br>operations that it used to be able to move now must consider ARC information. We<br>may need to consider running ARC code motion earlier in the pipeline where we<br>normally run Normal Code Motion to ensure that we are able to handle these<br>cases.<br></p><p>### ARC Optimization<br></p><p>The main implication for ARC optimization is that instead of eliminating just<br>retains, releases, it must be able to recognize `load_strong`, `store_strong`<br>and set their flags as appropriate.<br></p><p>### Function Signature Optimization<br></p><p>Semantic ARC affects function signature optimization in the context of the owned<br>to guaranteed optimization. Specifically:<br></p><p>1. A `store_strong` must be recognized as a release of the old value that is<br>   being overridden. In such a case, we can move the `release` of the old value<br>   into the caller and change the `store_strong` into a `store_strong<br>   [init]`.<br>2. A `load_strong` must be recognized as a retain in the callee. Then function<br>   signature optimization will transform the `load_strong` into a `load_strong<br>   [guaranteed]`. This would require the addition of a new `@guaranteed` return<br>   value convention.<br></p><p># Appendix<br></p><p>## Partial Initialization of Loadable References in SIL<br></p><p>In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>follows:<br></p><p>    %x = load %x_ptr : $*S<br>    ...<br>    retain_value %x_ptr : $S<br></p><p>At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>the partially initialized zone in between the load and the retain<br>operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>insert an instruction that causes x to be deallocated before the copy is<br>finished being initialized. Similar issues come up when trying to perform a<br>store of a non-trival value into a memory location.<br></p><p>Since this sort of partial initialization is allowed in SIL, the optimizer is<br>forced to be overly conservative when attempting to move releases passed retains<br>lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>two concrete examples that show how semantically providing load_strong,<br>store_strong instructions eliminate this problem.<br></p><p>**NOTE** Without any loss of generality, we will speak of values with reference<br>semantics instead of non-trivial values.<br></p><p>## Case Study: Partial Initialization and load_strong<br></p><p>### The Problem<br></p><p>Consider the following swift program:<br></p><p>    func opaque_call()<br></p><p>    final class C {<br>      var int: Int = 0<br>      deinit {<br>        opaque_call()<br>      }<br>    }<br></p><p>    final class D {<br>      var int: Int = 0<br>    }<br></p><p>    var GLOBAL_C : C? = nil<br>    var GLOBAL_D : D? = nil<br></p><p>    func useC(_ c: C)<br>    func useD(_ d: D)<br></p><p>    func run() {<br>        let c = C()<br>        GLOBAL_C = c<br>        let d = D()<br>        GLOBAL_D = d<br>        useC(c)<br>        useD(d)<br>    }<br></p><p>Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>`GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>known to the compiler to not have any affects on instances of type `D`, `C`<br>respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>valid SIL lowering for `run`:<br></p><p>    sil_global GLOBAL_D : $D<br>    sil_global GLOBAL_C : $C<br></p><p>    final class C {<br>      var x: Int<br>      deinit<br>    }<br></p><p>    final class D {<br>      var x: Int<br>    }<br></p><p>    sil @useC : $@convention(thin) () -&gt; ()<br>    sil @useD : $@convention(thin) () -&gt; ()<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load %global_c : $*C                                               (3)<br>      strong_retain %c2 : $C                                                   (4)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Lets optimize this function! First we perform the following operations:<br></p><p>1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>   can store to load forward `(1)` to `(3)`.<br>2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>   to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>   such information as an analysis and does not perform the actual load-&gt;store<br>   forwarding.<br>3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>   `(6)` so that `(4)` is right before `(7)`.<br></p><p>This yields (using the &#39; marker to designate that a register has had load-store<br>forwarding applied to it):<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Then by assumption, we know that `%useC` does not perform any releases of any<br>instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>analysis information that `%d2` and `%d` are th same due to the possibility of<br>performing store-&gt;load forwarding. After performing such transformations, `run`<br>looks as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Now by assumption, we know that `%useD_func` does not touch any instances of<br>class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>can be added. At first glance, this seems to suggest that we can move `(10)`<br>before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>optimization!<br></p><p>Lets think a bit more about this example and consider this example at the<br>language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>not allow for user level code to create dependencies from the body of the<br>destructor into the normal control flow that has called it. This means that<br>there are two valid results of this code:<br></p><p>- Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>  `%useD_func`.<br>- Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>   a different instance of `$D` is passed into `%useD_func`.<br></p><p>The fact that 1 occurs without optimization is just as a result of an<br>implementation detail of SILGen. 2 is also a valid sequence of operations.<br></p><p>Given that:<br></p><p>1. As a principle, the optimizer does not consider such dependencies to avoid<br>   being overly conservative.<br>2. We provide constructs to ensure appropriate lifetimes via the usage of<br>   constructs such as fix_lifetime.<br></p><p>We need to figure out how to express our optimization such that 2<br>happens. Remember that one of the optimizations that we performed at the<br>beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br></p><p>      %d = alloc_ref $D<br>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d = load %global_d_addr : $*D             (5)<br>      strong_retain %d : $D                      (6)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br></p><p>into:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d2 = load %global_d_addr : $*D             (5)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      strong_retain %d2 : $D                      (6)<br></p><p>This transformation in Swift corresponds to transforming:<br></p><p>      let d = GLOBAL_D<br>      useC(c)<br></p><p>to:<br></p><p>      let d_raw = load_d_value(GLOBAL_D)<br>      useC(c)<br>      let d = take_ownership_of_d(d_raw)<br></p><p>This is clearly an instance where we have moved a side-effect in between the<br>loading of the data and the taking ownership of such data, that is before the<br>`let` is fully initialized. What if instead of just moving the retain, we moved<br>the entire let statement? This would then result in the following swift code:<br></p><p>      useC(c)<br>      let d = GLOBAL_D<br></p><p>and would correspond to the following SIL snippet:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      %d2 = load %global_d_addr : $*D                                         (5)<br>      strong_retain %d2 : $D                                                  (6)<br></p><p>Moving the load with the strong_retain to ensure that the full initialization is<br>performed even after code motion causes our SIL to look as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Giving us the exact result that we want: Operation Sequence 2!<br></p><p>### Defining load_strong<br></p><p>Given that we wish the load, store to be tightly coupled together, it is natural<br>to express this operation as a `load_strong` instruction. Lets define the<br>`load_strong` instruction as follows:<br></p><p>    %1 = load_strong %0 : $*C<br></p><p>      =&gt;<br></p><p>    %1 = load %0 : $*C<br>    retain_value %1 : $C<br></p><p>Now lets transform our initial example to use this instruction:<br></p><p>Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load_strong %global_c : $*C                                        (3)<br>      %d2 = load_strong %global_d : $*D                                        (5)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then perform the previous code motion:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load_strong %global_c : $*C                                        (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>      strong_release %d : $D                                                   (9)<br></p><p>      %d2 = load_strong %global_d : $*D                                        (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>`(8)`. Can we still do so? One way we could do this is by introducing the<br>`[take]` flag. The `[take]` flag on a load_strong says that one is semantically<br>loading a value from a memory location and are taking ownership of the value<br>thus eliding the retain. In terms of SIL this flag is defined as:<br></p><p>    %x = load_strong [take] %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br></p><p>Why do we care about having such a `load_strong [take]` instruction when we<br>could just use a `load`? The reason why is that a normal `load` has unsafe<br>unowned ownership (i.e. it has no implications on ownership). We would like for<br>memory that has non-trivial type to only be able to be loaded via instructions<br>that maintain said ownership. We will allow for casting to trivial types as<br>usual to provide such access if it is required.<br></p><p>Thus we have achieved the desired result:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load_strong [take] %global_c : $*C                                 (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %d2 = load_strong [take] %global_d : $*D                                 (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>    }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160930/55692667/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt; <br>&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt; <br>&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; # Summary<br>&gt; <br>&gt; This document proposes:<br>&gt; <br>&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;    be used with memory locations of `non-trivial` type.<br></p><p>I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br></p><p>Brainstorming:<br></p><p>Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br></p><p>load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br></p><p>One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br></p><p>If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>  load [take] %0 : $*MyClass<br>  load [copy] %0 : $*MyClass<br>  load [trivial] %0 : $*Int<br></p><p>  store %0 to [initialization] %1 : $*MyClass<br>  store %0 to [assignment] %1 : $*MyClass<br>  store %0 to [trivial] %1 : $*Int<br></p><p>John.<br></p><p>&gt; 2. banning the use of `load`, `store` on values of `non-trivial` type.<br>&gt; <br>&gt; This will allow for:<br>&gt; <br>&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt; 2. modeling `load`/`store` as having `unsafe unowned` ownership semantics. This<br>&gt;    will be enforced via the verifier.<br>&gt; 3. more aggressive ARC code motion.<br>&gt; <br>&gt; # Definitions<br>&gt; <br>&gt; ## load_strong<br>&gt; <br>&gt; We propose three different forms of load_strong differentiated via flags. First<br>&gt; define `load_strong` as follows:<br>&gt; <br>&gt;     %x = load_strong %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt;     retain_value %x : $C<br>&gt; <br>&gt; Then define `load_strong [take]` as:<br>&gt; <br>&gt;     %x = load_strong [take] %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt; **NOTE** `load_strong [take]` implies that the loaded from memory location no<br>&gt; longer owns the result object (i.e. a take is a move). Loading from the memory<br>&gt; location again without reinitialization is illegal.<br>&gt; <br>&gt; Next we provide `load_strong [guaranteed]`:<br>&gt; <br>&gt;     %x = load_strong [guaranteed] %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     fixLifetime(%x)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     fixLifetime(%x)<br>&gt; <br>&gt; `load_strong [guaranteed]` implies that in the region before the fixLifetime,<br>&gt; the loaded object is guaranteed semantically to remain alive. The fixLifetime<br>&gt; communicates to the optimizer the location up to which the value&#39;s lifetime is<br>&gt; guaranteed to live. An example of where this construct is useful is when one has<br>&gt; a let binding to a class instance `c` that contains a let field `f`. In that<br>&gt; case `c`&#39;s lifetime guarantees `f`&#39;s lifetime.<br>&gt; <br>&gt; ## store_strong<br>&gt; <br>&gt; Define a store_strong as follows:<br>&gt; <br>&gt;     store_strong %x to %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     %old_x = load %x_ptr : $*C<br>&gt;     store %new_x to %x_ptr : $*C<br>&gt;     release_value %old_x : $C<br>&gt; <br>&gt; *NOTE* store_strong is defined as a consuming operation. We also provide<br>&gt; `store_strong [init]` in the case where we know statically that there is no<br>&gt; previous value in the memory location:<br>&gt; <br>&gt;     store_strong %x to [init] %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     store %new_x to %x_ptr : $*C<br>&gt; <br>&gt; # Implementation<br>&gt; <br>&gt; ## Goals<br>&gt; <br>&gt; Our implementation strategy goals are:<br>&gt; <br>&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;    developed. This implies all work will be done behind a flag.<br>&gt; 2. separation of feature implementation from updating passes.<br>&gt; <br>&gt; Goal 2 will be implemented via a pass that blows up `load_strong`/`store_strong`<br>&gt; right after SILGen.<br>&gt; <br>&gt; ## Plan<br>&gt; <br>&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt; <br>&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt; <br>&gt; 2. Bots will be brought up to test the compiler with<br>&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt; <br>&gt;    * RA-OSX+simulators<br>&gt;    * RA-Device<br>&gt;    * RA-Linux.<br>&gt; <br>&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;    polling model will be followed.<br>&gt; <br>&gt; Now that change isolation is guaranteed, we develop building blocks for the<br>&gt; optimization:<br>&gt; <br>&gt; 1. load_strong, store_strong will be added to SIL and IRGen, serialization,<br>&gt; printing, SIL parsing support will be implemented. SILGen will not be modified<br>&gt; at this stage.<br>&gt; <br>&gt; 2. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt; (initially) blow up load_strong/store_strong instructions into their constituent<br>&gt; operations.<br>&gt; <br>&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt; the option is set, the verifier will assert if unsafe unowned loads, stores are<br>&gt; used to load from non-trivial memory locations.<br>&gt; <br>&gt; Finally, we wire up the building blocks:<br>&gt; <br>&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;    pipeline starts.<br>&gt; 3. SILGen will be changed to emit load_strong, store_strong instructions when<br>&gt;    the EnableSILOwnershipModel flag is set. We will use the verifier throwing to<br>&gt;    guarantee that we are not missing any specific cases.<br>&gt; <br>&gt; Then once all fo the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt; <br>&gt; ## Optimizer Changes<br>&gt; <br>&gt; Since the SILOwnershipModel eliminator will eliminate the load_strong,<br>&gt; store_strong instructions right after ownership verification, there will be no<br>&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt; parallel with the rest of the ARC optimization work.<br>&gt; <br>&gt; But, in the long run, we need IRGen to eliminate the load_strong, store_strong<br>&gt; instructions, not the SILOwnershipModel eliminator, so that we can enforce<br>&gt; Ownership invariants all through the SIL pipeline. Thus we will need to update<br>&gt; passes to handle these new instructions. The main optimizer changes can be<br>&gt; separated into the following areas: memory forwarding, dead stores, ARC<br>&gt; optimization. In all of these cases, the necessary changes are relatively<br>&gt; trivial to respond to. We give a quick taste of two of them: store-&gt;load<br>&gt; forwarding and ARC Code Motion.<br>&gt; <br>&gt; ### store-&gt;load forwarding<br>&gt; <br>&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     use(%x)<br>&gt; <br>&gt; In a world, where we are using load_strong, store_strong, we have to also<br>&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt; store_strong, `store_strong` and `store_strong [init]` are treated the<br>&gt; same. Thus without any loss of generality, lets consider solely `store_strong`.<br>&gt; <br>&gt;     store_strong %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load_strong %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store_strong %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     strong_retain %x<br>&gt;     use(%x)<br>&gt; <br>&gt; ### ARC Code Motion<br>&gt; <br>&gt; If ARC Code Motion wishes to move `load_strong`, `store_strong` instructions, it<br>&gt; must now consider read/write effects. On the other hand, it will be able to now<br>&gt; not consider the side-effects of destructors when moving retain/release<br>&gt; operations.<br>&gt; <br>&gt; ### Normal Code Motion<br>&gt; <br>&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt; cases.<br>&gt; <br>&gt; ### ARC Optimization<br>&gt; <br>&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt; retains, releases, it must be able to recognize `load_strong`, `store_strong`<br>&gt; and set their flags as appropriate.<br>&gt; <br>&gt; ### Function Signature Optimization<br>&gt; <br>&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt; to guaranteed optimization. Specifically:<br>&gt; <br>&gt; 1. A `store_strong` must be recognized as a release of the old value that is<br>&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;    into the caller and change the `store_strong` into a `store_strong<br>&gt;    [init]`.<br>&gt; 2. A `load_strong` must be recognized as a retain in the callee. Then function<br>&gt;    signature optimization will transform the `load_strong` into a `load_strong<br>&gt;    [guaranteed]`. This would require the addition of a new `@guaranteed` return<br>&gt;    value convention.<br>&gt; <br>&gt; # Appendix<br>&gt; <br>&gt; ## Partial Initialization of Loadable References in SIL<br>&gt; <br>&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt; follows:<br>&gt; <br>&gt;     %x = load %x_ptr : $*S<br>&gt;     ...<br>&gt;     retain_value %x_ptr : $S<br>&gt; <br>&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt; the partially initialized zone in between the load and the retain<br>&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt; store of a non-trival value into a memory location.<br>&gt; <br>&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt; two concrete examples that show how semantically providing load_strong,<br>&gt; store_strong instructions eliminate this problem.<br>&gt; <br>&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt; semantics instead of non-trivial values.<br>&gt; <br>&gt; ## Case Study: Partial Initialization and load_strong<br>&gt; <br>&gt; ### The Problem<br>&gt; <br>&gt; Consider the following swift program:<br>&gt; <br>&gt;     func opaque_call()<br>&gt; <br>&gt;     final class C {<br>&gt;       var int: Int = 0<br>&gt;       deinit {<br>&gt;         opaque_call()<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var int: Int = 0<br>&gt;     }<br>&gt; <br>&gt;     var GLOBAL_C : C? = nil<br>&gt;     var GLOBAL_D : D? = nil<br>&gt; <br>&gt;     func useC(_ c: C)<br>&gt;     func useD(_ d: D)<br>&gt; <br>&gt;     func run() {<br>&gt;         let c = C()<br>&gt;         GLOBAL_C = c<br>&gt;         let d = D()<br>&gt;         GLOBAL_D = d<br>&gt;         useC(c)<br>&gt;         useD(d)<br>&gt;     }<br>&gt; <br>&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt; valid SIL lowering for `run`:<br>&gt; <br>&gt;     sil_global GLOBAL_D : $D<br>&gt;     sil_global GLOBAL_C : $C<br>&gt; <br>&gt;     final class C {<br>&gt;       var x: Int<br>&gt;       deinit<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var x: Int<br>&gt;     }<br>&gt; <br>&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Lets optimize this function! First we perform the following operations:<br>&gt; <br>&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;    can store to load forward `(1)` to `(3)`.<br>&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;    forwarding.<br>&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt; <br>&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt; forwarding applied to it):<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt; looks as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt; optimization!<br>&gt; <br>&gt; Lets think a bit more about this example and consider this example at the<br>&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt; not allow for user level code to create dependencies from the body of the<br>&gt; destructor into the normal control flow that has called it. This means that<br>&gt; there are two valid results of this code:<br>&gt; <br>&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;   `%useD_func`.<br>&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt; <br>&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt; <br>&gt; Given that:<br>&gt; <br>&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;    being overly conservative.<br>&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;    constructs such as fix_lifetime.<br>&gt; <br>&gt; We need to figure out how to express our optimization such that 2<br>&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;       strong_retain %d : $D                      (6)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt; <br>&gt; into:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       strong_retain %d2 : $D                      (6)<br>&gt; <br>&gt; This transformation in Swift corresponds to transforming:<br>&gt; <br>&gt;       let d = GLOBAL_D<br>&gt;       useC(c)<br>&gt; <br>&gt; to:<br>&gt; <br>&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;       useC(c)<br>&gt;       let d = take_ownership_of_d(d_raw)<br>&gt; <br>&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt; the entire let statement? This would then result in the following swift code:<br>&gt; <br>&gt;       useC(c)<br>&gt;       let d = GLOBAL_D<br>&gt; <br>&gt; and would correspond to the following SIL snippet:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt; <br>&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt; performed even after code motion causes our SIL to look as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt; <br>&gt; ### Defining load_strong<br>&gt; <br>&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt; to express this operation as a `load_strong` instruction. Lets define the<br>&gt; `load_strong` instruction as follows:<br>&gt; <br>&gt;     %1 = load_strong %0 : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %1 = load %0 : $*C<br>&gt;     retain_value %1 : $C<br>&gt; <br>&gt; Now lets transform our initial example to use this instruction:<br>&gt; <br>&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then perform the previous code motion:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;       strong_release %d : $D                                                   (9)<br>&gt; <br>&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt; `[take]` flag. The `[take]` flag on a load_strong says that one is semantically<br>&gt; loading a value from a memory location and are taking ownership of the value<br>&gt; thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt; <br>&gt;     %x = load_strong [take] %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt; <br>&gt; Why do we care about having such a `load_strong [take]` instruction when we<br>&gt; could just use a `load`? The reason why is that a normal `load` has unsafe<br>&gt; unowned ownership (i.e. it has no implications on ownership). We would like for<br>&gt; memory that has non-trivial type to only be able to be loaded via instructions<br>&gt; that maintain said ownership. We will allow for casting to trivial types as<br>&gt; usual to provide such access if it is required.<br>&gt; <br>&gt; Thus we have achieved the desired result:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load_strong [take] %global_c : $*C                                 (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %d2 = load_strong [take] %global_d : $*D                                 (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;     }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161004/06f16f8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt; <br>&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt; <br>&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt; <br>&gt;&gt; ----<br>&gt;&gt; <br>&gt;&gt; # Summary<br>&gt;&gt; <br>&gt;&gt; This document proposes:<br>&gt;&gt; <br>&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt; <br>&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt; <br>&gt; Brainstorming:<br>&gt; <br>&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt; <br>&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt; <br>&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt; <br>&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;   load [take] %0 : $*MyClass<br>&gt;   load [copy] %0 : $*MyClass<br>&gt;   load [trivial] %0 : $*Int<br>&gt; <br>&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;   store %0 to [trivial] %1 : $*Int<br>&gt; <br>&gt; John.<br></p><p>The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br></p><p>As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br></p><p>In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br></p><p>Does this sound reasonable:<br></p><p>1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br></p><p>Michael<br></p><p>&gt; <br>&gt;&gt; 2. banning the use of `load`, `store` on values of `non-trivial` type.<br>&gt;&gt; <br>&gt;&gt; This will allow for:<br>&gt;&gt; <br>&gt;&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt;&gt; 2. modeling `load`/`store` as having `unsafe unowned` ownership semantics. This<br>&gt;&gt;    will be enforced via the verifier.<br>&gt;&gt; 3. more aggressive ARC code motion.<br>&gt;&gt; <br>&gt;&gt; # Definitions<br>&gt;&gt; <br>&gt;&gt; ## load_strong<br>&gt;&gt; <br>&gt;&gt; We propose three different forms of load_strong differentiated via flags. First<br>&gt;&gt; define `load_strong` as follows:<br>&gt;&gt; <br>&gt;&gt;     %x = load_strong %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;     retain_value %x : $C<br>&gt;&gt; <br>&gt;&gt; Then define `load_strong [take]` as:<br>&gt;&gt; <br>&gt;&gt;     %x = load_strong [take] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt; <br>&gt;&gt; **NOTE** `load_strong [take]` implies that the loaded from memory location no<br>&gt;&gt; longer owns the result object (i.e. a take is a move). Loading from the memory<br>&gt;&gt; location again without reinitialization is illegal.<br>&gt;&gt; <br>&gt;&gt; Next we provide `load_strong [guaranteed]`:<br>&gt;&gt; <br>&gt;&gt;     %x = load_strong [guaranteed] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;     ...<br>&gt;&gt;     fixLifetime(%x)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;     ...<br>&gt;&gt;     fixLifetime(%x)<br>&gt;&gt; <br>&gt;&gt; `load_strong [guaranteed]` implies that in the region before the fixLifetime,<br>&gt;&gt; the loaded object is guaranteed semantically to remain alive. The fixLifetime<br>&gt;&gt; communicates to the optimizer the location up to which the value&#39;s lifetime is<br>&gt;&gt; guaranteed to live. An example of where this construct is useful is when one has<br>&gt;&gt; a let binding to a class instance `c` that contains a let field `f`. In that<br>&gt;&gt; case `c`&#39;s lifetime guarantees `f`&#39;s lifetime.<br>&gt;&gt; <br>&gt;&gt; ## store_strong<br>&gt;&gt; <br>&gt;&gt; Define a store_strong as follows:<br>&gt;&gt; <br>&gt;&gt;     store_strong %x to %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;        =&gt;<br>&gt;&gt; <br>&gt;&gt;     %old_x = load %x_ptr : $*C<br>&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;     release_value %old_x : $C<br>&gt;&gt; <br>&gt;&gt; *NOTE* store_strong is defined as a consuming operation. We also provide<br>&gt;&gt; `store_strong [init]` in the case where we know statically that there is no<br>&gt;&gt; previous value in the memory location:<br>&gt;&gt; <br>&gt;&gt;     store_strong %x to [init] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;        =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt; # Implementation<br>&gt;&gt; <br>&gt;&gt; ## Goals<br>&gt;&gt; <br>&gt;&gt; Our implementation strategy goals are:<br>&gt;&gt; <br>&gt;&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;&gt;    developed. This implies all work will be done behind a flag.<br>&gt;&gt; 2. separation of feature implementation from updating passes.<br>&gt;&gt; <br>&gt;&gt; Goal 2 will be implemented via a pass that blows up `load_strong`/`store_strong`<br>&gt;&gt; right after SILGen.<br>&gt;&gt; <br>&gt;&gt; ## Plan<br>&gt;&gt; <br>&gt;&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt;&gt; <br>&gt;&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt;&gt; <br>&gt;&gt; 2. Bots will be brought up to test the compiler with<br>&gt;&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt;&gt; <br>&gt;&gt;    * RA-OSX+simulators<br>&gt;&gt;    * RA-Device<br>&gt;&gt;    * RA-Linux.<br>&gt;&gt; <br>&gt;&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;&gt;    polling model will be followed.<br>&gt;&gt; <br>&gt;&gt; Now that change isolation is guaranteed, we develop building blocks for the<br>&gt;&gt; optimization:<br>&gt;&gt; <br>&gt;&gt; 1. load_strong, store_strong will be added to SIL and IRGen, serialization,<br>&gt;&gt; printing, SIL parsing support will be implemented. SILGen will not be modified<br>&gt;&gt; at this stage.<br>&gt;&gt; <br>&gt;&gt; 2. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;&gt; (initially) blow up load_strong/store_strong instructions into their constituent<br>&gt;&gt; operations.<br>&gt;&gt; <br>&gt;&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt;&gt; the option is set, the verifier will assert if unsafe unowned loads, stores are<br>&gt;&gt; used to load from non-trivial memory locations.<br>&gt;&gt; <br>&gt;&gt; Finally, we wire up the building blocks:<br>&gt;&gt; <br>&gt;&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt;&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;&gt;    pipeline starts.<br>&gt;&gt; 3. SILGen will be changed to emit load_strong, store_strong instructions when<br>&gt;&gt;    the EnableSILOwnershipModel flag is set. We will use the verifier throwing to<br>&gt;&gt;    guarantee that we are not missing any specific cases.<br>&gt;&gt; <br>&gt;&gt; Then once all fo the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt;&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt;&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt;&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt;&gt; <br>&gt;&gt; ## Optimizer Changes<br>&gt;&gt; <br>&gt;&gt; Since the SILOwnershipModel eliminator will eliminate the load_strong,<br>&gt;&gt; store_strong instructions right after ownership verification, there will be no<br>&gt;&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt;&gt; parallel with the rest of the ARC optimization work.<br>&gt;&gt; <br>&gt;&gt; But, in the long run, we need IRGen to eliminate the load_strong, store_strong<br>&gt;&gt; instructions, not the SILOwnershipModel eliminator, so that we can enforce<br>&gt;&gt; Ownership invariants all through the SIL pipeline. Thus we will need to update<br>&gt;&gt; passes to handle these new instructions. The main optimizer changes can be<br>&gt;&gt; separated into the following areas: memory forwarding, dead stores, ARC<br>&gt;&gt; optimization. In all of these cases, the necessary changes are relatively<br>&gt;&gt; trivial to respond to. We give a quick taste of two of them: store-&gt;load<br>&gt;&gt; forwarding and ARC Code Motion.<br>&gt;&gt; <br>&gt;&gt; ### store-&gt;load forwarding<br>&gt;&gt; <br>&gt;&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt;&gt; <br>&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     %y = load %x_ptr : $C<br>&gt;&gt;     use(%y)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     use(%x)<br>&gt;&gt; <br>&gt;&gt; In a world, where we are using load_strong, store_strong, we have to also<br>&gt;&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt;&gt; store_strong, `store_strong` and `store_strong [init]` are treated the<br>&gt;&gt; same. Thus without any loss of generality, lets consider solely `store_strong`.<br>&gt;&gt; <br>&gt;&gt;     store_strong %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     %y = load_strong %x_ptr : $C<br>&gt;&gt;     use(%y)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     store_strong %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     strong_retain %x<br>&gt;&gt;     use(%x)<br>&gt;&gt; <br>&gt;&gt; ### ARC Code Motion<br>&gt;&gt; <br>&gt;&gt; If ARC Code Motion wishes to move `load_strong`, `store_strong` instructions, it<br>&gt;&gt; must now consider read/write effects. On the other hand, it will be able to now<br>&gt;&gt; not consider the side-effects of destructors when moving retain/release<br>&gt;&gt; operations.<br>&gt;&gt; <br>&gt;&gt; ### Normal Code Motion<br>&gt;&gt; <br>&gt;&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt;&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt;&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt;&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt;&gt; cases.<br>&gt;&gt; <br>&gt;&gt; ### ARC Optimization<br>&gt;&gt; <br>&gt;&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt;&gt; retains, releases, it must be able to recognize `load_strong`, `store_strong`<br>&gt;&gt; and set their flags as appropriate.<br>&gt;&gt; <br>&gt;&gt; ### Function Signature Optimization<br>&gt;&gt; <br>&gt;&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt;&gt; to guaranteed optimization. Specifically:<br>&gt;&gt; <br>&gt;&gt; 1. A `store_strong` must be recognized as a release of the old value that is<br>&gt;&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;&gt;    into the caller and change the `store_strong` into a `store_strong<br>&gt;&gt;    [init]`.<br>&gt;&gt; 2. A `load_strong` must be recognized as a retain in the callee. Then function<br>&gt;&gt;    signature optimization will transform the `load_strong` into a `load_strong<br>&gt;&gt;    [guaranteed]`. This would require the addition of a new `@guaranteed` return<br>&gt;&gt;    value convention.<br>&gt;&gt; <br>&gt;&gt; # Appendix<br>&gt;&gt; <br>&gt;&gt; ## Partial Initialization of Loadable References in SIL<br>&gt;&gt; <br>&gt;&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt;&gt; follows:<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*S<br>&gt;&gt;     ...<br>&gt;&gt;     retain_value %x_ptr : $S<br>&gt;&gt; <br>&gt;&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt;&gt; the partially initialized zone in between the load and the retain<br>&gt;&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt;&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt;&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt;&gt; store of a non-trival value into a memory location.<br>&gt;&gt; <br>&gt;&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt;&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt;&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt;&gt; two concrete examples that show how semantically providing load_strong,<br>&gt;&gt; store_strong instructions eliminate this problem.<br>&gt;&gt; <br>&gt;&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt;&gt; semantics instead of non-trivial values.<br>&gt;&gt; <br>&gt;&gt; ## Case Study: Partial Initialization and load_strong<br>&gt;&gt; <br>&gt;&gt; ### The Problem<br>&gt;&gt; <br>&gt;&gt; Consider the following swift program:<br>&gt;&gt; <br>&gt;&gt;     func opaque_call()<br>&gt;&gt; <br>&gt;&gt;     final class C {<br>&gt;&gt;       var int: Int = 0<br>&gt;&gt;       deinit {<br>&gt;&gt;         opaque_call()<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     final class D {<br>&gt;&gt;       var int: Int = 0<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     var GLOBAL_C : C? = nil<br>&gt;&gt;     var GLOBAL_D : D? = nil<br>&gt;&gt; <br>&gt;&gt;     func useC(_ c: C)<br>&gt;&gt;     func useD(_ d: D)<br>&gt;&gt; <br>&gt;&gt;     func run() {<br>&gt;&gt;         let c = C()<br>&gt;&gt;         GLOBAL_C = c<br>&gt;&gt;         let d = D()<br>&gt;&gt;         GLOBAL_D = d<br>&gt;&gt;         useC(c)<br>&gt;&gt;         useD(d)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt;&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt;&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt;&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt;&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt;&gt; valid SIL lowering for `run`:<br>&gt;&gt; <br>&gt;&gt;     sil_global GLOBAL_D : $D<br>&gt;&gt;     sil_global GLOBAL_C : $C<br>&gt;&gt; <br>&gt;&gt;     final class C {<br>&gt;&gt;       var x: Int<br>&gt;&gt;       deinit<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     final class D {<br>&gt;&gt;       var x: Int<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Lets optimize this function! First we perform the following operations:<br>&gt;&gt; <br>&gt;&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;&gt;    can store to load forward `(1)` to `(3)`.<br>&gt;&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;&gt;    forwarding.<br>&gt;&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt;&gt; <br>&gt;&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt;&gt; forwarding applied to it):<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt;&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt;&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt;&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt;&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt;&gt; looks as follows:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt; <br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt;&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt;&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt;&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt;&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt;&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt;&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt;&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt;&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt;&gt; optimization!<br>&gt;&gt; <br>&gt;&gt; Lets think a bit more about this example and consider this example at the<br>&gt;&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt;&gt; not allow for user level code to create dependencies from the body of the<br>&gt;&gt; destructor into the normal control flow that has called it. This means that<br>&gt;&gt; there are two valid results of this code:<br>&gt;&gt; <br>&gt;&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;&gt;   `%useD_func`.<br>&gt;&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt;&gt; <br>&gt;&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt;&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt;&gt; <br>&gt;&gt; Given that:<br>&gt;&gt; <br>&gt;&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;&gt;    being overly conservative.<br>&gt;&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;&gt;    constructs such as fix_lifetime.<br>&gt;&gt; <br>&gt;&gt; We need to figure out how to express our optimization such that 2<br>&gt;&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt;&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;&gt;       strong_retain %d : $D                      (6)<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt; <br>&gt;&gt; into:<br>&gt;&gt; <br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;       strong_retain %d2 : $D                      (6)<br>&gt;&gt; <br>&gt;&gt; This transformation in Swift corresponds to transforming:<br>&gt;&gt; <br>&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;       useC(c)<br>&gt;&gt; <br>&gt;&gt; to:<br>&gt;&gt; <br>&gt;&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;&gt;       useC(c)<br>&gt;&gt;       let d = take_ownership_of_d(d_raw)<br>&gt;&gt; <br>&gt;&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt;&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt;&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt;&gt; the entire let statement? This would then result in the following swift code:<br>&gt;&gt; <br>&gt;&gt;       useC(c)<br>&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt; <br>&gt;&gt; and would correspond to the following SIL snippet:<br>&gt;&gt; <br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt;&gt; <br>&gt;&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt;&gt; performed even after code motion causes our SIL to look as follows:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt; <br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt;&gt; <br>&gt;&gt; ### Defining load_strong<br>&gt;&gt; <br>&gt;&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt;&gt; to express this operation as a `load_strong` instruction. Lets define the<br>&gt;&gt; `load_strong` instruction as follows:<br>&gt;&gt; <br>&gt;&gt;     %1 = load_strong %0 : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %1 = load %0 : $*C<br>&gt;&gt;     retain_value %1 : $C<br>&gt;&gt; <br>&gt;&gt; Now lets transform our initial example to use this instruction:<br>&gt;&gt; <br>&gt;&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; We then perform the previous code motion:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt;&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt;&gt; `[take]` flag. The `[take]` flag on a load_strong says that one is semantically<br>&gt;&gt; loading a value from a memory location and are taking ownership of the value<br>&gt;&gt; thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt;&gt; <br>&gt;&gt;     %x = load_strong [take] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt; Why do we care about having such a `load_strong [take]` instruction when we<br>&gt;&gt; could just use a `load`? The reason why is that a normal `load` has unsafe<br>&gt;&gt; unowned ownership (i.e. it has no implications on ownership). We would like for<br>&gt;&gt; memory that has non-trivial type to only be able to be loaded via instructions<br>&gt;&gt; that maintain said ownership. We will allow for casting to trivial types as<br>&gt;&gt; usual to provide such access if it is required.<br>&gt;&gt; <br>&gt;&gt; Thus we have achieved the desired result:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load_strong [take] %global_c : $*C                                 (3)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load_strong [take] %global_d : $*D                                 (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161005/2df88516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ----<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt; <br>&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt; <br>&gt;&gt; Brainstorming:<br>&gt;&gt; <br>&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt; <br>&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt; <br>&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt; <br>&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt; <br>&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt; <br>&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt; <br>&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt; <br>&gt; Does this sound reasonable:<br>&gt; <br>&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br></p><p>Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 2. banning the use of `load`, `store` on values of `non-trivial` type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will allow for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;&gt;&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;&gt;&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt;&gt;&gt; 2. modeling `load`/`store` as having `unsafe unowned` ownership semantics. This<br>&gt;&gt;&gt;    will be enforced via the verifier.<br>&gt;&gt;&gt; 3. more aggressive ARC code motion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Definitions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## load_strong<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose three different forms of load_strong differentiated via flags. First<br>&gt;&gt;&gt; define `load_strong` as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load_strong %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;&gt;     retain_value %x : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then define `load_strong [take]` as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load_strong [take] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **NOTE** `load_strong [take]` implies that the loaded from memory location no<br>&gt;&gt;&gt; longer owns the result object (i.e. a take is a move). Loading from the memory<br>&gt;&gt;&gt; location again without reinitialization is illegal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Next we provide `load_strong [guaranteed]`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load_strong [guaranteed] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     fixLifetime(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     fixLifetime(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `load_strong [guaranteed]` implies that in the region before the fixLifetime,<br>&gt;&gt;&gt; the loaded object is guaranteed semantically to remain alive. The fixLifetime<br>&gt;&gt;&gt; communicates to the optimizer the location up to which the value&#39;s lifetime is<br>&gt;&gt;&gt; guaranteed to live. An example of where this construct is useful is when one has<br>&gt;&gt;&gt; a let binding to a class instance `c` that contains a let field `f`. In that<br>&gt;&gt;&gt; case `c`&#39;s lifetime guarantees `f`&#39;s lifetime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## store_strong<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Define a store_strong as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store_strong %x to %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %old_x = load %x_ptr : $*C<br>&gt;&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;&gt;     release_value %old_x : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *NOTE* store_strong is defined as a consuming operation. We also provide<br>&gt;&gt;&gt; `store_strong [init]` in the case where we know statically that there is no<br>&gt;&gt;&gt; previous value in the memory location:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store_strong %x to [init] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Goals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our implementation strategy goals are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;&gt;&gt;    developed. This implies all work will be done behind a flag.<br>&gt;&gt;&gt; 2. separation of feature implementation from updating passes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Goal 2 will be implemented via a pass that blows up `load_strong`/`store_strong`<br>&gt;&gt;&gt; right after SILGen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Plan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;&gt;&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;&gt;&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Bots will be brought up to test the compiler with<br>&gt;&gt;&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * RA-OSX+simulators<br>&gt;&gt;&gt;    * RA-Device<br>&gt;&gt;&gt;    * RA-Linux.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;&gt;&gt;    polling model will be followed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that change isolation is guaranteed, we develop building blocks for the<br>&gt;&gt;&gt; optimization:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. load_strong, store_strong will be added to SIL and IRGen, serialization,<br>&gt;&gt;&gt; printing, SIL parsing support will be implemented. SILGen will not be modified<br>&gt;&gt;&gt; at this stage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;&gt;&gt; (initially) blow up load_strong/store_strong instructions into their constituent<br>&gt;&gt;&gt; operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt;&gt;&gt; the option is set, the verifier will assert if unsafe unowned loads, stores are<br>&gt;&gt;&gt; used to load from non-trivial memory locations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, we wire up the building blocks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;&gt;&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt;&gt;&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;&gt;&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;&gt;&gt;    pipeline starts.<br>&gt;&gt;&gt; 3. SILGen will be changed to emit load_strong, store_strong instructions when<br>&gt;&gt;&gt;    the EnableSILOwnershipModel flag is set. We will use the verifier throwing to<br>&gt;&gt;&gt;    guarantee that we are not missing any specific cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then once all fo the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt;&gt;&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt;&gt;&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt;&gt;&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Optimizer Changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the SILOwnershipModel eliminator will eliminate the load_strong,<br>&gt;&gt;&gt; store_strong instructions right after ownership verification, there will be no<br>&gt;&gt;&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt;&gt;&gt; parallel with the rest of the ARC optimization work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, in the long run, we need IRGen to eliminate the load_strong, store_strong<br>&gt;&gt;&gt; instructions, not the SILOwnershipModel eliminator, so that we can enforce<br>&gt;&gt;&gt; Ownership invariants all through the SIL pipeline. Thus we will need to update<br>&gt;&gt;&gt; passes to handle these new instructions. The main optimizer changes can be<br>&gt;&gt;&gt; separated into the following areas: memory forwarding, dead stores, ARC<br>&gt;&gt;&gt; optimization. In all of these cases, the necessary changes are relatively<br>&gt;&gt;&gt; trivial to respond to. We give a quick taste of two of them: store-&gt;load<br>&gt;&gt;&gt; forwarding and ARC Code Motion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### store-&gt;load forwarding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     %y = load %x_ptr : $C<br>&gt;&gt;&gt;     use(%y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     use(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a world, where we are using load_strong, store_strong, we have to also<br>&gt;&gt;&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt;&gt;&gt; store_strong, `store_strong` and `store_strong [init]` are treated the<br>&gt;&gt;&gt; same. Thus without any loss of generality, lets consider solely `store_strong`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store_strong %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     %y = load_strong %x_ptr : $C<br>&gt;&gt;&gt;     use(%y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store_strong %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     strong_retain %x<br>&gt;&gt;&gt;     use(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### ARC Code Motion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If ARC Code Motion wishes to move `load_strong`, `store_strong` instructions, it<br>&gt;&gt;&gt; must now consider read/write effects. On the other hand, it will be able to now<br>&gt;&gt;&gt; not consider the side-effects of destructors when moving retain/release<br>&gt;&gt;&gt; operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Normal Code Motion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt;&gt;&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt;&gt;&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt;&gt;&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt;&gt;&gt; cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### ARC Optimization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt;&gt;&gt; retains, releases, it must be able to recognize `load_strong`, `store_strong`<br>&gt;&gt;&gt; and set their flags as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Function Signature Optimization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt;&gt;&gt; to guaranteed optimization. Specifically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A `store_strong` must be recognized as a release of the old value that is<br>&gt;&gt;&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;&gt;&gt;    into the caller and change the `store_strong` into a `store_strong<br>&gt;&gt;&gt;    [init]`.<br>&gt;&gt;&gt; 2. A `load_strong` must be recognized as a retain in the callee. Then function<br>&gt;&gt;&gt;    signature optimization will transform the `load_strong` into a `load_strong<br>&gt;&gt;&gt;    [guaranteed]`. This would require the addition of a new `@guaranteed` return<br>&gt;&gt;&gt;    value convention.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Appendix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Partial Initialization of Loadable References in SIL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt;&gt;&gt; follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*S<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     retain_value %x_ptr : $S<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt;&gt;&gt; the partially initialized zone in between the load and the retain<br>&gt;&gt;&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt;&gt;&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt;&gt;&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt;&gt;&gt; store of a non-trival value into a memory location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt;&gt;&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt;&gt;&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt;&gt;&gt; two concrete examples that show how semantically providing load_strong,<br>&gt;&gt;&gt; store_strong instructions eliminate this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt;&gt;&gt; semantics instead of non-trivial values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Case Study: Partial Initialization and load_strong<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### The Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following swift program:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func opaque_call()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class C {<br>&gt;&gt;&gt;       var int: Int = 0<br>&gt;&gt;&gt;       deinit {<br>&gt;&gt;&gt;         opaque_call()<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class D {<br>&gt;&gt;&gt;       var int: Int = 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var GLOBAL_C : C? = nil<br>&gt;&gt;&gt;     var GLOBAL_D : D? = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func useC(_ c: C)<br>&gt;&gt;&gt;     func useD(_ d: D)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func run() {<br>&gt;&gt;&gt;         let c = C()<br>&gt;&gt;&gt;         GLOBAL_C = c<br>&gt;&gt;&gt;         let d = D()<br>&gt;&gt;&gt;         GLOBAL_D = d<br>&gt;&gt;&gt;         useC(c)<br>&gt;&gt;&gt;         useD(d)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt;&gt;&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt;&gt;&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt;&gt;&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt;&gt;&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt;&gt;&gt; valid SIL lowering for `run`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil_global GLOBAL_D : $D<br>&gt;&gt;&gt;     sil_global GLOBAL_C : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class C {<br>&gt;&gt;&gt;       var x: Int<br>&gt;&gt;&gt;       deinit<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class D {<br>&gt;&gt;&gt;       var x: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;&gt;&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;&gt;&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets optimize this function! First we perform the following operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;&gt;&gt;    can store to load forward `(1)` to `(3)`.<br>&gt;&gt;&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;&gt;&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;&gt;&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;&gt;&gt;    forwarding.<br>&gt;&gt;&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;&gt;&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt;&gt;&gt; forwarding applied to it):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt;&gt;&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt;&gt;&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt;&gt;&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt;&gt;&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt;&gt;&gt; looks as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt;&gt;&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt;&gt;&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt;&gt;&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt;&gt;&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt;&gt;&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt;&gt;&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt;&gt;&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt;&gt;&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt;&gt;&gt; optimization!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets think a bit more about this example and consider this example at the<br>&gt;&gt;&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt;&gt;&gt; not allow for user level code to create dependencies from the body of the<br>&gt;&gt;&gt; destructor into the normal control flow that has called it. This means that<br>&gt;&gt;&gt; there are two valid results of this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;&gt;&gt;   `%useD_func`.<br>&gt;&gt;&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;&gt;&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt;&gt;&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;&gt;&gt;    being overly conservative.<br>&gt;&gt;&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;&gt;&gt;    constructs such as fix_lifetime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We need to figure out how to express our optimization such that 2<br>&gt;&gt;&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt;&gt;&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;&gt;&gt;       strong_retain %d : $D                      (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                      (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This transformation in Swift corresponds to transforming:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt;       let d = take_ownership_of_d(d_raw)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt;&gt;&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt;&gt;&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt;&gt;&gt; the entire let statement? This would then result in the following swift code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and would correspond to the following SIL snippet:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt;&gt;&gt; performed even after code motion causes our SIL to look as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Defining load_strong<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt;&gt;&gt; to express this operation as a `load_strong` instruction. Lets define the<br>&gt;&gt;&gt; `load_strong` instruction as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %1 = load_strong %0 : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %1 = load %0 : $*C<br>&gt;&gt;&gt;     retain_value %1 : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now lets transform our initial example to use this instruction:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;&gt;&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We then perform the previous code motion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load_strong %global_c : $*C                                        (3)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load_strong %global_d : $*D                                        (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt;&gt;&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt;&gt;&gt; `[take]` flag. The `[take]` flag on a load_strong says that one is semantically<br>&gt;&gt;&gt; loading a value from a memory location and are taking ownership of the value<br>&gt;&gt;&gt; thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load_strong [take] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do we care about having such a `load_strong [take]` instruction when we<br>&gt;&gt;&gt; could just use a `load`? The reason why is that a normal `load` has unsafe<br>&gt;&gt;&gt; unowned ownership (i.e. it has no implications on ownership). We would like for<br>&gt;&gt;&gt; memory that has non-trivial type to only be able to be loaded via instructions<br>&gt;&gt;&gt; that maintain said ownership. We will allow for casting to trivial types as<br>&gt;&gt;&gt; usual to provide such access if it is required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus we have achieved the desired result:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load_strong [take] %global_c : $*C                                 (3)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load_strong [take] %global_d : $*D                                 (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161005/1239f269/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 5, 2016, at 4:48 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brainstorming:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt;&gt; <br>&gt;&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt;&gt; <br>&gt;&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt;&gt; <br>&gt;&gt; Does this sound reasonable:<br>&gt;&gt; <br>&gt;&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt;&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br>&gt; <br>&gt; Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br></p><p>That sounds great, thanks.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161006/583fc3fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  7, 2016 at 02:00:00pm</p></header><div class="content"><p>Attached below is an updated version of the proposal. Again a rendered version is located at:<br></p><p>https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html<br></p><p>Michael<br></p><p>----<br></p><p># Summary<br></p><p>This document proposes:<br></p><p>1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>   `[borrow]`, `[trivial]`.<br>2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>   `[trivial]`.<br>3. requiring all `load` and `store` operations to have ownership qualifiers.<br>4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>   `non-trivial` type.<br></p><p>This will allow for:<br></p><p>1. eliminating optimizer miscompiles that occur due to releases being moved into<br>   the region in between a `load`/`retain`, `load`/`release`,<br>   `store`/`release`. (For a specific example, see the appendix).<br>2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>   unowned` ownership semantics. This will be enforced via the verifier.<br>3. more aggressive ARC code motion.<br></p><p># Definitions<br></p><p>## ownership qualified load<br></p><p>We propose four different ownership qualifiers for load. Define `load [trivial]`<br>as:<br></p><p>    %x = load [trivial] %x_ptr : $*Int<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Int<br></p><p>A `load [trivial]` can not be used to load values of non-trivial type. Define<br>`load [copy]` as:<br></p><p>    %x = load [copy] %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br>    retain_value %x : $C<br></p><p>Then define `load [take]` as:<br></p><p>    %x = load [take] %x_ptr : $*Builtin.NativeObject<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br></p><p>**NOTE** `load [take]` implies that the loaded from memory location no longer<br>owns the result object (i.e. a take is a move). Loading from the memory location<br>again without reinitialization is illegal.<br></p><p>Next we provide `load [borrow]`:<br></p><p>    %x = load [borrow] %x_ptr : $*Builtin.NativeObject<br>    ...<br>    endBorrow(%x, %x_ptr)<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br>    ...<br>    endBorrow(%x, %x_ptr)<br></p><p>`load [borrow]` implies that in the region between the `load` and the<br>`endBorrow`, the loaded object must semantically remain alive. The `endBorrow`<br>communicates to the optimizer:<br></p><p>1. That the value in `%x_ptr` should not be destroyed before endBorrow.<br>2. Uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>   copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>   alive.<br></p><p>An example of where this construct is useful is when one has a let binding to a<br>class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>boundary is safe.<br></p><p>## ownership qualified store<br></p><p>First define a `store [trivial]` as:<br></p><p>    store %x to [trivial] %x_ptr : $*Int<br></p><p>      =&gt;<br></p><p>    store %x to %x_ptr : $*Int<br></p><p>The verifier will prevent this instruction from being used on types with<br>non-trivial ownership. Define a `store [assign]` as follows:<br></p><p>    store %x to [assign] %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    %old_x = load %x_ptr : $*C<br>    store %new_x to %x_ptr : $*C<br>    release_value %old_x : $C<br></p><p>*NOTE* `store` is defined as a consuming operation. We also provide<br>`store [init]` in the case where we know statically that there is no<br>previous value in the memory location:<br></p><p>    store %x to [init] %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    store %new_x to %x_ptr : $*C<br></p><p># Implementation<br></p><p>## Goals<br></p><p>Our implementation strategy goals are:<br></p><p>1. zero impact on other compiler developers until the feature is fully<br>   developed. This implies all work will be done behind a flag.<br>2. separation of feature implementation from updating passes.<br></p><p>Goal 2 will be implemented via a pass that transforms ownership qualified<br>`load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br></p><p>## Plan<br></p><p>We begin by adding initial infrastructure for our development. This means:<br></p><p>1. Adding to SILOptions a disabled by default flag called<br> &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br> option called &quot;-enable-sil-ownership-mode&quot;.<br></p><p>2. Bots will be brought up to test the compiler with<br>   &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br></p><p>   * RA-OSX+simulators<br>   * RA-Device<br>   * RA-Linux.<br></p><p>   The bots will run once a day until the feature is close to completion. Then a<br>   polling model will be followed.<br></p><p>Now that change isolation is borrow, we develop building blocks for the<br>optimization:<br></p><p>1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>   `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>   follows:<br></p><p>       enum class LoadOwnershipQualifier {<br>         Unqualified, Take, Copy, Borrow, Trivial<br>       };<br>       enum class StoreOwnershipQualifier {<br>         Unqualified, Init, Assign, Trivial<br>       };<br></p><p>    *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>    `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br></p><p>2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>`load`, `store` when parsed via textual SIL will be considered to be<br>unqualified. This implies that the rest of the compiler will not have to be<br>changed as a result of this step.<br></p><p>3. Support will be added to SIL, IRGen, Serialization, SILPrinting, and SIL<br>Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>stage.<br></p><p>4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>   blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>   into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>   insts.<br></p><p>3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>the option is set, the verifier will assert if:<br></p><p>   a. `load`, `store` operations with trivial ownership are applied to memory<br>      locations with non-trivial type.<br></p><p>   b. `load`, `store` operation with unqualified ownership type are present in<br>   the IR.<br></p><p>Finally, we wire up the building blocks:<br></p><p>1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>   verification will be performed with EnforceSILOwnershipModel set to true.<br>2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>   the OwnershipModelEliminator pass right after SILGen before the normal pass<br>   pipeline starts.<br>3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>   store instructions when the EnableSILOwnershipModel flag is set. We will use<br>   the verifier throwing to guarantee that we are not missing any specific<br>   cases.<br></p><p>Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>to be true by default. After a cooling off period, we move all of the code<br>behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>reuse that flag for further SILOwnershipModel changes.<br></p><p>## Optimizer Changes<br></p><p>Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>on load, store instructions right after ownership verification, there will be no<br>immediate affects on the optimizer and thus the optimizer changes can be done in<br>parallel with the rest of the ARC optimization work.<br></p><p>But, in the long run, we want to enforce these ownership invariants all<br>throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>eliminator. Thus we will need to update passes to handle these new<br>instructions. The main optimizer changes can be separated into the following<br>areas: memory forwarding, dead stores, ARC optimization. In all of these cases,<br>the necessary changes are relatively trivial to respond to. We give a quick<br>taste of two of them: store-&gt;load forwarding and ARC Code Motion.<br></p><p>### store-&gt;load forwarding<br></p><p>Currently we perform store-&gt;load forwarding as follows:<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    use(%x)<br></p><p>In a world, where we are using ownership qualified load, store, we have to also<br>consider the ownership implications. *NOTE* Since we are not modifying the<br>store, `store [assign]` and `store [init]` are treated the same. Thus without<br>any loss of generality, lets consider solely `store`.<br></p><p>    store %x to [assign] %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load [copy] %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store %x to [assign] %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    strong_retain %x<br>    use(%x)<br></p><p>### ARC Code Motion<br></p><p>If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>`load`, `store` instructions, it must now consider read/write effects. On the<br>other hand, it will be able to now not consider the side-effects of destructors<br>when moving retain/release operations.<br></p><p>### Normal Code Motion<br></p><p>Normal code motion will lose some effectiveness since many of the load/store<br>operations that it used to be able to move now must consider ARC information. We<br>may need to consider running ARC code motion earlier in the pipeline where we<br>normally run Normal Code Motion to ensure that we are able to handle these<br>cases.<br></p><p>### ARC Optimization<br></p><p>The main implication for ARC optimization is that instead of eliminating just<br>retains, releases, it must be able to recognize ownership qualified `load`,<br>`store` and set their flags as appropriate.<br></p><p>### Function Signature Optimization<br></p><p>Semantic ARC affects function signature optimization in the context of the owned<br>to borrow optimization. Specifically:<br></p><p>1. A `store [assign]` must be recognized as a release of the old value that is<br>   being overridden. In such a case, we can move the `release` of the old value<br>   into the caller and change the `store [assign]` into a `store [init]`.<br>2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>   signature optimization will transform the `load [copy]` into a `load<br>   [borrow]`. This would require the addition of a new `@borrow` return<br>   value convention.<br></p><p># Appendix<br></p><p>## Partial Initialization of Loadable References in SIL<br></p><p>In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>follows:<br></p><p>    %x = load %x_ptr : $*S<br>    ...<br>    retain_value %x_ptr : $S<br></p><p>At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>the partially initialized zone in between the load and the retain<br>operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>insert an instruction that causes x to be deallocated before the copy is<br>finished being initialized. Similar issues come up when trying to perform a<br>store of a non-trival value into a memory location.<br></p><p>Since this sort of partial initialization is allowed in SIL, the optimizer is<br>forced to be overly conservative when attempting to move releases passed retains<br>lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>two concrete examples that show how semantically providing ownership qualified<br>load, store instructions eliminate this problem.<br></p><p>**NOTE** Without any loss of generality, we will speak of values with reference<br>semantics instead of non-trivial values.<br></p><p>## Case Study: Partial Initialization and load [copy]<br></p><p>### The Problem<br></p><p>Consider the following swift program:<br></p><p>    func opaque_call()<br></p><p>    final class C {<br>      var int: Int = 0<br>      deinit {<br>        opaque_call()<br>      }<br>    }<br></p><p>    final class D {<br>      var int: Int = 0<br>    }<br></p><p>    var GLOBAL_C : C? = nil<br>    var GLOBAL_D : D? = nil<br></p><p>    func useC(_ c: C)<br>    func useD(_ d: D)<br></p><p>    func run() {<br>        let c = C()<br>        GLOBAL_C = c<br>        let d = D()<br>        GLOBAL_D = d<br>        useC(c)<br>        useD(d)<br>    }<br></p><p>Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>`GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>known to the compiler to not have any affects on instances of type `D`, `C`<br>respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>valid SIL lowering for `run`:<br></p><p>    sil_global GLOBAL_D : $D<br>    sil_global GLOBAL_C : $C<br></p><p>    final class C {<br>      var x: Int<br>      deinit<br>    }<br></p><p>    final class D {<br>      var x: Int<br>    }<br></p><p>    sil @useC : $@convention(thin) () -&gt; ()<br>    sil @useD : $@convention(thin) () -&gt; ()<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load %global_c : $*C                                               (3)<br>      strong_retain %c2 : $C                                                   (4)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Lets optimize this function! First we perform the following operations:<br></p><p>1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>   can store to load forward `(1)` to `(3)`.<br>2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>   to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>   such information as an analysis and does not perform the actual load-&gt;store<br>   forwarding.<br>3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>   `(6)` so that `(4)` is right before `(7)`.<br></p><p>This yields (using the &#39; marker to designate that a register has had load-store<br>forwarding applied to it):<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Then by assumption, we know that `%useC` does not perform any releases of any<br>instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>analysis information that `%d2` and `%d` are th same due to the possibility of<br>performing store-&gt;load forwarding. After performing such transformations, `run`<br>looks as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Now by assumption, we know that `%useD_func` does not touch any instances of<br>class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>can be added. At first glance, this seems to suggest that we can move `(10)`<br>before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>optimization!<br></p><p>Lets think a bit more about this example and consider this example at the<br>language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>not allow for user level code to create dependencies from the body of the<br>destructor into the normal control flow that has called it. This means that<br>there are two valid results of this code:<br></p><p>- Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>  `%useD_func`.<br>- Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>   a different instance of `$D` is passed into `%useD_func`.<br></p><p>The fact that 1 occurs without optimization is just as a result of an<br>implementation detail of SILGen. 2 is also a valid sequence of operations.<br></p><p>Given that:<br></p><p>1. As a principle, the optimizer does not consider such dependencies to avoid<br>   being overly conservative.<br>2. We provide constructs to ensure appropriate lifetimes via the usage of<br>   constructs such as fix_lifetime.<br></p><p>We need to figure out how to express our optimization such that 2<br>happens. Remember that one of the optimizations that we performed at the<br>beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br></p><p>      %d = alloc_ref $D<br>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d = load %global_d_addr : $*D             (5)<br>      strong_retain %d : $D                      (6)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br></p><p>into:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d2 = load %global_d_addr : $*D             (5)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      strong_retain %d2 : $D                      (6)<br></p><p>This transformation in Swift corresponds to transforming:<br></p><p>      let d = GLOBAL_D<br>      useC(c)<br></p><p>to:<br></p><p>      let d_raw = load_d_value(GLOBAL_D)<br>      useC(c)<br>      let d = take_ownership_of_d(d_raw)<br></p><p>This is clearly an instance where we have moved a side-effect in between the<br>loading of the data and the taking ownership of such data, that is before the<br>`let` is fully initialized. What if instead of just moving the retain, we moved<br>the entire let statement? This would then result in the following swift code:<br></p><p>      useC(c)<br>      let d = GLOBAL_D<br></p><p>and would correspond to the following SIL snippet:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      %d2 = load %global_d_addr : $*D                                         (5)<br>      strong_retain %d2 : $D                                                  (6)<br></p><p>Moving the load with the strong_retain to ensure that the full initialization is<br>performed even after code motion causes our SIL to look as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Giving us the exact result that we want: Operation Sequence 2!<br></p><p>### Defining load [copy]<br></p><p>Given that we wish the load, store to be tightly coupled together, it is natural<br>to express this operation as a `load [copy]` instruction. Lets define the `load<br>[copy]` instruction as follows:<br></p><p>    %1 = load [copy] %0 : $*C<br></p><p>      =&gt;<br></p><p>    %1 = load %0 : $*C<br>    retain_value %1 : $C<br></p><p>Now lets transform our initial example to use this instruction:<br></p><p>Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [copy] %global_c : $*C                                        (3)<br>      %d2 = load [copy] %global_d : $*D                                        (5)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then perform the previous code motion:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [copy] %global_c : $*C                                        (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>      strong_release %d : $D                                                   (9)<br></p><p>      %d2 = load [copy] %global_d : $*D                                        (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>`(8)`. Can we still do so? One way we could do this is by introducing the<br>`[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>semantically loading a value from a memory location and are taking ownership of<br>the value thus eliding the retain. In terms of SIL this flag is defined as:<br></p><p>    %x = load [take] %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br></p><p>Why do we care about having such a `load [take]` instruction when we could just<br>use a `load`? The reason why is that a normal `load` has unsafe unowned<br>ownership (i.e. it has no implications on ownership). We would like for memory<br>that has non-trivial type to only be able to be loaded via instructions that<br>maintain said ownership. We will allow for casting to trivial types as usual to<br>provide such access if it is required.<br></p><p>Thus we have achieved the desired result:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [take] %global_c : $*C                                        (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %d2 = load [take] %global_d : $*D                                        (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>    }<br></p><p><br>&gt; On Oct 6, 2016, at 3:03 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 5, 2016, at 4:48 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brainstorming:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this sound reasonable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt;&gt;&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br>&gt;&gt; <br>&gt;&gt; Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br>&gt; <br>&gt; That sounds great, thanks.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/e27c4441/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 2:38 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; Attached below is an updated version of the proposal. Again a rendered version is located at:<br>&gt; <br>&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt; <br>&gt; Michael<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; # Summary<br>&gt; <br>&gt; This document proposes:<br>&gt; <br>&gt; 1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>&gt;    `[borrow]`, `[trivial]`.<br>&gt; 2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>&gt;    `[trivial]`.<br>&gt; 3. requiring all `load` and `store` operations to have ownership qualifiers.<br>&gt; 4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>&gt;    `non-trivial` type.<br>&gt; <br>&gt; This will allow for:<br>&gt; <br>&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt; 2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>&gt;    unowned` ownership semantics. This will be enforced via the verifier.<br>&gt; 3. more aggressive ARC code motion.<br>&gt; <br>&gt; # Definitions<br>&gt; <br>&gt; ## ownership qualified load<br>&gt; <br>&gt; We propose four different ownership qualifiers for load. Define `load [trivial]`<br>&gt; as:<br>&gt; <br>&gt;     %x = load [trivial] %x_ptr : $*Int<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Int<br>&gt; <br>&gt; A `load [trivial]` can not be used to load values of non-trivial type.<br></p><p>Should we mandate the reverse as well, that e.g. load [copy] cannot be used to<br>load values of trivial type?  That&#39;s a little more work for substituting cloners, but it<br>keeps everything nice and canonical.<br></p><p>&gt; Define<br>&gt; `load [copy]` as:<br>&gt; <br>&gt;     %x = load [copy] %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt;     retain_value %x : $C<br>&gt; <br>&gt; Then define `load [take]` as:<br>&gt; <br>&gt;     %x = load [take] %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt; **NOTE** `load [take]` implies that the loaded from memory location no longer<br>&gt; owns the result object (i.e. a take is a move). Loading from the memory location<br>&gt; again without reinitialization is illegal.<br>&gt; <br>&gt; Next we provide `load [borrow]`:<br>&gt; <br>&gt;     %x = load [borrow] %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     endBorrow(%x, %x_ptr)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     endBorrow(%x, %x_ptr)<br>&gt; <br>&gt; `load [borrow]` implies that in the region between the `load` and the<br>&gt; `endBorrow`, the loaded object must semantically remain alive.<br></p><p>For consistency with other multi-word SIL instructions, this should be end_borrow.<br></p><p>I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>which returns a non-owned value, which will be a typing difference when we record<br>ownership in the type system.<br></p><p>Anyway, I really like that load [borrow] is scoped..  Are you planning to include the formation<br>restrictions on scopes instructions immediately, or will you do that in a later proposal?<br></p><p>The requirements we need from scopes are:<br>  - there has to be a well-defined set of IPs that lie within the scope and<br>  - there can&#39;t be a non-explicit transition into or out of the scope.<br></p><p>One way to get the first condition is to say that there has to be a unique scope-ender that<br>post-dominates the scope-beginner, but that&#39;s a pretty hard restriction for SILGen to satisfy<br>(as well as the optimizer, I imagine), and it doesn&#39;t handle &quot;unreachable&quot; or infinite loops.<br>We need to allow multiple scope-enders, and we need to allow scope-enders to be missing<br>in some cases.  Here&#39;s the right formalism, I think:<br></p><p>For all walks W beginning from the entry point of the function:<br>  For each node B in the CFG which is a scope-beginner:<br>    Let E be the set of scope-enders for B, and consider just the sub-sequence S of nodes<br>    of W where the node is a member of {B} U E.  Then the elements of S at even<br>    positions (starting from 0) must be B, and the elements at odd positions must be<br>    members of E.  Furthermore, if the walk ends in a return or throw instruction, then<br>    S must have even length.<br></p><p>Note that for this to be true, all the scope-enders must be dominated by the scope-beginner.<br></p><p>It is sufficient to just consider the set of &quot;beeline&quot; paths, i.e. acyclic paths ending in either a true<br>terminator (a return, throw, or unreachable) or an edge back to a node already in the path.<br>No such path may include multiple scope-enders for the same scope-beginner.  If the path ends<br>in a return or throw, it must include a matching scope-ender after every scope-beginner.  If<br>it ends in a loop back, then for every scope-beginner in the path, if the path contains a scope-ender<br>then the loop destination must either precede the scope-beginner or follow the scope-ender;<br>otherwise, the loop destination must follow the scope-beginner.<br></p><p>Or, as a decision algorithm in Swift for a single scope-beginner:<br></p><p>  var blockEntryIsInScope = [Block: Bool]()<br>  func scan(startingFrom inst: Instruction, isInScope: Bool) {<br>    if inst is ReturnInst || inst is ThrowInst {<br>      guard !isInScope else { invalid(&quot;ended function while in scope&quot;) }<br>      return<br>    }<br></p><p>    if let term = inst as? TerminatorInst {<br>      for successor in term.successors {<br>        guard begin.dominates(successor) else {<br>          guard !isInScope else { invalid(&quot;branch out of scope while in scope&quot;) }<br>          continue<br>        }<br>        if let cachedValue = blockEntryIsInScope[successor] {<br>          if cachedValue != isInScope {<br>            invalid(isInScope ? &quot;branch out of scope while in scope&quot; : &quot;branch into scope after exiting scope&quot;)<br>          }<br>        } else {<br>          blockEntryIsInScope[successor] = isInScope<br>          scan(startingFrom: successor.begin, isInScope: isInScope)<br>        }<br>      }<br>      return<br>    }<br></p><p>    if inst.endsScopeOf(begin) {<br>      guard isInScope else { invalid(&quot;ending scope that was already ended&quot;) }<br>      scan(startingFrom: inst.next, isInScope: false)<br>    } else {<br>      scan(startingFrom: inst.next, isInScope: isInScope)<br>    }<br>  }<br>  scan(startingFrom: begin, isInScope: true)<br></p><p>John.<br></p><p>&gt; The `endBorrow` communicates to the optimizer:<br>&gt; <br>&gt; 1. That the value in `%x_ptr` should not be destroyed before endBorrow.<br>&gt; 2. Uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>&gt;    copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>&gt;    alive.<br>&gt; <br>&gt; An example of where this construct is useful is when one has a let binding to a<br>&gt; class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>&gt; guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>&gt; boundary is safe.<br>&gt; <br>&gt; ## ownership qualified store<br>&gt; <br>&gt; First define a `store [trivial]` as:<br>&gt; <br>&gt;     store %x to [trivial] %x_ptr : $*Int<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to %x_ptr : $*Int<br>&gt; <br>&gt; The verifier will prevent this instruction from being used on types with<br>&gt; non-trivial ownership. Define a `store [assign]` as follows:<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     %old_x = load %x_ptr : $*C<br>&gt;     store %new_x to %x_ptr : $*C<br>&gt;     release_value %old_x : $C<br>&gt; <br>&gt; *NOTE* `store` is defined as a consuming operation. We also provide<br>&gt; `store [init]` in the case where we know statically that there is no<br>&gt; previous value in the memory location:<br>&gt; <br>&gt;     store %x to [init] %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     store %new_x to %x_ptr : $*C<br>&gt; <br>&gt; # Implementation<br>&gt; <br>&gt; ## Goals<br>&gt; <br>&gt; Our implementation strategy goals are:<br>&gt; <br>&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;    developed. This implies all work will be done behind a flag.<br>&gt; 2. separation of feature implementation from updating passes.<br>&gt; <br>&gt; Goal 2 will be implemented via a pass that transforms ownership qualified<br>&gt; `load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br>&gt; <br>&gt; ## Plan<br>&gt; <br>&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt; <br>&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt; <br>&gt; 2. Bots will be brought up to test the compiler with<br>&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt; <br>&gt;    * RA-OSX+simulators<br>&gt;    * RA-Device<br>&gt;    * RA-Linux.<br>&gt; <br>&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;    polling model will be followed.<br>&gt; <br>&gt; Now that change isolation is borrow, we develop building blocks for the<br>&gt; optimization:<br>&gt; <br>&gt; 1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>&gt;    `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>&gt;    follows:<br>&gt; <br>&gt;        enum class LoadOwnershipQualifier {<br>&gt;          Unqualified, Take, Copy, Borrow, Trivial<br>&gt;        };<br>&gt;        enum class StoreOwnershipQualifier {<br>&gt;          Unqualified, Init, Assign, Trivial<br>&gt;        };<br>&gt; <br>&gt;     *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>&gt;     `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br>&gt; <br>&gt; 2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>&gt; qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>&gt; `load`, `store` when parsed via textual SIL will be considered to be<br>&gt; unqualified. This implies that the rest of the compiler will not have to be<br>&gt; changed as a result of this step.<br>&gt; <br>&gt; 3. Support will be added to SIL, IRGen, Serialization, SILPrinting, and SIL<br>&gt; Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>&gt; stage.<br>&gt; <br>&gt; 4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;    blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>&gt;    into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>&gt;    insts.<br>&gt; <br>&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt; the option is set, the verifier will assert if:<br>&gt; <br>&gt;    a. `load`, `store` operations with trivial ownership are applied to memory<br>&gt;       locations with non-trivial type.<br>&gt; <br>&gt;    b. `load`, `store` operation with unqualified ownership type are present in<br>&gt;    the IR.<br>&gt; <br>&gt; Finally, we wire up the building blocks:<br>&gt; <br>&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;    pipeline starts.<br>&gt; 3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>&gt;    store instructions when the EnableSILOwnershipModel flag is set. We will use<br>&gt;    the verifier throwing to guarantee that we are not missing any specific<br>&gt;    cases.<br>&gt; <br>&gt; Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt; <br>&gt; ## Optimizer Changes<br>&gt; <br>&gt; Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>&gt; on load, store instructions right after ownership verification, there will be no<br>&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt; parallel with the rest of the ARC optimization work.<br>&gt; <br>&gt; But, in the long run, we want to enforce these ownership invariants all<br>&gt; throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>&gt; instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>&gt; eliminator. Thus we will need to update passes to handle these new<br>&gt; instructions. The main optimizer changes can be separated into the following<br>&gt; areas: memory forwarding, dead stores, ARC optimization. In all of these cases,<br>&gt; the necessary changes are relatively trivial to respond to. We give a quick<br>&gt; taste of two of them: store-&gt;load forwarding and ARC Code Motion.<br>&gt; <br>&gt; ### store-&gt;load forwarding<br>&gt; <br>&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     use(%x)<br>&gt; <br>&gt; In a world, where we are using ownership qualified load, store, we have to also<br>&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt; store, `store [assign]` and `store [init]` are treated the same. Thus without<br>&gt; any loss of generality, lets consider solely `store`.<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load [copy] %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     strong_retain %x<br>&gt;     use(%x)<br>&gt; <br>&gt; ### ARC Code Motion<br>&gt; <br>&gt; If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>&gt; `load`, `store` instructions, it must now consider read/write effects. On the<br>&gt; other hand, it will be able to now not consider the side-effects of destructors<br>&gt; when moving retain/release operations.<br>&gt; <br>&gt; ### Normal Code Motion<br>&gt; <br>&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt; cases.<br>&gt; <br>&gt; ### ARC Optimization<br>&gt; <br>&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt; retains, releases, it must be able to recognize ownership qualified `load`,<br>&gt; `store` and set their flags as appropriate.<br>&gt; <br>&gt; ### Function Signature Optimization<br>&gt; <br>&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt; to borrow optimization. Specifically:<br>&gt; <br>&gt; 1. A `store [assign]` must be recognized as a release of the old value that is<br>&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;    into the caller and change the `store [assign]` into a `store [init]`.<br>&gt; 2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>&gt;    signature optimization will transform the `load [copy]` into a `load<br>&gt;    [borrow]`. This would require the addition of a new `@borrow` return<br>&gt;    value convention.<br>&gt; <br>&gt; # Appendix<br>&gt; <br>&gt; ## Partial Initialization of Loadable References in SIL<br>&gt; <br>&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt; follows:<br>&gt; <br>&gt;     %x = load %x_ptr : $*S<br>&gt;     ...<br>&gt;     retain_value %x_ptr : $S<br>&gt; <br>&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt; the partially initialized zone in between the load and the retain<br>&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt; store of a non-trival value into a memory location.<br>&gt; <br>&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt; two concrete examples that show how semantically providing ownership qualified<br>&gt; load, store instructions eliminate this problem.<br>&gt; <br>&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt; semantics instead of non-trivial values.<br>&gt; <br>&gt; ## Case Study: Partial Initialization and load [copy]<br>&gt; <br>&gt; ### The Problem<br>&gt; <br>&gt; Consider the following swift program:<br>&gt; <br>&gt;     func opaque_call()<br>&gt; <br>&gt;     final class C {<br>&gt;       var int: Int = 0<br>&gt;       deinit {<br>&gt;         opaque_call()<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var int: Int = 0<br>&gt;     }<br>&gt; <br>&gt;     var GLOBAL_C : C? = nil<br>&gt;     var GLOBAL_D : D? = nil<br>&gt; <br>&gt;     func useC(_ c: C)<br>&gt;     func useD(_ d: D)<br>&gt; <br>&gt;     func run() {<br>&gt;         let c = C()<br>&gt;         GLOBAL_C = c<br>&gt;         let d = D()<br>&gt;         GLOBAL_D = d<br>&gt;         useC(c)<br>&gt;         useD(d)<br>&gt;     }<br>&gt; <br>&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt; valid SIL lowering for `run`:<br>&gt; <br>&gt;     sil_global GLOBAL_D : $D<br>&gt;     sil_global GLOBAL_C : $C<br>&gt; <br>&gt;     final class C {<br>&gt;       var x: Int<br>&gt;       deinit<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var x: Int<br>&gt;     }<br>&gt; <br>&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Lets optimize this function! First we perform the following operations:<br>&gt; <br>&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;    can store to load forward `(1)` to `(3)`.<br>&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;    forwarding.<br>&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt; <br>&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt; forwarding applied to it):<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt; looks as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt; optimization!<br>&gt; <br>&gt; Lets think a bit more about this example and consider this example at the<br>&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt; not allow for user level code to create dependencies from the body of the<br>&gt; destructor into the normal control flow that has called it. This means that<br>&gt; there are two valid results of this code:<br>&gt; <br>&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;   `%useD_func`.<br>&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt; <br>&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt; <br>&gt; Given that:<br>&gt; <br>&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;    being overly conservative.<br>&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;    constructs such as fix_lifetime.<br>&gt; <br>&gt; We need to figure out how to express our optimization such that 2<br>&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;       strong_retain %d : $D                      (6)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt; <br>&gt; into:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       strong_retain %d2 : $D                      (6)<br>&gt; <br>&gt; This transformation in Swift corresponds to transforming:<br>&gt; <br>&gt;       let d = GLOBAL_D<br>&gt;       useC(c)<br>&gt; <br>&gt; to:<br>&gt; <br>&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;       useC(c)<br>&gt;       let d = take_ownership_of_d(d_raw)<br>&gt; <br>&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt; the entire let statement? This would then result in the following swift code:<br>&gt; <br>&gt;       useC(c)<br>&gt;       let d = GLOBAL_D<br>&gt; <br>&gt; and would correspond to the following SIL snippet:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt; <br>&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt; performed even after code motion causes our SIL to look as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt; <br>&gt; ### Defining load [copy]<br>&gt; <br>&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt; to express this operation as a `load [copy]` instruction. Lets define the `load<br>&gt; [copy]` instruction as follows:<br>&gt; <br>&gt;     %1 = load [copy] %0 : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %1 = load %0 : $*C<br>&gt;     retain_value %1 : $C<br>&gt; <br>&gt; Now lets transform our initial example to use this instruction:<br>&gt; <br>&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then perform the previous code motion:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;       strong_release %d : $D                                                   (9)<br>&gt; <br>&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt; `[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>&gt; semantically loading a value from a memory location and are taking ownership of<br>&gt; the value thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt; <br>&gt;     %x = load [take] %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt; <br>&gt; Why do we care about having such a `load [take]` instruction when we could just<br>&gt; use a `load`? The reason why is that a normal `load` has unsafe unowned<br>&gt; ownership (i.e. it has no implications on ownership). We would like for memory<br>&gt; that has non-trivial type to only be able to be loaded via instructions that<br>&gt; maintain said ownership. We will allow for casting to trivial types as usual to<br>&gt; provide such access if it is required.<br>&gt; <br>&gt; Thus we have achieved the desired result:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [take] %global_c : $*C                                        (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %d2 = load [take] %global_d : $*D                                        (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;     }<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 6, 2016, at 3:03 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 5, 2016, at 4:48 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brainstorming:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;&gt;&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does this sound reasonable:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt;&gt;&gt;&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br>&gt;&gt; <br>&gt;&gt; That sounds great, thanks.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/792ca132/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 5:09 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 7, 2016, at 2:38 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Attached below is an updated version of the proposal. Again a rendered version is located at:<br>&gt;&gt; <br>&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt; ----<br>&gt;&gt; <br>&gt;&gt; # Summary<br>&gt;&gt; <br>&gt;&gt; This document proposes:<br>&gt;&gt; <br>&gt;&gt; 1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>&gt;&gt;    `[borrow]`, `[trivial]`.<br>&gt;&gt; 2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>&gt;&gt;    `[trivial]`.<br>&gt;&gt; 3. requiring all `load` and `store` operations to have ownership qualifiers.<br>&gt;&gt; 4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>&gt;&gt;    `non-trivial` type.<br>&gt;&gt; <br>&gt;&gt; This will allow for:<br>&gt;&gt; <br>&gt;&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt;&gt; 2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>&gt;&gt;    unowned` ownership semantics. This will be enforced via the verifier.<br>&gt;&gt; 3. more aggressive ARC code motion.<br>&gt;&gt; <br>&gt;&gt; # Definitions<br>&gt;&gt; <br>&gt;&gt; ## ownership qualified load<br>&gt;&gt; <br>&gt;&gt; We propose four different ownership qualifiers for load. Define `load [trivial]`<br>&gt;&gt; as:<br>&gt;&gt; <br>&gt;&gt;     %x = load [trivial] %x_ptr : $*Int<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*Int<br>&gt;&gt; <br>&gt;&gt; A `load [trivial]` can not be used to load values of non-trivial type.<br>&gt; <br>&gt; Should we mandate the reverse as well, that e.g. load [copy] cannot be used to<br>&gt; load values of trivial type?  That&#39;s a little more work for substituting cloners, but it<br>&gt; keeps everything nice and canonical.<br></p><p>No. I think that in the trivial case, load [copy] optimizes to load [trivial] as a canonicalization. This is just like applying a retain_value to a trivial type.<br></p><p>&gt; <br>&gt;&gt; Define<br>&gt;&gt; `load [copy]` as:<br>&gt;&gt; <br>&gt;&gt;     %x = load [copy] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;     retain_value %x : $C<br>&gt;&gt; <br>&gt;&gt; Then define `load [take]` as:<br>&gt;&gt; <br>&gt;&gt;     %x = load [take] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt; <br>&gt;&gt; **NOTE** `load [take]` implies that the loaded from memory location no longer<br>&gt;&gt; owns the result object (i.e. a take is a move). Loading from the memory location<br>&gt;&gt; again without reinitialization is illegal.<br>&gt;&gt; <br>&gt;&gt; Next we provide `load [borrow]`:<br>&gt;&gt; <br>&gt;&gt;     %x = load [borrow] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;     ...<br>&gt;&gt;     endBorrow(%x, %x_ptr)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;     ...<br>&gt;&gt;     endBorrow(%x, %x_ptr)<br>&gt;&gt; <br>&gt;&gt; `load [borrow]` implies that in the region between the `load` and the<br>&gt;&gt; `endBorrow`, the loaded object must semantically remain alive.<br>&gt; <br>&gt; For consistency with other multi-word SIL instructions, this should be end_borrow.<br></p><p>Sure.<br></p><p>&gt; <br>&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt; ownership in the type system.<br></p><p>I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br></p><p>&gt; <br>&gt; Anyway, I really like that load [borrow] is scoped..  Are you planning to include the formation<br>&gt; restrictions on scopes instructions immediately, or will you do that in a later proposal?<br></p><p>It will be done in a later proposal. We are just trying to set the stage for verification.<br></p><p>&gt; <br>&gt; The requirements we need from scopes are:<br>&gt;   - there has to be a well-defined set of IPs that lie within the scope and<br>&gt;   - there can&#39;t be a non-explicit transition into or out of the scope.<br>&gt; <br>&gt; One way to get the first condition is to say that there has to be a unique scope-ender that<br>&gt; post-dominates the scope-beginner, but that&#39;s a pretty hard restriction for SILGen to satisfy<br>&gt; (as well as the optimizer, I imagine), and it doesn&#39;t handle &quot;unreachable&quot; or infinite loops.<br>&gt; We need to allow multiple scope-enders, and we need to allow scope-enders to be missing<br>&gt; in some cases.<br></p><p>I agree with you here. We definitely want to be able to support multiple scope-enders.<br></p><p>&gt;  Here&#39;s the right formalism, I think:<br>&gt; <br>&gt; For all walks W beginning from the entry point of the function:<br>&gt;   For each node B in the CFG which is a scope-beginner:<br>&gt;     Let E be the set of scope-enders for B, and consider just the sub-sequence S of nodes<br>&gt;     of W where the node is a member of {B} U E.  Then the elements of S at even<br>&gt;     positions (starting from 0) must be B, and the elements at odd positions must be<br>&gt;     members of E.  Furthermore, if the walk ends in a return or throw instruction, then<br>&gt;     S must have even length.<br>&gt; <br>&gt; Note that for this to be true, all the scope-enders must be dominated by the scope-beginner.<br>&gt; <br>&gt; It is sufficient to just consider the set of &quot;beeline&quot; paths, i.e. acyclic paths ending in either a true<br>&gt; terminator (a return, throw, or unreachable) or an edge back to a node already in the path.<br>&gt; No such path may include multiple scope-enders for the same scope-beginner.  If the path ends<br>&gt; in a return or throw, it must include a matching scope-ender after every scope-beginner.  If<br>&gt; it ends in a loop back, then for every scope-beginner in the path, if the path contains a scope-ender<br>&gt; then the loop destination must either precede the scope-beginner or follow the scope-ender;<br>&gt; otherwise, the loop destination must follow the scope-beginner.<br>&gt; <br>&gt; Or, as a decision algorithm in Swift for a single scope-beginner:<br>&gt; <br>&gt;   var blockEntryIsInScope = [Block: Bool]()<br>&gt;   func scan(startingFrom inst: Instruction, isInScope: Bool) {<br>&gt;     if inst is ReturnInst || inst is ThrowInst {<br>&gt;       guard !isInScope else { invalid(&quot;ended function while in scope&quot;) }<br>&gt;       return<br>&gt;     }<br>&gt; <br>&gt;     if let term = inst as? TerminatorInst {<br>&gt;       for successor in term.successors {<br>&gt;         guard begin.dominates(successor) else {<br>&gt;           guard !isInScope else { invalid(&quot;branch out of scope while in scope&quot;) }<br>&gt;           continue<br>&gt;         }<br>&gt;         if let cachedValue = blockEntryIsInScope[successor] {<br>&gt;           if cachedValue != isInScope {<br>&gt;             invalid(isInScope ? &quot;branch out of scope while in scope&quot; : &quot;branch into scope after exiting scope&quot;)<br>&gt;           }<br>&gt;         } else {<br>&gt;           blockEntryIsInScope[successor] = isInScope<br>&gt;           scan(startingFrom: successor.begin, isInScope: isInScope)<br>&gt;         }<br>&gt;       }<br>&gt;       return<br>&gt;     }<br>&gt; <br>&gt;     if inst.endsScopeOf(begin) {<br>&gt;       guard isInScope else { invalid(&quot;ending scope that was already ended&quot;) }<br>&gt;       scan(startingFrom: inst.next, isInScope: false)<br>&gt;     } else {<br>&gt;       scan(startingFrom: inst.next, isInScope: isInScope)<br>&gt;     }<br>&gt;   }<br>&gt;   scan(startingFrom: begin, isInScope: true)<br></p><p>Since this is tangential to the current proposal, can we introduce a side thread?<br></p><p>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; The `endBorrow` communicates to the optimizer:<br>&gt;&gt; <br>&gt;&gt; 1. That the value in `%x_ptr` should not be destroyed before endBorrow.<br>&gt;&gt; 2. Uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>&gt;&gt;    copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>&gt;&gt;    alive.<br>&gt;&gt; <br>&gt;&gt; An example of where this construct is useful is when one has a let binding to a<br>&gt;&gt; class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>&gt;&gt; guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>&gt;&gt; boundary is safe.<br>&gt;&gt; <br>&gt;&gt; ## ownership qualified store<br>&gt;&gt; <br>&gt;&gt; First define a `store [trivial]` as:<br>&gt;&gt; <br>&gt;&gt;     store %x to [trivial] %x_ptr : $*Int<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %x to %x_ptr : $*Int<br>&gt;&gt; <br>&gt;&gt; The verifier will prevent this instruction from being used on types with<br>&gt;&gt; non-trivial ownership. Define a `store [assign]` as follows:<br>&gt;&gt; <br>&gt;&gt;     store %x to [assign] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;        =&gt;<br>&gt;&gt; <br>&gt;&gt;     %old_x = load %x_ptr : $*C<br>&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;     release_value %old_x : $C<br>&gt;&gt; <br>&gt;&gt; *NOTE* `store` is defined as a consuming operation. We also provide<br>&gt;&gt; `store [init]` in the case where we know statically that there is no<br>&gt;&gt; previous value in the memory location:<br>&gt;&gt; <br>&gt;&gt;     store %x to [init] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;        =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt; # Implementation<br>&gt;&gt; <br>&gt;&gt; ## Goals<br>&gt;&gt; <br>&gt;&gt; Our implementation strategy goals are:<br>&gt;&gt; <br>&gt;&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;&gt;    developed. This implies all work will be done behind a flag.<br>&gt;&gt; 2. separation of feature implementation from updating passes.<br>&gt;&gt; <br>&gt;&gt; Goal 2 will be implemented via a pass that transforms ownership qualified<br>&gt;&gt; `load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br>&gt;&gt; <br>&gt;&gt; ## Plan<br>&gt;&gt; <br>&gt;&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt;&gt; <br>&gt;&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt;&gt; <br>&gt;&gt; 2. Bots will be brought up to test the compiler with<br>&gt;&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt;&gt; <br>&gt;&gt;    * RA-OSX+simulators<br>&gt;&gt;    * RA-Device<br>&gt;&gt;    * RA-Linux.<br>&gt;&gt; <br>&gt;&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;&gt;    polling model will be followed.<br>&gt;&gt; <br>&gt;&gt; Now that change isolation is borrow, we develop building blocks for the<br>&gt;&gt; optimization:<br>&gt;&gt; <br>&gt;&gt; 1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>&gt;&gt;    `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>&gt;&gt;    follows:<br>&gt;&gt; <br>&gt;&gt;        enum class LoadOwnershipQualifier {<br>&gt;&gt;          Unqualified, Take, Copy, Borrow, Trivial<br>&gt;&gt;        };<br>&gt;&gt;        enum class StoreOwnershipQualifier {<br>&gt;&gt;          Unqualified, Init, Assign, Trivial<br>&gt;&gt;        };<br>&gt;&gt; <br>&gt;&gt;     *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>&gt;&gt;     `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br>&gt;&gt; <br>&gt;&gt; 2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>&gt;&gt; qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>&gt;&gt; `load`, `store` when parsed via textual SIL will be considered to be<br>&gt;&gt; unqualified. This implies that the rest of the compiler will not have to be<br>&gt;&gt; changed as a result of this step.<br>&gt;&gt; <br>&gt;&gt; 3. Support will be added to SIL, IRGen, Serialization, SILPrinting, and SIL<br>&gt;&gt; Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>&gt;&gt; stage.<br>&gt;&gt; <br>&gt;&gt; 4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;&gt;    blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>&gt;&gt;    into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>&gt;&gt;    insts.<br>&gt;&gt; <br>&gt;&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt;&gt; the option is set, the verifier will assert if:<br>&gt;&gt; <br>&gt;&gt;    a. `load`, `store` operations with trivial ownership are applied to memory<br>&gt;&gt;       locations with non-trivial type.<br>&gt;&gt; <br>&gt;&gt;    b. `load`, `store` operation with unqualified ownership type are present in<br>&gt;&gt;    the IR.<br>&gt;&gt; <br>&gt;&gt; Finally, we wire up the building blocks:<br>&gt;&gt; <br>&gt;&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt;&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;&gt;    pipeline starts.<br>&gt;&gt; 3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>&gt;&gt;    store instructions when the EnableSILOwnershipModel flag is set. We will use<br>&gt;&gt;    the verifier throwing to guarantee that we are not missing any specific<br>&gt;&gt;    cases.<br>&gt;&gt; <br>&gt;&gt; Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt;&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt;&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt;&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt;&gt; <br>&gt;&gt; ## Optimizer Changes<br>&gt;&gt; <br>&gt;&gt; Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>&gt;&gt; on load, store instructions right after ownership verification, there will be no<br>&gt;&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt;&gt; parallel with the rest of the ARC optimization work.<br>&gt;&gt; <br>&gt;&gt; But, in the long run, we want to enforce these ownership invariants all<br>&gt;&gt; throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>&gt;&gt; instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>&gt;&gt; eliminator. Thus we will need to update passes to handle these new<br>&gt;&gt; instructions. The main optimizer changes can be separated into the following<br>&gt;&gt; areas: memory forwarding, dead stores, ARC optimization. In all of these cases,<br>&gt;&gt; the necessary changes are relatively trivial to respond to. We give a quick<br>&gt;&gt; taste of two of them: store-&gt;load forwarding and ARC Code Motion.<br>&gt;&gt; <br>&gt;&gt; ### store-&gt;load forwarding<br>&gt;&gt; <br>&gt;&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt;&gt; <br>&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     %y = load %x_ptr : $C<br>&gt;&gt;     use(%y)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     use(%x)<br>&gt;&gt; <br>&gt;&gt; In a world, where we are using ownership qualified load, store, we have to also<br>&gt;&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt;&gt; store, `store [assign]` and `store [init]` are treated the same. Thus without<br>&gt;&gt; any loss of generality, lets consider solely `store`.<br>&gt;&gt; <br>&gt;&gt;     store %x to [assign] %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     %y = load [copy] %x_ptr : $C<br>&gt;&gt;     use(%y)<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     store %x to [assign] %x_ptr : $C<br>&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;     strong_retain %x<br>&gt;&gt;     use(%x)<br>&gt;&gt; <br>&gt;&gt; ### ARC Code Motion<br>&gt;&gt; <br>&gt;&gt; If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>&gt;&gt; `load`, `store` instructions, it must now consider read/write effects. On the<br>&gt;&gt; other hand, it will be able to now not consider the side-effects of destructors<br>&gt;&gt; when moving retain/release operations.<br>&gt;&gt; <br>&gt;&gt; ### Normal Code Motion<br>&gt;&gt; <br>&gt;&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt;&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt;&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt;&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt;&gt; cases.<br>&gt;&gt; <br>&gt;&gt; ### ARC Optimization<br>&gt;&gt; <br>&gt;&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt;&gt; retains, releases, it must be able to recognize ownership qualified `load`,<br>&gt;&gt; `store` and set their flags as appropriate.<br>&gt;&gt; <br>&gt;&gt; ### Function Signature Optimization<br>&gt;&gt; <br>&gt;&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt;&gt; to borrow optimization. Specifically:<br>&gt;&gt; <br>&gt;&gt; 1. A `store [assign]` must be recognized as a release of the old value that is<br>&gt;&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;&gt;    into the caller and change the `store [assign]` into a `store [init]`.<br>&gt;&gt; 2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>&gt;&gt;    signature optimization will transform the `load [copy]` into a `load<br>&gt;&gt;    [borrow]`. This would require the addition of a new `@borrow` return<br>&gt;&gt;    value convention.<br>&gt;&gt; <br>&gt;&gt; # Appendix<br>&gt;&gt; <br>&gt;&gt; ## Partial Initialization of Loadable References in SIL<br>&gt;&gt; <br>&gt;&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt;&gt; follows:<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*S<br>&gt;&gt;     ...<br>&gt;&gt;     retain_value %x_ptr : $S<br>&gt;&gt; <br>&gt;&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt;&gt; the partially initialized zone in between the load and the retain<br>&gt;&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt;&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt;&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt;&gt; store of a non-trival value into a memory location.<br>&gt;&gt; <br>&gt;&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt;&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt;&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt;&gt; two concrete examples that show how semantically providing ownership qualified<br>&gt;&gt; load, store instructions eliminate this problem.<br>&gt;&gt; <br>&gt;&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt;&gt; semantics instead of non-trivial values.<br>&gt;&gt; <br>&gt;&gt; ## Case Study: Partial Initialization and load [copy]<br>&gt;&gt; <br>&gt;&gt; ### The Problem<br>&gt;&gt; <br>&gt;&gt; Consider the following swift program:<br>&gt;&gt; <br>&gt;&gt;     func opaque_call()<br>&gt;&gt; <br>&gt;&gt;     final class C {<br>&gt;&gt;       var int: Int = 0<br>&gt;&gt;       deinit {<br>&gt;&gt;         opaque_call()<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     final class D {<br>&gt;&gt;       var int: Int = 0<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     var GLOBAL_C : C? = nil<br>&gt;&gt;     var GLOBAL_D : D? = nil<br>&gt;&gt; <br>&gt;&gt;     func useC(_ c: C)<br>&gt;&gt;     func useD(_ d: D)<br>&gt;&gt; <br>&gt;&gt;     func run() {<br>&gt;&gt;         let c = C()<br>&gt;&gt;         GLOBAL_C = c<br>&gt;&gt;         let d = D()<br>&gt;&gt;         GLOBAL_D = d<br>&gt;&gt;         useC(c)<br>&gt;&gt;         useD(d)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt;&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt;&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt;&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt;&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt;&gt; valid SIL lowering for `run`:<br>&gt;&gt; <br>&gt;&gt;     sil_global GLOBAL_D : $D<br>&gt;&gt;     sil_global GLOBAL_C : $C<br>&gt;&gt; <br>&gt;&gt;     final class C {<br>&gt;&gt;       var x: Int<br>&gt;&gt;       deinit<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     final class D {<br>&gt;&gt;       var x: Int<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Lets optimize this function! First we perform the following operations:<br>&gt;&gt; <br>&gt;&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;&gt;    can store to load forward `(1)` to `(3)`.<br>&gt;&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;&gt;    forwarding.<br>&gt;&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt;&gt; <br>&gt;&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt;&gt; forwarding applied to it):<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt;&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt;&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt;&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt;&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt;&gt; looks as follows:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt; <br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt;&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt;&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt;&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt;&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt;&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt;&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt;&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt;&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt;&gt; optimization!<br>&gt;&gt; <br>&gt;&gt; Lets think a bit more about this example and consider this example at the<br>&gt;&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt;&gt; not allow for user level code to create dependencies from the body of the<br>&gt;&gt; destructor into the normal control flow that has called it. This means that<br>&gt;&gt; there are two valid results of this code:<br>&gt;&gt; <br>&gt;&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;&gt;   `%useD_func`.<br>&gt;&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt;&gt; <br>&gt;&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt;&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt;&gt; <br>&gt;&gt; Given that:<br>&gt;&gt; <br>&gt;&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;&gt;    being overly conservative.<br>&gt;&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;&gt;    constructs such as fix_lifetime.<br>&gt;&gt; <br>&gt;&gt; We need to figure out how to express our optimization such that 2<br>&gt;&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt;&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;&gt;       strong_retain %d : $D                      (6)<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt; <br>&gt;&gt; into:<br>&gt;&gt; <br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;       strong_retain %d2 : $D                      (6)<br>&gt;&gt; <br>&gt;&gt; This transformation in Swift corresponds to transforming:<br>&gt;&gt; <br>&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;       useC(c)<br>&gt;&gt; <br>&gt;&gt; to:<br>&gt;&gt; <br>&gt;&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;&gt;       useC(c)<br>&gt;&gt;       let d = take_ownership_of_d(d_raw)<br>&gt;&gt; <br>&gt;&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt;&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt;&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt;&gt; the entire let statement? This would then result in the following swift code:<br>&gt;&gt; <br>&gt;&gt;       useC(c)<br>&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt; <br>&gt;&gt; and would correspond to the following SIL snippet:<br>&gt;&gt; <br>&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt; <br>&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt;&gt; <br>&gt;&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt;&gt; performed even after code motion causes our SIL to look as follows:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt; <br>&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt;&gt; <br>&gt;&gt; ### Defining load [copy]<br>&gt;&gt; <br>&gt;&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt;&gt; to express this operation as a `load [copy]` instruction. Lets define the `load<br>&gt;&gt; [copy]` instruction as follows:<br>&gt;&gt; <br>&gt;&gt;     %1 = load [copy] %0 : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %1 = load %0 : $*C<br>&gt;&gt;     retain_value %1 : $C<br>&gt;&gt; <br>&gt;&gt; Now lets transform our initial example to use this instruction:<br>&gt;&gt; <br>&gt;&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;&gt; <br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt; <br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; We then perform the previous code motion:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt;&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt;&gt; `[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>&gt;&gt; semantically loading a value from a memory location and are taking ownership of<br>&gt;&gt; the value thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt;&gt; <br>&gt;&gt;     %x = load [take] %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt;       =&gt;<br>&gt;&gt; <br>&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt; <br>&gt;&gt; Why do we care about having such a `load [take]` instruction when we could just<br>&gt;&gt; use a `load`? The reason why is that a normal `load` has unsafe unowned<br>&gt;&gt; ownership (i.e. it has no implications on ownership). We would like for memory<br>&gt;&gt; that has non-trivial type to only be able to be loaded via instructions that<br>&gt;&gt; maintain said ownership. We will allow for casting to trivial types as usual to<br>&gt;&gt; provide such access if it is required.<br>&gt;&gt; <br>&gt;&gt; Thus we have achieved the desired result:<br>&gt;&gt; <br>&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;     bb0:<br>&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt; <br>&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt; <br>&gt;&gt;       %c2 = load [take] %global_c : $*C                                        (3)<br>&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt; <br>&gt;&gt;       %d2 = load [take] %global_d : $*D                                        (5)<br>&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 6, 2016, at 3:03 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 5, 2016, at 4:48 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Brainstorming:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;&gt;&gt;&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does this sound reasonable:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt;&gt;&gt;&gt;&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That sounds great, thanks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/7b42dd80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; On Oct 7, 2016, at 5:09 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 7, 2016, at 2:38 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Attached below is an updated version of the proposal. Again a rendered version is located at:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ----<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>&gt;&gt;&gt;    `[borrow]`, `[trivial]`.<br>&gt;&gt;&gt; 2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>&gt;&gt;&gt;    `[trivial]`.<br>&gt;&gt;&gt; 3. requiring all `load` and `store` operations to have ownership qualifiers.<br>&gt;&gt;&gt; 4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>&gt;&gt;&gt;    `non-trivial` type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will allow for:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;&gt;&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;&gt;&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt;&gt;&gt; 2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>&gt;&gt;&gt;    unowned` ownership semantics. This will be enforced via the verifier.<br>&gt;&gt;&gt; 3. more aggressive ARC code motion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Definitions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## ownership qualified load<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose four different ownership qualifiers for load. Define `load [trivial]`<br>&gt;&gt;&gt; as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load [trivial] %x_ptr : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A `load [trivial]` can not be used to load values of non-trivial type.<br>&gt;&gt; <br>&gt;&gt; Should we mandate the reverse as well, that e.g. load [copy] cannot be used to<br>&gt;&gt; load values of trivial type?  That&#39;s a little more work for substituting cloners, but it<br>&gt;&gt; keeps everything nice and canonical.<br>&gt; <br>&gt; No. I think that in the trivial case, load [copy] optimizes to load [trivial] as a canonicalization. This is just like applying a retain_value to a trivial type.<br></p><p>I guess I&#39;m fine with that.<br></p><p>&gt;&gt;&gt; Define<br>&gt;&gt;&gt; `load [copy]` as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load [copy] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;&gt;     retain_value %x : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then define `load [take]` as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load [take] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **NOTE** `load [take]` implies that the loaded from memory location no longer<br>&gt;&gt;&gt; owns the result object (i.e. a take is a move). Loading from the memory location<br>&gt;&gt;&gt; again without reinitialization is illegal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Next we provide `load [borrow]`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load [borrow] %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     endBorrow(%x, %x_ptr)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     endBorrow(%x, %x_ptr)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `load [borrow]` implies that in the region between the `load` and the<br>&gt;&gt;&gt; `endBorrow`, the loaded object must semantically remain alive.<br>&gt;&gt; <br>&gt;&gt; For consistency with other multi-word SIL instructions, this should be end_borrow.<br>&gt; <br>&gt; Sure.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt; ownership in the type system.<br>&gt; <br>&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br></p><p>Yes, it&#39;s fine to introduce this incrementally.<br></p><p>We can discuss the formation rules on scopes concurrently.  I think the same theoretical<br>foundation is probably what we&#39;ll use for pseudo-linearity, memory-initialization soundness,<br>and so on.<br></p><p>John.<br></p><p>&gt;&gt; Anyway, I really like that load [borrow] is scoped..  Are you planning to include the formation<br>&gt;&gt; restrictions on scopes instructions immediately, or will you do that in a later proposal?<br>&gt; <br>&gt; It will be done in a later proposal. We are just trying to set the stage for verification.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The requirements we need from scopes are:<br>&gt;&gt;   - there has to be a well-defined set of IPs that lie within the scope and<br>&gt;&gt;   - there can&#39;t be a non-explicit transition into or out of the scope.<br>&gt;&gt; <br>&gt;&gt; One way to get the first condition is to say that there has to be a unique scope-ender that<br>&gt;&gt; post-dominates the scope-beginner, but that&#39;s a pretty hard restriction for SILGen to satisfy<br>&gt;&gt; (as well as the optimizer, I imagine), and it doesn&#39;t handle &quot;unreachable&quot; or infinite loops.<br>&gt;&gt; We need to allow multiple scope-enders, and we need to allow scope-enders to be missing<br>&gt;&gt; in some cases.<br>&gt; <br>&gt; I agree with you here. We definitely want to be able to support multiple scope-enders.<br>&gt; <br>&gt;&gt;  Here&#39;s the right formalism, I think:<br>&gt;&gt; <br>&gt;&gt; For all walks W beginning from the entry point of the function:<br>&gt;&gt;   For each node B in the CFG which is a scope-beginner:<br>&gt;&gt;     Let E be the set of scope-enders for B, and consider just the sub-sequence S of nodes<br>&gt;&gt;     of W where the node is a member of {B} U E.  Then the elements of S at even<br>&gt;&gt;     positions (starting from 0) must be B, and the elements at odd positions must be<br>&gt;&gt;     members of E.  Furthermore, if the walk ends in a return or throw instruction, then<br>&gt;&gt;     S must have even length.<br>&gt;&gt; <br>&gt;&gt; Note that for this to be true, all the scope-enders must be dominated by the scope-beginner.<br>&gt;&gt; <br>&gt;&gt; It is sufficient to just consider the set of &quot;beeline&quot; paths, i.e. acyclic paths ending in either a true<br>&gt;&gt; terminator (a return, throw, or unreachable) or an edge back to a node already in the path.<br>&gt;&gt; No such path may include multiple scope-enders for the same scope-beginner.  If the path ends<br>&gt;&gt; in a return or throw, it must include a matching scope-ender after every scope-beginner.  If<br>&gt;&gt; it ends in a loop back, then for every scope-beginner in the path, if the path contains a scope-ender<br>&gt;&gt; then the loop destination must either precede the scope-beginner or follow the scope-ender;<br>&gt;&gt; otherwise, the loop destination must follow the scope-beginner.<br>&gt;&gt; <br>&gt;&gt; Or, as a decision algorithm in Swift for a single scope-beginner:<br>&gt;&gt; <br>&gt;&gt;   var blockEntryIsInScope = [Block: Bool]()<br>&gt;&gt;   func scan(startingFrom inst: Instruction, isInScope: Bool) {<br>&gt;&gt;     if inst is ReturnInst || inst is ThrowInst {<br>&gt;&gt;       guard !isInScope else { invalid(&quot;ended function while in scope&quot;) }<br>&gt;&gt;       return<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if let term = inst as? TerminatorInst {<br>&gt;&gt;       for successor in term.successors {<br>&gt;&gt;         guard begin.dominates(successor) else {<br>&gt;&gt;           guard !isInScope else { invalid(&quot;branch out of scope while in scope&quot;) }<br>&gt;&gt;           continue<br>&gt;&gt;         }<br>&gt;&gt;         if let cachedValue = blockEntryIsInScope[successor] {<br>&gt;&gt;           if cachedValue != isInScope {<br>&gt;&gt;             invalid(isInScope ? &quot;branch out of scope while in scope&quot; : &quot;branch into scope after exiting scope&quot;)<br>&gt;&gt;           }<br>&gt;&gt;         } else {<br>&gt;&gt;           blockEntryIsInScope[successor] = isInScope<br>&gt;&gt;           scan(startingFrom: successor.begin, isInScope: isInScope)<br>&gt;&gt;         }<br>&gt;&gt;       }<br>&gt;&gt;       return<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if inst.endsScopeOf(begin) {<br>&gt;&gt;       guard isInScope else { invalid(&quot;ending scope that was already ended&quot;) }<br>&gt;&gt;       scan(startingFrom: inst.next, isInScope: false)<br>&gt;&gt;     } else {<br>&gt;&gt;       scan(startingFrom: inst.next, isInScope: isInScope)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;   scan(startingFrom: begin, isInScope: true)<br>&gt; <br>&gt; Since this is tangential to the current proposal, can we introduce a side thread?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; The `endBorrow` communicates to the optimizer:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. That the value in `%x_ptr` should not be destroyed before endBorrow.<br>&gt;&gt;&gt; 2. Uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>&gt;&gt;&gt;    copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>&gt;&gt;&gt;    alive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An example of where this construct is useful is when one has a let binding to a<br>&gt;&gt;&gt; class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>&gt;&gt;&gt; guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>&gt;&gt;&gt; boundary is safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## ownership qualified store<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First define a `store [trivial]` as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to [trivial] %x_ptr : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to %x_ptr : $*Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The verifier will prevent this instruction from being used on types with<br>&gt;&gt;&gt; non-trivial ownership. Define a `store [assign]` as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to [assign] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %old_x = load %x_ptr : $*C<br>&gt;&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;&gt;     release_value %old_x : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *NOTE* `store` is defined as a consuming operation. We also provide<br>&gt;&gt;&gt; `store [init]` in the case where we know statically that there is no<br>&gt;&gt;&gt; previous value in the memory location:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to [init] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %new_x to %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Goals<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our implementation strategy goals are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;&gt;&gt;    developed. This implies all work will be done behind a flag.<br>&gt;&gt;&gt; 2. separation of feature implementation from updating passes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Goal 2 will be implemented via a pass that transforms ownership qualified<br>&gt;&gt;&gt; `load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Plan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;&gt;&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;&gt;&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Bots will be brought up to test the compiler with<br>&gt;&gt;&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    * RA-OSX+simulators<br>&gt;&gt;&gt;    * RA-Device<br>&gt;&gt;&gt;    * RA-Linux.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;&gt;&gt;    polling model will be followed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that change isolation is borrow, we develop building blocks for the<br>&gt;&gt;&gt; optimization:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>&gt;&gt;&gt;    `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>&gt;&gt;&gt;    follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        enum class LoadOwnershipQualifier {<br>&gt;&gt;&gt;          Unqualified, Take, Copy, Borrow, Trivial<br>&gt;&gt;&gt;        };<br>&gt;&gt;&gt;        enum class StoreOwnershipQualifier {<br>&gt;&gt;&gt;          Unqualified, Init, Assign, Trivial<br>&gt;&gt;&gt;        };<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>&gt;&gt;&gt;     `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>&gt;&gt;&gt; qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>&gt;&gt;&gt; `load`, `store` when parsed via textual SIL will be considered to be<br>&gt;&gt;&gt; unqualified. This implies that the rest of the compiler will not have to be<br>&gt;&gt;&gt; changed as a result of this step.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Support will be added to SIL, IRGen, Serialization, SILPrinting, and SIL<br>&gt;&gt;&gt; Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>&gt;&gt;&gt; stage.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;&gt;&gt;    blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>&gt;&gt;&gt;    into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>&gt;&gt;&gt;    insts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt;&gt;&gt; the option is set, the verifier will assert if:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    a. `load`, `store` operations with trivial ownership are applied to memory<br>&gt;&gt;&gt;       locations with non-trivial type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    b. `load`, `store` operation with unqualified ownership type are present in<br>&gt;&gt;&gt;    the IR.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, we wire up the building blocks:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;&gt;&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt;&gt;&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;&gt;&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;&gt;&gt;    pipeline starts.<br>&gt;&gt;&gt; 3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>&gt;&gt;&gt;    store instructions when the EnableSILOwnershipModel flag is set. We will use<br>&gt;&gt;&gt;    the verifier throwing to guarantee that we are not missing any specific<br>&gt;&gt;&gt;    cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt;&gt;&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt;&gt;&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt;&gt;&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Optimizer Changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>&gt;&gt;&gt; on load, store instructions right after ownership verification, there will be no<br>&gt;&gt;&gt; immediate affects on the optimizer and thus the optimizer changes can be done in<br>&gt;&gt;&gt; parallel with the rest of the ARC optimization work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But, in the long run, we want to enforce these ownership invariants all<br>&gt;&gt;&gt; throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>&gt;&gt;&gt; instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>&gt;&gt;&gt; eliminator. Thus we will need to update passes to handle these new<br>&gt;&gt;&gt; instructions. The main optimizer changes can be separated into the following<br>&gt;&gt;&gt; areas: memory forwarding, dead stores, ARC optimization. In all of these cases,<br>&gt;&gt;&gt; the necessary changes are relatively trivial to respond to. We give a quick<br>&gt;&gt;&gt; taste of two of them: store-&gt;load forwarding and ARC Code Motion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### store-&gt;load forwarding<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     %y = load %x_ptr : $C<br>&gt;&gt;&gt;     use(%y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     use(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a world, where we are using ownership qualified load, store, we have to also<br>&gt;&gt;&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt;&gt;&gt; store, `store [assign]` and `store [init]` are treated the same. Thus without<br>&gt;&gt;&gt; any loss of generality, lets consider solely `store`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to [assign] %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     %y = load [copy] %x_ptr : $C<br>&gt;&gt;&gt;     use(%y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     store %x to [assign] %x_ptr : $C<br>&gt;&gt;&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;&gt;&gt;     strong_retain %x<br>&gt;&gt;&gt;     use(%x)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### ARC Code Motion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>&gt;&gt;&gt; `load`, `store` instructions, it must now consider read/write effects. On the<br>&gt;&gt;&gt; other hand, it will be able to now not consider the side-effects of destructors<br>&gt;&gt;&gt; when moving retain/release operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Normal Code Motion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt;&gt;&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt;&gt;&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt;&gt;&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt;&gt;&gt; cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### ARC Optimization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt;&gt;&gt; retains, releases, it must be able to recognize ownership qualified `load`,<br>&gt;&gt;&gt; `store` and set their flags as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Function Signature Optimization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt;&gt;&gt; to borrow optimization. Specifically:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A `store [assign]` must be recognized as a release of the old value that is<br>&gt;&gt;&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;&gt;&gt;    into the caller and change the `store [assign]` into a `store [init]`.<br>&gt;&gt;&gt; 2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>&gt;&gt;&gt;    signature optimization will transform the `load [copy]` into a `load<br>&gt;&gt;&gt;    [borrow]`. This would require the addition of a new `@borrow` return<br>&gt;&gt;&gt;    value convention.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Appendix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Partial Initialization of Loadable References in SIL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt;&gt;&gt; follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*S<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;     retain_value %x_ptr : $S<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt;&gt;&gt; the partially initialized zone in between the load and the retain<br>&gt;&gt;&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt;&gt;&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt;&gt;&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt;&gt;&gt; store of a non-trival value into a memory location.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt;&gt;&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt;&gt;&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt;&gt;&gt; two concrete examples that show how semantically providing ownership qualified<br>&gt;&gt;&gt; load, store instructions eliminate this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt;&gt;&gt; semantics instead of non-trivial values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Case Study: Partial Initialization and load [copy]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### The Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following swift program:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func opaque_call()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class C {<br>&gt;&gt;&gt;       var int: Int = 0<br>&gt;&gt;&gt;       deinit {<br>&gt;&gt;&gt;         opaque_call()<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class D {<br>&gt;&gt;&gt;       var int: Int = 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var GLOBAL_C : C? = nil<br>&gt;&gt;&gt;     var GLOBAL_D : D? = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func useC(_ c: C)<br>&gt;&gt;&gt;     func useD(_ d: D)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func run() {<br>&gt;&gt;&gt;         let c = C()<br>&gt;&gt;&gt;         GLOBAL_C = c<br>&gt;&gt;&gt;         let d = D()<br>&gt;&gt;&gt;         GLOBAL_D = d<br>&gt;&gt;&gt;         useC(c)<br>&gt;&gt;&gt;         useD(d)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt;&gt;&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt;&gt;&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt;&gt;&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt;&gt;&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt;&gt;&gt; valid SIL lowering for `run`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil_global GLOBAL_D : $D<br>&gt;&gt;&gt;     sil_global GLOBAL_C : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class C {<br>&gt;&gt;&gt;       var x: Int<br>&gt;&gt;&gt;       deinit<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     final class D {<br>&gt;&gt;&gt;       var x: Int<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;&gt;&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;&gt;&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets optimize this function! First we perform the following operations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;&gt;&gt;    can store to load forward `(1)` to `(3)`.<br>&gt;&gt;&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;&gt;&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;&gt;&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;&gt;&gt;    forwarding.<br>&gt;&gt;&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;&gt;&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt;&gt;&gt; forwarding applied to it):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt;&gt;&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt;&gt;&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt;&gt;&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt;&gt;&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt;&gt;&gt; looks as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt;&gt;&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt;&gt;&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt;&gt;&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt;&gt;&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt;&gt;&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt;&gt;&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt;&gt;&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt;&gt;&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt;&gt;&gt; optimization!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets think a bit more about this example and consider this example at the<br>&gt;&gt;&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt;&gt;&gt; not allow for user level code to create dependencies from the body of the<br>&gt;&gt;&gt; destructor into the normal control flow that has called it. This means that<br>&gt;&gt;&gt; there are two valid results of this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;&gt;&gt;   `%useD_func`.<br>&gt;&gt;&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;&gt;&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt;&gt;&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;&gt;&gt;    being overly conservative.<br>&gt;&gt;&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;&gt;&gt;    constructs such as fix_lifetime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We need to figure out how to express our optimization such that 2<br>&gt;&gt;&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt;&gt;&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;&gt;&gt;       strong_retain %d : $D                      (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                      (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This transformation in Swift corresponds to transforming:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt;       let d = take_ownership_of_d(d_raw)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt;&gt;&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt;&gt;&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt;&gt;&gt; the entire let statement? This would then result in the following swift code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       useC(c)<br>&gt;&gt;&gt;       let d = GLOBAL_D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and would correspond to the following SIL snippet:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;&gt;&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;&gt;&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt;&gt;&gt; performed even after code motion causes our SIL to look as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Defining load [copy]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt;&gt;&gt; to express this operation as a `load [copy]` instruction. Lets define the `load<br>&gt;&gt;&gt; [copy]` instruction as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %1 = load [copy] %0 : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %1 = load %0 : $*C<br>&gt;&gt;&gt;     retain_value %1 : $C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now lets transform our initial example to use this instruction:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;&gt;&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We then perform the previous code motion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt;       strong_release %d : $D                                                   (9)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt;       strong_release %c : $C                                                   (10)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt;&gt;&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt;&gt;&gt; `[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>&gt;&gt;&gt; semantically loading a value from a memory location and are taking ownership of<br>&gt;&gt;&gt; the value thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load [take] %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     %x = load %x_ptr : $*C<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do we care about having such a `load [take]` instruction when we could just<br>&gt;&gt;&gt; use a `load`? The reason why is that a normal `load` has unsafe unowned<br>&gt;&gt;&gt; ownership (i.e. it has no implications on ownership). We would like for memory<br>&gt;&gt;&gt; that has non-trivial type to only be able to be loaded via instructions that<br>&gt;&gt;&gt; maintain said ownership. We will allow for casting to trivial types as usual to<br>&gt;&gt;&gt; provide such access if it is required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus we have achieved the desired result:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;&gt;&gt;     bb0:<br>&gt;&gt;&gt;       %c = alloc_ref $C<br>&gt;&gt;&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;&gt;&gt;       strong_retain %c : $C<br>&gt;&gt;&gt;       store %c to %global_c : $*C                                              (1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d = alloc_ref $D<br>&gt;&gt;&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;&gt;&gt;       strong_retain %d : $D<br>&gt;&gt;&gt;       store %d to %global_d : $*D                                              (2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %c2 = load [take] %global_c : $*C                                        (3)<br>&gt;&gt;&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;&gt;&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;       %d2 = load [take] %global_d : $*D                                        (5)<br>&gt;&gt;&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;&gt;&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 6, 2016, at 3:03 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 5, 2016, at 4:48 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 5, 2016, at 4:40 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 4, 2016, at 1:04 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sep 30, 2016, at 11:54 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The document attached below contains the first &quot;Semantic ARC&quot; mini proposal: the High Level ARC Memory Operations Proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; An html rendered version of this markdown document is available at the following URL:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ----<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; # Summary<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This document proposes:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. adding the `load_strong`, `store_strong` instructions to SIL. These can only<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    be used with memory locations of `non-trivial` type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would really like to avoid using the word &quot;strong&quot; here.  Under the current proposal, these instructions will be usable with arbitrary non-trivial types, not just primitive class references.  Even if you think of an aggregate that happens to contain one or more strong references as some sort of aggregate strong reference (which is questionable but not completely absurd), we already have loadable non-strong class references that this operation would be usable with, like native unowned references.  &quot;load_strong %0 : $*@sil_unowned T&quot; as an operation yielding a scalar &quot;@sil_unowned T&quot; is ridiculous, and it will only get more ridiculous when we eventually allow this operation to work with types that are currently address-only, like weak references.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brainstorming:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like load_copy and store_copy would be a bit unfortunate, since store_copy doesn&#39;t actually copy the source operand and we want to have a load_copy [take].<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; load_value and store_value seem excessively generic.  It&#39;s not like non-trivial types aren&#39;t values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One question that comes to mind: do we actually need new instructions here other than for staging purposes?  We don&#39;t actually need new instructions for pseudo-linear SIL to work; we just need to say that we only enforce pseudo-linearity for non-trivial types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we just want the instruction to be explicit about ownership so that we can easily distinguish these cases, we can make the rule always explicit, e.g.:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   load [take] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   load [copy] %0 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   load [trivial] %0 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [initialization] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [assignment] %1 : $*MyClass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   store %0 to [trivial] %1 : $*Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The reason why I originally suggested to go the load_strong route is that we already have load_weak, load_unowned instructions. If I could add a load_strong instruction, then it would make sense to assign an engineer to do a pass over all 3 of these instructions and combine them into 1 load instruction. That is, first transform into a form amenable for canonicalization and then canonicalize all at once.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As you pointed out, both load_unowned and load_weak involve representation changes in type (for instance the change of weak pointers to Optional&lt;T&gt;). Such a change would be against the &quot;spirit&quot; of a load instruction to perform such representation changes versus ownership changes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In terms of the properties that we actually want here, what is important is that we can verify that no non-trivially typed values are loaded in an unsafe unowned manner. That can be done also with ownership flags on load/store.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does this sound reasonable:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. We introduce two enums that define memory ownership changes, one for load and one for store. Both of these enums will contain a [trivial] ownership.<br>&gt;&gt;&gt;&gt;&gt;&gt; 2. We enforce in the verifier that non-trivial types must have a non-trivial ownership modifier on any memory operations that they are involved in.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry for not being explicit. I will not add new instructions, just modifiers. Assuming that this is agreeable to you, I am going to prepare a quick additional version of the proposal document.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That sounds great, thanks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/ae30cb48/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt; ownership in the type system.<br>&gt; <br>&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br></p><p>There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow? load [trivial] is an optimization, so that should follow a functionally complete implementation.  load [take] should definitely not exist until there’s some motivation.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/e4612de6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt; <br>&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt; <br>&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br></p><p>These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br></p><p>%0 = load [copy] %x_ptr<br></p><p>destroy_value %1<br></p><p>=&gt;<br></p><p>%0 = load [borrow] %x_ptr<br></p><p>borrow_end(%0, %x_ptr)<br></p><p>These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br></p><p>&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation.<br></p><p>Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br></p><p>&gt;  load [take] should definitely not exist until there’s some motivation.<br></p><p>If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br></p><p>Did I provide the motivation that you requested?<br></p><p>Michael<br></p><p>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/592b8ade/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:08 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt;&gt; <br>&gt;&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br>&gt; <br>&gt; These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br>&gt; <br>&gt; %0 = load [copy] %x_ptr<br>&gt; <br>&gt; destroy_value %1<br>&gt; <br>&gt; =&gt;<br>&gt; <br>&gt; %0 = load [borrow] %x_ptr<br>&gt; <br>&gt; borrow_end(%0, %x_ptr)<br>&gt; <br>&gt; These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br>&gt; <br>&gt;&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation. <br>&gt; <br>&gt; Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br>&gt; <br>&gt;&gt;  load [take] should definitely not exist until there’s some motivation.<br>&gt; <br>&gt; If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br>&gt; <br>&gt; Did I provide the motivation that you requested?<br></p><p>Yes. My general request is for each commit to be easy to review and the functionality obvious to test. I’m convinced we’ll eventually want the variants. Although I still want to understand better when we need to [take] values out of memory.<br></p><p>I also want to prove that my understanding of the model is accurate by seeing everything work with load [copy].<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/0f574d95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:26 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 10:08 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br>&gt;&gt; <br>&gt;&gt; These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br>&gt;&gt; <br>&gt;&gt; %0 = load [copy] %x_ptr<br>&gt;&gt; <br>&gt;&gt; destroy_value %1<br>&gt;&gt; <br>&gt;&gt; =&gt;<br>&gt;&gt; <br>&gt;&gt; %0 = load [borrow] %x_ptr<br>&gt;&gt; <br>&gt;&gt; borrow_end(%0, %x_ptr)<br>&gt;&gt; <br>&gt;&gt; These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br>&gt;&gt; <br>&gt;&gt;&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation. <br>&gt;&gt; <br>&gt;&gt; Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br>&gt;&gt; <br>&gt;&gt;&gt;  load [take] should definitely not exist until there’s some motivation.<br>&gt;&gt; <br>&gt;&gt; If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br>&gt;&gt; <br>&gt;&gt; Did I provide the motivation that you requested?<br>&gt; <br>&gt; Yes. My general request is for each commit to be easy to review and the functionality obvious to test. I’m convinced we’ll eventually want the variants. Although I still want to understand better when we need to [take] values out of memory.<br></p><p>Just as a quick example, the API for emitLoad in SILGenFunction:<br></p><p>  ManagedValue emitLoad(SILLocation loc, SILValue addr,<br>                        const TypeLowering &amp;rvalueTL,<br>                        SGFContext C, IsTake_t isTake,<br>                        bool isGuaranteedValid = false);<br></p><p>Notice the IsTake_t parameter. I see that code path used in several locations in SILGenFunction.<br></p><p>&gt; <br>&gt; I also want to prove that my understanding of the model is accurate by seeing everything work with load [copy].<br></p><p>I am fine doing everything initially with load [copy] (and when SILGen requires load [take]). The other things can wait until we need them. I just don&#39;t want to have to do another proposal at that point ; ).<br></p><p>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/bf139a34/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:36 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; On Oct 7, 2016, at 10:26 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 10:08 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt;&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt;&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt;&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; %0 = load [copy] %x_ptr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; destroy_value %1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; %0 = load [borrow] %x_ptr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; borrow_end(%0, %x_ptr)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  load [take] should definitely not exist until there’s some motivation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did I provide the motivation that you requested?<br>&gt;&gt; <br>&gt;&gt; Yes. My general request is for each commit to be easy to review and the functionality obvious to test. I’m convinced we’ll eventually want the variants. Although I still want to understand better when we need to [take] values out of memory.<br>&gt; <br>&gt; Just as a quick example, the API for emitLoad in SILGenFunction:<br>&gt; <br>&gt;   ManagedValue emitLoad(SILLocation loc, SILValue addr,<br>&gt;                         const TypeLowering &amp;rvalueTL,<br>&gt;                         SGFContext C, IsTake_t isTake,<br>&gt;                         bool isGuaranteedValid = false);<br>&gt; <br>&gt; Notice the IsTake_t parameter. I see that code path used in several locations in SILGenFunction.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I also want to prove that my understanding of the model is accurate by seeing everything work with load [copy].<br>&gt; <br>&gt; I am fine doing everything initially with load [copy] (and when SILGen requires load [take]). The other things can wait until we need them. I just don&#39;t want to have to do another proposal at that point ; ).<br></p><p>Well, you might as well *implement* load [trivial] now.  It&#39;s literally going to be, like, five lines in various switch statements plus an obvious case in the verifier.  You can incrementally move things over to actually start *using* load [trivial] whenever you like.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/4af5f5eb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:36 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 7, 2016, at 10:26 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 10:08 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt;&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt;&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt;&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; %0 = load [copy] %x_ptr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; destroy_value %1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; =&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; %0 = load [borrow] %x_ptr<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; borrow_end(%0, %x_ptr)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  load [take] should definitely not exist until there’s some motivation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did I provide the motivation that you requested?<br>&gt;&gt; <br>&gt;&gt; Yes. My general request is for each commit to be easy to review and the functionality obvious to test. I’m convinced we’ll eventually want the variants. Although I still want to understand better when we need to [take] values out of memory.<br>&gt; <br>&gt; Just as a quick example, the API for emitLoad in SILGenFunction:<br>&gt; <br>&gt;   ManagedValue emitLoad(SILLocation loc, SILValue addr,<br>&gt;                         const TypeLowering &amp;rvalueTL,<br>&gt;                         SGFContext C, IsTake_t isTake,<br>&gt;                         bool isGuaranteedValid = false);<br>&gt; <br>&gt; Notice the IsTake_t parameter. I see that code path used in several locations in SILGenFunction.<br></p><p>I guess it’s doing this to forward locals variables at their last use, avoiding a copy. Although probably not theoretically necessary, I guess it would be silly not to do this.<br>-Andy<br></p><p>&gt;&gt; <br>&gt;&gt; I also want to prove that my understanding of the model is accurate by seeing everything work with load [copy].<br>&gt; <br>&gt; I am fine doing everything initially with load [copy] (and when SILGen requires load [take]). The other things can wait until we need them. I just don&#39;t want to have to do another proposal at that point ; ).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/a5b3f9f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 10:46 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; On Oct 7, 2016, at 10:36 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 7, 2016, at 10:26 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 7, 2016, at 10:08 PM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 9:25 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 7, 2016, at 6:04 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder whether it might make more sense for load [borrow] to be a different instruction.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s a couple reasons for that first.  The first is that it&#39;s the only load which introduces<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a scope, which is a really big difference structurally.  The second is that it&#39;s the only load<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which returns a non-owned value, which will be a typing difference when we record<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ownership in the type system.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am fine with a load_borrow. If this is the only change left that you want can I just send out a proposal with that small change and start implementing. I am nervous about perfection being the enemy of the good (and I want to start implementing this weekend if possible *evil smile*).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There’s a lot in the proposal that makes sense to discuss for completeness but isn’t motivated by a particular need. Please separate functionality. We only need load [copy] at first right? When do those need to be promoted to load_borrow?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These are needed for the ARC optimizer to eliminate retain, release operations, i.e. a:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; %0 = load [copy] %x_ptr<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; destroy_value %1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; =&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; %0 = load [borrow] %x_ptr<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; borrow_end(%0, %x_ptr)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These constructs will be needed by engineers to update passes like ARC. By implementing such modifiers now, we can begin to implement support in the various passes for these new instructions via sil-opt/etc in parallel to other semantic ARC work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; load [trivial] is an optimization, so that should follow a functionally complete implementation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes you are correct that given that we are exploding the load [copy] in the eliminator, the trivial load is not *strictly* needed. But as soon as we start upgrading passes, we are going to want this. Again assuming that parallel work can be done, it makes sense to set the stage for optimizer work that will occur in parallel to further semantic ARC work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  load [take] should definitely not exist until there’s some motivation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you look at the frontend, there are places where the frontend wants to emit a take. Unless we are willing to use unqualified loads for those cases (which we can not if we are trying to prove that no unqualified loads are emitted by the frontend), then we must have a load [take].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Did I provide the motivation that you requested?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. My general request is for each commit to be easy to review and the functionality obvious to test. I’m convinced we’ll eventually want the variants. Although I still want to understand better when we need to [take] values out of memory.<br>&gt;&gt; <br>&gt;&gt; Just as a quick example, the API for emitLoad in SILGenFunction:<br>&gt;&gt; <br>&gt;&gt;   ManagedValue emitLoad(SILLocation loc, SILValue addr,<br>&gt;&gt;                         const TypeLowering &amp;rvalueTL,<br>&gt;&gt;                         SGFContext C, IsTake_t isTake,<br>&gt;&gt;                         bool isGuaranteedValid = false);<br>&gt;&gt; <br>&gt;&gt; Notice the IsTake_t parameter. I see that code path used in several locations in SILGenFunction.<br>&gt; <br>&gt; I guess it’s doing this to forward locals variables at their last use, avoiding a copy. Although probably not theoretically necessary, I guess it would be silly not to do this.<br></p><p>Values, not variables.  SILGen can&#39;t do that kind of optimization on a local &quot;let&quot; or &quot;var&quot; because it&#39;s intentionally statement-by-statement.  It also can&#39;t do that kind of optimization on a &quot;var&quot; because, for all it knows, the variable might have escaped and thus not really have a statically-knowable last use; that&#39;s why SILGen emits them all as boxes and lets the mandatory optimizer promote them to the stack.  But there are several reasons why a local r-value might get emitted into memory and then need to get promoted to be a scalar, and of course we won&#39;t emit that as a copy.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161007/41fd27ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 2:38 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Attached below is an updated version of the proposal. Again a rendered version is located at:<br>&gt; <br>&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt; <br>&gt; Michael<br></p><p>This looks great Michael, a couple of comments/questions:<br></p><p>typo: affects -&gt; effects.<br></p><p><br>&gt;If ARC Code Motion wishes to move the ARC semantics of ownership qualified load, store instructions, it must now consider read/write effects. On the other hand, it will be able to now not consider the side-effects of destructors when moving retain/release operations.<br></p><p>Can you elaborate on what you mean by this?  Does this mean the ARC optimizer has additional freedom somehow to ignore side effects in deinits?  What grants that ability?<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161010/ec01101a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 8:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 7, 2016, at 2:38 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Attached below is an updated version of the proposal. Again a rendered version is located at:<br>&gt;&gt; <br>&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt; <br>&gt; This looks great Michael, a couple of comments/questions:<br>&gt; <br>&gt; typo: affects -&gt; effects.<br>&gt; <br>&gt; <br>&gt; &gt;If ARC Code Motion wishes to move the ARC semantics of ownership qualified load, store instructions, it must now consider read/write effects. On the other hand, it will be able to now not consider the side-effects of destructors when moving retain/release operations.<br>&gt; <br>&gt; Can you elaborate on what you mean by this?  Does this mean the ARC optimizer has additional freedom somehow to ignore side effects in deinits?  What grants that ability?<br></p><p>Sorry for not being clear.<br></p><p>deinits in ARC are not sequenced with respect to memory operations in normal control flow, but if ARC performs any code motion, we must ensure that memory safety is respected. Such semantics are not new.<br></p><p>The main change here is that previously there were situations where we would split up the load/retain in a load [copy] operation. Then if the right things occured, we could cause the object to be deallocated before we use the value or took full ownership of the value.<br></p><p>Consider the following example:<br></p><p>----<br>class D {}<br>class D1 : D {}<br>class D2 : D {}<br></p><p>var GLOBAL_D : D = D1()<br></p><p>class C { deinit { GLOBAL_D = D2 } }<br></p><p>func main() {<br>  let c = C()<br>  let d = GLOBAL_D<br>  useC(c)<br>  useD(d)<br>}<br></p><p>main()<br>----<br></p><p>Assume that useC does not directly in any way touch an instance of class D except via the destructor .<br></p><p>Since memory operations are not sequenced with respect to deinits, there are two correct programs here that the optimizer can produce: the original and the one where useC(c) and GLOBAL_D are swapped, i.e.:<br></p><p>----<br>func main() {<br>  let c = C()<br>  useC(c)<br>  let d = GLOBAL_D<br>  useD(d)<br>}<br>----<br></p><p>In the first program, d would be an instance of class D1. In the second, it would be an instance of class D2. Notice how in both programs though, no deinitialized object is accessed. On the other hand, imagine if we had split main like so:<br></p><p>----<br>func main() {<br>  let c = C()<br>  let d = unsafe_unowned_load(GLOBAL_D)<br>  useC(c)<br>  let owned_d = retain(d)<br>  useD(owned_d)<br>}<br>----<br></p><p>In this case, we would be passing off to useD a deallocated instance of class D1 which would be undefined behavior.<br></p><p>So as long as for these load [copy] operations, we move the load/retain fused together, we can guarantee that an object is produced instantaneously in a safe way without any worry.<br></p><p>Was this helpful?<br>Michael<br></p><p>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161011/b8f56178/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>On Oct 11, 2016, at 10:10 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; &gt;If ARC Code Motion wishes to move the ARC semantics of ownership qualified load, store instructions, it must now consider read/write effects. On the other hand, it will be able to now not consider the side-effects of destructors when moving retain/release operations.<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on what you mean by this?  Does this mean the ARC optimizer has additional freedom somehow to ignore side effects in deinits?  What grants that ability?<br>&gt; <br>&gt; Sorry for not being clear.<br>&gt; <br>&gt; deinits in ARC are not sequenced with respect to memory operations in normal control flow, but if ARC performs any code motion, we must ensure that memory safety is respected. Such semantics are not new.<br>&gt; <br>&gt; The main change here is that previously there were situations where we would split up the load/retain in a load [copy] operation. Then if the right things occured, we could cause the object to be deallocated before we use the value or took full ownership of the value.<br></p><p>Ah, I see what you mean.  Got it.<br></p><p>&gt; In this case, we would be passing off to useD a deallocated instance of class D1 which would be undefined behavior.<br>&gt; <br>&gt; So as long as for these load [copy] operations, we move the load/retain fused together, we can guarantee that an object is produced instantaneously in a safe way without any worry.<br>&gt; <br>&gt; Was this helpful?<br></p><p>Yep, totally.  The new approach is much more clear, thanks Michael!<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161011/042fee6a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Attached below is a final version of the proposal. I am going to commit it to the repo if there are no further questions/changes/etc.<br></p><p>&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>Michael<br></p><p>----<br></p><p># Summary<br></p><p>This document proposes:<br></p><p>1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>   `[trivial]`.<br>2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>   `[trivial]`.<br>3. adding the `load_borrow` instruction and the `end_borrow` instruction.<br>3. requiring all `load` and `store` operations to have ownership qualifiers.<br>4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>   `non-trivial` type.<br></p><p>This will allow for:<br></p><p>1. eliminating optimizer miscompiles that occur due to releases being moved into<br>   the region in between a `load`/`retain`, `load`/`release`,<br>   `store`/`release`. (For a specific example, see the appendix).<br>2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>   unowned` ownership semantics. This will be enforced via the verifier.<br>3. more aggressive ARC code motion.<br></p><p># Definitions<br></p><p>## ownership qualified load<br></p><p>We propose three different ownership qualifiers for load. Define `load [trivial]`<br>as:<br></p><p>    %x = load [trivial] %x_ptr : $*Int<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Int<br></p><p>A `load [trivial]` can not be used to load values of non-trivial type. Define<br>`load [copy]` as:<br></p><p>    %x = load [copy] %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br>    retain_value %x : $C<br></p><p>Then define `load [take]` as:<br></p><p>    %x = load [take] %x_ptr : $*Builtin.NativeObject<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br></p><p>**NOTE** `load [take]` implies that the loaded from memory location no longer<br>owns the result object (i.e. a take is a move). Loading from the memory location<br>again without reinitialization is illegal.<br></p><p>## load_borrow and end_borrow<br></p><p>Next we provide `load_borrow` and `end_borrow`:<br></p><p>    %x = load_borrow %x_ptr : $*Builtin.NativeObject<br>    ...<br>    end_borrow %x, %x_ptr : $*Builtin.NativeObject<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*Builtin.NativeObject<br>    ...<br>    endLifetime %x : $Builtin.NativeObject<br>    fixLifetime %x_ptr : $*Builtin.NativeObject<br></p><p>`load [borrow]` implies that in the region between the `load` and the<br>`end_borrow`, the loaded object must semantically remain alive. The `end_borrow`<br>communicates to the optimizer:<br></p><p>1. that the value in `%x_ptr` should not be destroyed before endBorrow.<br>2. uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>   copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>   alive.<br></p><p>An example of where this construct is useful is when one has a let binding to a<br>class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>boundary is safe.<br></p><p>*NOTE* since the SILOwnershipModelEliminator will not process these<br>instructions, endLifetime is just a strawman instruction that will not be<br>implemented. In practice though, IRGen will need to create a suitable barrier to<br>ensure that LLVM does not move any uses of `%x` past the `fixLifetime`<br>instruction of `%x_ptr` once we begin creating such instructions as a result of<br>ARC optimization.<br></p><p>## ownership qualified store<br></p><p>First define a `store [trivial]` as:<br></p><p>    store %x to [trivial] %x_ptr : $*Int<br></p><p>      =&gt;<br></p><p>    store %x to %x_ptr : $*Int<br></p><p>The verifier will prevent this instruction from being used on types with<br>non-trivial ownership. Define a `store [assign]` as follows:<br></p><p>    store %x to [assign] %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    %old_x = load %x_ptr : $*C<br>    store %new_x to %x_ptr : $*C<br>    release_value %old_x : $C<br></p><p>*NOTE* `store` is defined as a consuming operation. We also provide<br>`store [init]` in the case where we know statically that there is no<br>previous value in the memory location:<br></p><p>    store %x to [init] %x_ptr : $*C<br></p><p>       =&gt;<br></p><p>    store %new_x to %x_ptr : $*C<br></p><p># Implementation<br></p><p>## Goals<br></p><p>Our implementation strategy goals are:<br></p><p>1. zero impact on other compiler developers until the feature is fully<br>   developed. This implies all work will be done behind a flag.<br>2. separation of feature implementation from updating passes.<br></p><p>Goal 2 will be implemented via a pass that transforms ownership qualified<br>`load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br></p><p>## Plan<br></p><p>We begin by adding initial infrastructure for our development. This means:<br></p><p>1. Adding to SILOptions a disabled by default flag called<br> &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br> option called &quot;-enable-sil-ownership-mode&quot;.<br></p><p>2. Bots will be brought up to test the compiler with<br>   &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br></p><p>   * RA-OSX+simulators<br>   * RA-Device<br>   * RA-Linux.<br></p><p>   The bots will run once a day until the feature is close to completion. Then a<br>   polling model will be followed.<br></p><p>Now that change isolation is borrow, we develop building blocks for the<br>optimization:<br></p><p>1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>   `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>   follows:<br></p><p>       enum class LoadOwnershipQualifier {<br>         Unqualified, Take, Copy, Trivial<br>       };<br>       enum class StoreOwnershipQualifier {<br>         Unqualified, Init, Assign, Trivial<br>       };<br></p><p>    *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>    `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br></p><p>2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>`load`, `store` when parsed via textual SIL will be considered to be<br>unqualified. This implies that the rest of the compiler will not have to be<br>changed as a result of this step.<br></p><p>3. Support will be added to SIL, IRGen, Serialization, SIL Printing, and SIL<br>Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>stage.<br></p><p>4. The `load_borrow` and `end_borrow` instructions will be implemented in SIL,<br>   IRGen, Serialization, SIL Printing, and SIL Parsing. They will not be used<br>   immediately.<br></p><p>4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>   blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>   into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>   insts. It will not process `load_borrow` and `end_borrow` since currently it<br>   is not expected for SILGen to emit such instructions.<br></p><p>5. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>the option is set, the verifier will assert if:<br></p><p>   a. `load`, `store` operations with trivial ownership are applied to memory<br>      locations with non-trivial type.<br></p><p>   b. `load`, `store` operation with unqualified ownership type are present in<br>   the IR.<br></p><p>   c. `load_borrow` or `end_borrow` are present in the IR. This is because<br>   currently we do not support SIL containing such instructions in SIL<br>   Ownership Mode. Once we have the ability to verify borrowing scopes, this<br>   will no longer be the case, but this is a different proposal.<br></p><p>Finally, we wire up the building blocks:<br></p><p>1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>   verification will be performed with EnforceSILOwnershipModel set to true.<br>2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>   the OwnershipModelEliminator pass right after SILGen before the normal pass<br>   pipeline starts.<br>3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>   store instructions when the EnableSILOwnershipModel flag is set. We will use<br>   the verifier throwing to guarantee that we are not missing any specific<br>   cases.<br></p><p>Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>to be true by default. After a cooling off period, we move all of the code<br>behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>reuse that flag for further SILOwnershipModel changes.<br></p><p>## Optimizer Changes<br></p><p>Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>on load, store instructions right after ownership verification, there will be no<br>immediate effects on the optimizer and thus the optimizer changes can be done in<br>parallel with the rest of the ARC optimization work.<br></p><p>But, in the long run, we want to enforce these ownership invariants all<br>throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>eliminator. Thus we will need to update passes to handle these new instructions<br>and also will need to implement the `load_borrow`, `end_borrow` instruction.<br></p><p>The main optimizer changes can be separated into the following areas: memory<br>forwarding, dead stores, ARC optimization. In all of these cases, the necessary<br>changes are relatively trivial to respond to. We give a quick taste of two of<br>them: store-&gt;load forwarding and ARC Code Motion.<br></p><p>### store-&gt;load forwarding<br></p><p>Currently we perform store-&gt;load forwarding as follows:<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store %x to %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    use(%x)<br></p><p>In a world, where we are using ownership qualified load, store, we have to also<br>consider the ownership implications. *NOTE* Since we are not modifying the<br>store, `store [assign]` and `store [init]` are treated the same. Thus without<br>any loss of generality, lets consider solely `store`.<br></p><p>    store %x to [assign] %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    %y = load [copy] %x_ptr : $C<br>    use(%y)<br></p><p>      =&gt;<br></p><p>    store %x to [assign] %x_ptr : $C<br>    ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>    strong_retain %x<br>    use(%x)<br></p><p>### ARC Code Motion<br></p><p>If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>`load`, `store` instructions, it must now consider read/write effects. On the<br>other hand, we can perform more aggressive ARC code motion of ownership<br>qualified loads and stores in the face of deinits. This is because we no longer<br>need to worry about our code motion causing a deinit to fire in between (without<br>any loss of generality) the load/retain.<br></p><p>### Normal Code Motion<br></p><p>Normal code motion will lose some effectiveness since many of the load/store<br>operations that it used to be able to move now must consider ARC information. We<br>may need to consider running ARC code motion earlier in the pipeline where we<br>normally run Normal Code Motion to ensure that we are able to handle these<br>cases.<br></p><p>### ARC Optimization<br></p><p>The main implication for ARC optimization is that instead of eliminating just<br>retains, releases, it must be able to recognize ownership qualified `load`,<br>`store` and set their flags as appropriate. Also in general ARC optimization and<br>memory behavior will need to recognize the `end_borrow` instruction as a code<br>motion barrier.<br></p><p>### Function Signature Optimization<br></p><p>Semantic ARC affects function signature optimization in the context of the owned<br>to borrow optimization. Specifically:<br></p><p>1. A `store [assign]` must be recognized as a release of the old value that is<br>   being overridden. In such a case, we can move the `release` of the old value<br>   into the caller and change the `store [assign]` into a `store [init]`.<br>2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>   signature optimization will transform the `load [copy]` into a<br>   `load_borrow`. This would require the addition of a new `@borrow` return<br>   value convention.<br></p><p># Appendix<br></p><p>## Partial Initialization of Loadable References in SIL<br></p><p>In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>follows:<br></p><p>    %x = load %x_ptr : $*S<br>    ...<br>    retain_value %x_ptr : $S<br></p><p>At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>the partially initialized zone in between the load and the retain<br>operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>insert an instruction that causes x to be deallocated before the copy is<br>finished being initialized. Similar issues come up when trying to perform a<br>store of a non-trival value into a memory location.<br></p><p>Since this sort of partial initialization is allowed in SIL, the optimizer is<br>forced to be overly conservative when attempting to move releases passed retains<br>lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>two concrete examples that show how semantically providing ownership qualified<br>load, store instructions eliminate this problem.<br></p><p>**NOTE** Without any loss of generality, we will speak of values with reference<br>semantics instead of non-trivial values.<br></p><p>## Case Study: Partial Initialization and load [copy]<br></p><p>### The Problem<br></p><p>Consider the following swift program:<br></p><p>    func opaque_call()<br></p><p>    final class C {<br>      var int: Int = 0<br>      deinit {<br>        opaque_call()<br>      }<br>    }<br></p><p>    final class D {<br>      var int: Int = 0<br>    }<br></p><p>    var GLOBAL_C : C? = nil<br>    var GLOBAL_D : D? = nil<br></p><p>    func useC(_ c: C)<br>    func useD(_ d: D)<br></p><p>    func run() {<br>        let c = C()<br>        GLOBAL_C = c<br>        let d = D()<br>        GLOBAL_D = d<br>        useC(c)<br>        useD(d)<br>    }<br></p><p>Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>`GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>known to the compiler to not have any affects on instances of type `D`, `C`<br>respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>valid SIL lowering for `run`:<br></p><p>    sil_global GLOBAL_D : $D<br>    sil_global GLOBAL_C : $C<br></p><p>    final class C {<br>      var x: Int<br>      deinit<br>    }<br></p><p>    final class D {<br>      var x: Int<br>    }<br></p><p>    sil @useC : $@convention(thin) () -&gt; ()<br>    sil @useD : $@convention(thin) () -&gt; ()<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load %global_c : $*C                                               (3)<br>      strong_retain %c2 : $C                                                   (4)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Lets optimize this function! First we perform the following operations:<br></p><p>1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>   can store to load forward `(1)` to `(3)`.<br>2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>   to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>   such information as an analysis and does not perform the actual load-&gt;store<br>   forwarding.<br>3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>   `(6)` so that `(4)` is right before `(7)`.<br></p><p>This yields (using the &#39; marker to designate that a register has had load-store<br>forwarding applied to it):<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %d2 : $D                                                   (6)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Then by assumption, we know that `%useC` does not perform any releases of any<br>instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>analysis information that `%d2` and `%d` are th same due to the possibility of<br>performing store-&gt;load forwarding. After performing such transformations, `run`<br>looks as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Now by assumption, we know that `%useD_func` does not touch any instances of<br>class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>can be added. At first glance, this seems to suggest that we can move `(10)`<br>before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>optimization!<br></p><p>Lets think a bit more about this example and consider this example at the<br>language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>not allow for user level code to create dependencies from the body of the<br>destructor into the normal control flow that has called it. This means that<br>there are two valid results of this code:<br></p><p>- Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>  `%useD_func`.<br>- Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>   a different instance of `$D` is passed into `%useD_func`.<br></p><p>The fact that 1 occurs without optimization is just as a result of an<br>implementation detail of SILGen. 2 is also a valid sequence of operations.<br></p><p>Given that:<br></p><p>1. As a principle, the optimizer does not consider such dependencies to avoid<br>   being overly conservative.<br>2. We provide constructs to ensure appropriate lifetimes via the usage of<br>   constructs such as fix_lifetime.<br></p><p>We need to figure out how to express our optimization such that 2<br>happens. Remember that one of the optimizations that we performed at the<br>beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br></p><p>      %d = alloc_ref $D<br>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d = load %global_d_addr : $*D             (5)<br>      strong_retain %d : $D                      (6)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br></p><p>into:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br>      %d2 = load %global_d_addr : $*D             (5)<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      strong_retain %d2 : $D                      (6)<br></p><p>This transformation in Swift corresponds to transforming:<br></p><p>      let d = GLOBAL_D<br>      useC(c)<br></p><p>to:<br></p><p>      let d_raw = load_d_value(GLOBAL_D)<br>      useC(c)<br>      let d = take_ownership_of_d(d_raw)<br></p><p>This is clearly an instance where we have moved a side-effect in between the<br>loading of the data and the taking ownership of such data, that is before the<br>`let` is fully initialized. What if instead of just moving the retain, we moved<br>the entire let statement? This would then result in the following swift code:<br></p><p>      useC(c)<br>      let d = GLOBAL_D<br></p><p>and would correspond to the following SIL snippet:<br></p><p>      %global_d_addr = global_addr GLOBAL_D : $D<br></p><p>      // Call the user functions passing in the instances that we loaded from the globals.<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>      %d2 = load %global_d_addr : $*D                                         (5)<br>      strong_retain %d2 : $D                                                  (6)<br></p><p>Moving the load with the strong_retain to ensure that the full initialization is<br>performed even after code motion causes our SIL to look as follows:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D<br></p><p>      strong_retain %c : $C                                                    (4&#39;)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br></p><p>      %d2 = load %global_d : $*D                                               (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>Giving us the exact result that we want: Operation Sequence 2!<br></p><p>### Defining load [copy]<br></p><p>Given that we wish the load, store to be tightly coupled together, it is natural<br>to express this operation as a `load [copy]` instruction. Lets define the `load<br>[copy]` instruction as follows:<br></p><p>    %1 = load [copy] %0 : $*C<br></p><p>      =&gt;<br></p><p>    %1 = load %0 : $*C<br>    retain_value %1 : $C<br></p><p>Now lets transform our initial example to use this instruction:<br></p><p>Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [copy] %global_c : $*C                                        (3)<br>      %d2 = load [copy] %global_d : $*D                                        (5)<br></p><p>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br></p><p>      strong_release %d : $D                                                   (9)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then perform the previous code motion:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [copy] %global_c : $*C                                        (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>      strong_release %d : $D                                                   (9)<br></p><p>      %d2 = load [copy] %global_d : $*D                                        (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>      strong_release %c : $C                                                   (10)<br>    }<br></p><p>We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>`(8)`. Can we still do so? One way we could do this is by introducing the<br>`[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>semantically loading a value from a memory location and are taking ownership of<br>the value thus eliding the retain. In terms of SIL this flag is defined as:<br></p><p>    %x = load [take] %x_ptr : $*C<br></p><p>      =&gt;<br></p><p>    %x = load %x_ptr : $*C<br></p><p>Why do we care about having such a `load [take]` instruction when we could just<br>use a `load`? The reason why is that a normal `load` has unsafe unowned<br>ownership (i.e. it has no implications on ownership). We would like for memory<br>that has non-trivial type to only be able to be loaded via instructions that<br>maintain said ownership. We will allow for casting to trivial types as usual to<br>provide such access if it is required.<br></p><p>Thus we have achieved the desired result:<br></p><p>    sil @run : $@convention(thin) () -&gt; () {<br>    bb0:<br>      %c = alloc_ref $C<br>      %global_c = global_addr @GLOBAL_C : $*C<br>      strong_retain %c : $C<br>      store %c to %global_c : $*C                                              (1)<br></p><p>      %d = alloc_ref $D<br>      %global_d = global_addr @GLOBAL_D : $*D<br>      strong_retain %d : $D<br>      store %d to %global_d : $*D                                              (2)<br></p><p>      %c2 = load [take] %global_c : $*C                                        (3)<br>      %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>      apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br></p><p>      %d2 = load [take] %global_d : $*D                                        (5)<br>      %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>      apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>    }<br></p><p>----<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161014/1cf24387/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[semantic-arc][proposal] High Level ARC Memory Operations</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October 14, 2016 at 04:00:00pm</p></header><div class="content"><p>This seems fine to me… at a high level!<br>-Andy<br></p><p>&gt; On Oct 14, 2016, at 2:44 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Attached below is a final version of the proposal. I am going to commit it to the repo if there are no further questions/changes/etc.<br>&gt; <br>&gt;&gt; https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html &lt;https://gottesmm.github.io/proposals/high-level-arc-memory-operations.html&gt;<br>&gt; Michael<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; # Summary<br>&gt; <br>&gt; This document proposes:<br>&gt; <br>&gt; 1. adding the following ownership qualifiers to `load`: `[take]`, `[copy]`,<br>&gt;    `[trivial]`.<br>&gt; 2. adding the following ownership qualifiers to `store`: `[init]`, `[assign]`,<br>&gt;    `[trivial]`.<br>&gt; 3. adding the `load_borrow` instruction and the `end_borrow` instruction.<br>&gt; 3. requiring all `load` and `store` operations to have ownership qualifiers.<br>&gt; 4. banning the use of `load [trivial]`, `store [trivial]` on memory locations of<br>&gt;    `non-trivial` type.<br>&gt; <br>&gt; This will allow for:<br>&gt; <br>&gt; 1. eliminating optimizer miscompiles that occur due to releases being moved into<br>&gt;    the region in between a `load`/`retain`, `load`/`release`,<br>&gt;    `store`/`release`. (For a specific example, see the appendix).<br>&gt; 2. explicitly modeling `load [trivial]`/`store [trivial]` as having `unsafe<br>&gt;    unowned` ownership semantics. This will be enforced via the verifier.<br>&gt; 3. more aggressive ARC code motion.<br>&gt; <br>&gt; # Definitions<br>&gt; <br>&gt; ## ownership qualified load<br>&gt; <br>&gt; We propose three different ownership qualifiers for load. Define `load [trivial]`<br>&gt; as:<br>&gt; <br>&gt;     %x = load [trivial] %x_ptr : $*Int<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Int<br>&gt; <br>&gt; A `load [trivial]` can not be used to load values of non-trivial type. Define<br>&gt; `load [copy]` as:<br>&gt; <br>&gt;     %x = load [copy] %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt;     retain_value %x : $C<br>&gt; <br>&gt; Then define `load [take]` as:<br>&gt; <br>&gt;     %x = load [take] %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt; **NOTE** `load [take]` implies that the loaded from memory location no longer<br>&gt; owns the result object (i.e. a take is a move). Loading from the memory location<br>&gt; again without reinitialization is illegal.<br>&gt; <br>&gt; ## load_borrow and end_borrow<br>&gt; <br>&gt; Next we provide `load_borrow` and `end_borrow`:<br>&gt; <br>&gt;     %x = load_borrow %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     end_borrow %x, %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*Builtin.NativeObject<br>&gt;     ...<br>&gt;     endLifetime %x : $Builtin.NativeObject<br>&gt;     fixLifetime %x_ptr : $*Builtin.NativeObject<br>&gt; <br>&gt; `load [borrow]` implies that in the region between the `load` and the<br>&gt; `end_borrow`, the loaded object must semantically remain alive. The `end_borrow`<br>&gt; communicates to the optimizer:<br>&gt; <br>&gt; 1. that the value in `%x_ptr` should not be destroyed before endBorrow.<br>&gt; 2. uses of `%x` should not be sunk past endBorrow since `%x` is only a shallow<br>&gt;    copy of the value in `%x_ptr` and past that point `%x_ptr` may not remain<br>&gt;    alive.<br>&gt; <br>&gt; An example of where this construct is useful is when one has a let binding to a<br>&gt; class instance `c` that contains a let field `f`. In that case `c`&#39;s lifetime<br>&gt; guarantees `f`&#39;s lifetime meaning that returning `f` over the function call<br>&gt; boundary is safe.<br>&gt; <br>&gt; *NOTE* since the SILOwnershipModelEliminator will not process these<br>&gt; instructions, endLifetime is just a strawman instruction that will not be<br>&gt; implemented. In practice though, IRGen will need to create a suitable barrier to<br>&gt; ensure that LLVM does not move any uses of `%x` past the `fixLifetime`<br>&gt; instruction of `%x_ptr` once we begin creating such instructions as a result of<br>&gt; ARC optimization.<br>&gt; <br>&gt; ## ownership qualified store<br>&gt; <br>&gt; First define a `store [trivial]` as:<br>&gt; <br>&gt;     store %x to [trivial] %x_ptr : $*Int<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to %x_ptr : $*Int<br>&gt; <br>&gt; The verifier will prevent this instruction from being used on types with<br>&gt; non-trivial ownership. Define a `store [assign]` as follows:<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     %old_x = load %x_ptr : $*C<br>&gt;     store %new_x to %x_ptr : $*C<br>&gt;     release_value %old_x : $C<br>&gt; <br>&gt; *NOTE* `store` is defined as a consuming operation. We also provide<br>&gt; `store [init]` in the case where we know statically that there is no<br>&gt; previous value in the memory location:<br>&gt; <br>&gt;     store %x to [init] %x_ptr : $*C<br>&gt; <br>&gt;        =&gt;<br>&gt; <br>&gt;     store %new_x to %x_ptr : $*C<br>&gt; <br>&gt; # Implementation<br>&gt; <br>&gt; ## Goals<br>&gt; <br>&gt; Our implementation strategy goals are:<br>&gt; <br>&gt; 1. zero impact on other compiler developers until the feature is fully<br>&gt;    developed. This implies all work will be done behind a flag.<br>&gt; 2. separation of feature implementation from updating passes.<br>&gt; <br>&gt; Goal 2 will be implemented via a pass that transforms ownership qualified<br>&gt; `load`/`store` instructions into unqualified `load`/`store` right after SILGen.<br>&gt; <br>&gt; ## Plan<br>&gt; <br>&gt; We begin by adding initial infrastructure for our development. This means:<br>&gt; <br>&gt; 1. Adding to SILOptions a disabled by default flag called<br>&gt;  &quot;EnableSILOwnershipModel&quot;. This flag will be set by a false by default frontend<br>&gt;  option called &quot;-enable-sil-ownership-mode&quot;.<br>&gt; <br>&gt; 2. Bots will be brought up to test the compiler with<br>&gt;    &quot;-enable-sil-ownership-model&quot; set to true. The specific bots are:<br>&gt; <br>&gt;    * RA-OSX+simulators<br>&gt;    * RA-Device<br>&gt;    * RA-Linux.<br>&gt; <br>&gt;    The bots will run once a day until the feature is close to completion. Then a<br>&gt;    polling model will be followed.<br>&gt; <br>&gt; Now that change isolation is borrow, we develop building blocks for the<br>&gt; optimization:<br>&gt; <br>&gt; 1. Two enums will be defined: `LoadInstOwnershipQualifier`,<br>&gt;    `StoreInstOwnershipQualifier`. The exact definition of these enums are as<br>&gt;    follows:<br>&gt; <br>&gt;        enum class LoadOwnershipQualifier {<br>&gt;          Unqualified, Take, Copy, Trivial<br>&gt;        };<br>&gt;        enum class StoreOwnershipQualifier {<br>&gt;          Unqualified, Init, Assign, Trivial<br>&gt;        };<br>&gt; <br>&gt;     *NOTE* `LoadOwnershipQualifier::Unqualified` and<br>&gt;     `StoreOwnershipQualifier::Unqualified` are only needed for staging purposes.<br>&gt; <br>&gt; 2. Creating a `LoadInst`, `StoreInst` will be changed to require an ownership<br>&gt; qualifier. At this stage, this argument will default to `Unqualified`. &quot;Bare&quot;<br>&gt; `load`, `store` when parsed via textual SIL will be considered to be<br>&gt; unqualified. This implies that the rest of the compiler will not have to be<br>&gt; changed as a result of this step.<br>&gt; <br>&gt; 3. Support will be added to SIL, IRGen, Serialization, SIL Printing, and SIL<br>&gt; Parsing for the rest of the qualifiers. SILGen will not be modified at this<br>&gt; stage.<br>&gt; <br>&gt; 4. The `load_borrow` and `end_borrow` instructions will be implemented in SIL,<br>&gt;    IRGen, Serialization, SIL Printing, and SIL Parsing. They will not be used<br>&gt;    immediately.<br>&gt; <br>&gt; 4. A pass called the &quot;OwnershipModelEliminator&quot; will be implemented. It will<br>&gt;    blow up all `load`, `store` instructions with non `*::Unqualified` ownership<br>&gt;    into their constituant ARC operations and `*::Unqualified` `load`, `store`<br>&gt;    insts. It will not process `load_borrow` and `end_borrow` since currently it<br>&gt;    is not expected for SILGen to emit such instructions.<br>&gt; <br>&gt; 5. An option called &quot;EnforceSILOwnershipMode&quot; will be added to the verifier. If<br>&gt; the option is set, the verifier will assert if:<br>&gt; <br>&gt;    a. `load`, `store` operations with trivial ownership are applied to memory<br>&gt;       locations with non-trivial type.<br>&gt; <br>&gt;    b. `load`, `store` operation with unqualified ownership type are present in<br>&gt;    the IR.<br>&gt; <br>&gt;    c. `load_borrow` or `end_borrow` are present in the IR. This is because<br>&gt;    currently we do not support SIL containing such instructions in SIL<br>&gt;    Ownership Mode. Once we have the ability to verify borrowing scopes, this<br>&gt;    will no longer be the case, but this is a different proposal.<br>&gt; <br>&gt; Finally, we wire up the building blocks:<br>&gt; <br>&gt; 1. If SILOption.EnableSILOwnershipModel is true, then the after SILGen SIL<br>&gt;    verification will be performed with EnforceSILOwnershipModel set to true.<br>&gt; 2. If SILOption.EnableSILOwnershipModel is true, then the pass manager will run<br>&gt;    the OwnershipModelEliminator pass right after SILGen before the normal pass<br>&gt;    pipeline starts.<br>&gt; 3. SILGen will be changed to emit non-unqualified ownership qualifiers on load,<br>&gt;    store instructions when the EnableSILOwnershipModel flag is set. We will use<br>&gt;    the verifier throwing to guarantee that we are not missing any specific<br>&gt;    cases.<br>&gt; <br>&gt; Then once all of the bots are green, we change SILOption.EnableSILOwnershipModel<br>&gt; to be true by default. After a cooling off period, we move all of the code<br>&gt; behind the SILOwnershipModel flag in front of the flag. We do this so we can<br>&gt; reuse that flag for further SILOwnershipModel changes.<br>&gt; <br>&gt; ## Optimizer Changes<br>&gt; <br>&gt; Since the SILOwnershipModel eliminator will eliminate the ownership qualifiers<br>&gt; on load, store instructions right after ownership verification, there will be no<br>&gt; immediate effects on the optimizer and thus the optimizer changes can be done in<br>&gt; parallel with the rest of the ARC optimization work.<br>&gt; <br>&gt; But, in the long run, we want to enforce these ownership invariants all<br>&gt; throughout the SIL pipeline implying these ownership qualified `load`, `store`<br>&gt; instructions must be processed by IRGen, not eliminated by the SILOwnershipModel<br>&gt; eliminator. Thus we will need to update passes to handle these new instructions<br>&gt; and also will need to implement the `load_borrow`, `end_borrow` instruction.<br>&gt; <br>&gt; The main optimizer changes can be separated into the following areas: memory<br>&gt; forwarding, dead stores, ARC optimization. In all of these cases, the necessary<br>&gt; changes are relatively trivial to respond to. We give a quick taste of two of<br>&gt; them: store-&gt;load forwarding and ARC Code Motion.<br>&gt; <br>&gt; ### store-&gt;load forwarding<br>&gt; <br>&gt; Currently we perform store-&gt;load forwarding as follows:<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     use(%x)<br>&gt; <br>&gt; In a world, where we are using ownership qualified load, store, we have to also<br>&gt; consider the ownership implications. *NOTE* Since we are not modifying the<br>&gt; store, `store [assign]` and `store [init]` are treated the same. Thus without<br>&gt; any loss of generality, lets consider solely `store`.<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     %y = load [copy] %x_ptr : $C<br>&gt;     use(%y)<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     store %x to [assign] %x_ptr : $C<br>&gt;     ... NO SIDE EFFECTS THAT TOUCH X_PTR ...<br>&gt;     strong_retain %x<br>&gt;     use(%x)<br>&gt; <br>&gt; ### ARC Code Motion<br>&gt; <br>&gt; If ARC Code Motion wishes to move the ARC semantics of ownership qualified<br>&gt; `load`, `store` instructions, it must now consider read/write effects. On the<br>&gt; other hand, we can perform more aggressive ARC code motion of ownership<br>&gt; qualified loads and stores in the face of deinits. This is because we no longer<br>&gt; need to worry about our code motion causing a deinit to fire in between (without<br>&gt; any loss of generality) the load/retain.<br>&gt; <br>&gt; ### Normal Code Motion<br>&gt; <br>&gt; Normal code motion will lose some effectiveness since many of the load/store<br>&gt; operations that it used to be able to move now must consider ARC information. We<br>&gt; may need to consider running ARC code motion earlier in the pipeline where we<br>&gt; normally run Normal Code Motion to ensure that we are able to handle these<br>&gt; cases.<br>&gt; <br>&gt; ### ARC Optimization<br>&gt; <br>&gt; The main implication for ARC optimization is that instead of eliminating just<br>&gt; retains, releases, it must be able to recognize ownership qualified `load`,<br>&gt; `store` and set their flags as appropriate. Also in general ARC optimization and<br>&gt; memory behavior will need to recognize the `end_borrow` instruction as a code<br>&gt; motion barrier.<br>&gt; <br>&gt; ### Function Signature Optimization<br>&gt; <br>&gt; Semantic ARC affects function signature optimization in the context of the owned<br>&gt; to borrow optimization. Specifically:<br>&gt; <br>&gt; 1. A `store [assign]` must be recognized as a release of the old value that is<br>&gt;    being overridden. In such a case, we can move the `release` of the old value<br>&gt;    into the caller and change the `store [assign]` into a `store [init]`.<br>&gt; 2. A `load [copy]` must be recognized as a retain in the callee. Then function<br>&gt;    signature optimization will transform the `load [copy]` into a<br>&gt;    `load_borrow`. This would require the addition of a new `@borrow` return<br>&gt;    value convention.<br>&gt; <br>&gt; # Appendix<br>&gt; <br>&gt; ## Partial Initialization of Loadable References in SIL<br>&gt; <br>&gt; In SIL, a value of non-trivial loadable type is loaded from a memory location as<br>&gt; follows:<br>&gt; <br>&gt;     %x = load %x_ptr : $*S<br>&gt;     ...<br>&gt;     retain_value %x_ptr : $S<br>&gt; <br>&gt; At first glance, this looks reasonable, but in truth there is a hidden drawback:<br>&gt; the partially initialized zone in between the load and the retain<br>&gt; operation. This zone creates a period of time when an &quot;evil optimizer&quot; could<br>&gt; insert an instruction that causes x to be deallocated before the copy is<br>&gt; finished being initialized. Similar issues come up when trying to perform a<br>&gt; store of a non-trival value into a memory location.<br>&gt; <br>&gt; Since this sort of partial initialization is allowed in SIL, the optimizer is<br>&gt; forced to be overly conservative when attempting to move releases passed retains<br>&gt; lest the release triggers a deinit that destroys a value like `%x`. Lets look at<br>&gt; two concrete examples that show how semantically providing ownership qualified<br>&gt; load, store instructions eliminate this problem.<br>&gt; <br>&gt; **NOTE** Without any loss of generality, we will speak of values with reference<br>&gt; semantics instead of non-trivial values.<br>&gt; <br>&gt; ## Case Study: Partial Initialization and load [copy]<br>&gt; <br>&gt; ### The Problem<br>&gt; <br>&gt; Consider the following swift program:<br>&gt; <br>&gt;     func opaque_call()<br>&gt; <br>&gt;     final class C {<br>&gt;       var int: Int = 0<br>&gt;       deinit {<br>&gt;         opaque_call()<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var int: Int = 0<br>&gt;     }<br>&gt; <br>&gt;     var GLOBAL_C : C? = nil<br>&gt;     var GLOBAL_D : D? = nil<br>&gt; <br>&gt;     func useC(_ c: C)<br>&gt;     func useD(_ d: D)<br>&gt; <br>&gt;     func run() {<br>&gt;         let c = C()<br>&gt;         GLOBAL_C = c<br>&gt;         let d = D()<br>&gt;         GLOBAL_D = d<br>&gt;         useC(c)<br>&gt;         useD(d)<br>&gt;     }<br>&gt; <br>&gt; Notice that both `C` and `D` have fixed layouts and separate class hierarchies,<br>&gt; but `C`&#39;s deinit has a call to the function `opaque_call` which may write to<br>&gt; `GLOBAL_D` or `GLOBAL_C`. Additionally assume that both `useC` and `useD` are<br>&gt; known to the compiler to not have any affects on instances of type `D`, `C`<br>&gt; respectively and useC assigns `nil` to `GLOBAL_C`. Now consider the following<br>&gt; valid SIL lowering for `run`:<br>&gt; <br>&gt;     sil_global GLOBAL_D : $D<br>&gt;     sil_global GLOBAL_C : $C<br>&gt; <br>&gt;     final class C {<br>&gt;       var x: Int<br>&gt;       deinit<br>&gt;     }<br>&gt; <br>&gt;     final class D {<br>&gt;       var x: Int<br>&gt;     }<br>&gt; <br>&gt;     sil @useC : $@convention(thin) () -&gt; ()<br>&gt;     sil @useD : $@convention(thin) () -&gt; ()<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load %global_c : $*C                                               (3)<br>&gt;       strong_retain %c2 : $C                                                   (4)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Lets optimize this function! First we perform the following operations:<br>&gt; <br>&gt; 1. Since `(2)` is storing to an identified object that can not be `GLOBAL_C`, we<br>&gt;    can store to load forward `(1)` to `(3)`.<br>&gt; 2. Since a retain does not block store to load forwarding, we can forward `(2)`<br>&gt;    to `(5)`. But lets for the sake of argument, assume that the optimizer keeps<br>&gt;    such information as an analysis and does not perform the actual load-&gt;store<br>&gt;    forwarding.<br>&gt; 3. Even though we do not foward `(2)` to `(5)`, we can still move `(4)` over<br>&gt;    `(6)` so that `(4)` is right before `(7)`.<br>&gt; <br>&gt; This yields (using the &#39; marker to designate that a register has had load-store<br>&gt; forwarding applied to it):<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %d2 : $D                                                   (6)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Then by assumption, we know that `%useC` does not perform any releases of any<br>&gt; instances of class `D`. Thus `(6)` can be moved past `(7&#39;)` and we can then pair<br>&gt; and eliminate `(6)` and `(9)` via the rules of ARC optimization using the<br>&gt; analysis information that `%d2` and `%d` are th same due to the possibility of<br>&gt; performing store-&gt;load forwarding. After performing such transformations, `run`<br>&gt; looks as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Now by assumption, we know that `%useD_func` does not touch any instances of<br>&gt; class `C` and `%c` does not contain any ivars of type `D` and is final so none<br>&gt; can be added. At first glance, this seems to suggest that we can move `(10)`<br>&gt; before `(8&#39;)` and then pair/eliminate `(4&#39;)` and `(10)`. But is this a safe<br>&gt; optimization perform?  Absolutely Not! Why? Remember that since `useC_func`<br>&gt; assigns `nil` to `GLOBAL_C`, after `(7&#39;)`, `%c` could have a reference count<br>&gt; of 1.  Thus `(10)` _may_ invoke the destructor of `C`. Since this destructor<br>&gt; calls an opaque function that _could_ potentially write to `GLOBAL_D`, we may be<br>&gt; be passing `%d2`, an already deallocated object to `%useD_func`, an illegal<br>&gt; optimization!<br>&gt; <br>&gt; Lets think a bit more about this example and consider this example at the<br>&gt; language level. Remember that while Swift&#39;s deinit are not asychronous, we do<br>&gt; not allow for user level code to create dependencies from the body of the<br>&gt; destructor into the normal control flow that has called it. This means that<br>&gt; there are two valid results of this code:<br>&gt; <br>&gt; - Operation Sequence 1: No optimization is performed and `%d2` is passed to<br>&gt;   `%useD_func`.<br>&gt; - Operation Sequence 2: We shorten the lifetime of `%c` before `%useD_func` and<br>&gt;    a different instance of `$D` is passed into `%useD_func`.<br>&gt; <br>&gt; The fact that 1 occurs without optimization is just as a result of an<br>&gt; implementation detail of SILGen. 2 is also a valid sequence of operations.<br>&gt; <br>&gt; Given that:<br>&gt; <br>&gt; 1. As a principle, the optimizer does not consider such dependencies to avoid<br>&gt;    being overly conservative.<br>&gt; 2. We provide constructs to ensure appropriate lifetimes via the usage of<br>&gt;    constructs such as fix_lifetime.<br>&gt; <br>&gt; We need to figure out how to express our optimization such that 2<br>&gt; happens. Remember that one of the optimizations that we performed at the<br>&gt; beginning was to move `(6)` over `(7&#39;)`, i.e., transform this:<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d = load %global_d_addr : $*D             (5)<br>&gt;       strong_retain %d : $D                      (6)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt; <br>&gt; into:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt;       %d2 = load %global_d_addr : $*D             (5)<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       strong_retain %d2 : $D                      (6)<br>&gt; <br>&gt; This transformation in Swift corresponds to transforming:<br>&gt; <br>&gt;       let d = GLOBAL_D<br>&gt;       useC(c)<br>&gt; <br>&gt; to:<br>&gt; <br>&gt;       let d_raw = load_d_value(GLOBAL_D)<br>&gt;       useC(c)<br>&gt;       let d = take_ownership_of_d(d_raw)<br>&gt; <br>&gt; This is clearly an instance where we have moved a side-effect in between the<br>&gt; loading of the data and the taking ownership of such data, that is before the<br>&gt; `let` is fully initialized. What if instead of just moving the retain, we moved<br>&gt; the entire let statement? This would then result in the following swift code:<br>&gt; <br>&gt;       useC(c)<br>&gt;       let d = GLOBAL_D<br>&gt; <br>&gt; and would correspond to the following SIL snippet:<br>&gt; <br>&gt;       %global_d_addr = global_addr GLOBAL_D : $D<br>&gt; <br>&gt;       // Call the user functions passing in the instances that we loaded from the globals.<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()                (7&#39;)<br>&gt;       %d2 = load %global_d_addr : $*D                                         (5)<br>&gt;       strong_retain %d2 : $D                                                  (6)<br>&gt; <br>&gt; Moving the load with the strong_retain to ensure that the full initialization is<br>&gt; performed even after code motion causes our SIL to look as follows:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D<br>&gt; <br>&gt;       strong_retain %c : $C                                                    (4&#39;)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c) : $@convention(thin) (@owned C) -&gt; ()               (7&#39;)<br>&gt; <br>&gt;       %d2 = load %global_d : $*D                                               (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; Giving us the exact result that we want: Operation Sequence 2!<br>&gt; <br>&gt; ### Defining load [copy]<br>&gt; <br>&gt; Given that we wish the load, store to be tightly coupled together, it is natural<br>&gt; to express this operation as a `load [copy]` instruction. Lets define the `load<br>&gt; [copy]` instruction as follows:<br>&gt; <br>&gt;     %1 = load [copy] %0 : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %1 = load %0 : $*C<br>&gt;     retain_value %1 : $C<br>&gt; <br>&gt; Now lets transform our initial example to use this instruction:<br>&gt; <br>&gt; Notice how now if we move `(7)` over `(3)` and `(6)` now, we get the following SIL:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt; <br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt; <br>&gt;       strong_release %d : $D                                                   (9)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then perform the previous code motion:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [copy] %global_c : $*C                                        (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt;       strong_release %d : $D                                                   (9)<br>&gt; <br>&gt;       %d2 = load [copy] %global_d : $*D                                        (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;       strong_release %c : $C                                                   (10)<br>&gt;     }<br>&gt; <br>&gt; We then would like to eliminate `(9)` and `(10)` by pairing them with `(3)` and<br>&gt; `(8)`. Can we still do so? One way we could do this is by introducing the<br>&gt; `[take]` flag. The `[take]` flag on a `load [take]` says that one is<br>&gt; semantically loading a value from a memory location and are taking ownership of<br>&gt; the value thus eliding the retain. In terms of SIL this flag is defined as:<br>&gt; <br>&gt;     %x = load [take] %x_ptr : $*C<br>&gt; <br>&gt;       =&gt;<br>&gt; <br>&gt;     %x = load %x_ptr : $*C<br>&gt; <br>&gt; Why do we care about having such a `load [take]` instruction when we could just<br>&gt; use a `load`? The reason why is that a normal `load` has unsafe unowned<br>&gt; ownership (i.e. it has no implications on ownership). We would like for memory<br>&gt; that has non-trivial type to only be able to be loaded via instructions that<br>&gt; maintain said ownership. We will allow for casting to trivial types as usual to<br>&gt; provide such access if it is required.<br>&gt; <br>&gt; Thus we have achieved the desired result:<br>&gt; <br>&gt;     sil @run : $@convention(thin) () -&gt; () {<br>&gt;     bb0:<br>&gt;       %c = alloc_ref $C<br>&gt;       %global_c = global_addr @GLOBAL_C : $*C<br>&gt;       strong_retain %c : $C<br>&gt;       store %c to %global_c : $*C                                              (1)<br>&gt; <br>&gt;       %d = alloc_ref $D<br>&gt;       %global_d = global_addr @GLOBAL_D : $*D<br>&gt;       strong_retain %d : $D<br>&gt;       store %d to %global_d : $*D                                              (2)<br>&gt; <br>&gt;       %c2 = load [take] %global_c : $*C                                        (3)<br>&gt;       %useC_func = function_ref @useC : $@convention(thin) (@owned C) -&gt; ()<br>&gt;       apply %useC_func(%c2) : $@convention(thin) (@owned C) -&gt; ()              (7)<br>&gt; <br>&gt;       %d2 = load [take] %global_d : $*D                                        (5)<br>&gt;       %useD_func = function_ref @useD : $@convention(thin) (@owned D) -&gt; ()<br>&gt;       apply %useD_func(%d2) : $@convention(thin) (@owned D) -&gt; ()              (8)<br>&gt;     }<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161014/40ede538/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
