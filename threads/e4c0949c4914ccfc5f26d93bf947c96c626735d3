<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Apply for closure</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 28, 2016 at 09:00:00am</p></header><div class="content"><p>This is a discussion inspired by the recent proposal of Chris to remove turple splats.<br></p><p>I would like to propose we add a apply method for all closures.<br></p><p>What would the syntax look like?<br></p><p>To apply a bunch of variables to a normal function and call it we can first access it&#39;s closure like so<br></p><p>object.foo<br></p><p>Since this returns a closure to use apply we just do this<br></p><p>object.foo.apply(...)<br></p><p>When it comes to anonymous closures we can do the same:<br></p><p>closure.apply(...)<br></p><p>So why would we need this?<br></p><p>This is an alternative way of performing actions that you would normally do via NSInvocation and I feel it also opens the doors for things other people have proposed else where like partial initialisers. <br></p><p>So how would the syntax work?<br></p><p>The compiler would allow you to pass in a array which will be splatted to have all of its arguments applied. This would be useful for applying vargs.<br></p><p>closure.apply(args:[12])<br></p><p>Since this is only applied to closures the compiler knows how many arguments an array should have and what value.<br></p><p>Additionally it could allow turples to replace the previous splat behviour<br></p><p>closure.apply(turple:(12))<br></p><p>My last is what I call a symbol hash:<br></p><p>closure.apply([<br>.argument: 12<br>])<br></p><p>It allows you to pass in dictionary to be used to construct the arguments.<br></p><p>The keys are a special generated symbol(enums maybe) that represent the argument label. The value for each key is passed to the relevant argument.<br></p><p>This allows you to construct a struct without having to pass all the parameters. Which is great for functional programming as you could allow people to  partially initialise a struct or to return a new copy with one value mutated (currently this requires a huge amount of boilerplate)<br></p><p>struct.copyWithMutation.apply([<br>.name: &quot;hey&quot;<br>])<br></p><p>I know nothing about compilers so would love to hear your thoughts. This makes the most sense to me coming from a ruby and JavaScript background <br></p><p>Sent from my iPhone<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Apply for closure</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>I have no obvious use case, but I like the concept of &quot;functions having functions&quot;:<br>It is most likely not that relevant for Swift 3, but as soon as the macro-system becomes concrete, it could be valuable for meta-programming…<br></p><p>Besides &quot;apply&quot;, we could have introspection (&quot;f.parametersByIndex[0].type&quot;) and a revival of currying<br>let twice: (Double) -&gt; Double = *.curry(parameterIndex: 0, value: 2.0)<br></p><p>It could even be possible to do meta-programming without leaving the language, e.g.<br></p><p>class Snitch: SomeClass {<br>	for f in super.overridableMethods {<br>		self.implementation[f] = { (args: f.argumentTuple) in<br>			print(&quot;Function \(f.name) has been called with \(args)&quot;)<br>			return f.apply(args)<br>		}<br>	}<br>}<br></p><p>I probably would hate anyone actually using such a feature (unless the debugger is really great ;-), but it would be freaking cool nonetheless ;-)<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Apply for closure</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I think making functions first class citizens would be mega cool<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 Jan 2016, at 13:07, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I have no obvious use case, but I like the concept of &quot;functions having functions&quot;:<br>&gt; It is most likely not that relevant for Swift 3, but as soon as the macro-system becomes concrete, it could be valuable for meta-programming…<br>&gt; <br>&gt; Besides &quot;apply&quot;, we could have introspection (&quot;f.parametersByIndex[0].type&quot;) and a revival of currying<br>&gt; let twice: (Double) -&gt; Double = *.curry(parameterIndex: 0, value: 2.0)<br>&gt; <br>&gt; It could even be possible to do meta-programming without leaving the language, e.g.<br>&gt; <br>&gt; class Snitch: SomeClass {<br>&gt;    for f in super.overridableMethods {<br>&gt;        self.implementation[f] = { (args: f.argumentTuple) in<br>&gt;            print(&quot;Function \(f.name) has been called with \(args)&quot;)<br>&gt;            return f.apply(args)<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I probably would hate anyone actually using such a feature (unless the debugger is really great ;-), but it would be freaking cool nonetheless ;-)<br>&gt; <br>&gt; Tino<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
