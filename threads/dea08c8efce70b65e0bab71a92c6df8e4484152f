<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July 30, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Chris,<br></p><p>thanks for the tip about Hirundo app!<br></p><p>A positive side-effect of removing the classical for;; loop<br> (yes, it’s me saying this :o)  is that it forces me to find<br>a good and generic equivalent for it, <br>making the conversion of my for;;s to 3.0 easier.<br>which is *not* based on collections or sequences and<br>does not rely on deeper calls to Sequence etc.<br></p><p>so, I’ve made the functions [iterator, iterator2D, iterator3D]  (hereunder)<br>wich btw clearly demonstrate the power and flexibility of Swift. <br></p><p>Very straightforward, and efficient (i assume) just like the classical for;; loop.  <br>It works quite well in my sources.<br></p><p>As a spin-off,  I’ve extended these to iterators for matrices 2D and cubes? 3D...<br></p><p>Question: <br>Perhaps implementing “multi dimensional iterator functions<br>in Swift might  be a good idea. so that is no longer necessary to nest/nest/nest iterators. <br></p><p>Met vriendelijke groeten, sorry for my “intensity” in discussing the classical for;; <br>I&#39;ll have to rethink this for;; again..  <br>Thanks, Ted.<br></p><p>Any remarks ( all ), suggestions about the code hereunder:              ? <br></p><p>protocol NumericType<br>{<br>    func +(lhs: Self, rhs: Self) -&gt; Self<br>    func -(lhs: Self, rhs: Self) -&gt; Self<br>    func *(lhs: Self, rhs: Self) -&gt; Self<br>    func /(lhs: Self, rhs: Self) -&gt; Self<br>    func %(lhs: Self, rhs: Self) -&gt; Self<br>}<br></p><p>extension Double : NumericType { }<br>extension Float  : NumericType { }<br>extension CGFloat: NumericType { }<br>extension Int    : NumericType { }<br>extension Int8   : NumericType { }<br>extension Int16  : NumericType { }<br>extension Int32  : NumericType { }<br>extension Int64  : NumericType { }<br>extension UInt   : NumericType { }<br>extension UInt8  : NumericType { }<br>extension UInt16 : NumericType { }<br>extension UInt32 : NumericType { }<br>extension UInt64 : NumericType { }<br></p><p><br>/// Simple iterator with generic parameters, with just a few lines of code.<br>/// for most numeric types (see above)<br>/// Usage Example:<br>///<br>///   iterate(xmax, { $0 &gt; xmin}, -xstep,<br>///    {x in<br>///        print(&quot;x = \(x)&quot;)<br>///        return true  // returning false acts like a break<br>///     } )<br>///<br>///  -Parameter vstart: Initial value<br>///  -Parameter step:    The iteration stepping value.<br>///  -Parameter test:    A block with iteration test. e.g. {$0 &gt; 10}<br>///<br>///  -Parameter block:   A block to be executed with each step.<br>///       The block must include a return true (acts like &quot;continue&quot;)<br>///                                   or false (acts like &quot;break&quot;)<br>///  -Please Note: <br>///  There is minor precision loss ca: 1/1000 ... 1/500 <br>///  when iterating with floating point numbers.<br>///  However, in most cases this can be safely ignored.<br>///  made by ted van gaalen.<br></p><p><br>func iterate&lt;T:NumericType&gt; (<br>                    vstart:  T,<br>                   _ vstep:  T,<br>                   _  test: (T) -&gt; Bool,<br>                   _ block: (T) -&gt; Bool )<br>{<br>    var current = vstart<br>    <br>    while test(current) &amp;&amp; block(current)<br>    {<br>        current = current + vstep<br>    }<br>}<br></p><p><br>/// X,Y 2D matrix (table) iterator with generic parameters<br>func iterate2D&lt;T:NumericType&gt; (<br>     xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>   _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>   _ block: (T,T) -&gt; Bool )<br>{<br>    var xcurrent = xstart<br>    var ycurrent = ystart<br>    <br>    var dontStop = true<br>    <br>    while xtest(xcurrent) &amp;&amp; dontStop<br>    {<br>        ycurrent = ystart<br>        while ytest(ycurrent) &amp;&amp; dontStop<br>        {<br>            dontStop = block(xcurrent, ycurrent)<br>            ycurrent = ycurrent + ystep<br>        }<br>        xcurrent = xcurrent + xstep<br>    }<br>}<br></p><p><br>/// X,Y,Z 3D (cubic) iterator with generic parameters:<br></p><p>func iterate3D&lt;T:NumericType&gt; (<br>    xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>  _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>  _ zstart:  T,  _ zstep: T, _ ztest: (T) -&gt; Bool,<br>      _ block: (T,T,T) -&gt; Bool )<br>{<br>    var xcurrent = xstart<br>    var ycurrent = ystart<br>    var zcurrent = zstart<br>    <br>    var dontStop = true<br>    <br>    while xtest(xcurrent) &amp;&amp; dontStop<br>    {<br>        ycurrent = ystart<br>        while ytest(ycurrent) &amp;&amp; dontStop<br>        {<br>            zcurrent = zstart<br>            while ztest(zcurrent) &amp;&amp; dontStop<br>            {<br>                dontStop = block(xcurrent, ycurrent, zcurrent)<br>                zcurrent = zcurrent + zstep<br>            }<br>            ycurrent = ycurrent + ystep<br>        }<br>        xcurrent = xcurrent + xstep<br>    }<br>}<br></p><p><br>func testIterator()<br>{<br>    iterate(0.0, 0.5, {$0 &lt; 1000.00000} ,<br>            { value in<br>                print(&quot;Value = \(value) &quot;)<br>                return true<br>    } )<br></p><p>    let startv: CGFloat = -20.0<br>    let stepv: CGFloat =   0.5<br>    <br>    iterate(startv, stepv, {$0 &lt; 1000.00000} ,<br>            { val in<br>                print(&quot;R = \(val)&quot;)<br>                return true<br>    } )<br></p><p>    let tolerance = 0.01 // boundary tolerance for floating point type<br>    <br>    iterate2D( 0.0, 10.0, { $0 &lt; 100.0 + tolerance } ,<br>               0.0,  5.0, { $0 &lt;  50.0 + tolerance } ,<br>               {x,y in<br>                print(&quot;x = \(x) y = \(y)&quot;)<br>                return true  // false from block stops iterating ( like break)<br>                } )<br></p><p>    iterate3D( 0.0,  10.0, { $0 &lt;   30.0 } ,  // x<br>               0.0,   5.0, { $0 &lt;   20.0 } ,  // y<br>               10.0, -5.0, { $0 &gt;  -10.0 } ,  // z<br>               {x,y,z in<br>                    print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>                    if z &lt; 0.0<br>                    {<br>                        print ( &quot;** z value \(z) is below zero! **&quot; )<br>                        <br>                        return false  // (acts as break in for;;)<br>                    }<br>                    return true  // return stmt is obligatory (continue)<br>               } )<br>}<br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/dea0152f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 30, 2016 at 07:00:00pm</p></header><div class="content"><p>What benefit do Iterator2D and Iterator3D provide that nesting does not?<br></p><p>&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; thanks for the tip about Hirundo app!<br>&gt; <br>&gt; A positive side-effect of removing the classical for;; loop<br>&gt;  (yes, it’s me saying this :o)  is that it forces me to find<br>&gt; a good and generic equivalent for it, <br>&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt; which is *not* based on collections or sequences and<br>&gt; does not rely on deeper calls to Sequence etc.<br>&gt; <br>&gt; so, I’ve made the functions [iterator, iterator2D, iterator3D]  (hereunder)<br>&gt; wich btw clearly demonstrate the power and flexibility of Swift. <br>&gt; <br>&gt; Very straightforward, and efficient (i assume) just like the classical for;; loop.  <br>&gt; It works quite well in my sources.<br>&gt; <br>&gt; As a spin-off,  I’ve extended these to iterators for matrices 2D and cubes? 3D...<br>&gt; <br>&gt; Question: <br>&gt; Perhaps implementing “multi dimensional iterator functions<br>&gt; in Swift might  be a good idea. so that is no longer necessary to nest/nest/nest iterators. <br>&gt; <br>&gt; Met vriendelijke groeten, sorry for my “intensity” in discussing the classical for;; <br>&gt; I&#39;ll have to rethink this for;; again..  <br>&gt; Thanks, Ted.<br>&gt; <br>&gt; Any remarks ( all ), suggestions about the code hereunder:              ? <br>&gt; <br>&gt; protocol NumericType<br>&gt; {<br>&gt;     func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     func -(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     func /(lhs: Self, rhs: Self) -&gt; Self<br>&gt;     func %(lhs: Self, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension Double : NumericType { }<br>&gt; extension Float  : NumericType { }<br>&gt; extension CGFloat: NumericType { }<br>&gt; extension Int    : NumericType { }<br>&gt; extension Int8   : NumericType { }<br>&gt; extension Int16  : NumericType { }<br>&gt; extension Int32  : NumericType { }<br>&gt; extension Int64  : NumericType { }<br>&gt; extension UInt   : NumericType { }<br>&gt; extension UInt8  : NumericType { }<br>&gt; extension UInt16 : NumericType { }<br>&gt; extension UInt32 : NumericType { }<br>&gt; extension UInt64 : NumericType { }<br>&gt; <br>&gt; <br>&gt; /// Simple iterator with generic parameters, with just a few lines of code.<br>&gt; /// for most numeric types (see above)<br>&gt; /// Usage Example:<br>&gt; ///<br>&gt; ///   iterate(xmax, { $0 &gt; xmin}, -xstep,<br>&gt; ///    {x in<br>&gt; ///        print(&quot;x = \(x)&quot;)<br>&gt; ///        return true  // returning false acts like a break<br>&gt; ///     } )<br>&gt; ///<br>&gt; ///  -Parameter vstart: Initial value<br>&gt; ///  -Parameter step:    The iteration stepping value.<br>&gt; ///  -Parameter test:    A block with iteration test. e.g. {$0 &gt; 10}<br>&gt; ///<br>&gt; ///  -Parameter block:   A block to be executed with each step.<br>&gt; ///       The block must include a return true (acts like &quot;continue&quot;)<br>&gt; ///                                   or false (acts like &quot;break&quot;)<br>&gt; ///  -Please Note: <br>&gt; ///  There is minor precision loss ca: 1/1000 ... 1/500 <br>&gt; ///  when iterating with floating point numbers.<br>&gt; ///  However, in most cases this can be safely ignored.<br>&gt; ///  made by ted van gaalen.<br>&gt; <br>&gt; <br>&gt; func iterate&lt;T:NumericType&gt; (<br>&gt;                     vstart:  T,<br>&gt;                    _ vstep:  T,<br>&gt;                    _  test: (T) -&gt; Bool,<br>&gt;                    _ block: (T) -&gt; Bool )<br>&gt; {<br>&gt;     var current = vstart<br>&gt;     <br>&gt;     while test(current) &amp;&amp; block(current)<br>&gt;     {<br>&gt;         current = current + vstep<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; /// X,Y 2D matrix (table) iterator with generic parameters<br>&gt; func iterate2D&lt;T:NumericType&gt; (<br>&gt;      xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;    _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;    _ block: (T,T) -&gt; Bool )<br>&gt; {<br>&gt;     var xcurrent = xstart<br>&gt;     var ycurrent = ystart<br>&gt;     <br>&gt;     var dontStop = true<br>&gt;     <br>&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;     {<br>&gt;         ycurrent = ystart<br>&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;         {<br>&gt;             dontStop = block(xcurrent, ycurrent)<br>&gt;             ycurrent = ycurrent + ystep<br>&gt;         }<br>&gt;         xcurrent = xcurrent + xstep<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; /// X,Y,Z 3D (cubic) iterator with generic parameters:<br>&gt; <br>&gt; func iterate3D&lt;T:NumericType&gt; (<br>&gt;     xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;   _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;   _ zstart:  T,  _ zstep: T, _ ztest: (T) -&gt; Bool,<br>&gt;       _ block: (T,T,T) -&gt; Bool )<br>&gt; {<br>&gt;     var xcurrent = xstart<br>&gt;     var ycurrent = ystart<br>&gt;     var zcurrent = zstart<br>&gt;     <br>&gt;     var dontStop = true<br>&gt;     <br>&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;     {<br>&gt;         ycurrent = ystart<br>&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;         {<br>&gt;             zcurrent = zstart<br>&gt;             while ztest(zcurrent) &amp;&amp; dontStop<br>&gt;             {<br>&gt;                 dontStop = block(xcurrent, ycurrent, zcurrent)<br>&gt;                 zcurrent = zcurrent + zstep<br>&gt;             }<br>&gt;             ycurrent = ycurrent + ystep<br>&gt;         }<br>&gt;         xcurrent = xcurrent + xstep<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; func testIterator()<br>&gt; {<br>&gt;     iterate(0.0, 0.5, {$0 &lt; 1000.00000} ,<br>&gt;             { value in<br>&gt;                 print(&quot;Value = \(value) &quot;)<br>&gt;                 return true<br>&gt;     } )<br>&gt; <br>&gt;     let startv: CGFloat = -20.0<br>&gt;     let stepv: CGFloat =   0.5<br>&gt;     <br>&gt;     iterate(startv, stepv, {$0 &lt; 1000.00000} ,<br>&gt;             { val in<br>&gt;                 print(&quot;R = \(val)&quot;)<br>&gt;                 return true<br>&gt;     } )<br>&gt; <br>&gt;     let tolerance = 0.01 // boundary tolerance for floating point type<br>&gt;     <br>&gt;     iterate2D( 0.0, 10.0, { $0 &lt; 100.0 + tolerance } ,<br>&gt;                0.0,  5.0, { $0 &lt;  50.0 + tolerance } ,<br>&gt;                {x,y in<br>&gt;                 print(&quot;x = \(x) y = \(y)&quot;)<br>&gt;                 return true  // false from block stops iterating ( like break)<br>&gt;                 } )<br>&gt; <br>&gt;     iterate3D( 0.0,  10.0, { $0 &lt;   30.0 } ,  // x<br>&gt;                0.0,   5.0, { $0 &lt;   20.0 } ,  // y<br>&gt;                10.0, -5.0, { $0 &gt;  -10.0 } ,  // z<br>&gt;                {x,y,z in<br>&gt;                     print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>&gt;                     if z &lt; 0.0<br>&gt;                     {<br>&gt;                         print ( &quot;** z value \(z) is below zero! **&quot; )<br>&gt;                         <br>&gt;                         return false  // (acts as break in for;;)<br>&gt;                     }<br>&gt;                     return true  // return stmt is obligatory (continue)<br>&gt;                } )<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/ea3a47c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 31.07.2016, at 04:28, jaden.geller at gmail.com wrote:<br>&gt; <br>&gt; What benefit do Iterator2D and Iterator3D provide that nesting does not?<br>Hi Jaden,<br>well, simply because of hiding/enclosing repetitive functionality<br>like with every other programming element is convenient,<br>prevents errors and from writing the same over and over again.<br>That is why there are functions.<br>but you already know that, of course.<br>Kind Regards<br>TedvG<br></p><p>&gt; <br>&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; thanks for the tip about Hirundo app!<br>&gt;&gt; <br>&gt;&gt; A positive side-effect of removing the classical for;; loop<br>&gt;&gt;  (yes, it’s me saying this :o)  is that it forces me to find<br>&gt;&gt; a good and generic equivalent for it, <br>&gt;&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt;&gt; which is *not* based on collections or sequences and<br>&gt;&gt; does not rely on deeper calls to Sequence etc.<br>&gt;&gt; <br>&gt;&gt; so, I’ve made the functions [iterator, iterator2D, iterator3D]  (hereunder)<br>&gt;&gt; wich btw clearly demonstrate the power and flexibility of Swift. <br>&gt;&gt; <br>&gt;&gt; Very straightforward, and efficient (i assume) just like the classical for;; loop.  <br>&gt;&gt; It works quite well in my sources.<br>&gt;&gt; <br>&gt;&gt; As a spin-off,  I’ve extended these to iterators for matrices 2D and cubes? 3D...<br>&gt;&gt; <br>&gt;&gt; Question: <br>&gt;&gt; Perhaps implementing “multi dimensional iterator functions<br>&gt;&gt; in Swift might  be a good idea. so that is no longer necessary to nest/nest/nest iterators. <br>&gt;&gt; <br>&gt;&gt; Met vriendelijke groeten, sorry for my “intensity” in discussing the classical for;; <br>&gt;&gt; I&#39;ll have to rethink this for;; again..  <br>&gt;&gt; Thanks, Ted.<br>&gt;&gt; <br>&gt;&gt; Any remarks ( all ), suggestions about the code hereunder:              ? <br>&gt;&gt; <br>&gt;&gt; protocol NumericType<br>&gt;&gt; {<br>&gt;&gt;     func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     func -(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     func /(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     func %(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Double : NumericType { }<br>&gt;&gt; extension Float  : NumericType { }<br>&gt;&gt; extension CGFloat: NumericType { }<br>&gt;&gt; extension Int    : NumericType { }<br>&gt;&gt; extension Int8   : NumericType { }<br>&gt;&gt; extension Int16  : NumericType { }<br>&gt;&gt; extension Int32  : NumericType { }<br>&gt;&gt; extension Int64  : NumericType { }<br>&gt;&gt; extension UInt   : NumericType { }<br>&gt;&gt; extension UInt8  : NumericType { }<br>&gt;&gt; extension UInt16 : NumericType { }<br>&gt;&gt; extension UInt32 : NumericType { }<br>&gt;&gt; extension UInt64 : NumericType { }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /// Simple iterator with generic parameters, with just a few lines of code.<br>&gt;&gt; /// for most numeric types (see above)<br>&gt;&gt; /// Usage Example:<br>&gt;&gt; ///<br>&gt;&gt; ///   iterate(xmax, { $0 &gt; xmin}, -xstep,<br>&gt;&gt; ///    {x in<br>&gt;&gt; ///        print(&quot;x = \(x)&quot;)<br>&gt;&gt; ///        return true  // returning false acts like a break<br>&gt;&gt; ///     } )<br>&gt;&gt; ///<br>&gt;&gt; ///  -Parameter vstart: Initial value<br>&gt;&gt; ///  -Parameter step:    The iteration stepping value.<br>&gt;&gt; ///  -Parameter test:    A block with iteration test. e.g. {$0 &gt; 10}<br>&gt;&gt; ///<br>&gt;&gt; ///  -Parameter block:   A block to be executed with each step.<br>&gt;&gt; ///       The block must include a return true (acts like &quot;continue&quot;)<br>&gt;&gt; ///                                   or false (acts like &quot;break&quot;)<br>&gt;&gt; ///  -Please Note: <br>&gt;&gt; ///  There is minor precision loss ca: 1/1000 ... 1/500 <br>&gt;&gt; ///  when iterating with floating point numbers.<br>&gt;&gt; ///  However, in most cases this can be safely ignored.<br>&gt;&gt; ///  made by ted van gaalen.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func iterate&lt;T:NumericType&gt; (<br>&gt;&gt;                     vstart:  T,<br>&gt;&gt;                    _ vstep:  T,<br>&gt;&gt;                    _  test: (T) -&gt; Bool,<br>&gt;&gt;                    _ block: (T) -&gt; Bool )<br>&gt;&gt; {<br>&gt;&gt;     var current = vstart<br>&gt;&gt;     <br>&gt;&gt;     while test(current) &amp;&amp; block(current)<br>&gt;&gt;     {<br>&gt;&gt;         current = current + vstep<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /// X,Y 2D matrix (table) iterator with generic parameters<br>&gt;&gt; func iterate2D&lt;T:NumericType&gt; (<br>&gt;&gt;      xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;    _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;    _ block: (T,T) -&gt; Bool )<br>&gt;&gt; {<br>&gt;&gt;     var xcurrent = xstart<br>&gt;&gt;     var ycurrent = ystart<br>&gt;&gt;     <br>&gt;&gt;     var dontStop = true<br>&gt;&gt;     <br>&gt;&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;     {<br>&gt;&gt;         ycurrent = ystart<br>&gt;&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;         {<br>&gt;&gt;             dontStop = block(xcurrent, ycurrent)<br>&gt;&gt;             ycurrent = ycurrent + ystep<br>&gt;&gt;         }<br>&gt;&gt;         xcurrent = xcurrent + xstep<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /// X,Y,Z 3D (cubic) iterator with generic parameters:<br>&gt;&gt; <br>&gt;&gt; func iterate3D&lt;T:NumericType&gt; (<br>&gt;&gt;     xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;   _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;   _ zstart:  T,  _ zstep: T, _ ztest: (T) -&gt; Bool,<br>&gt;&gt;       _ block: (T,T,T) -&gt; Bool )<br>&gt;&gt; {<br>&gt;&gt;     var xcurrent = xstart<br>&gt;&gt;     var ycurrent = ystart<br>&gt;&gt;     var zcurrent = zstart<br>&gt;&gt;     <br>&gt;&gt;     var dontStop = true<br>&gt;&gt;     <br>&gt;&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;     {<br>&gt;&gt;         ycurrent = ystart<br>&gt;&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;         {<br>&gt;&gt;             zcurrent = zstart<br>&gt;&gt;             while ztest(zcurrent) &amp;&amp; dontStop<br>&gt;&gt;             {<br>&gt;&gt;                 dontStop = block(xcurrent, ycurrent, zcurrent)<br>&gt;&gt;                 zcurrent = zcurrent + zstep<br>&gt;&gt;             }<br>&gt;&gt;             ycurrent = ycurrent + ystep<br>&gt;&gt;         }<br>&gt;&gt;         xcurrent = xcurrent + xstep<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func testIterator()<br>&gt;&gt; {<br>&gt;&gt;     iterate(0.0, 0.5, {$0 &lt; 1000.00000} ,<br>&gt;&gt;             { value in<br>&gt;&gt;                 print(&quot;Value = \(value) &quot;)<br>&gt;&gt;                 return true<br>&gt;&gt;     } )<br>&gt;&gt; <br>&gt;&gt;     let startv: CGFloat = -20.0<br>&gt;&gt;     let stepv: CGFloat =   0.5<br>&gt;&gt;     <br>&gt;&gt;     iterate(startv, stepv, {$0 &lt; 1000.00000} ,<br>&gt;&gt;             { val in<br>&gt;&gt;                 print(&quot;R = \(val)&quot;)<br>&gt;&gt;                 return true<br>&gt;&gt;     } )<br>&gt;&gt; <br>&gt;&gt;     let tolerance = 0.01 // boundary tolerance for floating point type<br>&gt;&gt;     <br>&gt;&gt;     iterate2D( 0.0, 10.0, { $0 &lt; 100.0 + tolerance } ,<br>&gt;&gt;                0.0,  5.0, { $0 &lt;  50.0 + tolerance } ,<br>&gt;&gt;                {x,y in<br>&gt;&gt;                 print(&quot;x = \(x) y = \(y)&quot;)<br>&gt;&gt;                 return true  // false from block stops iterating ( like break)<br>&gt;&gt;                 } )<br>&gt;&gt; <br>&gt;&gt;     iterate3D( 0.0,  10.0, { $0 &lt;   30.0 } ,  // x<br>&gt;&gt;                0.0,   5.0, { $0 &lt;   20.0 } ,  // y<br>&gt;&gt;                10.0, -5.0, { $0 &gt;  -10.0 } ,  // z<br>&gt;&gt;                {x,y,z in<br>&gt;&gt;                     print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>&gt;&gt;                     if z &lt; 0.0<br>&gt;&gt;                     {<br>&gt;&gt;                         print ( &quot;** z value \(z) is below zero! **&quot; )<br>&gt;&gt;                         <br>&gt;&gt;                         return false  // (acts as break in for;;)<br>&gt;&gt;                     }<br>&gt;&gt;                     return true  // return stmt is obligatory (continue)<br>&gt;&gt;                } )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160731/8b8b51c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Jaden Geller: What benefit do Iterator2D and Iterator3D provide that nesting does not?<br>&gt; <br>&gt; Ted F.A. van Gaalen:  well, simply because of hiding/enclosing repetitive functionality like with every other programming element is convenient, prevents errors and from writing the same over and over again.<br></p><p>I’m not sure why you’re trying to avoid sequences - as far as the actual values you are iterating over, your needs seem to be pretty well covered by the existing stride() family.<br></p><p>Given that you just want to flatten the call sites, perhaps something like this would suit your needs:<br></p><p>let xrange = stride(from:  0.0, to: 30.0, by: 10.0)<br>let yrange = stride(from:  0.0, to: 20.0, by: 5.0)<br>let zrange = stride(from: 10.0, to:-10.0, by:-5.0)<br></p><p>for (x, y, z) in cartesianProduct(xrange, yrange, zrange) {<br>    print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>    if z &lt; 0.0 {<br>        print ( &quot;** z value \(z) is below zero! **&quot; )<br>        break<br>    }<br>}<br>Using strides removes the need for any of the NumericType labels, and cartesianProduct() would be usable for any (reiterable) sequences, not just your designated types. <br></p><p>If you want a language issue to obsess over, I suggest the inflexibility of tuples, which force you to have a separate wrapper for each number of dimensions. :-)<br></p><p>I would have thought there’d be an off-the-shelf cartesian product somewhere that you could use, but it doesn’t seem to come up in the Google. It’d look something like this. (This is causing a compiler crash in Xcode 8b3 and so is not completely vetted, but it’s probably close…)<br></p><p>func cartesianProduct&lt;U, V where U: Sequence, V == U.Iterator.Element&gt;(_ args: U...) -&gt;<br>    AnyIterator&lt;[V]&gt;<br>{<br>    var iterators = args.map { $0.makeIterator() }<br>    var values = [V?]()<br>    for i in 0 ... iterators.endIndex {<br>        values.append(iterators[i].next())<br>    }<br>    var done = values.contains { $0 == nil }<br>    <br>    return AnyIterator() {<br>        if done {<br>            return nil<br>        }<br>        let thisValue = values.map { $0! }<br>        var i = args.endIndex<br>        repeat {<br>            values[i] = iterators[i].next()<br>            if values[i] != nil {<br>                return thisValue<br>            } else if i == 0 {<br>                done = true<br>                return thisValue<br>            } else {<br>                iterators[i] = args[i].makeIterator()<br>                values[i] = iterators[i].next()<br>                i -= 1<br>            }<br>        } while true<br>    }<br>}<br></p><p>func cartesianProduct&lt;U, V where U: Sequence, V == U.Iterator.Element&gt;(_ a: U, _ b: U, _ c: U) -&gt;<br>    AnyIterator&lt;(V, V, V)&gt;<br>{<br>    var subIterator: AnyIterator&lt;[V]&gt; = cartesianProduct(a, b, c)<br>    return AnyIterator() {<br>        if let value = subIterator.next() {<br>            return (value[0], value[1], value[2])<br>        }<br>        return nil<br>    }<br>}<br>Garth<br></p><p><br>&gt; That is why there are functions.<br>&gt; but you already know that, of course.<br>&gt; Kind Regards<br>&gt; TedvG<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; thanks for the tip about Hirundo app!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A positive side-effect of removing the classical for;; loop<br>&gt;&gt;&gt;  (yes, it’s me saying this :o)  is that it forces me to find<br>&gt;&gt;&gt; a good and generic equivalent for it, <br>&gt;&gt;&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt;&gt;&gt; which is *not* based on collections or sequences and<br>&gt;&gt;&gt; does not rely on deeper calls to Sequence etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; so, I’ve made the functions [iterator, iterator2D, iterator3D]  (hereunder)<br>&gt;&gt;&gt; wich btw clearly demonstrate the power and flexibility of Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Very straightforward, and efficient (i assume) just like the classical for;; loop.  <br>&gt;&gt;&gt; It works quite well in my sources.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a spin-off,  I’ve extended these to iterators for matrices 2D and cubes? 3D...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Question: <br>&gt;&gt;&gt; Perhaps implementing “multi dimensional iterator functions<br>&gt;&gt;&gt; in Swift might  be a good idea. so that is no longer necessary to nest/nest/nest iterators. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Met vriendelijke groeten, sorry for my “intensity” in discussing the classical for;; <br>&gt;&gt;&gt; I&#39;ll have to rethink this for;; again..  <br>&gt;&gt;&gt; Thanks, Ted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any remarks ( all ), suggestions about the code hereunder:              ? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol NumericType<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     func -(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     func /(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     func %(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Double : NumericType { }<br>&gt;&gt;&gt; extension Float  : NumericType { }<br>&gt;&gt;&gt; extension CGFloat: NumericType { }<br>&gt;&gt;&gt; extension Int    : NumericType { }<br>&gt;&gt;&gt; extension Int8   : NumericType { }<br>&gt;&gt;&gt; extension Int16  : NumericType { }<br>&gt;&gt;&gt; extension Int32  : NumericType { }<br>&gt;&gt;&gt; extension Int64  : NumericType { }<br>&gt;&gt;&gt; extension UInt   : NumericType { }<br>&gt;&gt;&gt; extension UInt8  : NumericType { }<br>&gt;&gt;&gt; extension UInt16 : NumericType { }<br>&gt;&gt;&gt; extension UInt32 : NumericType { }<br>&gt;&gt;&gt; extension UInt64 : NumericType { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Simple iterator with generic parameters, with just a few lines of code.<br>&gt;&gt;&gt; /// for most numeric types (see above)<br>&gt;&gt;&gt; /// Usage Example:<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; ///   iterate(xmax, { $0 &gt; xmin}, -xstep,<br>&gt;&gt;&gt; ///    {x in<br>&gt;&gt;&gt; ///        print(&quot;x = \(x)&quot;)<br>&gt;&gt;&gt; ///        return true  // returning false acts like a break<br>&gt;&gt;&gt; ///     } )<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; ///  -Parameter vstart: Initial value<br>&gt;&gt;&gt; ///  -Parameter step:    The iteration stepping value.<br>&gt;&gt;&gt; ///  -Parameter test:    A block with iteration test. e.g. {$0 &gt; 10}<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; ///  -Parameter block:   A block to be executed with each step.<br>&gt;&gt;&gt; ///       The block must include a return true (acts like &quot;continue&quot;)<br>&gt;&gt;&gt; ///                                   or false (acts like &quot;break&quot;)<br>&gt;&gt;&gt; ///  -Please Note: <br>&gt;&gt;&gt; ///  There is minor precision loss ca: 1/1000 ... 1/500 <br>&gt;&gt;&gt; ///  when iterating with floating point numbers.<br>&gt;&gt;&gt; ///  However, in most cases this can be safely ignored.<br>&gt;&gt;&gt; ///  made by ted van gaalen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func iterate&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;                     vstart:  T,<br>&gt;&gt;&gt;                    _ vstep:  T,<br>&gt;&gt;&gt;                    _  test: (T) -&gt; Bool,<br>&gt;&gt;&gt;                    _ block: (T) -&gt; Bool )<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     var current = vstart<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     while test(current) &amp;&amp; block(current)<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         current = current + vstep<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// X,Y 2D matrix (table) iterator with generic parameters<br>&gt;&gt;&gt; func iterate2D&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;      xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;&gt;    _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;&gt;    _ block: (T,T) -&gt; Bool )<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     var xcurrent = xstart<br>&gt;&gt;&gt;     var ycurrent = ystart<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var dontStop = true<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         ycurrent = ystart<br>&gt;&gt;&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;         {<br>&gt;&gt;&gt;             dontStop = block(xcurrent, ycurrent)<br>&gt;&gt;&gt;             ycurrent = ycurrent + ystep<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         xcurrent = xcurrent + xstep<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// X,Y,Z 3D (cubic) iterator with generic parameters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func iterate3D&lt;T:NumericType&gt; (<br>&gt;&gt;&gt;     xstart:  T,  _ xstep: T, _ xtest: (T) -&gt; Bool,<br>&gt;&gt;&gt;   _ ystart:  T,  _ ystep: T, _ ytest: (T) -&gt; Bool,<br>&gt;&gt;&gt;   _ zstart:  T,  _ zstep: T, _ ztest: (T) -&gt; Bool,<br>&gt;&gt;&gt;       _ block: (T,T,T) -&gt; Bool )<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     var xcurrent = xstart<br>&gt;&gt;&gt;     var ycurrent = ystart<br>&gt;&gt;&gt;     var zcurrent = zstart<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var dontStop = true<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     while xtest(xcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;     {<br>&gt;&gt;&gt;         ycurrent = ystart<br>&gt;&gt;&gt;         while ytest(ycurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;         {<br>&gt;&gt;&gt;             zcurrent = zstart<br>&gt;&gt;&gt;             while ztest(zcurrent) &amp;&amp; dontStop<br>&gt;&gt;&gt;             {<br>&gt;&gt;&gt;                 dontStop = block(xcurrent, ycurrent, zcurrent)<br>&gt;&gt;&gt;                 zcurrent = zcurrent + zstep<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             ycurrent = ycurrent + ystep<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         xcurrent = xcurrent + xstep<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func testIterator()<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;     iterate(0.0, 0.5, {$0 &lt; 1000.00000} ,<br>&gt;&gt;&gt;             { value in<br>&gt;&gt;&gt;                 print(&quot;Value = \(value) &quot;)<br>&gt;&gt;&gt;                 return true<br>&gt;&gt;&gt;     } )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let startv: CGFloat = -20.0<br>&gt;&gt;&gt;     let stepv: CGFloat =   0.5<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     iterate(startv, stepv, {$0 &lt; 1000.00000} ,<br>&gt;&gt;&gt;             { val in<br>&gt;&gt;&gt;                 print(&quot;R = \(val)&quot;)<br>&gt;&gt;&gt;                 return true<br>&gt;&gt;&gt;     } )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let tolerance = 0.01 // boundary tolerance for floating point type<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     iterate2D( 0.0, 10.0, { $0 &lt; 100.0 + tolerance } ,<br>&gt;&gt;&gt;                0.0,  5.0, { $0 &lt;  50.0 + tolerance } ,<br>&gt;&gt;&gt;                {x,y in<br>&gt;&gt;&gt;                 print(&quot;x = \(x) y = \(y)&quot;)<br>&gt;&gt;&gt;                 return true  // false from block stops iterating ( like break)<br>&gt;&gt;&gt;                 } )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     iterate3D( 0.0,  10.0, { $0 &lt;   30.0 } ,  // x<br>&gt;&gt;&gt;                0.0,   5.0, { $0 &lt;   20.0 } ,  // y<br>&gt;&gt;&gt;                10.0, -5.0, { $0 &gt;  -10.0 } ,  // z<br>&gt;&gt;&gt;                {x,y,z in<br>&gt;&gt;&gt;                     print(&quot;x = \(x) y = \(y) z = \(z)&quot;)<br>&gt;&gt;&gt;                     if z &lt; 0.0<br>&gt;&gt;&gt;                     {<br>&gt;&gt;&gt;                         print ( &quot;** z value \(z) is below zero! **&quot; )<br>&gt;&gt;&gt;                         <br>&gt;&gt;&gt;                         return false  // (acts as break in for;;)<br>&gt;&gt;&gt;                     }<br>&gt;&gt;&gt;                     return true  // return stmt is obligatory (continue)<br>&gt;&gt;&gt;                } )<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160731/96bc651a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; thanks for the tip about Hirundo app!<br>&gt; <br>&gt; A positive side-effect of removing the classical for;; loop<br>&gt;  (yes, it’s me saying this :o)  is that it forces me to find<br>&gt; a good and generic equivalent for it, <br>&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt; which is *not* based on collections or sequences and<br>&gt; does not rely on deeper calls to Sequence etc.<br></p><p>Hi Ted,<br></p><p>I know that you’re very passionate about the removal of C style for loops, but any direction to add back features to compensate for them will need to wait until Stage 2 of Swift 4’s planning cycle.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>Multi dimensional - iterator, Iterator2D, Iterator3D</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>July 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 31.07.2016, at 07:07, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 30, 2016, at 1:48 PM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; thanks for the tip about Hirundo app!<br>&gt;&gt; <br>&gt;&gt; A positive side-effect of removing the classical for;; loop<br>&gt;&gt; (yes, it’s me saying this :o)  is that it forces me to find<br>&gt;&gt; a good and generic equivalent for it, <br>&gt;&gt; making the conversion of my for;;s to 3.0 easier.<br>&gt;&gt; which is *not* based on collections or sequences and<br>&gt;&gt; does not rely on deeper calls to Sequence etc.<br>&gt; <br>&gt; Hi Ted,<br>&gt; <br>&gt; I know that you’re very passionate about the removal of C style for loops,<br></p><p>Hi Chris,<br></p><p>I am trying to channel my sometimes chaotic energy into positive things,<br>which means I should not have only criticism, but try<br>to find positive alternatives and suggestions for the things <br>that I don’t like.<br></p><p>&gt; but any direction to add back features to compensate for them will need to wait until Stage 2 of Swift 4’s planning cycle.<br>Yes, of course, I understand that. Forgot to mention that.<br>It is more intended as to viewing aspects of iteration in general.<br></p><p>The code example was initially intended as a convenience “workaround” <br>(usable without any alterations in Swift 2.x and higher) <br>for those of us who are using the for;; frequently,<br></p><p>However, I for me find it now even better then just a workaround <br>especially for 2 and 3D iterations. <br></p><p>So it could be that I won’t miss the for;; that much as I thought.<br>as the power and  flexibility of Swift mostly allows us to add <br>own extensions as alternative solutions when desired<br>and that is very cool!<br></p><p>Kind Regards<br>TedvG<br></p><p>(Note that that my biggest challenge in life is to coordinate <br>the chaos that always storms in my mind due to heavy <br>ADHD aspects (which also have advantages)<br>and to communicate with “other lifeforms”  <br>like human beings because of that.)<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
