<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>August  4, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Aug 04 2016, Manav Gabhawala &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; &gt; I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is<br>&gt;&gt; &gt; being able to index the values using a variable. The tuple.i<br>&gt;&gt; &gt; notation apparently doesn&#39;t work (or I did not try hard<br>&gt;&gt; &gt; enough). Also, for low-level things that will be mapped to GPU<br>&gt;&gt; &gt; memory, precise/predictable/settable alignment is needed. <br>&gt;<br>&gt; This might be a bit hacky but I just wanted to point out there exists<br>&gt; a way to index into tuples.  You can use the Mirror(reflecting:<br>&gt; tuple).children syntax. You can loop over the values of the tuple and<br>&gt; even though a bit awkward you can even use indices to index into the<br>&gt; children.<br></p><p>True, but the inefficiency of that approach pretty much defeats the<br>purpose of having a fixed-sized array.<br></p><p>&gt;<br>&gt; Regards,<br>&gt; Manav Gabhawala<br>&gt;<br>&gt; On August 4, 2016 at 5:18:13 AM, James Froggatt via swift-evolution<br>&gt; (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) wrote:<br>&gt;<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; On 4 Aug 2016, at 13:00, Raphael Sebbe wrote:<br>&gt;&gt;  <br>&gt;&gt; &gt; Thank you Chris, James.  <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; I&#39;m answering James feedback/questions below.<br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; On Thu, Aug 4, 2016 at 1:57 AM James Froggatt wrote:  <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; &gt; What are your thoughts on using tuples for this?  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; typealias CGPoint4 = (CGPoint, CGPoint, CGPoint, CGPoint)  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; struct Quad { var corners: CGPoint4 }  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; var fixedLength = (point1, point2, point3, point4)  <br>&gt;&gt; &gt; &gt; print(fixedLength.0)<br>&gt;&gt; &gt; &gt; print(fixedLength.4) //compiler error, not an element of the tuple<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; With shorthand declaration syntax, this would have the benefits<br>&gt;&gt; &gt; &gt; of a fixed-length array with added compile-time safety. A<br>&gt;&gt; &gt; &gt; previously suggested syntax was along the lines of &#39;(CGPoint *<br>&gt;&gt; &gt; &gt; 4)&#39;.<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is<br>&gt;&gt; &gt; being able to index the values using a variable. The tuple.i<br>&gt;&gt; &gt; notation apparently doesn&#39;t work (or I did not try hard<br>&gt;&gt; &gt; enough). Also, for low-level things that will be mapped to GPU<br>&gt;&gt; &gt; memory, precise/predictable/settable alignment is needed.<br>&gt;&gt;  <br>&gt;&gt; Good point. A similar mechanism might be possible eventually for<br>&gt;&gt; tuples, but right now this isn&#39;t possible.<br>&gt;&gt; &gt; &gt; &gt; 4. Reference/pointer to structs: accessing &amp; modifying structs<br>&gt;&gt; &gt; &gt; &gt; deep into the model currently requires fully qualified path to<br>&gt;&gt; &gt; &gt; &gt; the struct instance. Fully qualifying an inner struct in your<br>&gt;&gt; &gt; &gt; &gt; data model can be very tedious, depending on model complexity.<br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt; For instance, with scoped access solutions made with Swift 3,<br>&gt;&gt; &gt; &gt; &gt; you need to cascade blocks if you need to access multiple<br>&gt;&gt; &gt; &gt; &gt; inner structs, which doesn&#39;t scale well as it creates code<br>&gt;&gt; &gt; &gt; &gt; pyramids:<br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt; scopedAccess(&amp;varA) {  <br>&gt;&gt; &gt; &gt; &gt; scopedAccess(&amp;varB) {  <br>&gt;&gt; &gt; &gt; &gt; // modify varA &amp; varB  <br>&gt;&gt; &gt; &gt; &gt; }  <br>&gt;&gt; &gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt; It&#39;s easily done in C/C++ using pointers/references. To make<br>&gt;&gt; &gt; &gt; &gt; that better, we&#39;d need some kind of language support IMO.<br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; Could this be generalised, maybe with a reference-semantic ‘property accessor’?  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; Example:  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; let get: () -&gt; Bool = #get(controller.view.isVisible)  <br>&gt;&gt; &gt; &gt; print(get())<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; let set: (Bool) -&gt; () = #set(controller.view.isVisible)  <br>&gt;&gt; &gt; &gt; set(true)<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; let accessor: Lens = #lens(controller.view.isVisible)  <br>&gt;&gt; &gt; &gt; print(accessor.value)<br>&gt;&gt; &gt; &gt; accessor.value = true<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; This would have the added bonus of also tracking the<br>&gt;&gt; &gt; &gt; reassignment of reference-type properties - in this example, if<br>&gt;&gt; &gt; &gt; &#39;view&#39; is reassigned, the referenced value is updated.<br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; Sounds good, I&#39;m not aware of this syntax. Will investigate, thanks.  <br>&gt;&gt;  <br>&gt;&gt; Sorry, I was suggesting a *possible* syntax. No such syntax<br>&gt;&gt; currently exists, though the functionality can be imitated with<br>&gt;&gt; closures:<br>&gt;&gt;  <br>&gt;&gt; let get: () -&gt; Bool = {controller.view.isVisible}  <br>&gt;&gt; print(get())<br>&gt;&gt;  <br>&gt;&gt; let set: (Bool) -&gt; () = {controller.view.isVisible = $0}  <br>&gt;&gt; set(true)<br>&gt;&gt;  <br>&gt;&gt; struct Lens {  <br>&gt;&gt; var get: () -&gt; T<br>&gt;&gt; var set: (T) -&gt; ()<br>&gt;&gt; var value: T { get { return get() } set { set(newValue) } }<br>&gt;&gt; }<br>&gt;&gt; let accessor: Lens = Lens(get: {controller.view.isVisible}, set:<br>&gt;&gt; {controller.view.visible = $0})<br>&gt;&gt; print(accessor.value)<br>&gt;&gt; accessor.value = true<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; It&#39;s a bit more verbose when creating the get-set accessor, and may<br>&gt;&gt; not perform optimally, but it&#39;s actually pretty functional.<br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt; 5. Memory / pointer access, including casting. It&#39;s too<br>&gt;&gt; &gt; &gt; &gt; verbose currently IMO when compared to C. Should be better<br>&gt;&gt; &gt; &gt; &gt; supported for a language that is also targeting low-level<br>&gt;&gt; &gt; &gt; &gt; (network, disk storage). A syntax that is both fast (like C)<br>&gt;&gt; &gt; &gt; &gt; and safe would be great.<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; Not familiar with low-level programming in Swift, but have you<br>&gt;&gt; &gt; &gt; considered creating domain-specific operators?<br>&gt;&gt; &gt; &gt; For example, I imagine something like &#39;UnsafeMutablePointer(v)&#39;<br>&gt;&gt; &gt; &gt; could be reduced to &#39;*v&#39;.<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; Do you mean operator is available only within a limited scope?<br>&gt;&gt; &gt; That would be interesting, because I don&#39;t want to pollute global<br>&gt;&gt; &gt; scope with such all-purpose operator. Sounds that I need to<br>&gt;&gt; &gt; investigate that as well.<br>&gt;&gt;  <br>&gt;&gt; If you have a specific module which performs this sort of operation<br>&gt;&gt; a lot, you can just declare the operator as internal. If it&#39;s needed<br>&gt;&gt; in several, making a separate module for the operators could be<br>&gt;&gt; preferable.<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous<br>&gt;&gt; &gt; &gt; &gt; flows, etc., but this has already been mentioned -&gt; cool!<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; I would like to see some ideas in this area.  <br>&gt;&gt; &gt; &gt; async/await never really clicked for me until I realised it&#39;s<br>&gt;&gt; &gt; &gt; just syntactic sugar - &#39;await&#39; actually ends the function, and<br>&gt;&gt; &gt; &gt; everything below is an implicit callback. Personally I feel like<br>&gt;&gt; &gt; &gt; Swift&#39;s trailing closure syntax makes callbacks lightweight<br>&gt;&gt; &gt; &gt; enough that this isn&#39;t so much of an issue. Something focusing<br>&gt;&gt; &gt; &gt; more on the memory-management and thread-safety aspects of<br>&gt;&gt; &gt; &gt; asynchronous code does seem useful in the context of Swift.<br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt;  <br>&gt;&gt; &gt; &gt; &gt;  <br>&gt;&gt; &gt; Sure thread-safety, atomicity features would be really nice &amp; useful.  <br>&gt;&gt; &gt;  <br>&gt;&gt; &gt; The one problem I have with closure syntax (trailing or not, I<br>&gt;&gt; &gt; like trailing too), is that when you chain a few of them, which is<br>&gt;&gt; &gt; pretty frequent is async programming, you end up with a closure<br>&gt;&gt; &gt; pyramid. It doesn&#39;t scale well beyond 2 or 3 levels.<br>&gt;&gt;  <br>&gt;&gt; Makes sense. _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
