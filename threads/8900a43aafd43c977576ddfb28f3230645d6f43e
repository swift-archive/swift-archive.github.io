<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>throws!</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>December  7, 2015 at 01:00:00am</p></header><div class="content"><p>For context, I just read this thread (that happened before I joined) which discusses the idea of having a variant of arithmetic which can throw on overflow:<br>https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html<br></p><p><br>I wonder if having a variant of ‘throws’ might allow this...  ‘throws!’ would act exactly like throws, but it could be called without ‘try’ (resulting in a crash  if it tries to throw).  Basically, any statement calling a function/operation with throws! would have the equivalent of an implicit ‘try!&#39; unless there is an actual ‘try’.<br></p><p>It would allow the following (assuming + is marked ‘throws!’):<br></p><p>	let x = 2 + 3  // No crash, No exception<br></p><p>	let y = try Int.max + 1 // Exception, but no crash<br></p><p>	let z = Int.max + 1 // Crash!<br></p><p>	let w = try? Int.max + 1 // nil<br></p><p>Similarly, the thread mentions the desire for a throwing forced unwrap operator, and I think this allows that as well. Assuming the force unwrap operator is marked &#39;throws!’:<br></p><p>	let x:Int? = nil<br>	<br>	let y = try x! // Exception, but no crash<br>	<br>	let z = x! // Crash!<br></p><p><br>Anyway, this is all of the top of my head, so I am sure there is some issue I am missing.  I am not entirely sure that this would allow more good than evil overall, but I do like that the ! in ‘throws!’ signifies danger.  In the cases above, it is being used to take something which already crashes now, and allow the programmer to catch an exception instead of that crash if they think to look for it.<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>throws!</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>This seems like reasonable feature for me. Combined with throwing subscripts (proposed in another thread), we could translate that into bounds checking as well:<br></p><p>&gt; let array = [1, 2, 3]<br>&gt; <br>&gt; let fifth = array[5] // traps<br>&gt; <br>&gt; let fifth = try? array[5] // nil<br></p><p>However, I&#39;m still trying to find a use case for catching such errors. Imagine you&#39;re making a GUI app (e.g. for iOS), and then write the following code:<br></p><p>&gt; do {<br>&gt; 	let fifth = try array[5]<br>&gt; } catch BoundsError {<br>&gt; 	// ???<br>&gt; }<br></p><p>or<br></p><p>&gt; let sum: Int = Int.max // assuming it has the max value by accident<br>&gt; <br>&gt; do {<br>&gt; 	sum += 1<br>&gt; } catch ArithmeticError {<br>&gt; 	// ???<br>&gt; }<br></p><p>What would you do in the catch clause?<br></p><p>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 07.12.2015, o godz. 10:29:<br>&gt; <br>&gt; For context, I just read this thread (that happened before I joined) which discusses the idea of having a variant of arithmetic which can throw on overflow:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html<br>&gt; <br>&gt; <br>&gt; I wonder if having a variant of ‘throws’ might allow this...  ‘throws!’ would act exactly like throws, but it could be called without ‘try’ (resulting in a crash  if it tries to throw).  Basically, any statement calling a function/operation with throws! would have the equivalent of an implicit ‘try!&#39; unless there is an actual ‘try’.<br>&gt; <br>&gt; It would allow the following (assuming + is marked ‘throws!’):<br>&gt; <br>&gt; 	let x = 2 + 3  // No crash, No exception<br>&gt; <br>&gt; 	let y = try Int.max + 1 // Exception, but no crash<br>&gt; <br>&gt; 	let z = Int.max + 1 // Crash!<br>&gt; <br>&gt; 	let w = try? Int.max + 1 // nil<br>&gt; <br>&gt; Similarly, the thread mentions the desire for a throwing forced unwrap operator, and I think this allows that as well. Assuming the force unwrap operator is marked &#39;throws!’:<br>&gt; <br>&gt; 	let x:Int? = nil<br>&gt; 	<br>&gt; 	let y = try x! // Exception, but no crash<br>&gt; 	<br>&gt; 	let z = x! // Crash!<br>&gt; <br>&gt; <br>&gt; Anyway, this is all of the top of my head, so I am sure there is some issue I am missing.  I am not entirely sure that this would allow more good than evil overall, but I do like that the ! in ‘throws!’ signifies danger.  In the cases above, it is being used to take something which already crashes now, and allow the programmer to catch an exception instead of that crash if they think to look for it.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c13c08c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>throws!</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>December  7, 2015 at 02:00:00am</p></header><div class="content"><p>You would display an error (in different ways depending on the UI &amp; error), which is much nicer than crashing on the user.  For example, in an app like Numbers, you would display a little warning icon in the cell instead of crashing.<br></p><p><br>&gt; On Dec 7, 2015, at 2:12 AM, Adrian Kashivskyy &lt;adrian.kashivskyy at me.com&gt; wrote:<br>&gt; <br>&gt; This seems like reasonable feature for me. Combined with throwing subscripts (proposed in another thread), we could translate that into bounds checking as well:<br>&gt; <br>&gt;&gt; let array = [1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; let fifth = array[5] // traps<br>&gt;&gt; <br>&gt;&gt; let fifth = try? array[5] // nil<br>&gt; <br>&gt; However, I&#39;m still trying to find a use case for catching such errors. Imagine you&#39;re making a GUI app (e.g. for iOS), and then write the following code:<br>&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	let fifth = try array[5]<br>&gt;&gt; } catch BoundsError {<br>&gt;&gt; 	// ???<br>&gt;&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt;&gt; let sum: Int = Int.max // assuming it has the max value by accident<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	sum += 1<br>&gt;&gt; } catch ArithmeticError {<br>&gt;&gt; 	// ???<br>&gt;&gt; }<br>&gt; <br>&gt; What would you do in the catch clause?<br>&gt; <br>&gt; Pozdrawiam – Regards,<br>&gt; Adrian Kashivskyy<br>&gt; <br>&gt;&gt; Wiadomość napisana przez Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; w dniu 07.12.2015, o godz. 10:29:<br>&gt;&gt; <br>&gt;&gt; For context, I just read this thread (that happened before I joined) which discusses the idea of having a variant of arithmetic which can throw on overflow:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000292.html&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I wonder if having a variant of ‘throws’ might allow this...  ‘throws!’ would act exactly like throws, but it could be called without ‘try’ (resulting in a crash  if it tries to throw).  Basically, any statement calling a function/operation with throws! would have the equivalent of an implicit ‘try!&#39; unless there is an actual ‘try’.<br>&gt;&gt; <br>&gt;&gt; It would allow the following (assuming + is marked ‘throws!’):<br>&gt;&gt; <br>&gt;&gt; 	let x = 2 + 3  // No crash, No exception<br>&gt;&gt; <br>&gt;&gt; 	let y = try Int.max + 1 // Exception, but no crash<br>&gt;&gt; <br>&gt;&gt; 	let z = Int.max + 1 // Crash!<br>&gt;&gt; <br>&gt;&gt; 	let w = try? Int.max + 1 // nil<br>&gt;&gt; <br>&gt;&gt; Similarly, the thread mentions the desire for a throwing forced unwrap operator, and I think this allows that as well. Assuming the force unwrap operator is marked &#39;throws!’:<br>&gt;&gt; <br>&gt;&gt; 	let x:Int? = nil<br>&gt;&gt; 	<br>&gt;&gt; 	let y = try x! // Exception, but no crash<br>&gt;&gt; 	<br>&gt;&gt; 	let z = x! // Crash!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Anyway, this is all of the top of my head, so I am sure there is some issue I am missing.  I am not entirely sure that this would allow more good than evil overall, but I do like that the ! in ‘throws!’ signifies danger.  In the cases above, it is being used to take something which already crashes now, and allow the programmer to catch an exception instead of that crash if they think to look for it.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/6be05bf2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>throws!</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:12 AM, Adrian Kashivskyy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This seems like reasonable feature for me. Combined with throwing subscripts (proposed in another thread), we could translate that into bounds checking as well:<br>&gt; <br>&gt;&gt; let array = [1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; let fifth = array[5] // traps<br>&gt;&gt; <br>&gt;&gt; let fifth = try? array[5] // nil<br>&gt; <br>&gt; However, I&#39;m still trying to find a use case for catching such errors. Imagine you&#39;re making a GUI app (e.g. for iOS), and then write the following code:<br>&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	let fifth = try array[5]<br>&gt;&gt; } catch BoundsError {<br>&gt;&gt; 	// ???<br>&gt;&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt;&gt; let sum: Int = Int.max // assuming it has the max value by accident<br>&gt;&gt; <br>&gt;&gt; do {<br>&gt;&gt; 	sum += 1<br>&gt;&gt; } catch ArithmeticError {<br>&gt;&gt; 	// ???<br>&gt;&gt; }<br>&gt; <br>&gt; What would you do in the catch clause?<br></p><p>There’s a common scenario where there are multiple algorithms that might be used to perform a computation:<br></p><p>	do {<br>		// fast algorithm that is usually correct by may overflow on rare inputs<br>	} catch ArithmeticError {<br>		// slow algorithm that can give correct result no matter what<br>	}<br></p><p>Note that it’s often *faster* to structure the computation this way than it is to try to inspect the inputs to ascertain whether or not the slow algorithm needs to be used before doing the work.<br></p><p>– Steve<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
