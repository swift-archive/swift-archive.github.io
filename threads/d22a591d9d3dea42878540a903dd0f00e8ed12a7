<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Optional dictionary subscripts</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>This isn’t the most compelling of ideas but a couple of times I’ve found myself writing:<br></p><p>if let value = key != nil ? dict[key] : nil {…<br></p><p>and was wondering if the syntax could be:<br></p><p>if let value = dict[key?] {…<br></p><p>The key for dictionaries could be made optional in stdlib but this is probably best implemented in the compiler for safety.<br></p><p>Cheers<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Optional dictionary subscripts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>if let key = key, value = dict[key] {<br>    ...whatever...<br>}<br></p><p>seems to work fine without introducing a new construct<br></p><p>-- E, waving hi to John <br></p><p><br>&gt; On Dec 22, 2015, at 4:37 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This isn’t the most compelling of ideas but a couple of times I’ve found myself writing:<br>&gt; <br>&gt; if let value = key != nil ? dict[key] : nil {…<br>&gt; <br>&gt; and was wondering if the syntax could be:<br>&gt; <br>&gt; if let value = dict[key?] {…<br>&gt; <br>&gt; The key for dictionaries could be made optional in stdlib but this is probably best implemented in the compiler for safety.<br>&gt; <br>&gt; Cheers<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Optional dictionary subscripts</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>if let value = map(key) { dict($0) }<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 13:00:45, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; if let key = key, value = dict[key] {<br>&gt;    ...whatever...<br>&gt; }<br>&gt; <br>&gt; seems to work fine without introducing a new construct<br>&gt; <br>&gt; -- E, waving hi to John <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 4:37 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This isn’t the most compelling of ideas but a couple of times I’ve found myself writing:<br>&gt;&gt; <br>&gt;&gt; if let value = key != nil ? dict[key] : nil {…<br>&gt;&gt; <br>&gt;&gt; and was wondering if the syntax could be:<br>&gt;&gt; <br>&gt;&gt; if let value = dict[key?] {…<br>&gt;&gt; <br>&gt;&gt; The key for dictionaries could be made optional in stdlib but this is probably best implemented in the compiler for safety.<br>&gt;&gt; <br>&gt;&gt; Cheers<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Optional dictionary subscripts</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>I think this would be the standard syntax:<br></p><p>if let value = key.map({ dict[$0] }) {<br></p><p>}<br></p><p>&gt; On Dec 22, 2015, at 10:33 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; if let value = map(key) { dict($0) }<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 13:00:45, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; if let key = key, value = dict[key] {<br>&gt;&gt;   ...whatever...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; seems to work fine without introducing a new construct<br>&gt;&gt; <br>&gt;&gt; -- E, waving hi to John <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 4:37 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t the most compelling of ideas but a couple of times I’ve found myself writing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let value = key != nil ? dict[key] : nil {…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and was wondering if the syntax could be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if let value = dict[key?] {…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The key for dictionaries could be made optional in stdlib but this is probably best implemented in the compiler for safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Optional dictionary subscripts</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; I think this would be the standard syntax:<br>&gt; <br>&gt; if let value = key.map({ dict[$0] }) {<br>&gt; <br>&gt; }<br></p><p>In this case, I think you actually want a flatMap, to merge the two `nil` cases instead of nesting them.<br></p><p>	if let value = key.flatMap({ dict[$0] }) {<br>		<br>	}<br></p><p>I wish that could be this, though:<br></p><p>	if let value = key.flatMap(dict.subscript) {<br>		<br>	}<br></p><p>In any case, I think two different approaches to do this (chained `if let` and `flatMap`) are probably enough; we don&#39;t need a third.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 22, 2016 at 05:00:00pm</p></header><div class="content"><p>I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>suggested in the very first week Swift was open sourced and before that in various radars.<br></p><p>https://github.com/apple/swift/pull/2275<br></p><p>The approach taken is as simple as possible defining multi-line strings as being<br>delimited by “”” instead of “ and thereafter able to contain new line characters.<br></p><p>There has been some discussion of this before on swift-evolution:<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br></p><p>I’m trying to avoid more advanced features such as the handling of indenting which<br>for me complicates something that if kept simple can be documented very easily.<br></p><p>This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br></p><p>Thoughts?<br></p><p>John<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 22, 2016 at 02:00:00pm</p></header><div class="content"><p>This doesn&#39;t provide very much flexibility. I&#39;d like to see something more like Perl6&#39;s quoting constructs: https://doc.perl6.org/language/quoting.<br></p><p>-Patrick<br></p><p>&gt; On Apr 22, 2016, at 12:59 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>&gt; suggested in the very first week Swift was open sourced and before that in various radars.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2275<br>&gt; <br>&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br>&gt; <br>&gt; There has been some discussion of this before on swift-evolution:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br>&gt; <br>&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt; <br>&gt; This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; John<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 22, 2016 at 07:00:00pm</p></header><div class="content"><p>As a long time user of Perl, for me the simplicity and lack of flexibility is the attraction<br>when it comes to “”” syntax ;) That’s a lot of documentation for just specifying a string.<br></p><p>Perl makes life difficult for itself due to it’s rather simplistic $var interpolation syntax<br>which means you frequently want an un-interpolated string literal. The situation is<br>far better in Swift with the more distinct \().<br></p><p>Can you think of anything that couldn’t be readily expressed using Python style “””?<br></p><p>John<br>&gt; On 22 Apr 2016, at 19:12, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; This doesn&#39;t provide very much flexibility. I&#39;d like to see something more like Perl6&#39;s quoting constructs: https://doc.perl6.org/language/quoting.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:59 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>&gt;&gt; suggested in the very first week Swift was open sourced and before that in various radars.<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt; <br>&gt;&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt;&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br>&gt;&gt; <br>&gt;&gt; There has been some discussion of this before on swift-evolution:<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br>&gt;&gt; <br>&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt;&gt; <br>&gt;&gt; This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27ca9066ad05bd8aa9ec366115f3cd38?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Kurt Werle</string> &lt;kurt at circlew.org&gt;<p>April 22, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Apr 22, 2016 at 11:48 AM, John Holdsworth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; As a long time user of Perl, for me the simplicity and lack of flexibility<br>&gt; is the attraction<br>&gt; when it comes to “”” syntax ;) That’s a lot of documentation for just<br>&gt; specifying a string.<br>&gt;<br></p><p>+1<br></p><p>-- <br>kurt at CircleW.org<br>http://www.CircleW.org/kurt/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/511f1cd9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 22, 2016 at 03:00:00pm</p></header><div class="content"><p>If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br></p><p>-Patrick<br></p><p>&gt; On Apr 22, 2016, at 2:48 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; As a long time user of Perl, for me the simplicity and lack of flexibility is the attraction<br>&gt; when it comes to “”” syntax ;) That’s a lot of documentation for just specifying a string.<br>&gt; <br>&gt; Perl makes life difficult for itself due to it’s rather simplistic $var interpolation syntax<br>&gt; which means you frequently want an un-interpolated string literal. The situation is<br>&gt; far better in Swift with the more distinct \().<br>&gt; <br>&gt; Can you think of anything that couldn’t be readily expressed using Python style “””?<br>&gt; <br>&gt; John<br>&gt;&gt; On 22 Apr 2016, at 19:12, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t provide very much flexibility. I&#39;d like to see something more like Perl6&#39;s quoting constructs: https://doc.perl6.org/language/quoting.<br>&gt;&gt; <br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 12:59 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>&gt;&gt;&gt; suggested in the very first week Swift was open sourced and before that in various radars.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt;&gt;&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There has been some discussion of this before on swift-evolution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 23, 2016 at 04:00:00am</p></header><div class="content"><p>Regex support certainly needs to be kept in mind. I can propose something a little different<br>on that front however that retains the existing simple literal syntax. Bear with me.<br></p><p>What if invalid escape sequences did not result in an error but were passed through to the string?<br>This is a very small change to the lexer.<br></p><p>For example:<br></p><p>&gt; print( “\w+[\w\d]+” )<br>\w+[\w\d]+<br></p><p>It’s easy for a developer to know there are only seven valid escapes \0, \r, \n, \”, \’, \\  and \u{NNNN}<br>so the error is not a particularly helpful one and these escapes do not overlap with regex syntax.<br></p><p>In this way you get the best of both worlds, minimalist string syntax and not have to write “\\w+[\\w\\d]+”<br></p><p>John<br></p><p>&gt; On 22 Apr 2016, at 20:54, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Apr 22, 2016, at 2:48 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a long time user of Perl, for me the simplicity and lack of flexibility is the attraction<br>&gt;&gt; when it comes to “”” syntax ;) That’s a lot of documentation for just specifying a string.<br>&gt;&gt; <br>&gt;&gt; Perl makes life difficult for itself due to it’s rather simplistic $var interpolation syntax<br>&gt;&gt; which means you frequently want an un-interpolated string literal. The situation is<br>&gt;&gt; far better in Swift with the more distinct \().<br>&gt;&gt; <br>&gt;&gt; Can you think of anything that couldn’t be readily expressed using Python style “””?<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt;&gt; On 22 Apr 2016, at 19:12, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn&#39;t provide very much flexibility. I&#39;d like to see something more like Perl6&#39;s quoting constructs: https://doc.perl6.org/language/quoting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 22, 2016, at 12:59 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>&gt;&gt;&gt;&gt; suggested in the very first week Swift was open sourced and before that in various radars.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt;&gt;&gt;&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There has been some discussion of this before on swift-evolution:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt;&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 23, 2016 at 01:00:00pm</p></header><div class="content"><p>This is oversimplifying the problem of escaping. Simply relaxing the grammar for the content of the string literal doesn&#39;t always work.<br></p><p>For example, a regular expression that detects a might be written &quot;\N*\n&quot;. If escaping is enabled, then the compiler changes &quot;\n&quot; into line feed, which does not have the same meaning to the regular expression engine as &quot;\n&quot;.<br></p><p>-Patrick<br></p><p>&gt; On Apr 22, 2016, at 11:13 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; Regex support certainly needs to be kept in mind. I can propose something a little different<br>&gt; on that front however that retains the existing simple literal syntax. Bear with me.<br>&gt; <br>&gt; What if invalid escape sequences did not result in an error but were passed through to the string?<br>&gt; This is a very small change to the lexer.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt;&gt; print( “\w+[\w\d]+” )<br>&gt; \w+[\w\d]+<br>&gt; <br>&gt; It’s easy for a developer to know there are only seven valid escapes \0, \r, \n, \”, \’, \\  and \u{NNNN}<br>&gt; so the error is not a particularly helpful one and these escapes do not overlap with regex syntax.<br>&gt; <br>&gt; In this way you get the best of both worlds, minimalist string syntax and not have to write “\\w+[\\w\\d]+”<br>&gt; <br>&gt; John<br>&gt; <br>&gt;&gt; On 22 Apr 2016, at 20:54, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br>&gt;&gt; <br>&gt;&gt; -Patrick<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 22, 2016, at 2:48 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a long time user of Perl, for me the simplicity and lack of flexibility is the attraction<br>&gt;&gt;&gt; when it comes to “”” syntax ;) That’s a lot of documentation for just specifying a string.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perl makes life difficult for itself due to it’s rather simplistic $var interpolation syntax<br>&gt;&gt;&gt; which means you frequently want an un-interpolated string literal. The situation is<br>&gt;&gt;&gt; far better in Swift with the more distinct \().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you think of anything that couldn’t be readily expressed using Python style “””?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt; On 22 Apr 2016, at 19:12, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This doesn&#39;t provide very much flexibility. I&#39;d like to see something more like Perl6&#39;s quoting constructs: https://doc.perl6.org/language/quoting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 22, 2016, at 12:59 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals as was<br>&gt;&gt;&gt;&gt;&gt; suggested in the very first week Swift was open sourced and before that in various radars.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt;&gt;&gt;&gt;&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There has been some discussion of this before on swift-evolution:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001565.html<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt;&gt;&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This change will require a evolution proposal so I’d like to take the pulse before I write it up.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 03:00:00pm</p></header><div class="content"><p>On Apr 22, 2016, at 12:54 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br></p><p>Wouldn’t the natural regex literal syntax be to enclose them in /’s, e.g.  /foo*/  ?<br></p><p>I don’t see how this proposal conflicts with that.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 25, 2016 at 07:00:00am</p></header><div class="content"><p>My thinking here was two-fold:<br>1) Address the need to accommodate the lack of regex literals today, and<br>2) Future-proof the proposal to accommodate the eventuality of regex literals.<br></p><p>-Patrick<br></p><p>&gt; On Apr 24, 2016, at 6:09 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 22, 2016, at 12:54 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br>&gt; <br>&gt; Wouldn’t the natural regex literal syntax be to enclose them in /’s, e.g.  /foo*/  ?<br>&gt; <br>&gt; I don’t see how this proposal conflicts with that.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>On Apr 25, 2016, at 4:55 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; My thinking here was two-fold:<br>&gt; 1) Address the need to accommodate the lack of regex literals today, and<br>&gt; 2) Future-proof the proposal to accommodate the eventuality of regex literals.<br></p><p>MHO is that regex literals are an essential feature for Swift to eventually have, but that they are a huge design project and completely separate from multi-line string literals.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 6:09 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 22, 2016, at 12:54 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; If we use a quoting structure similar to Perl6, then we future proof the grammar to accommodate regular expression literals (and multi-line regular expression literals) later. It also gives us the possibility for support for fine-grain control over escaping and interpolation.<br>&gt;&gt; <br>&gt;&gt; Wouldn’t the natural regex literal syntax be to enclose them in /’s, e.g.  /foo*/  ?<br>&gt;&gt; <br>&gt;&gt; I don’t see how this proposal conflicts with that.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals<br></p><p>Wow, it&#39;s pretty cool that this change is so surgical.<br></p><p>&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt; for me complicates something that if kept simple can be documented very easily.<br></p><p>I don&#39;t think you can tackle multiline strings without worrying about indenting. Indentation may fundamentally change the approach you choose.<br></p><p>I continue to believe that we&#39;re actually looking at three orthogonal features here:<br></p><p>* Multiline string literals<br>* Alternative string literal delimiters<br>* Disabling escapes in string literals<br></p><p>The way I would prefer to tackle these is:<br></p><p>* Multiline literals: If the closing quote of a string is not present, look at the next line. If it consists of (optional) indentation followed by a matching opening quote, the string has a newline and then continues after the quote on the next line. (The handling of comments is an open question here.)<br></p><p>	let xml: String = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>				&quot;&lt;catalog&gt;<br>				&quot;\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>				&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>				&quot;\t&lt;/book&gt;<br>				&quot;&lt;/catalog&gt;&quot;<br></p><p>The cool things about this are that (a) the compiler can tell you really do mean this to be part of the literal and you haven&#39;t just forgotten to close the string, and (b) there&#39;s no guesswork about how indentation should be handled. The uncool thing is that you need to insert the quote at the beginning of each line, so you can&#39;t just blindly paste into a multiline literal. Editors can help make that easier, though—a &quot;paste as string literal&quot; feature would be a nice addition to Xcode, and not just for multiline strings or just for Swift.<br></p><p>* Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br></p><p>	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>				&quot;&quot;&quot;&lt;catalog&gt;<br>				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>				&quot;&quot;&quot;\t&lt;/book&gt;<br>				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br></p><p>You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br></p><p>* Disabling escapes: If you use single quotes instead of double quotes, backslash escapes are disabled. (There is no escaping at all, not even \\ or \&#39;. If you need to include the delimiter, use a delimiter with more quote marks. I&#39;m not sure if this should disable interpolation; for now, I&#39;m assuming it should. If it doesn&#39;t disable interpolation, the only way to get a \( into the string would be by interpolating it in, not by escaping it somehow.)<br></p><p>	let xml: String = &#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>				&#39;&#39;&#39;&lt;catalog&gt;<br>				&#39;&#39;&#39;	&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>				&#39;&#39;&#39;		&lt;author&gt;&#39;&#39;&#39; + author + &#39;&#39;&#39;&lt;/author&gt;<br>				&#39;&#39;&#39;	&lt;/book&gt;<br>				&#39;&#39;&#39;&lt;/catalog&gt;&#39;&#39;&#39;<br></p><p>I&#39;m not sure if single quotes should allow interpolation. Options are:<br></p><p>* No, just concatenate (as shown above).<br>* Yes, with the ordinary syntax: &#39;&#39;&#39;		&lt;author&gt;\(author)&lt;/author&gt;<br>* Yes, with a number of backslashes matching the number of quotes, which allows you to insert literal \( text: &#39;&#39;&#39;		&lt;author&gt;\\\(author)&lt;/author&gt;<br></p><p>Note that you can use these features in any combination. I&#39;ve shown a few combinations above, but here are some others.<br></p><p>A single-line literal with an alternate delimiter:<br>	&quot;&quot;&quot;	&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;&quot;&quot;&quot;<br></p><p>The same thing, but no-escaping:<br>	&#39;&#39;&#39;	&lt;book id=&#39;bk101&#39; empty=&#39;&#39;&gt;&#39;&#39;&#39;<br></p><p>A no-escaping multiline literal with a normal delimiter:<br>	&#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	&#39;&lt;catalog /&gt;&#39;<br></p><p>* * *<br></p><p>Notes on alternatives:<br></p><p>1. If you wanted to not provide no-escaping strings, an alternative would be to say that *all* escapes require as many backslashes as there are quotes in the string delimiter. Thus, a newline escape in a `&quot;&quot;&quot;` string would be `\\\n`. This would in practice give you the same flexibility to write a literal without worrying (much) about escaping.<br></p><p>2. However, it&#39;s not entirely clear to me that we really need escapes other than interpolations at all. You could write &quot;\(.newline)&quot; or &quot;\(.doubleQuote)&quot; or &quot;\(.backslash)&quot; to get those characters. (These might be static members required by StringInterpolationConvertible.) Plain backslashes would have no special meaning at all; only &quot;\(&quot; would be special.<br></p><p>3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does. That would allow you to document things in literals. Then you would want `&#39;` again so that you could turn that smartness off. (Of course, the big problem here is that a naïve implementation would consider &quot;http://&quot; to have a comment at the end of it.)<br></p><p>* * *<br></p><p>Finally, a brief aside:<br></p><p>&gt; For example, a regular expression that detects a might be written &quot;\N*\n&quot;. If escaping is enabled, then the compiler changes &quot;\n&quot; into line feed, which does not have the same meaning to the regular expression engine as &quot;\n&quot;.<br></p><p>There is a special place in Hell reserved for authors of languages which use `\` as an escape character, provide no regex literals or non-escaping string literals, and ship with regex libraries which use `\` as a metacharacter. It&#39;s in the outer circles—Satan has some sense of perspective—but it&#39;s definitely there.<br></p><p>Sorry if that&#39;s not very constructive, but *man*, that burns my biscuits.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 23, 2016 at 11:00:00pm</p></header><div class="content"><p>Instead of creating yet another set of string quotation rules, I would prefer copy &amp; pasting the Perl 5 rules :)<br></p><p>let x = XMLDocument(&lt;&lt;END_OF_XML)<br>&lt;xml&gt;<br>  &lt;yes&gt;it works&lt;/yes&gt;<br>&lt;/xml&gt;<br>END_OF_XML<br></p><p>/* I think multiline literals should not consider indentation. If you want to have it formatted nicely, the editor should display a nice text box for you. Editors could do so much more than they are doing now, IMHO. I remember a time when editors refused to interoperate, because one file used a LF line style, while another editor used CRLF. Now, this is no longer a problem, and the reasons are better editors. Editors could also solve the Tabs- versus Spaces-issues or the { bracket styles }, by always keeping the style of the file intact, but displaying the style that the user likes to see. */<br></p><p>let y = q(if you want to use &quot; and &#39; and even &quot;&quot;&quot; in the string itself. You can also use (parenthesis), as long as you balance them properly. A single &quot;q&quot; at the beginning, so no string interpolation here.)<br></p><p>let z = qq/if you want string interpolation, you can have it. BTW x = $(x)/<br>let w: Array&lt;String&gt; = qw[this is an array of words]<br></p><p>m/regexes are a nice feature too/i<br>s{if you want to match slashes\(/\), just use another delimiter.}{yes, we can}g<br></p><p>-Michael<br></p><p>&gt; Am 23.04.2016 um 23:08 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; I’ve raised a speculative PR against the Swift Lexer to support multi-line string literals<br>&gt; <br>&gt; Wow, it&#39;s pretty cool that this change is so surgical.<br>&gt; <br>&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt; <br>&gt; I don&#39;t think you can tackle multiline strings without worrying about indenting. Indentation may fundamentally change the approach you choose.<br>&gt; <br>&gt; I continue to believe that we&#39;re actually looking at three orthogonal features here:<br>&gt; <br>&gt; * Multiline string literals<br>&gt; * Alternative string literal delimiters<br>&gt; * Disabling escapes in string literals<br>&gt; <br>&gt; The way I would prefer to tackle these is:<br>&gt; <br>&gt; * Multiline literals: If the closing quote of a string is not present, look at the next line. If it consists of (optional) indentation followed by a matching opening quote, the string has a newline and then continues after the quote on the next line. (The handling of comments is an open question here.)<br>&gt; <br>&gt; 	let xml: String = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; 				&quot;&lt;catalog&gt;<br>&gt; 				&quot;\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt; 				&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 				&quot;\t&lt;/book&gt;<br>&gt; 				&quot;&lt;/catalog&gt;&quot;<br>&gt; <br>&gt; The cool things about this are that (a) the compiler can tell you really do mean this to be part of the literal and you haven&#39;t just forgotten to close the string, and (b) there&#39;s no guesswork about how indentation should be handled. The uncool thing is that you need to insert the quote at the beginning of each line, so you can&#39;t just blindly paste into a multiline literal. Editors can help make that easier, though—a &quot;paste as string literal&quot; feature would be a nice addition to Xcode, and not just for multiline strings or just for Swift.<br>&gt; <br>&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt; <br>&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt; <br>&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt; <br>&gt; * Disabling escapes: If you use single quotes instead of double quotes, backslash escapes are disabled. (There is no escaping at all, not even \\ or \&#39;. If you need to include the delimiter, use a delimiter with more quote marks. I&#39;m not sure if this should disable interpolation; for now, I&#39;m assuming it should. If it doesn&#39;t disable interpolation, the only way to get a \( into the string would be by interpolating it in, not by escaping it somehow.)<br>&gt; <br>&gt; 	let xml: String = &#39;&#39;&#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 				&#39;&#39;&#39;&lt;catalog&gt;<br>&gt; 				&#39;&#39;&#39;	&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 				&#39;&#39;&#39;		&lt;author&gt;&#39;&#39;&#39; + author + &#39;&#39;&#39;&lt;/author&gt;<br>&gt; 				&#39;&#39;&#39;	&lt;/book&gt;<br>&gt; 				&#39;&#39;&#39;&lt;/catalog&gt;&#39;&#39;&#39;<br>&gt; <br>&gt; I&#39;m not sure if single quotes should allow interpolation. Options are:<br>&gt; <br>&gt; * No, just concatenate (as shown above).<br>&gt; * Yes, with the ordinary syntax: &#39;&#39;&#39;		&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; * Yes, with a number of backslashes matching the number of quotes, which allows you to insert literal \( text: &#39;&#39;&#39;		&lt;author&gt;\\\(author)&lt;/author&gt;<br>&gt; <br>&gt; Note that you can use these features in any combination. I&#39;ve shown a few combinations above, but here are some others.<br>&gt; <br>&gt; A single-line literal with an alternate delimiter:<br>&gt; 	&quot;&quot;&quot;	&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;&quot;&quot;&quot;<br>&gt; <br>&gt; The same thing, but no-escaping:<br>&gt; 	&#39;&#39;&#39;	&lt;book id=&#39;bk101&#39; empty=&#39;&#39;&gt;&#39;&#39;&#39;<br>&gt; <br>&gt; A no-escaping multiline literal with a normal delimiter:<br>&gt; 	&#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	&#39;&lt;catalog /&gt;&#39;<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Notes on alternatives:<br>&gt; <br>&gt; 1. If you wanted to not provide no-escaping strings, an alternative would be to say that *all* escapes require as many backslashes as there are quotes in the string delimiter. Thus, a newline escape in a `&quot;&quot;&quot;` string would be `\\\n`. This would in practice give you the same flexibility to write a literal without worrying (much) about escaping.<br>&gt; <br>&gt; 2. However, it&#39;s not entirely clear to me that we really need escapes other than interpolations at all. You could write &quot;\(.newline)&quot; or &quot;\(.doubleQuote)&quot; or &quot;\(.backslash)&quot; to get those characters. (These might be static members required by StringInterpolationConvertible.) Plain backslashes would have no special meaning at all; only &quot;\(&quot; would be special.<br>&gt; <br>&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does. That would allow you to document things in literals. Then you would want `&#39;` again so that you could turn that smartness off. (Of course, the big problem here is that a naïve implementation would consider &quot;http://&quot; to have a comment at the end of it.)<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Finally, a brief aside:<br>&gt; <br>&gt;&gt; For example, a regular expression that detects a might be written &quot;\N*\n&quot;. If escaping is enabled, then the compiler changes &quot;\n&quot; into line feed, which does not have the same meaning to the regular expression engine as &quot;\n&quot;.<br>&gt; <br>&gt; There is a special place in Hell reserved for authors of languages which use `\` as an escape character, provide no regex literals or non-escaping string literals, and ship with regex libraries which use `\` as a metacharacter. It&#39;s in the outer circles—Satan has some sense of perspective—but it&#39;s definitely there.<br>&gt; <br>&gt; Sorry if that&#39;s not very constructive, but *man*, that burns my biscuits.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Instead of creating yet another set of string quotation rules, I would prefer copy &amp; pasting the Perl 5 rules :)<br></p><p>I wouldn&#39;t.<br></p><p>I&#39;m a big fan of Perl. It was my daily driver for many years. I participated in the Perl 6 design process, was pumpking for a Parrot (the early Perl 6 interpreter) subsystem, and have patches in the Perl 5 interpreter. I&#39;m fluent in Perl 5&#39;s various literal syntaxes. (Actually, a piece of syntax I added had to be disambiguated from empty-regex.)<br></p><p>I&#39;ve used and appreciated virtually all of Perl&#39;s literal syntaxes, but I don&#39;t think they&#39;d be a good fit for Swift.<br></p><p>Every language has its own character. Perl&#39;s is that it&#39;s maximally expressive and deeply embraces precedent from other languages, even at the cost of making code ambiguous, obscure, or downright ugly. In that context, having two quoting mechanisms (q and qq) in three forms (&#39;/&quot;, q/qq, heredoc) is a great solution, and the lack of indentation handling is not a big deal. It fits perfectly into Perl&#39;s concept of TMTOWTDI (&quot;there&#39;s more than one way to do it&quot;).<br></p><p>Swift&#39;s character is quite different from Perl&#39;s, though. Swift aims to be simple and clear, permitting shorthands, omissions, and inferences, but usually not outright redundancy. If the language is making something difficult, you should enhance an existing construct, not create a new one:<br></p><p>* Too much junk in a closure declaration? Let people omit inferrable types or even parameter names.<br>* Immutable collections too slow, mutable ones too dangerous, and having both is an ugly compromise? Make them value types, giving you the best of both worlds.<br>* String and Array are kind of similar, but not really the same? Unite them with common protocols. (And if Int indexing is too dangerous for Strings, use an associated type to make sure Strings can use a safely opaque Index.)<br></p><p>The huge preponderance of quoting syntaxes in Perl isn&#39;t very Swifty, but neither is the decision to leave a major style issue (indentation) on the table. Swift generally does not tolerate designs that lead to ugly code.<br></p><p>If I had to create a slogan like TMTOWTDI for Swift, I would probably choose &quot;one way, maximally elegant&quot;. That&#39;s quite a different approach to language design, and it calls for a different approach to string literals.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 24, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 for Brent&#39;s comments<br></p><p>On Sunday, 24 April 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Instead of creating yet another set of string quotation rules, I would<br>&gt; prefer copy &amp; pasting the Perl 5 rules :)<br>&gt;<br>&gt; I wouldn&#39;t.<br>&gt;<br>&gt; I&#39;m a big fan of Perl. It was my daily driver for many years. I<br>&gt; participated in the Perl 6 design process, was pumpking for a Parrot (the<br>&gt; early Perl 6 interpreter) subsystem, and have patches in the Perl 5<br>&gt; interpreter. I&#39;m fluent in Perl 5&#39;s various literal syntaxes. (Actually, a<br>&gt; piece of syntax I added had to be disambiguated from empty-regex.)<br>&gt;<br>&gt; I&#39;ve used and appreciated virtually all of Perl&#39;s literal syntaxes, but I<br>&gt; don&#39;t think they&#39;d be a good fit for Swift.<br>&gt;<br>&gt; Every language has its own character. Perl&#39;s is that it&#39;s maximally<br>&gt; expressive and deeply embraces precedent from other languages, even at the<br>&gt; cost of making code ambiguous, obscure, or downright ugly. In that context,<br>&gt; having two quoting mechanisms (q and qq) in three forms (&#39;/&quot;, q/qq,<br>&gt; heredoc) is a great solution, and the lack of indentation handling is not a<br>&gt; big deal. It fits perfectly into Perl&#39;s concept of TMTOWTDI (&quot;there&#39;s more<br>&gt; than one way to do it&quot;).<br>&gt;<br>&gt; Swift&#39;s character is quite different from Perl&#39;s, though. Swift aims to be<br>&gt; simple and clear, permitting shorthands, omissions, and inferences, but<br>&gt; usually not outright redundancy. If the language is making something<br>&gt; difficult, you should enhance an existing construct, not create a new one:<br>&gt;<br>&gt; * Too much junk in a closure declaration? Let people omit inferrable types<br>&gt; or even parameter names.<br>&gt; * Immutable collections too slow, mutable ones too dangerous, and having<br>&gt; both is an ugly compromise? Make them value types, giving you the best of<br>&gt; both worlds.<br>&gt; * String and Array are kind of similar, but not really the same? Unite<br>&gt; them with common protocols. (And if Int indexing is too dangerous for<br>&gt; Strings, use an associated type to make sure Strings can use a safely<br>&gt; opaque Index.)<br>&gt;<br>&gt; The huge preponderance of quoting syntaxes in Perl isn&#39;t very Swifty, but<br>&gt; neither is the decision to leave a major style issue (indentation) on the<br>&gt; table. Swift generally does not tolerate designs that lead to ugly code.<br>&gt;<br>&gt; If I had to create a slogan like TMTOWTDI for Swift, I would probably<br>&gt; choose &quot;one way, maximally elegant&quot;. That&#39;s quite a different approach to<br>&gt; language design, and it calls for a different approach to string literals.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/c2522950/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 24, 2016 at 03:00:00pm</p></header><div class="content"><p>It’s +1 from me also. Swift’s Lexer is less than 2000 lines in it’s entirety whereas Perl’s<br>tokeniser is more than 11,000 lines so I don’t think this is a direction we want to head in.<br></p><p>Besides, I don’t feel there is a need for more than one type of string as Swift&#39;s<br>\() interpolation syntax is sufficiently distinct that needing an un-interpolated<br>string is comparatively rare. With respect to the “picket fence” problem with<br>complex regular expressions one proposal is that unknown escape sequences <br>be passed into the string literal instead of giving an error. This would make the<br>following a legal string/regex: “\w[\w\d]+”. This involves a shift from thinking of<br>\ as an escape character. More specific supported escape sequences \r \n \( etc.<br></p><p>This leaves the question of indentation inside string. I’d prefer not to address this<br>as it prevents data being pasted directly into a program and on KISS grounds.<br>If someone suggests a simple consistent syntax however I could take a look at it.<br></p><p>If you want to give the proposal a test drive you can download a 3.0 toolchain<br>supporting multiline strings including the regex suggestion installing it as follows :<br></p><p>$ curl http://johnholdsworth.com/swift-LOCAL-2016-04-24-a-osx.tar.gz &gt; multiline.tar.gz<br>$ sudo tar xfz multiline.tar.gz -C /<br></p><p>Select &quot;Local Swift Development Snapshot 2016-04-24” in preferences and restart Xcode.<br></p><p>John<br></p><p>&gt; On 24 Apr 2016, at 04:31, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 for Brent&#39;s comments <br>&gt; <br>&gt; On Sunday, 24 April 2016, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; Instead of creating yet another set of string quotation rules, I would prefer copy &amp; pasting the Perl 5 rules :)<br>&gt; <br>&gt; I wouldn&#39;t.<br>&gt; <br>&gt; I&#39;m a big fan of Perl. It was my daily driver for many years. I participated in the Perl 6 design process, was pumpking for a Parrot (the early Perl 6 interpreter) subsystem, and have patches in the Perl 5 interpreter. I&#39;m fluent in Perl 5&#39;s various literal syntaxes. (Actually, a piece of syntax I added had to be disambiguated from empty-regex.)<br>&gt; <br>&gt; I&#39;ve used and appreciated virtually all of Perl&#39;s literal syntaxes, but I don&#39;t think they&#39;d be a good fit for Swift.<br>&gt; <br>&gt; Every language has its own character. Perl&#39;s is that it&#39;s maximally expressive and deeply embraces precedent from other languages, even at the cost of making code ambiguous, obscure, or downright ugly. In that context, having two quoting mechanisms (q and qq) in three forms (&#39;/&quot;, q/qq, heredoc) is a great solution, and the lack of indentation handling is not a big deal. It fits perfectly into Perl&#39;s concept of TMTOWTDI (&quot;there&#39;s more than one way to do it&quot;).<br>&gt; <br>&gt; Swift&#39;s character is quite different from Perl&#39;s, though. Swift aims to be simple and clear, permitting shorthands, omissions, and inferences, but usually not outright redundancy. If the language is making something difficult, you should enhance an existing construct, not create a new one:<br>&gt; <br>&gt; * Too much junk in a closure declaration? Let people omit inferrable types or even parameter names.<br>&gt; * Immutable collections too slow, mutable ones too dangerous, and having both is an ugly compromise? Make them value types, giving you the best of both worlds.<br>&gt; * String and Array are kind of similar, but not really the same? Unite them with common protocols. (And if Int indexing is too dangerous for Strings, use an associated type to make sure Strings can use a safely opaque Index.)<br>&gt; <br>&gt; The huge preponderance of quoting syntaxes in Perl isn&#39;t very Swifty, but neither is the decision to leave a major style issue (indentation) on the table. Swift generally does not tolerate designs that lead to ugly code.<br>&gt; <br>&gt; If I had to create a slogan like TMTOWTDI for Swift, I would probably choose &quot;one way, maximally elegant&quot;. That&#39;s quite a different approach to language design, and it calls for a different approach to string literals.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/da614858/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 23, 2016, at 2:08 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt; <br>&gt; I don&#39;t think you can tackle multiline strings without worrying about indenting. Indentation may fundamentally change the approach you choose.<br></p><p>I agree with this and almost every point you make in your email (and your other subsequent one about one approach maximally general).  That said, I wonder if there is a different conclusion that can be reached.  I’m going to rearrange your three features a bit:<br></p><p>&gt; The way I would prefer to tackle these is:<br>&gt; <br>&gt; * Multiline literals: If the closing quote of a string is not present, look at the next line. If it consists of (optional) indentation followed by a matching opening quote, the string has a newline and then continues after the quote on the next line. (The handling of comments is an open question here.)<br>&gt; <br>&gt; 	let xml: String = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; 				&quot;&lt;catalog&gt;<br>&gt; 				&quot;\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt; 				&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 				&quot;\t&lt;/book&gt;<br>&gt; 				&quot;&lt;/catalog&gt;&quot;<br>&gt; <br>&gt; The cool things about this are that (a) the compiler can tell you really do mean this to be part of the literal and you haven&#39;t just forgotten to close the string, and (b) there&#39;s no guesswork about how indentation should be handled. The uncool thing is that you need to insert the quote at the beginning of each line, so you can&#39;t just blindly paste into a multiline literal. Editors can help make that easier, though—a &quot;paste as string literal&quot; feature would be a nice addition to Xcode, and not just for multiline strings or just for Swift.<br></p><p>Yes, I completely agree.  This is is awesome, and a nice &amp; simple generalization of our existing syntax.  It has obvious behavior even if you encounter it in code without knowing about the feature.<br></p><p>&gt; * Disabling escapes: If you use single quotes instead of double quotes, backslash escapes are disabled.<br></p><p>We need a way to disable escapes, but it seems to me that (since it is orthogonal to the other concerns) that it should not be tied to the “multiple single quotes” syntax.  What is your thought on “modifier” prefix characters for string literals?  e.g.:<br></p><p>	let x = e”no \escapes \(processed here”<br></p><p>If we supported these, they would be supported with multi-line string literals by putting the modifiers on the first line of the literal, and the multi-line approach above would “just work”.  You could introduce several different modifiers, e.g. one that disabled general escapes, but still allowed \(x) for substitution.  <br></p><p>&gt; * Yes, with a number of backslashes matching the number of quotes, which allows you to insert literal \( text: &#39;&#39;&#39;		&lt;author&gt;\\\(author)&lt;/author&gt;<br></p><p>Egads!<br></p><p>&gt; Notes on alternatives:<br>&gt; <br>&gt; 1. If you wanted to not provide no-escaping strings, an alternative would be to say that *all* escapes require as many backslashes as there are quotes in the string delimiter. Thus, a newline escape in a `&quot;&quot;&quot;` string would be `\\\n`. This would in practice give you the same flexibility to write a literal without worrying (much) about escaping.<br></p><p>I’m really not a fan of requiring “stacking” of escapes to re-enable them.  This (IMO) just makes it less likely that you’ll run into an edge case.  I also don’t like the “fix&quot; being to have to use 5 quotes around your strings :-)<br></p><p>&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br></p><p>If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br></p><p>&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt; <br>&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt; <br>&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br></p><p>I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br></p><p>For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br></p><p>	let str = &lt;&lt;EOF<br>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>\t&lt;/book&gt;<br>&lt;/catalog&gt;<br>EOF<br></p><p>for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br></p><p>I generally agree with your down thread remarks about how Swift doesn’t like to have multiple different solutions for the same problem.  OTOH, you could look at “” syntax as being analogous to closure exprs, and heredoc syntax as being analogous to nested functions :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 25, 2016 at 02:00:00am</p></header><div class="content"><p>To audition Xcode using the following multi-line syntax:<br></p><p>        let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;<br>            &quot;&quot;<br>        print(xml)<br></p><p>You can install:  http://johnholdsworth.com/swift-LOCAL-2016-04-25-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-04-25-a-osx.tar.gz&gt;<br></p><p>&gt; On 24 Apr 2016, at 23:35, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 23, 2016, at 2:08 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I’m trying to avoid more advanced features such as the handling of indenting which<br>&gt;&gt;&gt; for me complicates something that if kept simple can be documented very easily.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think you can tackle multiline strings without worrying about indenting. Indentation may fundamentally change the approach you choose.<br>&gt; <br>&gt; I agree with this and almost every point you make in your email (and your other subsequent one about one approach maximally general).  That said, I wonder if there is a different conclusion that can be reached.  I’m going to rearrange your three features a bit:<br>&gt; <br>&gt;&gt; The way I would prefer to tackle these is:<br>&gt;&gt; <br>&gt;&gt; * Multiline literals: If the closing quote of a string is not present, look at the next line. If it consists of (optional) indentation followed by a matching opening quote, the string has a newline and then continues after the quote on the next line. (The handling of comments is an open question here.)<br>&gt;&gt; <br>&gt;&gt; 	let xml: String = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; 				&quot;&lt;catalog&gt;<br>&gt;&gt; 				&quot;\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt; 				&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 				&quot;\t&lt;/book&gt;<br>&gt;&gt; 				&quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; <br>&gt;&gt; The cool things about this are that (a) the compiler can tell you really do mean this to be part of the literal and you haven&#39;t just forgotten to close the string, and (b) there&#39;s no guesswork about how indentation should be handled. The uncool thing is that you need to insert the quote at the beginning of each line, so you can&#39;t just blindly paste into a multiline literal. Editors can help make that easier, though—a &quot;paste as string literal&quot; feature would be a nice addition to Xcode, and not just for multiline strings or just for Swift.<br>&gt; <br>&gt; Yes, I completely agree.  This is is awesome, and a nice &amp; simple generalization of our existing syntax.  It has obvious behavior even if you encounter it in code without knowing about the feature.<br>&gt; <br>&gt;&gt; * Disabling escapes: If you use single quotes instead of double quotes, backslash escapes are disabled.<br>&gt; <br>&gt; We need a way to disable escapes, but it seems to me that (since it is orthogonal to the other concerns) that it should not be tied to the “multiple single quotes” syntax.  What is your thought on “modifier” prefix characters for string literals?  e.g.:<br>&gt; <br>&gt; 	let x = e”no \escapes \(processed here”<br>&gt; <br>&gt; If we supported these, they would be supported with multi-line string literals by putting the modifiers on the first line of the literal, and the multi-line approach above would “just work”.  You could introduce several different modifiers, e.g. one that disabled general escapes, but still allowed \(x) for substitution.  <br>&gt; <br>&gt;&gt; * Yes, with a number of backslashes matching the number of quotes, which allows you to insert literal \( text: &#39;&#39;&#39;		&lt;author&gt;\\\(author)&lt;/author&gt;<br>&gt; <br>&gt; Egads!<br>&gt; <br>&gt;&gt; Notes on alternatives:<br>&gt;&gt; <br>&gt;&gt; 1. If you wanted to not provide no-escaping strings, an alternative would be to say that *all* escapes require as many backslashes as there are quotes in the string delimiter. Thus, a newline escape in a `&quot;&quot;&quot;` string would be `\\\n`. This would in practice give you the same flexibility to write a literal without worrying (much) about escaping.<br>&gt; <br>&gt; I’m really not a fan of requiring “stacking” of escapes to re-enable them.  This (IMO) just makes it less likely that you’ll run into an edge case.  I also don’t like the “fix&quot; being to have to use 5 quotes around your strings :-)<br>&gt; <br>&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt; <br>&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt; <br>&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt; <br>&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt; <br>&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt; <br>&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt; <br>&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt; <br>&gt; 	let str = &lt;&lt;EOF<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; \t&lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; EOF<br>&gt; <br>&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt; <br>&gt; I generally agree with your down thread remarks about how Swift doesn’t like to have multiple different solutions for the same problem.  OTOH, you could look at “” syntax as being analogous to closure exprs, and heredoc syntax as being analogous to nested functions :-)<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/a015a2c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; To audition Xcode using the following multi-line syntax:<br>&gt; <br>&gt;         let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;<br>&gt;             &quot;&quot;<br>&gt;         print(xml)<br>&gt; <br>&gt; You can install:  http://johnholdsworth.com/swift-LOCAL-2016-04-25-a-osx.tar.gz<br></p><p>This is super-cool, and in a little bit of testing, I really like what this does to multiline strings. The quotation marks on the left end up forming a column that marks the lines as special, much like using `///` on multiline doc comments instead of `/**`.<br></p><p>In the spirit of building prototypes, I wrote a Perl script which generates literals in various formats: &lt;https://dl.dropboxusercontent.com/u/64017186/make-swift-literal.pl&gt; It allows you to feed in different strings and evaluate how they might look with various language features we might add.<br></p><p>The command takes a file on the command line (&quot;-&quot; for stdin, nothing to use the contents of the pasteboard) and prints it as a Swift literal. It supports the following options:<br></p><p>* --multiline|nomultiline: Controls the hanging-quote format we&#39;ve been discussing for multiline quotes.<br>* --unescaped|nounescaped: Controls the `e&quot;string&quot;` format we&#39;ve been discussing for quotes that ignore escaping.<br>* --quotes=n: Sets the number of quotation marks to be used.<br>* --auto|noauto: If enabled, the exact settings are chosen heuristically, with the command-line options being used as maximums. If disabled, the options directly control the settings used.<br></p><p>The default is to use heuristics, enable all options with a very high maximum number of quotes, and read the string from the pasteboard. (These defaults are controlled from lines 9 and 13-16.) I chose these defaults so that this can be used to prototype a &quot;Paste as String Literal&quot; command in TextMate 2. Just open the Swift bundle in the bundle editor, paste the script into a new &quot;Paste as String Literal&quot; command, and choose &quot;Key Equivalent: Ctrl-Cmd-V&quot;, &quot;Input: Nothing&quot;, and &quot;Output: Replace Selection&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; * Disabling escapes: If you use single quotes instead of double quotes, backslash escapes are disabled.<br>&gt; <br>&gt; We need a way to disable escapes, but it seems to me that (since it is orthogonal to the other concerns) that it should not be tied to the “multiple single quotes” syntax.  What is your thought on “modifier” prefix characters for string literals?  e.g.:<br>&gt; <br>&gt; 	let x = e”no \escapes \(processed here”<br>&gt; <br>&gt; If we supported these, they would be supported with multi-line string literals by putting the modifiers on the first line of the literal, and the multi-line approach above would “just work”.  You could introduce several different modifiers, e.g. one that disabled general escapes, but still allowed \(x) for substitution.  <br>&gt; <br>&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt; <br>&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br></p><p>Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br></p><p>(The Perl script I just posted about supports the e&quot;&quot; syntax you&#39;re proposing.)<br></p><p>&gt;&gt; * Yes, with a number of backslashes matching the number of quotes, which allows you to insert literal \( text: &#39;&#39;&#39;		&lt;author&gt;\\\(author)&lt;/author&gt;<br>&gt; <br>&gt; Egads!<br></p><p>Yeah, that&#39;s a little more clever than nice. :^)<br></p><p>&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt; <br>&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt; <br>&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt; <br>&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br></p><p>On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br></p><p>I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br></p><p>&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt; <br>&gt; 	let str = &lt;&lt;EOF<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; \t&lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; EOF<br>&gt; <br>&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br></p><p>There are two questions and a suggestion I have whenever heredoc syntax comes up.<br></p><p>Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br></p><p>Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br></p><p>S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br></p><p>	func x() -&gt; String {<br>		return &lt;&lt;EOF<br>		&lt;?xml version=&quot;1.0&quot;?&gt;<br>		&lt;catalog&gt;<br>		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>		\t&lt;/book&gt;<br>		&lt;/catalog&gt;<br>		EOF<br>	}<br></p><p>Does that seem like a good approach?<br></p><p>&gt; I generally agree with your down thread remarks about how Swift doesn’t like to have multiple different solutions for the same problem.  OTOH, you could look at “” syntax as being analogous to closure exprs, and heredoc syntax as being analogous to nested functions :-)<br></p><p>Function declarations vs. closure variable assignments were actually the only example I could think of where Swift offers two hugely different ways to write the same thing. I ultimately decided that closure syntax is an inline shorthand for function syntax, and the fact that a declared function is kind of like a declared variable of function type is a red herring. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 25, 2016 at 11:00:00pm</p></header><div class="content"><p>On Apr 25, 2016, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt;&gt; <br>&gt;&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt; <br>&gt; Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br></p><p>Right. I consider modifiers to be highly precedented in other languages, and therefore proven to work.  If we go this way, I greatly prefer prefix to postfix modifiers.<br></p><p>&gt;&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt;&gt; <br>&gt;&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt; <br>&gt; On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br></p><p>Right, but it is also heavy weight and ugly.  In your previous email you said about the single quote approach: &quot;The quotation marks on the left end up forming a column that marks the lines as special”, so I don’t see a need for a triple quote syntax to solve this specific problem.<br></p><p>&gt; I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br></p><p>I agree that this is a real problem that would be great to solve.<br></p><p>If I step back and look at the string literal space we’re discussing, I feel like there are three options:<br></p><p>1) single and simple multiline strings, using “<br>2) your triple quote sort of string, specifically tuned to avoid having to escape “ when it occurs once or twice in sequence.<br>3) heredoc, which is a very general (but also very heavy weight) solution to quoting problems.<br></p><p>I’m trying to eliminate the middle one, so we only have to have &quot;two things”.  Here are some alternative ways to solve the problem, which might have less of an impact on the language:<br></p><p>A) Introduce single quoted string literals to avoid double quote problems specifically, e.g.:   ‘look “here” I say!’.  This is another form of #2 which is less ugly.  It also doesn’t help you if you have both “ and ‘ in your string.<br></p><p>B) Introduce a modifier character that requires a more complex closing sequence to close off the string, see C++ raw string literals for prior art on this approach.  Perhaps something like:<br></p><p>	 Rxxx”look “ here “ I can use quotes “xxx<br></p><p>That said, I still prefer C) &quot;ignore this issue for now”.  In other words, I wouldn’t want to block progress on improving the string literal situation overall on this issue, because anything we do here is an further extension to a proposal that doesn’t solve this problem.<br></p><p>&gt; <br>&gt;&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt;&gt; <br>&gt;&gt; 	let str = &lt;&lt;EOF<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; \t&lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt; EOF<br>&gt;&gt; <br>&gt;&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt; <br>&gt; There are two questions and a suggestion I have whenever heredoc syntax comes up.<br>&gt; <br>&gt; Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br>&gt; <br>&gt; Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br>&gt; <br>&gt; S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br>&gt; <br>&gt; 	func x() -&gt; String {<br>&gt; 		return &lt;&lt;EOF<br>&gt; 		&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 		&lt;catalog&gt;<br>&gt; 		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 		\t&lt;/book&gt;<br>&gt; 		&lt;/catalog&gt;<br>&gt; 		EOF<br>&gt; 	}<br>&gt; <br>&gt; Does that seem like a good approach?<br></p><p>I think that either approach could work, that you have a lot more experience on these topics than I do, and I would expect a vigorous community debate about these topics. :-)<br></p><p>That said, if you look at what we’re discussing:<br></p><p>1. “Continuation&quot; string literals, to allow a multi-line string literal.  You and I appear to completely agree about this.<br>2. Heredoc: You and I seem to agree that they are a good “fully general” solution to have, but there are the details you outline above to iron out.<br>3. Modifier characters:  I’m in favor, but I don’t know where you stand.  There is also still much to iron out here (such as the specific characters).<br>4. A way to avoid having to escape “ in a non-heredoc literal.  I’m still unconvinced, and think that any solution to this problem will be orthogonal to the problems solved by 1-3 (and therefore can be added after getting experience with the other parts).<br></p><p>If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.  After that, we can discuss heredoc and modifiers (if you think they’re a good solution) on their own threads.  If those turn out to be uncontroversial, then perhaps they can get in too.<br></p><p>On the heredoc aspects specifically, unless others chime in with strong opinions about the topics you brought up, I’d suggest that you craft a proposal for adding them with your preferred solution to these.  You can mention the other answers (along with their tradeoffs and rationale for why you picked whatever you think is right) in the proposal, and we can help the community hash it out.<br></p><p>What do you think?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>Tracking the discussion, I’ve updated the prototype toolchain to support the following types of string:<br></p><p>        let multipart1 = &quot;one&quot; &quot;two&quot;<br>        let multipart2 = “one\n&quot;<br>            “two\n&quot;<br>        let multipart3 = &quot;one<br>            “two\n&quot;<br>        let regex = e&quot;\w[\w\d]*\n&quot;<br></p><p>It can be downloaded here: http://johnholdsworth.com/swift-LOCAL-2016-04-26-a-osx.tar.gz<br></p><p>Due to an implementation detail the e”” escaped strings still process escapes and interpolation<br>which is how I would argue it should be anyway. The “e” modifier just mutes the invalid escape error.<br></p><p>I’d only like to add I hope we can avoid HEREDOC strings are compared to Brent’s continuation<br>approach as the aesthetics are not at all good.<br></p><p>&gt; On 26 Apr 2016, at 07:04, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 25, 2016, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt;&gt; <br>&gt;&gt; Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br>&gt; <br>&gt; Right. I consider modifiers to be highly precedented in other languages, and therefore proven to work.  If we go this way, I greatly prefer prefix to postfix modifiers.<br>&gt; <br>&gt;&gt;&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt;&gt; <br>&gt;&gt; On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br>&gt; <br>&gt; Right, but it is also heavy weight and ugly.  In your previous email you said about the single quote approach: &quot;The quotation marks on the left end up forming a column that marks the lines as special”, so I don’t see a need for a triple quote syntax to solve this specific problem.<br>&gt; <br>&gt;&gt; I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br>&gt; <br>&gt; I agree that this is a real problem that would be great to solve.<br>&gt; <br>&gt; If I step back and look at the string literal space we’re discussing, I feel like there are three options:<br>&gt; <br>&gt; 1) single and simple multiline strings, using “<br>&gt; 2) your triple quote sort of string, specifically tuned to avoid having to escape “ when it occurs once or twice in sequence.<br>&gt; 3) heredoc, which is a very general (but also very heavy weight) solution to quoting problems.<br>&gt; <br>&gt; I’m trying to eliminate the middle one, so we only have to have &quot;two things”.  Here are some alternative ways to solve the problem, which might have less of an impact on the language:<br>&gt; <br>&gt; A) Introduce single quoted string literals to avoid double quote problems specifically, e.g.:   ‘look “here” I say!’.  This is another form of #2 which is less ugly.  It also doesn’t help you if you have both “ and ‘ in your string.<br>&gt; <br>&gt; B) Introduce a modifier character that requires a more complex closing sequence to close off the string, see C++ raw string literals for prior art on this approach.  Perhaps something like:<br>&gt; <br>&gt; 	 Rxxx”look “ here “ I can use quotes “xxx<br>&gt; <br>&gt; That said, I still prefer C) &quot;ignore this issue for now”.  In other words, I wouldn’t want to block progress on improving the string literal situation overall on this issue, because anything we do here is an further extension to a proposal that doesn’t solve this problem.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let str = &lt;&lt;EOF<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; \t&lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt; EOF<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt;&gt; <br>&gt;&gt; There are two questions and a suggestion I have whenever heredoc syntax comes up.<br>&gt;&gt; <br>&gt;&gt; Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br>&gt;&gt; <br>&gt;&gt; Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br>&gt;&gt; <br>&gt;&gt; S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br>&gt;&gt; <br>&gt;&gt; 	func x() -&gt; String {<br>&gt;&gt; 		return &lt;&lt;EOF<br>&gt;&gt; 		&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 		&lt;catalog&gt;<br>&gt;&gt; 		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 		\t&lt;/book&gt;<br>&gt;&gt; 		&lt;/catalog&gt;<br>&gt;&gt; 		EOF<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Does that seem like a good approach?<br>&gt; <br>&gt; I think that either approach could work, that you have a lot more experience on these topics than I do, and I would expect a vigorous community debate about these topics. :-)<br>&gt; <br>&gt; That said, if you look at what we’re discussing:<br>&gt; <br>&gt; 1. “Continuation&quot; string literals, to allow a multi-line string literal.  You and I appear to completely agree about this.<br>&gt; 2. Heredoc: You and I seem to agree that they are a good “fully general” solution to have, but there are the details you outline above to iron out.<br>&gt; 3. Modifier characters:  I’m in favor, but I don’t know where you stand.  There is also still much to iron out here (such as the specific characters).<br>&gt; 4. A way to avoid having to escape “ in a non-heredoc literal.  I’m still unconvinced, and think that any solution to this problem will be orthogonal to the problems solved by 1-3 (and therefore can be added after getting experience with the other parts).<br>&gt; <br>&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.  After that, we can discuss heredoc and modifiers (if you think they’re a good solution) on their own threads.  If those turn out to be uncontroversial, then perhaps they can get in too.<br>&gt; <br>&gt; On the heredoc aspects specifically, unless others chime in with strong opinions about the topics you brought up, I’d suggest that you craft a proposal for adding them with your preferred solution to these.  You can mention the other answers (along with their tradeoffs and rationale for why you picked whatever you think is right) in the proposal, and we can help the community hash it out.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/85589077/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 27, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.<br></p><p>I&#39;ve gone ahead and drafted this proposal, with some small extensions and adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed and what concerns I have.<br></p><p>Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br></p><p>Multiline string literals<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: First Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br></p><p>In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br></p><p>Swift-evolution thread: multi-line string literals. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br></p><p>This draft differs from the prototypes being thrown around on the list in that it specifies that comments should be treated as whitespace, and that whitespace-only lines in the middle of a multiline string should be ignored. I&#39;m not sure if this is feasible from a parsing standpoint, and I&#39;d like feedback from implementers on this point.<br></p><p>This draft also specifies diagnostics which should be included. Feedback on whether these are good choices would be welcome.<br></p><p>I am considering allowing you to put a backslash before the newline to indicate it should not be included in the literal. In other words, this code:<br></p><p>print(&quot;foo\<br>&quot;bar&quot;)<br>Would print &quot;foobar&quot;. However, I think this should probably be proposed separately, because there may be a better way to do it.<br></p><p>I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br></p><p>As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>The string is practically unreadable, its structure drowned in escapes and run-together characters; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>          &quot;&lt;catalog&gt;\n&quot; + <br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>          &quot; &lt;/book&gt;\n&quot; + <br>          &quot;&lt;/catalog&gt;&quot;<br>However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br></p><p>We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br></p><p>Our sample above could thus be written as:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;<br>(Note that GitHub is applying incorrect syntax highlighting to this code sample, because it&#39;s applying Swift 2 rules.)<br></p><p>This format&#39;s unbalanced quotes might strike some programmers as strange, but it attempts to mimic the way multiple lines are quoted in English prose. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br></p><p>“That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br></p><p>“Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br></p><p>“Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br></p><p>“Oh, that makes sense. Thanks!”<br>Similarly, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the literal continues on the next line, while including the continuation quote reminds the reader (and compiler) that this line is part of a string literal.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes&gt;Benefits of continuation quotes<br></p><p>It would be simpler to not require continuation quotes, so why are they required by this proposal? There are three reasons:<br></p><p>They help the compiler pinpoint errors in string literal delimiting. If continuation quotes were not required, then a missing end quote would be interpreted as a multiline string literal. This string literal would continue until the compiler encountered either another quote mark—perhaps at the site of another string literal or in a comment—or the end of the file. In either case, the compiler could at best only indicate the start of the runaway string literal; in pathological cases (for instance, if the next string literal was &quot;+&quot;), it might not even be able to do that properly.<br></p><p>With continuation quotes required, if you forget to include an end quote, the compiler can tell that you did not intend to create a multiline string and flag the line that actually has the problem. It can also provide immediately actionable fix-it assistance. The fact that there is a redundant indication on each line of the programmer&#39;s intent to include that line in a multiline quote allows the compiler to guess the meaning of the code.<br></p><p>They separate indentation from the string&#39;s contents. Without continuation quotes, there would be no obvious indication of whether whitespace at the start of the line was intended to indent the string literal so it matched the surrounding code, or whether that whitespace was actually meant to be included in the resulting string. Multiline string literals would either have to put subsequent lines against the left margin, or apply error-prone heuristics to try to guess which whitespace was indentation and which was string literal content.<br></p><p>They improve the ability to quickly recognize the literal. The &quot; on each line serves as an immediately obvious indication that the line is part of a string literal, not code, and the row of &quot; characters in a well-formatted file allows you to quickly scan up and down the file to see the extent of the literal.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br></p><p>When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br></p><p>If the next line is all whitespace, it is ignored; Swift moves on to the line afterward, applying these rules again.<br></p><p>If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br></p><p>If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. This syntax error should offer two fix-its: one to close the string literal at the end of the current line, and one to include the next line in the string literal by inserting a continuation quote.<br></p><p>Rules 1 and 2 should treat comments as though they are whitespace; this allows you to comment out individual lines in a multiline string literal. (However, commenting out the last line of the string literal will still make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br></p><p>Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring no continuation character<br></p><p>The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;&quot;<br>This has several advantages:<br></p><p>It is simpler.<br></p><p>It is less offensive to programmers&#39; sensibilities (since there are no unmatched &quot; characters).<br></p><p>It does not require that you edit the string literal to insert a continuation quote in each line.<br></p><p>Balanced against the advantages, however, is the loss of the improved diagnostics, code formatting, and visual affordances mentioned in the &quot;Benefits of continuation quotes&quot; section above.<br></p><p>In practice, we believe that editor support (such as &quot;Paste as String Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding continuation quotes less burdensome, while also providing other conveniences like automatic escaping. We believe the other two factors are outweighed by the benefits of continuation quotes.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br></p><p>The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. This solution was rejected because it has the same issues as the &quot;no continuation character&quot; solution, and because it was mixing two orthogonal issues (multiline strings and alternate delimiters).<br></p><p>Another suggestion was to support a heredoc syntax, which would allow you to specify a placeholder string literal on one line whose content begins on the next line, running until some arbitrary delimiter. For instance, if Swift adopted Perl 5&#39;s syntax, it might support code like:<br></p><p>connection.sendString(&lt;&lt;&quot;END&quot;)<br>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;<br>END<br>In addition to the issues with the &quot;&quot;&quot; syntax, heredocs are complicated both to explain and to parse, and are not a natural extension of Swift&#39;s current string syntax.<br></p><p>Both of these suggestions address interesting issues with string literals, solving compelling use cases. They&#39;re just not that good at fixing the specific issue at hand. We might consider them in the future to address those problems to which they are better suited.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues&gt;Fixing other string literal readability issues<br></p><p>This proposal is narrowly aimed at multiline strings. It intentionally doesn&#39;t tackle several other problems with string literals:<br></p><p>Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br></p><p>Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br></p><p>String literals consisting of very long pieces of text which are best represented completely verbatim.<br></p><p>These are likely to be subjects of future proposals, though not necessarily during Swift 3.<br></p><p>This proposal also does not attempt to address regular expression literals. The members of the core team who are interested in regular expression support have ambitions for that feature which put it out of scope for Swift 3.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/04a6520e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 27, 2016 at 04:00:00pm</p></header><div class="content"><p>On 27.04.2016 11:52, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as<br>&gt;&gt; such: I’d suggest that you provide a proposal that just tackles the<br>&gt;&gt; continuation string literals.  This seems simple, and possible to get in<br>&gt;&gt; for Swift 3.<br>&gt;<br>&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and<br>&gt; adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed<br>&gt; and what concerns I have.<br></p><p>I don&#39;t feel like this proposal(draft) solves the issue we want(?) to solve <br>with multi-line feature.<br></p><p>I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source <br>file. No escaping, no interpolation, etc. I believe this should be a target <br>of the proposal.<br>Otherwise, I reject to see any reason to introduce anything new at this <br>area - we already can concatenate strings and place them on next line and <br>escape special characters.<br></p><p>In your proposal, you have to escape characters in your text, you need to <br>carefully modify the copy-pasted text to be allowed as correct multi-line <br>string. Also, what if I need to have spaces *at the end of string* ? Editor <br>can just trimmed them, and we can&#39;t clearly see them.<br></p><p>Personally I need to be able to have this(in some way) in my code:<br>(note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to have <br>inside my xml)<br></p><p>let xml = ... // some marker to start the multi-line str<br>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>         &lt;author&gt;myAuthor&lt;/author&gt;<br>         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>     &lt;/book&gt;<br>&lt;/catalog&gt;<br>... // some marker here to stop multi-line str<br></p><p>It seems like we need some markers for end-of-the-line to be able to keep <br>spaces/tabs in the end of line.<br></p><p>What about something like this. Two suported variants : first when we need <br>to keep spaces in the end of line, and second when we don&#39;t need <br>spaced(will be trimmed by parser)<br></p><p>#1 (parser should just take the text between first and last quote *as-is*)<br></p><p>let xml = &quot;\<br>&quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&quot;&lt;catalog&gt;&quot;<br>&quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&quot;    &lt;/book&gt;&quot;<br>&quot;&lt;/catalog&gt;&quot;<br>&quot;<br></p><p>#2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t care):<br>(parser takes all that is after | as-is but trims any trailing spaces/tabs <br>in lines to be clear in behaviour)<br></p><p>let xml = &quot;\<br>|&lt;?xml version=&quot;1.0&quot;?&gt;<br>|&lt;catalog&gt;<br>|    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>|        &lt;author&gt;myAuthor&lt;/author&gt;<br>|        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>|    &lt;/book&gt;<br>|&lt;/catalog&gt;<br>&quot;<br></p><p>Or these two could be combined in one(as-is between |..|) but I&#39;m not sure:<br></p><p>let xml = &quot;\<br>|&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>|&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>|    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>|        &lt;author&gt;myAuthor&lt;/author&gt;|<br>|        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>|    &lt;/book&gt;|<br>|&lt;/catalog&gt;|<br>&quot;<br></p><p><br>&gt;<br>&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br>&gt;<br>&gt;<br>&gt;   Multiline string literals<br>&gt;<br>&gt;   * Proposal: SE-NNNN<br>&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;   * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;   * Status: First Draft<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;<br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt; punctuation which is a straightforward extension of our existing string<br>&gt; literals.<br>&gt;<br>&gt; Swift-evolution thread: multi-line string literals.<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft<br>&gt;     Notes<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     This draft differs from the prototypes being thrown around on the list<br>&gt;     in that it specifies that comments should be treated as whitespace, and<br>&gt;     that whitespace-only lines in the middle of a multiline string should<br>&gt;     be ignored. I&#39;m not sure if this is feasible from a parsing standpoint,<br>&gt;     and I&#39;d like feedback from implementers on this point.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     This draft also specifies diagnostics which should be included.<br>&gt;     Feedback on whether these are good choices would be welcome.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     I am considering allowing you to put a backslash before the newline to<br>&gt;     indicate it should /not/ be included in the literal. In other words,<br>&gt;     this code:<br>&gt;<br>&gt;     print(&quot;foo\<br>&gt;     &quot;bar&quot;)<br>&gt;<br>&gt;     Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;     proposed separately, because there may be a better way to do it.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     I&#39;ve listed only myself as an author because I don&#39;t want to put anyone<br>&gt;     else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;     deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;     think you should be included.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt;<br>&gt; As Swift begins to move into roles beyond app development, code which needs<br>&gt; to generate text becomes a more important use case. Consider, for instance,<br>&gt; generating even a small XML string:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;<br>&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt; run-together characters; it looks like little more than line noise. We can<br>&gt; improve its readability somewhat by concatenating separate strings for each<br>&gt; line and using real tabs instead of |\t| escapes:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;           &quot;&lt;catalog&gt;\n&quot; +<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;           &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;           &quot; &lt;/book&gt;\n&quot; +<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;<br>&gt; However, this creates a more complex expression for the type checker, and<br>&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt; far short of that goal.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed<br>&gt;     solution<br>&gt;<br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt; end of the line without encountering an end quote, it should look at the<br>&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt; string literal contains a newline and then continues on that line.<br>&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;<br>&gt; Our sample above could thus be written as:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;<br>&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;<br>&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt; prose. As an English Stack Exchange answer illustrates<br>&gt; &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;<br>&gt;     “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;     would there be in using quotation marks at the end of every paragraph?”<br>&gt;<br>&gt;     “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;     quotes at the end of every paragraph, then you would need to reidentify<br>&gt;     the speaker with every subsequent paragraph.<br>&gt;<br>&gt;     “Say a narrative was describing two or three people engaged in a<br>&gt;     lengthy conversation. If you closed the quotation marks in the previous<br>&gt;     paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;     previous speaker was extending his point, or if someone else in the<br>&gt;     room had picked up the conversation. By leaving the previous<br>&gt;     paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;     is still the one talking.”<br>&gt;<br>&gt;     “Oh, that makes sense. Thanks!”<br>&gt;<br>&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and<br>&gt; compiler) that the literal continues on the next line, while including the<br>&gt; continuation quote reminds the reader (and compiler) that this line is part<br>&gt; of a string literal.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes&gt;Benefits<br>&gt;       of continuation quotes<br>&gt;<br>&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt; required by this proposal? There are three reasons:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     *They help the compiler pinpoint errors in string literal<br>&gt;     delimiting.* If continuation quotes were not required, then a missing<br>&gt;     end quote would be interpreted as a multiline string literal. This<br>&gt;     string literal would continue until the compiler encountered either<br>&gt;     another quote mark—perhaps at the site of another string literal or in<br>&gt;     a comment—or the end of the file. In either case, the compiler could at<br>&gt;     best only indicate the start of the runaway string literal; in<br>&gt;     pathological cases (for instance, if the next string literal<br>&gt;     was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;<br>&gt;     With continuation quotes required, if you forget to include an end<br>&gt;     quote, the compiler can tell that you did not intend to create a<br>&gt;     multiline string and flag the line that actually has the problem. It<br>&gt;     can also provide immediately actionable fix-it assistance. The fact<br>&gt;     that there is a redundant indication on each line of the programmer&#39;s<br>&gt;     intent to include that line in a multiline quote allows the compiler to<br>&gt;     guess the meaning of the code.<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     *They separate indentation from the string&#39;s contents.* Without<br>&gt;     continuation quotes, there would be no obvious indication of whether<br>&gt;     whitespace at the start of the line was intended to indent the string<br>&gt;     literal so it matched the surrounding code, or whether that whitespace<br>&gt;     was actually meant to be included in the resulting string. Multiline<br>&gt;     string literals would either have to put subsequent lines against the<br>&gt;     left margin, or apply error-prone heuristics to try to guess which<br>&gt;     whitespace was indentation and which was string literal content.<br>&gt;<br>&gt;  3.<br>&gt;<br>&gt;     *They improve the ability to quickly recognize the literal.* The |&quot;| on<br>&gt;     each line serves as an immediately obvious indication that the line is<br>&gt;     part of a string literal, not code, and the row of |&quot;| characters in a<br>&gt;     well-formatted file allows you to quickly scan up and down the file to<br>&gt;     see the extent of the literal.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed<br>&gt;     design<br>&gt;<br>&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt; without finding a closing quote, it examines the next line, applying the<br>&gt; following rules:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;     the line afterward, applying these rules again.<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     If the next line begins with whitespace followed by a continuation<br>&gt;     quote, then the string literal contains a newline followed by the<br>&gt;     contents of the string literal starting on that line. (This line may<br>&gt;     itself have no closing quote, in which case the same rules apply to the<br>&gt;     line which follows.)<br>&gt;<br>&gt;  3.<br>&gt;<br>&gt;     If the next line contains anything else, Swift raises a syntax error<br>&gt;     for an unterminated string literal. This syntax error should offer two<br>&gt;     fix-its: one to close the string literal at the end of the current<br>&gt;     line, and one to include the next line in the string literal by<br>&gt;     inserting a continuation quote.<br>&gt;<br>&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt; (However, commenting out the last line of the string literal will still<br>&gt; make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact<br>&gt;     on existing code<br>&gt;<br>&gt; Failing to close a string literal before the end of the line is currently a<br>&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives<br>&gt;     considered<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring<br>&gt;       no continuation character<br>&gt;<br>&gt; The main alternative is to not require a continuation quote, and simply<br>&gt; extend the string literal from the starting quote to the ending quote,<br>&gt; including all newlines between them. For example:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt; &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt;<br>&gt; This has several advantages:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     It is simpler.<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     It is less offensive to programmers&#39; sensibilities (since there are no<br>&gt;     unmatched |&quot;| characters).<br>&gt;<br>&gt;  3.<br>&gt;<br>&gt;     It does not require that you edit the string literal to insert a<br>&gt;     continuation quote in each line.<br>&gt;<br>&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;<br>&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt; continuation quotes less burdensome, while also providing other<br>&gt; conveniences like automatic escaping. We believe the other two factors are<br>&gt; outweighed by the benefits of continuation quotes.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use<br>&gt;       a different delimiter for multiline strings<br>&gt;<br>&gt; The initial suggestion was that multiline strings should use a different<br>&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt; continuation characters between. This solution was rejected because it has<br>&gt; the same issues as the &quot;no continuation character&quot; solution, and because it<br>&gt; was mixing two orthogonal issues (multiline strings and alternate delimiters).<br>&gt;<br>&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt; to specify a placeholder string literal on one line whose content begins on<br>&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;<br>&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; END<br>&gt;<br>&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt; current string syntax.<br>&gt;<br>&gt; Both of these suggestions address interesting issues with string literals,<br>&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt; specific issue at hand. We might consider them in the future to address<br>&gt; those problems to which they are better suited.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues&gt;Fixing<br>&gt;       other string literal readability issues<br>&gt;<br>&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Reducing the amount of double-backslashing needed when working with<br>&gt;     regular expression libraries, Windows paths, source code generation,<br>&gt;     and other tasks where backslashes are part of the data.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Alternate delimiters or other strategies for writing strings<br>&gt;     with |&quot;| characters in them.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     String literals consisting of very long pieces of text which are best<br>&gt;     represented completely verbatim.<br>&gt;<br>&gt; These are likely to be subjects of future proposals, though not necessarily<br>&gt; during Swift 3.<br>&gt;<br>&gt; This proposal also does not attempt to address regular expression literals.<br>&gt; The members of the core team who are interested in regular expression<br>&gt; support have ambitions for that feature which put it out of scope for Swift 3.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 27, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source file. No escaping, no interpolation, etc. I believe this should be a target of the proposal.<br></p><p>I think that&#39;s a great feature we should also add. I just think it&#39;s a *different* feature from this one. That&#39;s why I listed it in the &quot;Fixing other string literal readability issues&quot; part of the &quot;Alternatives considered&quot; section as something I think is worth fixing.<br></p><p>&gt; Otherwise, I reject to see any reason to introduce anything new at this area - we already can concatenate strings and place them on next line and escape special characters.<br></p><p>Sure, but it&#39;s a lot less easy to understand what&#39;s going on. See the examples in the &quot;Motivation&quot; and &quot;Proposed solution&quot; sections.<br></p><p>&gt; Also, what if I need to have spaces *at the end of string* ? Editor can just trimmed them, and we can&#39;t clearly see them.<br></p><p>One way to address this is with a &quot;zero-width escape&quot;, an escape which doesn&#39;t actually insert anything but merely breaks up sequences and protects whitespace in front of it.<br></p><p>Of course, using tools which don&#39;t modify whitespace in string literals since doing so affects the program&#39;s behavior is probably the &quot;correct&quot; answer here...<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 27, 2016 at 07:00:00pm</p></header><div class="content"><p>On 27.04.2016 17:33, Brent Royal-Gordon wrote:<br>&gt;&gt; Otherwise, I reject to see any reason to introduce anything new at<br>&gt;&gt; this area - we already can concatenate strings and place them on next<br>&gt;&gt; line and escape special characters.<br>&gt; Sure, but it&#39;s a lot less easy to understand what&#39;s going on. See the<br>&gt; examples in the &quot;Motivation&quot; and &quot;Proposed solution&quot; sections.<br>&gt;<br></p><p>Sorry, but I don&#39;t see that your suggestion is &quot;lot less easy to understand <br>what&#39;s going on&quot; in compare to what we have now.<br></p><p>We have :<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>           &quot;&lt;catalog&gt;\n&quot; +<br>           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>           &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>           &quot; &lt;/book&gt;\n&quot; +<br>           &quot;&lt;/catalog&gt;&quot;<br></p><p>You suggest :<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>           &quot;&lt;catalog&gt;<br>           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>           &quot; &lt;/book&gt;<br>           &quot;&lt;/catalog&gt;&quot;<br></p><p>I can&#39;t feel this like much more better because of the same escaping of <br>special chars. I don&#39;t see much problems in \n&quot; and + in first(current) <br>variant. I just don&#39;t understand what such kind of multiline we need for, <br>so we want to introduce a new &#39;feature&#39; in language. I don&#39;t feel such a <br>small improvement worth to be implemented. Just my opinion, probably I&#39;m <br>not right.<br></p><p>My suggestion(one of) :<br></p><p>let xml = &quot;\<br>&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&quot;&lt;catalog&gt;<br>&quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&quot;        &lt;author&gt;myAuthor&lt;/author&gt;<br>&quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&quot;    &lt;/book&gt;<br>&quot;&lt;/catalog&gt;<br>/&quot;<br></p><p>Pros:<br>* multi-line<br>* text as-is(with just &quot; at start), no escaping, all characters are allowed<br>* &quot; at the start says it is a string<br>* begins with &quot;\  - clearly saying it is a start of special string<br>* ends with /&quot;  - clearly saying &quot;end of the special string&quot;<br>Cons(but actually this is &#39;by design&#39; of the feature for text as-is):<br>* not able to explicitly have &#39;tab&#39; symbol (was \t)<br>* not able to have other escaped chars like \n<br>* not able to have string interpolation.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/afb1af7924cbadd912a8b5b2f1308bba?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Siracusa</string> &lt;siracusa at gmail.com&gt;<p>April 27, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Apr 27, 2016 at 9:08 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source<br>&gt; file. No escaping, no interpolation, etc. I believe this should be a target<br>&gt; of the proposal.<br>&gt;<br></p><p>I also see this as one of the most important goals of any multi-line<br>string-handling proposal. The &quot;no escapes required&quot; syntax doesn&#39;t have to<br>be the only way to handle multi-line strings, but it should be one of the<br>available ways.<br></p><p>-John<br></p><p>P.S. - Secondarily (and broader than just multi-line strings) I think there<br>should also be a way to avoid backslash-itis in strings of all kinds by<br>providing some flexibility in string delimiters. But that&#39;s for another<br>thread…<br></p><p><br></p><p>&gt; Otherwise, I reject to see any reason to introduce anything new at this<br>&gt; area - we already can concatenate strings and place them on next line and<br>&gt; escape special characters.<br>&gt;<br>&gt; In your proposal, you have to escape characters in your text, you need to<br>&gt; carefully modify the copy-pasted text to be allowed as correct multi-line<br>&gt; string. Also, what if I need to have spaces *at the end of string* ? Editor<br>&gt; can just trimmed them, and we can&#39;t clearly see them.<br>&gt;<br>&gt; Personally I need to be able to have this(in some way) in my code:<br>&gt; (note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to<br>&gt; have inside my xml)<br>&gt;<br>&gt; let xml = ... // some marker to start the multi-line str<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; ... // some marker here to stop multi-line str<br>&gt;<br>&gt; It seems like we need some markers for end-of-the-line to be able to keep<br>&gt; spaces/tabs in the end of line.<br>&gt;<br>&gt; What about something like this. Two suported variants : first when we need<br>&gt; to keep spaces in the end of line, and second when we don&#39;t need<br>&gt; spaced(will be trimmed by parser)<br>&gt;<br>&gt; #1 (parser should just take the text between first and last quote *as-is*)<br>&gt;<br>&gt; let xml = &quot;\<br>&gt; &quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&gt; &quot;&lt;catalog&gt;&quot;<br>&gt; &quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&gt; &quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&gt; &quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&gt; &quot;    &lt;/book&gt;&quot;<br>&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt; &quot;<br>&gt;<br>&gt; #2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t<br>&gt; care):<br>&gt; (parser takes all that is after | as-is but trims any trailing spaces/tabs<br>&gt; in lines to be clear in behaviour)<br>&gt;<br>&gt; let xml = &quot;\<br>&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; |&lt;catalog&gt;<br>&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt; |    &lt;/book&gt;<br>&gt; |&lt;/catalog&gt;<br>&gt; &quot;<br>&gt;<br>&gt; Or these two could be combined in one(as-is between |..|) but I&#39;m not sure:<br>&gt;<br>&gt; let xml = &quot;\<br>&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>&gt; |&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;|<br>&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>&gt; |    &lt;/book&gt;|<br>&gt; |&lt;/catalog&gt;|<br>&gt; &quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   Multiline string literals<br>&gt;&gt;<br>&gt;&gt;   * Proposal: SE-NNNN<br>&gt;&gt;     &lt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt;&gt; &gt;<br>&gt;&gt;   * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt;   * Status: First Draft<br>&gt;&gt;   * Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction<br>&gt;&gt; &gt;Introduction<br>&gt;&gt;<br>&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt;&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt;&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt;&gt; punctuation which is a straightforward extension of our existing string<br>&gt;&gt; literals.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: multi-line string literals.<br>&gt;&gt; &lt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes<br>&gt;&gt; &gt;Draft<br>&gt;&gt;     Notes<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     This draft differs from the prototypes being thrown around on the list<br>&gt;&gt;     in that it specifies that comments should be treated as whitespace,<br>&gt;&gt; and<br>&gt;&gt;     that whitespace-only lines in the middle of a multiline string should<br>&gt;&gt;     be ignored. I&#39;m not sure if this is feasible from a parsing<br>&gt;&gt; standpoint,<br>&gt;&gt;     and I&#39;d like feedback from implementers on this point.<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     This draft also specifies diagnostics which should be included.<br>&gt;&gt;     Feedback on whether these are good choices would be welcome.<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     I am considering allowing you to put a backslash before the newline to<br>&gt;&gt;     indicate it should /not/ be included in the literal. In other words,<br>&gt;&gt;     this code:<br>&gt;&gt;<br>&gt;&gt;     print(&quot;foo\<br>&gt;&gt;     &quot;bar&quot;)<br>&gt;&gt;<br>&gt;&gt;     Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;&gt;     proposed separately, because there may be a better way to do it.<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     I&#39;ve listed only myself as an author because I don&#39;t want to put<br>&gt;&gt; anyone<br>&gt;&gt;     else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;&gt;     deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;&gt;     think you should be included.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation<br>&gt;&gt; &gt;Motivation<br>&gt;&gt;<br>&gt;&gt; As Swift begins to move into roles beyond app development, code which<br>&gt;&gt; needs<br>&gt;&gt; to generate text becomes a more important use case. Consider, for<br>&gt;&gt; instance,<br>&gt;&gt; generating even a small XML string:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt;<br>&gt;&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt;&gt; run-together characters; it looks like little more than line noise. We can<br>&gt;&gt; improve its readability somewhat by concatenating separate strings for<br>&gt;&gt; each<br>&gt;&gt; line and using real tabs instead of |\t| escapes:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;           &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;           &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;           &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;<br>&gt;&gt; However, this creates a more complex expression for the type checker, and<br>&gt;&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt;&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt;&gt; far short of that goal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution<br>&gt;&gt; &gt;Proposed<br>&gt;&gt;     solution<br>&gt;&gt;<br>&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt;&gt; end of the line without encountering an end quote, it should look at the<br>&gt;&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt;&gt; string literal contains a newline and then continues on that line.<br>&gt;&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt;<br>&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; &quot;&lt;catalog&gt;<br>&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;           &quot; &lt;/book&gt;<br>&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;<br>&gt;&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt;&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;&gt;<br>&gt;&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt;&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt;&gt; prose. As an English Stack Exchange answer illustrates<br>&gt;&gt; &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;&gt;<br>&gt;&gt;     “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt;     would there be in using quotation marks at the end of every<br>&gt;&gt; paragraph?”<br>&gt;&gt;<br>&gt;&gt;     “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt;     quotes at the end of every paragraph, then you would need to<br>&gt;&gt; reidentify<br>&gt;&gt;     the speaker with every subsequent paragraph.<br>&gt;&gt;<br>&gt;&gt;     “Say a narrative was describing two or three people engaged in a<br>&gt;&gt;     lengthy conversation. If you closed the quotation marks in the<br>&gt;&gt; previous<br>&gt;&gt;     paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;&gt;     previous speaker was extending his point, or if someone else in the<br>&gt;&gt;     room had picked up the conversation. By leaving the previous<br>&gt;&gt;     paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;&gt;     is still the one talking.”<br>&gt;&gt;<br>&gt;&gt;     “Oh, that makes sense. Thanks!”<br>&gt;&gt;<br>&gt;&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and<br>&gt;&gt; compiler) that the literal continues on the next line, while including the<br>&gt;&gt; continuation quote reminds the reader (and compiler) that this line is<br>&gt;&gt; part<br>&gt;&gt; of a string literal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes<br>&gt;&gt; &gt;Benefits<br>&gt;&gt;       of continuation quotes<br>&gt;&gt;<br>&gt;&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt;&gt; required by this proposal? There are three reasons:<br>&gt;&gt;<br>&gt;&gt;  1.<br>&gt;&gt;<br>&gt;&gt;     *They help the compiler pinpoint errors in string literal<br>&gt;&gt;     delimiting.* If continuation quotes were not required, then a missing<br>&gt;&gt;     end quote would be interpreted as a multiline string literal. This<br>&gt;&gt;     string literal would continue until the compiler encountered either<br>&gt;&gt;     another quote mark—perhaps at the site of another string literal or in<br>&gt;&gt;     a comment—or the end of the file. In either case, the compiler could<br>&gt;&gt; at<br>&gt;&gt;     best only indicate the start of the runaway string literal; in<br>&gt;&gt;     pathological cases (for instance, if the next string literal<br>&gt;&gt;     was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;&gt;<br>&gt;&gt;     With continuation quotes required, if you forget to include an end<br>&gt;&gt;     quote, the compiler can tell that you did not intend to create a<br>&gt;&gt;     multiline string and flag the line that actually has the problem. It<br>&gt;&gt;     can also provide immediately actionable fix-it assistance. The fact<br>&gt;&gt;     that there is a redundant indication on each line of the programmer&#39;s<br>&gt;&gt;     intent to include that line in a multiline quote allows the compiler<br>&gt;&gt; to<br>&gt;&gt;     guess the meaning of the code.<br>&gt;&gt;<br>&gt;&gt;  2.<br>&gt;&gt;<br>&gt;&gt;     *They separate indentation from the string&#39;s contents.* Without<br>&gt;&gt;     continuation quotes, there would be no obvious indication of whether<br>&gt;&gt;     whitespace at the start of the line was intended to indent the string<br>&gt;&gt;     literal so it matched the surrounding code, or whether that whitespace<br>&gt;&gt;     was actually meant to be included in the resulting string. Multiline<br>&gt;&gt;     string literals would either have to put subsequent lines against the<br>&gt;&gt;     left margin, or apply error-prone heuristics to try to guess which<br>&gt;&gt;     whitespace was indentation and which was string literal content.<br>&gt;&gt;<br>&gt;&gt;  3.<br>&gt;&gt;<br>&gt;&gt;     *They improve the ability to quickly recognize the literal.* The |&quot;|<br>&gt;&gt; on<br>&gt;&gt;     each line serves as an immediately obvious indication that the line is<br>&gt;&gt;     part of a string literal, not code, and the row of |&quot;| characters in a<br>&gt;&gt;     well-formatted file allows you to quickly scan up and down the file to<br>&gt;&gt;     see the extent of the literal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design<br>&gt;&gt; &gt;Detailed<br>&gt;&gt;     design<br>&gt;&gt;<br>&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt; without finding a closing quote, it examines the next line, applying the<br>&gt;&gt; following rules:<br>&gt;&gt;<br>&gt;&gt;  1.<br>&gt;&gt;<br>&gt;&gt;     If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;&gt;     the line afterward, applying these rules again.<br>&gt;&gt;<br>&gt;&gt;  2.<br>&gt;&gt;<br>&gt;&gt;     If the next line begins with whitespace followed by a continuation<br>&gt;&gt;     quote, then the string literal contains a newline followed by the<br>&gt;&gt;     contents of the string literal starting on that line. (This line may<br>&gt;&gt;     itself have no closing quote, in which case the same rules apply to<br>&gt;&gt; the<br>&gt;&gt;     line which follows.)<br>&gt;&gt;<br>&gt;&gt;  3.<br>&gt;&gt;<br>&gt;&gt;     If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt;     for an unterminated string literal. This syntax error should offer two<br>&gt;&gt;     fix-its: one to close the string literal at the end of the current<br>&gt;&gt;     line, and one to include the next line in the string literal by<br>&gt;&gt;     inserting a continuation quote.<br>&gt;&gt;<br>&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt;&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt;&gt; (However, commenting out the last line of the string literal will still<br>&gt;&gt; make it unterminated, so you don&#39;t have a completely free hand in<br>&gt;&gt; commenting.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code<br>&gt;&gt; &gt;Impact<br>&gt;&gt;     on existing code<br>&gt;&gt;<br>&gt;&gt; Failing to close a string literal before the end of the line is currently<br>&gt;&gt; a<br>&gt;&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered<br>&gt;&gt; &gt;Alternatives<br>&gt;&gt;     considered<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character<br>&gt;&gt; &gt;Requiring<br>&gt;&gt;       no continuation character<br>&gt;&gt;<br>&gt;&gt; The main alternative is to not require a continuation quote, and simply<br>&gt;&gt; extend the string literal from the starting quote to the ending quote,<br>&gt;&gt; including all newlines between them. For example:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt;<br>&gt;&gt; This has several advantages:<br>&gt;&gt;<br>&gt;&gt;  1.<br>&gt;&gt;<br>&gt;&gt;     It is simpler.<br>&gt;&gt;<br>&gt;&gt;  2.<br>&gt;&gt;<br>&gt;&gt;     It is less offensive to programmers&#39; sensibilities (since there are no<br>&gt;&gt;     unmatched |&quot;| characters).<br>&gt;&gt;<br>&gt;&gt;  3.<br>&gt;&gt;<br>&gt;&gt;     It does not require that you edit the string literal to insert a<br>&gt;&gt;     continuation quote in each line.<br>&gt;&gt;<br>&gt;&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt;&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt;&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt;<br>&gt;&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt;&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt;&gt; continuation quotes less burdensome, while also providing other<br>&gt;&gt; conveniences like automatic escaping. We believe the other two factors are<br>&gt;&gt; outweighed by the benefits of continuation quotes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings<br>&gt;&gt; &gt;Use<br>&gt;&gt;<br>&gt;&gt;       a different delimiter for multiline strings<br>&gt;&gt;<br>&gt;&gt; The initial suggestion was that multiline strings should use a different<br>&gt;&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt;&gt; continuation characters between. This solution was rejected because it has<br>&gt;&gt; the same issues as the &quot;no continuation character&quot; solution, and because<br>&gt;&gt; it<br>&gt;&gt; was mixing two orthogonal issues (multiline strings and alternate<br>&gt;&gt; delimiters).<br>&gt;&gt;<br>&gt;&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt;&gt; to specify a placeholder string literal on one line whose content begins<br>&gt;&gt; on<br>&gt;&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt;&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;&gt;<br>&gt;&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;     &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt; END<br>&gt;&gt;<br>&gt;&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt;&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt;&gt; current string syntax.<br>&gt;&gt;<br>&gt;&gt; Both of these suggestions address interesting issues with string literals,<br>&gt;&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt;&gt; specific issue at hand. We might consider them in the future to address<br>&gt;&gt; those problems to which they are better suited.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       &lt;<br>&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues<br>&gt;&gt; &gt;Fixing<br>&gt;&gt;       other string literal readability issues<br>&gt;&gt;<br>&gt;&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt;&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     Reducing the amount of double-backslashing needed when working with<br>&gt;&gt;     regular expression libraries, Windows paths, source code generation,<br>&gt;&gt;     and other tasks where backslashes are part of the data.<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     Alternate delimiters or other strategies for writing strings<br>&gt;&gt;     with |&quot;| characters in them.<br>&gt;&gt;<br>&gt;&gt;   *<br>&gt;&gt;<br>&gt;&gt;     String literals consisting of very long pieces of text which are best<br>&gt;&gt;     represented completely verbatim.<br>&gt;&gt;<br>&gt;&gt; These are likely to be subjects of future proposals, though not<br>&gt;&gt; necessarily<br>&gt;&gt; during Swift 3.<br>&gt;&gt;<br>&gt;&gt; This proposal also does not attempt to address regular expression<br>&gt;&gt; literals.<br>&gt;&gt; The members of the core team who are interested in regular expression<br>&gt;&gt; support have ambitions for that feature which put it out of scope for<br>&gt;&gt; Swift 3.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/ff4f7ae0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>April 27, 2016 at 04:00:00pm</p></header><div class="content"><p>Can this concept be dealt with my allowing a string file to be imported and<br>assigned to a string constant? All happening at compile time and using<br>#include type concept from C? It would tackle at least a reasonable subset<br>of the issue in a way that I think works better for source control, etc.<br></p><p>let xml = @stringfile(&quot;Foo/Bar/baz.xml&quot;);<br></p><p>On Wed, Apr 27, 2016 at 9:35 AM John Siracusa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Apr 27, 2016 at 9:08 AM, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source<br>&gt;&gt; file. No escaping, no interpolation, etc. I believe this should be a target<br>&gt;&gt; of the proposal.<br>&gt;&gt;<br>&gt;<br>&gt; I also see this as one of the most important goals of any multi-line<br>&gt; string-handling proposal. The &quot;no escapes required&quot; syntax doesn&#39;t have to<br>&gt; be the only way to handle multi-line strings, but it should be one of the<br>&gt; available ways.<br>&gt;<br>&gt; -John<br>&gt;<br>&gt; P.S. - Secondarily (and broader than just multi-line strings) I think<br>&gt; there should also be a way to avoid backslash-itis in strings of all kinds<br>&gt; by providing some flexibility in string delimiters. But that&#39;s for another<br>&gt; thread…<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; Otherwise, I reject to see any reason to introduce anything new at this<br>&gt;&gt; area - we already can concatenate strings and place them on next line and<br>&gt;&gt; escape special characters.<br>&gt;&gt;<br>&gt;&gt; In your proposal, you have to escape characters in your text, you need to<br>&gt;&gt; carefully modify the copy-pasted text to be allowed as correct multi-line<br>&gt;&gt; string. Also, what if I need to have spaces *at the end of string* ? Editor<br>&gt;&gt; can just trimmed them, and we can&#39;t clearly see them.<br>&gt;&gt;<br>&gt;&gt; Personally I need to be able to have this(in some way) in my code:<br>&gt;&gt; (note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to<br>&gt;&gt; have inside my xml)<br>&gt;&gt;<br>&gt;&gt; let xml = ... // some marker to start the multi-line str<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;         &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt;         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt;     &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt; ... // some marker here to stop multi-line str<br>&gt;&gt;<br>&gt;&gt; It seems like we need some markers for end-of-the-line to be able to keep<br>&gt;&gt; spaces/tabs in the end of line.<br>&gt;&gt;<br>&gt;&gt; What about something like this. Two suported variants : first when we<br>&gt;&gt; need to keep spaces in the end of line, and second when we don&#39;t need<br>&gt;&gt; spaced(will be trimmed by parser)<br>&gt;&gt;<br>&gt;&gt; #1 (parser should just take the text between first and last quote *as-is*)<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; &quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&gt;&gt; &quot;&lt;catalog&gt;&quot;<br>&gt;&gt; &quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&gt;&gt; &quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&gt;&gt; &quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&gt;&gt; &quot;    &lt;/book&gt;&quot;<br>&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt; #2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t<br>&gt;&gt; care):<br>&gt;&gt; (parser takes all that is after | as-is but trims any trailing<br>&gt;&gt; spaces/tabs in lines to be clear in behaviour)<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; |&lt;catalog&gt;<br>&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt; |    &lt;/book&gt;<br>&gt;&gt; |&lt;/catalog&gt;<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt; Or these two could be combined in one(as-is between |..|) but I&#39;m not<br>&gt;&gt; sure:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;\<br>&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>&gt;&gt; |&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;|<br>&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>&gt;&gt; |    &lt;/book&gt;|<br>&gt;&gt; |&lt;/catalog&gt;|<br>&gt;&gt; &quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   Multiline string literals<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   * Proposal: SE-NNNN<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;   * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt;&gt;   * Status: First Draft<br>&gt;&gt;&gt;   * Review manager: TBD<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction<br>&gt;&gt;&gt; &gt;Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt;&gt;&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt;&gt;&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt;&gt;&gt; punctuation which is a straightforward extension of our existing string<br>&gt;&gt;&gt; literals.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: multi-line string literals.<br>&gt;&gt;&gt; &lt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes<br>&gt;&gt;&gt; &gt;Draft<br>&gt;&gt;&gt;     Notes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This draft differs from the prototypes being thrown around on the<br>&gt;&gt;&gt; list<br>&gt;&gt;&gt;     in that it specifies that comments should be treated as whitespace,<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt;     that whitespace-only lines in the middle of a multiline string should<br>&gt;&gt;&gt;     be ignored. I&#39;m not sure if this is feasible from a parsing<br>&gt;&gt;&gt; standpoint,<br>&gt;&gt;&gt;     and I&#39;d like feedback from implementers on this point.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This draft also specifies diagnostics which should be included.<br>&gt;&gt;&gt;     Feedback on whether these are good choices would be welcome.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I am considering allowing you to put a backslash before the newline<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt;     indicate it should /not/ be included in the literal. In other words,<br>&gt;&gt;&gt;     this code:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     print(&quot;foo\<br>&gt;&gt;&gt;     &quot;bar&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;&gt;&gt;     proposed separately, because there may be a better way to do it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I&#39;ve listed only myself as an author because I don&#39;t want to put<br>&gt;&gt;&gt; anyone<br>&gt;&gt;&gt;     else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;&gt;&gt;     deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;&gt;&gt;     think you should be included.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation<br>&gt;&gt;&gt; &gt;Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As Swift begins to move into roles beyond app development, code which<br>&gt;&gt;&gt; needs<br>&gt;&gt;&gt; to generate text becomes a more important use case. Consider, for<br>&gt;&gt;&gt; instance,<br>&gt;&gt;&gt; generating even a small XML string:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The string is practically unreadable, its structure drowned in escapes<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; run-together characters; it looks like little more than line noise. We<br>&gt;&gt;&gt; can<br>&gt;&gt;&gt; improve its readability somewhat by concatenating separate strings for<br>&gt;&gt;&gt; each<br>&gt;&gt;&gt; line and using real tabs instead of |\t| escapes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;&gt;           &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;&gt;           &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;&gt;           &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, this creates a more complex expression for the type checker, and<br>&gt;&gt;&gt; there&#39;s still far more punctuation than ought to be necessary. If the<br>&gt;&gt;&gt; most<br>&gt;&gt;&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt;&gt;&gt; far short of that goal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution<br>&gt;&gt;&gt; &gt;Proposed<br>&gt;&gt;&gt;     solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; end of the line without encountering an end quote, it should look at the<br>&gt;&gt;&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt;&gt;&gt; string literal contains a newline and then continues on that line.<br>&gt;&gt;&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt; &quot;&lt;catalog&gt;<br>&gt;&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;           &quot; &lt;/book&gt;<br>&gt;&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt;&gt;&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt;&gt;&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt;&gt;&gt; prose. As an English Stack Exchange answer illustrates<br>&gt;&gt;&gt; &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt;&gt;     would there be in using quotation marks at the end of every<br>&gt;&gt;&gt; paragraph?”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt;&gt;     quotes at the end of every paragraph, then you would need to<br>&gt;&gt;&gt; reidentify<br>&gt;&gt;&gt;     the speaker with every subsequent paragraph.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     “Say a narrative was describing two or three people engaged in a<br>&gt;&gt;&gt;     lengthy conversation. If you closed the quotation marks in the<br>&gt;&gt;&gt; previous<br>&gt;&gt;&gt;     paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;&gt;&gt;     previous speaker was extending his point, or if someone else in the<br>&gt;&gt;&gt;     room had picked up the conversation. By leaving the previous<br>&gt;&gt;&gt;     paragraph’s quote unclosed, the reader knows that the previous<br>&gt;&gt;&gt; speaker<br>&gt;&gt;&gt;     is still the one talking.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     “Oh, that makes sense. Thanks!”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader<br>&gt;&gt;&gt; (and<br>&gt;&gt;&gt; compiler) that the literal continues on the next line, while including<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; continuation quote reminds the reader (and compiler) that this line is<br>&gt;&gt;&gt; part<br>&gt;&gt;&gt; of a string literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes<br>&gt;&gt;&gt; &gt;Benefits<br>&gt;&gt;&gt;       of continuation quotes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt;&gt;&gt; required by this proposal? There are three reasons:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     *They help the compiler pinpoint errors in string literal<br>&gt;&gt;&gt;     delimiting.* If continuation quotes were not required, then a missing<br>&gt;&gt;&gt;     end quote would be interpreted as a multiline string literal. This<br>&gt;&gt;&gt;     string literal would continue until the compiler encountered either<br>&gt;&gt;&gt;     another quote mark—perhaps at the site of another string literal or<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt;     a comment—or the end of the file. In either case, the compiler could<br>&gt;&gt;&gt; at<br>&gt;&gt;&gt;     best only indicate the start of the runaway string literal; in<br>&gt;&gt;&gt;     pathological cases (for instance, if the next string literal<br>&gt;&gt;&gt;     was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     With continuation quotes required, if you forget to include an end<br>&gt;&gt;&gt;     quote, the compiler can tell that you did not intend to create a<br>&gt;&gt;&gt;     multiline string and flag the line that actually has the problem. It<br>&gt;&gt;&gt;     can also provide immediately actionable fix-it assistance. The fact<br>&gt;&gt;&gt;     that there is a redundant indication on each line of the programmer&#39;s<br>&gt;&gt;&gt;     intent to include that line in a multiline quote allows the compiler<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt;     guess the meaning of the code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     *They separate indentation from the string&#39;s contents.* Without<br>&gt;&gt;&gt;     continuation quotes, there would be no obvious indication of whether<br>&gt;&gt;&gt;     whitespace at the start of the line was intended to indent the string<br>&gt;&gt;&gt;     literal so it matched the surrounding code, or whether that<br>&gt;&gt;&gt; whitespace<br>&gt;&gt;&gt;     was actually meant to be included in the resulting string. Multiline<br>&gt;&gt;&gt;     string literals would either have to put subsequent lines against the<br>&gt;&gt;&gt;     left margin, or apply error-prone heuristics to try to guess which<br>&gt;&gt;&gt;     whitespace was indentation and which was string literal content.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     *They improve the ability to quickly recognize the literal.* The |&quot;|<br>&gt;&gt;&gt; on<br>&gt;&gt;&gt;     each line serves as an immediately obvious indication that the line<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt;     part of a string literal, not code, and the row of |&quot;| characters in<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt;     well-formatted file allows you to quickly scan up and down the file<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt;     see the extent of the literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design<br>&gt;&gt;&gt; &gt;Detailed<br>&gt;&gt;&gt;     design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt;&gt; without finding a closing quote, it examines the next line, applying the<br>&gt;&gt;&gt; following rules:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;&gt;&gt;     the line afterward, applying these rules again.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     If the next line begins with whitespace followed by a continuation<br>&gt;&gt;&gt;     quote, then the string literal contains a newline followed by the<br>&gt;&gt;&gt;     contents of the string literal starting on that line. (This line may<br>&gt;&gt;&gt;     itself have no closing quote, in which case the same rules apply to<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt;     line which follows.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt;&gt;     for an unterminated string literal. This syntax error should offer<br>&gt;&gt;&gt; two<br>&gt;&gt;&gt;     fix-its: one to close the string literal at the end of the current<br>&gt;&gt;&gt;     line, and one to include the next line in the string literal by<br>&gt;&gt;&gt;     inserting a continuation quote.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt;&gt;&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt;&gt;&gt; (However, commenting out the last line of the string literal will still<br>&gt;&gt;&gt; make it unterminated, so you don&#39;t have a completely free hand in<br>&gt;&gt;&gt; commenting.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code<br>&gt;&gt;&gt; &gt;Impact<br>&gt;&gt;&gt;     on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Failing to close a string literal before the end of the line is<br>&gt;&gt;&gt; currently a<br>&gt;&gt;&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered<br>&gt;&gt;&gt; &gt;Alternatives<br>&gt;&gt;&gt;     considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character<br>&gt;&gt;&gt; &gt;Requiring<br>&gt;&gt;&gt;       no continuation character<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The main alternative is to not require a continuation quote, and simply<br>&gt;&gt;&gt; extend the string literal from the starting quote to the ending quote,<br>&gt;&gt;&gt; including all newlines between them. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     It is simpler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     It is less offensive to programmers&#39; sensibilities (since there are<br>&gt;&gt;&gt; no<br>&gt;&gt;&gt;     unmatched |&quot;| characters).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     It does not require that you edit the string literal to insert a<br>&gt;&gt;&gt;     continuation quote in each line.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt;&gt;&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt;&gt;&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt;&gt;&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt;&gt;&gt; continuation quotes less burdensome, while also providing other<br>&gt;&gt;&gt; conveniences like automatic escaping. We believe the other two factors<br>&gt;&gt;&gt; are<br>&gt;&gt;&gt; outweighed by the benefits of continuation quotes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings<br>&gt;&gt;&gt; &gt;Use<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       a different delimiter for multiline strings<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The initial suggestion was that multiline strings should use a different<br>&gt;&gt;&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt;&gt;&gt; continuation characters between. This solution was rejected because it<br>&gt;&gt;&gt; has<br>&gt;&gt;&gt; the same issues as the &quot;no continuation character&quot; solution, and because<br>&gt;&gt;&gt; it<br>&gt;&gt;&gt; was mixing two orthogonal issues (multiline strings and alternate<br>&gt;&gt;&gt; delimiters).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt;&gt;&gt; to specify a placeholder string literal on one line whose content begins<br>&gt;&gt;&gt; on<br>&gt;&gt;&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt;&gt;&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;     &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt; END<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt;&gt;&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt;&gt;&gt; current string syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both of these suggestions address interesting issues with string<br>&gt;&gt;&gt; literals,<br>&gt;&gt;&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt;&gt;&gt; specific issue at hand. We might consider them in the future to address<br>&gt;&gt;&gt; those problems to which they are better suited.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       &lt;<br>&gt;&gt;&gt; https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues<br>&gt;&gt;&gt; &gt;Fixing<br>&gt;&gt;&gt;       other string literal readability issues<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt;&gt;&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Reducing the amount of double-backslashing needed when working with<br>&gt;&gt;&gt;     regular expression libraries, Windows paths, source code generation,<br>&gt;&gt;&gt;     and other tasks where backslashes are part of the data.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Alternate delimiters or other strategies for writing strings<br>&gt;&gt;&gt;     with |&quot;| characters in them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   *<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     String literals consisting of very long pieces of text which are best<br>&gt;&gt;&gt;     represented completely verbatim.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These are likely to be subjects of future proposals, though not<br>&gt;&gt;&gt; necessarily<br>&gt;&gt;&gt; during Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal also does not attempt to address regular expression<br>&gt;&gt;&gt; literals.<br>&gt;&gt;&gt; The members of the core team who are interested in regular expression<br>&gt;&gt;&gt; support have ambitions for that feature which put it out of scope for<br>&gt;&gt;&gt; Swift 3.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/603ab093/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Apr 27, 2016, at 6:51 PM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can this concept be dealt with my allowing a string file to be imported and assigned to a string constant? All happening at compile time and using #include type concept from C? It would tackle at least a reasonable subset of the issue in a way that I think works better for source control, etc.<br>&gt; <br>&gt; let xml = @stringfile(&quot;Foo/Bar/baz.xml&quot;);<br></p><p>If memory serves me, this is not unlike what D does, with the added restriction of binding the contents to a single variable.<br></p><p>&gt; <br>&gt;&gt; On Wed, Apr 27, 2016 at 9:35 AM John Siracusa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Wed, Apr 27, 2016 at 9:08 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I expect to be able to have multiline text exactly *&quot;as-is&quot;* in my source file. No escaping, no interpolation, etc. I believe this should be a target of the proposal.<br>&gt;&gt; <br>&gt;&gt; I also see this as one of the most important goals of any multi-line string-handling proposal. The &quot;no escapes required&quot; syntax doesn&#39;t have to be the only way to handle multi-line strings, but it should be one of the available ways.<br>&gt;&gt; <br>&gt;&gt; -John<br>&gt;&gt; <br>&gt;&gt; P.S. - Secondarily (and broader than just multi-line strings) I think there should also be a way to avoid backslash-itis in strings of all kinds by providing some flexibility in string delimiters. But that&#39;s for another thread…<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; Otherwise, I reject to see any reason to introduce anything new at this area - we already can concatenate strings and place them on next line and escape special characters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In your proposal, you have to escape characters in your text, you need to carefully modify the copy-pasted text to be allowed as correct multi-line string. Also, what if I need to have spaces *at the end of string* ? Editor can just trimmed them, and we can&#39;t clearly see them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I need to be able to have this(in some way) in my code:<br>&gt;&gt;&gt; (note this &quot;\tuttorial&quot; and &quot;\(edition&quot; - this is just text, I want to have inside my xml)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let xml = ... // some marker to start the multi-line str<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;     &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;         &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt;&gt;         &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt;&gt;     &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt; ... // some marker here to stop multi-line str<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like we need some markers for end-of-the-line to be able to keep spaces/tabs in the end of line.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about something like this. Two suported variants : first when we need to keep spaces in the end of line, and second when we don&#39;t need spaced(will be trimmed by parser)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #1 (parser should just take the text between first and last quote *as-is*)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let xml = &quot;\<br>&gt;&gt;&gt; &quot;&lt;?xml version=&quot;1.0&quot;?&gt;     &quot; // yes, *I need* these spaces at the end<br>&gt;&gt;&gt; &quot;&lt;catalog&gt;&quot;<br>&gt;&gt;&gt; &quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;&quot;<br>&gt;&gt;&gt; &quot;        &lt;author&gt;myAuthor&lt;/author&gt;&quot;<br>&gt;&gt;&gt; &quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;&quot;<br>&gt;&gt;&gt; &quot;    &lt;/book&gt;&quot;<br>&gt;&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #2 in this case we don&#39;t need any spaces/tabs in the end of lines(don&#39;t care):<br>&gt;&gt;&gt; (parser takes all that is after | as-is but trims any trailing spaces/tabs in lines to be clear in behaviour)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let xml = &quot;\<br>&gt;&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; |&lt;catalog&gt;<br>&gt;&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;<br>&gt;&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&gt;&gt;&gt; |    &lt;/book&gt;<br>&gt;&gt;&gt; |&lt;/catalog&gt;<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or these two could be combined in one(as-is between |..|) but I&#39;m not sure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let xml = &quot;\<br>&gt;&gt;&gt; |&lt;?xml version=&quot;1.0&quot;?&gt;     | // yes, I need these spaces<br>&gt;&gt;&gt; |&lt;catalog&gt;| // we have to have closing symbol in this case in other lines<br>&gt;&gt;&gt; |    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;|<br>&gt;&gt;&gt; |        &lt;author&gt;myAuthor&lt;/author&gt;|<br>&gt;&gt;&gt; |        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;|<br>&gt;&gt;&gt; |    &lt;/book&gt;|<br>&gt;&gt;&gt; |&lt;/catalog&gt;|<br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   Multiline string literals<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   * Proposal: SE-NNNN<br>&gt;&gt;&gt;&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt;&gt;&gt;   * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt;&gt;&gt;   * Status: First Draft<br>&gt;&gt;&gt;&gt;   * Review manager: TBD<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt;&gt;&gt;&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt;&gt;&gt;&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt;&gt;&gt;&gt; punctuation which is a straightforward extension of our existing string<br>&gt;&gt;&gt;&gt; literals.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: multi-line string literals.<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft<br>&gt;&gt;&gt;&gt;     Notes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     This draft differs from the prototypes being thrown around on the list<br>&gt;&gt;&gt;&gt;     in that it specifies that comments should be treated as whitespace, and<br>&gt;&gt;&gt;&gt;     that whitespace-only lines in the middle of a multiline string should<br>&gt;&gt;&gt;&gt;     be ignored. I&#39;m not sure if this is feasible from a parsing standpoint,<br>&gt;&gt;&gt;&gt;     and I&#39;d like feedback from implementers on this point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     This draft also specifies diagnostics which should be included.<br>&gt;&gt;&gt;&gt;     Feedback on whether these are good choices would be welcome.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     I am considering allowing you to put a backslash before the newline to<br>&gt;&gt;&gt;&gt;     indicate it should /not/ be included in the literal. In other words,<br>&gt;&gt;&gt;&gt;     this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     print(&quot;foo\<br>&gt;&gt;&gt;&gt;     &quot;bar&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Would print |&quot;foobar&quot;|. However, I think this should probably be<br>&gt;&gt;&gt;&gt;     proposed separately, because there may be a better way to do it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     I&#39;ve listed only myself as an author because I don&#39;t want to put anyone<br>&gt;&gt;&gt;&gt;     else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;&gt;&gt;&gt;     deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;&gt;&gt;&gt;     think you should be included.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As Swift begins to move into roles beyond app development, code which needs<br>&gt;&gt;&gt;&gt; to generate text becomes a more important use case. Consider, for instance,<br>&gt;&gt;&gt;&gt; generating even a small XML string:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt;&gt;&gt;&gt; run-together characters; it looks like little more than line noise. We can<br>&gt;&gt;&gt;&gt; improve its readability somewhat by concatenating separate strings for each<br>&gt;&gt;&gt;&gt; line and using real tabs instead of |\t| escapes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;&gt;&gt;           &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;&gt;&gt;           &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;&gt;&gt;           &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;&gt;&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, this creates a more complex expression for the type checker, and<br>&gt;&gt;&gt;&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt;&gt;&gt;&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt;&gt;&gt;&gt; far short of that goal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed<br>&gt;&gt;&gt;&gt;     solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt;&gt;&gt;&gt; end of the line without encountering an end quote, it should look at the<br>&gt;&gt;&gt;&gt; next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the<br>&gt;&gt;&gt;&gt; string literal contains a newline and then continues on that line.<br>&gt;&gt;&gt;&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt;&gt; &quot;&lt;catalog&gt;<br>&gt;&gt;&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;           &quot; &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Note that GitHub is applying incorrect syntax highlighting to this code<br>&gt;&gt;&gt;&gt; sample, because it&#39;s applying Swift 2 rules.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This format&#39;s unbalanced quotes might strike some programmers as strange,<br>&gt;&gt;&gt;&gt; but it attempts to mimic the way multiple lines are quoted in English<br>&gt;&gt;&gt;&gt; prose. As an English Stack Exchange answer illustrates<br>&gt;&gt;&gt;&gt; &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt;&gt;&gt;     would there be in using quotation marks at the end of every paragraph?”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt;&gt;&gt;     quotes at the end of every paragraph, then you would need to reidentify<br>&gt;&gt;&gt;&gt;     the speaker with every subsequent paragraph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     “Say a narrative was describing two or three people engaged in a<br>&gt;&gt;&gt;&gt;     lengthy conversation. If you closed the quotation marks in the previous<br>&gt;&gt;&gt;&gt;     paragraph, then a reader wouldn’t be able to easily tell if the<br>&gt;&gt;&gt;&gt;     previous speaker was extending his point, or if someone else in the<br>&gt;&gt;&gt;&gt;     room had picked up the conversation. By leaving the previous<br>&gt;&gt;&gt;&gt;     paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;&gt;&gt;&gt;     is still the one talking.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     “Oh, that makes sense. Thanks!”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and<br>&gt;&gt;&gt;&gt; compiler) that the literal continues on the next line, while including the<br>&gt;&gt;&gt;&gt; continuation quote reminds the reader (and compiler) that this line is part<br>&gt;&gt;&gt;&gt; of a string literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#benefits-of-continuation-quotes&gt;Benefits<br>&gt;&gt;&gt;&gt;       of continuation quotes<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be simpler to not require continuation quotes, so why are they<br>&gt;&gt;&gt;&gt; required by this proposal? There are three reasons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     *They help the compiler pinpoint errors in string literal<br>&gt;&gt;&gt;&gt;     delimiting.* If continuation quotes were not required, then a missing<br>&gt;&gt;&gt;&gt;     end quote would be interpreted as a multiline string literal. This<br>&gt;&gt;&gt;&gt;     string literal would continue until the compiler encountered either<br>&gt;&gt;&gt;&gt;     another quote mark—perhaps at the site of another string literal or in<br>&gt;&gt;&gt;&gt;     a comment—or the end of the file. In either case, the compiler could at<br>&gt;&gt;&gt;&gt;     best only indicate the start of the runaway string literal; in<br>&gt;&gt;&gt;&gt;     pathological cases (for instance, if the next string literal<br>&gt;&gt;&gt;&gt;     was |&quot;+&quot;|), it might not even be able to do that properly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     With continuation quotes required, if you forget to include an end<br>&gt;&gt;&gt;&gt;     quote, the compiler can tell that you did not intend to create a<br>&gt;&gt;&gt;&gt;     multiline string and flag the line that actually has the problem. It<br>&gt;&gt;&gt;&gt;     can also provide immediately actionable fix-it assistance. The fact<br>&gt;&gt;&gt;&gt;     that there is a redundant indication on each line of the programmer&#39;s<br>&gt;&gt;&gt;&gt;     intent to include that line in a multiline quote allows the compiler to<br>&gt;&gt;&gt;&gt;     guess the meaning of the code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     *They separate indentation from the string&#39;s contents.* Without<br>&gt;&gt;&gt;&gt;     continuation quotes, there would be no obvious indication of whether<br>&gt;&gt;&gt;&gt;     whitespace at the start of the line was intended to indent the string<br>&gt;&gt;&gt;&gt;     literal so it matched the surrounding code, or whether that whitespace<br>&gt;&gt;&gt;&gt;     was actually meant to be included in the resulting string. Multiline<br>&gt;&gt;&gt;&gt;     string literals would either have to put subsequent lines against the<br>&gt;&gt;&gt;&gt;     left margin, or apply error-prone heuristics to try to guess which<br>&gt;&gt;&gt;&gt;     whitespace was indentation and which was string literal content.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     *They improve the ability to quickly recognize the literal.* The |&quot;| on<br>&gt;&gt;&gt;&gt;     each line serves as an immediately obvious indication that the line is<br>&gt;&gt;&gt;&gt;     part of a string literal, not code, and the row of |&quot;| characters in a<br>&gt;&gt;&gt;&gt;     well-formatted file allows you to quickly scan up and down the file to<br>&gt;&gt;&gt;&gt;     see the extent of the literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed<br>&gt;&gt;&gt;&gt;     design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt;&gt;&gt; without finding a closing quote, it examines the next line, applying the<br>&gt;&gt;&gt;&gt; following rules:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     If the next line is all whitespace, it is ignored; Swift moves on to<br>&gt;&gt;&gt;&gt;     the line afterward, applying these rules again.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     If the next line begins with whitespace followed by a continuation<br>&gt;&gt;&gt;&gt;     quote, then the string literal contains a newline followed by the<br>&gt;&gt;&gt;&gt;     contents of the string literal starting on that line. (This line may<br>&gt;&gt;&gt;&gt;     itself have no closing quote, in which case the same rules apply to the<br>&gt;&gt;&gt;&gt;     line which follows.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt;&gt;&gt;     for an unterminated string literal. This syntax error should offer two<br>&gt;&gt;&gt;&gt;     fix-its: one to close the string literal at the end of the current<br>&gt;&gt;&gt;&gt;     line, and one to include the next line in the string literal by<br>&gt;&gt;&gt;&gt;     inserting a continuation quote.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this<br>&gt;&gt;&gt;&gt; allows you to comment out individual lines in a multiline string literal.<br>&gt;&gt;&gt;&gt; (However, commenting out the last line of the string literal will still<br>&gt;&gt;&gt;&gt; make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt;     on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Failing to close a string literal before the end of the line is currently a<br>&gt;&gt;&gt;&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;&gt;     considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring<br>&gt;&gt;&gt;&gt;       no continuation character<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The main alternative is to not require a continuation quote, and simply<br>&gt;&gt;&gt;&gt; extend the string literal from the starting quote to the ending quote,<br>&gt;&gt;&gt;&gt; including all newlines between them. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;&gt;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     It is simpler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     It is less offensive to programmers&#39; sensibilities (since there are no<br>&gt;&gt;&gt;&gt;     unmatched |&quot;| characters).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     It does not require that you edit the string literal to insert a<br>&gt;&gt;&gt;&gt;     continuation quote in each line.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Balanced against the advantages, however, is the loss of the improved<br>&gt;&gt;&gt;&gt; diagnostics, code formatting, and visual affordances mentioned in the<br>&gt;&gt;&gt;&gt; &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In practice, we believe that editor support (such as &quot;Paste as String<br>&gt;&gt;&gt;&gt; Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding<br>&gt;&gt;&gt;&gt; continuation quotes less burdensome, while also providing other<br>&gt;&gt;&gt;&gt; conveniences like automatic escaping. We believe the other two factors are<br>&gt;&gt;&gt;&gt; outweighed by the benefits of continuation quotes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       a different delimiter for multiline strings<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The initial suggestion was that multiline strings should use a different<br>&gt;&gt;&gt;&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt;&gt;&gt;&gt; continuation characters between. This solution was rejected because it has<br>&gt;&gt;&gt;&gt; the same issues as the &quot;no continuation character&quot; solution, and because it<br>&gt;&gt;&gt;&gt; was mixing two orthogonal issues (multiline strings and alternate delimiters).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another suggestion was to support a heredoc syntax, which would allow you<br>&gt;&gt;&gt;&gt; to specify a placeholder string literal on one line whose content begins on<br>&gt;&gt;&gt;&gt; the next line, running until some arbitrary delimiter. For instance, if<br>&gt;&gt;&gt;&gt; Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt;&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;     &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt; END<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition to the issues with the |&quot;&quot;&quot;| syntax, heredocs are complicated<br>&gt;&gt;&gt;&gt; both to explain and to parse, and are not a natural extension of Swift&#39;s<br>&gt;&gt;&gt;&gt; current string syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Both of these suggestions address interesting issues with string literals,<br>&gt;&gt;&gt;&gt; solving compelling use cases. They&#39;re just not that good at fixing the<br>&gt;&gt;&gt;&gt; specific issue at hand. We might consider them in the future to address<br>&gt;&gt;&gt;&gt; those problems to which they are better suited.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#fixing-other-string-literal-readability-issues&gt;Fixing<br>&gt;&gt;&gt;&gt;       other string literal readability issues<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal is narrowly aimed at multiline strings. It intentionally<br>&gt;&gt;&gt;&gt; doesn&#39;t tackle several other problems with string literals:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Reducing the amount of double-backslashing needed when working with<br>&gt;&gt;&gt;&gt;     regular expression libraries, Windows paths, source code generation,<br>&gt;&gt;&gt;&gt;     and other tasks where backslashes are part of the data.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Alternate delimiters or other strategies for writing strings<br>&gt;&gt;&gt;&gt;     with |&quot;| characters in them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     String literals consisting of very long pieces of text which are best<br>&gt;&gt;&gt;&gt;     represented completely verbatim.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These are likely to be subjects of future proposals, though not necessarily<br>&gt;&gt;&gt;&gt; during Swift 3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal also does not attempt to address regular expression literals.<br>&gt;&gt;&gt;&gt; The members of the core team who are interested in regular expression<br>&gt;&gt;&gt;&gt; support have ambitions for that feature which put it out of scope for Swift 3.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/f37f6d9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 27, 2016 at 09:00:00pm</p></header><div class="content"><p>It really amazes me what some people think multiline strings are.<br></p><p>For me, the *definition* of a multiline string is this: &quot;&quot;&quot;A multiline string allows you to copy&amp;paste most text, without having to use any special string quoting rules: that&#39;s the primary use case. For example, you can embed something like &lt;span class=&quot;stronger&quot; id=&#39;highlighted_bit&#39;&gt;HTML Tags with different quotes in it&lt;/span&gt;, without needing any special care. Some not-so-common things may still need quotation, like 3 Quotes in a row, but most XML-snippets, JSON-text or Email-Headers can be pasted as-is.&quot;&quot;&quot;<br></p><p>If you guys have another definition, then please share with us and enlighten us: What is the purpose (use case) of having multiline string literals then? And what is the definition of a multiline string literal? It seems  (to me, at least) like some people just introduce a new string literal syntax and call it &quot;multiline&quot;.<br></p><p>I&#39;m really not very demanding on this issue. I would be happy with &quot;&quot;&quot;3 quotes&quot;&quot;&quot;, &#39;&#39;&#39;3 single quotes&#39;&#39;&#39;, &lt;&lt;HERE_DOCS, &lt;&lt;&#39;HERE_DOCS&#39;, q{perl style {balanced quotes} that also allow {{arbitrary} nesting}}; «Guillemets would also be nice», maybe combined with “English typographical quotes”, you usually don&#39;t use both in a string. My personal opinion would be to use &lt;&lt;HERE_DOCS for multiline literals with string interpolation (but without any escape sequences except \\ for \), and &lt;&lt;&#39;HERE_DOCS&#39; for multiline literals without any string interpolation or escape sequences at all (like &#39;bash string literals&#39;). But the users who prefer a quoting style that requires each line to start with a specific token (wether it&#39;s &quot; or \\) don&#39;t like any of the &quot;&quot;&quot;quotation examples&quot;&quot;&quot; that I presented, right?<br></p><p>Regards,<br>Michael<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>April 27, 2016 at 10:00:00am</p></header><div class="content"><p>On 4/27/16 05:52, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; (Note that GitHub is applying incorrect syntax highlighting to this code sample, because it&#39;s applying Swift 2 rules.)<br>&gt; <br>&gt; This format&#39;s unbalanced quotes might strike some programmers as strange, but it attempts to mimic the way multiple lines are quoted in English prose. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br></p><p>+1 from me. This looks like a good compromise and the analogy to English<br>is good (though maybe less intuitive for non-native speakers).<br></p><p>I&#39;ve seen objections that it would require significant work to &quot;just&quot;<br>paste in, say, a large XML file as a literal, and go back adding quotes<br>on every line. My reaction was that this is comparatively rare and<br>perhaps even should not be made overly easy :-).<br></p><p>On the other hand, Xcode (for one) already has a &quot;paste and preserve<br>formatting&quot; command. This could be extended to work as &quot;paste as<br>multi-line string literal&quot; under appropriate conditions, inserting<br>quotes after newlines, etc.<br></p><p>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>On Apr 27, 2016, at 10:52 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.<br>&gt; <br>&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed and what concerns I have.<br>&gt; <br>&gt; Gist: &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f&gt;<br>&gt; <br>&gt; Multiline string literals<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Brent Royal-Gordon<br>&gt; Status: First Draft<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt; <br>&gt; Swift-evolution thread: multi-line string literals.<br>&gt; <br>&gt; Draft Notes<br>&gt; <br>&gt; This draft differs from the prototypes being thrown around on the list in that it specifies that comments should be treated as whitespace, and that whitespace-only lines in the middle of a multiline string should be ignored. I&#39;m not sure if this is feasible from a parsing standpoint, and I&#39;d like feedback from implementers on this point.<br>&gt; <br>&gt; This draft also specifies diagnostics which should be included. Feedback on whether these are good choices would be welcome.<br>&gt; <br>&gt; I am considering allowing you to put a backslash before the newline to indicate it should not be included in the literal. In other words, this code:<br>&gt; <br>&gt; print(&quot;foo\<br>&gt; &quot;bar&quot;)<br>&gt; Would print &quot;foobar&quot;. However, I think this should probably be proposed separately, because there may be a better way to do it.<br>&gt; <br>&gt; I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt; The string is practically unreadable, its structure drowned in escapes and run-together characters; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>&gt;           &quot;&lt;catalog&gt;\n&quot; + <br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>&gt;           &quot; &lt;/book&gt;\n&quot; + <br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote mark there (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>Somehow I find the fundamental asymetry of this syntax disturbing for the eye (many years of programming have created this silent but real expectation that &quot; should match). The thought that it might be trying to mimic &quot;english prose&quot; does not make it suddenly look pretty or likeable. But again I probably have no taste as I used to find heredoc in perl/shell, if not pretty, at least practical.<br>I think what I find surprising is what I perceive as a what-we-give-with-the-left-hand (the promise of a convenient way to insert existing external text), we-take-back-with-the-right: yes you can insert text, but you will have to massage it so much that you are going to be detered from using it for anything past 10 lines.<br></p><p>&gt; (Note that GitHub is applying incorrect syntax highlighting to this code sample, because it&#39;s applying Swift 2 rules.)<br>&gt; <br>&gt; This format&#39;s unbalanced quotes might strike some programmers as strange, but it attempts to mimic the way multiple lines are quoted in English prose. As an English Stack Exchange answer illustrates:<br>&gt; <br>&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt; <br>&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt; <br>&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt; <br>&gt; “Oh, that makes sense. Thanks!”<br>&gt; Similarly, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the literal continues on the next line, while including the continuation quote reminds the reader (and compiler) that this line is part of a string literal.<br>&gt; <br>I certainly lack imagination as a missing quote does not make my mind immediately scream &#39;of course, it will be on the next line, or the one after, or maybe later... keep looking for it&#39;. <br></p><p><br>&gt; Benefits of continuation quotes<br>&gt; <br>&gt; It would be simpler to not require continuation quotes, so why are they required by this proposal? There are three reasons:<br>&gt; <br>&gt; They help the compiler pinpoint errors in string literal delimiting. If continuation quotes were not required, then a missing end quote would be interpreted as a multiline string literal. This string literal would continue until the compiler encountered either another quote mark—perhaps at the site of another string literal or in a comment—or the end of the file. In either case, the compiler could at best only indicate the start of the runaway string literal; in pathological cases (for instance, if the next string literal was &quot;+&quot;), it might not even be able to do that properly.<br>&gt; <br>&gt; With continuation quotes required, if you forget to include an end quote, the compiler can tell that you did not intend to create a multiline string and flag the line that actually has the problem. It can also provide immediately actionable fix-it assistance. The fact that there is a redundant indication on each line of the programmer&#39;s intent to include that line in a multiline quote allows the compiler to guess the meaning of the code.<br>&gt; <br>&gt; They separate indentation from the string&#39;s contents. Without continuation quotes, there would be no obvious indication of whether whitespace at the start of the line was intended to indent the string literal so it matched the surrounding code, or whether that whitespace was actually meant to be included in the resulting string. Multiline string literals would either have to put subsequent lines against the left margin, or apply error-prone heuristics to try to guess which whitespace was indentation and which was string literal content.<br>&gt; <br>&gt; They improve the ability to quickly recognize the literal. The &quot; on each line serves as an immediately obvious indication that the line is part of a string literal, not code, and the row of &quot; characters in a well-formatted file allows you to quickly scan up and down the file to see the extent of the literal.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br>&gt; <br>&gt; If the next line is all whitespace, it is ignored; Swift moves on to the line afterward, applying these rules again.<br>&gt; <br>&gt; If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br>&gt; <br>&gt; If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. This syntax error should offer two fix-its: one to close the string literal at the end of the current line, and one to include the next line in the string literal by inserting a continuation quote.<br>&gt; <br>&gt; Rules 1 and 2 should treat comments as though they are whitespace; this allows you to comment out individual lines in a multiline string literal. (However, commenting out the last line of the string literal will still make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Requiring no continuation character<br>&gt; <br>&gt; The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; This has several advantages:<br>&gt; <br>&gt; It is simpler.<br>&gt; <br>&gt; It is less offensive to programmers&#39; sensibilities (since there are no unmatched &quot; characters).<br>&gt; <br>&gt; It does not require that you edit the string literal to insert a continuation quote in each line.<br>&gt; <br>&gt; Balanced against the advantages, however, is the loss of the improved diagnostics, code formatting, and visual affordances mentioned in the &quot;Benefits of continuation quotes&quot; section above.<br>&gt; <br>&gt; In practice, we believe that editor support (such as &quot;Paste as String Literal&quot; or &quot;Convert to String Literal&quot; commands) can make adding continuation quotes less burdensome, while also providing other conveniences like automatic escaping. We believe the other two factors are outweighed by the benefits of continuation quotes.<br>&gt; <br>&gt; Use a different delimiter for multiline strings<br>&gt; <br>&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. This solution was rejected because it has the same issues as the &quot;no continuation character&quot; solution, and because it was mixing two orthogonal issues (multiline strings and alternate delimiters).<br>&gt; <br>&gt; Another suggestion was to support a heredoc syntax, which would allow you to specify a placeholder string literal on one line whose content begins on the next line, running until some arbitrary delimiter. For instance, if Swift adopted Perl 5&#39;s syntax, it might support code like:<br>&gt; <br>&gt; connection.sendString(&lt;&lt;&quot;END&quot;)<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; END<br>&gt; In addition to the issues with the &quot;&quot;&quot; syntax, heredocs are complicated both to explain and to parse, and are not a natural extension of Swift&#39;s current string syntax.<br>&gt; <br>&gt; Both of these suggestions address interesting issues with string literals, solving compelling use cases. They&#39;re just not that good at fixing the specific issue at hand. We might consider them in the future to address those problems to which they are better suited.<br>&gt; <br>&gt; Fixing other string literal readability issues<br>&gt; <br>&gt; This proposal is narrowly aimed at multiline strings. It intentionally doesn&#39;t tackle several other problems with string literals:<br>&gt; <br>&gt; Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br>&gt; <br>&gt; Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br>&gt; <br>&gt; String literals consisting of very long pieces of text which are best represented completely verbatim.<br>&gt; <br>&gt; These are likely to be subjects of future proposals, though not necessarily during Swift 3.<br>&gt; <br>&gt; This proposal also does not attempt to address regular expression literals. The members of the core team who are interested in regular expression support have ambitions for that feature which put it out of scope for Swift 3.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/c0700ca8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>On Apr 27, 2016, at 1:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.<br>&gt; <br>&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed and what concerns I have.<br></p><p>Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br></p><p>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt; <br>&gt; Swift-evolution thread: multi-line string literals. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;I would suggest - right up front - pointing out that “heredoc” style syntaxes are another potential solution to this problem, but that they are heavier weight (and other tradeoffs).  This proposal doesn’t attempt to address there heredoc usecase, but it also doesn’t preclude adding it.  It is also mentioning up front that this is part of multi-part proposal to make string literals nicer, and point to the “possible future directions” section at the end.<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt; <br>&gt; This draft differs from the prototypes being thrown around on the list in that it specifies that comments should be treated as whitespace, and that whitespace-only lines in the middle of a multiline string should be ignored. I&#39;m not sure if this is feasible from a parsing standpoint, and I&#39;d like feedback from implementers on this point.<br>&gt; <br>White space seems “implementable”, but I’m not sure that it is good.  Visually, it would break up the string literal and make it less obviously a unit.<br></p><p>Comments on the same line as a string chunk should *not* be split out IMO, in:<br></p><p>   let s = “fooo  // hello world<br>              “ nice to know you”<br></p><p>the “hello world” text should be included in the literal.  I suppose it would be possible to allow comments on whitespace lines, but I don’t see a reason to do that.  I’d suggest starting simple, since that could always be added down the road if there was great demand.<br>&gt; This draft also specifies diagnostics which should be included. Feedback on whether these are good choices would be welcome.<br>&gt; <br>I’d just say that these are suggested diagnostics that can be word smithed later.<br></p><p>&gt; I am considering allowing you to put a backslash before the newline to indicate it should not be included in the literal. In other words, this code:<br>&gt; <br>&gt; print(&quot;foo\<br>&gt; &quot;bar&quot;)<br>&gt; Would print &quot;foobar&quot;. However, I think this should probably be proposed separately, because there may be a better way to do it.<br>&gt; <br>I don’t see a reason to do that.  Why would this be helpful?<br>&gt; Benefits of continuation quotes<br>&gt; <br>&gt; It would be simpler to not require continuation quotes,<br>&gt; <br>I’d suggest being explicit here:<br></p><p>&quot;It would be simpler to not require continuation quotes at the start of subsequent lines, &quot;<br></p><p>&gt; <br>&gt; Rules 1 and 2 should treat comments as though they are whitespace; this allows you to comment out individual lines in a multiline string literal. (However, commenting out the last line of the string literal will still make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt; <br>As I mentioned above, I’d suggest keeping the proposal minimal - that makes it more likely to be accepted since you’re removing something that the discussion could rathole on.<br>&gt; Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br></p><p>I would add a “Potential Future Directions” section here, mention modifier characters, here doc, etc.  That will help explain how this proposal fits into your broader plan, and address the question of “ok, your XML example looks a little better, but what’s with all the escaping?!??” :-)<br></p><p><br>&gt; This has several advantages:<br>&gt; <br>&gt; It is simpler.<br>&gt; <br>&gt; It is less offensive to programmers&#39; sensibilities (since there are no unmatched &quot; characters).<br>&gt; <br>&gt; It does not require that you edit the string literal to insert a continuation quote in each line.<br>&gt; <br>&gt; Balanced against the advantages, however, is the loss of the improved diagnostics, code formatting, and visual affordances mentioned in the &quot;Benefits of continuation quotes&quot; section above.<br>&gt; <br>Just a writing observation, but by bulleting the advantages (and not bulleting the disadvantages) you’re making it look visually like the advantages are stronger or more important than the disadvantages.<br></p><p>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt; <br>&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between.<br>&gt; <br>Personally, I think that “”” could be the compelling heredoc designator we will also need. :-)  It would certainly fit elegantly with modifier characters, the same way that “” does.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/5e85f611/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 27, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>This is essentially the same solution I proposed way back in December: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002374.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002374.html&gt;<br></p><p>I still have the same reservations about copying and pasting. Copying a string into your code is going to require adding a continuation quote on every line. If the string being added has quotes itself, the process of adding continuation quotes is going to make the syntax highlighter go bonkers while they are being inserted. <br></p><p>Should we not have a master document that considers the pros and cons of many different solutions? I started writing one such treatise a few weeks ago, but I haven’t been able to finish it yet. Just being able to see all of the potential implementations compared in one place but provide some insight. I imagine that this a feature that won’t change once it’s implemented, so it’s important to get it right.<br></p><p>Tyler<br></p><p><br>&gt; On Apr 27, 2016, at 1:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 27, 2016, at 1:52 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed and what concerns I have.<br>&gt; <br>&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: multi-line string literals. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;I would suggest - right up front - pointing out that “heredoc” style syntaxes are another potential solution to this problem, but that they are heavier weight (and other tradeoffs).  This proposal doesn’t attempt to address there heredoc usecase, but it also doesn’t preclude adding it.  It is also mentioning up front that this is part of multi-part proposal to make string literals nicer, and point to the “possible future directions” section at the end.<br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt;&gt; <br>&gt;&gt; This draft differs from the prototypes being thrown around on the list in that it specifies that comments should be treated as whitespace, and that whitespace-only lines in the middle of a multiline string should be ignored. I&#39;m not sure if this is feasible from a parsing standpoint, and I&#39;d like feedback from implementers on this point.<br>&gt;&gt; <br>&gt; White space seems “implementable”, but I’m not sure that it is good.  Visually, it would break up the string literal and make it less obviously a unit.<br>&gt; <br>&gt; Comments on the same line as a string chunk should *not* be split out IMO, in:<br>&gt; <br>&gt;    let s = “fooo  // hello world<br>&gt;               “ nice to know you”<br>&gt; <br>&gt; the “hello world” text should be included in the literal.  I suppose it would be possible to allow comments on whitespace lines, but I don’t see a reason to do that.  I’d suggest starting simple, since that could always be added down the road if there was great demand.<br>&gt;&gt; This draft also specifies diagnostics which should be included. Feedback on whether these are good choices would be welcome.<br>&gt;&gt; <br>&gt; I’d just say that these are suggested diagnostics that can be word smithed later.<br>&gt; <br>&gt;&gt; I am considering allowing you to put a backslash before the newline to indicate it should not be included in the literal. In other words, this code:<br>&gt;&gt; <br>&gt;&gt; print(&quot;foo\<br>&gt;&gt; &quot;bar&quot;)<br>&gt;&gt; Would print &quot;foobar&quot;. However, I think this should probably be proposed separately, because there may be a better way to do it.<br>&gt;&gt; <br>&gt; I don’t see a reason to do that.  Why would this be helpful?<br>&gt;&gt; Benefits of continuation quotes<br>&gt;&gt; <br>&gt;&gt; It would be simpler to not require continuation quotes,<br>&gt;&gt; <br>&gt; I’d suggest being explicit here:<br>&gt; <br>&gt; &quot;It would be simpler to not require continuation quotes at the start of subsequent lines, &quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this allows you to comment out individual lines in a multiline string literal. (However, commenting out the last line of the string literal will still make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt;&gt; <br>&gt; As I mentioned above, I’d suggest keeping the proposal minimal - that makes it more likely to be accepted since you’re removing something that the discussion could rathole on.<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt; <br>&gt; <br>&gt; I would add a “Potential Future Directions” section here, mention modifier characters, here doc, etc.  That will help explain how this proposal fits into your broader plan, and address the question of “ok, your XML example looks a little better, but what’s with all the escaping?!??” :-)<br>&gt; <br>&gt; <br>&gt;&gt; This has several advantages:<br>&gt;&gt; <br>&gt;&gt; It is simpler.<br>&gt;&gt; <br>&gt;&gt; It is less offensive to programmers&#39; sensibilities (since there are no unmatched &quot; characters).<br>&gt;&gt; <br>&gt;&gt; It does not require that you edit the string literal to insert a continuation quote in each line.<br>&gt;&gt; <br>&gt;&gt; Balanced against the advantages, however, is the loss of the improved diagnostics, code formatting, and visual affordances mentioned in the &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt; <br>&gt; Just a writing observation, but by bulleting the advantages (and not bulleting the disadvantages) you’re making it look visually like the advantages are stronger or more important than the disadvantages.<br>&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt;&gt; <br>&gt;&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between.<br>&gt;&gt; <br>&gt; Personally, I think that “”” could be the compelling heredoc designator we will also need. :-)  It would certainly fit elegantly with modifier characters, the same way that “” does.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/6fbff70e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 27, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Brent,<br></p><p>What I mean is a document like the error handling rationale. Since there are so many potential solutions to this problem.<br></p><p>And ah right! You were the one who responded and proposed an implementation.<br></p><p>Thanks,<br></p><p>Tyler<br></p><p><br>&gt; On Apr 27, 2016, at 2:19 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; This is essentially the same solution I proposed way back in December: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002374.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002374.html&gt;<br>&gt; <br>&gt; I still have the same reservations about copying and pasting. Copying a string into your code is going to require adding a continuation quote on every line. If the string being added has quotes itself, the process of adding continuation quotes is going to make the syntax highlighter go bonkers while they are being inserted. <br>&gt; <br>&gt; Should we not have a master document that considers the pros and cons of many different solutions? I started writing one such treatise a few weeks ago, but I haven’t been able to finish it yet. Just being able to see all of the potential implementations compared in one place but provide some insight. I imagine that this a feature that won’t change once it’s implemented, so it’s important to get it right.<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 1:58 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 27, 2016, at 1:52 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve gone ahead and drafted this proposal, with some small extensions and adjustments. See the &quot;Draft Notes&quot; section for details of what I&#39;ve changed and what concerns I have.<br>&gt;&gt; <br>&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: multi-line string literals. &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;I would suggest - right up front - pointing out that “heredoc” style syntaxes are another potential solution to this problem, but that they are heavier weight (and other tradeoffs).  This proposal doesn’t attempt to address there heredoc usecase, but it also doesn’t preclude adding it.  It is also mentioning up front that this is part of multi-part proposal to make string literals nicer, and point to the “possible future directions” section at the end.<br>&gt;&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This draft differs from the prototypes being thrown around on the list in that it specifies that comments should be treated as whitespace, and that whitespace-only lines in the middle of a multiline string should be ignored. I&#39;m not sure if this is feasible from a parsing standpoint, and I&#39;d like feedback from implementers on this point.<br>&gt;&gt;&gt; <br>&gt;&gt; White space seems “implementable”, but I’m not sure that it is good.  Visually, it would break up the string literal and make it less obviously a unit.<br>&gt;&gt; <br>&gt;&gt; Comments on the same line as a string chunk should *not* be split out IMO, in:<br>&gt;&gt; <br>&gt;&gt;    let s = “fooo  // hello world<br>&gt;&gt;               “ nice to know you”<br>&gt;&gt; <br>&gt;&gt; the “hello world” text should be included in the literal.  I suppose it would be possible to allow comments on whitespace lines, but I don’t see a reason to do that.  I’d suggest starting simple, since that could always be added down the road if there was great demand.<br>&gt;&gt;&gt; This draft also specifies diagnostics which should be included. Feedback on whether these are good choices would be welcome.<br>&gt;&gt;&gt; <br>&gt;&gt; I’d just say that these are suggested diagnostics that can be word smithed later.<br>&gt;&gt; <br>&gt;&gt;&gt; I am considering allowing you to put a backslash before the newline to indicate it should not be included in the literal. In other words, this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(&quot;foo\<br>&gt;&gt;&gt; &quot;bar&quot;)<br>&gt;&gt;&gt; Would print &quot;foobar&quot;. However, I think this should probably be proposed separately, because there may be a better way to do it.<br>&gt;&gt;&gt; <br>&gt;&gt; I don’t see a reason to do that.  Why would this be helpful?<br>&gt;&gt;&gt; Benefits of continuation quotes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be simpler to not require continuation quotes,<br>&gt;&gt;&gt; <br>&gt;&gt; I’d suggest being explicit here:<br>&gt;&gt; <br>&gt;&gt; &quot;It would be simpler to not require continuation quotes at the start of subsequent lines, &quot;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rules 1 and 2 should treat comments as though they are whitespace; this allows you to comment out individual lines in a multiline string literal. (However, commenting out the last line of the string literal will still make it unterminated, so you don&#39;t have a completely free hand in commenting.)<br>&gt;&gt;&gt; <br>&gt;&gt; As I mentioned above, I’d suggest keeping the proposal minimal - that makes it more likely to be accepted since you’re removing something that the discussion could rathole on.<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would add a “Potential Future Directions” section here, mention modifier characters, here doc, etc.  That will help explain how this proposal fits into your broader plan, and address the question of “ok, your XML example looks a little better, but what’s with all the escaping?!??” :-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This has several advantages:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is simpler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is less offensive to programmers&#39; sensibilities (since there are no unmatched &quot; characters).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does not require that you edit the string literal to insert a continuation quote in each line.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Balanced against the advantages, however, is the loss of the improved diagnostics, code formatting, and visual affordances mentioned in the &quot;Benefits of continuation quotes&quot; section above.<br>&gt;&gt;&gt; <br>&gt;&gt; Just a writing observation, but by bulleting the advantages (and not bulleting the disadvantages) you’re making it look visually like the advantages are stronger or more important than the disadvantages.<br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between.<br>&gt;&gt;&gt; <br>&gt;&gt; Personally, I think that “”” could be the compelling heredoc designator we will also need. :-)  It would certainly fit elegantly with modifier characters, the same way that “” does.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/13bbe85e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 28, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Should we not have a master document that considers the pros and cons of many different solutions? I started writing one such treatise a few weeks ago, but I haven’t been able to finish it yet. Just being able to see all of the potential implementations compared in one place but provide some insight. I imagine that this a feature that won’t change once it’s implemented, so it’s important to get it right.<br></p><p>That might be a useful document to have, but I worry that we&#39;ll end up seeing the string feature proposals signed in triplicate, sent in, sent back, queried, lost, found, subjected to public inquiry, lost again, and finally buried in soft peat for three months and recycled as firelighters, all to end up in with basically the same proposals but with slightly different keywords. Not every decision needs that level of explicit, deep documentation. Some things you can think about, experiment with, discuss, and do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Probably the subject of this proposal(thread) should be changed to <br>something like &quot;multi-line string literals with escaping of special chars <br>and interpolation support&quot;<br>,as I believe many of us thinks about multi-line strings in source as <br>feature that allows us to have text *as-is*, without escaped characters, <br>without interpolation, in situations when the text contains a lot of \  \\ <br>\&quot;  &quot;  \(  \t   etc..<br></p><p>Probably someone can start new thread &quot;multi-line strings with text as-is, <br>without escaping&quot; - so it will be discussed separately from current suggestion.<br></p><p>On 28.04.2016 12:30, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; Should we not have a master document that considers the pros and cons<br>&gt;&gt; of many different solutions? I started writing one such treatise a few<br>&gt;&gt; weeks ago, but I haven’t been able to finish it yet. Just being able<br>&gt;&gt; to see all of the potential implementations compared in one place but<br>&gt;&gt; provide some insight. I imagine that this a feature that won’t change<br>&gt;&gt; once it’s implemented, so it’s important to get it right.<br>&gt;<br>&gt; That might be a useful document to have, but I worry that we&#39;ll end up<br>&gt; seeing the string feature proposals signed in triplicate, sent in, sent<br>&gt; back, queried, lost, found, subjected to public inquiry, lost again, and<br>&gt; finally buried in soft peat for three months and recycled as<br>&gt; firelighters, all to end up in with basically the same proposals but<br>&gt; with slightly different keywords. Not every decision needs that level of<br>&gt; explicit, deep documentation. Some things you can think about,<br>&gt; experiment with, discuss, and do.<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; White space seems “implementable”, but I’m not sure that it is good.  Visually, it would break up the string literal and make it less obviously a unit.<br>&gt; <br>&gt; Comments on the same line as a string chunk should *not* be split out IMO, in:<br>&gt; <br>&gt;    let s = “fooo  // hello world<br>&gt;               “ nice to know you”<br>&gt; <br>&gt; the “hello world” text should be included in the literal.  I suppose it would be possible to allow comments on whitespace lines, but I don’t see a reason to do that.  I’d suggest starting simple, since that could always be added down the road if there was great demand.<br></p><p>What I&#39;m actually suggesting is that comments *before* the continuing quote would be honored without terminating the literal:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot;	&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>//          &quot;		&lt;author&gt;\(author)&lt;/author&gt;<br>          &quot;	&lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;<br></p><p>A // or /* after the continuing quote would still be part of the literal.<br></p><p>I&#39;m preparing a second draft without that feature, though, so if you still think it&#39;s a bad idea, I&#39;ll drop it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br></p><p>I&#39;ve adopted these suggestions in some form, though I also ended up rewriting the explanation of why the feature was designed as it is and fusing it with material from &quot;Alternatives considered&quot;.<br></p><p>(Still not sure who I should list as a co-author. I&#39;m currently thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br></p><p>Multiline string literals<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: Second Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br></p><p>In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br></p><p>This proposal is one step in a larger plan to improve how string literals address various challenging use cases. It is not meant to solve all problems with escaping, nor to serve all use cases involving very long string literals. See the &quot;Future directions for string literals in general&quot; section for a sketch of the problems we ultimately want to address and some ideas of how we might do so.<br></p><p>Swift-evolution threads: multi-line string literals. (April) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line string literals (December) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br></p><p>Removes the comment feature, which was felt to be an unnecessary complication. This and the backslash feature have been listed as future directions. <br></p><p>Loosens the specification of diagnostics, suggesting instead of requiring fix-its.<br></p><p>Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br></p><p>Adds extensive discussion of other features which wold combine with this one.<br></p><p>I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br></p><p>As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>          &quot;&lt;catalog&gt;\n&quot; + <br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>          &quot; &lt;/book&gt;\n&quot; + <br>          &quot;&lt;/catalog&gt;&quot;<br>However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br></p><p>We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br></p><p>Our sample above could thus be written as:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;<br>If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br></p><p>This design is rather unusual, and it&#39;s worth pausing a moment to explain why it has been chosen.<br></p><p>The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br></p><p>We think continuation quotes offer several important advantages over the traditional design:<br></p><p>They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br></p><p>(This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br></p><p>Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br></p><p>Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed traditional quotes that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br></p><p>Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br></p><p>They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics or mode switches to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br></p><p>Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br></p><p>They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br></p><p>Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br></p><p>Nevertheless, the traditional design does has a few advantages:<br></p><p>It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br></p><p>There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. In some editors, new features aren&#39;t even necessary; TextMate, for instance, lets you insert a character on several lines simultaneously. And new tool features could also address other issues like escaping embedded quotes.<br></p><p>Naïve syntax highlighters may have trouble understanding this syntax. This is true, but naïve syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working some of the time with some contents, we don&#39;t think this occasional, accidental compatibility is a big enough gain to justify changing the design.<br></p><p>It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br></p><p>“That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br></p><p>“Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br></p><p>“Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br></p><p>“Oh, that makes sense. Thanks!”<br>In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br></p><p>Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br></p><p>On balance, we think continuation quotes are the best design for this problem.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br></p><p>When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br></p><p>If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br></p><p>If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. <br></p><p>The exact error messages and diagnostics provided are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br></p><p>Insert &quot; at the end of the current line to terminate the quote.<br></p><p>Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br></p><p>Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br></p><p>We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br></p><p>We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future directions for string literals in general<br></p><p>There are other issues with Swift&#39;s string handling which this proposal intentionally does not address:<br></p><p>Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br></p><p>Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br></p><p>Accommodating code formatting concerns like hard wrapping and commenting.<br></p><p>String literals consisting of very long pieces of text which are best represented completely verbatim, with minimal alteration.<br></p><p>This section briefly outlines some future proposals which might address these issues. Combined, we believe they would address most of the string literal use cases which Swift is currently not very good at.<br></p><p>Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#string-literal-modifiers&gt;String literal modifiers<br></p><p>A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a feature; lowercase characters disable a feature.<br></p><p>Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br></p><p>Modifiers are an extremely flexible feature which can be used for many proposes. Of the ideas listed below, we believe the e modifier is an urgent addition which should be included in Swift 3 if at all possible; the others are less urgent and most of them could be deferred, or at least added later if time allows.<br></p><p>Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br></p><p>Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo) followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br></p><p>Alternate delimiters: _ has no lowercase form, so it could be used to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_, __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br></p><p>Whitespace normalization: changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings purely to improve code formatting.<br></p><p>alert.informativeText =<br>    W&quot;\(appName) could not typeset the element “\(title)” because <br>     &quot;it includes a link to an element that has been removed from this <br>     &quot;book.&quot;<br>Localization: <br></p><p>alert.informativeText =<br>    LW&quot;\(appName) could not typeset the element “\(title)” because <br>      &quot;it includes a link to an element that has been removed from this <br>      &quot;book.&quot;<br>Comments: Embedding comments in string literals might be useful for literals containing regular expressions or other code.<br></p><p>Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#heredocs-or-other-verbatim-string-literal-features&gt;Heredocs or other &quot;verbatim string literal&quot; features<br></p><p>Sometimes it really is best to just splat something else down in the middle of a file full of Swift source code. Maybe the file is essentially a template and the literals are a majority of the code&#39;s contents, or maybe you&#39;re writing a code generator and just want to get string data into it with minimal fuss, or maybe people unfamiliar with Swift need to be able to edit the literals. Whatever the reason, the normal string literal syntax is just too burdensome.<br></p><p>One approach to this problem is heredocs. A heredoc allows you to put a placeholder for a literal on one line; the contents of the literal begin on the next line, running up to some delimiter. It would be possible to put multiple placeholders in a single line, and to apply string modifiers to them.<br></p><p>In Swift, this might look like:<br></p><p>print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>It was a dark and stormy \(timeOfDay) when <br>---<br>the Swift core team invented the \(interpolation) syntax.<br>END<br>Another possible approach would be to support traditional multiline string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might look like:<br></p><p>print(&quot;&quot;&quot;<br>It was a dark and stormy \(timeOfDay) when <br>&quot;&quot;&quot; + e&quot;&quot;&quot;<br>the Swift core team invented the \(interpolation) syntax.<br>&quot;&quot;&quot;)<br>Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#first-class-regular-expressions&gt;First-class regular expressions<br></p><p>Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br></p><p>In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring no continuation character<br></p><p>The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;&quot;<br>This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#skip-multiline-strings-and-just-support-heredocs&gt;Skip multiline strings and just support heredocs<br></p><p>There are definitely cases where a heredoc would be a better solution, such as generated code or code which is mostly literals with a little Swift sprinkled around. On the other hand, there are also cases where multiline strings are better: short strings in code which is meant to be read. If a single feature can&#39;t handle them both well, there&#39;s no shame in supporting the two features separately.<br></p><p>It makes sense to support multiline strings first because:<br></p><p>They extend existing syntax instead of introducing new syntax.<br></p><p>They are much easier to parse; heredocs require some kind of mode in the parser which kicks in at the start of the next line, whereas multiline string literals can be handled in the lexer.<br></p><p>As discussed in &quot;Rationale&quot;, they offer better diagnostics, code formatting, and visual scannability.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br></p><p>The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. Like heredocs, this might be a good alternative for certain use cases, but it has the same basic flaws as the &quot;no continuation character&quot; solution.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/833f01c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>April 29, 2016 at 12:00:00am</p></header><div class="content"><p>is it just me who would prefer a multiline string literal to not require a \backslash before each &quot;double quote&quot;?<br></p><p>Did you ever really use multiline string literals before? I did, and it&#39;s mostly for quick hacks where I wrote a script or tried something out quickly. And maybe I needed to put an XML snippet into a unit test case to see if my parser correctly parses or correctly rejects the snippet. The current proposal doesn&#39;t help this use case in any way. I cannot see which use case inspires multiline string literals which require double quotes to be escaped... I wouldn&#39;t use them if they were available. I&#39;d become an Android developer instead ;)<br></p><p>-Michael<br></p><p>&gt; Am 28.04.2016 um 23:56 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt; <br>&gt; I&#39;ve adopted these suggestions in some form, though I also ended up rewriting the explanation of why the feature was designed as it is and fusing it with material from &quot;Alternatives considered&quot;.<br>&gt; <br>&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br>&gt; <br>&gt; Multiline string literals<br>&gt; <br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Author(s): Brent Royal-Gordon<br>&gt; 	• Status: Second Draft<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt; <br>&gt; This proposal is one step in a larger plan to improve how string literals address various challenging use cases. It is not meant to solve all problems with escaping, nor to serve all use cases involving very long string literals. See the &quot;Future directions for string literals in general&quot; section for a sketch of the problems we ultimately want to address and some ideas of how we might do so.<br>&gt; <br>&gt; Swift-evolution threads: multi-line string literals. (April), multi-line string literals (December)<br>&gt; <br>&gt; Draft Notes<br>&gt; <br>&gt; 	• Removes the comment feature, which was felt to be an unnecessary complication. This and the backslash feature have been listed as future directions. <br>&gt; <br>&gt; 	• Loosens the specification of diagnostics, suggesting instead of requiring fix-its.<br>&gt; <br>&gt; 	• Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br>&gt; <br>&gt; 	• Adds extensive discussion of other features which wold combine with this one.<br>&gt; <br>&gt; 	• I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt; The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;&lt;catalog&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot; &lt;/book&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; <br>&gt; If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br>&gt; <br>&gt; Rationale<br>&gt; <br>&gt; This design is rather unusual, and it&#39;s worth pausing a moment to explain why it has been chosen.<br>&gt; <br>&gt; The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br>&gt; <br>&gt; We think continuation quotes offer several important advantages over the traditional design:<br>&gt; <br>&gt; 	• They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br>&gt; <br>&gt; (This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br>&gt; <br>&gt; Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br>&gt; <br>&gt; 	• Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed traditional quotes that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt; <br>&gt; Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br>&gt; <br>&gt; 	• They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics or mode switches to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt; <br>&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt; <br>&gt; 	• They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br>&gt; <br>&gt; Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br>&gt; <br>&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt; <br>&gt; 	• It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br>&gt; <br>&gt; 	• There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. In some editors, new features aren&#39;t even necessary; TextMate, for instance, lets you insert a character on several lines simultaneously. And new tool features could also address other issues like escaping embedded quotes.<br>&gt; <br>&gt; 	• Naïve syntax highlighters may have trouble understanding this syntax. This is true, but naïve syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working some of the time with some contents, we don&#39;t think this occasional, accidental compatibility is a big enough gain to justify changing the design.<br>&gt; <br>&gt; 	• It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. As an English Stack Exchange answer illustrates:<br>&gt; <br>&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt; <br>&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt; <br>&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt; <br>&gt; “Oh, that makes sense. Thanks!”<br>&gt; In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt; <br>&gt; Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br>&gt; <br>&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br>&gt; <br>&gt; 	• If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br>&gt; <br>&gt; 	• If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. <br>&gt; <br>&gt; The exact error messages and diagnostics provided are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br>&gt; <br>&gt; 	• Insert &quot; at the end of the current line to terminate the quote.<br>&gt; <br>&gt; 	• Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br>&gt; Future directions for multiline string literals<br>&gt; <br>&gt; 	• We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt; <br>&gt; 	• We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents.<br>&gt; <br>&gt; Future directions for string literals in general<br>&gt; <br>&gt; There are other issues with Swift&#39;s string handling which this proposal intentionally does not address:<br>&gt; <br>&gt; 	• Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br>&gt; <br>&gt; 	• Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br>&gt; <br>&gt; 	• Accommodating code formatting concerns like hard wrapping and commenting.<br>&gt; <br>&gt; 	• String literals consisting of very long pieces of text which are best represented completely verbatim, with minimal alteration.<br>&gt; <br>&gt; This section briefly outlines some future proposals which might address these issues. Combined, we believe they would address most of the string literal use cases which Swift is currently not very good at.<br>&gt; <br>&gt; Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br>&gt; <br>&gt; String literal modifiers<br>&gt; <br>&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a feature; lowercase characters disable a feature.<br>&gt; <br>&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt; <br>&gt; Modifiers are an extremely flexible feature which can be used for many proposes. Of the ideas listed below, we believe the e modifier is an urgent addition which should be included in Swift 3 if at all possible; the others are less urgent and most of them could be deferred, or at least added later if time allows.<br>&gt; <br>&gt; 	• Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br>&gt; <br>&gt; 	• Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo) followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br>&gt; <br>&gt; 	• Alternate delimiters: _ has no lowercase form, so it could be used to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_, __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br>&gt; <br>&gt; 	• Whitespace normalization: changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings purely to improve code formatting.<br>&gt; <br>&gt; alert.informativeText =<br>&gt;     W&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;      &quot;it includes a link to an element that has been removed from this <br>&gt;      &quot;book.&quot;<br>&gt; <br>&gt; 	• Localization: <br>&gt; <br>&gt; alert.informativeText =<br>&gt;     LW&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;       &quot;it includes a link to an element that has been removed from this <br>&gt;       &quot;book.&quot;<br>&gt; <br>&gt; 	• Comments: Embedding comments in string literals might be useful for literals containing regular expressions or other code.<br>&gt; <br>&gt; Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br>&gt; <br>&gt; Heredocs or other &quot;verbatim string literal&quot; features<br>&gt; <br>&gt; Sometimes it really is best to just splat something else down in the middle of a file full of Swift source code. Maybe the file is essentially a template and the literals are a majority of the code&#39;s contents, or maybe you&#39;re writing a code generator and just want to get string data into it with minimal fuss, or maybe people unfamiliar with Swift need to be able to edit the literals. Whatever the reason, the normal string literal syntax is just too burdensome.<br>&gt; <br>&gt; One approach to this problem is heredocs. A heredoc allows you to put a placeholder for a literal on one line; the contents of the literal begin on the next line, running up to some delimiter. It would be possible to put multiple placeholders in a single line, and to apply string modifiers to them.<br>&gt; <br>&gt; In Swift, this might look like:<br>&gt; <br>&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;<br>&gt; ))<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; ---<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; END<br>&gt; <br>&gt; Another possible approach would be to support traditional multiline string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might look like:<br>&gt; <br>&gt; print(&quot;&quot;&quot;<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;)<br>&gt; Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br>&gt; <br>&gt; First-class regular expressions<br>&gt; <br>&gt; Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br>&gt; <br>&gt; In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Requiring no continuation character<br>&gt; <br>&gt; The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt; <br>&gt; Skip multiline strings and just support heredocs<br>&gt; <br>&gt; There are definitely cases where a heredoc would be a better solution, such as generated code or code which is mostly literals with a little Swift sprinkled around. On the other hand, there are also cases where multiline strings are better: short strings in code which is meant to be read. If a single feature can&#39;t handle them both well, there&#39;s no shame in supporting the two features separately.<br>&gt; <br>&gt; It makes sense to support multiline strings first because:<br>&gt; <br>&gt; 	• They extend existing syntax instead of introducing new syntax.<br>&gt; <br>&gt; 	• They are much easier to parse; heredocs require some kind of mode in the parser which kicks in at the start of the next line, whereas multiline string literals can be handled in the lexer.<br>&gt; <br>&gt; 	• As discussed in &quot;Rationale&quot;, they offer better diagnostics, code formatting, and visual scannability.<br>&gt; <br>&gt; Use a different delimiter for multiline strings<br>&gt; <br>&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. Like heredocs, this might be a good alternative for certain use cases, but it has the same basic flaws as the &quot;no continuation character&quot; solution.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Did you ever really use multiline string literals before?<br></p><p>Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br></p><p>As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br></p><p>	let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	            &quot;&lt;catalog&gt;<br>	            &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>	            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>	            &quot; &lt;/book&gt;<br>	            &quot;&lt;/catalog&gt;&quot;_<br></p><p>Basically, I am trying very, *very* hard not to let this proposal turn into &quot;here&#39;s a huge pile of random string literal features which will become a giant catfight if we debate them all at once&quot;. Clearly this message is not getting through, but I&#39;m not sure how I should edit the proposal to make it clear enough.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>April 29, 2016 at 01:00:00am</p></header><div class="content"><p>I think the proposal is very clear on its intended scope.<br></p><p>I really like this idea. It&#39;s readable, and it&#39;s as simple and uncluttered as I think it could be while still allowing the tabbing of new lines. The one thing I dislike about multi line strings in Ruby is how you have to left align each new line, which can really disrupt the visual flow of your code, especially if you are several tabs of indentation deep.<br></p><p>I would love to see the addition (at some point) of the ability to escape all whitespaces preceding the new line, if that line does not begin with a quote and thus is meant to be a direct continuation of the preceding line. That way you could maintain your indentation without adding whitespaces between what are meant to be subsequent characters in the string literal.<br></p><p><br>On Apr 28, 2016, at 5:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; Did you ever really use multiline string literals before?<br>&gt; <br>&gt; Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br>&gt; <br>&gt; As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br>&gt; <br>&gt;  let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;              &quot;&lt;catalog&gt;<br>&gt;              &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;              &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;              &quot; &lt;/book&gt;<br>&gt;              &quot;&lt;/catalog&gt;&quot;_<br>&gt; <br>&gt; Basically, I am trying very, *very* hard not to let this proposal turn into &quot;here&#39;s a huge pile of random string literal features which will become a giant catfight if we debate them all at once&quot;. Clearly this message is not getting through, but I&#39;m not sure how I should edit the proposal to make it clear enough.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/b5a4da6f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 4:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Did you ever really use multiline string literals before?<br>&gt; <br>&gt; Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br>&gt; <br>&gt; As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br>&gt; <br>&gt; 	let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; 	            &quot;&lt;catalog&gt;<br>&gt; 	            &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt; 	            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt; 	            &quot; &lt;/book&gt;<br>&gt; 	            &quot;&lt;/catalog&gt;&quot;_<br></p><p>Other than the underscores (I&#39;m not sold on them but I could live with them), this is my favorite approach:<br></p><p>* It supports indented left-hand alignment, which is an important to me for readability<br>* It avoids painful `\n&quot;+` RHS constructions<br>* It&#39;s easy to scan and understand<br>* It&#39;s simple and harmonious<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 9:20 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 28, 2016, at 4:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you ever really use multiline string literals before?<br>&gt;&gt; <br>&gt;&gt; Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br>&gt;&gt; <br>&gt;&gt; As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br>&gt;&gt; <br>&gt;&gt;    let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;                &quot;&lt;catalog&gt;<br>&gt;&gt;                &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                &quot; &lt;/book&gt;<br>&gt;&gt;                &quot;&lt;/catalog&gt;&quot;_<br>&gt; <br>&gt; Other than the underscores (I&#39;m not sold on them but I could live with them), this is my favorite approach:<br>&gt; <br>&gt; * It supports indented left-hand alignment, which is an important to me for readability<br>&gt; * It avoids painful `\n&quot;+` RHS constructions<br>&gt; * It&#39;s easy to scan and understand<br>&gt; * It&#39;s simple and harmonious<br>&gt; <br>This would ultimately be my favorite approach. I do like the underscores, because they&#39;re unobtrusive and don&#39;t distract the eye, but I&#39;m interested to see alternative suggestions. However, I understand this is not considered in scope for the current proposal. Is the intention to propose alternate delimiters for Swift 3 now or wait?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 29, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; This would ultimately be my favorite approach. I do like the underscores, because they&#39;re unobtrusive and don&#39;t distract the eye, but I&#39;m interested to see alternative suggestions. However, I understand this is not considered in scope for the current proposal. Is the intention to propose alternate delimiters for Swift 3 now or wait?<br></p><p>My goal is to get Swift 3 string literals to the minimum viable feature set for tasks like scripting, templating, using regex libraries, and generating code. In my mind, the features I discuss in the &quot;Future directions for string literals&quot; section break down like this:<br></p><p>ABSOLUTELY NECESSARY—I definitely intend to propose these for Swift 3.<br></p><p>* Readable multiline strings<br>* Ability to disable escapes<br></p><p>REALLY NICE TO HAVE—We&#39;ll see how much the community wants them, and how much the core team thinks it can handle.<br></p><p>* Alternate delimiters<br>* Ability to disable escapes except for interpolation (and perhaps to selectively disable other escapes)<br></p><p>REALLY NICE TO HAVE, BUT WE CAN&#39;T—I would love to do these, but they&#39;re too hard for Swift 3.<br></p><p>* Very long, minimally massaged strings (i.e. heredocs)<br></p><p>CONVENIENCES—If we had infinite time...but we don&#39;t. And they might be dumb anyway.<br></p><p>* Whitespace normalization<br>* Embedded comments<br>* Localization<br>* Default modifier control<br></p><p>NOT INVENTED YET—Requires huge supporting designs we just don&#39;t have.<br></p><p>* Regex literals<br>* User-specified modifiers<br></p><p>I think we should definitely propose the items in &quot;Absolutely Necessary&quot; and consider proposing the ones in &quot;Really Nice To Have&quot; for Swift 3. I think we should definitely do the &quot;Really Nice To Have, But We Can&#39;t&quot; item in Swift 4. I think we should revisit and consider the others in Swift 4 and beyond.<br></p><p>* * *<br></p><p>I have intentionally described these features very broadly. For instance, I said &quot;alternate delimiters&quot;, not &quot;the `_` modifier&quot;. The specific designs I sketched in the proposal are merely examples of solutions to that class of problem. Here are a whole slew of other designs just for alternate delimiters:<br></p><p>* Use a different identifier-but-not-capitalizable character, like `$`.<br>* Use a different single-character ASCII delimiter, like `&#39;`.<br>* Use a different multi-character delimiter, like `&quot;&quot;&quot;`.<br>* Use a different Unicode delimiter, like smart quotes (`“foo ”`) or French quotes (`«foo»`) or Japanese quotes (`⸢foo⸥`).<br>* Permit arbitrary delimiters bounded by some specific, known character, like (just making this up) `&#39;~~~~~&#39;`.<br></p><p>That&#39;s just off the top of my head—there are probably a hundred more of these. What is presented in the &quot;Future directions for string literals&quot; section is a series of *example* solutions to illustrate the problems that need solving, not necessarily the exact thing we must write a proposal for in a few months or years. It&#39;s a sketch, not a roadmap.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>April 30, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I think we should definitely propose the items in &quot;Absolutely Necessary&quot; and consider proposing the ones in &quot;Really Nice To Have&quot; for Swift 3. I think we should definitely do the &quot;Really Nice To Have, But We Can&#39;t&quot; item in Swift 4. I think we should revisit and consider the others in Swift 4 and beyond.<br></p><p>Okay thanks. I wanted to make sure I wasn’t cluttering the thread with off-topic conversation. I agree with how you’ve prioritized the items for proposal.<br></p><p>&gt; I have intentionally described these features very broadly. For instance, I said &quot;alternate delimiters&quot;, not &quot;the `_` modifier&quot;. The specific designs I sketched in the proposal are merely examples of solutions to that class of problem. Here are a whole slew of other designs just for alternate delimiters:<br>&gt; <br>&gt; * Use a different identifier-but-not-capitalizable character, like `$`.<br>&gt; * Use a different single-character ASCII delimiter, like `&#39;`.<br>&gt; * Use a different multi-character delimiter, like `&quot;&quot;&quot;`.<br>&gt; * Use a different Unicode delimiter, like smart quotes (`“foo ”`) or French quotes (`«foo»`) or Japanese quotes (`⸢foo⸥`).<br>&gt; * Permit arbitrary delimiters bounded by some specific, known character, like (just making this up) `&#39;~~~~~&#39;`.<br>&gt; <br>&gt; That&#39;s just off the top of my head—there are probably a hundred more of these. What is presented in the &quot;Future directions for string literals&quot; section is a series of *example* solutions to illustrate the problems that need solving, not necessarily the exact thing we must write a proposal for in a few months or years. It&#39;s a sketch, not a roadmap.<br></p><p>I actually really like the examples of delimiters you sketched out in the proposal.<br></p><p>I have an idea for `_` as a modifier. What if it indicated that everything within the string literal is taken as part of the literal? All escapes are disabled and internal quotes are allowed. The `_` is already used to indicate in Swift when a value will not be used, so it follows (maybe?) that with strings it indicates that nothing in the literal will be evaluated. No expressions are ‘used’, so to speak.<br></p><p>The other suggestion I would make is to only use the `_` modifier at the beginning, unless I’m missing a reason why the compiler would need it at the end as well. I just bring it up because that is one less thing to forget to ‘close’ at the end, and it’s cleaner.<br></p><p>Here’s an example:<br></p><p>let string = _”This “string” allows anything<br>		“\(thisWillNotBeEvaluated)<br>		“Neither will these:<br>		“\w+\n<br>		“3 “slashes&quot; are fine too: \\\<br>		“etc. etc.”<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 for the proposal as a starting point<br></p><p><br>&gt; Am 30.04.2016 um 04:37 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; This would ultimately be my favorite approach. I do like the underscores, because they&#39;re unobtrusive and don&#39;t distract the eye, but I&#39;m interested to see alternative suggestions. However, I understand this is not considered in scope for the current proposal. Is the intention to propose alternate delimiters for Swift 3 now or wait?<br>&gt; <br>&gt; My goal is to get Swift 3 string literals to the minimum viable feature set for tasks like scripting, templating, using regex libraries, and generating code. In my mind, the features I discuss in the &quot;Future directions for string literals&quot; section break down like this:<br>&gt; <br>&gt; ABSOLUTELY NECESSARY—I definitely intend to propose these for Swift 3.<br>&gt; <br>&gt; * Readable multiline strings<br>&gt; * Ability to disable escapes<br></p><p>yep<br></p><p><br>&gt; <br>&gt; REALLY NICE TO HAVE—We&#39;ll see how much the community wants them, and how much the core team thinks it can handle.<br>&gt; <br>&gt; * Alternate delimiters<br></p><p>What’s the use for these if we already can disable escapes (after implementing the absolutely necessary proposals)?<br></p><p><br>&gt; * Ability to disable escapes except for interpolation (and perhaps to selectively disable other escapes)<br></p><p>That would be really useful (I would tend to push it up into the absolutely necessary category :-)<br></p><p><br>&gt; <br>&gt; REALLY NICE TO HAVE, BUT WE CAN&#39;T—I would love to do these, but they&#39;re too hard for Swift 3.<br>&gt; <br>&gt; * Very long, minimally massaged strings (i.e. heredocs)<br></p><p>Useful, but IMO not very pressing IF the tools support pasting multi line strings and adding/removing the leading marker<br></p><p><br>&gt; <br>&gt; CONVENIENCES—If we had infinite time...but we don&#39;t. And they might be dumb anyway.<br>&gt; <br>&gt; * Whitespace normalization<br>&gt; * Embedded comments<br></p><p>Embedded comments would be *very* nice. Absolutely sufficient would be the ability to embed line comments and empty lines, i.e. something like<br></p><p>let foo = <br>	&quot;blabla<br>	&quot;blabla<br></p><p>	// some comment here<br>	&quot;blabla<br>	&quot;blabla<br></p><p>	// another comment here<br>	&quot;blabla<br>	&quot;blabla<br>	<br>I’m not sure whether more complicated embedded comments (i.e. comments in the same line as a string line) would be worth the effort but might be doable with a modifier allowing them, e.g.<br>	c“blabla // some comment<br>This kind of embedding is certainly out of scope for Swift 3 and possibly Swift 4, but I’m hoping that line comments and empty lines might be even possible in Swift 3 :-)<br></p><p>-Thorsten<br></p><p><br>&gt; * Localization<br>&gt; * Default modifier control<br>&gt; <br>&gt; NOT INVENTED YET—Requires huge supporting designs we just don&#39;t have.<br>&gt; <br>&gt; * Regex literals<br>&gt; * User-specified modifiers<br>&gt; <br>&gt; I think we should definitely propose the items in &quot;Absolutely Necessary&quot; and consider proposing the ones in &quot;Really Nice To Have&quot; for Swift 3. I think we should definitely do the &quot;Really Nice To Have, But We Can&#39;t&quot; item in Swift 4. I think we should revisit and consider the others in Swift 4 and beyond.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; I have intentionally described these features very broadly. For instance, I said &quot;alternate delimiters&quot;, not &quot;the `_` modifier&quot;. The specific designs I sketched in the proposal are merely examples of solutions to that class of problem. Here are a whole slew of other designs just for alternate delimiters:<br>&gt; <br>&gt; * Use a different identifier-but-not-capitalizable character, like `$`.<br>&gt; * Use a different single-character ASCII delimiter, like `&#39;`.<br>&gt; * Use a different multi-character delimiter, like `&quot;&quot;&quot;`.<br>&gt; * Use a different Unicode delimiter, like smart quotes (`“foo ”`) or French quotes (`«foo»`) or Japanese quotes (`⸢foo⸥`).<br>&gt; * Permit arbitrary delimiters bounded by some specific, known character, like (just making this up) `&#39;~~~~~&#39;`.<br>&gt; <br>&gt; That&#39;s just off the top of my head—there are probably a hundred more of these. What is presented in the &quot;Future directions for string literals&quot; section is a series of *example* solutions to illustrate the problems that need solving, not necessarily the exact thing we must write a proposal for in a few months or years. It&#39;s a sketch, not a roadmap.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 30, 2016 at 08:00:00am</p></header><div class="content"><p>let whyOwhy = _&quot;\<br>    !!    Can&#39;t understand what improvements it truly delivers <br>    !!        It basically removes a handful of characters<br>    !!    It works today<br>    !!        But I don&#39;t see it as a likable foundations for adding in future enhancements<br>    !!\<br>    !!    I don&#39;t envy the people who will have to support it outside of xcode<br>    !!        Or even in xcode (considering how it currently struggles with indents/formatting<br>    !!    As for elegance, beauty is in the eye of the beholder, they say.<br>    &quot;_<br> var json = _&quot;[json]\<br>!!{<br>!!  &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>!!  &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>!!  &quot;rational&quot; : [<br>!!          &quot;Here we go again&quot;<br>!!          &quot;How will xcode help make these workable&quot;<br>!!       ]<br>!!}<br>&quot;_<br></p><p> [_&quot;]  --&gt; start string<br> [_&quot;\] --&gt; start line + ignore spaces until eol <br> [!!\]  --&gt; ignore everything until eol... basically the gap does not exits<br> [&quot;_]  --&gt; terminate string<br> [_&quot;[TYPEID]\] --&gt; start string knowing that it a verifyer or a formatter (or a chain of) understanding TYPEID can syntax check or format or or or<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Apr 29, 2016, at 4:20 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 28, 2016, at 4:52 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you ever really use multiline string literals before?<br>&gt;&gt; <br>&gt;&gt; Yes. I used Perl in the CGI script era. Believe me, I have used every quoting syntax it supports extensively, including `&#39;` strings, `&quot;` strings, `q` strings, `qq` strings, and heredocs. This proposal is educated by knowledge of their foibles.<br>&gt;&gt; <br>&gt;&gt; As outlined in the &quot;Future directions for string literals in general&quot; section, I believe alternate delimiters (so you can embed quotes) are a separate feature and should be handled in a separate proposal. Once both features are available, they can be combined. For instance, using the `_&quot;foo&quot;_` syntax I sketch there for alternate delimiters, you could say:<br>&gt;&gt; <br>&gt;&gt;    let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;                &quot;&lt;catalog&gt;<br>&gt;&gt;                &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                &quot; &lt;/book&gt;<br>&gt;&gt;                &quot;&lt;/catalog&gt;&quot;_<br>&gt; <br>&gt; Other than the underscores (I&#39;m not sold on them but I could live with them), this is my favorite approach:<br>&gt; <br>&gt; * It supports indented left-hand alignment, which is an important to me for readability<br>&gt; * It avoids painful `\n&quot;+` RHS constructions<br>&gt; * It&#39;s easy to scan and understand<br>&gt; * It&#39;s simple and harmonious<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/6ea8a865/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>On 29.04.2016 1:31, Michael Peternell via swift-evolution wrote:<br>&gt; is it just me who would prefer a multiline string literal to not require<br>&gt; a \backslash before each &quot;double quote&quot;?<br></p><p>You are not alone ;-)<br>But, as I understand, the proposal does not even try to solve a problem of <br>*as-is* text in sources, but is fighting against just \n&quot;+ at the end of <br>the string. That is what is proposed. I don&#39;t feel like it is a valuable <br>improvement, but it is OK for me to have such feature in language.<br></p><p>IMO we need just 2 variants: current method where we can use all the <br>escaped chars, interpolation, \n and closing quotes, and additionally <br>should have a feature to paste text *as-is*, without escapes and <br>interpolation. For example :<br></p><p>let xml = &quot;\<br>|&lt;?xml version=&quot;1.0&quot;?&gt;<br>|&lt;catalog&gt;<br>|    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>|        &lt;author&gt;myAuthor&lt;/author&gt;<br>|        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>|    &lt;/book&gt;<br>|&lt;/catalog&gt;<br>&quot;<br></p><p>or<br></p><p>let xml = _&quot;<br>&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&quot;&lt;catalog&gt;<br>&quot;    &lt;book id=&quot;myid&quot; empty=&quot;&quot;&gt;<br>&quot;        &lt;author&gt;myAuthor&lt;/author&gt;<br>&quot;        &lt;title&gt;myTitle \tutorial 1\(edition 2)&lt;/title&gt;<br>&quot;    &lt;/book&gt;<br>&quot;&lt;/catalog&gt;<br></p><p><br>&gt;<br>&gt; Did you ever really use multiline string literals before? I did, and<br>&gt; it&#39;s mostly for quick hacks where I wrote a script or tried something<br>&gt; out quickly. And maybe I needed to put an XML snippet into a unit test<br>&gt; case to see if my parser correctly parses or correctly rejects the<br>&gt; snippet. The current proposal doesn&#39;t help this use case in any way. I<br>&gt; cannot see which use case inspires multiline string literals which<br>&gt; require double quotes to be escaped... I wouldn&#39;t use them if they were<br>&gt; available. I&#39;d become an Android developer instead ;)<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;&gt; Am 28.04.2016 um 23:56 schrieb Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate<br>&gt;&gt;&gt; in a pull request if you prefer that.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve adopted these suggestions in some form, though I also ended up<br>&gt;&gt; rewriting the explanation of why the feature was designed as it is and<br>&gt;&gt; fusing it with material from &quot;Alternatives considered&quot;.<br>&gt;&gt;<br>&gt;&gt; (Still not sure who I should list as a co-author. I&#39;m currently<br>&gt;&gt; thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br>&gt;&gt;<br>&gt;&gt; Multiline string literals<br>&gt;&gt;<br>&gt;&gt; • Proposal: SE-NNNN • Author(s): Brent Royal-Gordon • Status: Second<br>&gt;&gt; Draft • Review manager: TBD Introduction<br>&gt;&gt;<br>&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal<br>&gt;&gt; is the \n escape. String literals specified in this way are generally<br>&gt;&gt; ugly and unreadable. We propose a multiline string feature inspired by<br>&gt;&gt; English punctuation which is a straightforward extension of our<br>&gt;&gt; existing string literals.<br>&gt;&gt;<br>&gt;&gt; This proposal is one step in a larger plan to improve how string<br>&gt;&gt; literals address various challenging use cases. It is not meant to<br>&gt;&gt; solve all problems with escaping, nor to serve all use cases involving<br>&gt;&gt; very long string literals. See the &quot;Future directions for string<br>&gt;&gt; literals in general&quot; section for a sketch of the problems we<br>&gt;&gt; ultimately want to address and some ideas of how we might do so.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution threads: multi-line string literals. (April),<br>&gt;&gt; multi-line string literals (December)<br>&gt;&gt;<br>&gt;&gt; Draft Notes<br>&gt;&gt;<br>&gt;&gt; • Removes the comment feature, which was felt to be an unnecessary<br>&gt;&gt; complication. This and the backslash feature have been listed as<br>&gt;&gt; future directions.<br>&gt;&gt;<br>&gt;&gt; • Loosens the specification of diagnostics, suggesting instead of<br>&gt;&gt; requiring fix-its.<br>&gt;&gt;<br>&gt;&gt; • Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot;<br>&gt;&gt; section.<br>&gt;&gt;<br>&gt;&gt; • Adds extensive discussion of other features which wold combine with<br>&gt;&gt; this one.<br>&gt;&gt;<br>&gt;&gt; • I&#39;ve listed only myself as an author because I don&#39;t want to put<br>&gt;&gt; anyone else&#39;s name to a document they haven&#39;t seen, but there are<br>&gt;&gt; others who deserve to be listed (John Holdsworth at least). Let me<br>&gt;&gt; know if you think you should be included.<br>&gt;&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; As Swift begins to move into roles beyond app development, code which<br>&gt;&gt; needs to generate text becomes a more important use case. Consider,<br>&gt;&gt; for instance, generating even a small XML string:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt;&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt; The string is practically unreadable, its structure drowned in escapes<br>&gt;&gt; and run-together lines; it looks like little more than line noise. We<br>&gt;&gt; can improve its readability somewhat by concatenating separate strings<br>&gt;&gt; for each line and using real tabs instead of \t escapes:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;&lt;catalog&gt;\n&quot; +<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot; &lt;/book&gt;\n&quot; +<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &quot;&lt;/catalog&gt;&quot; However, this creates a more complex expression for the<br>&gt;&gt; type checker, and there&#39;s still far more punctuation than ought to be<br>&gt;&gt; necessary. If the most important goal of Swift is making code<br>&gt;&gt; readable, this kind of code falls far short of that goal.<br>&gt;&gt;<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches<br>&gt;&gt; the end of the line without encountering an end quote, it should look<br>&gt;&gt; at the next line. If it sees a quote at the beginning (a &quot;continuation<br>&gt;&gt; quote&quot;), the string literal contains a newline and then continues on<br>&gt;&gt; that line. Otherwise, the string literal is unterminated and<br>&gt;&gt; syntactically invalid.<br>&gt;&gt;<br>&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &quot;&lt;catalog&gt; &quot; &lt;book id=\&quot;bk101\&quot;<br>&gt;&gt; empty=\&quot;\&quot;&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt; &quot; &lt;/book&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt;<br>&gt;&gt; If the second or subsequent lines had not begun with a quotation mark,<br>&gt;&gt; or the trailing quotation mark after the &lt;/catalog&gt;tag had not been<br>&gt;&gt; included, Swift would have emitted an error.<br>&gt;&gt;<br>&gt;&gt; Rationale<br>&gt;&gt;<br>&gt;&gt; This design is rather unusual, and it&#39;s worth pausing a moment to<br>&gt;&gt; explain why it has been chosen.<br>&gt;&gt;<br>&gt;&gt; The traditional design for this feature, seen in languages like Perl<br>&gt;&gt; and Python, simply places one delimiter at the beginning of the<br>&gt;&gt; literal and another at the end. Individual lines in the literal are<br>&gt;&gt; not marked in any way.<br>&gt;&gt;<br>&gt;&gt; We think continuation quotes offer several important advantages over<br>&gt;&gt; the traditional design:<br>&gt;&gt;<br>&gt;&gt; • They help the compiler pinpoint errors in string literal delimiting.<br>&gt;&gt; Traditional multiline strings have a serious weakness: if you forget<br>&gt;&gt; the closing quote, the compiler has no idea where you wanted the<br>&gt;&gt; literal to end. It simply continues on until the compiler encounters<br>&gt;&gt; another quote (or the end of the file). If you&#39;re lucky, the text<br>&gt;&gt; after that quote is not valid code, and the resulting error will at<br>&gt;&gt; least point you to the next string literal in the file. If you&#39;re<br>&gt;&gt; unlucky, you&#39;ll get a seemingly unrelated error several literals<br>&gt;&gt; later, an unbalanced brace error at the end of the file, or perhaps<br>&gt;&gt; even code that compiles but does something totally wrong.<br>&gt;&gt;<br>&gt;&gt; (This is not a minor concern. Many popular languages, including C and<br>&gt;&gt; Swift 2, specifically reject newlines in string literals to prevent<br>&gt;&gt; this from happening.)<br>&gt;&gt;<br>&gt;&gt; Continuation quotes provide the compiler with redundant information<br>&gt;&gt; about your intent. If you forget a closing quote, the continuation<br>&gt;&gt; quotes give the compiler a very good idea of where you meant to put<br>&gt;&gt; it. The compiler can point you to (or at least very near) the end of<br>&gt;&gt; the literal, where you want to insert the quote, rather than showing<br>&gt;&gt; you the beginning of the literal or even some unrelated error later in<br>&gt;&gt; the file that was caused by the missing quote.<br>&gt;&gt;<br>&gt;&gt; • Temporarily unclosed literals don&#39;t make editors go haywire. The<br>&gt;&gt; syntax highlighter has the same trouble parsing half-written, unclosed<br>&gt;&gt; traditional quotes that the compiler does: It can&#39;t tell where the<br>&gt;&gt; literal is supposed to end and the code should begin. It must either<br>&gt;&gt; apply heuristics to try to guess where the literal ends, or<br>&gt;&gt; incorrectly color everything between the opening quote and the next<br>&gt;&gt; closing quote as a string literal. This can cause the file&#39;s coloring<br>&gt;&gt; to alternate distractingly between &quot;string literal&quot; and &quot;running<br>&gt;&gt; code&quot;.<br>&gt;&gt;<br>&gt;&gt; Continuation quotes give the syntax highlighter enough context to<br>&gt;&gt; guess at the correct coloration, even when the string isn&#39;t complete<br>&gt;&gt; yet. Lines with a continuation quote are literals; lines without are<br>&gt;&gt; code. At worst, the syntax highlighter might incorrectly color a few<br>&gt;&gt; characters at the end of a line, rather than the remainder of the<br>&gt;&gt; file.<br>&gt;&gt;<br>&gt;&gt; • They separate indentation from the string&#39;s contents. Traditional<br>&gt;&gt; multiline strings usually include all of the content between the start<br>&gt;&gt; and end delimiters, including leading whitespace. This means that it&#39;s<br>&gt;&gt; usually impossible to indent a multiline string, so including one<br>&gt;&gt; breaks up the flow of the surrounding code, making it less readable.<br>&gt;&gt; Some languages apply heuristics or mode switches to try to remove<br>&gt;&gt; indentation, but like all heuristics, these are mistake-prone and<br>&gt;&gt; murky.<br>&gt;&gt;<br>&gt;&gt; Continuation quotes neatly avoid this problem. Whitespace before the<br>&gt;&gt; continuation quote is indentation used to format the source code;<br>&gt;&gt; whitespace after the continuation quote is part of the string literal.<br>&gt;&gt; The interpretation of the code is perfectly clear to both compiler and<br>&gt;&gt; programmer.<br>&gt;&gt;<br>&gt;&gt; • They improve the ability to quickly recognize the literal.<br>&gt;&gt; Traditional multiline strings don&#39;t provide much visual help. To find<br>&gt;&gt; the end, you must visually scan until you find the matching delimiter,<br>&gt;&gt; which may be only one or a few characters long. When looking at a<br>&gt;&gt; random line of source, it can be hard to tell at a glance whether it&#39;s<br>&gt;&gt; code or literal. Syntax highlighting can help with these issues, but<br>&gt;&gt; it&#39;s often unreliable, especially with advanced, idiosyncratic string<br>&gt;&gt; literal features like multiline strings.<br>&gt;&gt;<br>&gt;&gt; Continuation quotes solve these problems. To find the end of the<br>&gt;&gt; literal, just scan down the column of continuation characters until<br>&gt;&gt; they end. To figure out if a given line of source is part of a<br>&gt;&gt; literal, just see if it starts with a quote mark. The meaning of the<br>&gt;&gt; source becomes obvious at a glance.<br>&gt;&gt;<br>&gt;&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt;&gt;<br>&gt;&gt; • It is simpler. Although continuation quotes are more complex, we<br>&gt;&gt; believe that the advantages listed above pay for that complexity.<br>&gt;&gt;<br>&gt;&gt; • There is no need to edit the intervening lines to add continuation<br>&gt;&gt; quotes. While the additional effort required to insert continuation<br>&gt;&gt; quotes is an important downside, we believe that tool support,<br>&gt;&gt; including both compiler fix-its and perhaps editor support for<br>&gt;&gt; commands like &quot;Paste as String Literal&quot;, can address this issue. In<br>&gt;&gt; some editors, new features aren&#39;t even necessary; TextMate, for<br>&gt;&gt; instance, lets you insert a character on several lines simultaneously.<br>&gt;&gt; And new tool features could also address other issues like escaping<br>&gt;&gt; embedded quotes.<br>&gt;&gt;<br>&gt;&gt; • Naïve syntax highlighters may have trouble understanding this<br>&gt;&gt; syntax. This is true, but naïve syntax highlighters generally have<br>&gt;&gt; terrible trouble with advanced string literal constructs; some<br>&gt;&gt; struggle with even basic ones. While there are some designs (like<br>&gt;&gt; Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into<br>&gt;&gt; working some of the time with some contents, we don&#39;t think this<br>&gt;&gt; occasional, accidental compatibility is a big enough gain to justify<br>&gt;&gt; changing the design.<br>&gt;&gt;<br>&gt;&gt; • It looks funny—quotes should always be in matched pairs. We aren&#39;t<br>&gt;&gt; aware of another programming language which uses unbalanced quotes in<br>&gt;&gt; string literals, but there is one very important precedent for this<br>&gt;&gt; kind of formatting: natural languages. English, for instance, uses a<br>&gt;&gt; very similar format for quoting multiple lines of dialog by the same<br>&gt;&gt; speaker. As an English Stack Exchange answer illustrates:<br>&gt;&gt;<br>&gt;&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm<br>&gt;&gt; would there be in using quotation marks at the end of every<br>&gt;&gt; paragraph?”<br>&gt;&gt;<br>&gt;&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed<br>&gt;&gt; quotes at the end of every paragraph, then you would need to<br>&gt;&gt; reidentify the speaker with every subsequent paragraph.<br>&gt;&gt;<br>&gt;&gt; “Say a narrative was describing two or three people engaged in a<br>&gt;&gt; lengthy conversation. If you closed the quotation marks in the<br>&gt;&gt; previous paragraph, then a reader wouldn’t be able to easily tell if<br>&gt;&gt; the previous speaker was extending his point, or if someone else in<br>&gt;&gt; the room had picked up the conversation. By leaving the previous<br>&gt;&gt; paragraph’s quote unclosed, the reader knows that the previous speaker<br>&gt;&gt; is still the one talking.”<br>&gt;&gt;<br>&gt;&gt; “Oh, that makes sense. Thanks!” In English, omitting the ending<br>&gt;&gt; quotation mark tells the text&#39;s reader that the quote continues on the<br>&gt;&gt; next line, while including a quotation mark at the beginning of the<br>&gt;&gt; next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt;&gt;<br>&gt;&gt; Similarly, in this proposal, omitting the ending quotation mark tells<br>&gt;&gt; the code&#39;s reader (and compiler) that the string literal continues on<br>&gt;&gt; the next line, while including a quotation mark at the beginning of<br>&gt;&gt; the next line reminds the reader (and compiler) that they&#39;re in the<br>&gt;&gt; middle of a string literal.<br>&gt;&gt;<br>&gt;&gt; On balance, we think continuation quotes are the best design for this<br>&gt;&gt; problem.<br>&gt;&gt;<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt;&gt; without finding a closing quote, it examines the next line, applying<br>&gt;&gt; the following rules:<br>&gt;&gt;<br>&gt;&gt; • If the next line begins with whitespace followed by a continuation<br>&gt;&gt; quote, then the string literal contains a newline followed by the<br>&gt;&gt; contents of the string literal starting on that line. (This line may<br>&gt;&gt; itself have no closing quote, in which case the same rules apply to<br>&gt;&gt; the line which follows.)<br>&gt;&gt;<br>&gt;&gt; • If the next line contains anything else, Swift raises a syntax error<br>&gt;&gt; for an unterminated string literal.<br>&gt;&gt;<br>&gt;&gt; The exact error messages and diagnostics provided are left to the<br>&gt;&gt; implementers to determine, but we believe it should be possible to<br>&gt;&gt; provide two fix-its which will help users learn the syntax and correct<br>&gt;&gt; string literal mistakes:<br>&gt;&gt;<br>&gt;&gt; • Insert &quot; at the end of the current line to terminate the quote.<br>&gt;&gt;<br>&gt;&gt; • Insert &quot; at the beginning of the next line (with some indentation<br>&gt;&gt; heuristics) to continue the quote on the next line.<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; Failing to close a string literal before the end of the line is<br>&gt;&gt; currently a syntax error, so no valid Swift code should be affected by<br>&gt;&gt; this change.<br>&gt;&gt;<br>&gt;&gt; Future directions for multiline string literals<br>&gt;&gt;<br>&gt;&gt; • We could permit comments before encountering a continuation quote to<br>&gt;&gt; be counted as whitespace, and permit empty lines in the middle of<br>&gt;&gt; string literals. This would allow you to comment out whole lines in<br>&gt;&gt; the literal.<br>&gt;&gt;<br>&gt;&gt; • We could allow you to put a trailing backslash on a line to indicate<br>&gt;&gt; that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s<br>&gt;&gt; contents.<br>&gt;&gt;<br>&gt;&gt; Future directions for string literals in general<br>&gt;&gt;<br>&gt;&gt; There are other issues with Swift&#39;s string handling which this<br>&gt;&gt; proposal intentionally does not address:<br>&gt;&gt;<br>&gt;&gt; • Reducing the amount of double-backslashing needed when working with<br>&gt;&gt; regular expression libraries, Windows paths, source code generation,<br>&gt;&gt; and other tasks where backslashes are part of the data.<br>&gt;&gt;<br>&gt;&gt; • Alternate delimiters or other strategies for writing strings with &quot;<br>&gt;&gt; characters in them.<br>&gt;&gt;<br>&gt;&gt; • Accommodating code formatting concerns like hard wrapping and<br>&gt;&gt; commenting.<br>&gt;&gt;<br>&gt;&gt; • String literals consisting of very long pieces of text which are<br>&gt;&gt; best represented completely verbatim, with minimal alteration.<br>&gt;&gt;<br>&gt;&gt; This section briefly outlines some future proposals which might<br>&gt;&gt; address these issues. Combined, we believe they would address most of<br>&gt;&gt; the string literal use cases which Swift is currently not very good<br>&gt;&gt; at.<br>&gt;&gt;<br>&gt;&gt; Please note that these are simply sketches of hypothetical future<br>&gt;&gt; designs; they may radically change before proposal, and some may never<br>&gt;&gt; be proposed at all. Many, perhaps most, will not be proposed for Swift<br>&gt;&gt; 3. We are sketching these designs not to propose and refine these<br>&gt;&gt; features immediately, but merely to show how we think they might be<br>&gt;&gt; solved in ways which complement this proposal.<br>&gt;&gt;<br>&gt;&gt; String literal modifiers<br>&gt;&gt;<br>&gt;&gt; A string literal modifier is a cluster of identifier characters which<br>&gt;&gt; goes before a string literal and adjusts the way it is parsed.<br>&gt;&gt; Modifers only alter the interpretation of the text in the literal, not<br>&gt;&gt; the type of data it produces; for instance, there will never be<br>&gt;&gt; something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++.<br>&gt;&gt; Uppercase characters enable a feature; lowercase characters disable a<br>&gt;&gt; feature.<br>&gt;&gt;<br>&gt;&gt; Modifiers can be attached to both single-line and multiline literals,<br>&gt;&gt; and could also be attached to other literal syntaxes which might be<br>&gt;&gt; introduced in the future. When used with multiline strings, only the<br>&gt;&gt; starting quote needs to carry the modifiers, not the continuation<br>&gt;&gt; quotes.<br>&gt;&gt;<br>&gt;&gt; Modifiers are an extremely flexible feature which can be used for many<br>&gt;&gt; proposes. Of the ideas listed below, we believe the e modifier is an<br>&gt;&gt; urgent addition which should be included in Swift 3 if at all<br>&gt;&gt; possible; the others are less urgent and most of them could be<br>&gt;&gt; deferred, or at least added later if time allows.<br>&gt;&gt;<br>&gt;&gt; • Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br>&gt;&gt;<br>&gt;&gt; • Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo)<br>&gt;&gt; followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by<br>&gt;&gt; the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br>&gt;&gt;<br>&gt;&gt; • Alternate delimiters: _ has no lowercase form, so it could be used<br>&gt;&gt; to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_,<br>&gt;&gt; __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br>&gt;&gt;<br>&gt;&gt; • Whitespace normalization: changes all runs of whitespace in the<br>&gt;&gt; literal to single space characters; this would allow you to use<br>&gt;&gt; multiline strings purely to improve code formatting.<br>&gt;&gt;<br>&gt;&gt; alert.informativeText = W&quot;\(appName) could not typeset the element<br>&gt;&gt; “\(title)” because &quot;it includes a link to an element that has been<br>&gt;&gt; removed from this &quot;book.&quot;<br>&gt;&gt;<br>&gt;&gt; • Localization:<br>&gt;&gt;<br>&gt;&gt; alert.informativeText = LW&quot;\(appName) could not typeset the element<br>&gt;&gt; “\(title)” because &quot;it includes a link to an element that has been<br>&gt;&gt; removed from this &quot;book.&quot;<br>&gt;&gt;<br>&gt;&gt; • Comments: Embedding comments in string literals might be useful for<br>&gt;&gt; literals containing regular expressions or other code.<br>&gt;&gt;<br>&gt;&gt; Eventually, user-specified string modifiers could be added to Swift,<br>&gt;&gt; perhaps as part of a hygienic macro system. It might also become<br>&gt;&gt; possible to change the default modifiers applied to literals in a<br>&gt;&gt; particular file or scope.<br>&gt;&gt;<br>&gt;&gt; Heredocs or other &quot;verbatim string literal&quot; features<br>&gt;&gt;<br>&gt;&gt; Sometimes it really is best to just splat something else down in the<br>&gt;&gt; middle of a file full of Swift source code. Maybe the file is<br>&gt;&gt; essentially a template and the literals are a majority of the code&#39;s<br>&gt;&gt; contents, or maybe you&#39;re writing a code generator and just want to<br>&gt;&gt; get string data into it with minimal fuss, or maybe people unfamiliar<br>&gt;&gt; with Swift need to be able to edit the literals. Whatever the reason,<br>&gt;&gt; the normal string literal syntax is just too burdensome.<br>&gt;&gt;<br>&gt;&gt; One approach to this problem is heredocs. A heredoc allows you to put<br>&gt;&gt; a placeholder for a literal on one line; the contents of the literal<br>&gt;&gt; begin on the next line, running up to some delimiter. It would be<br>&gt;&gt; possible to put multiple placeholders in a single line, and to apply<br>&gt;&gt; string modifiers to them.<br>&gt;&gt;<br>&gt;&gt; In Swift, this might look like:<br>&gt;&gt;<br>&gt;&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot; )) It was a dark and stormy \(timeOfDay)<br>&gt;&gt; when --- the Swift core team invented the \(interpolation) syntax.<br>&gt;&gt; END<br>&gt;&gt;<br>&gt;&gt; Another possible approach would be to support traditional multiline<br>&gt;&gt; string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might<br>&gt;&gt; look like:<br>&gt;&gt;<br>&gt;&gt; print(&quot;&quot;&quot; It was a dark and stormy \(timeOfDay) when &quot;&quot;&quot; + e&quot;&quot;&quot; the<br>&gt;&gt; Swift core team invented the \(interpolation) syntax. &quot;&quot;&quot;) Although<br>&gt;&gt; heredocs could make a good addition to Swift eventually, there are<br>&gt;&gt; good reasons to defer them for now. Please see the &quot;Alternatives<br>&gt;&gt; considered&quot; section for details.<br>&gt;&gt;<br>&gt;&gt; First-class regular expressions<br>&gt;&gt;<br>&gt;&gt; Members of the core team are interested in regular expressions, but<br>&gt;&gt; they don&#39;t want to just build a literal that wraps PCRE or libicu;<br>&gt;&gt; rather, they aim to integrate regexes into the pattern matching system<br>&gt;&gt; and give them a deep, Perl 6-style rethink. This would be a major<br>&gt;&gt; effort, far beyond the scope of Swift 3.<br>&gt;&gt;<br>&gt;&gt; In the meantime, the e modifier and perhaps other string literal<br>&gt;&gt; modifiers will make it easier to specify regular expressions in string<br>&gt;&gt; literals for use with NSRegularExpression and other libraries<br>&gt;&gt; accessible from Swift.<br>&gt;&gt;<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; Requiring no continuation character<br>&gt;&gt;<br>&gt;&gt; The main alternative is to not require a continuation quote, and<br>&gt;&gt; simply extend the string literal from the starting quote to the ending<br>&gt;&gt; quote, including all newlines between them. For example:<br>&gt;&gt;<br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &lt;catalog&gt; &lt;book id=\&quot;bk101\&quot;<br>&gt;&gt; empty=\&quot;\&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;/book&gt; &lt;/catalog&gt;&quot; This<br>&gt;&gt; alternative is extensively discussed in the &quot;Rationale&quot; section<br>&gt;&gt; above.<br>&gt;&gt;<br>&gt;&gt; Skip multiline strings and just support heredocs<br>&gt;&gt;<br>&gt;&gt; There are definitely cases where a heredoc would be a better solution,<br>&gt;&gt; such as generated code or code which is mostly literals with a little<br>&gt;&gt; Swift sprinkled around. On the other hand, there are also cases where<br>&gt;&gt; multiline strings are better: short strings in code which is meant to<br>&gt;&gt; be read. If a single feature can&#39;t handle them both well, there&#39;s no<br>&gt;&gt; shame in supporting the two features separately.<br>&gt;&gt;<br>&gt;&gt; It makes sense to support multiline strings first because:<br>&gt;&gt;<br>&gt;&gt; • They extend existing syntax instead of introducing new syntax.<br>&gt;&gt;<br>&gt;&gt; • They are much easier to parse; heredocs require some kind of mode in<br>&gt;&gt; the parser which kicks in at the start of the next line, whereas<br>&gt;&gt; multiline string literals can be handled in the lexer.<br>&gt;&gt;<br>&gt;&gt; • As discussed in &quot;Rationale&quot;, they offer better diagnostics, code<br>&gt;&gt; formatting, and visual scannability.<br>&gt;&gt;<br>&gt;&gt; Use a different delimiter for multiline strings<br>&gt;&gt;<br>&gt;&gt; The initial suggestion was that multiline strings should use a<br>&gt;&gt; different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with<br>&gt;&gt; no continuation characters between. Like heredocs, this might be a<br>&gt;&gt; good alternative for certain use cases, but it has the same basic<br>&gt;&gt; flaws as the &quot;no continuation character&quot; solution.<br>&gt;&gt;<br>&gt;&gt; -- Brent Royal-Gordon Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>@Brent, I suggest to rename the proposal to be clear that it is not trying <br>to solve the problem with char escaping i.e. with text *as-is*, that it is <br>just removes the  \n&quot;+  from the end of the string. I think many can think <br>of &quot;as-is&quot; text feature when starting to read your proposal or will ask <br>questions like &quot;why multi-line proposal does not include proposal for as-is <br>multi-line&quot;, I feel like the title is too generic.<br></p><p>Regarding the proposal itself. I&#39;m ready to support it (in case you&#39;ll add <br>&#39;specification&#39; of your multi-line feature in the title like &quot;multi-line <br>with support of escaping and interpolation&quot;, so we can then have another <br>proposal like &quot;multi-line without escaping, with text as-is&quot;)<br></p><p>One question: what about trailing spaces/tabs in the end of each line? IMO <br>there should be one strict rule to prevent any hard-to-find bugs/errors : <br>your feature must trim all trailing spaces, or should have an explicit <br>marker when to do this or not.<br></p><p>On 29.04.2016 0:56, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a<br>&gt;&gt; pull request if you prefer that.<br>&gt;<br>&gt; I&#39;ve adopted these suggestions in some form, though I also ended up<br>&gt; rewriting the explanation of why the feature was designed as it is and<br>&gt; fusing it with material from &quot;Alternatives considered&quot;.<br>&gt;<br>&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking<br>&gt; John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br>&gt;<br>&gt;<br>&gt;   Multiline string literals<br>&gt;<br>&gt;   * Proposal: SE-NNNN<br>&gt;     &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;   * Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;   * Status: *Second Draft*<br>&gt;   * Review manager: TBD<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;<br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is<br>&gt; the |\n| escape. String literals specified in this way are generally ugly<br>&gt; and unreadable. We propose a multiline string feature inspired by English<br>&gt; punctuation which is a straightforward extension of our existing string<br>&gt; literals.<br>&gt;<br>&gt; This proposal is one step in a larger plan to improve how string literals<br>&gt; address various challenging use cases. It is not meant to solve all<br>&gt; problems with escaping, nor to serve all use cases involving very long<br>&gt; string literals. See the &quot;Future directions for string literals in general&quot;<br>&gt; section for a sketch of the problems we ultimately want to address and some<br>&gt; ideas of how we might do so.<br>&gt;<br>&gt; Swift-evolution threads: multi-line string literals. (April)<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line<br>&gt; string literals (December)<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft<br>&gt;     Notes<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Removes the comment feature, which was felt to be an unnecessary<br>&gt;     complication. This and the backslash feature have been listed as future<br>&gt;     directions.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Loosens the specification of diagnostics, suggesting instead of<br>&gt;     requiring fix-its.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Adds extensive discussion of other features which wold combine with<br>&gt;     this one.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     I&#39;ve listed only myself as an author because I don&#39;t want to put anyone<br>&gt;     else&#39;s name to a document they haven&#39;t seen, but there are others who<br>&gt;     deserve to be listed (John Holdsworth at least). Let me know if you<br>&gt;     think you should be included.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt;<br>&gt; As Swift begins to move into roles beyond app development, code which needs<br>&gt; to generate text becomes a more important use case. Consider, for instance,<br>&gt; generating even a small XML string:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot;<br>&gt; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;<br>&gt; The string is practically unreadable, its structure drowned in escapes and<br>&gt; run-together lines; it looks like little more than line noise. We can<br>&gt; improve its readability somewhat by concatenating separate strings for each<br>&gt; line and using real tabs instead of |\t| escapes:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;           &quot;&lt;catalog&gt;\n&quot; +<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;           &quot; &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;           &quot; &lt;/book&gt;\n&quot; +<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;<br>&gt; However, this creates a more complex expression for the type checker, and<br>&gt; there&#39;s still far more punctuation than ought to be necessary. If the most<br>&gt; important goal of Swift is making code readable, this kind of code falls<br>&gt; far short of that goal.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed<br>&gt;     solution<br>&gt;<br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the<br>&gt; end of the line without encountering an end quote, it should look at the<br>&gt; next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;),<br>&gt; the string literal contains a newline and then continues on that line.<br>&gt; Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;<br>&gt; Our sample above could thus be written as:<br>&gt;<br>&gt; |let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &quot;&lt;catalog&gt; &quot; &lt;book id=\&quot;bk101\&quot;<br>&gt; empty=\&quot;\&quot;&gt; &quot; &lt;author&gt;\(author)&lt;/author&gt; &quot; &lt;/book&gt; &quot;&lt;/catalog&gt;&quot; |<br>&gt;<br>&gt; If the second or subsequent lines had not begun with a quotation mark, or<br>&gt; the trailing quotation mark after the |&lt;/catalog&gt;|tag had not been<br>&gt; included, Swift would have emitted an error.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br>&gt;<br>&gt; This design is rather unusual, and it&#39;s worth pausing a moment to explain<br>&gt; why it has been chosen.<br>&gt;<br>&gt; The traditional design for this feature, seen in languages like Perl and<br>&gt; Python, simply places one delimiter at the beginning of the literal and<br>&gt; another at the end. Individual lines in the literal are not marked in any way.<br>&gt;<br>&gt; We think continuation quotes offer several important advantages over the<br>&gt; traditional design:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     *They help the compiler pinpoint errors in string literal<br>&gt;     delimiting.* Traditional multiline strings have a serious weakness: if<br>&gt;     you forget the closing quote, the compiler has no idea where you wanted<br>&gt;     the literal to end. It simply continues on until the compiler<br>&gt;     encounters another quote (or the end of the file). If you&#39;re lucky, the<br>&gt;     text after that quote is not valid code, and the resulting error will<br>&gt;     at least point you to the next string literal in the file. If you&#39;re<br>&gt;     unlucky, you&#39;ll get a seemingly unrelated error several literals later,<br>&gt;     an unbalanced brace error at the end of the file, or perhaps even code<br>&gt;     that compiles but does something totally wrong.<br>&gt;<br>&gt;     (This is not a minor concern. Many popular languages, including C and<br>&gt;     Swift 2, specifically reject newlines in string literals to prevent<br>&gt;     this from happening.)<br>&gt;<br>&gt;     Continuation quotes provide the compiler with redundant information<br>&gt;     about your intent. If you forget a closing quote, the continuation<br>&gt;     quotes give the compiler a very good idea of where you meant to put it.<br>&gt;     The compiler can point you to (or at least very near) the /end/ of the<br>&gt;     literal, where you want to insert the quote, rather than showing you<br>&gt;     the /beginning/ of the literal or even some unrelated error later in<br>&gt;     the file that was caused by the missing quote.<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     *Temporarily unclosed literals don&#39;t make editors go haywire.* The<br>&gt;     syntax highlighter has the same trouble parsing half-written, unclosed<br>&gt;     traditional quotes that the compiler does: It can&#39;t tell where the<br>&gt;     literal is supposed to end and the code should begin. It must either<br>&gt;     apply heuristics to try to guess where the literal ends, or incorrectly<br>&gt;     color everything between the opening quote and the next closing quote<br>&gt;     as a string literal. This can cause the file&#39;s coloring to alternate<br>&gt;     distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt;<br>&gt;     Continuation quotes give the syntax highlighter enough context to guess<br>&gt;     at the correct coloration, even when the string isn&#39;t complete yet.<br>&gt;     Lines with a continuation quote are literals; lines without are code.<br>&gt;     At worst, the syntax highlighter might incorrectly color a few<br>&gt;     characters at the end of a line, rather than the remainder of the file.<br>&gt;<br>&gt;  3.<br>&gt;<br>&gt;     They separate indentation from the string&#39;s contents. Traditional<br>&gt;     multiline strings usually include all of the content between the start<br>&gt;     and end delimiters, including leading whitespace. This means that it&#39;s<br>&gt;     usually impossible to indent a multiline string, so including one<br>&gt;     breaks up the flow of the surrounding code, making it less readable.<br>&gt;     Some languages apply heuristics or mode switches to try to remove<br>&gt;     indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt;<br>&gt;     Continuation quotes neatly avoid this problem. Whitespace before the<br>&gt;     continuation quote is indentation used to format the source code;<br>&gt;     whitespace after the continuation quote is part of the string literal.<br>&gt;     The interpretation of the code is perfectly clear to both compiler and<br>&gt;     programmer.<br>&gt;<br>&gt;  4.<br>&gt;<br>&gt;     They improve the ability to quickly recognize the literal. Traditional<br>&gt;     multiline strings don&#39;t provide much visual help. To find the end, you<br>&gt;     must visually scan until you find the matching delimiter, which may be<br>&gt;     only one or a few characters long. When looking at a random line of<br>&gt;     source, it can be hard to tell at a glance whether it&#39;s code or<br>&gt;     literal. Syntax highlighting can help with these issues, but it&#39;s often<br>&gt;     unreliable, especially with advanced, idiosyncratic string literal<br>&gt;     features like multiline strings.<br>&gt;<br>&gt;     Continuation quotes solve these problems. To find the end of the<br>&gt;     literal, just scan down the column of continuation characters until<br>&gt;     they end. To figure out if a given line of source is part of a literal,<br>&gt;     just see if it starts with a quote mark. The meaning of the source<br>&gt;     becomes obvious at a glance.<br>&gt;<br>&gt; Nevertheless, the traditional design /does/ has a few advantages:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     *It is simpler.* Although continuation quotes are more complex, we<br>&gt;     believe that the advantages listed above pay for that complexity.<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     *There is no need to edit the intervening lines to add continuation<br>&gt;     quotes.* While the additional effort required to insert continuation<br>&gt;     quotes is an important downside, we believe that tool support,<br>&gt;     including both compiler fix-its and perhaps editor support for commands<br>&gt;     like &quot;Paste as String Literal&quot;, can address this issue. In some<br>&gt;     editors, new features aren&#39;t even necessary; TextMate, for instance,<br>&gt;     lets you insert a character on several lines simultaneously. And new<br>&gt;     tool features could also address other issues like escaping embedded<br>&gt;     quotes.<br>&gt;<br>&gt;  3.<br>&gt;<br>&gt;     *Naïve syntax highlighters may have trouble understanding this<br>&gt;     syntax.* This is true, but naïve syntax highlighters generally have<br>&gt;     terrible trouble with advanced string literal constructs; some struggle<br>&gt;     with even basic ones. While there are some designs (like<br>&gt;     Python&#39;s |&quot;&quot;&quot;| strings) which trick some syntax highlighters into<br>&gt;     working some of the time with some contents, we don&#39;t think this<br>&gt;     occasional, accidental compatibility is a big enough gain to justify<br>&gt;     changing the design.<br>&gt;<br>&gt;  4.<br>&gt;<br>&gt;     *It looks funny—quotes should always be in matched pairs.* We aren&#39;t<br>&gt;     aware of another programming language which uses unbalanced quotes in<br>&gt;     string literals, but there /is/ one very important precedent for this<br>&gt;     kind of formatting: natural languages. English, for instance, uses a<br>&gt;     very similar format for quoting multiple lines of dialog by the same<br>&gt;     speaker. As an English Stack Exchange answer illustrates<br>&gt;     &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;<br>&gt;         “That seems like an odd way to use punctuation,” Tom said. “What<br>&gt;         harm would there be in using quotation marks at the end of every<br>&gt;         paragraph?”<br>&gt;<br>&gt;         “Oh, that’s not all that complicated,” J.R. answered. “If you<br>&gt;         closed quotes at the end of every paragraph, then you would need to<br>&gt;         reidentify the speaker with every subsequent paragraph.<br>&gt;<br>&gt;         “Say a narrative was describing two or three people engaged in a<br>&gt;         lengthy conversation. If you closed the quotation marks in the<br>&gt;         previous paragraph, then a reader wouldn’t be able to easily tell<br>&gt;         if the previous speaker was extending his point, or if someone else<br>&gt;         in the room had picked up the conversation. By leaving the previous<br>&gt;         paragraph’s quote unclosed, the reader knows that the previous<br>&gt;         speaker is still the one talking.”<br>&gt;<br>&gt;         “Oh, that makes sense. Thanks!”<br>&gt;<br>&gt;     In English, omitting the ending quotation mark tells the text&#39;s reader<br>&gt;     that the quote continues on the next line, while including a quotation<br>&gt;     mark at the beginning of the next line reminds the reader that they&#39;re<br>&gt;     in the middle of a quote.<br>&gt;<br>&gt;     Similarly, in this proposal, omitting the ending quotation mark tells<br>&gt;     the code&#39;s reader (and compiler) that the string literal continues on<br>&gt;     the next line, while including a quotation mark at the beginning of the<br>&gt;     next line reminds the reader (and compiler) that they&#39;re in the middle<br>&gt;     of a string literal.<br>&gt;<br>&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed<br>&gt;     design<br>&gt;<br>&gt; When Swift is parsing a string literal and reaches the end of a line<br>&gt; without finding a closing quote, it examines the next line, applying the<br>&gt; following rules:<br>&gt;<br>&gt;  1.<br>&gt;<br>&gt;     If the next line begins with whitespace followed by a continuation<br>&gt;     quote, then the string literal contains a newline followed by the<br>&gt;     contents of the string literal starting on that line. (This line may<br>&gt;     itself have no closing quote, in which case the same rules apply to the<br>&gt;     line which follows.)<br>&gt;<br>&gt;  2.<br>&gt;<br>&gt;     If the next line contains anything else, Swift raises a syntax error<br>&gt;     for an unterminated string literal.<br>&gt;<br>&gt; The exact error messages and diagnostics provided are left to the<br>&gt; implementers to determine, but we believe it should be possible to provide<br>&gt; two fix-its which will help users learn the syntax and correct string<br>&gt; literal mistakes:<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Insert |&quot;| at the end of the current line to terminate the quote.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Insert |&quot;| at the beginning of the next line (with some indentation<br>&gt;     heuristics) to continue the quote on the next line.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact<br>&gt;     on existing code<br>&gt;<br>&gt; Failing to close a string literal before the end of the line is currently a<br>&gt; syntax error, so no valid Swift code should be affected by this change.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future<br>&gt;     directions for multiline string literals<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     We could permit comments before encountering a continuation quote to be<br>&gt;     counted as whitespace, and permit empty lines in the middle of string<br>&gt;     literals. This would allow you to comment out whole lines in the literal.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     We could allow you to put a trailing backslash on a line to indicate<br>&gt;     that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s<br>&gt;     contents.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future<br>&gt;     directions for string literals in general<br>&gt;<br>&gt; There are other issues with Swift&#39;s string handling which this proposal<br>&gt; intentionally does not address:<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Reducing the amount of double-backslashing needed when working with<br>&gt;     regular expression libraries, Windows paths, source code generation,<br>&gt;     and other tasks where backslashes are part of the data.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Alternate delimiters or other strategies for writing strings<br>&gt;     with |&quot;| characters in them.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     Accommodating code formatting concerns like hard wrapping and commenting.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     String literals consisting of very long pieces of text which are best<br>&gt;     represented completely verbatim, with minimal alteration.<br>&gt;<br>&gt; This section briefly outlines some future proposals which might address<br>&gt; these issues. Combined, we believe they would address most of the string<br>&gt; literal use cases which Swift is currently not very good at.<br>&gt;<br>&gt; Please note that these are simply sketches of hypothetical future designs;<br>&gt; they may radically change before proposal, and some may never be proposed<br>&gt; at all. Many, perhaps most, will not be proposed for Swift 3. We are<br>&gt; sketching these designs not to propose and refine these features<br>&gt; immediately, but merely to show how we think they might be solved in ways<br>&gt; which complement this proposal.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#string-literal-modifiers&gt;String<br>&gt;       literal modifiers<br>&gt;<br>&gt; A string literal modifier is a cluster of identifier characters which goes<br>&gt; before a string literal and adjusts the way it is parsed. Modifers only<br>&gt; alter the interpretation of the text in the literal, not the type of data<br>&gt; it produces; for instance, there will never be something like the<br>&gt; UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a<br>&gt; feature; lowercase characters disable a feature.<br>&gt;<br>&gt; Modifiers can be attached to both single-line and multiline literals, and<br>&gt; could also be attached to other literal syntaxes which might be introduced<br>&gt; in the future. When used with multiline strings, only the starting quote<br>&gt; needs to carry the modifiers, not the continuation quotes.<br>&gt;<br>&gt; Modifiers are an extremely flexible feature which can be used for many<br>&gt; proposes. Of the ideas listed below, we believe the |e| modifier is an<br>&gt; urgent addition which should be included in Swift 3 if at all possible; the<br>&gt; others are less urgent and most of them could be deferred, or at least<br>&gt; added later if time allows.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Escape disabling*: |e&quot;\\\&quot;| (string with three backslash characters)<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Fine-grained escape disabling*: |i&quot;\(foo)\n&quot;| (the<br>&gt;     string |\(foo)| followed by a newline); |eI&quot;\(foo)\n&quot;| (the contents<br>&gt;     of |foo| followed by the string |\n|), |b&quot;\w+\n&quot;| (the<br>&gt;     string |\w+| followed by a newline)<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Alternate delimiters*: |_| has no lowercase form, so it could be used<br>&gt;     to allow strings with internal quotes: |_&quot;print(&quot;Hello,<br>&gt;     world!&quot;)&quot;_|, |__&quot;print(&quot;Hello, world!&quot;)&quot;__|, etc.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Whitespace normalization*: changes all runs of whitespace in the<br>&gt;     literal to single space characters; this would allow you to use<br>&gt;     multiline strings purely to improve code formatting.<br>&gt;<br>&gt;     |alert.informativeText = W&quot;\(appName) could not typeset the element<br>&gt;     “\(title)” because &quot;it includes a link to an element that has been<br>&gt;     removed from this &quot;book.&quot; |<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Localization*:<br>&gt;<br>&gt;     |alert.informativeText = LW&quot;\(appName) could not typeset the element<br>&gt;     “\(title)” because &quot;it includes a link to an element that has been<br>&gt;     removed from this &quot;book.&quot; |<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     *Comments*: Embedding comments in string literals might be useful for<br>&gt;     literals containing regular expressions or other code.<br>&gt;<br>&gt; Eventually, user-specified string modifiers could be added to Swift,<br>&gt; perhaps as part of a hygienic macro system. It might also become possible<br>&gt; to change the default modifiers applied to literals in a particular file or<br>&gt; scope.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#heredocs-or-other-verbatim-string-literal-features&gt;Heredocs<br>&gt;       or other &quot;verbatim string literal&quot; features<br>&gt;<br>&gt; Sometimes it really is best to just splat something else down in the middle<br>&gt; of a file full of Swift source code. Maybe the file is essentially a<br>&gt; template and the literals are a majority of the code&#39;s contents, or maybe<br>&gt; you&#39;re writing a code generator and just want to get string data into it<br>&gt; with minimal fuss, or maybe people unfamiliar with Swift need to be able to<br>&gt; edit the literals. Whatever the reason, the normal string literal syntax is<br>&gt; just too burdensome.<br>&gt;<br>&gt; One approach to this problem is heredocs. A heredoc allows you to put a<br>&gt; placeholder for a literal on one line; the contents of the literal begin on<br>&gt; the next line, running up to some delimiter. It would be possible to put<br>&gt; multiple placeholders in a single line, and to apply string modifiers to them.<br>&gt;<br>&gt; In Swift, this might look like:<br>&gt;<br>&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>&gt; It was a dark and stormy \(timeOfDay) when<br>&gt; ---<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; END<br>&gt;<br>&gt; Another possible approach would be to support traditional multiline string<br>&gt; literals bounded by a different delimiter, like |&quot;&quot;&quot;|. This might look like:<br>&gt;<br>&gt; print(&quot;&quot;&quot;<br>&gt; It was a dark and stormy \(timeOfDay) when<br>&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;)<br>&gt;<br>&gt; Although heredocs could make a good addition to Swift eventually, there are<br>&gt; good reasons to defer them for now. Please see the &quot;Alternatives<br>&gt; considered&quot; section for details.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#first-class-regular-expressions&gt;First-class<br>&gt;       regular expressions<br>&gt;<br>&gt; Members of the core team are interested in regular expressions, but they<br>&gt; don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they<br>&gt; aim to integrate regexes into the pattern matching system and give them a<br>&gt; deep, Perl 6-style rethink. This would be a major effort, far beyond the<br>&gt; scope of Swift 3.<br>&gt;<br>&gt; In the meantime, the |e| modifier and perhaps other string literal<br>&gt; modifiers will make it easier to specify regular expressions in string<br>&gt; literals for use with |NSRegularExpression| and other libraries accessible<br>&gt; from Swift.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives<br>&gt;     considered<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring<br>&gt;       no continuation character<br>&gt;<br>&gt; The main alternative is to not require a continuation quote, and simply<br>&gt; extend the string literal from the starting quote to the ending quote,<br>&gt; including all newlines between them. For example:<br>&gt;<br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt; &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt;<br>&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#skip-multiline-strings-and-just-support-heredocs&gt;Skip<br>&gt;       multiline strings and just support heredocs<br>&gt;<br>&gt; There are definitely cases where a heredoc would be a better solution, such<br>&gt; as generated code or code which is mostly literals with a little Swift<br>&gt; sprinkled around. On the other hand, there are also cases where multiline<br>&gt; strings are better: short strings in code which is meant to be read. If a<br>&gt; single feature can&#39;t handle them both well, there&#39;s no shame in supporting<br>&gt; the two features separately.<br>&gt;<br>&gt; It makes sense to support multiline strings first because:<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     They extend existing syntax instead of introducing new syntax.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     They are much easier to parse; heredocs require some kind of mode in<br>&gt;     the parser which kicks in at the start of the next line, whereas<br>&gt;     multiline string literals can be handled in the lexer.<br>&gt;<br>&gt;   *<br>&gt;<br>&gt;     As discussed in &quot;Rationale&quot;, they offer better diagnostics, code<br>&gt;     formatting, and visual scannability.<br>&gt;<br>&gt;<br>&gt;       &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use<br>&gt;       a different delimiter for multiline strings<br>&gt;<br>&gt; The initial suggestion was that multiline strings should use a different<br>&gt; delimiter, |&quot;&quot;&quot;|, at the beginning and end of the string, with no<br>&gt; continuation characters between. Like heredocs, this might be a good<br>&gt; alternative for certain use cases, but it has the same basic flaws as the<br>&gt; &quot;no continuation character&quot; solution.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 2:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt; <br>&gt; I&#39;ve adopted these suggestions in some form, though I also ended up rewriting the explanation of why the feature was designed as it is and fusing it with material from &quot;Alternatives considered&quot;.<br>&gt; <br>&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br>&gt; <br>&gt; Multiline string literals<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Second Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt; <br>&gt; This proposal is one step in a larger plan to improve how string literals address various challenging use cases. It is not meant to solve all problems with escaping, nor to serve all use cases involving very long string literals. See the &quot;Future directions for string literals in general&quot; section for a sketch of the problems we ultimately want to address and some ideas of how we might do so.<br>&gt; <br>&gt; Swift-evolution threads: multi-line string literals. (April) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line string literals (December) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt; <br>&gt; Removes the comment feature, which was felt to be an unnecessary complication. This and the backslash feature have been listed as future directions. <br>&gt; <br>&gt; Loosens the specification of diagnostics, suggesting instead of requiring fix-its.<br>&gt; <br>&gt; Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br>&gt; <br>&gt; Adds extensive discussion of other features which wold combine with this one.<br>&gt; <br>&gt; I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt; <br>&gt; As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt; The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>&gt;           &quot;&lt;catalog&gt;\n&quot; + <br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>&gt;           &quot; &lt;/book&gt;\n&quot; + <br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>One other way to implement the feature would be to allow quotes to be terminated by either a close quote or an end of line character. Multiline literals would then be constructed by concatenating adjacent (e.i. separated by only comments or whitespace) string literals. <br></p><p>There is an issue with this that <br></p><p>let foo = “bar<br></p><p>would be a valid string whose value would be “bar\n”, even though that might not be the intended result. There is also the issue of things like<br></p><p>let foo = [<br>	“string1”,<br>	“string2”<br>	“string3&quot;<br>]<br></p><p>becoming [“string1”, “string2string3”]. This is something that can happen in Python, for example.<br></p><p>However, this has a few benefits. Namely, that it simplifies the model and that if I’m just pasting in a block of text I don’t have to add a trailing quote to the last line. If I was in Vim for example, I could just visual-block add a column of quotes at the beginning. So it would be:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;<br></p><p><br></p><p>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br>&gt; <br>&gt; This design is rather unusual, and it&#39;s worth pausing a moment to explain why it has been chosen.<br>&gt; <br>&gt; The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br>&gt; <br>&gt; We think continuation quotes offer several important advantages over the traditional design:<br>&gt; <br>&gt; They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br>&gt; <br>&gt; (This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br>&gt; <br>&gt; Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br>&gt; <br>&gt; Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed traditional quotes that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt; <br>&gt; Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br>&gt; <br>&gt; They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics or mode switches to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt; <br>&gt; <br>Scala has an interesting solution to this problem which doesn’t involve a mode, but rather a function that strips out whitespace before the | character. In this case the | character serves a very similar purpose to the continuation quote. The particular character can be passed to the function as an argument. <br></p><p>https://www.safaribooksonline.com/library/view/scala-cookbook/9781449340292/ch01s03.html<br>&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt; <br>&gt; They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br>&gt; <br>&gt; Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br>&gt; <br>&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt; <br>&gt; It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br>&gt; <br>&gt; There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. In some editors, new features aren&#39;t even necessary; TextMate, for instance, lets you insert a character on several lines simultaneously. And new tool features could also address other issues like escaping embedded quotes.<br>&gt; <br>Although I was concerned about this, most editors do have some way of inserting a column of characters which would reduce the burden of pasting in code. And although enabling/disabling escaping is an orthogonal feature, allowing the _” syntax to disable escaping would allow you to paste in code with no other modifications.<br>&gt; Naïve syntax highlighters may have trouble understanding this syntax. This is true, but naïve syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working some of the time with some contents, we don&#39;t think this occasional, accidental compatibility is a big enough gain to justify changing the design.<br>&gt; <br>&gt; It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt; <br>&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt; <br>&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt; <br>&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt; <br>&gt; “Oh, that makes sense. Thanks!”<br>&gt; In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt; <br>&gt; Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br>&gt; <br>	This is very interesting, I never knew!<br></p><p><br>&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br>&gt; <br>&gt; When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br>&gt; <br>&gt; If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br>&gt; <br>&gt; If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. <br>&gt; <br>&gt; The exact error messages and diagnostics provided are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br>&gt; <br>&gt; Insert &quot; at the end of the current line to terminate the quote.<br>&gt; <br>&gt; Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br>&gt; <br>&gt; We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt; <br>&gt; We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future directions for string literals in general<br>&gt; <br>&gt; There are other issues with Swift&#39;s string handling which this proposal intentionally does not address:<br>&gt; <br>&gt; Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br>&gt; <br>&gt; Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br>&gt; <br>&gt; Accommodating code formatting concerns like hard wrapping and commenting.<br>&gt; <br>&gt; String literals consisting of very long pieces of text which are best represented completely verbatim, with minimal alteration.<br>&gt; <br>&gt; This section briefly outlines some future proposals which might address these issues. Combined, we believe they would address most of the string literal use cases which Swift is currently not very good at.<br>&gt; <br>&gt; Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#string-literal-modifiers&gt;String literal modifiers<br>&gt; <br>&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a feature; lowercase characters disable a feature.<br>&gt; <br>&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt; <br>&gt; Modifiers are an extremely flexible feature which can be used for many proposes. Of the ideas listed below, we believe the e modifier is an urgent addition which should be included in Swift 3 if at all possible; the others are less urgent and most of them could be deferred, or at least added later if time allows.<br>&gt; <br>&gt; Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br>&gt; <br>&gt; Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo) followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br>&gt; <br>&gt; Alternate delimiters: _ has no lowercase form, so it could be used to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_, __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br>&gt; <br>&gt; <br>This is interesting and perhaps could be applied per line with the continuation quote syntax:<br></p><p>let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>          _&quot;&lt;catalog&gt;<br>          _&quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          _&quot; &lt;/book&gt;<br>          _&quot;&lt;/catalog&gt;<br>This would allow individual lines to retain the ability to do escaping and interpolation without affecting the whole string, just like the author line in the example above. This is also very easy to insert into editors just like the standard continuation quote syntax. Or perhaps we could just “escape” each string:<br></p><p>let xml = \&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>          \&quot;&lt;catalog&gt;<br>          \&quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          \&quot; &lt;/book&gt;<br>          \&quot;&lt;/catalog&gt;<br></p><p>&gt; Whitespace normalization: changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings purely to improve code formatting.<br>&gt; <br>&gt; alert.informativeText =<br>&gt;     W&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;      &quot;it includes a link to an element that has been removed from this <br>&gt;      &quot;book.&quot;<br>&gt; Localization: <br>&gt; <br>&gt; alert.informativeText =<br>&gt;     LW&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;       &quot;it includes a link to an element that has been removed from this <br>&gt;       &quot;book.&quot;<br>&gt; Comments: Embedding comments in string literals might be useful for literals containing regular expressions or other code.<br>&gt; <br>&gt; Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#heredocs-or-other-verbatim-string-literal-features&gt;Heredocs or other &quot;verbatim string literal&quot; features<br>&gt; <br>&gt; Sometimes it really is best to just splat something else down in the middle of a file full of Swift source code. Maybe the file is essentially a template and the literals are a majority of the code&#39;s contents, or maybe you&#39;re writing a code generator and just want to get string data into it with minimal fuss, or maybe people unfamiliar with Swift need to be able to edit the literals. Whatever the reason, the normal string literal syntax is just too burdensome.<br>&gt; <br>&gt; One approach to this problem is heredocs. A heredoc allows you to put a placeholder for a literal on one line; the contents of the literal begin on the next line, running up to some delimiter. It would be possible to put multiple placeholders in a single line, and to apply string modifiers to them.<br>&gt; <br>&gt; In Swift, this might look like:<br>&gt; <br>&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; ---<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; END<br>&gt; Another possible approach would be to support traditional multiline string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might look like:<br>&gt; <br>&gt; print(&quot;&quot;&quot;<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;)<br>&gt; Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#first-class-regular-expressions&gt;First-class regular expressions<br>&gt; <br>&gt; Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br>&gt; <br>&gt; In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring no continuation character<br>&gt; <br>&gt; The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#skip-multiline-strings-and-just-support-heredocs&gt;Skip multiline strings and just support heredocs<br>&gt; <br>&gt; There are definitely cases where a heredoc would be a better solution, such as generated code or code which is mostly literals with a little Swift sprinkled around. On the other hand, there are also cases where multiline strings are better: short strings in code which is meant to be read. If a single feature can&#39;t handle them both well, there&#39;s no shame in supporting the two features separately.<br>&gt; <br>&gt; It makes sense to support multiline strings first because:<br>&gt; <br>&gt; They extend existing syntax instead of introducing new syntax.<br>&gt; <br>&gt; They are much easier to parse; heredocs require some kind of mode in the parser which kicks in at the start of the next line, whereas multiline string literals can be handled in the lexer.<br>&gt; <br>&gt; As discussed in &quot;Rationale&quot;, they offer better diagnostics, code formatting, and visual scannability.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt; <br>&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. Like heredocs, this might be a good alternative for certain use cases, but it has the same basic flaws as the &quot;no continuation character&quot; solution.<br>&gt; <br></p><p>&gt; That might be a useful document to have, but I worry that we&#39;ll end up seeing the string feature proposals signed in triplicate, sent in, sent back, queried, lost, found, subjected to public inquiry, lost again, and finally buried in soft peat for three months and recycled as firelighters, all to end up in with basically the same proposals but with slightly different keywords. Not every decision needs that level of explicit, deep documentation. Some things you can think about, experiment with, discuss, and do.<br></p><p><br>Yeah, I think you are probably right here. I actually think with the additions to your proposal it covers almost all of the other suggestions regarding string literals or at least mentions them as alternatives. Thanks so much for spending the time putting together the proposal! I have no idea how you find the time to follow and participate in what seems like every Swift evolution thread, but it’s awesome!<br></p><p>Tyler<br></p><p><br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/2a8338d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 30, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 30, 2016, at 11:54 AM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 2:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve adopted these suggestions in some form, though I also ended up rewriting the explanation of why the feature was designed as it is and fusing it with material from &quot;Alternatives considered&quot;.<br>&gt;&gt; <br>&gt;&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br>&gt;&gt; <br>&gt;&gt; Multiline string literals<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt; Status: Second Draft<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt;&gt; <br>&gt;&gt; This proposal is one step in a larger plan to improve how string literals address various challenging use cases. It is not meant to solve all problems with escaping, nor to serve all use cases involving very long string literals. See the &quot;Future directions for string literals in general&quot; section for a sketch of the problems we ultimately want to address and some ideas of how we might do so.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads: multi-line string literals. (April) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line string literals (December) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt;&gt; <br>&gt;&gt; Removes the comment feature, which was felt to be an unnecessary complication. This and the backslash feature have been listed as future directions. <br>&gt;&gt; <br>&gt;&gt; Loosens the specification of diagnostics, suggesting instead of requiring fix-its.<br>&gt;&gt; <br>&gt;&gt; Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br>&gt;&gt; <br>&gt;&gt; Adds extensive discussion of other features which wold combine with this one.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt;&gt; The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>&gt;&gt;           &quot;&lt;catalog&gt;\n&quot; + <br>&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>&gt;&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>&gt;&gt;           &quot; &lt;/book&gt;\n&quot; + <br>&gt;&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt;&gt; <br>&gt; One other way to implement the feature would be to allow quotes to be terminated by either a close quote or an end of line character. Multiline literals would then be constructed by concatenating adjacent (e.i. separated by only comments or whitespace) string literals. <br>&gt; <br>&gt; There is an issue with this that <br>&gt; <br>&gt; let foo = “bar<br>&gt; <br>&gt; would be a valid string whose value would be “bar\n”, even though that might not be the intended result. There is also the issue of things like<br>&gt; <br>&gt; let foo = [<br>&gt; 	“string1”,<br>&gt; 	“string2”<br>&gt; 	“string3&quot;<br>&gt; ]<br>&gt; <br>&gt; becoming [“string1”, “string2string3”]. This is something that can happen in Python, for example.<br>&gt; <br>&gt; However, this has a few benefits. Namely, that it simplifies the model and that if I’m just pasting in a block of text I don’t have to add a trailing quote to the last line. If I was in Vim for example, I could just visual-block add a column of quotes at the beginning. So it would be:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;<br>&gt; <br></p><p>Just one amendment, in order to have the same string you would still have to write:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;<br>Or else an unwanted newline would be appended to the end. Additionally Brent made an excellent point about having ending delimiters for the following case:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;.encoded(as: .UTF8)<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; Our sample above could thus be written as:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;           &quot;&lt;catalog&gt;<br>&gt;&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;           &quot; &lt;/book&gt;<br>&gt;&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt;&gt; If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br>&gt;&gt; <br>&gt;&gt; This design is rather unusual, and it&#39;s worth pausing a moment to explain why it has been chosen.<br>&gt;&gt; <br>&gt;&gt; The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br>&gt;&gt; <br>&gt;&gt; We think continuation quotes offer several important advantages over the traditional design:<br>&gt;&gt; <br>&gt;&gt; They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br>&gt;&gt; <br>&gt;&gt; (This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br>&gt;&gt; <br>&gt;&gt; Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br>&gt;&gt; <br>&gt;&gt; Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed traditional quotes that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt;&gt; <br>&gt;&gt; Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br>&gt;&gt; <br>&gt;&gt; They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics or mode switches to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; Scala has an interesting solution to this problem which doesn’t involve a mode, but rather a function that strips out whitespace before the | character. In this case the | character serves a very similar purpose to the continuation quote. The particular character can be passed to the function as an argument. <br>&gt; <br>&gt; https://www.safaribooksonline.com/library/view/scala-cookbook/9781449340292/ch01s03.html &lt;https://www.safaribooksonline.com/library/view/scala-cookbook/9781449340292/ch01s03.html&gt;<br>&gt;&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt;&gt; <br>&gt;&gt; They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br>&gt;&gt; <br>&gt;&gt; Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br>&gt;&gt; <br>&gt;&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt;&gt; <br>&gt;&gt; It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br>&gt;&gt; <br>&gt;&gt; There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. In some editors, new features aren&#39;t even necessary; TextMate, for instance, lets you insert a character on several lines simultaneously. And new tool features could also address other issues like escaping embedded quotes.<br>&gt;&gt; <br>&gt; Although I was concerned about this, most editors do have some way of inserting a column of characters which would reduce the burden of pasting in code. And although enabling/disabling escaping is an orthogonal feature, allowing the _” syntax to disable escaping would allow you to paste in code with no other modifications.<br>&gt;&gt; Naïve syntax highlighters may have trouble understanding this syntax. This is true, but naïve syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working some of the time with some contents, we don&#39;t think this occasional, accidental compatibility is a big enough gain to justify changing the design.<br>&gt;&gt; <br>&gt;&gt; It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt;&gt; <br>&gt;&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt;&gt; <br>&gt;&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt;&gt; <br>&gt;&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt;&gt; <br>&gt;&gt; “Oh, that makes sense. Thanks!”<br>&gt;&gt; In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt;&gt; <br>&gt;&gt; Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br>&gt;&gt; <br>&gt; 	This is very interesting, I never knew!<br>&gt; <br>&gt; <br>&gt;&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br>&gt;&gt; <br>&gt;&gt; If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br>&gt;&gt; <br>&gt;&gt; If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. <br>&gt;&gt; <br>&gt;&gt; The exact error messages and diagnostics provided are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br>&gt;&gt; <br>&gt;&gt; Insert &quot; at the end of the current line to terminate the quote.<br>&gt;&gt; <br>&gt;&gt; Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br>&gt;&gt; <br>&gt;&gt; We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt;&gt; <br>&gt;&gt; We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future directions for string literals in general<br>&gt;&gt; <br>&gt;&gt; There are other issues with Swift&#39;s string handling which this proposal intentionally does not address:<br>&gt;&gt; <br>&gt;&gt; Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br>&gt;&gt; <br>&gt;&gt; Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br>&gt;&gt; <br>&gt;&gt; Accommodating code formatting concerns like hard wrapping and commenting.<br>&gt;&gt; <br>&gt;&gt; String literals consisting of very long pieces of text which are best represented completely verbatim, with minimal alteration.<br>&gt;&gt; <br>&gt;&gt; This section briefly outlines some future proposals which might address these issues. Combined, we believe they would address most of the string literal use cases which Swift is currently not very good at.<br>&gt;&gt; <br>&gt;&gt; Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#string-literal-modifiers&gt;String literal modifiers<br>&gt;&gt; <br>&gt;&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a feature; lowercase characters disable a feature.<br>&gt;&gt; <br>&gt;&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt;&gt; <br>&gt;&gt; Modifiers are an extremely flexible feature which can be used for many proposes. Of the ideas listed below, we believe the e modifier is an urgent addition which should be included in Swift 3 if at all possible; the others are less urgent and most of them could be deferred, or at least added later if time allows.<br>&gt;&gt; <br>&gt;&gt; Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br>&gt;&gt; <br>&gt;&gt; Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo) followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br>&gt;&gt; <br>&gt;&gt; Alternate delimiters: _ has no lowercase form, so it could be used to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_, __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; This is interesting and perhaps could be applied per line with the continuation quote syntax:<br>&gt; <br>&gt; let xml = _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;           _&quot;&lt;catalog&gt;<br>&gt;           _&quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           _&quot; &lt;/book&gt;<br>&gt;           _&quot;&lt;/catalog&gt;<br>&gt; This would allow individual lines to retain the ability to do escaping and interpolation without affecting the whole string, just like the author line in the example above. This is also very easy to insert into editors just like the standard continuation quote syntax. Or perhaps we could just “escape” each string:<br>&gt; <br>&gt; let xml = \&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;           \&quot;&lt;catalog&gt;<br>&gt;           \&quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;            &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           \&quot; &lt;/book&gt;<br>&gt;           \&quot;&lt;/catalog&gt;<br>&gt; <br>&gt;&gt; Whitespace normalization: changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings purely to improve code formatting.<br>&gt;&gt; <br>&gt;&gt; alert.informativeText =<br>&gt;&gt;     W&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;&gt;      &quot;it includes a link to an element that has been removed from this <br>&gt;&gt;      &quot;book.&quot;<br>&gt;&gt; Localization: <br>&gt;&gt; <br>&gt;&gt; alert.informativeText =<br>&gt;&gt;     LW&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;&gt;       &quot;it includes a link to an element that has been removed from this <br>&gt;&gt;       &quot;book.&quot;<br>&gt;&gt; Comments: Embedding comments in string literals might be useful for literals containing regular expressions or other code.<br>&gt;&gt; <br>&gt;&gt; Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#heredocs-or-other-verbatim-string-literal-features&gt;Heredocs or other &quot;verbatim string literal&quot; features<br>&gt;&gt; <br>&gt;&gt; Sometimes it really is best to just splat something else down in the middle of a file full of Swift source code. Maybe the file is essentially a template and the literals are a majority of the code&#39;s contents, or maybe you&#39;re writing a code generator and just want to get string data into it with minimal fuss, or maybe people unfamiliar with Swift need to be able to edit the literals. Whatever the reason, the normal string literal syntax is just too burdensome.<br>&gt;&gt; <br>&gt;&gt; One approach to this problem is heredocs. A heredoc allows you to put a placeholder for a literal on one line; the contents of the literal begin on the next line, running up to some delimiter. It would be possible to put multiple placeholders in a single line, and to apply string modifiers to them.<br>&gt;&gt; <br>&gt;&gt; In Swift, this might look like:<br>&gt;&gt; <br>&gt;&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>&gt;&gt; It was a dark and stormy \(timeOfDay) when <br>&gt;&gt; ---<br>&gt;&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt;&gt; END<br>&gt;&gt; Another possible approach would be to support traditional multiline string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might look like:<br>&gt;&gt; <br>&gt;&gt; print(&quot;&quot;&quot;<br>&gt;&gt; It was a dark and stormy \(timeOfDay) when <br>&gt;&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt;&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt;&gt; &quot;&quot;&quot;)<br>&gt;&gt; Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#first-class-regular-expressions&gt;First-class regular expressions<br>&gt;&gt; <br>&gt;&gt; Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br>&gt;&gt; <br>&gt;&gt; In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring no continuation character<br>&gt;&gt; <br>&gt;&gt; The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt;&gt; <br>&gt;&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;     &lt;/book&gt;<br>&gt;&gt; &lt;/catalog&gt;&quot;<br>&gt;&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#skip-multiline-strings-and-just-support-heredocs&gt;Skip multiline strings and just support heredocs<br>&gt;&gt; <br>&gt;&gt; There are definitely cases where a heredoc would be a better solution, such as generated code or code which is mostly literals with a little Swift sprinkled around. On the other hand, there are also cases where multiline strings are better: short strings in code which is meant to be read. If a single feature can&#39;t handle them both well, there&#39;s no shame in supporting the two features separately.<br>&gt;&gt; <br>&gt;&gt; It makes sense to support multiline strings first because:<br>&gt;&gt; <br>&gt;&gt; They extend existing syntax instead of introducing new syntax.<br>&gt;&gt; <br>&gt;&gt; They are much easier to parse; heredocs require some kind of mode in the parser which kicks in at the start of the next line, whereas multiline string literals can be handled in the lexer.<br>&gt;&gt; <br>&gt;&gt; As discussed in &quot;Rationale&quot;, they offer better diagnostics, code formatting, and visual scannability.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt;&gt; <br>&gt;&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. Like heredocs, this might be a good alternative for certain use cases, but it has the same basic flaws as the &quot;no continuation character&quot; solution.<br>&gt;&gt; <br>&gt; <br>&gt;&gt; That might be a useful document to have, but I worry that we&#39;ll end up seeing the string feature proposals signed in triplicate, sent in, sent back, queried, lost, found, subjected to public inquiry, lost again, and finally buried in soft peat for three months and recycled as firelighters, all to end up in with basically the same proposals but with slightly different keywords. Not every decision needs that level of explicit, deep documentation. Some things you can think about, experiment with, discuss, and do.<br>&gt; <br>&gt; <br>&gt; Yeah, I think you are probably right here. I actually think with the additions to your proposal it covers almost all of the other suggestions regarding string literals or at least mentions them as alternatives. Thanks so much for spending the time putting together the proposal! I have no idea how you find the time to follow and participate in what seems like every Swift evolution thread, but it’s awesome!<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/5e0330f7/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>April 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 2:56 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Awesome.  Some specific suggestions below, but feel free to iterate in a pull request if you prefer that.<br>&gt; <br>&gt; I&#39;ve adopted these suggestions in some form, though I also ended up rewriting the explanation of why the feature was designed as it is and fusing it with material from &quot;Alternatives considered&quot;.<br>&gt; <br>&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking John, Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br></p><p><br>I haven’t contributed much beyond the initial suggestions, however, that being said I have never been an author on Swift evolution and it would really make my day (if not year, given that Swift is at least in my top 5 favorite things).<br></p><p>:)<br></p><p><br>&gt; <br>&gt; Multiline string literals<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: Second Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature inspired by English punctuation which is a straightforward extension of our existing string literals.<br>&gt; <br>&gt; This proposal is one step in a larger plan to improve how string literals address various challenging use cases. It is not meant to solve all problems with escaping, nor to serve all use cases involving very long string literals. See the &quot;Future directions for string literals in general&quot; section for a sketch of the problems we ultimately want to address and some ideas of how we might do so.<br>&gt; <br>&gt; Swift-evolution threads: multi-line string literals. (April) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line string literals (December) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#draft-notes&gt;Draft Notes<br>&gt; <br>&gt; Removes the comment feature, which was felt to be an unnecessary complication. This and the backslash feature have been listed as future directions. <br>&gt; <br>&gt; Loosens the specification of diagnostics, suggesting instead of requiring fix-its.<br>&gt; <br>&gt; Splits a &quot;Rationale&quot; section out of the &quot;Proposed solution&quot; section.<br>&gt; <br>&gt; Adds extensive discussion of other features which wold combine with this one.<br>&gt; <br>&gt; I&#39;ve listed only myself as an author because I don&#39;t want to put anyone else&#39;s name to a document they haven&#39;t seen, but there are others who deserve to be listed (John Holdsworth at least). Let me know if you think you should be included.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br>&gt; <br>&gt; As Swift begins to move into roles beyond app development, code which needs to generate text becomes a more important use case. Consider, for instance, generating even a small XML string:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt; The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>&gt;           &quot;&lt;catalog&gt;\n&quot; + <br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>&gt;           &quot; &lt;/book&gt;\n&quot; + <br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br>&gt; <br>&gt; This design is rather unusual, and it&#39;s worth pausing a moment to explain why it has been chosen.<br>&gt; <br>&gt; The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br>&gt; <br>&gt; We think continuation quotes offer several important advantages over the traditional design:<br>&gt; <br>&gt; They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br>&gt; <br>&gt; (This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br>&gt; <br>&gt; Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br>&gt; <br>&gt; Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed traditional quotes that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt; <br>&gt; Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br>&gt; <br>&gt; They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics or mode switches to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt; <br>&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt; <br>&gt; They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br>&gt; <br>&gt; Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br>&gt; <br>&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt; <br>&gt; It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br>&gt; <br>&gt; There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. In some editors, new features aren&#39;t even necessary; TextMate, for instance, lets you insert a character on several lines simultaneously. And new tool features could also address other issues like escaping embedded quotes.<br>&gt; <br>&gt; Naïve syntax highlighters may have trouble understanding this syntax. This is true, but naïve syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working some of the time with some contents, we don&#39;t think this occasional, accidental compatibility is a big enough gain to justify changing the design.<br>&gt; <br>&gt; It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br>&gt; <br>&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt; <br>&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt; <br>&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt; <br>&gt; “Oh, that makes sense. Thanks!”<br>&gt; In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt; <br>&gt; Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br>&gt; <br>&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br>&gt; <br>&gt; When Swift is parsing a string literal and reaches the end of a line without finding a closing quote, it examines the next line, applying the following rules:<br>&gt; <br>&gt; If the next line begins with whitespace followed by a continuation quote, then the string literal contains a newline followed by the contents of the string literal starting on that line. (This line may itself have no closing quote, in which case the same rules apply to the line which follows.)<br>&gt; <br>&gt; If the next line contains anything else, Swift raises a syntax error for an unterminated string literal. <br>&gt; <br>&gt; The exact error messages and diagnostics provided are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br>&gt; <br>&gt; Insert &quot; at the end of the current line to terminate the quote.<br>&gt; <br>&gt; Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br>&gt; <br>&gt; We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt; <br>&gt; We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future directions for string literals in general<br>&gt; <br>&gt; There are other issues with Swift&#39;s string handling which this proposal intentionally does not address:<br>&gt; <br>&gt; Reducing the amount of double-backslashing needed when working with regular expression libraries, Windows paths, source code generation, and other tasks where backslashes are part of the data.<br>&gt; <br>&gt; Alternate delimiters or other strategies for writing strings with &quot; characters in them.<br>&gt; <br>&gt; Accommodating code formatting concerns like hard wrapping and commenting.<br>&gt; <br>&gt; String literals consisting of very long pieces of text which are best represented completely verbatim, with minimal alteration.<br>&gt; <br>&gt; This section briefly outlines some future proposals which might address these issues. Combined, we believe they would address most of the string literal use cases which Swift is currently not very good at.<br>&gt; <br>&gt; Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#string-literal-modifiers&gt;String literal modifiers<br>&gt; <br>&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. Uppercase characters enable a feature; lowercase characters disable a feature.<br>&gt; <br>&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt; <br>&gt; Modifiers are an extremely flexible feature which can be used for many proposes. Of the ideas listed below, we believe the e modifier is an urgent addition which should be included in Swift 3 if at all possible; the others are less urgent and most of them could be deferred, or at least added later if time allows.<br>&gt; <br>&gt; Escape disabling: e&quot;\\\&quot; (string with three backslash characters)<br>&gt; <br>&gt; Fine-grained escape disabling: i&quot;\(foo)\n&quot; (the string \(foo) followed by a newline); eI&quot;\(foo)\n&quot; (the contents of foo followed by the string \n), b&quot;\w+\n&quot; (the string \w+ followed by a newline)<br>&gt; <br>&gt; Alternate delimiters: _ has no lowercase form, so it could be used to allow strings with internal quotes: _&quot;print(&quot;Hello, world!&quot;)&quot;_, __&quot;print(&quot;Hello, world!&quot;)&quot;__, etc.<br>&gt; <br>&gt; Whitespace normalization: changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings purely to improve code formatting.<br>&gt; <br>&gt; alert.informativeText =<br>&gt;     W&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;      &quot;it includes a link to an element that has been removed from this <br>&gt;      &quot;book.&quot;<br>&gt; Localization: <br>&gt; <br>&gt; alert.informativeText =<br>&gt;     LW&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;       &quot;it includes a link to an element that has been removed from this <br>&gt;       &quot;book.&quot;<br>&gt; Comments: Embedding comments in string literals might be useful for literals containing regular expressions or other code.<br>&gt; <br>&gt; Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#heredocs-or-other-verbatim-string-literal-features&gt;Heredocs or other &quot;verbatim string literal&quot; features<br>&gt; <br>&gt; Sometimes it really is best to just splat something else down in the middle of a file full of Swift source code. Maybe the file is essentially a template and the literals are a majority of the code&#39;s contents, or maybe you&#39;re writing a code generator and just want to get string data into it with minimal fuss, or maybe people unfamiliar with Swift need to be able to edit the literals. Whatever the reason, the normal string literal syntax is just too burdensome.<br>&gt; <br>&gt; One approach to this problem is heredocs. A heredoc allows you to put a placeholder for a literal on one line; the contents of the literal begin on the next line, running up to some delimiter. It would be possible to put multiple placeholders in a single line, and to apply string modifiers to them.<br>&gt; <br>&gt; In Swift, this might look like:<br>&gt; <br>&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; ---<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; END<br>&gt; Another possible approach would be to support traditional multiline string literals bounded by a different delimiter, like &quot;&quot;&quot;. This might look like:<br>&gt; <br>&gt; print(&quot;&quot;&quot;<br>&gt; It was a dark and stormy \(timeOfDay) when <br>&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; the Swift core team invented the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;)<br>&gt; Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#first-class-regular-expressions&gt;First-class regular expressions<br>&gt; <br>&gt; Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or libicu; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br>&gt; <br>&gt; In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#requiring-no-continuation-character&gt;Requiring no continuation character<br>&gt; <br>&gt; The main alternative is to not require a continuation quote, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#skip-multiline-strings-and-just-support-heredocs&gt;Skip multiline strings and just support heredocs<br>&gt; <br>&gt; There are definitely cases where a heredoc would be a better solution, such as generated code or code which is mostly literals with a little Swift sprinkled around. On the other hand, there are also cases where multiline strings are better: short strings in code which is meant to be read. If a single feature can&#39;t handle them both well, there&#39;s no shame in supporting the two features separately.<br>&gt; <br>&gt; It makes sense to support multiline strings first because:<br>&gt; <br>&gt; They extend existing syntax instead of introducing new syntax.<br>&gt; <br>&gt; They are much easier to parse; heredocs require some kind of mode in the parser which kicks in at the start of the next line, whereas multiline string literals can be handled in the lexer.<br>&gt; <br>&gt; As discussed in &quot;Rationale&quot;, they offer better diagnostics, code formatting, and visual scannability.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-a-different-delimiter-for-multiline-strings&gt;Use a different delimiter for multiline strings<br>&gt; <br>&gt; The initial suggestion was that multiline strings should use a different delimiter, &quot;&quot;&quot;, at the beginning and end of the string, with no continuation characters between. Like heredocs, this might be a good alternative for certain use cases, but it has the same basic flaws as the &quot;no continuation character&quot; solution.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/8ae4a09d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>multi-line string literals.</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 30, 2016 at 10:00:00pm</p></header><div class="content"><p>In my opinion, one problem is that we don’t have a reference to a laundry or wish list of what features we would like around string literals in the language. Without evaluating a proposal against all of those features (moves forward, doesn’t impact, creates later issues for) it is hard to evaluate.<br></p><p>My guess here at an exhaustive list:<br></p><p>Main goals:<br>- reduce the impact on readability when dealing with certain kinds of string literals<br>- reduce the amount of editing needed when inserting/referencing text from an external source to be used as a string literal<br></p><p>Specific tasks/asks:<br>- for large string literals, reduce the amount of editing needed to span multiple lines<br>- for strings literals meant to represent multi-line text, allow the visual newline to be used rather than an encoding<br>	(note: this may mean in the first case newlines are considered formatting of the literal, while in the second they are considered part of the represented text)<br>- with string literals spanning multiple lines, allow for the author to indent the literal to match flow with surrounding code without impacting the represented text<br>- allow for text with double quotes to be represented in a string literal without requiring those quotes to be escaped<br>- have the ability to disable all/most escape interpretation to reduce impact on readability of certain text<br>- take into account that regular expressions, when added, will likely require different escaping rules than text string literals<br></p><p>Approach-specific<br>- if allowing for inline blocks of strings delimited by start/end points e.g. here docs, data segments<br>	- if the block end is on its own line, control whether that newline is part of the represented text<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  1, 2016 at 02:00:00pm</p></header><div class="content"><p>[couple minutes read]<br></p><p>I read with great attention this thread, trying to see it from the implementation viewpoint (I know that the compiler structure should not drive the language features). I also revisited the how-to-contribute notes as well as the dev-process description. One of the ideas that stood out in my mind was that when looking at an implementation, enablement changes should be separated from the bulk of the feature, such that reviews can be easier.<br></p><p>So I tried to elevate this to the rank of a hidden-mandatory-requirement for anything related to this feature. It lead me to a staged approach to this feature that would allow a lot of things to be done, OVER TIME.<br></p><p>When distilling this feature to the smallest part enabler that would have to be added to the compiler I came to the following short list<br></p><p>add a string_multiline_token  to the lexer<br>I realize that the current lexer can be tweaked to work (as per John’s PR), but IMO adding a dedicated &quot;hole&quot; in the parsing code is what will give something working today (no difference with current compiler behavior) while allowing all future changes to be cleanly isolated from anything around<br>if one accepts the idea of a hole created by the token, then it stands to reason to have delimiters around it. I looking at the structure of the grammar, I came to the conclusion that  _” and “_ where an easy, unambiguous choice (I believe “”” and “”” looked like an equally easy an unambiguous choice)<br>the next choice should be the creation of a lexStringMultilineLiteral() and lexMultilineCharacter() method in the Lexer. Again… bare with me, I do believe it is relevant to what everyone wants this feature to be… The latter method should contain only extensions specific to multiline literals delegating common use cases to lexCharacter()<br></p><p>The main point of following this route (or any equivalent) is that <br>it represents a very clear commitment to multiline string literals<br>it ensures that there is no strong commitment to feature details, while allowing many future scenarios<br>it will remain backward compatible with enhancements to the current string literal syntax (translation?)<br>external contributors will be able to prototype while making sure we stay within strict boundaries for integration with the compiler<br></p><p>The next equally small step would be to describe the required minimal changes to Parser, a step I do not want to take now if the compiler experts  view no merit at all to the proposed staged approach.<br></p><p><br></p><p>A thought experiment pushing further down this path, shows how the following would be equally possible language features (with roughly equivalent implementation cost):<br></p><p>let whyOwhy = “”&quot;\<br>    !!    Can&#39;t understand what improvements it truly delivers <br>    !!        It basically removes a handful of characters<br>    !!    It works today<br>    !!        But I don&#39;t see it as a likable foundations for adding in future enhancements<br>    !!\<br>    !!    I don&#39;t envy the people who will have to support it outside of xcode<br>    !!        Or even in xcode (considering how it currently struggles with indents/formatting<br>    !!    As for elegance, beauty is in the eye of the beholder, they say.<br>“”&quot;<br></p><p>var json1 = _&quot;[json]\<br>    !!{<br>    !!  &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>    !!  &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>    !!  &quot;rational&quot; : [<br>    !!          &quot;Here we go again&quot;<br>    !!          &quot;How will xcode help make these workable&quot;<br>    !!       ]<br>    !!}<br>“_<br>var json2 = _&quot;[json]\<br>{<br>  &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>  &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>  &quot;rational&quot; : [<br>          &quot;Here we go again&quot;<br>          &quot;How will xcode help make these workable&quot;<br>       ]<br>}<br>“_<br></p><p> [_&quot;]  --&gt; start string<br> [_&quot;\] --&gt; start line + ignore spaces until eol (basically swallow \r\n)<br> [!!\] --&gt; ignore everything until eol... basically the gap does not exits<br> [&quot;_]  --&gt; terminate string<br> [_&quot;[TYPEID]\] --&gt; start string knowing that it a verifyer or a formatter (or a chain of) understanding TYPEID can syntax check or format or or or<br></p><p><br>IMO splitting these expression from the current lexing/parsing has another long term benefits when coupled with the aforementioned idea of contents tagging:<br>allow external dedicated formatter to be created in any editor supporting swift<br>allow external validators (including in the form of compiler plugins)<br>open a door for an equivalent to the scala&#39;s macros for contents marked as  [swift]<br></p><p>Once again I fully appreciate that implementation should not drive language design, but considering the flurry of great ideas, I thought it might in this instance be useful to identify a minimal, noncommittal, direction common to many scenarios, such that a step can be taken that will neither favor nor prohibit any of the proposals, but simply enable them all.<br></p><p>Thank you for your patience<br>Regards<br></p><p>PS: I am working on a rudimentary implementation that I hope could help people test all the ideas floating in this list. <br></p><p><br>&gt; On Apr 26, 2016, at 8:04 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 25, 2016, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt;&gt; <br>&gt;&gt; Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br>&gt; <br>&gt; Right. I consider modifiers to be highly precedented in other languages, and therefore proven to work.  If we go this way, I greatly prefer prefix to postfix modifiers.<br>&gt; <br>&gt;&gt;&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt;&gt; <br>&gt;&gt; On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br>&gt; <br>&gt; Right, but it is also heavy weight and ugly.  In your previous email you said about the single quote approach: &quot;The quotation marks on the left end up forming a column that marks the lines as special”, so I don’t see a need for a triple quote syntax to solve this specific problem.<br>&gt; <br>&gt;&gt; I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br>&gt; <br>&gt; I agree that this is a real problem that would be great to solve.<br>&gt; <br>&gt; If I step back and look at the string literal space we’re discussing, I feel like there are three options:<br>&gt; <br>&gt; 1) single and simple multiline strings, using “<br>&gt; 2) your triple quote sort of string, specifically tuned to avoid having to escape “ when it occurs once or twice in sequence.<br>&gt; 3) heredoc, which is a very general (but also very heavy weight) solution to quoting problems.<br>&gt; <br>&gt; I’m trying to eliminate the middle one, so we only have to have &quot;two things”.  Here are some alternative ways to solve the problem, which might have less of an impact on the language:<br>&gt; <br>&gt; A) Introduce single quoted string literals to avoid double quote problems specifically, e.g.:   ‘look “here” I say!’.  This is another form of #2 which is less ugly.  It also doesn’t help you if you have both “ and ‘ in your string.<br>&gt; <br>&gt; B) Introduce a modifier character that requires a more complex closing sequence to close off the string, see C++ raw string literals for prior art on this approach.  Perhaps something like:<br>&gt; <br>&gt; 	 Rxxx”look “ here “ I can use quotes “xxx<br>&gt; <br>&gt; That said, I still prefer C) &quot;ignore this issue for now”.  In other words, I wouldn’t want to block progress on improving the string literal situation overall on this issue, because anything we do here is an further extension to a proposal that doesn’t solve this problem.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let str = &lt;&lt;EOF<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; \t&lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt; EOF<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt;&gt; <br>&gt;&gt; There are two questions and a suggestion I have whenever heredoc syntax comes up.<br>&gt;&gt; <br>&gt;&gt; Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br>&gt;&gt; <br>&gt;&gt; Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br>&gt;&gt; <br>&gt;&gt; S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br>&gt;&gt; <br>&gt;&gt; 	func x() -&gt; String {<br>&gt;&gt; 		return &lt;&lt;EOF<br>&gt;&gt; 		&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt; 		&lt;catalog&gt;<br>&gt;&gt; 		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt; 		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt; 		\t&lt;/book&gt;<br>&gt;&gt; 		&lt;/catalog&gt;<br>&gt;&gt; 		EOF<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Does that seem like a good approach?<br>&gt; <br>&gt; I think that either approach could work, that you have a lot more experience on these topics than I do, and I would expect a vigorous community debate about these topics. :-)<br>&gt; <br>&gt; That said, if you look at what we’re discussing:<br>&gt; <br>&gt; 1. “Continuation&quot; string literals, to allow a multi-line string literal.  You and I appear to completely agree about this.<br>&gt; 2. Heredoc: You and I seem to agree that they are a good “fully general” solution to have, but there are the details you outline above to iron out.<br>&gt; 3. Modifier characters:  I’m in favor, but I don’t know where you stand.  There is also still much to iron out here (such as the specific characters).<br>&gt; 4. A way to avoid having to escape “ in a non-heredoc literal.  I’m still unconvinced, and think that any solution to this problem will be orthogonal to the problems solved by 1-3 (and therefore can be added after getting experience with the other parts).<br>&gt; <br>&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.  After that, we can discuss heredoc and modifiers (if you think they’re a good solution) on their own threads.  If those turn out to be uncontroversial, then perhaps they can get in too.<br>&gt; <br>&gt; On the heredoc aspects specifically, unless others chime in with strong opinions about the topics you brought up, I’d suggest that you craft a proposal for adding them with your preferred solution to these.  You can mention the other answers (along with their tradeoffs and rationale for why you picked whatever you think is right) in the proposal, and we can help the community hash it out.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/93798af0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks Brent for pulling together the proposal and summarising this thread.<br></p><p>I have to say I still feel most drawn to your “continuation quotes” idea and after<br>some thought the “_” modifier for _”strings”with”quotes”_ also seems sensible.<br>Most of all, for me the appeal of these approaches is their absolute simplicity.<br>My only reservation is what external editors will make of these strings as there<br>is no precedent in another programming language I am aware of.<br></p><p>I’ve updated the &quot;reference toolchain&quot; and PR for testing and review.<br></p><p>http://johnholdsworth.com/swift-LOCAL-2016-05-01-a-osx.tar.gz<br>https://github.com/apple/swift/pull/2275<br></p><p>This implementation still contains the “e” modifier as an example of how they<br>would be lexed (which I’ll remove before submission as it is outside the scope <br>of this proposal) and one new feature that \ before a newline ignores the newline.<br>In this implementation modifiers can only be applied to the first segment of the literal.<br></p><p>This makes the following strings valid to my mind:<br></p><p>        let xml = &quot;\<br>            &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating \<br>                        &quot;applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;<br>            &quot;&quot;<br>        print(xml)<br></p><p>        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;<br>            &quot;&quot;_ )<br></p><p>        try! NSRegularExpression(pattern: e&quot;&lt;([a-zA-Z][\w]*)&quot;, options: [])<br>            .enumerateMatches(in: xml, options: [], range: NSMakeRange(0, xml.utf16.count)) {<br>                (result, flags, stop) in<br>                print((xml as NSString).substring( with:result!.range(at: 1)))<br>        }<br></p><p>I’d not create a lexStringMultilineLiteral() function just yet as the changes are still minor as you<br>can see from the PR and due to the fact you can’t determine if a string is multiline until you<br>are half way through it. Excuse the “bottom up&quot; approach but the reasoning is it would be no<br>accident that if the lexer and any changes to it are minimal, it will be easy to document and use.<br></p><p>John<br></p><p><br>&gt; On 1 May 2016, at 13:04, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; [couple minutes read]<br>&gt; <br>&gt; I read with great attention this thread, trying to see it from the implementation viewpoint (I know that the compiler structure should not drive the language features). I also revisited the how-to-contribute notes as well as the dev-process description. One of the ideas that stood out in my mind was that when looking at an implementation, enablement changes should be separated from the bulk of the feature, such that reviews can be easier.<br>&gt; <br>&gt; So I tried to elevate this to the rank of a hidden-mandatory-requirement for anything related to this feature. It lead me to a staged approach to this feature that would allow a lot of things to be done, OVER TIME.<br>&gt; <br>&gt; When distilling this feature to the smallest part enabler that would have to be added to the compiler I came to the following short list<br>&gt; <br>&gt; add a string_multiline_token  to the lexer<br>&gt; I realize that the current lexer can be tweaked to work (as per John’s PR), but IMO adding a dedicated &quot;hole&quot; in the parsing code is what will give something working today (no difference with current compiler behavior) while allowing all future changes to be cleanly isolated from anything around<br>&gt; if one accepts the idea of a hole created by the token, then it stands to reason to have delimiters around it. I looking at the structure of the grammar, I came to the conclusion that  _” and “_ where an easy, unambiguous choice (I believe “”” and “”” looked like an equally easy an unambiguous choice)<br>&gt; the next choice should be the creation of a lexStringMultilineLiteral() and lexMultilineCharacter() method in the Lexer. Again… bare with me, I do believe it is relevant to what everyone wants this feature to be… The latter method should contain only extensions specific to multiline literals delegating common use cases to lexCharacter()<br>&gt; <br>&gt; The main point of following this route (or any equivalent) is that <br>&gt; it represents a very clear commitment to multiline string literals<br>&gt; it ensures that there is no strong commitment to feature details, while allowing many future scenarios<br>&gt; it will remain backward compatible with enhancements to the current string literal syntax (translation?)<br>&gt; external contributors will be able to prototype while making sure we stay within strict boundaries for integration with the compiler<br>&gt; <br>&gt; The next equally small step would be to describe the required minimal changes to Parser, a step I do not want to take now if the compiler experts  view no merit at all to the proposed staged approach.<br>&gt; <br>&gt; <br>&gt; <br>&gt; A thought experiment pushing further down this path, shows how the following would be equally possible language features (with roughly equivalent implementation cost):<br>&gt; <br>&gt; let whyOwhy = “”&quot;\<br>&gt;     !!    Can&#39;t understand what improvements it truly delivers <br>&gt;     !!        It basically removes a handful of characters<br>&gt;     !!    It works today<br>&gt;     !!        But I don&#39;t see it as a likable foundations for adding in future enhancements<br>&gt;     !!\<br>&gt;     !!    I don&#39;t envy the people who will have to support it outside of xcode<br>&gt;     !!        Or even in xcode (considering how it currently struggles with indents/formatting<br>&gt;     !!    As for elegance, beauty is in the eye of the beholder, they say.<br>&gt; “”&quot;<br>&gt; var json1 = _&quot;[json]\<br>&gt;     !!{<br>&gt;     !!  &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>&gt;     !!  &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>&gt;     !!  &quot;rational&quot; : [<br>&gt;     !!          &quot;Here we go again&quot;<br>&gt;     !!          &quot;How will xcode help make these workable&quot;<br>&gt;     !!       ]<br>&gt;     !!}<br>&gt; “_<br>&gt; var json2 = _&quot;[json]\<br>&gt; {<br>&gt;   &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>&gt;   &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>&gt;   &quot;rational&quot; : [<br>&gt;           &quot;Here we go again&quot;<br>&gt;           &quot;How will xcode help make these workable&quot;<br>&gt;        ]<br>&gt; }<br>&gt; “_<br>&gt; <br>&gt;  [_&quot;]  --&gt; start string<br>&gt;  [_&quot;\] --&gt; start line + ignore spaces until eol (basically swallow \r\n)<br>&gt;  [!!\] --&gt; ignore everything until eol... basically the gap does not exits<br>&gt;  [&quot;_]  --&gt; terminate string<br>&gt;  [_&quot;[TYPEID]\] --&gt; start string knowing that it a verifyer or a formatter (or a chain of) understanding TYPEID can syntax check or format or or or<br>&gt; <br>&gt; <br>&gt; IMO splitting these expression from the current lexing/parsing has another long term benefits when coupled with the aforementioned idea of contents tagging:<br>&gt; allow external dedicated formatter to be created in any editor supporting swift<br>&gt; allow external validators (including in the form of compiler plugins)<br>&gt; open a door for an equivalent to the scala&#39;s macros for contents marked as  [swift]<br>&gt; <br>&gt; Once again I fully appreciate that implementation should not drive language design, but considering the flurry of great ideas, I thought it might in this instance be useful to identify a minimal, noncommittal, direction common to many scenarios, such that a step can be taken that will neither favor nor prohibit any of the proposals, but simply enable them all.<br>&gt; <br>&gt; Thank you for your patience<br>&gt; Regards<br>&gt; <br>&gt; PS: I am working on a rudimentary implementation that I hope could help people test all the ideas floating in this list. <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 26, 2016, at 8:04 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 25, 2016, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br>&gt;&gt; <br>&gt;&gt; Right. I consider modifiers to be highly precedented in other languages, and therefore proven to work.  If we go this way, I greatly prefer prefix to postfix modifiers.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br>&gt;&gt; <br>&gt;&gt; Right, but it is also heavy weight and ugly.  In your previous email you said about the single quote approach: &quot;The quotation marks on the left end up forming a column that marks the lines as special”, so I don’t see a need for a triple quote syntax to solve this specific problem.<br>&gt;&gt; <br>&gt;&gt;&gt; I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br>&gt;&gt; <br>&gt;&gt; I agree that this is a real problem that would be great to solve.<br>&gt;&gt; <br>&gt;&gt; If I step back and look at the string literal space we’re discussing, I feel like there are three options:<br>&gt;&gt; <br>&gt;&gt; 1) single and simple multiline strings, using “<br>&gt;&gt; 2) your triple quote sort of string, specifically tuned to avoid having to escape “ when it occurs once or twice in sequence.<br>&gt;&gt; 3) heredoc, which is a very general (but also very heavy weight) solution to quoting problems.<br>&gt;&gt; <br>&gt;&gt; I’m trying to eliminate the middle one, so we only have to have &quot;two things”.  Here are some alternative ways to solve the problem, which might have less of an impact on the language:<br>&gt;&gt; <br>&gt;&gt; A) Introduce single quoted string literals to avoid double quote problems specifically, e.g.:   ‘look “here” I say!’.  This is another form of #2 which is less ugly.  It also doesn’t help you if you have both “ and ‘ in your string.<br>&gt;&gt; <br>&gt;&gt; B) Introduce a modifier character that requires a more complex closing sequence to close off the string, see C++ raw string literals for prior art on this approach.  Perhaps something like:<br>&gt;&gt; <br>&gt;&gt; 	 Rxxx”look “ here “ I can use quotes “xxx<br>&gt;&gt; <br>&gt;&gt; That said, I still prefer C) &quot;ignore this issue for now”.  In other words, I wouldn’t want to block progress on improving the string literal situation overall on this issue, because anything we do here is an further extension to a proposal that doesn’t solve this problem.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let str = &lt;&lt;EOF<br>&gt;&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; \t&lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt; EOF<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two questions and a suggestion I have whenever heredoc syntax comes up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func x() -&gt; String {<br>&gt;&gt;&gt; 		return &lt;&lt;EOF<br>&gt;&gt;&gt; 		&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; 		&lt;catalog&gt;<br>&gt;&gt;&gt; 		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt; 		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; 		\t&lt;/book&gt;<br>&gt;&gt;&gt; 		&lt;/catalog&gt;<br>&gt;&gt;&gt; 		EOF<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does that seem like a good approach?<br>&gt;&gt; <br>&gt;&gt; I think that either approach could work, that you have a lot more experience on these topics than I do, and I would expect a vigorous community debate about these topics. :-)<br>&gt;&gt; <br>&gt;&gt; That said, if you look at what we’re discussing:<br>&gt;&gt; <br>&gt;&gt; 1. “Continuation&quot; string literals, to allow a multi-line string literal.  You and I appear to completely agree about this.<br>&gt;&gt; 2. Heredoc: You and I seem to agree that they are a good “fully general” solution to have, but there are the details you outline above to iron out.<br>&gt;&gt; 3. Modifier characters:  I’m in favor, but I don’t know where you stand.  There is also still much to iron out here (such as the specific characters).<br>&gt;&gt; 4. A way to avoid having to escape “ in a non-heredoc literal.  I’m still unconvinced, and think that any solution to this problem will be orthogonal to the problems solved by 1-3 (and therefore can be added after getting experience with the other parts).<br>&gt;&gt; <br>&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.  After that, we can discuss heredoc and modifiers (if you think they’re a good solution) on their own threads.  If those turn out to be uncontroversial, then perhaps they can get in too.<br>&gt;&gt; <br>&gt;&gt; On the heredoc aspects specifically, unless others chime in with strong opinions about the topics you brought up, I’d suggest that you craft a proposal for adding them with your preferred solution to these.  You can mention the other answers (along with their tradeoffs and rationale for why you picked whatever you think is right) in the proposal, and we can help the community hash it out.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/cad1e08a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi John,<br></p><p>in truth, your work is what gave me the idea of creating a separate parsing path now (what I called lexStringMultilineLiteral() )exactly for the two points you make:<br></p><p>it is possible/straightforward to ‘tweak’ the current lexing code to get something going as you proved it<br>using the default string literal recognition mechanism binds us to have to ‘wait’ a bit in order to figure which kind of string literal we are dealing with (single/multi line)<br></p><p>I poorly described that and apologize for it. So there is now doubt that with enough small alterations, the current parser will be made better, smarter, … my point is that this may not be desirable, and in fact be like the song of a siren calling in the wrong direction?!<br></p><p>Taking today the step to split the parsing into 2 separate paths has some implication on the features that can be devised in the future, without IMO ever having to revisit this fundamental split. However, I will also be the first to recognize that if there is no long term appeal for content type tagging or macros or custom formatters/verifiers, then there is indeed no need to split the path today, or ever for that matter.<br></p><p>But if these make sense for 3 and more likely past 3, then one can easily see today that a split is likely going to make these features a lot easier to implement then, and if it is the right path then and we can see it today, then IMO it stands to reason to build it in today (per the team’s development doctrine that features be as much as possible split between the preliminary enablement steps and the specifics of the features) provided that it does not commit us to anything today that has not and cannot yet be decided, and considering how it will on the other hand facilitate more exploratory work in the community with minimal burden to the core team. Considering the length of this thread and sophistication of some of the interventions, there is little doubt in my mind that this will not be a simple consensus builder, which will IMO only increase the value of having a common extension ground for prototypes.<br></p><p>The names I proposed are only the result of trying to make the additions simple by reference to the surrounding code, while trying to minimize the intersection between current and new code.  To that effect my ongoing implementation is based on a couple of changes in lexImpl(), the rest being isolated inside new methods. But fundamentally the question I am presenting is about the<br></p><p>long term usability of a contents tagging possibility (does not have to be done now, but will IMO be easier that way)<br>workload management utilitarian aspect of a simple base split today for parallel explorations and easier merges along the way<br></p><p>The short term how is only one of the possible ways, which only makes sense based on the long term term direction string literals will take.<br></p><p>Best regards, and thank you John for showing me where to start.<br></p><p>LM/<br></p><p><br>&gt; On May 1, 2016, at 7:15 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; Thanks Brent for pulling together the proposal and summarising this thread.<br>&gt; <br>&gt; I have to say I still feel most drawn to your “continuation quotes” idea and after<br>&gt; some thought the “_” modifier for _”strings”with”quotes”_ also seems sensible.<br>&gt; Most of all, for me the appeal of these approaches is their absolute simplicity.<br>&gt; My only reservation is what external editors will make of these strings as there<br>&gt; is no precedent in another programming language I am aware of.<br>&gt; <br>&gt; I’ve updated the &quot;reference toolchain&quot; and PR for testing and review.<br>&gt; <br>&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-01-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-01-a-osx.tar.gz&gt;<br>&gt; https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;<br>&gt; <br>&gt; This implementation still contains the “e” modifier as an example of how they<br>&gt; would be lexed (which I’ll remove before submission as it is outside the scope <br>&gt; of this proposal) and one new feature that \ before a newline ignores the newline.<br>&gt; In this implementation modifiers can only be applied to the first segment of the literal.<br>&gt; <br>&gt; This makes the following strings valid to my mind:<br>&gt; <br>&gt;         let xml = &quot;\<br>&gt;             &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating \<br>&gt;                         &quot;applications with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;<br>&gt;             &quot;&quot;<br>&gt;         print(xml)<br>&gt; <br>&gt;         assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;<br>&gt;             &quot;&quot;_ )<br>&gt; <br>&gt;         try! NSRegularExpression(pattern: e&quot;&lt;([a-zA-Z][\w]*)&quot;, options: [])<br>&gt;             .enumerateMatches(in: xml, options: [], range: NSMakeRange(0, xml.utf16.count)) {<br>&gt;                 (result, flags, stop) in<br>&gt;                 print((xml as NSString).substring( with:result!.range(at: 1)))<br>&gt;         }<br>&gt; <br>&gt; I’d not create a lexStringMultilineLiteral() function just yet as the changes are still minor as you<br>&gt; can see from the PR and due to the fact you can’t determine if a string is multiline until you<br>&gt; are half way through it. Excuse the “bottom up&quot; approach but the reasoning is it would be no<br>&gt; accident that if the lexer and any changes to it are minimal, it will be easy to document and use.<br>&gt; <br>&gt; John<br>&gt; <br>&gt; <br>&gt;&gt; On 1 May 2016, at 13:04, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [couple minutes read]<br>&gt;&gt; <br>&gt;&gt; I read with great attention this thread, trying to see it from the implementation viewpoint (I know that the compiler structure should not drive the language features). I also revisited the how-to-contribute notes as well as the dev-process description. One of the ideas that stood out in my mind was that when looking at an implementation, enablement changes should be separated from the bulk of the feature, such that reviews can be easier.<br>&gt;&gt; <br>&gt;&gt; So I tried to elevate this to the rank of a hidden-mandatory-requirement for anything related to this feature. It lead me to a staged approach to this feature that would allow a lot of things to be done, OVER TIME.<br>&gt;&gt; <br>&gt;&gt; When distilling this feature to the smallest part enabler that would have to be added to the compiler I came to the following short list<br>&gt;&gt; <br>&gt;&gt; add a string_multiline_token  to the lexer<br>&gt;&gt; I realize that the current lexer can be tweaked to work (as per John’s PR), but IMO adding a dedicated &quot;hole&quot; in the parsing code is what will give something working today (no difference with current compiler behavior) while allowing all future changes to be cleanly isolated from anything around<br>&gt;&gt; if one accepts the idea of a hole created by the token, then it stands to reason to have delimiters around it. I looking at the structure of the grammar, I came to the conclusion that  _” and “_ where an easy, unambiguous choice (I believe “”” and “”” looked like an equally easy an unambiguous choice)<br>&gt;&gt; the next choice should be the creation of a lexStringMultilineLiteral() and lexMultilineCharacter() method in the Lexer. Again… bare with me, I do believe it is relevant to what everyone wants this feature to be… The latter method should contain only extensions specific to multiline literals delegating common use cases to lexCharacter()<br>&gt;&gt; <br>&gt;&gt; The main point of following this route (or any equivalent) is that <br>&gt;&gt; it represents a very clear commitment to multiline string literals<br>&gt;&gt; it ensures that there is no strong commitment to feature details, while allowing many future scenarios<br>&gt;&gt; it will remain backward compatible with enhancements to the current string literal syntax (translation?)<br>&gt;&gt; external contributors will be able to prototype while making sure we stay within strict boundaries for integration with the compiler<br>&gt;&gt; <br>&gt;&gt; The next equally small step would be to describe the required minimal changes to Parser, a step I do not want to take now if the compiler experts  view no merit at all to the proposed staged approach.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A thought experiment pushing further down this path, shows how the following would be equally possible language features (with roughly equivalent implementation cost):<br>&gt;&gt; <br>&gt;&gt; let whyOwhy = “”&quot;\<br>&gt;&gt;     !!    Can&#39;t understand what improvements it truly delivers <br>&gt;&gt;     !!        It basically removes a handful of characters<br>&gt;&gt;     !!    It works today<br>&gt;&gt;     !!        But I don&#39;t see it as a likable foundations for adding in future enhancements<br>&gt;&gt;     !!\<br>&gt;&gt;     !!    I don&#39;t envy the people who will have to support it outside of xcode<br>&gt;&gt;     !!        Or even in xcode (considering how it currently struggles with indents/formatting<br>&gt;&gt;     !!    As for elegance, beauty is in the eye of the beholder, they say.<br>&gt;&gt; “”&quot;<br>&gt;&gt; var json1 = _&quot;[json]\<br>&gt;&gt;     !!{<br>&gt;&gt;     !!  &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>&gt;&gt;     !!  &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>&gt;&gt;     !!  &quot;rational&quot; : [<br>&gt;&gt;     !!          &quot;Here we go again&quot;<br>&gt;&gt;     !!          &quot;How will xcode help make these workable&quot;<br>&gt;&gt;     !!       ]<br>&gt;&gt;     !!}<br>&gt;&gt; “_<br>&gt;&gt; var json2 = _&quot;[json]\<br>&gt;&gt; {<br>&gt;&gt;   &quot;file&quot; : &quot;\(wishIhadPlaceholders)_000.md&quot;<br>&gt;&gt;   &quot;desc&quot; : &quot;and why are all examples in xml, i thought it died a while ago ;-)&quot;<br>&gt;&gt;   &quot;rational&quot; : [<br>&gt;&gt;           &quot;Here we go again&quot;<br>&gt;&gt;           &quot;How will xcode help make these workable&quot;<br>&gt;&gt;        ]<br>&gt;&gt; }<br>&gt;&gt; “_<br>&gt;&gt; <br>&gt;&gt;  [_&quot;]  --&gt; start string<br>&gt;&gt;  [_&quot;\] --&gt; start line + ignore spaces until eol (basically swallow \r\n)<br>&gt;&gt;  [!!\] --&gt; ignore everything until eol... basically the gap does not exits<br>&gt;&gt;  [&quot;_]  --&gt; terminate string<br>&gt;&gt;  [_&quot;[TYPEID]\] --&gt; start string knowing that it a verifyer or a formatter (or a chain of) understanding TYPEID can syntax check or format or or or<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; IMO splitting these expression from the current lexing/parsing has another long term benefits when coupled with the aforementioned idea of contents tagging:<br>&gt;&gt; allow external dedicated formatter to be created in any editor supporting swift<br>&gt;&gt; allow external validators (including in the form of compiler plugins)<br>&gt;&gt; open a door for an equivalent to the scala&#39;s macros for contents marked as  [swift]<br>&gt;&gt; <br>&gt;&gt; Once again I fully appreciate that implementation should not drive language design, but considering the flurry of great ideas, I thought it might in this instance be useful to identify a minimal, noncommittal, direction common to many scenarios, such that a step can be taken that will neither favor nor prohibit any of the proposals, but simply enable them all.<br>&gt;&gt; <br>&gt;&gt; Thank you for your patience<br>&gt;&gt; Regards<br>&gt;&gt; <br>&gt;&gt; PS: I am working on a rudimentary implementation that I hope could help people test all the ideas floating in this list. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 26, 2016, at 8:04 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 25, 2016, at 5:22 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; 3. It might be useful to make multiline `&quot;` strings trim trailing whitespace and comments like Perl&#39;s `/x` regex modifier does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you have modifier characters already, it is easy to build a small zoo full of these useful beasts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Modifiers are definitely a workable alternative, and can be quite flexible, particularly if a future macro system can let you create new modifiers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right. I consider modifiers to be highly precedented in other languages, and therefore proven to work.  If we go this way, I greatly prefer prefix to postfix modifiers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Alternative delimiters: If a string literal starts with three, or five, or seven, or etc. quotes, that is the delimiter, and fewer quotes than that in a row are simply literal quote marks. Four, six, etc. quotes is a quote mark abutting the end of the literal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let xml: String = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;catalog&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;\t&lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 				&quot;&quot;&quot;&lt;/catalog&gt;&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can&#39;t use this syntax to express an empty string, or a string consisting entirely of quote marks, but `&quot;&quot;` handles empty strings adequately, and escaping can help with quote marks. (An alternative would be to remove the abutting rule and permit `&quot;&quot;&quot;&quot;&quot;&quot;` to mean &quot;empty string&quot;, but abutting quotes seem more useful than long-delimiter empty strings.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that there is a need to support alternative delimiters, but subjectively, I find this to be pretty ugly.  It is also a really unfortunate degenerate case for “I just want a large blob of XML” because you’d end up using “&quot;” almost all the time, and you have to use it on every line.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On the other hand, the `&quot;&quot;&quot;` does form a much larger, more obvious continuation indicator. It is *extremely* obvious that the above line is not Swift code, but something else embedded in it. It&#39;s also extremely obvious what its extent is: when you stop seeing `&quot;&quot;&quot;`, you&#39;re back to normal Swift code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but it is also heavy weight and ugly.  In your previous email you said about the single quote approach: &quot;The quotation marks on the left end up forming a column that marks the lines as special”, so I don’t see a need for a triple quote syntax to solve this specific problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I *really* don&#39;t like the idea of our only alternatives being &quot;one double-quote mark with backslashing&quot; or &quot;use an entire heredoc&quot;. Heredocs have their place, but they are a *very* heavyweight quoting mechanism, and relatively short strings with many double-quotes are pretty common. (Consider, for instance, strings containing unparsed JSON.) I think we need *some* alternative to double-quotes, either single-quotes (with the same semantics, just as an alternative) or this kind of quote-stacking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this is a real problem that would be great to solve.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If I step back and look at the string literal space we’re discussing, I feel like there are three options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) single and simple multiline strings, using “<br>&gt;&gt;&gt; 2) your triple quote sort of string, specifically tuned to avoid having to escape “ when it occurs once or twice in sequence.<br>&gt;&gt;&gt; 3) heredoc, which is a very general (but also very heavy weight) solution to quoting problems.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m trying to eliminate the middle one, so we only have to have &quot;two things”.  Here are some alternative ways to solve the problem, which might have less of an impact on the language:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A) Introduce single quoted string literals to avoid double quote problems specifically, e.g.:   ‘look “here” I say!’.  This is another form of #2 which is less ugly.  It also doesn’t help you if you have both “ and ‘ in your string.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B) Introduce a modifier character that requires a more complex closing sequence to close off the string, see C++ raw string literals for prior art on this approach.  Perhaps something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	 Rxxx”look “ here “ I can use quotes “xxx<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I still prefer C) &quot;ignore this issue for now”.  In other words, I wouldn’t want to block progress on improving the string literal situation overall on this issue, because anything we do here is an further extension to a proposal that doesn’t solve this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For cases like this, I think it would be reasonable to have a “heredoc” like scheme, which does not allow leading indentation, and does work with all the same modifier characters above.  I do not have a preference on a particular syntax, and haven’t given it any thought, but this would allow you to do things like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let str = &lt;&lt;EOF<br>&gt;&gt;&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;catalog&gt;<br>&gt;&gt;&gt;&gt;&gt; \t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;&gt; \t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;&gt; \t&lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt;&gt; EOF<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for example.  You could then turn off escaping and other knobs using the modifier character (somehow, it would have to be incorporated into the syntax of course).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two questions and a suggestion I have whenever heredoc syntax comes up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q1: Does the heredoc begin immediately, at the next line, or at the next valid place for a statement to start? Heredocs traditionally take the second approach.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q2: Do you permit heredocs to stack—that is, for a single line to specify multiple heredocs?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; S: During the Perl 6 redesign, they decided to use the delimiter&#39;s indentation to determine the base indentation for the heredoc:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func x() -&gt; String {<br>&gt;&gt;&gt;&gt; 		return &lt;&lt;EOF<br>&gt;&gt;&gt;&gt; 		&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; 		&lt;catalog&gt;<br>&gt;&gt;&gt;&gt; 		\t&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt; 		\t\t&lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; 		\t&lt;/book&gt;<br>&gt;&gt;&gt;&gt; 		&lt;/catalog&gt;<br>&gt;&gt;&gt;&gt; 		EOF<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does that seem like a good approach?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that either approach could work, that you have a lot more experience on these topics than I do, and I would expect a vigorous community debate about these topics. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, if you look at what we’re discussing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. “Continuation&quot; string literals, to allow a multi-line string literal.  You and I appear to completely agree about this.<br>&gt;&gt;&gt; 2. Heredoc: You and I seem to agree that they are a good “fully general” solution to have, but there are the details you outline above to iron out.<br>&gt;&gt;&gt; 3. Modifier characters:  I’m in favor, but I don’t know where you stand.  There is also still much to iron out here (such as the specific characters).<br>&gt;&gt;&gt; 4. A way to avoid having to escape “ in a non-heredoc literal.  I’m still unconvinced, and think that any solution to this problem will be orthogonal to the problems solved by 1-3 (and therefore can be added after getting experience with the other parts).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you agree that these are all orthogonal pieces, then treat them as such: I’d suggest that you provide a proposal that just tackles the continuation string literals.  This seems simple, and possible to get in for Swift 3.  After that, we can discuss heredoc and modifiers (if you think they’re a good solution) on their own threads.  If those turn out to be uncontroversial, then perhaps they can get in too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the heredoc aspects specifically, unless others chime in with strong opinions about the topics you brought up, I’d suggest that you craft a proposal for adding them with your preferred solution to these.  You can mention the other answers (along with their tradeoffs and rationale for why you picked whatever you think is right) in the proposal, and we can help the community hash it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160501/59a2c81b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	• using the default string literal recognition mechanism binds us to have to ‘wait’ a bit in order to figure which kind of string literal we are dealing with (single/multi line)<br></p><p>Part of the idea of the continuation quotes proposal is that there *is* no distinction between a single-line literal and a multi-line literal. There are just string literals, which may include one line or many.<br></p><p>And in general, part of the advantage of this proposal is precisely that it has such low impact on the parser and lexer, and the grammar more generally. It is currently illegal to open a string and fail to close it on the same line, so we are just giving that obviously illegal construct an interpretation. By extending the existing feature, we get a whole lot of stuff for free:<br></p><p>* We don&#39;t have to worry about whether `|&gt;` or `@|` or whatever construct you end up using might, in some place where you could otherwise use a string literal, be confusable with some other construct.<br>* We don&#39;t have to worry about whether obscure corners of the language, like the string parameters to `@available`, support multiline string literals (they do, automatically).<br>* We don&#39;t have to do a huge amount of redesigning in the lexer, and I doubt we&#39;ll have to touch the parser at all (the prototype doesn&#39;t).<br></p><p>It seems a bit backwards to propose we introduce a separate path for lexing multiline strings, and then complain that one of the proposals on the table makes it difficult to tell which path you should take, when the proposal in question is specifically designed to make having a separate path unnecessary.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  2, 2016 at 03:00:00am</p></header><div class="content"><p>On May 2, 2016, at 1:49 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt;    • using the default string literal recognition mechanism binds us to have to ‘wait’ a bit in order to figure which kind of string literal we are dealing with (single/multi line)<br>&gt; <br>&gt; Part of the idea of the continuation quotes proposal is that there *is* no distinction between a single-line literal and a multi-line literal. There are just string literals, which may include one line or many.<br>&gt; <br>&gt; And in general, part of the advantage of this proposal is precisely that it has such low impact on the parser and lexer, and the grammar more generally. It is currently illegal to open a string and fail to close it on the same line, so we are just giving that obviously illegal construct an interpretation. By extending the existing feature, we get a whole lot of stuff for free:<br>&gt; <br></p><p>I appreciate how easy it is to retrofit some multiline literal behavior without touching much as demonstrated by John&#39;s code (I also implemented a different patch that isolates all code changes inside a couple new methods and generates the existing string_literal token).<br></p><p>The problem I am facing is that I also want to support &quot;ZERO massaging&quot; schemes (direct past without editing the lines), and so far I have not seen how to do it without opening a wider whole through the parser/lexer. I chose to make a parallel route simply to avoid risking making my code a merge nightmare as soon as the core team touches anything in the vicinity.<br></p><p><br>&gt; * We don&#39;t have to worry about whether `|&gt;` or `@|` or whatever construct you end up using might, in some place where you could otherwise use a string literal, be confusable with some other construct.<br>&gt; * We don&#39;t have to worry about whether obscure corners of the language, like the string parameters to `@available`, support multiline string literals (they do, automatically).<br>&gt; * We don&#39;t have to do a huge amount of redesigning in the lexer, and I doubt we&#39;ll have to touch the parser at all (the prototype doesn&#39;t).<br>&gt; <br>&gt; It seems a bit backwards to propose we introduce a separate path for lexing multiline strings, and then complain that one of the proposals on the table makes it difficult to tell which path you should take, when the proposal in question is specifically designed to make having a separate path unnecessary.<br></p><p>Just to be sure, I am complaining about anything, but merely referencing an argument I read in one of John Holdsworth&#39;s recent contribution. Regarding the &quot;unnecessary separate path&quot;, IMHO it depends on what the end game is supposed to look like (as previously stated, I want to try tagging the contents of multine literals, which makes them different from single line ones), and at what horizon.<br></p><p>No matter what, you are the experts... I just appreciate how easy the quality of the codebase makes prototyping some of these ideas.<br></p><p>King regards<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  1, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; The problem I am facing is that I also want to support &quot;ZERO massaging&quot; schemes (direct past without editing the lines), and so far I have not seen how to do it without opening a wider whole through the parser/lexer. I chose to make a parallel route simply to avoid risking making my code a merge nightmare as soon as the core team touches anything in the vicinity.<br></p><p>I totally understand that; since I do think we should have a no-massaging feature eventually, you&#39;re right that such a path should probably exist sooner or later.<br></p><p>Sorry if I jumped down your throat—I think I just misinterpreted what you were asking for.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May  2, 2016 at 11:00:00am</p></header><div class="content"><p>So I’m pretty late to the discussion here, but my question is; do we really want to encourage large blocks of text in code? They tend to bloat things, especially if they’re not used very often, and even if they are, any large chunk of text can be loaded from file and cached if (and when) necessary. If you need to process it, then some kind of templating system would be better.<br></p><p>I dunno, I just feel like if you’re storing enough text that the current syntax becomes burdensome, then perhaps the text should be stored elsewhere? I’d rather discourage big blocks of text in code personally.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8def0d36f56d3e6720a44e41bf6f9a71?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Basem Emara</string> &lt;contact at basememara.com&gt;<p>May  2, 2016 at 06:00:00am</p></header><div class="content"><p>I’ve been trying to keep up with this thread and this crossed my mind too. Of course, we don’t want to rule out multi-line strings because of readability and flexibility (Python “”” or Markdown’s ```…``` would be my vote). However, a built-in tempting engine like Mustache would be progressive and powerful.<br></p><p>&gt; On May 2, 2016, at 6:31 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So I’m pretty late to the discussion here, but my question is; do we really want to encourage large blocks of text in code? They tend to bloat things, especially if they’re not used very often, and even if they are, any large chunk of text can be loaded from file and cached if (and when) necessary. If you need to process it, then some kind of templating system would be better.<br>&gt; <br>&gt; I dunno, I just feel like if you’re storing enough text that the current syntax becomes burdensome, then perhaps the text should be stored elsewhere? I’d rather discourage big blocks of text in code personally.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  2, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; So I’m pretty late to the discussion here, but my question is; do we really want to encourage large blocks of text in code?<br></p><p>It&#39;s not written up, but it has occurred to me that, rather than having `&quot;&quot;&quot;` strings or even heredocs for large chunks of text, we might want something which puts the text at the end of the file, or even in a separate file. I even have some vague ideas about what that might look like.<br></p><p>But that is so *massively* out of scope for Swift 3 that I don&#39;t think it&#39;s worth contemplating right now. There are so many interesting possibilities we virtually have to punt.<br></p><p>The latest draft of my proposal adds this section:<br></p><p>	### An aside: Small and large multiline strings<br>	<br>	The first entry in the list above, &quot;Putting newlines in string <br>	literals&quot;, might be thought of as a subset of the fourth, &quot;putting very <br>	large quantities of text in string literals&quot;. (In fact, *all* of the <br>	entries could perhaps be subsumed by the fourth.) However, we believe <br>	they are best addressed as separate goals, using separate features.<br>	<br>	When you are embedding enormous string literals in source code, you <br>	must put undistorted representation of the string above all other <br>	considerations. If the design which best permits the string to be <br>	written verbatim is ugly, bulky, unlike other language constructs, <br>	disruptive to code readability, error-prone, arbitrary, difficult to <br>	parse, or otherwise a wart on the language, that is simply the price we <br>	have to pay for that feature.<br>	<br>	But it&#39;s a different story for short multiline strings. When you are <br>	writing a little bit of text, but still more than one line, you don&#39;t <br>	want to disrupt your code&#39;s indentation, add whole lines just for <br>	delimiters, insert bizarre or cryptic tokens into your code, or create <br>	syntax errors which take ten minutes to trace back to their source. You <br>	want a different feature, with different tradeoffs.<br>	<br>	It is that feature which this proposal seeks to design.<br></p><p>I envision that, during Swift 3, people will indeed use multiline string literals for very long strings. But eventually (hopefully by 4), we will have some other feature specifically designed and optimized for that task, and multiline string literals will only be used for relatively short strings where the &quot;really long string&quot; feature would be too clunky. I mean things like error messages, short snippets of HTML, stuff like that. Things you write in your source code, rather than designing somewhere else and then copying to your source code.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49f329a0267f5a1773a77017882a82a8?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Rainer Brockerhoff</string> &lt;rainer at brockerhoff.net&gt;<p>May  2, 2016 at 11:00:00am</p></header><div class="content"><p>On 5/2/16 09:53, Brent Royal-Gordon via swift-evolution wrote:<br>&gt; 	When you are embedding enormous string literals in source code, you <br>&gt; 	must put undistorted representation of the string above all other <br>&gt; 	considerations. If the design which best permits the string to be <br>&gt; 	written verbatim is ugly, bulky, unlike other language constructs, <br>&gt; 	disruptive to code readability, error-prone, arbitrary, difficult to <br>&gt; 	parse, or otherwise a wart on the language, that is simply the price we <br>&gt; 	have to pay for that feature.<br></p><p>+1. I&#39;ve tried to write this up a few times, but couldn&#39;t find a<br>satisfactory syntax; still, how about introducing &quot;named comments&quot; or<br>&quot;footnotes in comments&quot; like this:<br></p><p>/*#label#<br>...N lines of unescaped, as-is text<br>#*/<br></p><p>and elsewhere in source referring to this with some #construct(label)<br>syntax?<br></p><p>&gt; 	But it&#39;s a different story for short multiline strings. When you are <br>&gt; 	writing a little bit of text, but still more than one line, you don&#39;t <br>&gt; 	want to disrupt your code&#39;s indentation, add whole lines just for <br>&gt; 	delimiters, insert bizarre or cryptic tokens into your code, or create <br>&gt; 	syntax errors which take ten minutes to trace back to their source. You <br>&gt; 	want a different feature, with different tradeoffs.<br></p><p>At least for Xcode having a &quot;paste as escaped string&quot; would solve this,<br>other platforms/editors could have a standard macro with the same<br>effect. Of course readability of the pasted literal would suffer.<br></p><p><br>-- <br>Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>Belo Horizonte, Brazil<br>&quot;In the affairs of others even fools are wise<br>In their own business even sages err.&quot;<br>http://brockerhoff.net/blog/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30d1f306226b784770a7365f08cb388b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Chris Blessing</string> &lt;cblessing at dvd.com&gt;<p>May  2, 2016 at 11:00:00am</p></header><div class="content"><p>Hi swift-evo,<br></p><p>Forgive my naive interjection here.  I’ve enjoyed lurking on this list and watching all the discussions around topics I don’t even fully understand, but this one strikes me.<br></p><p>I certainly agree that multi-line literals should be undistorted, and I also agree that they should be 100% easy to edit/read in the source. To that end, my (hold your breath) PHP dev days made great use of the heredoc syntax. I know it has been covered in this thread but I haven’t seen any compelling reason why it shouldn’t be the solution to this wanted feature.<br></p><p>var myString = &lt;&lt;&lt;SOMETAG<br>// string content starts here after the new line<br>SOMETAG&gt;&gt;&gt;	// ends here<br></p><p>String interpolation could be implemented as-is:<br></p><p>var myString = &lt;&lt;&lt;LETTER<br>Dear \(receipientName),<br></p><p>I’m writing this letter to you… // more lines<br>// more lines<br>// more lines<br>Sincerely,<br></p><p>\(senderName)<br>LETTER&gt;&gt;&gt;<br></p><p><br>There are a few constraints from PHP land which might make this easier (? simpler?) to implement:<br></p><p>- multi-line string contents begin on the NEXT line after the opening heredoc operator<br>- closing operator MUST have no prefix characters (so it must be directly after the last line of the string, and cannot be indented)<br>—&gt; this means source code formatting can be a tad out of alignment with the rest of your code but then what multi-line string isn’t?<br>-&gt; in fact the behavior is very similar to a &lt;pre&gt;&lt;/pre&gt; block of HTML, whitespace counts!<br></p><p>Benefits include:<br></p><p>- absolutely no need for a line-by-line delimiter<br>- any character could be supported in the multi-line block<br>- string interpolation is completely possible (and could be made optional if that speeds things up)<br>- parser errors would be pretty simple to read and should be sufficient to prevent compile-time errors<br></p><p><br>Again apologies if this has already been shot down, and yes I fully admit that I don’t even know the origin of heredoc syntax (it’s probably something awful or great from the past) but objectively, I can’t see too many downsides to this solution.<br></p><p>With humility,<br></p><p>-Chris<br></p><p><br>&gt; On May 2, 2016, at 7:47 AM, Rainer Brockerhoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 5/2/16 09:53, Brent Royal-Gordon via swift-evolution wrote:<br>&gt;&gt; 	When you are embedding enormous string literals in source code, you <br>&gt;&gt; 	must put undistorted representation of the string above all other <br>&gt;&gt; 	considerations. If the design which best permits the string to be <br>&gt;&gt; 	written verbatim is ugly, bulky, unlike other language constructs, <br>&gt;&gt; 	disruptive to code readability, error-prone, arbitrary, difficult to <br>&gt;&gt; 	parse, or otherwise a wart on the language, that is simply the price we <br>&gt;&gt; 	have to pay for that feature.<br>&gt; <br>&gt; +1. I&#39;ve tried to write this up a few times, but couldn&#39;t find a<br>&gt; satisfactory syntax; still, how about introducing &quot;named comments&quot; or<br>&gt; &quot;footnotes in comments&quot; like this:<br>&gt; <br>&gt; /*#label#<br>&gt; ...N lines of unescaped, as-is text<br>&gt; #*/<br>&gt; <br>&gt; and elsewhere in source referring to this with some #construct(label)<br>&gt; syntax?<br>&gt; <br>&gt;&gt; 	But it&#39;s a different story for short multiline strings. When you are <br>&gt;&gt; 	writing a little bit of text, but still more than one line, you don&#39;t <br>&gt;&gt; 	want to disrupt your code&#39;s indentation, add whole lines just for <br>&gt;&gt; 	delimiters, insert bizarre or cryptic tokens into your code, or create <br>&gt;&gt; 	syntax errors which take ten minutes to trace back to their source. You <br>&gt;&gt; 	want a different feature, with different tradeoffs.<br>&gt; <br>&gt; At least for Xcode having a &quot;paste as escaped string&quot; would solve this,<br>&gt; other platforms/editors could have a standard macro with the same<br>&gt; effect. Of course readability of the pasted literal would suffer.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Rainer Brockerhoff  &lt;rainer at brockerhoff.net&gt;<br>&gt; Belo Horizonte, Brazil<br>&gt; &quot;In the affairs of others even fools are wise<br>&gt; In their own business even sages err.&quot;<br>&gt; http://brockerhoff.net/blog/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  1, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; My only reservation is what external editors will make of these strings as there<br>&gt; is no precedent in another programming language I am aware of.<br></p><p>I understand what you mean. The `e` syntax is similar to some things in other languages (C# uses `@`, Python uses `r`, etc.), but so far as I&#39;m aware, we&#39;re breaking new ground with the other stuff.<br></p><p>On the other hand, we&#39;d hardly be the first language to do exotic things for multiline strings or alternate delimiters. I think people who use general purpose text editors are used to this stuff not always working quite right.<br></p><p>&gt; I’ve updated the &quot;reference toolchain&quot; and PR for testing and review.<br>&gt; <br>&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-01-a-osx.tar.gz<br>&gt; https://github.com/apple/swift/pull/2275<br></p><p>Thank you. It is super-cool to be able to take these things out for a test drive.<br></p><p>&gt; This implementation still contains the “e” modifier as an example of how they<br>&gt; would be lexed (which I’ll remove before submission as it is outside the scope <br>&gt; of this proposal)<br></p><p>I left a line comment in the pull request about how it&#39;s been implemented, but this is great for testing the ergonomics.<br></p><p>I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br></p><p>Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br></p><p>I&#39;ve written a gist with some tests to show how I expect things to work:<br></p><p>	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e<br></p><p>I haven&#39;t looked into Stdlib&#39;s testing tools, so I wrote a chunk of code that uses an old Perl testing format I know by heart. If these tests look useful, I&#39;d be happy to help adapt them to the Swift test suite.<br></p><p>If you want to look instead of run, the actual tests start around line 100. As I write this, it currently has three failures and two to-do tests (the todos use `e` and `_` at the same time). There are also a couple examples of expected compiler errors at the bottom of the file that you can uncomment.<br></p><p>&gt; and one new feature that \ before a newline ignores the newline.<br></p><p>This is in the &quot;Future directions for multiline strings&quot; section of the proposal. Having implemented this, how do you feel about it? Does it seem like such a no-brainer that we should just incorporate it into the proposal?<br></p><p>&gt; In this implementation modifiers can only be applied to the first segment of the literal.<br></p><p>That is how I imagine this would work. For instance:<br></p><p>	let swiftCode = e_&quot;print(&quot;hello, world!\n&quot;)<br>	                             &quot;print(&quot;How are you today?&quot;)&quot;_<br></p><p>Note that the continuation quote on the second line doesn&#39;t say `e` or `_`; it is merely a reminder that we are parsing a string literal, and doesn&#39;t need those things.<br></p><p>(If we wanted to, of course, we *could* require them. But I don&#39;t see much benefit—it would make changing modifiers burdensome.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br>&gt; <br>&gt; Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br>&gt; <br>&gt; I&#39;ve written a gist with some tests to show how I expect things to work:<br>&gt; <br>&gt; 	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e<br></p><p>The problem here is that I’ve not implemented unescaped literals fully as it would require changes outside the lexer.<br>This is because the string is first lexed and tokenised by one piece of code Lexer::lexStringLiteral but later<br>on in the code generation phase it generates the actual literal in a function Lexer::getEncodedStringSegment.<br>This is passed the same string from the source file but does not know what modifiers should be applied. As a result<br>normal escapes are still processed. All the “e” flag does is silence the error for invalid escapes during tokenising.<br></p><p>        assert( e&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\(author)\n&quot; );<br></p><p>Having encountered this limitation I managed to persuade myself this is what you want anyway but perhaps few would agree,<br>What has been implemented is more of an r”” than a e”” that solves the “picket fence” problem where you can also interpolate<br>into convenient regex literals. This is all beyond the scope of this proposal anyway so I’ll leave that battle for another day.<br>The changes to the compiler for anything else would be a step up in terms of disruption.<br></p><p>&gt;&gt; and one new feature that \ before a newline ignores the newline.<br>&gt; <br>&gt; This is in the &quot;Future directions for multiline strings&quot; section of the proposal. Having implemented this, how do you feel about it? Does it seem like such a no-brainer that we should just incorporate it into the proposal?<br></p><p>I agree, lets move it into scope.<br></p><p>Latest toolchain with the ability to have more than one modifier as you suggest is now:<br>http://johnholdsworth.com/swift-LOCAL-2016-05-02-a-osx.tar.gz<br></p><p>John<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/7ec4fbcd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  2, 2016 at 04:00:00pm</p></header><div class="content"><p>Inline<br></p><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On May 2, 2016, at 2:23 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br>&gt;&gt; <br>&gt;&gt; Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve written a gist with some tests to show how I expect things to work:<br>&gt;&gt; <br>&gt;&gt; 	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e<br>&gt; <br>&gt; The problem here is that I’ve not implemented unescaped literals fully as it would require changes outside the lexer.<br></p><p>I think you are correct, I am looking at Parse.cpp and further down the pipeline.<br></p><p>Here is a 1¢ thought born out of this exploration: <br></p><p>%1 = _&quot;[aapl_sil]&quot;\<br>// inline sil code (macro-like)<br>...<br>// more code<br>...<br>&quot;_<br></p><p>Just a different kind of string literal contents... understood by the ide (completion/syntax chk) and processed by the compiler at the right stage. Who knows where really adventurous devs might take something like this?<br></p><p><br>&gt; This is because the string is first lexed and tokenised by one piece of code Lexer::lexStringLiteral but later<br>&gt; on in the code generation phase it generates the actual literal in a function Lexer::getEncodedStringSegment.<br>&gt; This is passed the same string from the source file but does not know what modifiers should be applied. As a result<br>&gt; normal escapes are still processed. All the “e” flag does is silence the error for invalid escapes during tokenising.<br>&gt; <br>&gt;         assert( e&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\(author)\n&quot; );<br>&gt; <br>&gt; Having encountered this limitation I managed to persuade myself this is what you want anyway but perhaps few would agree,<br>&gt; What has been implemented is more of an r”” than a e”” that solves the “picket fence” problem where you can also interpolate<br>&gt; into convenient regex literals. This is all beyond the scope of this proposal anyway so I’ll leave that battle for another day.<br>&gt; The changes to the compiler for anything else would be a step up in terms of disruption.<br>&gt; <br>&gt;&gt;&gt; and one new feature that \ before a newline ignores the newline.<br>&gt;&gt; <br>&gt;&gt; This is in the &quot;Future directions for multiline strings&quot; section of the proposal. Having implemented this, how do you feel about it? Does it seem like such a no-brainer that we should just incorporate it into the proposal?<br>&gt; <br>&gt; I agree, lets move it into scope.<br>&gt; <br>&gt; Latest toolchain with the ability to have more than one modifier as you suggest is now:<br>&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-02-a-osx.tar.gz<br>&gt; <br>&gt; John<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/e536239b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  4, 2016 at 12:00:00am</p></header><div class="content"><p>inline<br></p><p>Regards<br>(From mobile)<br></p><p>On May 2, 2016, at 2:23 PM, John Holdsworth &lt;mac at johnholdsworth.com &lt;mailto:mac at johnholdsworth.com&gt;&gt; wrote:<br></p><p>&gt; <br>&gt;&gt; I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br>&gt;&gt; <br>&gt;&gt; Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve written a gist with some tests to show how I expect things to work:<br>&gt;&gt; <br>&gt;&gt; 	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e &lt;https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e&gt;<br>&gt; The problem here is that I’ve not implemented unescaped literals fully as it would require changes outside the lexer.<br>&gt; This is because the string is first lexed and tokenised by one piece of code Lexer::lexStringLiteral but later<br>&gt; on in the code generation phase it generates the actual literal in a function Lexer::getEncodedStringSegment.<br>&gt; This is passed the same string from the source file but does not know what modifiers should be applied. As a result<br>&gt; normal escapes are still processed. All the “e” flag does is silence the error for invalid escapes during tokenising.<br></p><p>Lexer just lays ropes around certain areas to tell what&#39;s where. sometimes this is not enough for extra semantics. this is the reason why i went down the path of a custom string_multiline_literal token. It looks like you might want to consider that path too. If you do, you might consider the merits of suggesting that half the work be put in place now, allowing both our experimentations (and other more sophisticated) to lean on it, as an alternative to just directly adding extra conditional code in the default lexer code.<br></p><p>&gt; Having encountered this limitation I managed to persuade myself this is what you want anyway but perhaps few would agree,<br>&gt; What has been implemented is more of an r”” than a e”” that solves the “picket fence” problem where you can also interpolate<br>&gt; into convenient regex literals. This is all beyond the scope of this proposal anyway so I’ll leave that battle for another day.<br>&gt; The changes to the compiler for anything else would be a step up in terms of disruption.<br></p><p>I found that by separating new from existing in Lexer using a new token, you can go further along without really disrupting the original flow. Having a custom token would give your a differentiation point to know how to treat the contents differently. As a concrete eg, this is my way to deal with 2 character prefix/postfix around multiline literals while keeping the existing interpolation logic in place:<br></p><p>void Lexer::getStringLiteralSegments(UNCHANGED SIG) {<br>  // normal initialization<br></p><p>  // drop double character marker of multiline literals<br>  if (Str.is(tok::string_multiline_literal)) {<br>    Bytes = Bytes.drop_front().drop_back();<br>  }<br>  <br>  // normal segmenter below<br>}<br></p><p>Just thinking… another way to differentiation could be to seed the second lexer with a specific initial token to giving it a different context to interpret incoming chars from. Would probably give you the extra context you seem to be looking for (without widening the signature of the existing parse/lexer communication channel).<br></p><p>@dabrahams / @clattner<br>Might I ask if it would be possible to have even a very high level yup/nope answer regarding the feasibility of using the temporary lexer swapping facility to inline SIL contents as the body of multiline string literal expression? <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/88755ac3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  4, 2016 at 12:00:00pm</p></header><div class="content"><p>… response inline<br></p><p>&gt; On May 2, 2016, at 2:23 PM, John Holdsworth &lt;mac at johnholdsworth.com &lt;mailto:mac at johnholdsworth.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve written a gist with some tests to show how I expect things to work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e &lt;https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e&gt;<br>&gt;&gt; The problem here is that I’ve not implemented unescaped literals fully as it would require changes outside the lexer.<br>&gt;&gt; This is because the string is first lexed and tokenised by one piece of code Lexer::lexStringLiteral but later<br>&gt;&gt; on in the code generation phase it generates the actual literal in a function Lexer::getEncodedStringSegment.<br>&gt;&gt; This is passed the same string from the source file but does not know what modifiers should be applied. As a result<br>&gt;&gt; normal escapes are still processed. All the “e” flag does is silence the error for invalid escapes during tokenising.<br>&gt; <br>&gt; Lexer just lays ropes around certain areas to tell what&#39;s where. sometimes this is not enough for extra semantics. this is the reason why i went down the path of a custom string_multiline_literal token. It looks like you might want to consider that path too. If you do, you might consider the merits of suggesting that half the work be put in place now, allowing both our experimentations (and other more sophisticated) to lean on it, as an alternative to just directly adding extra conditional code in the default lexer code.<br></p><p>Not sure what you mean here. It’s the modifiers that have a greater effect on lexing, not whether a string is multi-line. IMO it’s <br>probably best to avoid creating a separate string_multiline_literal token as that would require visiting the grammar everywhere<br>a string could occur. If you want to see what I mean I’ve committed a change which uses 3 extra bits to the Token structure to<br>carry modifiers applied from the lexing stage to code generation so non-escaping strings can finally be handled correctly.<br></p><p>https://github.com/apple/swift/pull/2275<br>new toolchain: http://johnholdsworth.com/swift-LOCAL-2016-05-04-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-04-a-osx.tar.gz&gt;<br></p><p>The following now holds<br></p><p>        assert( e&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\\(author)\\n&quot; );<br>        assert( r&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\(author)\n&quot; ); // previous implementation<br></p><p>John<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/18ab892c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  4, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 4, 2016, at 1:51 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; … response inline<br>&gt; <br>&gt;&gt;&gt; On May 2, 2016, at 2:23 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m having trouble getting the `e` modifier to work as advertised, at least for the sequence `\\`. For example, `print(e&quot;\\\\&quot;)` prints two backslashes, and `print(e&quot;\\\&quot;)` seems to try to escape the string literal. I&#39;m currently envisioning `e` as disabling *all* backslash escapes, so these behaviors wouldn&#39;t be appropriate. It also looks like interpolation is still enabled in `e` strings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since other things like `print(e&quot;\w+&quot;)` work just fine, I&#39;m guessing this is a bug in the proposal&#39;s sketches (not being clear enough about the expected behavior), not your code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve written a gist with some tests to show how I expect things to work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem here is that I’ve not implemented unescaped literals fully as it would require changes outside the lexer.<br>&gt;&gt;&gt; This is because the string is first lexed and tokenised by one piece of code Lexer::lexStringLiteral but later<br>&gt;&gt;&gt; on in the code generation phase it generates the actual literal in a function Lexer::getEncodedStringSegment.<br>&gt;&gt;&gt; This is passed the same string from the source file but does not know what modifiers should be applied. As a result<br>&gt;&gt;&gt; normal escapes are still processed. All the “e” flag does is silence the error for invalid escapes during tokenising.<br>&gt;&gt; <br>&gt;&gt; Lexer just lays ropes around certain areas to tell what&#39;s where. sometimes this is not enough for extra semantics. this is the reason why i went down the path of a custom string_multiline_literal token. It looks like you might want to consider that path too. If you do, you might consider the merits of suggesting that half the work be put in place now, allowing both our experimentations (and other more sophisticated) to lean on it, as an alternative to just directly adding extra conditional code in the default lexer code.<br>&gt; <br>&gt; Not sure what you mean here. It’s the modifiers that have a greater effect on lexing, not whether a string is multi-line. IMO it’s <br>&gt; probably best to avoid creating a separate string_multiline_literal token as that would require visiting the grammar everywhere<br>&gt; a string could occur. If you want to see what I mean I’ve committed a change which uses 3 extra bits to the Token structure to<br>&gt; carry modifiers applied from the lexing stage to code generation so non-escaping strings can finally be handled correctly.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2275<br>&gt; new toolchain: http://johnholdsworth.com/swift-LOCAL-2016-05-04-a-osx.tar.gz<br>&gt; <br>&gt; The following now holds<br>&gt; <br>&gt;         assert( e&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\\(author)\\n&quot; );<br>&gt;         assert( r&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\(author)\n&quot; ); // previous implementation<br>&gt; <br>&gt; John<br>&gt; <br></p><p>Cool job!.. Yup, you proceed by &quot;widening the existing holes&quot; to carry the missing info (eg Modifiers). Making direct changes to lexCharacter() is a step I thought might be a bit premature considering nothing is carved in stone yet. I was trying to advocate for a clean boundary between current behavior and new ones, such that we, as well as others, would be able to try alternative syntaxes by changing the content of clearly identified methods (as opposed to starting their own integration from scratch each time, or having to un-unstitch parts of multiple already not so simple methods). I guess I am also extra cautious in my own coding because this a lexer, and the more paths through something like lexCharacter() or getEncodedStringSegment(), the more difficult it might be to prove that all of them have been identified and exercised. Thx for inspiring my experimentations.<br></p><p>Very Best<br>(From mobile)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/815924d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  4, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 4 May 2016, at 15:07, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Cool job!.. Yup, you proceed by &quot;widening the existing holes&quot; to carry the missing info (eg Modifiers). Making direct changes to lexCharacter() is a step I thought might be a bit premature considering nothing is carved in stone yet. I was trying to advocate for a clean boundary between current behavior and new ones, such that we, as well as others, would be able to try alternative syntaxes by changing the content of clearly identified methods (as opposed to starting their own integration from scratch each time, or having to un-unstitch parts of multiple already not so simple methods). I guess I am also extra cautious in my own coding because this a lexer, and the more paths through something like lexCharacter() or getEncodedStringSegment(), the more difficult it might be to prove that all of them have been identified and exercised. Thx for inspiring my experimentations.<br>&gt; <br></p><p>Thanks (I think!). I’m not trying to disenfranchise other developers by trying to squeeze all functionality into the existing functions.<br>It’s the nature of the problem. Multiline strings, alternative delimiter _””_ and non processing of escapes (\’s) are orthogonal;<br>they can in theory be applied separately and together. Wouldn’t that require 8 separate implementations dependent on<br>the combination? Far easier to just use modality. The code is getting unruly but not beyond the pale yet.<br></p><p>It’s just a prototype anyway intended to help with specification and testing. Better take a step back.<br></p><p>Did we get near to acquiescence to any of the following as a prospective proposal (as I understand it)?<br></p><p>	1) Any string literal that is it not closed becomes a multiline literal if the first non-whitespace character on the next line is “<br></p><p>        let xml = &quot;\<br>            &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating \<br>                        &quot;applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;\n&quot;<br>        print(xml)<br></p><p><br>While this is not ideal in terms of having to massage data templates as you paste them in, it is the price of code that looks<br>easy on the eye. (In practice pasting into Xcode it will reformat your string anyway so editing will normally be required.)<br>What will other editors make of this novel format?<br></p><p>Optionally, for a separate proposal perhaps:<br></p><p>	2) As a convenience, if a literal starts with _” it must be terminated by “_ to avoid having to escape embedded “s.<br></p><p>        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;<br>            &quot;&quot;_ )<br></p><p>	3) Opening the floodgates to an alphabet of the literal modifiers, if the string starts e”a string” then all escape sequences<br>	including interpolation but not including \” and \&lt;newline&gt; are not processed but passed through into the literal intact.<br></p><p>        assert( e&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\\(author)\\n&quot; );<br></p><p>	These modifiers are smuggled through the parsing process to code generation by storing them against the Token.<br></p><p>Very Optionally, and largely as an historical accident<br></p><p>	4) an r”regex” string will pass through non-standard escapes but still process \0, \r, \n, \”, \’, \\, \u{NNNN} and \(<br></p><p>        assert( r&quot;\w\d+\(author)\n&quot; == &quot;\\w\\d+\(author)\n&quot; ); // handy if you ask me<br></p><p>Brent, what is the state of the proposal document you prepared?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/a741ba6d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  4, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Brent, what is the state of the proposal document you prepared?<br></p><p>The state is that there is now a third draft, pasted below.<br></p><p>The main change in this version is that I&#39;ve included a *lot* of rationale around what I think needs to be done to strings overall. This kind of bloats the proposal, but I&#39;m not sure if there&#39;s a better way to make clear why it&#39;s tackling the problems it is.<br></p><p>John: I have not moved your trailing backslash suggestion back into the proposal yet, simply because I haven&#39;t decided how to write it up yet. I probably will unless others strongly think it should be subsetted out.<br></p><p>Dave: This obliquely addresses some of the points in your email, but I intend to reply more directly soon. Sorry, life has been happening to me during the last few days.<br>Multiline string literals<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Brent Royal-Gordon &lt;https://github.com/brentdax&gt;, John Holdsworth &lt;https://github.com/johnno1962&gt;, Tyler Cloutier &lt;https://github.com/TheArtOfEngineering&gt;<br>Status: Third Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduction&gt;Introduction<br></p><p>In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature emphasizing code readability which is a straightforward extension of our existing string literals and appears to be exceptionally easy to implement.<br></p><p>This proposal is the first step in a larger plan to improve how string literals address various challenging use cases. By itself, it is not meant to solve all problems with string escaping or the representation of long string literals. However, it is an important step in that direction, and it does modestly improve on the status quo even for those use cases which we intend to address more directly later.<br></p><p>See the &quot;Motivation&quot; section for the overall goals of this project, and the &quot;Future directions for string literals in general&quot; section for a sketch of how we might achieve those goals.<br></p><p>Swift-evolution threads: multi-line string literals. (April) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160418/015500.html&gt;, multi-line string literals (December) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002349.html&gt;<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#third-draft-notes&gt;Third draft notes<br></p><p>Expands the &quot;Motivation&quot; section to discuss the overall string improvement project, including a list of goals, and reworks the &quot;Future directions for string literals in general&quot; section to theme it around the new list of goals and to discuss the sketched designs and some alternatives in more detail.<br></p><p>Added a change to the formal grammar.<br></p><p>Added discussion of John Holdsworth&#39;s prototype and the implementation lessons from it.<br></p><p>Fills in co-authors. (I did the proposal drafting, John did the prototyping, and Tyler had the original idea and offered particularly detailed critiques.)<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#motivation&gt;Motivation<br></p><p>Swift&#39;s string literals include the minimum viable feature set: they have quoting and escaping features sufficient to embed any Unicode string in a Swift source code file. They also support interpolation, a feature which makes constructing strings from dynamic data much easier. This is a great foundation for Swift string handling.<br></p><p>However, as Swift begins to move into roles beyond native app development, code which needs to generate text becomes a more important use case. Whether you&#39;re emitting HTML or XML, writing configuration files, generating source code in Swift or another language, or just showing long textual messages to the user, you need string literals to be more than just &quot;minimum viable&quot;. We must move beyond that, making it easy and even pleasant to embed long, complex, and special-character-ridden strings into Swift code.<br></p><p>There are four very important areas where we think string literals need to improve:<br></p><p>Putting newlines in string literals.<br>Putting backslashes in string literals.<br>Putting quote marks in string literals.<br>Putting very large quantities of text (more than, say, twenty lines) in string literals.<br>Swift&#39;s design principles call for an incremental approach to design, so this proposal only considers the first of these four goals. We intend to address the others in separate but compatible future proposals, with the goal of fixing at least two in Swift 3 and all four by the time Swift 4 is released. A sketch of one possible design for these features is included in the &quot;Future directions for string literals in general&quot; section below.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#an-aside-small-and-large-multiline-strings&gt;An aside: Small and large multiline strings<br></p><p>The first entry in the list above, &quot;Putting newlines in string literals&quot;, might be thought of as a subset of the fourth, &quot;putting very large quantities of text in string literals&quot;. (In fact, all of the entries could perhaps be subsumed by the fourth.) However, we believe they are best addressed as separate goals, using separate features.<br></p><p>When you are embedding enormous string literals in source code, you must put undistorted representation of the string above all other considerations. If the design which best permits the string to be written verbatim is ugly, bulky, unlike other language constructs, disruptive to code readability, error-prone, arbitrary, difficult to parse, or otherwise a wart on the language, that is simply the price we have to pay for that feature.<br></p><p>But it&#39;s a different story for short multiline strings. When you are writing a little bit of text, but still more than one line, you don&#39;t want to disrupt your code&#39;s indentation, add whole lines just for delimiters, insert bizarre or cryptic tokens into your code, or create syntax errors which take ten minutes to trace back to their source. You want a different feature, with different tradeoffs.<br></p><p>It is that feature which we propose.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#the-goal-newlines-in-string-literals&gt;The goal: Newlines in string literals<br></p><p>Consider a piece of code which generates a small XML string:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + <br>          &quot;&lt;catalog&gt;\n&quot; + <br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; + <br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; + <br>          &quot; &lt;/book&gt;\n&quot; + <br>          &quot;&lt;/catalog&gt;&quot;<br>However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br></p><p>The example above generates XML, but there are many similar cases where a short fragment of text including newlines must be included in a string literal:<br></p><p>Generating HTML, a task which will hopefully become more common<br>Generating error messages and other user-facing text, in both graphical and command-line interfaces<br>Generating configuration files and other &quot;scripty&quot; tasks<br>Generating messages for other text-based protocols and formats<br>Generating Swift code (common to work around the current lack of metaprogramming features other than generics)<br>Generating code in general<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#proposed-solution&gt;Proposed solution<br></p><p>We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br></p><p>Our sample above could thus be written as:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;&quot;<br>If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#rationale&gt;Rationale<br></p><p>This design is rather unusual, and it&#39;s worth pausing for a moment to explain why it has been chosen.<br></p><p>The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br></p><p>We think continuation quotes offer several important advantages over the traditional design:<br></p><p>They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br></p><p>(This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br></p><p>Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br></p><p>Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed string literals that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br></p><p>Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br></p><p>They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics, either at compile time or through runtime string manipulation functions, to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br></p><p>Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br></p><p>They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br></p><p>Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br></p><p>Nevertheless, the traditional design does has a few advantages:<br></p><p>It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br></p><p>There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. These features could also address other issues like escaping. And many editors already support features which permit you to insert the same character at the same column in many adjacent lines—the exact task required to add continuation quotes.<br></p><p>Simple syntax highlighters may not support this syntax. This is true, but simple, generic syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working with some contents, we think the code formatting and visual recognition gains described above assist code reading more than the loss of finicky partial syntax highlighting compatibility hinders it.<br></p><p>It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. (Nor is this an English-only quirk; Spanish and French, the other two languages I checked, seem to have similar conventions.)<br></p><p>As an English Stack Exchange answer illustrates &lt;http://english.stackexchange.com/a/96613/64636&gt;:<br></p><p>“That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br></p><p>“Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br></p><p>“Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br></p><p>“Oh, that makes sense. Thanks!”<br>In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br></p><p>Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br></p><p>On balance, we think continuation quotes are the best design for this problem.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#detailed-design&gt;Detailed design<br></p><p>When Swift is parsing a string literal and reaches the end of a line without finding an end quote, it examines the next line, applying the following rules:<br></p><p>If the next line begins with a quote mark (skipping horizontal whitespace), then the string literal contains a newline followed by the contents of the string literal starting after the quote mark. (This line may itself have no end quote, in which case the same rules apply to the line which follows.)<br></p><p>If the next line begins with anything else, Swift raises a syntax error for an unterminated string literal. <br></p><p>Formally, the following grammar productions (from The Swift Programming Language):<br></p><p>static-string-literal       → &#39;&quot;&#39; quoted-text(opt) &#39;&quot;&#39;<br></p><p>interpolated-string-literal → &#39;&quot;&#39; interpolated-text(opt) &#39;&quot;&#39;<br>Become something like:<br></p><p>discarded-whitespace        → (zero or more horizontal whitespace characters)<br></p><p>static-string-literal       → &#39;&quot;&#39; quoted-text(opt) &#39;&quot;&#39;<br>                            | &#39;&quot;&#39; quoted-text(opt) \n discarded-whitespace static-string-literal<br></p><p>interpolated-string-literal → &#39;&quot;&#39; interpolated-text(opt) &#39;&quot;&#39;<br>                            | &#39;&quot;&#39; interpolated-text(opt) \n discarded-whitespace interpolated-string-literal<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#diagnostics&gt;Diagnostics<br></p><p>The exact error messages and diagnostics provided for unterminated quotes are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br></p><p>Insert &quot; at the end of the current line to terminate the quote.<br></p><p>Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#prototypes-and-samples&gt;Prototypes and samples<br></p><p>John Holdsworth&#39;s pull request &lt;https://github.com/apple/swift/pull/2275&gt; includes prototypes of several of the features we are planning, including this multiline string proposal. The pull request includes a link to a pre-built Swift toolchain containing the prototypes, which you can download and install to try these features for yourself.<br></p><p>The multiline strings prototype seems to indicate that the footprint of this feature will be very small. The changes for this proposal are confined entirely to the Lexer methods lexStringLiteral(), lexCharacter(), and getEncodedStringSegment(). (The string literal modifier feature impacts other parts of the lexer, but this proposal doesn&#39;t require those changes.) The prototype&#39;s diagnostics are primitive, and improving them would probably increase the impacted code, but it seems likely that the required changes will be very localized.<br></p><p>A very small ad-hoc set of tests for parts of the prototyped features is available in this gist &lt;https://gist.github.com/brentdax/be3c032bc7e0c101d7ba8b72cd1a692e#file-quotetest-swift-L91&gt;. It is more demo than comprehensive test suite, but it shows a couple of ways this proposal and the other proposed features might be used, together and separately.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#impact-on-existing-code&gt;Impact on existing code<br></p><p>Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br></p><p>We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br></p><p>We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents. Holdsworth&#39;s prototype includes this feature.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-string-literals-in-general&gt;Future directions for string literals in general<br></p><p>In the &quot;Motivation&quot; section, we identified four goals for improvements in Swift string literals:<br></p><p>Putting newlines in string literals.<br>Putting backslashes in string literals.<br>Putting quote marks in string literals.<br>Putting very large quantities of text (more than, say, twenty lines) in string literals.<br>This proposal addresses #1. Let&#39;s sketch some solutions for the other three, as well as related features we might enable along the way.<br></p><p>Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br></p><p>What is most important about these designs is how they all work together with each other, with the current proposal, and with existing Swift string literals. Rather than inventing a new kind of string literal for each feature, we want to, where possible, extend and reuse existing syntax features.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#a-general-mechanism-string-literal-modifiers&gt;A general mechanism: String literal modifiers<br></p><p>We may introduce the concept of string literal modifiers to alter the interpretation of string literals. These would become the basis for many future string literal features.<br></p><p>A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. <br></p><p>Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br></p><p>In one potential design, uppercase modifier characters enable a feature; lowercase characters disable a feature.<br></p><p>Our prototype also includes basic support for string modifiers, although the specific behavior of the modifiers in the prototype doesn&#39;t precisely match this sketch.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#goal-2-backslashes&gt;Goal 2: Backslashes<br></p><p>In the simplest version of this feature, we could add an e/E string literal modifier which enables all backslash-based escaping, including interpolation, double backslash, and backslash-quote. An e string would treat all backslashes literally, while an E string would treat all backslashes as escapes of some sort. E (the current behavior) would be the default. Thus, these would print:<br></p><p>print(e&quot;\\\&quot;)<br>    =&gt; \\\<br>print(e&quot;C:\Program Files\Microsoft Word&quot;)<br>    =&gt; C:\Program Files\Microsoft Word<br>print(e&quot;\w+&quot;)<br>    =&gt; \w+<br>print(e&quot;Interpolation looks like<br>        &quot;\(this)&quot;)<br>    =&gt; Interpolation looks like<br>    =&gt; \(this)<br>We might also allow you to enable or disable individual features. For instance, i might control interpolation, q might control quotes, and b might control other backslashes. Thus:<br></p><p>print(i&quot;Interpolation looks like \&quot;\(this)\&quot;&quot;)<br>    =&gt; Interpolation looks like &quot;\(this)&quot;<br>print(eI&quot;C:\Program Files\\(programName)&quot;)<br>    =&gt; C:\Program Files\Microsoft Word<br>print(b&quot;\w+\n&quot;)<br>    =&gt; \w+<br>    =&gt; <br>These could be proposed separately, with e coming in Swift 3 and more nuanced modifiers potentially waiting for Swift 4.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#goal-3-quote-marks&gt;Goal 3: Quote Marks<br></p><p>One possibility is to allow the user to put any number of _ characters—a valid identifier character with no uppercase equivalent—between the modifier (if any) and the opening quote. The parser would then look for a matching number of _characters after any closing quote, and if it did not find them, it would treat the &quot; as a character in the string literal. Thus:<br></p><p>print(_&quot;&lt;a href=&quot;\(url)&quot;&gt;&quot;_)<br>    =&gt; &lt;a href=&quot;http://www.swift.org/&quot;&gt;<br>print(e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_)<br>    =&gt; print(&quot;Hello, world!\n&quot;)<br>print(b_&quot;&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;&quot;_)<br>    =&gt; &quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;<br>Here are some other ways this feature could be implemented:<br></p><p>Use a different identifier-but-not-capitalizable modifier, like $&quot;foo&quot;$.<br>Use a different single-character ASCII delimiter, like &#39;foo&#39;.<br>Use a different multi-character delimiter, like &quot;&quot;&quot;foo&quot;&quot;&quot;.<br>Use a different Unicode delimiter, like smart quotes (“foo”) or French quotes («foo») or Japanese quotes (⸢foo⸥).<br>Permit arbitrary delimiters bounded by some specific, known character, like &#39;zyzyx&#39;foo&#39;zyzyx&#39;.<br> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#goal-4-very-large-quantities-of-text&gt;Goal 4: Very large quantities of text<br></p><p>As discussed in the &quot;Motivation&quot; section, when a string gets long enough, the most important feature of the quoting construct becomes fidelity to the text represented. When your string literal is 50 or 100 lines long, you don&#39;t want to mess around with prefixing lines with continuation quotes—you&#39;ve already disrupted the flow of your program far more than outdenting the literal would, you&#39;re not likely to miss the enormous delimiter the feature provides, and the size of the literal will be obviously more than &quot;a screenful&quot; (and more obvious because it&#39;s not indented properly). You just want something that makes it as easy as possible to get the text into your source without fuss.<br></p><p>(Note: To keep this brief, I&#39;ll be using examples which are shorter than you would normally use this feature with.)<br></p><p>There are two main options here, which might broadly be thought of as &quot;the Python way&quot; (which we will call verbatim strings) and &quot;the Perl way&quot; (heredocs).<br></p><p>Verbatim strings are, quite simply, string literals bounded by &quot;&quot;&quot;. Between the two pairs of &quot;&quot;&quot; delimiters, you may put any character, including newlines.<br></p><p>print(&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;&quot;&quot;&quot;)<br></p><p>print(&quot;&quot;&quot;It was a dark and <br>stormy \(timeOfDay) when &quot;&quot;&quot; + e&quot;&quot;&quot;the Swift core team invented <br>the \(interpolation) syntax.&quot;&quot;&quot;)<br>A variation on this would require the delimiters to be on separate lines from the string contents:<br></p><p>print(&quot;&quot;&quot;<br>&lt;?xml version=&quot;1.0&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;<br>&quot;&quot;&quot;)<br></p><p>print(&quot;&quot;&quot;<br>It was a dark and stormy <br>\(timeOfDay) when <br>&quot;&quot;&quot; + e&quot;&quot;&quot;<br>the Swift core team invented <br>the \(interpolation) syntax.<br>&quot;&quot;&quot;)<br>A very simple approach with generally similar features would be to introduce a modifier which disabled continuation quotes; in other words, it would turn this proposal&#39;s multiline strings into a more traditional version. If you needed an alternate delimiter, you could then use whatever alternate delimiter mechanism we introduce for normal string literals.<br></p><p>print(c_&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;&quot;_)<br></p><p>print(c&quot;It was a dark and stormy <br>\(timeOfDay) when &quot; + ec&quot;the Swift core team invented <br>the \(interpolation) syntax.&quot;)<br>Heredocs have you put a placeholder token in one line for a string literal whose contents begin on the next line. Traditionally, heredocs have allowed you to specify an arbitrary string as a delimiter, which must appear on its own line. The traditional syntax for heredocs would look something like:<br></p><p>print(&lt;&lt;&quot;END&quot;)<br>&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;<br>END<br></p><p>print(&lt;&lt;&quot;---&quot; + &lt;&lt;e&quot;END&quot;)<br>It was a dark and stormy <br>\(timeOfDay) when <br>---<br>the Swift core team invented <br>the \(interpolation) syntax.<br>END<br>A more Swift-style syntax might use a # function:<br></p><p>print(#to(&quot;END&quot;))<br>&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;<br>END<br></p><p>print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>It was a dark and stormy <br>\(timeOfDay) when <br>---<br>the Swift core team invented <br>the \(interpolation) syntax.<br>END<br>Or we might even borrow Python&#39;s &quot;&quot;&quot; delimiter, creating an unholy union of the two languages:<br></p><p>print(&quot;&quot;&quot;)<br>&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;<br>&quot;&quot;&quot;<br></p><p>print(&quot;&quot;&quot; + e&quot;&quot;&quot;)<br>It was a dark and stormy <br>\(timeOfDay) when <br>&quot;&quot;&quot;<br>the Swift core team invented <br>the \(interpolation) syntax.<br>&quot;&quot;&quot;<br>Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#other-potential-modifier-features&gt;Other potential modifier features<br></p><p>Whitespace normalization: Changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings and other spacing purely to improve code formatting.<br></p><p>alert.informativeText =<br>    W&quot;\(appName) could not typeset the element “\(title)” because <br>     &quot;it includes a link to an element that has been removed from this <br>     &quot;book.&quot;<br>Localization: Passes the string through Foundation&#39;s localization APIs; interpolations would be represented as format strings.<br></p><p>alert.informativeText =<br>    LW&quot;\(appName) could not typeset the element “\(title)” because <br>      &quot;it includes a link to an element that has been removed from this <br>      &quot;book.&quot;<br>Comments: Embedding comments in string literals which were not included in their contents might be useful for literals containing regular expressions or other code.<br></p><p>Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#a-note-on-regular-expressions&gt;A note on regular expressions<br></p><p>Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or ICU; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br></p><p>In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#dont-require-a-continuation-quote&gt;Don&#39;t require a continuation quote<br></p><p>The main alternative is to not require a continuation quote at the beginning of each subsequent line, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br></p><p>let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&lt;catalog&gt;<br>    &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>        &lt;author&gt;\(author)&lt;/author&gt;<br>    &lt;/book&gt;<br>&lt;/catalog&gt;&quot;<br>This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#use-verbatim-strings-or-heredocs-instead&gt;Use verbatim strings or heredocs instead<br></p><p>While these constructs have their place, a feature with lighter syntactic weight, better code formatting, and improved diagnostics is more appropriate for shorter multiline strings. See &quot;An aside: Small and large multiline strings&quot; above.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#introduce-verbatim-strings-or-heredocs-first-or-at-the-same-time&gt;Introduce verbatim strings or heredocs first, or at the same time<br></p><p>Verbatim strings could probably be implemented relatively easily, but heredocs are probably too complex for the Swift 3 timeframe. We don&#39;t want to choose between these two approaches merely on the basis that one can be implemented sooner.<br></p><p> &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#dont-require-the-end-quote&gt;Don&#39;t require the end quote<br></p><p>Since each line is marked with a continuation quote, in theory, the end quote is redundant; the string could simply end after the last line with a continuation quote.<br></p><p>// Something like:<br>let xml = M&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>           &quot;&lt;catalog&gt;<br>           &quot;    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>           &quot;        &lt;author&gt;\(author)&lt;/author&gt;<br>           &quot;    &lt;/book&gt;<br>           &quot;&lt;/catalog&gt;<br>Alternatively, the M modifier could be left out (which would require quotes on that line to be escaped), or a different character or character sequence could be used. There was a fair bit of bikeshedding on this; in some cases, a single post suggested several syntaxes with slightly different semantics (such as different escaping rules). Some marked the first and/or last line differently from the other lines. What they all have in common is that the beginning of each line is marked in some way, but the end is not, even at the end of the literal.<br></p><p>Because there is no end delimiter—only a start-of-line marker—these designs may not require you to escape quotes; thus, they could potentially obviate the need for an alternate delimiter feature as well. Depending on the design, however, many of them have issues:<br></p><p>In most designs, it is possible to create a single-line string with the feature, but the resulting code tends to be ugly and awkward.<br></p><p>If the last line is marked the same as the others and the user forgets the marker on a line, the compiler has no way to notice, except by diagnosing errors caused by treating a line of a string literal as code. Since some lines of string content will be valid code (such as blank lines or C-style comments), these mistakes may pass unnoticed.<br></p><p>If the last line is marked the same as the others, then commenting out a line of a string literal, inserting a blank line in the middle of a string literal, or just in general inserting some sort of valid Swift code in the middle of a string literal would break the literal in half, once again potentially forming syntactically valid but incorrect Swift code.<br></p><p>Generally, the more these constructs work to avoid the above problems, the uglier and less quote-like they end up looking, and the more complex they will be for the parser.<br></p><p>Finally, all approaches share one fundamental issue.<br></p><p>String literals are expressions, and so they ought to have a syntax which can be nested inside other expressions. Line-oriented features like these don&#39;t work well as expressions, because you normally place several expressions on a single line, nesting them inside one another. Thus, these features may be awkward to use in any but the simplest ways.<br> &lt;&gt; &lt;https://gist.github.com/brentdax&gt;<br>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/60f346a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  4, 2016 at 11:00:00pm</p></header><div class="content"><p>Comments inline.<br></p><p>&gt; On May 4, 2016, at 7:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics, either at compile time or through runtime string manipulation functions, to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt; <br>&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt; <br>&gt; <br>Although I agree that there can be problems with runtime manipulation, the Scala implementation of stripMargin does, in a way, solve the &quot;n delimiter” problem, by allowing you to specify which character should be used for the margin marker.  For example,<br></p><p>val s = &quot;&quot;&quot;<br>  |Line 1.<br>  |Line 2.<br>  |Line 3.&quot;&quot;&quot;.stripMargin<br></p><p>Source: http://alvinalexander.com/scala/scala-multiline-strings-heredoc-syntax<br></p><p>There are a few issues with this off the bat. First, if you are unfamiliar with stripMargin it’s not clear if the first line counts as a newline.<br></p><p>\n<br>Line 1.\n<br>Line 2.\n<br>Line 3.\n<br></p><p>vs<br></p><p>Line 1.\n<br>Line 2.\n<br>Line 3.\n<br></p><p>and what about:<br></p><p>val s = “&quot;&quot;<br>  |Line 1.<br></p><p>  |Line 2.<br>  |Line 3.&quot;&quot;”.stripMargin<br></p><p>or<br></p><p>val s = “”&quot;|<br>  |Line 1.<br>  |Line 2.<br>  |Line 3.&quot;&quot;”.stripMargin<br></p><p>or<br></p><p>val s = “”&quot;<br>  |Line 1.<br>  |Line 2.<br>  |Line 3.<br>  |&quot;&quot;”.stripMargin<br></p><p><br>Secondly, due to the start and end delimiters, it doesn’t play as nicely with indentation as a single column of quote characters. Furthermore, it requires a lot of massaging to get a pasted string to be correct especially because it’s difficult to have the editor auto-format since the delimiters are really just part of the string.<br></p><p>Plus this has the other issues that you mentioned in terms of syntax highlighting, errors, and finding delimiters. Still I think that it does solve some of the more major problems and it has the nice property of being extensible with a simple standard library change. I don’t think that these benefits outweigh these points and the points you brought up, but perhaps it should be included in alternatives considered with the reasons for and against? <br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#future-directions-for-multiline-string-literals&gt;Future directions for multiline string literals<br>&gt; <br>&gt; We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt; <br>&gt; We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents. Holdsworth&#39;s prototype includes this feature.<br>&gt; <br>&gt; <br>Alternately, you could just close the quote on that line, perhaps? As in the limerick below.<br></p><p>let limerick = &quot;Here’s a multiline literal string<br>               &quot;It’s a cool, kinda fun, sort of thing<br>               &quot;It&#39;s got newlines galore<br>               &quot;but not anymore &quot;<br>               &quot;&#39;cause I&#39;ve capped the above line with bling&quot;<br></p><p>This could be implemented by concatenating adjacent strings together automatically. However, I’m far from a compiler hacker, would an implementation like that be too complicated for the type checker?<br></p><p><br>&gt;  &lt;https://gist.github.com/brentdax/c580bae68990b160645c030b2d0d1a8f#a-general-mechanism-string-literal-modifiers&gt;A general mechanism: String literal modifiers<br>&gt; <br>&gt; We may introduce the concept of string literal modifiers to alter the interpretation of string literals. These would become the basis for many future string literal features.<br>&gt; <br>&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. <br>&gt; <br>&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt; <br>&gt; In one potential design, uppercase modifier characters enable a feature; lowercase characters disable a feature.<br>&gt; <br>&gt; Our prototype also includes basic support for string modifiers, although the specific behavior of the modifiers in the prototype doesn&#39;t precisely match this sketch.<br>&gt; <br>&gt; <br>I seems like it would be easy to mistake a modified multiline string literal from an unmodified literal since the modifier is only at the top. We could require the modifier on each line, which would allow more granular control, but would be more difficult to edit.<br></p><p>With regard to the rest of the proposal, it’s awesome! It’s really quite thorough in it’s consideration of the tradeoffs. I did not expect someone to actually start running with the idea, but you’ve really taken it really far!<br></p><p>Tyler<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/73aa218c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  5, 2016 at 09:00:00am</p></header><div class="content"><p>Rust and Scala support macros, C++ has templates, and even the venerable C has #defines. Introducing mera-programming is by no means easy as it generally equates introducing a second, more limited, language inside the original. There exists today an opportunity to take advantage of the string literal effort <br>* provide a minimalmultiline literal extension<br>* provide a general mechanism into the current parser for dealing with &quot;pockets&quot; of semantically tagged contents into the stream of implicitely swift-tagged characters<br></p><p>The latter could be used at a later date for<br>* custom colorization schemes <br>* custom validation<br></p><p>It is conceivable to reserve one of these semantic tags, say SWIFT_SIL for the introduction of SIL code in multiline litterals as a test of what macros in swift might be.<br></p><p>Done clealy, this scheme has the advantage of<br>* very minimal intrusion into the existing parser, reducing the risk of unwantes side effects<br>* very minimal level of commitment to featureset of string literals<br>* maximum open doors regarding what can be added via future via content tags (imagine using mime types as tags, while allowing the mirror API to query the tag value)<br>* a simple pathway for the introduction of macros, even supporting different types of macro types, none of which requiring changes to the parser once the proposed first step is in place<br></p><p>Regards<br>(From mobile)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/75860fda/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br></p><p>I just wanted to say that I have drafted a proposal that solves the issues that I have encountered. (It&#39;s here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016219.html )<br>- it allows pasting text as-is<br>- it allows creating string literals where leading space on each line is stripped (while keeping indentation differences intact)<br>- it allows creating string literals where leading space on each line is not stripped<br>- optionally it allows strings to be raw, without any string interpolation or escaping whatsoever<br>- in none of the literals you have to write &quot;&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;&quot;, you can just write &quot;&quot;&quot;&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;&quot;&quot;&quot;. This also lets you copy&amp;paste text out of the program source and back into a HTML file.<br></p><p>It had the idea that maybe the motivation behind continuation quotes is to make using multiline strings harder to use; in order to discourage their use at all. Two points to consider:<br>- people who don&#39;t want to use MSL will not, even if you throw Python-like &quot;&quot;&quot;multi-line strings&quot;&quot;&quot; at them.<br>- people who want to use them do it, even if there is no MSL available. I saw that in Objective-C, with multiple lines of HTML and CSS wrapped into a big multiline objc-string-literal and thrown at a WebView. I could send the literal to the console before sending it to the WebView and it was basically unreadable. I eventually refactored it to put the thing into a file (also because the HTML grew in space, and the inline-literal became impractical)<br>- my most important point: if someone uses multiple lines of HTML or CSS or XML directly within the code, I want it to look okay. I don&#39;t want an MSL feature that is so unwieldy that people voluntarily not use it; it would be better to have no MSL at all.<br></p><p>I don&#39;t think that multiline strings are a must-have feature for a language, because they are not used very often. (I included an example of a good use case in my proposal.) I acknowledge that in many programming cases it would be better to not put a huge pile of text directly into the source, but to load the text from a file at runtime. But even when these MSL are misused, I prefer to read a &quot;&quot;&quot;python multiline string&quot;&quot;&quot; over a &quot;concatenated\n&quot;+&quot;Java\n&quot;+&quot;String&quot;.<br></p><p>-Michael<br></p><p>&gt; Am 05.05.2016 um 04:57 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Brent, what is the state of the proposal document you prepared?<br>&gt; <br>&gt; The state is that there is now a third draft, pasted below.<br>&gt; <br>&gt; The main change in this version is that I&#39;ve included a *lot* of rationale around what I think needs to be done to strings overall. This kind of bloats the proposal, but I&#39;m not sure if there&#39;s a better way to make clear why it&#39;s tackling the problems it is.<br>&gt; <br>&gt; John: I have not moved your trailing backslash suggestion back into the proposal yet, simply because I haven&#39;t decided how to write it up yet. I probably will unless others strongly think it should be subsetted out.<br>&gt; <br>&gt; Dave: This obliquely addresses some of the points in your email, but I intend to reply more directly soon. Sorry, life has been happening to me during the last few days.<br>&gt; Multiline string literals<br>&gt; 	• Proposal: SE-NNNN<br>&gt; 	• Author(s): Brent Royal-Gordon, John Holdsworth, Tyler Cloutier<br>&gt; 	• Status: Third Draft<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; In Swift 2.2, the only means to insert a newline into a string literal is the \n escape. String literals specified in this way are generally ugly and unreadable. We propose a multiline string feature emphasizing code readability which is a straightforward extension of our existing string literals and appears to be exceptionally easy to implement.<br>&gt; <br>&gt; This proposal is the first step in a larger plan to improve how string literals address various challenging use cases. By itself, it is not meant to solve all problems with string escaping or the representation of long string literals. However, it is an important step in that direction, and it does modestly improve on the status quo even for those use cases which we intend to address more directly later.<br>&gt; <br>&gt; See the &quot;Motivation&quot; section for the overall goals of this project, and the &quot;Future directions for string literals in general&quot; section for a sketch of how we might achieve those goals.<br>&gt; <br>&gt; Swift-evolution threads: multi-line string literals. (April), multi-line string literals (December)<br>&gt; <br>&gt; Third draft notes<br>&gt; <br>&gt; 	• Expands the &quot;Motivation&quot; section to discuss the overall string improvement project, including a list of goals, and reworks the &quot;Future directions for string literals in general&quot; section to theme it around the new list of goals and to discuss the sketched designs and some alternatives in more detail.<br>&gt; <br>&gt; 	• Added a change to the formal grammar.<br>&gt; <br>&gt; 	• Added discussion of John Holdsworth&#39;s prototype and the implementation lessons from it.<br>&gt; <br>&gt; 	• Fills in co-authors. (I did the proposal drafting, John did the prototyping, and Tyler had the original idea and offered particularly detailed critiques.)<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift&#39;s string literals include the minimum viable feature set: they have quoting and escaping features sufficient to embed any Unicode string in a Swift source code file. They also support interpolation, a feature which makes constructing strings from dynamic data much easier. This is a great foundation for Swift string handling.<br>&gt; <br>&gt; However, as Swift begins to move into roles beyond native app development, code which needs to generate text becomes a more important use case. Whether you&#39;re emitting HTML or XML, writing configuration files, generating source code in Swift or another language, or just showing long textual messages to the user, you need string literals to be more than just &quot;minimum viable&quot;. We must move beyond that, making it easy and even pleasant to embed long, complex, and special-character-ridden strings into Swift code.<br>&gt; <br>&gt; There are four very important areas where we think string literals need to improve:<br>&gt; <br>&gt; 	• Putting newlines in string literals.<br>&gt; 	• Putting backslashes in string literals.<br>&gt; 	• Putting quote marks in string literals.<br>&gt; 	• Putting very large quantities of text (more than, say, twenty lines) in string literals.<br>&gt; Swift&#39;s design principles call for an incremental approach to design, so this proposal only considers the first of these four goals. We intend to address the others in separate but compatible future proposals, with the goal of fixing at least two in Swift 3 and all four by the time Swift 4 is released. A sketch of one possible design for these features is included in the &quot;Future directions for string literals in general&quot; section below.<br>&gt; <br>&gt; An aside: Small and large multiline strings<br>&gt; <br>&gt; The first entry in the list above, &quot;Putting newlines in string literals&quot;, might be thought of as a subset of the fourth, &quot;putting very large quantities of text in string literals&quot;. (In fact, all of the entries could perhaps be subsumed by the fourth.) However, we believe they are best addressed as separate goals, using separate features.<br>&gt; <br>&gt; When you are embedding enormous string literals in source code, you must put undistorted representation of the string above all other considerations. If the design which best permits the string to be written verbatim is ugly, bulky, unlike other language constructs, disruptive to code readability, error-prone, arbitrary, difficult to parse, or otherwise a wart on the language, that is simply the price we have to pay for that feature.<br>&gt; <br>&gt; But it&#39;s a different story for short multiline strings. When you are writing a little bit of text, but still more than one line, you don&#39;t want to disrupt your code&#39;s indentation, add whole lines just for delimiters, insert bizarre or cryptic tokens into your code, or create syntax errors which take ten minutes to trace back to their source. You want a different feature, with different tradeoffs.<br>&gt; <br>&gt; It is that feature which we propose.<br>&gt; <br>&gt; The goal: Newlines in string literals<br>&gt; <br>&gt; Consider a piece of code which generates a small XML string:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;catalog&gt;\n\t&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n\t\t&lt;author&gt;\(author)&lt;/author&gt;\n\t&lt;/book&gt;\n&lt;/catalog&gt;&quot;<br>&gt; The string is practically unreadable, its structure drowned in escapes and run-together lines; it looks like little more than line noise. We can improve its readability somewhat by concatenating separate strings for each line and using real tabs instead of \t escapes:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;&lt;catalog&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;     &lt;author&gt;\(author)&lt;/author&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot; &lt;/book&gt;\n&quot; +<br>&gt;  <br>&gt;           <br>&gt; &quot;&lt;/catalog&gt;&quot;<br>&gt; However, this creates a more complex expression for the type checker, and there&#39;s still far more punctuation than ought to be necessary. If the most important goal of Swift is making code readable, this kind of code falls far short of that goal.<br>&gt; <br>&gt; The example above generates XML, but there are many similar cases where a short fragment of text including newlines must be included in a string literal:<br>&gt; <br>&gt; 	• Generating HTML, a task which will hopefully become more common<br>&gt; 	• Generating error messages and other user-facing text, in both graphical and command-line interfaces<br>&gt; 	• Generating configuration files and other &quot;scripty&quot; tasks<br>&gt; 	• Generating messages for other text-based protocols and formats<br>&gt; 	• Generating Swift code (common to work around the current lack of metaprogramming features other than generics)<br>&gt; 	• Generating code in general<br>&gt; Proposed solution<br>&gt; <br>&gt; We propose that, when Swift is parsing a string literal, if it reaches the end of the line without encountering an end quote, it should look at the next line. If it sees a quote at the beginning (a &quot;continuation quote&quot;), the string literal contains a newline and then continues on that line. Otherwise, the string literal is unterminated and syntactically invalid.<br>&gt; <br>&gt; Our sample above could thus be written as:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;           &quot;&lt;catalog&gt;<br>&gt;           &quot; &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;           &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;           &quot; &lt;/book&gt;<br>&gt;           &quot;&lt;/catalog&gt;&quot;<br>&gt; <br>&gt; If the second or subsequent lines had not begun with a quotation mark, or the trailing quotation mark after the &lt;/catalog&gt;tag had not been included, Swift would have emitted an error.<br>&gt; <br>&gt; Rationale<br>&gt; <br>&gt; This design is rather unusual, and it&#39;s worth pausing for a moment to explain why it has been chosen.<br>&gt; <br>&gt; The traditional design for this feature, seen in languages like Perl and Python, simply places one delimiter at the beginning of the literal and another at the end. Individual lines in the literal are not marked in any way. <br>&gt; <br>&gt; We think continuation quotes offer several important advantages over the traditional design:<br>&gt; <br>&gt; 	• They help the compiler pinpoint errors in string literal delimiting. Traditional multiline strings have a serious weakness: if you forget the closing quote, the compiler has no idea where you wanted the literal to end. It simply continues on until the compiler encounters another quote (or the end of the file). If you&#39;re lucky, the text after that quote is not valid code, and the resulting error will at least point you to the next string literal in the file. If you&#39;re unlucky, you&#39;ll get a seemingly unrelated error several literals later, an unbalanced brace error at the end of the file, or perhaps even code that compiles but does something totally wrong.<br>&gt; <br>&gt; (This is not a minor concern. Many popular languages, including C and Swift 2, specifically reject newlines in string literals to prevent this from happening.)<br>&gt; <br>&gt; Continuation quotes provide the compiler with redundant information about your intent. If you forget a closing quote, the continuation quotes give the compiler a very good idea of where you meant to put it. The compiler can point you to (or at least very near) the end of the literal, where you want to insert the quote, rather than showing you the beginning of the literal or even some unrelated error later in the file that was caused by the missing quote.<br>&gt; <br>&gt; 	• Temporarily unclosed literals don&#39;t make editors go haywire. The syntax highlighter has the same trouble parsing half-written, unclosed string literals that the compiler does: It can&#39;t tell where the literal is supposed to end and the code should begin. It must either apply heuristics to try to guess where the literal ends, or incorrectly color everything between the opening quote and the next closing quote as a string literal. This can cause the file&#39;s coloring to alternate distractingly between &quot;string literal&quot; and &quot;running code&quot;.<br>&gt; <br>&gt; Continuation quotes give the syntax highlighter enough context to guess at the correct coloration, even when the string isn&#39;t complete yet. Lines with a continuation quote are literals; lines without are code. At worst, the syntax highlighter might incorrectly color a few characters at the end of a line, rather than the remainder of the file.<br>&gt; <br>&gt; 	• They separate indentation from the string&#39;s contents. Traditional multiline strings usually include all of the content between the start and end delimiters, including leading whitespace. This means that it&#39;s usually impossible to indent a multiline string, so including one breaks up the flow of the surrounding code, making it less readable. Some languages apply heuristics, either at compile time or through runtime string manipulation functions, to try to remove indentation, but like all heuristics, these are mistake-prone and murky.<br>&gt; <br>&gt; Continuation quotes neatly avoid this problem. Whitespace before the continuation quote is indentation used to format the source code; whitespace after the continuation quote is part of the string literal. The interpretation of the code is perfectly clear to both compiler and programmer.<br>&gt; <br>&gt; 	• They improve the ability to quickly recognize the literal. Traditional multiline strings don&#39;t provide much visual help. To find the end, you must visually scan until you find the matching delimiter, which may be only one or a few characters long. When looking at a random line of source, it can be hard to tell at a glance whether it&#39;s code or literal. Syntax highlighting can help with these issues, but it&#39;s often unreliable, especially with advanced, idiosyncratic string literal features like multiline strings.<br>&gt; <br>&gt; Continuation quotes solve these problems. To find the end of the literal, just scan down the column of continuation characters until they end. To figure out if a given line of source is part of a literal, just see if it starts with a quote mark. The meaning of the source becomes obvious at a glance.<br>&gt; <br>&gt; Nevertheless, the traditional design does has a few advantages:<br>&gt; <br>&gt; 	• It is simpler. Although continuation quotes are more complex, we believe that the advantages listed above pay for that complexity.<br>&gt; <br>&gt; 	• There is no need to edit the intervening lines to add continuation quotes. While the additional effort required to insert continuation quotes is an important downside, we believe that tool support, including both compiler fix-its and perhaps editor support for commands like &quot;Paste as String Literal&quot;, can address this issue. These features could also address other issues like escaping. And many editors already support features which permit you to insert the same character at the same column in many adjacent lines—the exact task required to add continuation quotes.<br>&gt; <br>&gt; 	• Simple syntax highlighters may not support this syntax. This is true, but simple, generic syntax highlighters generally have terrible trouble with advanced string literal constructs; some struggle with even basic ones. While there are some designs (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax highlighters into working with some contents, we think the code formatting and visual recognition gains described above assist code reading more than the loss of finicky partial syntax highlighting compatibility hinders it.<br>&gt; <br>&gt; 	• It looks funny—quotes should always be in matched pairs. We aren&#39;t aware of another programming language which uses unbalanced quotes in string literals, but there is one very important precedent for this kind of formatting: natural languages. English, for instance, uses a very similar format for quoting multiple lines of dialog by the same speaker. (Nor is this an English-only quirk; Spanish and French, the other two languages I checked, seem to have similar conventions.)<br>&gt; <br>&gt; As an English Stack Exchange answer illustrates:<br>&gt; <br>&gt; “That seems like an odd way to use punctuation,” Tom said. “What harm would there be in using quotation marks at the end of every paragraph?”<br>&gt; <br>&gt; “Oh, that’s not all that complicated,” J.R. answered. “If you closed quotes at the end of every paragraph, then you would need to reidentify the speaker with every subsequent paragraph.<br>&gt; <br>&gt; “Say a narrative was describing two or three people engaged in a lengthy conversation. If you closed the quotation marks in the previous paragraph, then a reader wouldn’t be able to easily tell if the previous speaker was extending his point, or if someone else in the room had picked up the conversation. By leaving the previous paragraph’s quote unclosed, the reader knows that the previous speaker is still the one talking.”<br>&gt; <br>&gt; “Oh, that makes sense. Thanks!”<br>&gt; In English, omitting the ending quotation mark tells the text&#39;s reader that the quote continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader that they&#39;re in the middle of a quote.<br>&gt; <br>&gt; Similarly, in this proposal, omitting the ending quotation mark tells the code&#39;s reader (and compiler) that the string literal continues on the next line, while including a quotation mark at the beginning of the next line reminds the reader (and compiler) that they&#39;re in the middle of a string literal.<br>&gt; <br>&gt; On balance, we think continuation quotes are the best design for this problem.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; When Swift is parsing a string literal and reaches the end of a line without finding an end quote, it examines the next line, applying the following rules:<br>&gt; <br>&gt; 	• If the next line begins with a quote mark (skipping horizontal whitespace), then the string literal contains a newline followed by the contents of the string literal starting after the quote mark. (This line may itself have no end quote, in which case the same rules apply to the line which follows.)<br>&gt; <br>&gt; 	• If the next line begins with anything else, Swift raises a syntax error for an unterminated string literal. <br>&gt; <br>&gt; Formally, the following grammar productions (from The Swift Programming Language):<br>&gt; <br>&gt; static-string-literal       → &#39;&quot;&#39; quoted-text(opt) &#39;&quot;&#39;<br>&gt; <br>&gt; interpolated-string-literal → &#39;&quot;&#39; interpolated-text(opt) &#39;&quot;&#39;<br>&gt; <br>&gt; Become something like:<br>&gt; <br>&gt; discarded-whitespace        → (zero or more horizontal whitespace characters)<br>&gt; <br>&gt; static-string-literal       → &#39;&quot;&#39; quoted-text(opt) &#39;&quot;&#39;<br>&gt;                             | &#39;&quot;&#39; quoted-text(opt) \n discarded-whitespace static-string-literal<br>&gt; <br>&gt; interpolated-string-literal → &#39;&quot;&#39; interpolated-text(opt) &#39;&quot;&#39;<br>&gt;                             | &#39;&quot;&#39; interpolated-text(opt) \n discarded-whitespace interpolated-string-literal<br>&gt; <br>&gt; Diagnostics<br>&gt; <br>&gt; The exact error messages and diagnostics provided for unterminated quotes are left to the implementers to determine, but we believe it should be possible to provide two fix-its which will help users learn the syntax and correct string literal mistakes:<br>&gt; <br>&gt; 	• Insert &quot; at the end of the current line to terminate the quote.<br>&gt; <br>&gt; 	• Insert &quot; at the beginning of the next line (with some indentation heuristics) to continue the quote on the next line.<br>&gt; <br>&gt; Prototypes and samples<br>&gt; <br>&gt; John Holdsworth&#39;s pull request includes prototypes of several of the features we are planning, including this multiline string proposal. The pull request includes a link to a pre-built Swift toolchain containing the prototypes, which you can download and install to try these features for yourself.<br>&gt; <br>&gt; The multiline strings prototype seems to indicate that the footprint of this feature will be very small. The changes for this proposal are confined entirely to the Lexer methods lexStringLiteral(), lexCharacter(), and getEncodedStringSegment(). (The string literal modifier feature impacts other parts of the lexer, but this proposal doesn&#39;t require those changes.) The prototype&#39;s diagnostics are primitive, and improving them would probably increase the impacted code, but it seems likely that the required changes will be very localized.<br>&gt; <br>&gt; A very small ad-hoc set of tests for parts of the prototyped features is available in this gist. It is more demo than comprehensive test suite, but it shows a couple of ways this proposal and the other proposed features might be used, together and separately.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; Failing to close a string literal before the end of the line is currently a syntax error, so no valid Swift code should be affected by this change.<br>&gt; <br>&gt; Future directions for multiline string literals<br>&gt; <br>&gt; 	• We could permit comments before encountering a continuation quote to be counted as whitespace, and permit empty lines in the middle of string literals. This would allow you to comment out whole lines in the literal.<br>&gt; <br>&gt; 	• We could allow you to put a trailing backslash on a line to indicate that the newline isn&#39;t &quot;real&quot; and should be omitted from the literal&#39;s contents. Holdsworth&#39;s prototype includes this feature.<br>&gt; <br>&gt; Future directions for string literals in general<br>&gt; <br>&gt; In the &quot;Motivation&quot; section, we identified four goals for improvements in Swift string literals:<br>&gt; <br>&gt; 	• Putting newlines in string literals.<br>&gt; 	• Putting backslashes in string literals.<br>&gt; 	• Putting quote marks in string literals.<br>&gt; 	• Putting very large quantities of text (more than, say, twenty lines) in string literals.<br>&gt; This proposal addresses #1. Let&#39;s sketch some solutions for the other three, as well as related features we might enable along the way.<br>&gt; <br>&gt; Please note that these are simply sketches of hypothetical future designs; they may radically change before proposal, and some may never be proposed at all. Many, perhaps most, will not be proposed for Swift 3. We are sketching these designs not to propose and refine these features immediately, but merely to show how we think they might be solved in ways which complement this proposal.<br>&gt; <br>&gt; What is most important about these designs is how they all work together with each other, with the current proposal, and with existing Swift string literals. Rather than inventing a new kind of string literal for each feature, we want to, where possible, extend and reuse existing syntax features.<br>&gt; <br>&gt; A general mechanism: String literal modifiers<br>&gt; <br>&gt; We may introduce the concept of string literal modifiers to alter the interpretation of string literals. These would become the basis for many future string literal features.<br>&gt; <br>&gt; A string literal modifier is a cluster of identifier characters which goes before a string literal and adjusts the way it is parsed. Modifers only alter the interpretation of the text in the literal, not the type of data it produces; for instance, there will never be something like the UTF-8/UTF-16/UTF-32 literal modifiers in C++. <br>&gt; <br>&gt; Modifiers can be attached to both single-line and multiline literals, and could also be attached to other literal syntaxes which might be introduced in the future. When used with multiline strings, only the starting quote needs to carry the modifiers, not the continuation quotes.<br>&gt; <br>&gt; In one potential design, uppercase modifier characters enable a feature; lowercase characters disable a feature.<br>&gt; <br>&gt; Our prototype also includes basic support for string modifiers, although the specific behavior of the modifiers in the prototype doesn&#39;t precisely match this sketch.<br>&gt; <br>&gt; Goal 2: Backslashes<br>&gt; <br>&gt; In the simplest version of this feature, we could add an e/E string literal modifier which enables all backslash-based escaping, including interpolation, double backslash, and backslash-quote. An e string would treat all backslashes literally, while an E string would treat all backslashes as escapes of some sort. E (the current behavior) would be the default. Thus, these would print:<br>&gt; <br>&gt; print(e&quot;\\\&quot;)<br>&gt;     =&gt; \\\<br>&gt; print(e&quot;C:\Program Files\Microsoft Word&quot;)<br>&gt;     =&gt; C:\Program Files\Microsoft Word<br>&gt; print(e&quot;\w+&quot;)<br>&gt;     =&gt; \w+<br>&gt; print(e&quot;<br>&gt; Interpolation looks like<br>&gt;         <br>&gt; &quot;\(this)&quot;<br>&gt; )<br>&gt;     <br>&gt; =&gt;<br>&gt;  Interpolation looks like<br>&gt;     <br>&gt; =&gt; \(this)<br>&gt; We might also allow you to enable or disable individual features. For instance, i might control interpolation, q might control quotes, and b might control other backslashes. Thus:<br>&gt; <br>&gt; print(i&quot;Interpolation looks like \&quot;\(this)\&quot;&quot;<br>&gt; )<br>&gt;     <br>&gt; =&gt; Interpolation looks like &quot;\(this)&quot;<br>&gt; print(eI&quot;C:\Program Files\\(programName)&quot;<br>&gt; )<br>&gt;     <br>&gt; =&gt; C:\Program Files\Microsoft Word<br>&gt; print(b&quot;\w+\n&quot;<br>&gt; )<br>&gt;     <br>&gt; =&gt; \w+<br>&gt; <br>&gt;     <br>&gt; =&gt; <br>&gt; These could be proposed separately, with e coming in Swift 3 and more nuanced modifiers potentially waiting for Swift 4.<br>&gt; <br>&gt; Goal 3: Quote Marks<br>&gt; <br>&gt; One possibility is to allow the user to put any number of _ characters—a valid identifier character with no uppercase equivalent—between the modifier (if any) and the opening quote. The parser would then look for a matching number of _characters after any closing quote, and if it did not find them, it would treat the &quot; as a character in the string literal. Thus:<br>&gt; <br>&gt; print(_&quot;&lt;a href=&quot;\(url)&quot;&gt;&quot;<br>&gt; _)<br>&gt;     <br>&gt; =&gt; &lt;a href=&quot;http://www.swift.org/&quot;&gt;<br>&gt; print(e_&quot;print(&quot;Hello, world!\n&quot;)&quot;<br>&gt; _)<br>&gt;     <br>&gt; =&gt; print(&quot;Hello, world!\n&quot;<br>&gt; )<br>&gt; <br>&gt; print(b_&quot;&quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;&quot;<br>&gt; _)<br>&gt;     <br>&gt; =&gt; &quot;[^&quot;\\]*(\\.[^&quot;\\]*)*+&quot;<br>&gt; Here are some other ways this feature could be implemented:<br>&gt; <br>&gt; 	• Use a different identifier-but-not-capitalizable modifier, like $&quot;foo&quot;$.<br>&gt; 	• Use a different single-character ASCII delimiter, like &#39;foo&#39;.<br>&gt; 	• Use a different multi-character delimiter, like &quot;&quot;&quot;foo&quot;&quot;&quot;.<br>&gt; 	• Use a different Unicode delimiter, like smart quotes (“foo”) or French quotes («foo») or Japanese quotes (⸢foo⸥).<br>&gt; 	• Permit arbitrary delimiters bounded by some specific, known character, like &#39;zyzyx&#39;foo&#39;zyzyx&#39;.<br>&gt; Goal 4: Very large quantities of text<br>&gt; <br>&gt; As discussed in the &quot;Motivation&quot; section, when a string gets long enough, the most important feature of the quoting construct becomes fidelity to the text represented. When your string literal is 50 or 100 lines long, you don&#39;t want to mess around with prefixing lines with continuation quotes—you&#39;ve already disrupted the flow of your program far more than outdenting the literal would, you&#39;re not likely to miss the enormous delimiter the feature provides, and the size of the literal will be obviously more than &quot;a screenful&quot; (and more obvious because it&#39;s not indented properly). You just want something that makes it as easy as possible to get the text into your source without fuss.<br>&gt; <br>&gt; (Note: To keep this brief, I&#39;ll be using examples which are shorter than you would normally use this feature with.)<br>&gt; <br>&gt; There are two main options here, which might broadly be thought of as &quot;the Python way&quot; (which we will call verbatim strings) and &quot;the Perl way&quot; (heredocs).<br>&gt; <br>&gt; Verbatim strings are, quite simply, string literals bounded by &quot;&quot;&quot;. Between the two pairs of &quot;&quot;&quot; delimiters, you may put any character, including newlines.<br>&gt; <br>&gt; print(&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;&quot;&quot;<br>&gt; )<br>&gt; <br>&gt; <br>&gt; print(&quot;&quot;&quot;It was a dark and <br>&gt; stormy \(timeOfDay) when &quot;&quot;&quot; + e&quot;&quot;&quot;the Swift core team invented <br>&gt; the \(interpolation) syntax.&quot;&quot;&quot;)<br>&gt; A variation on this would require the delimiters to be on separate lines from the string contents:<br>&gt; <br>&gt; print(&quot;&quot;&quot;<br>&gt; &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; &quot;&quot;&quot;<br>&gt; )<br>&gt; <br>&gt; <br>&gt; print(&quot;&quot;&quot;<br>&gt; It was a dark and stormy <br>&gt; \(timeOfDay) when <br>&gt; &quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; the Swift core team invented <br>&gt; the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;)<br>&gt; A very simple approach with generally similar features would be to introduce a modifier which disabled continuation quotes; in other words, it would turn this proposal&#39;s multiline strings into a more traditional version. If you needed an alternate delimiter, you could then use whatever alternate delimiter mechanism we introduce for normal string literals.<br>&gt; <br>&gt; print(c_&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; _)<br>&gt; <br>&gt; <br>&gt; print(c&quot;It was a dark and stormy <br>&gt; \(timeOfDay) when &quot; + ec&quot;the Swift core team invented <br>&gt; the \(interpolation) syntax.&quot;)<br>&gt; Heredocs have you put a placeholder token in one line for a string literal whose contents begin on the next line. Traditionally, heredocs have allowed you to specify an arbitrary string as a delimiter, which must appear on its own line. The traditional syntax for heredocs would look something like:<br>&gt; <br>&gt; print(&lt;&lt;&quot;END&quot;<br>&gt; )<br>&gt; <br>&gt; &lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; END<br>&gt; <br>&gt; print(&lt;&lt;&quot;---&quot; + &lt;&lt;e&quot;END&quot;)<br>&gt; It was a dark and stormy <br>&gt; \(timeOfDay) when <br>&gt; ---<br>&gt; the Swift core team invented <br>&gt; the \(interpolation) syntax.<br>&gt; END<br>&gt; A more Swift-style syntax might use a # function:<br>&gt; <br>&gt; print(#to(&quot;END&quot;<br>&gt; ))<br>&gt; <br>&gt; &lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; END<br>&gt; <br>&gt; print(#to(&quot;---&quot;) + e#to(&quot;END&quot;))<br>&gt; It was a dark and stormy <br>&gt; \(timeOfDay) when <br>&gt; ---<br>&gt; the Swift core team invented <br>&gt; the \(interpolation) syntax.<br>&gt; END<br>&gt; Or we might even borrow Python&#39;s &quot;&quot;&quot; delimiter, creating an unholy union of the two languages:<br>&gt; <br>&gt; print(&quot;&quot;&quot;)<br>&gt; &lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;<br>&gt; &quot;&quot;&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; print(&quot;&quot;&quot; + e&quot;&quot;&quot;<br>&gt; )<br>&gt; It was a dark and stormy <br>&gt; \(timeOfDay) when <br>&gt; <br>&gt; &quot;&quot;&quot;<br>&gt; the Swift core team invented <br>&gt; the \(interpolation) syntax.<br>&gt; &quot;&quot;&quot;<br>&gt; Although heredocs could make a good addition to Swift eventually, there are good reasons to defer them for now. Please see the &quot;Alternatives considered&quot; section for details.<br>&gt; <br>&gt; Other potential modifier features<br>&gt; <br>&gt; 	• Whitespace normalization: Changes all runs of whitespace in the literal to single space characters; this would allow you to use multiline strings and other spacing purely to improve code formatting.<br>&gt; <br>&gt; alert.informativeText =<br>&gt;     W&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;      &quot;it includes a link to an element that has been removed from this <br>&gt;      &quot;book.&quot;<br>&gt; <br>&gt; 	• Localization: Passes the string through Foundation&#39;s localization APIs; interpolations would be represented as format strings.<br>&gt; <br>&gt; alert.informativeText =<br>&gt;     LW&quot;\(appName) could not typeset the element “\(title)” because <br>&gt;       &quot;it includes a link to an element that has been removed from this <br>&gt;       &quot;book.&quot;<br>&gt; <br>&gt; 	• Comments: Embedding comments in string literals which were not included in their contents might be useful for literals containing regular expressions or other code.<br>&gt; <br>&gt; Eventually, user-specified string modifiers could be added to Swift, perhaps as part of a hygienic macro system. It might also become possible to change the default modifiers applied to literals in a particular file or scope.<br>&gt; <br>&gt; A note on regular expressions<br>&gt; <br>&gt; Members of the core team are interested in regular expressions, but they don&#39;t want to just build a literal that wraps PCRE or ICU; rather, they aim to integrate regexes into the pattern matching system and give them a deep, Perl 6-style rethink. This would be a major effort, far beyond the scope of Swift 3.<br>&gt; <br>&gt; In the meantime, the e modifier and perhaps other string literal modifiers will make it easier to specify regular expressions in string literals for use with NSRegularExpression and other libraries accessible from Swift.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Don&#39;t require a continuation quote<br>&gt; <br>&gt; The main alternative is to not require a continuation quote at the beginning of each subsequent line, and simply extend the string literal from the starting quote to the ending quote, including all newlines between them. For example:<br>&gt; <br>&gt; let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt; &lt;catalog&gt;<br>&gt;     &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;         &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;     &lt;/book&gt;<br>&gt; &lt;/catalog&gt;&quot;<br>&gt; This alternative is extensively discussed in the &quot;Rationale&quot; section above.<br>&gt; <br>&gt; Use verbatim strings or heredocs instead<br>&gt; <br>&gt; While these constructs have their place, a feature with lighter syntactic weight, better code formatting, and improved diagnostics is more appropriate for shorter multiline strings. See &quot;An aside: Small and large multiline strings&quot; above.<br>&gt; <br>&gt; Introduce verbatim strings or heredocs first, or at the same time<br>&gt; <br>&gt; Verbatim strings could probably be implemented relatively easily, but heredocs are probably too complex for the Swift 3 timeframe. We don&#39;t want to choose between these two approaches merely on the basis that one can be implemented sooner.<br>&gt; <br>&gt; Don&#39;t require the end quote<br>&gt; <br>&gt; Since each line is marked with a continuation quote, in theory, the end quote is redundant; the string could simply end after the last line with a continuation quote.<br>&gt; <br>&gt; // Something like:<br>&gt; let xml = M&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;            &quot;&lt;catalog&gt;<br>&gt;            &quot;    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;            &quot;        &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;            &quot;    &lt;/book&gt;<br>&gt;            &quot;&lt;/catalog&gt;<br>&gt; <br>&gt; Alternatively, the M modifier could be left out (which would require quotes on that line to be escaped), or a different character or character sequence could be used. There was a fair bit of bikeshedding on this; in some cases, a single post suggested several syntaxes with slightly different semantics (such as different escaping rules). Some marked the first and/or last line differently from the other lines. What they all have in common is that the beginning of each line is marked in some way, but the end is not, even at the end of the literal.<br>&gt; <br>&gt; Because there is no end delimiter—only a start-of-line marker—these designs may not require you to escape quotes; thus, they could potentially obviate the need for an alternate delimiter feature as well. Depending on the design, however, many of them have issues:<br>&gt; <br>&gt; 	• In most designs, it is possible to create a single-line string with the feature, but the resulting code tends to be ugly and awkward.<br>&gt; <br>&gt; 	• If the last line is marked the same as the others and the user forgets the marker on a line, the compiler has no way to notice, except by diagnosing errors caused by treating a line of a string literal as code. Since some lines of string content will be valid code (such as blank lines or C-style comments), these mistakes may pass unnoticed.<br>&gt; <br>&gt; 	• If the last line is marked the same as the others, then commenting out a line of a string literal, inserting a blank line in the middle of a string literal, or just in general inserting some sort of valid Swift code in the middle of a string literal would break the literal in half, once again potentially forming syntactically valid but incorrect Swift code.<br>&gt; <br>&gt; 	• Generally, the more these constructs work to avoid the above problems, the uglier and less quote-like they end up looking, and the more complex they will be for the parser.<br>&gt; <br>&gt; Finally, all approaches share one fundamental issue.<br>&gt; <br>&gt; String literals are expressions, and so they ought to have a syntax which can be nested inside other expressions. Line-oriented features like these don&#39;t work well as expressions, because you normally place several expressions on a single line, nesting them inside one another. Thus, these features may be awkward to use in any but the simplest ways.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>multi-line string literals.</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br></p><p>I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br></p><p>I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/bba8924a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May  5, 2016 at 03:00:00pm</p></header><div class="content"><p>I like the continuation quote. It makes the code stay pretty. It doesn&#39;t break the indentation of your code. If you take out the continuation quote then things look out of place, as if someone pasted text in the middle of your code by mistake. I don&#39;t like the heredoc notation either for the same reasons.<br></p><p>I envision being able to type the opening multi line quote, i.e. M&quot; and then pasting multi line text from the clipboard. The editor would do a smart paste prepending the lines of text with the continuation character.  <br></p><p>Let&#39;s keep our code looking  pretty and focus on the main things:<br></p><p>1. Allow interpolation <br>2. Remove the need to add the \n character for each line<br>3. Remove the need to escape the double quote and apostrophe<br>4. Keep it simple<br></p><p>I would be fine just with this:<br></p><p>let xml = M&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>           &quot;&lt;catalog&gt;<br>           &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>           &quot;   &lt;author&gt;\(author)&lt;/author&gt;<br>           &quot; &lt;/book&gt;<br>           &quot;&lt;/catalog&gt;<br></p><p><br></p><p>&gt; On May 5, 2016, at 9:17 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt; <br>&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt; <br>&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/c8ddc19f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I like the continuation quote. It makes the code stay pretty. It doesn&#39;t break the indentation of your code. If you take out the continuation quote then things look out of place, as if someone pasted text in the middle of your code by mistake. I don&#39;t like the heredoc notation either for the same reasons.<br></p><p>I envision being able to type the opening multi line quote, i.e. M&quot; and then pasting multi line text from the clipboard. The editor would do a smart paste prepending the lines of text with the continuation character.  <br></p><p>Let&#39;s keep our code looking  pretty and focus on the main things:<br></p><p>1. Allow interpolation <br>2. Remove the need to add the \n character for each line<br>3. Remove the need to escape the double quote and apostrophe<br>4. Keep it simple<br></p><p>I would be fine just with this:<br></p><p>let xml = M&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>          &quot;&lt;catalog&gt;<br>          &quot; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>          &quot;     &lt;author&gt;\(author)&lt;/author&gt;<br>          &quot; &lt;/book&gt;<br>          &quot;&lt;/catalog&gt;<br></p><p><br></p><p>&gt; On May 5, 2016, at 9:17 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt; <br>&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt; <br>&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/472f815a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt; <br>&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt; <br>&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br></p><p><br>Adapting the original proposal if you’re not a fan of continuation quotes..<br></p><p>It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>As suggested earlier in this thread the lexer can strip the margin on the basis of<br>the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>but might as well be the default TBH.) Would this be the best of both worlds?<br></p><p>        assert( xml == i&quot;&quot;&quot;<br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;” )<br></p><p>Other modifiers can also be applied such as “no-escapes&quot;<br></p><p>        assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;&quot; )<br></p><p>I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br></p><p>Or you could support both continuation and indented python style:<br>http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz&gt;<br></p><p>John<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/b70f0ed9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 5:08 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt; <br>&gt;&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt;&gt; <br>&gt;&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt; <br>&gt; <br>&gt; Adapting the original proposal if you’re not a fan of continuation quotes..<br>&gt; <br>&gt; It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>&gt; As suggested earlier in this thread the lexer can strip the margin on the basis of<br>&gt; the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>&gt; but might as well be the default TBH.) Would this be the best of both worlds?<br>&gt; <br>&gt;         assert( xml == i&quot;&quot;&quot;<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;” )<br>&gt; <br>&gt; Other modifiers can also be applied such as “no-escapes&quot;<br>&gt; <br>&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br>&gt; <br>&gt; I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br>&gt; <br>&gt; Or you could support both continuation and indented python style:<br>&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz&gt;<br>&gt; <br>&gt; John<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I’m of the opinion that either of these are reasonable solutions, and both offer different tradeoffs. I’m probably partial to the continuation quotes, because I don’t want to be guessing about what is going to end up being in my string and what won’t.  <br></p><p>&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;” )<br></p><p>For example, is there a new line after &lt;/catalog&gt;?<br>How would the indenting work if it were immediately followed by triple quotes: &lt;/catalog&gt;”””<br>I would really like the first line to be lined up with the rest of the xml. Is that going to introduce a newline into the top of the string?<br></p><p>Could we just enforce that no characters on the lines of the triple quotes would be included in the string, very much like the heredoc syntax?<br></p><p>        assert( xml != ei&quot;”” The text I’m typing here would cause a compiler error.<br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>same here   &quot;&quot;” )<br></p><p>Then it’s very clear what the whitespace stripping will do. But what about mixed tab vs whitespace? What is the behavior in that case?<br></p><p>Tyler<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/b6414de4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 6:27 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 5, 2016, at 5:08 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Adapting the original proposal if you’re not a fan of continuation quotes..<br>&gt;&gt; <br>&gt;&gt; It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>&gt;&gt; As suggested earlier in this thread the lexer can strip the margin on the basis of<br>&gt;&gt; the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>&gt;&gt; but might as well be the default TBH.) Would this be the best of both worlds?<br>&gt;&gt; <br>&gt;&gt;         assert( xml == i&quot;&quot;&quot;<br>&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;” )<br>&gt;&gt; <br>&gt;&gt; Other modifiers can also be applied such as “no-escapes&quot;<br>&gt;&gt; <br>&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;&quot; )<br>&gt;&gt; <br>&gt;&gt; I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br>&gt;&gt; <br>&gt;&gt; Or you could support both continuation and indented python style:<br>&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz&gt;<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I’m of the opinion that either of these are reasonable solutions, and both offer different tradeoffs. I’m probably partial to the continuation quotes, because I don’t want to be guessing about what is going to end up being in my string and what won’t.  <br>&gt; <br>&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;” )<br>&gt; <br>&gt; For example, is there a new line after &lt;/catalog&gt;?<br>&gt; How would the indenting work if it were immediately followed by triple quotes: &lt;/catalog&gt;”””<br>&gt; I would really like the first line to be lined up with the rest of the xml. Is that going to introduce a newline into the top of the string?<br>&gt; <br>&gt; Could we just enforce that no characters on the lines of the triple quotes would be included in the string, very much like the heredoc syntax?<br>&gt; <br>&gt;         assert( xml != ei&quot;”” The text I’m typing here would cause a compiler error.<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt; same here   &quot;&quot;” )<br>&gt; <br>&gt; Then it’s very clear what the whitespace stripping will do. But what about mixed tab vs whitespace? What is the behavior in that case?<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Then you could even, if you were so daring, put the string modifiers in the string as compiler directives.<br></p><p>        assert( xml != <br>            “”” #escaped #marginStripped <br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;” )<br></p><p>Is this dirty? It sure feels dirty, but it also makes it so I can line up my triple quotes and finally achieve a zen state.<br></p><p>Tyler<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/26c70156/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 8:27 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 5, 2016, at 5:08 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Adapting the original proposal if you’re not a fan of continuation quotes..<br>&gt;&gt; <br>&gt;&gt; It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>&gt;&gt; As suggested earlier in this thread the lexer can strip the margin on the basis of<br>&gt;&gt; the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>&gt;&gt; but might as well be the default TBH.) Would this be the best of both worlds?<br>&gt;&gt; <br>&gt;&gt;         assert( xml == i&quot;&quot;&quot;<br>&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;” )<br>&gt;&gt; <br>&gt;&gt; Other modifiers can also be applied such as “no-escapes&quot;<br>&gt;&gt; <br>&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;&quot; )<br>&gt;&gt; <br>&gt;&gt; I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br>&gt;&gt; <br>&gt;&gt; Or you could support both continuation and indented python style:<br>&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz&gt;<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; I’m of the opinion that either of these are reasonable solutions, and both offer different tradeoffs. I’m probably partial to the continuation quotes, because I don’t want to be guessing about what is going to end up being in my string and what won’t.  <br>&gt; <br>&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;             &quot;&quot;” )<br>&gt; <br>&gt; For example, is there a new line after &lt;/catalog&gt;?<br>&gt; How would the indenting work if it were immediately followed by triple quotes: &lt;/catalog&gt;”””<br>&gt; I would really like the first line to be lined up with the rest of the xml. Is that going to introduce a newline into the top of the string?<br>&gt; <br>&gt; Could we just enforce that no characters on the lines of the triple quotes would be included in the string, very much like the heredoc syntax?<br>&gt; <br>&gt;         assert( xml != ei&quot;”” The text I’m typing here would cause a compiler error.<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt; same here   &quot;&quot;” )<br>&gt; <br>&gt; Then it’s very clear what the whitespace stripping will do. But what about mixed tab vs whitespace? What is the behavior in that case?<br></p><p><br>I’m jumping into this thread late and have only followed bits of it so I apologize if I’m repeating anything.<br></p><p>I really like the idea of having leading space stripped automatically without requiring the continuation quotes.  I have done my share of leading space stripping in the past when working with heredocs.  It’s not that big a deal but it would be better to have the language take care of it for us.<br></p><p>I like the idea of banning any characters on the same line as the triple quotes (not just omitting them but actually making it a syntax error to include them).<br></p><p>As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/e74bc572/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  6, 2016 at 07:00:00am</p></header><div class="content"><p>Inline<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On May 6, 2016, at 4:13 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 5, 2016, at 8:27 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 5, 2016, at 5:08 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adapting the original proposal if you’re not a fan of continuation quotes..<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>&gt;&gt;&gt; As suggested earlier in this thread the lexer can strip the margin on the basis of<br>&gt;&gt;&gt; the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>&gt;&gt;&gt; but might as well be the default TBH.) Would this be the best of both worlds?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         assert( xml == i&quot;&quot;&quot;<br>&gt;&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;             &quot;&quot;” )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other modifiers can also be applied such as “no-escapes&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;             &quot;&quot;&quot; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or you could support both continuation and indented python style:<br>&gt;&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; I’m of the opinion that either of these are reasonable solutions, and both offer different tradeoffs. I’m probably partial to the continuation quotes, because I don’t want to be guessing about what is going to end up being in my string and what won’t. <br>&gt;&gt; <br>&gt;&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;             &quot;&quot;” )<br>&gt;&gt; <br>&gt;&gt; For example, is there a new line after &lt;/catalog&gt;?<br>&gt;&gt; How would the indenting work if it were immediately followed by triple quotes: &lt;/catalog&gt;”””<br>&gt;&gt; I would really like the first line to be lined up with the rest of the xml. Is that going to introduce a newline into the top of the string?<br>&gt;&gt; <br>&gt;&gt; Could we just enforce that no characters on the lines of the triple quotes would be included in the string, very much like the heredoc syntax?<br>&gt;&gt; <br>&gt;&gt;         assert( xml != ei&quot;”” The text I’m typing here would cause a compiler error.<br>&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt; same here   &quot;&quot;” )<br>&gt;&gt; <br>&gt;&gt; Then it’s very clear what the whitespace stripping will do. But what about mixed tab vs whitespace? What is the behavior in that case?<br>&gt; <br>&gt; <br>&gt; I’m jumping into this thread late and have only followed bits of it so I apologize if I’m repeating anything.<br>&gt; <br>&gt; I really like the idea of having leading space stripped automatically without requiring the continuation quotes.  I have done my share of leading space stripping in the past when working with heredocs.  It’s not that big a deal but it would be better to have the language take care of it for us.<br>&gt; <br>&gt; I like the idea of banning any characters on the same line as the triple quotes (not just omitting them but actually making it a syntax error to include them).<br>&gt; <br>&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  <br></p><p>Upon first consideration, this does not strike me as realistic considering how we are talking about invisible character (requiring editor configuration to be materialisable) and how widely diverse the opinions which to use are, leading to all sorts of combinations in existing source code.<br></p><p>&gt; All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/740ceea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  6, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 6, 2016, at 12:14 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On May 6, 2016, at 4:13 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 5, 2016, at 8:27 PM, Tyler Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 5, 2016, at 5:08 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 May 2016, at 14:17, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 05 May 2016, at 12:30, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with all you said. I’m fairly sure I would never vote for Brent’s proposal simply because of the existence of continuation quotes, no matter the amount of reasoning behind it. They are simply too unwieldy, cumbersome and unfriendly to modification.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I could see either your proposal, or your proposal without the HERE_DOCs but using Tyler’s/Scala’s .stripMargin. Do you think you could start a formal proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Adapting the original proposal if you’re not a fan of continuation quotes..<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s possible to have a multiline “””python””” multi-line string but tidily indented.<br>&gt;&gt;&gt;&gt; As suggested earlier in this thread the lexer can strip the margin on the basis of<br>&gt;&gt;&gt;&gt; the whitespace before the closing quote as per Perl6 (This could be a modifier “I”<br>&gt;&gt;&gt;&gt; but might as well be the default TBH.) Would this be the best of both worlds?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         assert( xml == i&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt;             &quot;&quot;” )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other modifiers can also be applied such as “no-escapes&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt;             &quot;&quot;&quot; )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d hope this would satisfy any need for &lt;&lt;HERE/&lt;&lt;‘HERE’ style constructs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or you could support both continuation and indented python style:<br>&gt;&gt;&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-05-a-osx.tar.gz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m of the opinion that either of these are reasonable solutions, and both offer different tradeoffs. I’m probably partial to the continuation quotes, because I don’t want to be guessing about what is going to end up being in my string and what won’t.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt;&gt;             &quot;&quot;” )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, is there a new line after &lt;/catalog&gt;?<br>&gt;&gt;&gt; How would the indenting work if it were immediately followed by triple quotes: &lt;/catalog&gt;”””<br>&gt;&gt;&gt; I would really like the first line to be lined up with the rest of the xml. Is that going to introduce a newline into the top of the string?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could we just enforce that no characters on the lines of the triple quotes would be included in the string, very much like the heredoc syntax?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         assert( xml != ei&quot;”” The text I’m typing here would cause a compiler error.<br>&gt;&gt;&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;             &lt;catalog&gt;<br>&gt;&gt;&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;                &lt;/book&gt;<br>&gt;&gt;&gt;             &lt;/catalog&gt;<br>&gt;&gt;&gt; same here   &quot;&quot;” )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then it’s very clear what the whitespace stripping will do. But what about mixed tab vs whitespace? What is the behavior in that case?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’m jumping into this thread late and have only followed bits of it so I apologize if I’m repeating anything.<br>&gt;&gt; <br>&gt;&gt; I really like the idea of having leading space stripped automatically without requiring the continuation quotes.  I have done my share of leading space stripping in the past when working with heredocs.  It’s not that big a deal but it would be better to have the language take care of it for us.<br>&gt;&gt; <br>&gt;&gt; I like the idea of banning any characters on the same line as the triple quotes (not just omitting them but actually making it a syntax error to include them).<br>&gt;&gt; <br>&gt;&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  <br>&gt; <br>&gt; Upon first consideration, this does not strike me as realistic considering how we are talking about invisible character (requiring editor configuration to be materialisable) and how widely diverse the opinions which to use are, leading to all sorts of combinations in existing source code.<br></p><p>However, most existing code will not mix tabs and spaces.  It happens by accident occasionally, best practice is definitely to pick one and stick to it.  Allowing either means most existing code will comply.<br>&gt; <br>&gt;&gt; All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/4818282f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br></p><p>The sane thing to do would be to require every line be prefixed with *exactly* the same sequence of characters as the closing delimiter line. Anything else (except perhaps a completely blank line, to permit whitespace trimming) would be a syntax error.<br></p><p>But take a moment to consider the downsides before you leap to adopt this solution.<br></p><p>1. You have introduced tab-space confusion into the equation.<br></p><p>2. You have introduced trailing-newline confusion into the equation.<br></p><p>3. The #escaped and #marginStripped keywords are now specific to multiline strings; #escaped in particular will be attractive there for tasks like regexes. You will have to invent a different syntax for it there.<br></p><p>4. This form of `&quot;&quot;&quot;` is not useful for not having to escape `&quot;` in a single-line string; you now have to invent a separate mechanism for that.<br></p><p>5. You can&#39;t necessarily look at a line and tell whether it&#39;s code or string. And—especially with the #escaped-style constructs—the delimiters don&#39;t necessarily &quot;pop&quot; visually; they&#39;re too small and easy to miss compared to the text they contain. In extremis, you actually have to look at the entire file from top to bottom, counting the `&quot;&quot;&quot;`s to figure out whether you&#39;re in a string or not. Granted, you *usually* can tell from context, but it&#39;s a far cry from what continuation quotes offer.<br></p><p>6. You are now forcing *any* string literal of more than one line to include two extra lines devoted wholly to the quoting syntax. In my Swift-generating example, that would change shorter snippets like this:<br></p><p>code +=      &quot;    <br>             &quot;    static var messages: [HTTPStatus: String] = [<br>             &quot;&quot;<br></p><p>Into things like this:<br></p><p>code +=      &quot;&quot;&quot;<br>                 <br>                 static var messages: [HTTPStatus: String] = [<br>                            <br>             &quot;&quot;&quot;<br></p><p>To my mind, the second syntax is actually *heavier*, despite not requiring every line be marked, because it takes two extra lines and additional punctuation.<br></p><p>7. You are also introducing visual ambiguity into the equation—in the above example, the left margin is now ambiguous to the eye (even if it&#39;s not ambiguous to the compiler). You could recover it by permitting non-whitespace prefix characters:<br></p><p>code +=      &quot;&quot;&quot;<br>            |    <br>            |    static var messages: [HTTPStatus: String] = [<br>            |<br>            |&quot;&quot;&quot;<br></p><p>...but then we&#39;re back to annotating every line, *plus* we have the leading and trailing `&quot;&quot;&quot;` lines. Worst of both worlds.<br></p><p>8. In longer examples, you are dividing the expression in half in a way that makes it difficult to read. For instance, consider this code:<br></p><p>        socket.send( <br>            &quot;&quot;&quot; #escaped #marginStripped <br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br></p><p>The effect—particularly with even larger literals than this—is not unlike pausing in the middle of reading an article to watch a movie. What were we talking about again?<br></p><p>This problem is neatly avoided by a heredoc syntax, which keeps the expression together and then collects the string below it:<br></p><p>        socket.send(&quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;&quot;<br></p><p>(I&#39;m assuming there&#39;s no need for #escaped or #marginStripped; they&#39;re both enabled by default.)<br></p><p>* * *<br></p><p>Let&#39;s actually talk about heredocs. Leaving aside indentation (which can be applied to either feature) and the traditional token choices (which can be changed), I think these are the pros of heredocs compared to Python triple-quotes:<br></p><p>H1: Doesn&#39;t break up expressions, as discussed above.<br>H2: Literal content formatting is completely unaffected by code formatting, including the first and last lines.<br></p><p>Here are the pros of Python triple-quotes compared to heredocs:<br></p><p>P1: Simpler to explain: &quot;like a string literal, but really big&quot;.<br>P2: Lighter syntactic weight, enough to make`&quot;&quot;&quot;` usable as a single-line syntax.<br>P3: Less trailing-newline confusion.<br></p><p>(There is one other difference: `&quot;&quot;&quot;` is simpler to parse, so we might be able to get it in Swift 3, whereas heredocs probably have to wait for Swift 4. But I don&#39;t think we should pick one feature over another merely so we can get it sooner. It&#39;s one thing if you plan to eventually introduce both features, as I plan to eventually have both continuation quotes and heredocs, to introduce each of them as soon as you can; it&#39;s another to actually choose one feature over another specifically to get something you can implement sooner.)<br></p><p>But the design you&#39;re discussing trades P2 and P3—and frankly, with the mandatory newlines, part of P1—away in an attempt to get H2. So we end up deciding between these two selling points:<br></p><p>* This triple-quotes design: Simpler to explain.<br>* Heredocs: Doesn&#39;t break up expressions.<br></p><p>Simplicity is good, but I really like the code reading benefits of heredocs. Your code is your code and your text is your text. The interface between them is a bit funky, but within their separate worlds, they&#39;re both pretty nice.<br></p><p>* * *<br></p><p>Either way, heredocs or multiline-only triple quotes could be tweaked to support indentation by using the indentation of the end delimiter. But as I explained above, I don&#39;t think that&#39;s a great idea for either triple quotes *or* heredocs—the edge of the indentation is not visually well defined enough.<br></p><p>That&#39;s why I came to the conclusion that trying to cram every multiline literal into one syntax is trying to cram too many peg shapes into one hole shape. Indentation should *only* be supported by a dedicated syntax which is also designed for the smallest multiline strings, where indentation support is most useful. A separate feature without indentation support should handle longer strings, where the length alone is so disruptive to the flow of your code that there&#39;s just no point even trying to indent them to match (and the break with normal indentation itself assists you in finding the end of the string).<br></p><p>And I think that the best choice for the first feature is continuation quotes, and for the second is heredocs. Triple-quote syntaxes—either Python&#39;s or this modification—are jacks of all trades, but masters of none.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/262b094e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  6, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 6, 2016, at 12:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br>&gt; <br>&gt; The sane thing to do would be to require every line be prefixed with *exactly* the same sequence of characters as the closing delimiter line. Anything else (except perhaps a completely blank line, to permit whitespace trimming) would be a syntax error.<br></p><p>Yes, this is the important implication of what I suggested.<br></p><p>&gt; <br>&gt; But take a moment to consider the downsides before you leap to adopt this solution.<br>&gt; <br>&gt; 1. You have introduced tab-space confusion into the equation.<br>&gt; <br>&gt; 2. You have introduced trailing-newline confusion into the equation.<br></p><p>I don&#39;t think confusion is the right word.  When tabs and spaces are mixed accidentally the compiler can offer a very clear error message.  The problem is easy to understand and easy to fix.<br></p><p>The new line question is really just a matter of learning how the language works and then doing the right thing.  Confusion only exists if you don&#39;t know the language, which can be said about pretty much any feature.  <br></p><p>&gt; <br>&gt; 3. The #escaped and #marginStripped keywords are now specific to multiline strings; #escaped in particular will be attractive there for tasks like regexes. You will have to invent a different syntax for it there.<br></p><p>The syntax for those was not my suggestion.  <br></p><p>&gt; <br>&gt; 4. This form of `&quot;&quot;&quot;` is not useful for not having to escape `&quot;` in a single-line string; you now have to invent a separate mechanism for that.<br></p><p>I was only commenting on the leading space issue.  If you prefer heredoc syntax that is fine with me.<br>&gt; <br>&gt; 5. You can&#39;t necessarily look at a line and tell whether it&#39;s code or string. And—especially with the #escaped-style constructs—the delimiters don&#39;t necessarily &quot;pop&quot; visually; they&#39;re too small and easy to miss compared to the text they contain. In extremis, you actually have to look at the entire file from top to bottom, counting the `&quot;&quot;&quot;`s to figure out whether you&#39;re in a string or not. Granted, you *usually* can tell from context, but it&#39;s a far cry from what continuation quotes offer.<br></p><p>This has never been a problem for me.  I have used heredocs extensively in the past.<br>&gt; <br>&gt; 6. You are now forcing *any* string literal of more than one line to include two extra lines devoted wholly to the quoting syntax. In my Swift-generating example, that would change shorter snippets like this:<br>&gt; <br>&gt; code +=      &quot;    <br>&gt;              &quot;    static var messages: [HTTPStatus: String] = [<br>&gt;              &quot;&quot;<br>&gt; <br>&gt; Into things like this:<br>&gt; <br>&gt; code +=      &quot;&quot;&quot;<br>&gt;                  <br>&gt;                  static var messages: [HTTPStatus: String] = [<br>&gt;                             <br>&gt;              &quot;&quot;&quot;<br>&gt; <br>&gt; To my mind, the second syntax is actually *heavier*, despite not requiring every line be marked, because it takes two extra lines and additional punctuation.<br></p><p>Granted.  But in my experience multi-line string literals are usually not so short.  This has never bothered me in work with heredocs.<br>&gt; <br>&gt; 7. You are also introducing visual ambiguity into the equation—in the above example, the left margin is now ambiguous to the eye (even if it&#39;s not ambiguous to the compiler). You could recover it by permitting non-whitespace prefix characters:<br>&gt; <br>&gt; code +=      &quot;&quot;&quot;<br>&gt;             |    <br>&gt;             |    static var messages: [HTTPStatus: String] = [<br>&gt;             |<br>&gt;             |&quot;&quot;&quot;<br>&gt; <br>&gt; ...but then we&#39;re back to annotating every line, *plus* we have the leading and trailing `&quot;&quot;&quot;` lines. Worst of both worlds.<br></p><p>This is a reasonable point and one I hadn&#39;t thought of.  I never had a problem with it when working with heredocs, but I can see where occasionally this would make a difference.<br></p><p>&gt; <br>&gt; 8. In longer examples, you are dividing the expression in half in a way that makes it difficult to read. For instance, consider this code:<br>&gt; <br>&gt;         socket.send( <br>&gt;             &quot;&quot;&quot; #escaped #marginStripped <br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br>&gt; <br>&gt; The effect—particularly with even larger literals than this—is not unlike pausing in the middle of reading an article to watch a movie. What were we talking about again?<br>&gt; <br>&gt; This problem is neatly avoided by a heredoc syntax, which keeps the expression together and then collects the string below it:<br>&gt; <br>&gt;         socket.send(&quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot;<br>&gt; <br>&gt; (I&#39;m assuming there&#39;s no need for #escaped or #marginStripped; they&#39;re both enabled by default.)<br></p><p>That&#39;s interesting.  I haven&#39;t encountered syntax like that before.  I think I like it but would have to consider it further.<br></p><p>Again, I was only commenting on the leading space issue, not triple quote vs heredoc.<br></p><p><br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Let&#39;s actually talk about heredocs. Leaving aside indentation (which can be applied to either feature) and the traditional token choices (which can be changed), I think these are the pros of heredocs compared to Python triple-quotes:<br>&gt; <br>&gt; H1: Doesn&#39;t break up expressions, as discussed above.<br>&gt; H2: Literal content formatting is completely unaffected by code formatting, including the first and last lines.<br>&gt; <br>&gt; Here are the pros of Python triple-quotes compared to heredocs:<br>&gt; <br>&gt; P1: Simpler to explain: &quot;like a string literal, but really big&quot;.<br>&gt; P2: Lighter syntactic weight, enough to make`&quot;&quot;&quot;` usable as a single-line syntax.<br>&gt; P3: Less trailing-newline confusion.<br>&gt; <br>&gt; (There is one other difference: `&quot;&quot;&quot;` is simpler to parse, so we might be able to get it in Swift 3, whereas heredocs probably have to wait for Swift 4. But I don&#39;t think we should pick one feature over another merely so we can get it sooner. It&#39;s one thing if you plan to eventually introduce both features, as I plan to eventually have both continuation quotes and heredocs, to introduce each of them as soon as you can; it&#39;s another to actually choose one feature over another specifically to get something you can implement sooner.)<br>&gt; <br>&gt; But the design you&#39;re discussing trades P2 and P3—and frankly, with the mandatory newlines, part of P1—away in an attempt to get H2. So we end up deciding between these two selling points:<br>&gt; <br>&gt; * This triple-quotes design: Simpler to explain.<br>&gt; * Heredocs: Doesn&#39;t break up expressions.<br>&gt; <br>&gt; Simplicity is good, but I really like the code reading benefits of heredocs. Your code is your code and your text is your text. The interface between them is a bit funky, but within their separate worlds, they&#39;re both pretty nice.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Either way, heredocs or multiline-only triple quotes could be tweaked to support indentation by using the indentation of the end delimiter. But as I explained above, I don&#39;t think that&#39;s a great idea for either triple quotes *or* heredocs—the edge of the indentation is not visually well defined enough.<br></p><p>How would you feel about making stripping a choice, like escapes, etc?  I think building the option into the language is great.  The reason is that almost every heredoc I ever wrote was stripped of leading space by code I had to write and call myself.<br></p><p>&gt; <br>&gt; That&#39;s why I came to the conclusion that trying to cram every multiline literal into one syntax is trying to cram too many peg shapes into one hole shape. Indentation should *only* be supported by a dedicated syntax which is also designed for the smallest multiline strings, where indentation support is most useful. A separate feature without indentation support should handle longer strings, where the length alone is so disruptive to the flow of your code that there&#39;s just no point even trying to indent them to match (and the break with normal indentation itself assists you in finding the end of the string).<br>&gt; <br>&gt; And I think that the best choice for the first feature is continuation quotes, and for the second is heredocs. Triple-quote syntaxes—either Python&#39;s or this modification—are jacks of all trades, but masters of none.<br></p><p>This is fine with me.  Again, I was only commenting on the leading space issue.  I don&#39;t mind continuation quotes if we think heredocs (or triple quotes) are also likely to be added.  You make a good case for having both.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/12af36c9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  6, 2016 at 07:00:00pm</p></header><div class="content"><p>As I (believe I) start to understand the parser, I somehow think that doing something like the following would <br>not violate (not take too much risk) the current Lexer/Parser<br>be somewhat reasonable to implement<br>address many of the reqs I read <br>leave some infrastructure in the Lexer/Parser to add more feature without needing to go back to square 0 next time<br></p><p>Any thoughts?!<br></p><p><br>#!/usr/bin/env xcrun swift<br></p><p>let s1 = &quot;{\&quot;key1\&quot;: \&quot;stringValue\&quot;}&quot;<br></p><p>let s2 = _&quot;{&quot;key1&quot;: &quot;stringValue&quot;}&quot;_<br></p><p>let s3 =<br>    /* this is the same template */<br>    _&quot;{&quot;key1&quot;: &quot;stringValue&quot;}&quot;_<br></p><p>let s4 =<br>/* this is (almost) the same template */<br>_&quot;<br>{<br>  &quot;key1&quot;: &quot;stringValue&quot;<br>  , &quot;key2&quot;: &quot;stringValue&quot;<br>}<br>&quot;_<br></p><p>let s5 = @literal(json)<br>  /* this is exactly the same template as s4 */<br>  _&quot;<br>  {<br>    &quot;key1&quot;: &quot;stringValue&quot;<br>    , &quot;key2&quot;: &quot;stringValue&quot;<br>  }<br>  &quot;_<br></p><p>let s6 = @literal(json)<br>  /* this is exactly the same template as s5&amp;s4 */<br>  _&quot;<br>  |{<br>  |  &quot;key1&quot;: &quot;stringValue&quot;<br>  |  , &quot;key2&quot;: &quot;stringValue&quot;<br>  |}<br>  &quot;_<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/7384c26a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 7:13 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; As I (believe I) start to understand the parser, I somehow think that doing something like the following would <br>&gt; not violate (not take too much risk) the current Lexer/Parser<br>&gt; be somewhat reasonable to implement<br>&gt; address many of the reqs I read <br>&gt; leave some infrastructure in the Lexer/Parser to add more feature without needing to go back to square 0 next time<br>&gt; <br>&gt; Any thoughts?!<br>&gt; <br>&gt; <br>&gt; #!/usr/bin/env xcrun swift<br>&gt; <br>&gt; let s1 = &quot;{\&quot;key1\&quot;: \&quot;stringValue\&quot;}&quot;<br>&gt; <br>&gt; let s2 = _&quot;{&quot;key1&quot;: &quot;stringValue&quot;}&quot;_<br>&gt; <br>&gt; let s3 =<br>&gt;     /* this is the same template */<br>&gt;     _&quot;{&quot;key1&quot;: &quot;stringValue&quot;}&quot;_<br>&gt; <br>&gt; let s4 =<br>&gt; /* this is (almost) the same template */<br>&gt; _&quot;<br>&gt; {<br>&gt;   &quot;key1&quot;: &quot;stringValue&quot;<br>&gt;   , &quot;key2&quot;: &quot;stringValue&quot;<br>&gt; }<br>&gt; &quot;_<br>&gt; <br>&gt; let s5 = @literal(json)<br>&gt;   /* this is exactly the same template as s4 */<br>&gt;   _&quot;<br>&gt;   {<br>&gt;     &quot;key1&quot;: &quot;stringValue&quot;<br>&gt;     , &quot;key2&quot;: &quot;stringValue&quot;<br>&gt;   }<br>&gt;   &quot;_<br>&gt; <br></p><p>sorry for the mistake, but I think the more appropriate way to say that should have been<br></p><p>let s5: @literal(json) String = <br>  /* this is exactly the same template as s4 */<br>  _&quot;<br>  {<br>    &quot;key1&quot;: &quot;stringValue&quot;<br>    , &quot;key2&quot;: &quot;stringValue&quot;<br>  }<br>  &quot;_<br></p><p><br>&gt; let s6 = @literal(json)<br>&gt;   /* this is exactly the same template as s5&amp;s4 */<br>&gt;   _&quot;<br>&gt;   |{<br>&gt;   |  &quot;key1&quot;: &quot;stringValue&quot;<br>&gt;   |  , &quot;key2&quot;: &quot;stringValue&quot;<br>&gt;   |}<br>&gt;   &quot;_<br>&gt; <br></p><p>same for s6 which should read<br></p><p>let s6: @literal(json) String = ...<br></p><p>I have not checked it the following would be enough<br></p><p>let s6: @literal(json)  = ...<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/8049da51/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 10:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br>&gt; <br>&gt; The sane thing to do would be to require every line be prefixed with *exactly* the same sequence of characters as the closing delimiter line. Anything else (except perhaps a completely blank line, to permit whitespace trimming) would be a syntax error.<br>&gt; <br></p><p>Yes, this I think would be the way to do it.<br></p><p>&gt; But take a moment to consider the downsides before you leap to adopt this solution.<br>&gt; <br>&gt; 1. You have introduced tab-space confusion into the equation.<br></p><p>Agreed, and that’s never fun since they are invisible. Confusing for people new to programming, I imagine.<br></p><p>&gt; <br>&gt; 2. You have introduced trailing-newline confusion into the equation.<br></p><p>Yes, you are absolutely right and I missed this one in my response. I assume you are referring to whether or not there is a new line after &lt;/catalog&gt;, and if so how do you get rid of it without messing up the whitespace trimming.<br></p><p>Is this not also a problem for heredocs (if you want to use the closing delimiter to mark how much whitespace to trim)?<br></p><p>&gt; <br>&gt; 3. The #escaped and #marginStripped keywords are now specific to multiline strings; #escaped in particular will be attractive there for tasks like regexes. You will have to invent a different syntax for it there.<br></p><p>These were just straw man proposals, I don’t think that is what they should/would be. Just throwing the general idea out there.<br></p><p>&gt; <br>&gt; 4. This form of `&quot;&quot;&quot;` is not useful for not having to escape `&quot;` in a single-line string; you now have to invent a separate mechanism for that.<br></p><p>True, unless you don’t mind taking up 3 lines to do it.<br></p><p>&gt; <br>&gt; 5. You can&#39;t necessarily look at a line and tell whether it&#39;s code or string. And—especially with the #escaped-style constructs—the delimiters don&#39;t necessarily &quot;pop&quot; visually; they&#39;re too small and easy to miss compared to the text they contain. In extremis, you actually have to look at the entire file from top to bottom, counting the `&quot;&quot;&quot;`s to figure out whether you&#39;re in a string or not. Granted, you *usually* can tell from context, but it&#39;s a far cry from what continuation quotes offer.<br></p><p>To be fair, syntax highlighting also helps with this, but it’s quite possible you are looking at the code in a context where it is not available.<br></p><p>I don’t see how the #compilerDirective modifiers make the delimiters any less visible, though <br></p><p>And, the same could be said for heredoc delimiters, I think. Although, that really depends on what the delimiters are.<br></p><p>&gt; <br>&gt; 6. You are now forcing *any* string literal of more than one line to include two extra lines devoted wholly to the quoting syntax. In my Swift-generating example, that would change shorter snippets like this:<br>&gt; <br>&gt; code +=      &quot;    <br>&gt;              &quot;    static var messages: [HTTPStatus: String] = [<br>&gt;              &quot;&quot;<br>&gt; <br>&gt; Into things like this:<br>&gt; <br>&gt; code +=      &quot;&quot;&quot;<br>&gt;                  <br>&gt;                  static var messages: [HTTPStatus: String] = [<br>&gt;                             <br>&gt;              &quot;&quot;&quot;<br>&gt; <br>&gt; To my mind, the second syntax is actually *heavier*, despite not requiring every line be marked, because it takes two extra lines and additional punctuation.<br></p><p>&gt; <br>&gt; 7. You are also introducing visual ambiguity into the equation—in the above example, the left margin is now ambiguous to the eye (even if it&#39;s not ambiguous to the compiler). You could recover it by permitting non-whitespace prefix characters:<br>&gt; <br>&gt; code +=      &quot;&quot;&quot;<br>&gt;             |    <br>&gt;             |    static var messages: [HTTPStatus: String] = [<br>&gt;             |<br>&gt;             |&quot;&quot;&quot;<br>&gt; <br>&gt; ...but then we&#39;re back to annotating every line, *plus* we have the leading and trailing `&quot;&quot;&quot;` lines. Worst of both worlds.<br>&gt; <br></p><p>This is a good point. It takes up 5 lines, and you quite possibly will still have to go about counting spaces. It would be worse for the more whitespace you have.<br></p><p><br>&gt; 8. In longer examples, you are dividing the expression in half in a way that makes it difficult to read. For instance, consider this code:<br>&gt; <br>&gt;         socket.send( <br>&gt;             &quot;&quot;&quot; #escaped #marginStripped <br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br>&gt; <br>&gt; The effect—particularly with even larger literals than this—is not unlike pausing in the middle of reading an article to watch a movie. What were we talking about again?<br>&gt; <br>&gt; This problem is neatly avoided by a heredoc syntax, which keeps the expression together and then collects the string below it:<br>&gt; <br>&gt;         socket.send(&quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot;<br>&gt; <br>&gt; (I&#39;m assuming there&#39;s no need for #escaped or #marginStripped; they&#39;re both enabled by default.)<br></p><p> I don’t really see the argument of pausing in the middle of the code. Isn’t that the mental model that most people have for string literals? If anything heredoc syntax would be more confusing.<br></p><p>Where would you put the modifiers then? I assume as modifying letters before the “””? <br></p><p>        socket.send(ei&quot;&quot;&quot;.data(using: NSUTF8StringEncoding))<br></p><p>That would work and also be consistent with single line and continuation quote strings if this feature were added there.<br></p><p>Heredocs look like they would be harder to parse than the alternative syntax, no? <br></p><p>&gt; <br>&gt; * * *<br>&gt; <br>&gt; Let&#39;s actually talk about heredocs. Leaving aside indentation (which can be applied to either feature) and the traditional token choices (which can be changed), I think these are the pros of heredocs compared to Python triple-quotes:<br>&gt; <br>&gt; H1: Doesn&#39;t break up expressions, as discussed above.<br>&gt; H2: Literal content formatting is completely unaffected by code formatting, including the first and last lines.<br>&gt; <br>&gt; Here are the pros of Python triple-quotes compared to heredocs:<br>&gt; <br>&gt; P1: Simpler to explain: &quot;like a string literal, but really big&quot;.<br>&gt; P2: Lighter syntactic weight, enough to make`&quot;&quot;&quot;` usable as a single-line syntax.<br>&gt; P3: Less trailing-newline confusion.<br>&gt; <br>&gt; (There is one other difference: `&quot;&quot;&quot;` is simpler to parse, so we might be able to get it in Swift 3, whereas heredocs probably have to wait for Swift 4. But I don&#39;t think we should pick one feature over another merely so we can get it sooner. It&#39;s one thing if you plan to eventually introduce both features, as I plan to eventually have both continuation quotes and heredocs, to introduce each of them as soon as you can; it&#39;s another to actually choose one feature over another specifically to get something you can implement sooner.)<br>&gt; <br>&gt; But the design you&#39;re discussing trades P2 and P3—and frankly, with the mandatory newlines, part of P1—away in an attempt to get H2. So we end up deciding between these two selling points:<br>&gt; <br>&gt; * This triple-quotes design: Simpler to explain.<br>&gt; * Heredocs: Doesn&#39;t break up expressions.<br>&gt; <br>&gt; Simplicity is good, but I really like the code reading benefits of heredocs. Your code is your code and your text is your text. The interface between them is a bit funky, but within their separate worlds, they&#39;re both pretty nice.<br>&gt; <br></p><p>I would support having both. I think they have sufficiently different use cases and tradeoffs to warrant two solutions. It is also nice that if implementing both were the way to go, continuation quotes could be added to Swift 3, and heredoc could come later if necessary.<br></p><p><br>&gt; * * *<br>&gt; <br>&gt; Either way, heredocs or multiline-only triple quotes could be tweaked to support indentation by using the indentation of the end delimiter. But as I explained above, I don&#39;t think that&#39;s a great idea for either triple quotes *or* heredocs—the edge of the indentation is not visually well defined enough.<br>&gt; <br>&gt; That&#39;s why I came to the conclusion that trying to cram every multiline literal into one syntax is trying to cram too many peg shapes into one hole shape. Indentation should *only* be supported by a dedicated syntax which is also designed for the smallest multiline strings, where indentation support is most useful. A separate feature without indentation support should handle longer strings, where the length alone is so disruptive to the flow of your code that there&#39;s just no point even trying to indent them to match (and the break with normal indentation itself assists you in finding the end of the string).<br>&gt; <br>&gt; And I think that the best choice for the first feature is continuation quotes, and for the second is heredocs. Triple-quote syntaxes—either Python&#39;s or this modification—are jacks of all trades, but masters of none.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/e88a7f5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May  7, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 6 May 2016, at 20:09, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 5, 2016, at 10:52 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; As far as mixed whitespace, I think the only sane thing to do would be to only allow leading tabs *or* spaces.  Mixing tabs and spaces in the leading whitespace would be a syntax error.  All lines in the string would need to use tabs or all lines use spaces, you could not have one line with tabs and another with spaces.  This would keep the compiler out of the business of making any assumptions or guesses, would not be a problem often, and would be very easy to fix if it ever happens accidentally.<br>&gt;&gt; <br>&gt;&gt; The sane thing to do would be to require every line be prefixed with *exactly* the same sequence of characters as the closing delimiter line. Anything else (except perhaps a completely blank line, to permit whitespace trimming) would be a syntax error.<br>&gt;&gt; <br>&gt; <br>&gt; Yes, this I think would be the way to do it.<br></p><p>This is implemented this in today’s prototype toolchain (as a warning)<br>http://johnholdsworth.com/swift-LOCAL-2016-05-06-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-06-a-osx.tar.gz&gt;<br></p><p>&gt; Heredocs look like they would be harder to parse than the alternative syntax, no? <br></p><p>I’ve had a go at parsing HEREDOC (why does autocorrect always change this to HERETIC!)<br>It wasn’t as difficult as I’d expected once you comment out a few well meaning asserts in the <br>compiler. To keep lexing happy there are two variants &lt;&lt;“HEREDOC” and &lt;&lt;‘HEREDOC’.<br></p><p>        assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == (xml + xml) )<br>        &lt;?xml version=&quot;1.0&quot;?&gt;<br>        &lt;catalog&gt;<br>           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>               &lt;author&gt;\(author)&lt;/author&gt;<br>               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>               &lt;genre&gt;Computer&lt;/genre&gt;<br>               &lt;price&gt;44.95&lt;/price&gt;<br>               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>               &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           &lt;/book&gt;<br>        &lt;/catalog&gt;<br>        XML<br>        &lt;?xml version=&quot;1.0&quot;?&gt;<br>        &lt;catalog&gt;<br>           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>               &lt;author&gt;\(author)&lt;/author&gt;<br>               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>               &lt;genre&gt;Computer&lt;/genre&gt;<br>               &lt;price&gt;44.95&lt;/price&gt;<br>               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>               &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           &lt;/book&gt;<br>        &lt;/catalog&gt;<br>        XML<br></p><p>Its a credit to it&#39;s authors that Xcode and the remainder of the toolchain cope with this remarkably well<br>now that tokens arrive out of order. The weird colouring is an artefact I’ve not been able to resolve.<br></p><p>The changes are here: https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;, and amount to an additional 60 lines of by no<br>means bullet proof code. The total changes for multi-line literals are now 10% of the Swift lib/Parse/Lexer.cpp.<br></p><p>&gt;&gt; Simplicity is good, but I really like the code reading benefits of heredocs. Your code is your code and your text is your text. The interface between them is a bit funky, but within their separate worlds, they&#39;re both pretty nice.<br>&gt;&gt; <br>&gt; <br>&gt; I would support having both. I think they have sufficiently different use cases and tradeoffs to warrant two solutions. It is also nice that if implementing both were the way to go, continuation quotes could be added to Swift 3, and heredoc could come later if necessary.<br></p><p>I agree, I think we should prepare a joint proposal with all three syntaxes to get consensus.<br></p><p>John<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/71ec394d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] multiline string literals</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Wanting to test the validity of some of the arguments I read on the main proposal, I worked on my own prototype. I think there is more freedom than seem to have been identified so far.<br></p><p>The syntax I am exploring is visible here: https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c &lt;https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c&gt;<br></p><p>There are still a couple of things that do not work <br>serialization of the @string_literal attribute (I persist in thinking that a lot of good can come from being able to tag the contents of string literal)<br>skipping leading spaces on each lines, based on the indentation of the first line<br>removing some of the extra EOL (rule to be defined)<br></p><p>The following works:<br>comments <br>@string_literal(“xxxx”). At the moment the attribute value is a string_literal, maybe a identifier would be better, and maybe it should be @string_literal(type: “xxxx”), so that other properties can be added<br>the code is based on a string_multiline_literal tag to make these extension visible in the grammar (other prototypes rely on clever tricks in the Lexer)<br></p><p><br></p><p>let s0 = &quot;s0&quot;<br></p><p>let s1 = &quot;{\&quot;key1\&quot;: \&quot;stringValue\&quot;}&quot;<br></p><p>let s2 = _&quot;{&quot;v2&quot;}&quot;_<br></p><p>let s3 =<br>    /* this is a template */<br>    _&quot;{&quot;key3&quot;: &quot;stringValue&quot;}&quot;_<br></p><p>let s4 =<br>/* this is (almost) the same template */<br>_&quot;<br>{<br>  &quot;key4&quot;: &quot;stringValue&quot;<br>  , &quot;key2&quot;: &quot;stringValue&quot;<br>}<br>&quot;_<br></p><p>@string_literal(&quot;json&quot;) let s5 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  {<br>    &quot;key5&quot;: &quot;stringValue&quot;<br>  }<br>  &quot;_<br></p><p>@string_literal(&quot;json&quot;) let s6 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  |{<br>  |  &quot;key6&quot;: &quot;stringValue&quot;<br>  |  , &quot;key2&quot;: &quot;stringValue&quot;<br>  |}<br>  &quot;_<br></p><p><br></p><p><br>&gt; On May 7, 2016, at 1:53 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve had a go at parsing HEREDOC (why does autocorrect always change this to HERETIC!)<br>&gt; It wasn’t as difficult as I’d expected once you comment out a few well meaning asserts in the <br>&gt; compiler. To keep lexing happy there are two variants &lt;&lt;“HEREDOC” and &lt;&lt;‘HEREDOC’.<br>&gt; <br>&gt;         assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == (xml + xml) )<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt; <br>&gt; Its a credit to it&#39;s authors that Xcode and the remainder of the toolchain cope with this remarkably well<br>&gt; now that tokens arrive out of order. The weird colouring is an artefact I’ve not been able to resolve.<br>&gt; <br>&gt; The changes are here: https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;, and amount to an additional 60 lines of by no<br>&gt; means bullet proof code. The total changes for multi-line literals are now 10% of the Swift lib/Parse/Lexer.cpp.<br>&gt; <br>&gt;&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/3ee06638/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>multi-line string literals.</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>May 10, 2016 at 07:00:00am</p></header><div class="content"><p>I’ve assembled a gist to summarise the main proposals of this thread.<br></p><p>https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br></p><p>At the moment there seem to be four proposals for multi-line strings:<br></p><p>1) Bent’s proposal for continuation quotes where if a conventional string<br>does not close, if the first non-whitespace character of the next line is “<br>(or perhaps |) the string is continued. This gives you precise control<br>over exactly what is in the string.<br></p><p>2) Tyler&#39;s original proposal involving strings that can contain newlines<br>delimited “””like this“”” as they are in python or, _”like this“_. This works<br>well in external editors and on github. Indentation is catered for by stripping <br>any whitespace before the closing quote from all lines in the string.<br></p><p>3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl <br>subject to the same indentation removal rules as “””strings””” above. This<br>has the advantage that the literal is clearly separated from your code.<br></p><p>4) Heck it all, why not all three syntaxes or some combination.<br></p><p>(There is a separate feature that all string literals can be prefixed by<br>e as in e”\w\d+” to turn of all escape processing for another day)<br></p><p>While the Swift Lexer could easily accommodate all these syntaxes there was<br>talk early on that Swift has more of a &quot;one way, maximally elegant” ethos and <br>indeed I find it difficult imagine the Swift Book breathlessly describing all three<br>formats so I’m wondering if push came to shove which format people would chose?<br></p><p>My vote having undergone a &quot;road to damascus&quot; moment now we know it is<br>available sooner rather than later is.. HEREDOC! It’s well understood and<br>while at first it would seem to not be a good fit for Swift produces clear code.<br></p><p>Votes?<br></p><p>John<br></p><p><br>        // Multi-line string proposals<br>        // https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;<br></p><p>        // swift-evolution thread:<br>        // http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133&gt;<br></p><p>        // These examples should load in the prototype toolchain available here:<br>        // http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz&gt;<br></p><p>        // The prototype currently parses three new forms of quoting<br>        // These new types are still string literals for the grammar.<br></p><p>        &quot;the existing string literal format&quot;<br>        _&quot;a format that does not require you to escape &quot; characters&quot;_ // possibly redundant<br>        &quot;&quot;&quot;a python-style syntax that will accept &quot;&#39;s and newlines in the string&quot;&quot;&quot;<br>        &lt;&lt;&quot;HEREDOC&quot;<br>        A full heredoc implementation (will always end in a newline)<br>        HEREDOC<br></p><p>        // These strings can be modified by prefixing the string by letters<br>        // There is currently only one, &quot;e&quot; to disable escape processing.<br>        // This is primarily used when specifying regular expressions.<br></p><p>        let str = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br></p><p>        assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot; == str )<br>        assert( e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str )<br>        assert( e&quot;&quot;&quot;print(&quot;Hello, world!\n&quot;)&quot;&quot;&quot; == str )<br></p><p>        // Continuation quotes allow you to extend a standard string literal<br>        // over multiple lines. If a string does not close on a line and the<br>        // first non-whitespace character on the next line is &quot; that line<br>        // will be a contination of the string including the newline character<br>        // (unless it is escaped). Interpolation and escapes process as before<br>        // unless the first segment of the string is modified by the &quot;e&quot; prefix.<br></p><p>        // The advantage of this format allows you to indent while giving<br>        // you precise control of exactly what is going into the literal.<br></p><p>        let author = &quot;Gambardella, Matthew&quot;<br></p><p>        let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;<br>            &quot;&quot;<br>        print(xml)<br></p><p>        // Perhaps, to avoid the zera crossing effect in text editors due to<br>        // the unbalanced quotes, the continuation character could be &quot;|&quot;.<br>        // (newlines escaped with \ and blank lines are discarded.)<br></p><p>        assert( xml == &quot;\<br>            |&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>            |&lt;catalog&gt;<br>            |   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>            |       &lt;author&gt;\(author)&lt;/author&gt;<br>            |       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            |       &lt;genre&gt;Computer&lt;/genre&gt;<br>            |       &lt;price&gt;44.95&lt;/price&gt;<br>            |       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            |       &lt;description&gt;An in-depth look at creating \<br>                            |applications with XML.&lt;/description&gt;<br></p><p>            |   &lt;/book&gt;<br>            |&lt;/catalog&gt;<br>            |&quot; )<br></p><p><br>        // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t require<br>        // escaping of embedded &quot; characters. Think of them as a being modifier<br>        // on conventional string literals. They support continuation quotes.<br></p><p>        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &quot;&lt;catalog&gt;<br>            &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>            &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>            &quot;   &lt;/book&gt;<br>            &quot;&lt;/catalog&gt;\n&quot;_ )<br></p><p>        // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot; discussed next<br></p><p>        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;_ )<br></p><p>        // The triple quoted strings can contain newlines and, unless modified by &quot;e&quot;<br>        // will process interpolations and not require escaping of &quot;. To allow indenting,<br>        // any whitespace characters that preceed the closing &quot;&quot;&quot; will be removed from <br>        // each line of the final literal. A warning is shown if lines do not contain<br>        // the exact same indentation characters. Any intial linefeed is also removed.<br></p><p>        // The advantage of this format is the &quot;&quot;&quot; introducer works well when syntax<br>        // highlighting in external editors and github as quotes are always balanced.<br></p><p>        assert( xml == &quot;&quot;&quot;<br>            &lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;&quot; )<br></p><p>        assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>            &lt;catalog&gt;<br>               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>                   &lt;author&gt;\(author)&lt;/author&gt;<br>                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>                   &lt;genre&gt;Computer&lt;/genre&gt;<br>                   &lt;price&gt;44.95&lt;/price&gt;<br>                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>                   &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>               &lt;/book&gt;<br>            &lt;/catalog&gt;<br>            &quot;&quot;&quot; )<br></p><p>        // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39; (non-escaping, &quot;e&quot; prefix)<br>        // It applies the same indentation removal rules as does &quot;&quot;&quot;. This change has wider<br>        // ramifications for the toolchain as compiler tokens are no longer in file order<br>        // and will take a while for a few problems to be ironed out. The more consistent<br>        // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39; for non-escaping strings.<br></p><p>        // HEREDOC&#39;s advantage is that the literal no longer interrupts the flow of your code.<br></p><p>        assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml )<br>        &lt;?xml version=&quot;1.0&quot;?&gt;<br>        &lt;catalog&gt;<br>           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>               &lt;author&gt;\(author)&lt;/author&gt;<br>               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>               &lt;genre&gt;Computer&lt;/genre&gt;<br>               &lt;price&gt;44.95&lt;/price&gt;<br>               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>               &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           &lt;/book&gt;<br>        &lt;/catalog&gt;<br>        XML<br>        &lt;?xml version=&quot;1.0&quot;?&gt;<br>        &lt;catalog&gt;<br>           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>               &lt;author&gt;\(author)&lt;/author&gt;<br>               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>               &lt;genre&gt;Computer&lt;/genre&gt;<br>               &lt;price&gt;44.95&lt;/price&gt;<br>               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>               &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           &lt;/book&gt;<br>        &lt;/catalog&gt;<br>        XML<br></p><p>        // For text you do not want to contain newlines, escape them using \<br></p><p>        print( &lt;&lt;&quot;LOREM&quot; )<br>        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt \<br>        ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco \<br>        laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in \<br>        voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat \<br>        non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\<br>        LOREM<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/7b49fd11/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 10, 2016 at 06:00:00pm</p></header><div class="content"><p>These are my comments so far.<br></p><p>Regarding the use of _” and “_ : It works but I think the _ already has a meaning elsewhere and may bring just a little bit of confusion at first.  But more than that, I’m not sure I like the way it looks aesthetically.  I can’t quite explain it.  It is one character shorter than the triple quote, i.e. “””.  However, I wonder if other alternatives could work out better.  For example, here’s a couple:<br></p><p>let xml = @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>        &lt;catalog&gt;<br>           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>               &lt;author&gt;\(author)&lt;/author&gt;<br>               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>               &lt;genre&gt;Computer&lt;/genre&gt;<br>               &lt;price&gt;44.95&lt;/price&gt;<br>               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>               &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           &lt;/book&gt;<br>        &lt;/catalog&gt;&quot;@<br></p><p>and with optional continuation quote it would look like this:<br></p><p>let xml = @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>           &quot;&lt;catalog&gt;<br>           “   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>           &quot;      &lt;author&gt;\(author)&lt;/author&gt;<br>           &quot;      &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>           &quot;      &lt;genre&gt;Computer&lt;/genre&gt;<br>           &quot;      &lt;price&gt;44.95&lt;/price&gt;<br>           &quot;      &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>           &quot;      &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>           “   &lt;/book&gt;<br>           &quot;&lt;/catalog&gt;&quot;@<br></p><p>Regarding the HEREDOC notation, all I can say is that it looks heavier.  It may be more flexible, but if @“”@ looks better (in my eyes) why would we want another alternative.  I would prefer to keep the one that looks better and simpler.<br></p><p><br>&gt; On May 10, 2016, at 2:53 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve assembled a gist to summarise the main proposals of this thread.<br>&gt; <br>&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf &lt;https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf&gt;<br>&gt; <br>&gt; At the moment there seem to be four proposals for multi-line strings:<br>&gt; <br>&gt; 1) Bent’s proposal for continuation quotes where if a conventional string<br>&gt; does not close, if the first non-whitespace character of the next line is “<br>&gt; (or perhaps |) the string is continued. This gives you precise control<br>&gt; over exactly what is in the string.<br>&gt; <br>&gt; 2) Tyler&#39;s original proposal involving strings that can contain newlines<br>&gt; delimited “””like this“”” as they are in python or, _”like this“_. This works<br>&gt; well in external editors and on github. Indentation is catered for by stripping <br>&gt; any whitespace before the closing quote from all lines in the string.<br>&gt; <br>&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl <br>&gt; subject to the same indentation removal rules as “””strings””” above. This<br>&gt; has the advantage that the literal is clearly separated from your code.<br>&gt; <br>&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt; <br>&gt; (There is a separate feature that all string literals can be prefixed by<br>&gt; e as in e”\w\d+” to turn of all escape processing for another day)<br>&gt; <br>&gt; While the Swift Lexer could easily accommodate all these syntaxes there was<br>&gt; talk early on that Swift has more of a &quot;one way, maximally elegant” ethos and <br>&gt; indeed I find it difficult imagine the Swift Book breathlessly describing all three<br>&gt; formats so I’m wondering if push came to shove which format people would chose?<br>&gt; <br>&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it is<br>&gt; available sooner rather than later is.. HEREDOC! It’s well understood and<br>&gt; while at first it would seem to not be a good fit for Swift produces clear code.<br>&gt; <br>&gt; Votes?<br>&gt; <br>&gt; John<br>&gt; <br>&gt; <br>&gt;         // Multi-line string proposals<br>&gt;         // https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;<br>&gt; <br>&gt;         // swift-evolution thread:<br>&gt;         // http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133&gt;<br>&gt; <br>&gt;         // These examples should load in the prototype toolchain available here:<br>&gt;         // http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz &lt;http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz&gt;<br>&gt; <br>&gt;         // The prototype currently parses three new forms of quoting<br>&gt;         // These new types are still string literals for the grammar.<br>&gt; <br>&gt;         &quot;the existing string literal format&quot;<br>&gt;         _&quot;a format that does not require you to escape &quot; characters&quot;_ // possibly redundant<br>&gt;         &quot;&quot;&quot;a python-style syntax that will accept &quot;&#39;s and newlines in the string&quot;&quot;&quot;<br>&gt;         &lt;&lt;&quot;HEREDOC&quot;<br>&gt;         A full heredoc implementation (will always end in a newline)<br>&gt;         HEREDOC<br>&gt; <br>&gt;         // These strings can be modified by prefixing the string by letters<br>&gt;         // There is currently only one, &quot;e&quot; to disable escape processing.<br>&gt;         // This is primarily used when specifying regular expressions.<br>&gt; <br>&gt;         let str = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt; <br>&gt;         assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot; == str )<br>&gt;         assert( e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str )<br>&gt;         assert( e&quot;&quot;&quot;print(&quot;Hello, world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt; <br>&gt;         // Continuation quotes allow you to extend a standard string literal<br>&gt;         // over multiple lines. If a string does not close on a line and the<br>&gt;         // first non-whitespace character on the next line is &quot; that line<br>&gt;         // will be a contination of the string including the newline character<br>&gt;         // (unless it is escaped). Interpolation and escapes process as before<br>&gt;         // unless the first segment of the string is modified by the &quot;e&quot; prefix.<br>&gt; <br>&gt;         // The advantage of this format allows you to indent while giving<br>&gt;         // you precise control of exactly what is going into the literal.<br>&gt; <br>&gt;         let author = &quot;Gambardella, Matthew&quot;<br>&gt; <br>&gt;         let xml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;<br>&gt;             &quot;&quot;<br>&gt;         print(xml)<br>&gt; <br>&gt;         // Perhaps, to avoid the zera crossing effect in text editors due to<br>&gt;         // the unbalanced quotes, the continuation character could be &quot;|&quot;.<br>&gt;         // (newlines escaped with \ and blank lines are discarded.)<br>&gt; <br>&gt;         assert( xml == &quot;\<br>&gt;             |&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             |&lt;catalog&gt;<br>&gt;             |   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             |       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             |       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             |       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             |       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             |       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             |       &lt;description&gt;An in-depth look at creating \<br>&gt;                             |applications with XML.&lt;/description&gt;<br>&gt; <br>&gt;             |   &lt;/book&gt;<br>&gt;             |&lt;/catalog&gt;<br>&gt;             |&quot; )<br>&gt; <br>&gt; <br>&gt;         // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t require<br>&gt;         // escaping of embedded &quot; characters. Think of them as a being modifier<br>&gt;         // on conventional string literals. They support continuation quotes.<br>&gt; <br>&gt;         assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt; <br>&gt;         // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot; discussed next<br>&gt; <br>&gt;         assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;_ )<br>&gt; <br>&gt;         // The triple quoted strings can contain newlines and, unless modified by &quot;e&quot;<br>&gt;         // will process interpolations and not require escaping of &quot;. To allow indenting,<br>&gt;         // any whitespace characters that preceed the closing &quot;&quot;&quot; will be removed from <br>&gt;         // each line of the final literal. A warning is shown if lines do not contain<br>&gt;         // the exact same indentation characters. Any intial linefeed is also removed.<br>&gt; <br>&gt;         // The advantage of this format is the &quot;&quot;&quot; introducer works well when syntax<br>&gt;         // highlighting in external editors and github as quotes are always balanced.<br>&gt; <br>&gt;         assert( xml == &quot;&quot;&quot;<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br>&gt; <br>&gt;         assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br>&gt; <br>&gt;         // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39; (non-escaping, &quot;e&quot; prefix)<br>&gt;         // It applies the same indentation removal rules as does &quot;&quot;&quot;. This change has wider<br>&gt;         // ramifications for the toolchain as compiler tokens are no longer in file order<br>&gt;         // and will take a while for a few problems to be ironed out. The more consistent<br>&gt;         // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39; for non-escaping strings.<br>&gt; <br>&gt;         // HEREDOC&#39;s advantage is that the literal no longer interrupts the flow of your code.<br>&gt; <br>&gt;         assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml )<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt; <br>&gt;         // For text you do not want to contain newlines, escape them using \<br>&gt; <br>&gt;         print( &lt;&lt;&quot;LOREM&quot; )<br>&gt;         Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt \<br>&gt;         ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco \<br>&gt;         laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in \<br>&gt;         voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat \<br>&gt;         non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\<br>&gt;         LOREM<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/b3f888d4/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 05:00:00pm</p></header><div class="content"><p>Did I miss the proposal for single quote?<br></p><p>Just found on <br>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br> &gt;---------------------&lt;<br>Single-quotes &#39;&#39; for Character literals: Swift takes the approach of highly <br>valuing Unicode. However, there are multiple concepts of a character that <br>could make sense in Unicode, and none is so much more commonly used than <br>the others that it makes sense to privilege them. We&#39;d rather save single <br>quoted literals for a greater purpose (e.g. non-escaped string literals).<br> &gt;---------------------&lt;<br></p><p>So, what about using of single quote as &quot;special&quot; strings?<br></p><p>For example, I&#39;d propose to use single quote quotation to say &quot;this string <br>should be used as-is, no escapes processing&quot;<br></p><p>&#39;some 1\total\\2\\\3 &quot;sdfsdf&quot; \(-: &quot;&quot;&quot; helllooo&#39;<br></p><p>the only &#39;disallowed&#39; symbol could be the single quote itself, but I <br>propose the solution used in other languages - duplicate it if we need it <br>in string:<br></p><p>&#39;this &#39;&#39; is a single quote in string, and this is another&#39;&#39;&#39;<br></p><p>and also in multiline strings:<br></p><p>assert( xml == &#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	&#39;&lt;catalog&gt;<br>	&#39;	&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>	&#39;		&lt;author&gt;\(author)&lt;/author&gt;<br>	// note &#39;&#39; here in string<br>	&#39;		&lt;title&gt;XML Developer&#39;&#39;s Guide&lt;/title&gt;<br>	&#39;		&lt;genre&gt;Computer&lt;/genre&gt;<br>	&#39;		&lt;price&gt;44.95&lt;/price&gt;<br>	&#39;		&lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>	&#39;		&lt;description&gt;An in-depth look at XML.&lt;/description&gt;<br>	&#39;	&lt;/book&gt;<br>	&#39;&lt;/catalog&gt;&#39;)<br></p><p>(also needs to duplicate single quote if in text. the compromise, yes.)<br></p><p>On 10.05.2016 9:53, John Holdsworth via swift-evolution wrote:<br>&gt; I’ve assembled a gist to summarise the main proposals of this thread.<br>&gt;<br>&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br>&gt;<br>&gt; At the moment there seem to be four proposals for multi-line strings:<br>&gt;<br>&gt; 1) Bent’s proposal for continuation quotes where if a conventional string<br>&gt; does not close, if the first non-whitespace character of the next line is “<br>&gt; (or perhaps |) the string is continued. This gives you precise control<br>&gt; over exactly what is in the string.<br>&gt;<br>&gt; 2) Tyler&#39;s original proposal involving strings that can contain newlines<br>&gt; delimited “””like this“”” as they are in python or, _”like this“_. This works<br>&gt; well in external editors and on github. Indentation is catered for by<br>&gt; stripping<br>&gt; any whitespace before the closing quote from all lines in the string.<br>&gt;<br>&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl<br>&gt; subject to the same indentation removal rules as “””strings””” above. This<br>&gt; has the advantage that the literal is clearly separated from your code.<br>&gt;<br>&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt;<br>&gt; (There is a separate feature that all string literals can be prefixed by<br>&gt; e as in e”\w\d+” to turn of all escape processing for another day)<br>&gt;<br>&gt; While the Swift Lexer could easily accommodate all these syntaxes there was<br>&gt; talk early on that Swift has more of a &quot;one way, maximally elegant” ethos and<br>&gt; indeed I find it difficult imagine the Swift Book breathlessly describing<br>&gt; all three<br>&gt; formats so I’m wondering if push came to shove which format people would chose?<br>&gt;<br>&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it is<br>&gt; available sooner rather than later is.. HEREDOC! It’s well understood and<br>&gt; while at first it would seem to not be a good fit for Swift produces clear<br>&gt; code.<br>&gt;<br>&gt; Votes?<br>&gt;<br>&gt; John<br>&gt;<br>&gt;<br>&gt;         // Multi-line string proposals<br>&gt;         // https://github.com/apple/swift/pull/2275<br>&gt;<br>&gt;         // swift-evolution thread:<br>&gt;         //<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>&gt;<br>&gt;         // These examples should load in the prototype toolchain available<br>&gt; here:<br>&gt;         // http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz<br>&gt;<br>&gt;         // The prototype currently parses three new forms of quoting<br>&gt;         // These new types are still string literals for the grammar.<br>&gt;<br>&gt;         &quot;the existing string literal format&quot;<br>&gt;         _&quot;a format that does not require you to escape &quot; characters&quot;_ //<br>&gt; possibly redundant<br>&gt;         &quot;&quot;&quot;a python-style syntax that will accept &quot;&#39;s and newlines in the<br>&gt; string&quot;&quot;&quot;<br>&gt;         &lt;&lt;&quot;HEREDOC&quot;<br>&gt;         A full heredoc implementation (will always end in a newline)<br>&gt;         HEREDOC<br>&gt;<br>&gt;         // These strings can be modified by prefixing the string by letters<br>&gt;         // There is currently only one, &quot;e&quot; to disable escape processing.<br>&gt;         // This is primarily used when specifying regular expressions.<br>&gt;<br>&gt;         letstr = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt;<br>&gt;         assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot;== str )<br>&gt;         assert( e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str )<br>&gt;         assert( e&quot;&quot;&quot;print(&quot;Hello, world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt;<br>&gt;         // Continuation quotes allow you to extend a standard string literal<br>&gt;         // over multiple lines. If a string does not close on a line and the<br>&gt;         // first non-whitespace character on the next line is &quot; that line<br>&gt;         // will be a contination of the string including the newline character<br>&gt;         // (unless it is escaped). Interpolation and escapes process as before<br>&gt;         // unless the first segment of the string is modified by the &quot;e&quot;<br>&gt; prefix.<br>&gt;<br>&gt;         // The advantage of this format allows you to indent while giving<br>&gt;         // you precise control of exactly what is going into the literal.<br>&gt;<br>&gt;         letauthor = &quot;Gambardella, Matthew&quot;<br>&gt;<br>&gt;         letxml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt; with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;<br>&gt;             &quot;&quot;<br>&gt;         print(xml)<br>&gt;<br>&gt;         // Perhaps, to avoid the zera crossing effect in text editors due to<br>&gt;         // the unbalanced quotes, the continuation character could be &quot;|&quot;.<br>&gt;         // (newlines escaped with \ and blank lines are discarded.)<br>&gt;<br>&gt;         assert( xml == &quot;\<br>&gt;             |&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;             |&lt;catalog&gt;<br>&gt;             |   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;             |       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             |       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             |       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             |       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             |       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             |       &lt;description&gt;An in-depth look at creating \<br>&gt;                             |applications with XML.&lt;/description&gt;<br>&gt;<br>&gt;             |   &lt;/book&gt;<br>&gt;             |&lt;/catalog&gt;<br>&gt;             |&quot;)<br>&gt;<br>&gt;<br>&gt;         // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t require<br>&gt;         // escaping of embedded &quot; characters. Think of them as a being modifier<br>&gt;         // on conventional string literals. They support continuation quotes.<br>&gt;<br>&gt;         assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &quot;&lt;catalog&gt;<br>&gt;             &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;             &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;             &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;             &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;             &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;             &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;             &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt; with XML.&lt;/description&gt;<br>&gt;             &quot;   &lt;/book&gt;<br>&gt;             &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt;<br>&gt;         // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot;<br>&gt; discussed next<br>&gt;<br>&gt;         assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications<br>&gt; with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;_ )<br>&gt;<br>&gt;         // The triple quoted strings can contain newlines and, unless<br>&gt; modified by &quot;e&quot;<br>&gt;         // will process interpolations and not require escaping of &quot;. To<br>&gt; allow indenting,<br>&gt;         // any whitespace characters that preceed the closing &quot;&quot;&quot; will be<br>&gt; removed from<br>&gt;         // each line of the final literal. A warning is shown if lines do<br>&gt; not contain<br>&gt;         // the exact same indentation characters. Any intial linefeed is<br>&gt; also removed.<br>&gt;<br>&gt;         // The advantage of this format is the &quot;&quot;&quot; introducer works well<br>&gt; when syntax<br>&gt;         // highlighting in external editors and github as quotes are always<br>&gt; balanced.<br>&gt;<br>&gt;         assert( xml == &quot;&quot;&quot;<br>&gt;             &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications<br>&gt; with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br>&gt;<br>&gt;         assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications<br>&gt; with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br>&gt;<br>&gt;         // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39;<br>&gt; (non-escaping, &quot;e&quot; prefix)<br>&gt;         // It applies the same indentation removal rules as does &quot;&quot;&quot;. This<br>&gt; change has wider<br>&gt;         // ramifications for the toolchain as compiler tokens are no longer<br>&gt; in file order<br>&gt;         // and will take a while for a few problems to be ironed out. The<br>&gt; more consistent<br>&gt;         // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39; for<br>&gt; non-escaping strings.<br>&gt;<br>&gt;         // HEREDOC&#39;s advantage is that the literal no longer interrupts the<br>&gt; flow of your code.<br>&gt;<br>&gt;         assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml )<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with<br>&gt; XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with<br>&gt; XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt;<br>&gt;         // For text you do not want to contain newlines, escape them using \<br>&gt;<br>&gt;         print( &lt;&lt;&quot;LOREM&quot; )<br>&gt;         Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do<br>&gt; eiusmod tempor incididunt \<br>&gt;         ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis<br>&gt; nostrud exercitation ullamco \<br>&gt;         laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure<br>&gt; dolor in reprehenderit in \<br>&gt;         voluptate velit esse cillum dolore eu fugiat nulla pariatur.<br>&gt; Excepteur sint occaecat cupidatat \<br>&gt;         non proident, sunt in culpa qui officia deserunt mollit anim id est<br>&gt; laborum.\<br>&gt;         LOREM<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 11, 2016 at 12:00:00pm</p></header><div class="content"><p>I did not suggest the single quote because it is commonly found in the English language and we would have to escape it.  <br></p><p>That is why I suggested a rare combination using the @&quot; and &quot;@ as the delimiters. Unless your text is Obj-C code it would be rare to find it. <br></p><p><br>&gt; On May 11, 2016, at 10:50 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Did I miss the proposal for single quote?<br>&gt; <br>&gt; Just found on https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt; &gt;---------------------&lt;<br>&gt; Single-quotes &#39;&#39; for Character literals: Swift takes the approach of highly valuing Unicode. However, there are multiple concepts of a character that could make sense in Unicode, and none is so much more commonly used than the others that it makes sense to privilege them. We&#39;d rather save single quoted literals for a greater purpose (e.g. non-escaped string literals).<br>&gt; &gt;---------------------&lt;<br>&gt; <br>&gt; So, what about using of single quote as &quot;special&quot; strings?<br>&gt; <br>&gt; For example, I&#39;d propose to use single quote quotation to say &quot;this string should be used as-is, no escapes processing&quot;<br>&gt; <br>&gt; &#39;some 1\total\\2\\\3 &quot;sdfsdf&quot; \(-: &quot;&quot;&quot; helllooo&#39;<br>&gt; <br>&gt; the only &#39;disallowed&#39; symbol could be the single quote itself, but I propose the solution used in other languages - duplicate it if we need it in string:<br>&gt; <br>&gt; &#39;this &#39;&#39; is a single quote in string, and this is another&#39;&#39;&#39;<br>&gt; <br>&gt; and also in multiline strings:<br>&gt; <br>&gt; assert( xml == &#39;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;    &#39;&lt;catalog&gt;<br>&gt;    &#39;    &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;    &#39;        &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;    // note &#39;&#39; here in string<br>&gt;    &#39;        &lt;title&gt;XML Developer&#39;&#39;s Guide&lt;/title&gt;<br>&gt;    &#39;        &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;    &#39;        &lt;price&gt;44.95&lt;/price&gt;<br>&gt;    &#39;        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;    &#39;        &lt;description&gt;An in-depth look at XML.&lt;/description&gt;<br>&gt;    &#39;    &lt;/book&gt;<br>&gt;    &#39;&lt;/catalog&gt;&#39;)<br>&gt; <br>&gt; (also needs to duplicate single quote if in text. the compromise, yes.)<br>&gt; <br>&gt;&gt; On 10.05.2016 9:53, John Holdsworth via swift-evolution wrote:<br>&gt;&gt; I’ve assembled a gist to summarise the main proposals of this thread.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br>&gt;&gt; <br>&gt;&gt; At the moment there seem to be four proposals for multi-line strings:<br>&gt;&gt; <br>&gt;&gt; 1) Bent’s proposal for continuation quotes where if a conventional string<br>&gt;&gt; does not close, if the first non-whitespace character of the next line is “<br>&gt;&gt; (or perhaps |) the string is continued. This gives you precise control<br>&gt;&gt; over exactly what is in the string.<br>&gt;&gt; <br>&gt;&gt; 2) Tyler&#39;s original proposal involving strings that can contain newlines<br>&gt;&gt; delimited “””like this“”” as they are in python or, _”like this“_. This works<br>&gt;&gt; well in external editors and on github. Indentation is catered for by<br>&gt;&gt; stripping<br>&gt;&gt; any whitespace before the closing quote from all lines in the string.<br>&gt;&gt; <br>&gt;&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl<br>&gt;&gt; subject to the same indentation removal rules as “””strings””” above. This<br>&gt;&gt; has the advantage that the literal is clearly separated from your code.<br>&gt;&gt; <br>&gt;&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt;&gt; <br>&gt;&gt; (There is a separate feature that all string literals can be prefixed by<br>&gt;&gt; e as in e”\w\d+” to turn of all escape processing for another day)<br>&gt;&gt; <br>&gt;&gt; While the Swift Lexer could easily accommodate all these syntaxes there was<br>&gt;&gt; talk early on that Swift has more of a &quot;one way, maximally elegant” ethos and<br>&gt;&gt; indeed I find it difficult imagine the Swift Book breathlessly describing<br>&gt;&gt; all three<br>&gt;&gt; formats so I’m wondering if push came to shove which format people would chose?<br>&gt;&gt; <br>&gt;&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it is<br>&gt;&gt; available sooner rather than later is.. HEREDOC! It’s well understood and<br>&gt;&gt; while at first it would seem to not be a good fit for Swift produces clear<br>&gt;&gt; code.<br>&gt;&gt; <br>&gt;&gt; Votes?<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        // Multi-line string proposals<br>&gt;&gt;        // https://github.com/apple/swift/pull/2275<br>&gt;&gt; <br>&gt;&gt;        // swift-evolution thread:<br>&gt;&gt;        //<br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>&gt;&gt; <br>&gt;&gt;        // These examples should load in the prototype toolchain available<br>&gt;&gt; here:<br>&gt;&gt;        // http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz<br>&gt;&gt; <br>&gt;&gt;        // The prototype currently parses three new forms of quoting<br>&gt;&gt;        // These new types are still string literals for the grammar.<br>&gt;&gt; <br>&gt;&gt;        &quot;the existing string literal format&quot;<br>&gt;&gt;        _&quot;a format that does not require you to escape &quot; characters&quot;_ //<br>&gt;&gt; possibly redundant<br>&gt;&gt;        &quot;&quot;&quot;a python-style syntax that will accept &quot;&#39;s and newlines in the<br>&gt;&gt; string&quot;&quot;&quot;<br>&gt;&gt;        &lt;&lt;&quot;HEREDOC&quot;<br>&gt;&gt;        A full heredoc implementation (will always end in a newline)<br>&gt;&gt;        HEREDOC<br>&gt;&gt; <br>&gt;&gt;        // These strings can be modified by prefixing the string by letters<br>&gt;&gt;        // There is currently only one, &quot;e&quot; to disable escape processing.<br>&gt;&gt;        // This is primarily used when specifying regular expressions.<br>&gt;&gt; <br>&gt;&gt;        letstr = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt;&gt; <br>&gt;&gt;        assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot;== str )<br>&gt;&gt;        assert( e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str )<br>&gt;&gt;        assert( e&quot;&quot;&quot;print(&quot;Hello, world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt;&gt; <br>&gt;&gt;        // Continuation quotes allow you to extend a standard string literal<br>&gt;&gt;        // over multiple lines. If a string does not close on a line and the<br>&gt;&gt;        // first non-whitespace character on the next line is &quot; that line<br>&gt;&gt;        // will be a contination of the string including the newline character<br>&gt;&gt;        // (unless it is escaped). Interpolation and escapes process as before<br>&gt;&gt;        // unless the first segment of the string is modified by the &quot;e&quot;<br>&gt;&gt; prefix.<br>&gt;&gt; <br>&gt;&gt;        // The advantage of this format allows you to indent while giving<br>&gt;&gt;        // you precise control of exactly what is going into the literal.<br>&gt;&gt; <br>&gt;&gt;        letauthor = &quot;Gambardella, Matthew&quot;<br>&gt;&gt; <br>&gt;&gt;        letxml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;            &quot;&lt;catalog&gt;<br>&gt;&gt;            &quot;   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;            &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with XML.&lt;/description&gt;<br>&gt;&gt;            &quot;   &lt;/book&gt;<br>&gt;&gt;            &quot;&lt;/catalog&gt;<br>&gt;&gt;            &quot;&quot;<br>&gt;&gt;        print(xml)<br>&gt;&gt; <br>&gt;&gt;        // Perhaps, to avoid the zera crossing effect in text editors due to<br>&gt;&gt;        // the unbalanced quotes, the continuation character could be &quot;|&quot;.<br>&gt;&gt;        // (newlines escaped with \ and blank lines are discarded.)<br>&gt;&gt; <br>&gt;&gt;        assert( xml == &quot;\<br>&gt;&gt;            |&lt;?xml version=\&quot;1.0\&quot;?&gt;<br>&gt;&gt;            |&lt;catalog&gt;<br>&gt;&gt;            |   &lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;<br>&gt;&gt;            |       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;            |       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;            |       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;            |       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;            |       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;            |       &lt;description&gt;An in-depth look at creating \<br>&gt;&gt;                            |applications with XML.&lt;/description&gt;<br>&gt;&gt; <br>&gt;&gt;            |   &lt;/book&gt;<br>&gt;&gt;            |&lt;/catalog&gt;<br>&gt;&gt;            |&quot;)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t require<br>&gt;&gt;        // escaping of embedded &quot; characters. Think of them as a being modifier<br>&gt;&gt;        // on conventional string literals. They support continuation quotes.<br>&gt;&gt; <br>&gt;&gt;        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;            &quot;&lt;catalog&gt;<br>&gt;&gt;            &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;            &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;            &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;            &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;            &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;            &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;            &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with XML.&lt;/description&gt;<br>&gt;&gt;            &quot;   &lt;/book&gt;<br>&gt;&gt;            &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt;&gt; <br>&gt;&gt;        // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot;<br>&gt;&gt; discussed next<br>&gt;&gt; <br>&gt;&gt;        assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;            &lt;catalog&gt;<br>&gt;&gt;               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                   &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                   &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                   &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                   &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with XML.&lt;/description&gt;<br>&gt;&gt;               &lt;/book&gt;<br>&gt;&gt;            &lt;/catalog&gt;<br>&gt;&gt;            &quot;_ )<br>&gt;&gt; <br>&gt;&gt;        // The triple quoted strings can contain newlines and, unless<br>&gt;&gt; modified by &quot;e&quot;<br>&gt;&gt;        // will process interpolations and not require escaping of &quot;. To<br>&gt;&gt; allow indenting,<br>&gt;&gt;        // any whitespace characters that preceed the closing &quot;&quot;&quot; will be<br>&gt;&gt; removed from<br>&gt;&gt;        // each line of the final literal. A warning is shown if lines do<br>&gt;&gt; not contain<br>&gt;&gt;        // the exact same indentation characters. Any intial linefeed is<br>&gt;&gt; also removed.<br>&gt;&gt; <br>&gt;&gt;        // The advantage of this format is the &quot;&quot;&quot; introducer works well<br>&gt;&gt; when syntax<br>&gt;&gt;        // highlighting in external editors and github as quotes are always<br>&gt;&gt; balanced.<br>&gt;&gt; <br>&gt;&gt;        assert( xml == &quot;&quot;&quot;<br>&gt;&gt;            &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;            &lt;catalog&gt;<br>&gt;&gt;               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                   &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                   &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                   &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                   &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with XML.&lt;/description&gt;<br>&gt;&gt;               &lt;/book&gt;<br>&gt;&gt;            &lt;/catalog&gt;<br>&gt;&gt;            &quot;&quot;&quot; )<br>&gt;&gt; <br>&gt;&gt;        assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;            &lt;catalog&gt;<br>&gt;&gt;               &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;                   &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;                   &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;                   &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;                   &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;                   &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;                   &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with XML.&lt;/description&gt;<br>&gt;&gt;               &lt;/book&gt;<br>&gt;&gt;            &lt;/catalog&gt;<br>&gt;&gt;            &quot;&quot;&quot; )<br>&gt;&gt; <br>&gt;&gt;        // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39;<br>&gt;&gt; (non-escaping, &quot;e&quot; prefix)<br>&gt;&gt;        // It applies the same indentation removal rules as does &quot;&quot;&quot;. This<br>&gt;&gt; change has wider<br>&gt;&gt;        // ramifications for the toolchain as compiler tokens are no longer<br>&gt;&gt; in file order<br>&gt;&gt;        // and will take a while for a few problems to be ironed out. The<br>&gt;&gt; more consistent<br>&gt;&gt;        // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39; for<br>&gt;&gt; non-escaping strings.<br>&gt;&gt; <br>&gt;&gt;        // HEREDOC&#39;s advantage is that the literal no longer interrupts the<br>&gt;&gt; flow of your code.<br>&gt;&gt; <br>&gt;&gt;        assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml )<br>&gt;&gt;        &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;        &lt;catalog&gt;<br>&gt;&gt;           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;               &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;               &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;               &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;               &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt; XML.&lt;/description&gt;<br>&gt;&gt;           &lt;/book&gt;<br>&gt;&gt;        &lt;/catalog&gt;<br>&gt;&gt;        XML<br>&gt;&gt;        &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;        &lt;catalog&gt;<br>&gt;&gt;           &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;               &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;               &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;               &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;               &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;               &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;               &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt; XML.&lt;/description&gt;<br>&gt;&gt;           &lt;/book&gt;<br>&gt;&gt;        &lt;/catalog&gt;<br>&gt;&gt;        XML<br>&gt;&gt; <br>&gt;&gt;        // For text you do not want to contain newlines, escape them using \<br>&gt;&gt; <br>&gt;&gt;        print( &lt;&lt;&quot;LOREM&quot; )<br>&gt;&gt;        Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do<br>&gt;&gt; eiusmod tempor incididunt \<br>&gt;&gt;        ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis<br>&gt;&gt; nostrud exercitation ullamco \<br>&gt;&gt;        laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure<br>&gt;&gt; dolor in reprehenderit in \<br>&gt;&gt;        voluptate velit esse cillum dolore eu fugiat nulla pariatur.<br>&gt;&gt; Excepteur sint occaecat cupidatat \<br>&gt;&gt;        non proident, sunt in culpa qui officia deserunt mollit anim id est<br>&gt;&gt; laborum.\<br>&gt;&gt;        LOREM<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 07:00:00pm</p></header><div class="content"><p>On 11.05.2016 19:38, Ricardo Parada wrote:<br>&gt; I did not suggest the single quote because it is commonly found in the<br>&gt; English language and we would have to escape it.<br></p><p>Wel.. in your document you have a number of variants of multi-line <br>&#39;feature&#39; implementations with different pros/cons for each.<br></p><p>Could you clarify, why this proposal with single quote can not be inside <br>your document as just another variant with its own pros/cons ? Especially, <br>as you can see, if &quot;We&#39;d rather save single quoted literals for a greater <br>purpose (e.g. non-escaped string literals)&quot; ?<br></p><p>&gt;<br>&gt; That is why I suggested a rare combination using the @&quot; and &quot;@ as the<br>&gt; delimiters. Unless your text is Obj-C code it would be rare to find it.<br>&gt;<br></p><p>And what do you suggest to do if we *have* `&quot;@` inside the text we want to <br>use ?<br></p><p>&gt;<br>&gt;<br>&gt;&gt; On May 11, 2016, at 10:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Did I miss the proposal for single quote?<br>&gt;&gt;<br>&gt;&gt; Just found on<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;&gt;&gt;<br>&gt;&gt;<br>---------------------&lt;<br>&gt;&gt; Single-quotes &#39;&#39; for Character literals: Swift takes the approach of<br>&gt;&gt; highly valuing Unicode. However, there are multiple concepts of a<br>&gt;&gt; character that could make sense in Unicode, and none is so much more<br>&gt;&gt; commonly used than the others that it makes sense to privilege them.<br>&gt;&gt; We&#39;d rather save single quoted literals for a greater purpose (e.g.<br>&gt;&gt; non-escaped string literals).<br>&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;<br>&gt;&gt; So, what about using of single quote as &quot;special&quot; strings?<br>&gt;&gt;<br>&gt;&gt; For example, I&#39;d propose to use single quote quotation to say &quot;this<br>&gt;&gt; string should be used as-is, no escapes processing&quot;<br>&gt;&gt;<br>&gt;&gt; &#39;some 1\total\\2\\\3 &quot;sdfsdf&quot; \(-: &quot;&quot;&quot; helllooo&#39;<br>&gt;&gt;<br>&gt;&gt; the only &#39;disallowed&#39; symbol could be the single quote itself, but I<br>&gt;&gt; propose the solution used in other languages - duplicate it if we need<br>&gt;&gt; it in string:<br>&gt;&gt;<br>&gt;&gt; &#39;this &#39;&#39; is a single quote in string, and this is another&#39;&#39;&#39;<br>&gt;&gt;<br>&gt;&gt; and also in multiline strings:<br>&gt;&gt;<br>&gt;&gt; assert( xml == &#39;&lt;?xml version=&quot;1.0&quot;?&gt; &#39;&lt;catalog&gt; &#39;    &lt;book id=&quot;bk101&quot;<br>&gt;&gt; empty=&quot;&quot;&gt; &#39;        &lt;author&gt;\(author)&lt;/author&gt; // note &#39;&#39; here in<br>&gt;&gt; string &#39;        &lt;title&gt;XML Developer&#39;&#39;s Guide&lt;/title&gt; &#39;<br>&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &#39;        &lt;price&gt;44.95&lt;/price&gt; &#39;<br>&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &#39;        &lt;description&gt;An<br>&gt;&gt; in-depth look at XML.&lt;/description&gt; &#39;    &lt;/book&gt; &#39;&lt;/catalog&gt;&#39;)<br>&gt;&gt;<br>&gt;&gt; (also needs to duplicate single quote if in text. the compromise,<br>&gt;&gt; yes.)<br>&gt;&gt;<br>&gt;&gt;&gt; On 10.05.2016 9:53, John Holdsworth via swift-evolution wrote: I’ve<br>&gt;&gt;&gt; assembled a gist to summarise the main proposals of this thread.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At the moment there seem to be four proposals for multi-line<br>&gt;&gt;&gt; strings:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) Bent’s proposal for continuation quotes where if a conventional<br>&gt;&gt;&gt; string does not close, if the first non-whitespace character of the<br>&gt;&gt;&gt; next line is “ (or perhaps |) the string is continued. This gives<br>&gt;&gt;&gt; you precise control over exactly what is in the string.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2) Tyler&#39;s original proposal involving strings that can contain<br>&gt;&gt;&gt; newlines delimited “””like this“”” as they are in python or, _”like<br>&gt;&gt;&gt; this“_. This works well in external editors and on github.<br>&gt;&gt;&gt; Indentation is catered for by stripping any whitespace before the<br>&gt;&gt;&gt; closing quote from all lines in the string.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl<br>&gt;&gt;&gt; subject to the same indentation removal rules as “””strings”””<br>&gt;&gt;&gt; above. This has the advantage that the literal is clearly separated<br>&gt;&gt;&gt; from your code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (There is a separate feature that all string literals can be<br>&gt;&gt;&gt; prefixed by e as in e”\w\d+” to turn of all escape processing for<br>&gt;&gt;&gt; another day)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While the Swift Lexer could easily accommodate all these syntaxes<br>&gt;&gt;&gt; there was talk early on that Swift has more of a &quot;one way, maximally<br>&gt;&gt;&gt; elegant” ethos and indeed I find it difficult imagine the Swift Book<br>&gt;&gt;&gt; breathlessly describing all three formats so I’m wondering if push<br>&gt;&gt;&gt; came to shove which format people would chose?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it<br>&gt;&gt;&gt; is available sooner rather than later is.. HEREDOC! It’s well<br>&gt;&gt;&gt; understood and while at first it would seem to not be a good fit for<br>&gt;&gt;&gt; Swift produces clear code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Votes?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Multi-line string proposals //<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // swift-evolution thread: //<br>&gt;&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>// These examples should load in the prototype toolchain available<br>&gt;&gt;&gt; here: //<br>&gt;&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The prototype currently parses three new forms of quoting //<br>&gt;&gt;&gt; These new types are still string literals for the grammar.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;the existing string literal format&quot; _&quot;a format that does not<br>&gt;&gt;&gt; require you to escape &quot; characters&quot;_ // possibly redundant &quot;&quot;&quot;a<br>&gt;&gt;&gt; python-style syntax that will accept &quot;&#39;s and newlines in the<br>&gt;&gt;&gt; string&quot;&quot;&quot; &lt;&lt;&quot;HEREDOC&quot; A full heredoc implementation (will always end<br>&gt;&gt;&gt; in a newline) HEREDOC<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // These strings can be modified by prefixing the string by letters<br>&gt;&gt;&gt; // There is currently only one, &quot;e&quot; to disable escape processing. //<br>&gt;&gt;&gt; This is primarily used when specifying regular expressions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; letstr = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot;== str ) assert(<br>&gt;&gt;&gt; e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str ) assert( e&quot;&quot;&quot;print(&quot;Hello,<br>&gt;&gt;&gt; world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Continuation quotes allow you to extend a standard string<br>&gt;&gt;&gt; literal // over multiple lines. If a string does not close on a line<br>&gt;&gt;&gt; and the // first non-whitespace character on the next line is &quot; that<br>&gt;&gt;&gt; line // will be a contination of the string including the newline<br>&gt;&gt;&gt; character // (unless it is escaped). Interpolation and escapes<br>&gt;&gt;&gt; process as before // unless the first segment of the string is<br>&gt;&gt;&gt; modified by the &quot;e&quot; prefix.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The advantage of this format allows you to indent while giving //<br>&gt;&gt;&gt; you precise control of exactly what is going into the literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; letauthor = &quot;Gambardella, Matthew&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; letxml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt; empty=\&quot;\&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;       &lt;title&gt;XML<br>&gt;&gt;&gt; Developer&#39;s Guide&lt;/title&gt; &quot;       &lt;genre&gt;Computer&lt;/genre&gt; &quot;<br>&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt; &quot;&quot; print(xml)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Perhaps, to avoid the zera crossing effect in text editors due<br>&gt;&gt;&gt; to // the unbalanced quotes, the continuation character could be<br>&gt;&gt;&gt; &quot;|&quot;. // (newlines escaped with \ and blank lines are discarded.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( xml == &quot;\ |&lt;?xml version=\&quot;1.0\&quot;?&gt; |&lt;catalog&gt; |   &lt;book<br>&gt;&gt;&gt; id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt; |       &lt;author&gt;\(author)&lt;/author&gt; |<br>&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; |<br>&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; |       &lt;price&gt;44.95&lt;/price&gt; |<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; |       &lt;description&gt;An<br>&gt;&gt;&gt; in-depth look at creating \ |applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; |   &lt;/book&gt; |&lt;/catalog&gt; |&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t<br>&gt;&gt;&gt; require // escaping of embedded &quot; characters. Think of them as a<br>&gt;&gt;&gt; being modifier // on conventional string literals. They support<br>&gt;&gt;&gt; continuation quotes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book<br>&gt;&gt;&gt; id=&quot;bk101&quot; empty=&quot;&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;<br>&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &quot;<br>&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &quot;       &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot;<br>&gt;&gt;&gt; discussed next<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt; &quot;_ )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The triple quoted strings can contain newlines and, unless<br>&gt;&gt;&gt; modified by &quot;e&quot; // will process interpolations and not require<br>&gt;&gt;&gt; escaping of &quot;. To allow indenting, // any whitespace characters that<br>&gt;&gt;&gt; preceed the closing &quot;&quot;&quot; will be removed from // each line of the<br>&gt;&gt;&gt; final literal. A warning is shown if lines do not contain // the<br>&gt;&gt;&gt; exact same indentation characters. Any intial linefeed is also<br>&gt;&gt;&gt; removed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // The advantage of this format is the &quot;&quot;&quot; introducer works well<br>&gt;&gt;&gt; when syntax // highlighting in external editors and github as quotes<br>&gt;&gt;&gt; are always balanced.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( xml == &quot;&quot;&quot; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt; (non-escaping, &quot;e&quot; prefix) // It applies the same indentation<br>&gt;&gt;&gt; removal rules as does &quot;&quot;&quot;. This change has wider // ramifications<br>&gt;&gt;&gt; for the toolchain as compiler tokens are no longer in file order //<br>&gt;&gt;&gt; and will take a while for a few problems to be ironed out. The more<br>&gt;&gt;&gt; consistent // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt; for non-escaping strings.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // HEREDOC&#39;s advantage is that the literal no longer interrupts the<br>&gt;&gt;&gt; flow of your code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml ) &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // For text you do not want to contain newlines, escape them using<br>&gt;&gt;&gt; \<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; print( &lt;&lt;&quot;LOREM&quot; ) Lorem ipsum dolor sit amet, consectetur<br>&gt;&gt;&gt; adipiscing elit, sed do eiusmod tempor incididunt \ ut labore et<br>&gt;&gt;&gt; dolore magna aliqua. Ut enim ad minim veniam, quis nostrud<br>&gt;&gt;&gt; exercitation ullamco \ laboris nisi ut aliquip ex ea commodo<br>&gt;&gt;&gt; consequat. Duis aute irure dolor in reprehenderit in \ voluptate<br>&gt;&gt;&gt; velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint<br>&gt;&gt;&gt; occaecat cupidatat \ non proident, sunt in culpa qui officia<br>&gt;&gt;&gt; deserunt mollit anim id est laborum.\ LOREM<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 11, 2016, at 12:55 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 11.05.2016 19:38, Ricardo Parada wrote:<br>&gt;&gt; I did not suggest the single quote because it is commonly found in the<br>&gt;&gt; English language and we would have to escape it.<br>&gt; <br>&gt; Wel.. in your document you have a number of variants of multi-line &#39;feature&#39; implementations with different pros/cons for each.<br></p><p>I don’t have a document.  I’ve seen different proposals.  <br>I have just been commenting on the proposals in this thread.<br></p><p>&gt; Could you clarify, why this proposal with single quote can not be inside your document as just another variant with its own pros/cons ? Especially, as you can see, if &quot;We&#39;d rather save single quoted literals for a greater purpose (e.g. non-escaped string literals)” ?<br></p><p>I cannot speak for them, but I think that if we want to get a feel about which alternatives get the most traction, I think all alternatives should be considered, including yours and mine.  :-)<br></p><p>&gt;&gt; <br>&gt;&gt; That is why I suggested a rare combination using the @&quot; and &quot;@ as the<br>&gt;&gt; delimiters. Unless your text is Obj-C code it would be rare to find it.<br>&gt;&gt; <br></p><p>I don’t think we need to worry about the opening quote occurring in the text because we just need the closing delimiter to find out where it ends.  For example:<br></p><p><br>let sourceCode = @“NSString *firstName = @“John”;<br>                  &quot;NSString *lastName = @“Doe”;<br>                  “NSString *fullName = [NSString stringWithFormat: @“%@ %@“, firstName, lastName];&quot;@<br></p><p>The one that would be a bit of a problem is the closing delimiter,<br></p><p><br>&gt; <br>&gt; And what do you suggest to do if we *have* `&quot;@` inside the text we want to use ?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 10:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did I miss the proposal for single quote?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just found on<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; ---------------------&lt;<br>&gt;&gt;&gt; Single-quotes &#39;&#39; for Character literals: Swift takes the approach of<br>&gt;&gt;&gt; highly valuing Unicode. However, there are multiple concepts of a<br>&gt;&gt;&gt; character that could make sense in Unicode, and none is so much more<br>&gt;&gt;&gt; commonly used than the others that it makes sense to privilege them.<br>&gt;&gt;&gt; We&#39;d rather save single quoted literals for a greater purpose (e.g.<br>&gt;&gt;&gt; non-escaped string literals).<br>&gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, what about using of single quote as &quot;special&quot; strings?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, I&#39;d propose to use single quote quotation to say &quot;this<br>&gt;&gt;&gt; string should be used as-is, no escapes processing&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;some 1\total\\2\\\3 &quot;sdfsdf&quot; \(-: &quot;&quot;&quot; helllooo&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the only &#39;disallowed&#39; symbol could be the single quote itself, but I<br>&gt;&gt;&gt; propose the solution used in other languages - duplicate it if we need<br>&gt;&gt;&gt; it in string:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &#39;this &#39;&#39; is a single quote in string, and this is another&#39;&#39;&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and also in multiline strings:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; assert( xml == &#39;&lt;?xml version=&quot;1.0&quot;?&gt; &#39;&lt;catalog&gt; &#39;    &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt; empty=&quot;&quot;&gt; &#39;        &lt;author&gt;\(author)&lt;/author&gt; // note &#39;&#39; here in<br>&gt;&gt;&gt; string &#39;        &lt;title&gt;XML Developer&#39;&#39;s Guide&lt;/title&gt; &#39;<br>&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &#39;        &lt;price&gt;44.95&lt;/price&gt; &#39;<br>&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &#39;        &lt;description&gt;An<br>&gt;&gt;&gt; in-depth look at XML.&lt;/description&gt; &#39;    &lt;/book&gt; &#39;&lt;/catalog&gt;&#39;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (also needs to duplicate single quote if in text. the compromise,<br>&gt;&gt;&gt; yes.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10.05.2016 9:53, John Holdsworth via swift-evolution wrote: I’ve<br>&gt;&gt;&gt;&gt; assembled a gist to summarise the main proposals of this thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At the moment there seem to be four proposals for multi-line<br>&gt;&gt;&gt;&gt; strings:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Bent’s proposal for continuation quotes where if a conventional<br>&gt;&gt;&gt;&gt; string does not close, if the first non-whitespace character of the<br>&gt;&gt;&gt;&gt; next line is “ (or perhaps |) the string is continued. This gives<br>&gt;&gt;&gt;&gt; you precise control over exactly what is in the string.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) Tyler&#39;s original proposal involving strings that can contain<br>&gt;&gt;&gt;&gt; newlines delimited “””like this“”” as they are in python or, _”like<br>&gt;&gt;&gt;&gt; this“_. This works well in external editors and on github.<br>&gt;&gt;&gt;&gt; Indentation is catered for by stripping any whitespace before the<br>&gt;&gt;&gt;&gt; closing quote from all lines in the string.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl<br>&gt;&gt;&gt;&gt; subject to the same indentation removal rules as “””strings”””<br>&gt;&gt;&gt;&gt; above. This has the advantage that the literal is clearly separated<br>&gt;&gt;&gt;&gt; from your code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (There is a separate feature that all string literals can be<br>&gt;&gt;&gt;&gt; prefixed by e as in e”\w\d+” to turn of all escape processing for<br>&gt;&gt;&gt;&gt; another day)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While the Swift Lexer could easily accommodate all these syntaxes<br>&gt;&gt;&gt;&gt; there was talk early on that Swift has more of a &quot;one way, maximally<br>&gt;&gt;&gt;&gt; elegant” ethos and indeed I find it difficult imagine the Swift Book<br>&gt;&gt;&gt;&gt; breathlessly describing all three formats so I’m wondering if push<br>&gt;&gt;&gt;&gt; came to shove which format people would chose?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it<br>&gt;&gt;&gt;&gt; is available sooner rather than later is.. HEREDOC! It’s well<br>&gt;&gt;&gt;&gt; understood and while at first it would seem to not be a good fit for<br>&gt;&gt;&gt;&gt; Swift produces clear code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Votes?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Multi-line string proposals //<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // swift-evolution thread: //<br>&gt;&gt;&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt; // These examples should load in the prototype toolchain available<br>&gt;&gt;&gt;&gt; here: //<br>&gt;&gt;&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The prototype currently parses three new forms of quoting //<br>&gt;&gt;&gt;&gt; These new types are still string literals for the grammar.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;the existing string literal format&quot; _&quot;a format that does not<br>&gt;&gt;&gt;&gt; require you to escape &quot; characters&quot;_ // possibly redundant &quot;&quot;&quot;a<br>&gt;&gt;&gt;&gt; python-style syntax that will accept &quot;&#39;s and newlines in the<br>&gt;&gt;&gt;&gt; string&quot;&quot;&quot; &lt;&lt;&quot;HEREDOC&quot; A full heredoc implementation (will always end<br>&gt;&gt;&gt;&gt; in a newline) HEREDOC<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // These strings can be modified by prefixing the string by letters<br>&gt;&gt;&gt;&gt; // There is currently only one, &quot;e&quot; to disable escape processing. //<br>&gt;&gt;&gt;&gt; This is primarily used when specifying regular expressions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; letstr = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot;== str ) assert(<br>&gt;&gt;&gt;&gt; e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str ) assert( e&quot;&quot;&quot;print(&quot;Hello,<br>&gt;&gt;&gt;&gt; world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Continuation quotes allow you to extend a standard string<br>&gt;&gt;&gt;&gt; literal // over multiple lines. If a string does not close on a line<br>&gt;&gt;&gt;&gt; and the // first non-whitespace character on the next line is &quot; that<br>&gt;&gt;&gt;&gt; line // will be a contination of the string including the newline<br>&gt;&gt;&gt;&gt; character // (unless it is escaped). Interpolation and escapes<br>&gt;&gt;&gt;&gt; process as before // unless the first segment of the string is<br>&gt;&gt;&gt;&gt; modified by the &quot;e&quot; prefix.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The advantage of this format allows you to indent while giving //<br>&gt;&gt;&gt;&gt; you precise control of exactly what is going into the literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; letauthor = &quot;Gambardella, Matthew&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; letxml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt;&gt; empty=\&quot;\&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;       &lt;title&gt;XML<br>&gt;&gt;&gt;&gt; Developer&#39;s Guide&lt;/title&gt; &quot;       &lt;genre&gt;Computer&lt;/genre&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt; &quot;&quot; print(xml)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Perhaps, to avoid the zera crossing effect in text editors due<br>&gt;&gt;&gt;&gt; to // the unbalanced quotes, the continuation character could be<br>&gt;&gt;&gt;&gt; &quot;|&quot;. // (newlines escaped with \ and blank lines are discarded.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( xml == &quot;\ |&lt;?xml version=\&quot;1.0\&quot;?&gt; |&lt;catalog&gt; |   &lt;book<br>&gt;&gt;&gt;&gt; id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt; |       &lt;author&gt;\(author)&lt;/author&gt; |<br>&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; |<br>&gt;&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; |       &lt;price&gt;44.95&lt;/price&gt; |<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; |       &lt;description&gt;An<br>&gt;&gt;&gt;&gt; in-depth look at creating \ |applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; |   &lt;/book&gt; |&lt;/catalog&gt; |&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t<br>&gt;&gt;&gt;&gt; require // escaping of embedded &quot; characters. Think of them as a<br>&gt;&gt;&gt;&gt; being modifier // on conventional string literals. They support<br>&gt;&gt;&gt;&gt; continuation quotes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book<br>&gt;&gt;&gt;&gt; id=&quot;bk101&quot; empty=&quot;&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &quot;       &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt; discussed next<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;_ )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The triple quoted strings can contain newlines and, unless<br>&gt;&gt;&gt;&gt; modified by &quot;e&quot; // will process interpolations and not require<br>&gt;&gt;&gt;&gt; escaping of &quot;. To allow indenting, // any whitespace characters that<br>&gt;&gt;&gt;&gt; preceed the closing &quot;&quot;&quot; will be removed from // each line of the<br>&gt;&gt;&gt;&gt; final literal. A warning is shown if lines do not contain // the<br>&gt;&gt;&gt;&gt; exact same indentation characters. Any intial linefeed is also<br>&gt;&gt;&gt;&gt; removed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // The advantage of this format is the &quot;&quot;&quot; introducer works well<br>&gt;&gt;&gt;&gt; when syntax // highlighting in external editors and github as quotes<br>&gt;&gt;&gt;&gt; are always balanced.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( xml == &quot;&quot;&quot; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt;&gt; (non-escaping, &quot;e&quot; prefix) // It applies the same indentation<br>&gt;&gt;&gt;&gt; removal rules as does &quot;&quot;&quot;. This change has wider // ramifications<br>&gt;&gt;&gt;&gt; for the toolchain as compiler tokens are no longer in file order //<br>&gt;&gt;&gt;&gt; and will take a while for a few problems to be ironed out. The more<br>&gt;&gt;&gt;&gt; consistent // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt;&gt; for non-escaping strings.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // HEREDOC&#39;s advantage is that the literal no longer interrupts the<br>&gt;&gt;&gt;&gt; flow of your code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml ) &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // For text you do not want to contain newlines, escape them using<br>&gt;&gt;&gt;&gt; \<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; print( &lt;&lt;&quot;LOREM&quot; ) Lorem ipsum dolor sit amet, consectetur<br>&gt;&gt;&gt;&gt; adipiscing elit, sed do eiusmod tempor incididunt \ ut labore et<br>&gt;&gt;&gt;&gt; dolore magna aliqua. Ut enim ad minim veniam, quis nostrud<br>&gt;&gt;&gt;&gt; exercitation ullamco \ laboris nisi ut aliquip ex ea commodo<br>&gt;&gt;&gt;&gt; consequat. Duis aute irure dolor in reprehenderit in \ voluptate<br>&gt;&gt;&gt;&gt; velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint<br>&gt;&gt;&gt;&gt; occaecat cupidatat \ non proident, sunt in culpa qui officia<br>&gt;&gt;&gt;&gt; deserunt mollit anim id est laborum.\ LOREM<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/d4e898b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 09:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On 11.05.2016 21:04, Ricardo Parada wrote:<br>&gt;<br>&gt;&gt; On May 11, 2016, at 12:55 PM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 11.05.2016 19:38, Ricardo Parada wrote:<br>&gt;&gt;&gt; I did not suggest the single quote because it is commonly found in the<br>&gt;&gt;&gt; English language and we would have to escape it.<br>&gt;&gt;<br>&gt;&gt; Wel.. in your document you have a number of variants of multi-line<br>&gt;&gt; &#39;feature&#39; implementations with different pros/cons for each.<br>&gt;<br>&gt; I don’t have a document.  I’ve seen different proposals.<br>&gt; I have just been commenting on the proposals in this thread.<br></p><p>Oh, sorry :-) Will check the initial sender more carefully the next time.<br></p><p>&gt;<br>&gt;&gt; Could you clarify, why this proposal with single quote can not be inside<br>&gt;&gt; your document as just another variant with its own pros/cons ?<br>&gt;&gt; Especially, as you can see, if &quot;We&#39;d rather save single quoted literals<br>&gt;&gt; for a greater purpose (e.g. non-escaped string literals)” ?<br>&gt;<br>&gt; I cannot speak for them, but I think that if we want to get a feel about<br>&gt; which alternatives get the most traction, I think all alternatives should<br>&gt; be considered, including yours and mine.  :-)<br></p><p>Got it :-)<br></p><p>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is why I suggested a rare combination using the @&quot; and &quot;@ as the<br>&gt;&gt;&gt; delimiters. Unless your text is Obj-C code it would be rare to find it.<br>&gt;&gt;&gt;<br>&gt;<br>&gt; I don’t think we need to worry about the opening quote occurring in the<br>&gt; text because we just need the closing delimiter to find out where it ends.<br>&gt;  For example:<br>&gt;<br>&gt;<br>&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;                   &quot;NSString *lastName = @“Doe”;<br>&gt;                   “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt; %@“, firstName, lastName];&quot;@<br>&gt;<br>&gt; The one that would be a bit of a problem is the closing delimiter,<br></p><p>Yes.. this is why I asked about `&quot;@` - closing delimiter<br>so.. what is the solution in your case ?<br></p><p>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; And what do you suggest to do if we *have* `&quot;@` inside the text we want<br>&gt;&gt; to use ?<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 11, 2016, at 10:50 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Did I miss the proposal for single quote?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Just found on<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt; ---------------------&lt;<br>&gt;&gt;&gt;&gt; Single-quotes &#39;&#39; for Character literals: Swift takes the approach of<br>&gt;&gt;&gt;&gt; highly valuing Unicode. However, there are multiple concepts of a<br>&gt;&gt;&gt;&gt; character that could make sense in Unicode, and none is so much more<br>&gt;&gt;&gt;&gt; commonly used than the others that it makes sense to privilege them.<br>&gt;&gt;&gt;&gt; We&#39;d rather save single quoted literals for a greater purpose (e.g.<br>&gt;&gt;&gt;&gt; non-escaped string literals).<br>&gt;&gt;&gt;&gt;&gt; ---------------------&lt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So, what about using of single quote as &quot;special&quot; strings?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, I&#39;d propose to use single quote quotation to say &quot;this<br>&gt;&gt;&gt;&gt; string should be used as-is, no escapes processing&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &#39;some 1\total\\2\\\3 &quot;sdfsdf&quot; \(-: &quot;&quot;&quot; helllooo&#39;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; the only &#39;disallowed&#39; symbol could be the single quote itself, but I<br>&gt;&gt;&gt;&gt; propose the solution used in other languages - duplicate it if we need<br>&gt;&gt;&gt;&gt; it in string:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &#39;this &#39;&#39; is a single quote in string, and this is another&#39;&#39;&#39;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; and also in multiline strings:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; assert( xml == &#39;&lt;?xml version=&quot;1.0&quot;?&gt; &#39;&lt;catalog&gt; &#39;    &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &#39;        &lt;author&gt;\(author)&lt;/author&gt; // note &#39;&#39; here in<br>&gt;&gt;&gt;&gt; string &#39;        &lt;title&gt;XML Developer&#39;&#39;s Guide&lt;/title&gt; &#39;<br>&gt;&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &#39;        &lt;price&gt;44.95&lt;/price&gt; &#39;<br>&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &#39;        &lt;description&gt;An<br>&gt;&gt;&gt;&gt; in-depth look at XML.&lt;/description&gt; &#39;    &lt;/book&gt; &#39;&lt;/catalog&gt;&#39;)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (also needs to duplicate single quote if in text. the compromise,<br>&gt;&gt;&gt;&gt; yes.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 10.05.2016 9:53, John Holdsworth via swift-evolution wrote: I’ve<br>&gt;&gt;&gt;&gt;&gt; assembled a gist to summarise the main proposals of this thread.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/johnno1962/5c325a16838ad3c73e0f109a514298bf<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; At the moment there seem to be four proposals for multi-line<br>&gt;&gt;&gt;&gt;&gt; strings:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 1) Bent’s proposal for continuation quotes where if a conventional<br>&gt;&gt;&gt;&gt;&gt; string does not close, if the first non-whitespace character of the<br>&gt;&gt;&gt;&gt;&gt; next line is “ (or perhaps |) the string is continued. This gives<br>&gt;&gt;&gt;&gt;&gt; you precise control over exactly what is in the string.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 2) Tyler&#39;s original proposal involving strings that can contain<br>&gt;&gt;&gt;&gt;&gt; newlines delimited “””like this“”” as they are in python or, _”like<br>&gt;&gt;&gt;&gt;&gt; this“_. This works well in external editors and on github.<br>&gt;&gt;&gt;&gt;&gt; Indentation is catered for by stripping any whitespace before the<br>&gt;&gt;&gt;&gt;&gt; closing quote from all lines in the string.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 3) HEREDOC syntax &lt;&lt;“TAG” or &lt;&lt;‘TAG’ taken from languages like Perl<br>&gt;&gt;&gt;&gt;&gt; subject to the same indentation removal rules as “””strings”””<br>&gt;&gt;&gt;&gt;&gt; above. This has the advantage that the literal is clearly separated<br>&gt;&gt;&gt;&gt;&gt; from your code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; 4) Heck it all, why not all three syntaxes or some combination.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; (There is a separate feature that all string literals can be<br>&gt;&gt;&gt;&gt;&gt; prefixed by e as in e”\w\d+” to turn of all escape processing for<br>&gt;&gt;&gt;&gt;&gt; another day)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; While the Swift Lexer could easily accommodate all these syntaxes<br>&gt;&gt;&gt;&gt;&gt; there was talk early on that Swift has more of a &quot;one way, maximally<br>&gt;&gt;&gt;&gt;&gt; elegant” ethos and indeed I find it difficult imagine the Swift Book<br>&gt;&gt;&gt;&gt;&gt; breathlessly describing all three formats so I’m wondering if push<br>&gt;&gt;&gt;&gt;&gt; came to shove which format people would chose?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My vote having undergone a &quot;road to damascus&quot; moment now we know it<br>&gt;&gt;&gt;&gt;&gt; is available sooner rather than later is.. HEREDOC! It’s well<br>&gt;&gt;&gt;&gt;&gt; understood and while at first it would seem to not be a good fit for<br>&gt;&gt;&gt;&gt;&gt; Swift produces clear code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Votes?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; John<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Multi-line string proposals //<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift/pull/2275<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // swift-evolution thread: //<br>&gt;&gt;&gt;&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; // These examples should load in the prototype toolchain available<br>&gt;&gt;&gt;&gt;&gt; here: //<br>&gt;&gt;&gt;&gt;&gt; http://johnholdsworth.com/swift-LOCAL-2016-05-09-a-osx.tar.gz<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // The prototype currently parses three new forms of quoting //<br>&gt;&gt;&gt;&gt;&gt; These new types are still string literals for the grammar.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;the existing string literal format&quot; _&quot;a format that does not<br>&gt;&gt;&gt;&gt;&gt; require you to escape &quot; characters&quot;_ // possibly redundant &quot;&quot;&quot;a<br>&gt;&gt;&gt;&gt;&gt; python-style syntax that will accept &quot;&#39;s and newlines in the<br>&gt;&gt;&gt;&gt;&gt; string&quot;&quot;&quot; &lt;&lt;&quot;HEREDOC&quot; A full heredoc implementation (will always end<br>&gt;&gt;&gt;&gt;&gt; in a newline) HEREDOC<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // These strings can be modified by prefixing the string by letters<br>&gt;&gt;&gt;&gt;&gt; // There is currently only one, &quot;e&quot; to disable escape processing. //<br>&gt;&gt;&gt;&gt;&gt; This is primarily used when specifying regular expressions.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; letstr = &quot;print(\&quot;Hello, world!\\n\&quot;)&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( e&quot;print(\&quot;Hello, world!\n\&quot;)&quot;== str ) assert(<br>&gt;&gt;&gt;&gt;&gt; e_&quot;print(&quot;Hello, world!\n&quot;)&quot;_ == str ) assert( e&quot;&quot;&quot;print(&quot;Hello,<br>&gt;&gt;&gt;&gt;&gt; world!\n&quot;)&quot;&quot;&quot; == str )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Continuation quotes allow you to extend a standard string<br>&gt;&gt;&gt;&gt;&gt; literal // over multiple lines. If a string does not close on a line<br>&gt;&gt;&gt;&gt;&gt; and the // first non-whitespace character on the next line is &quot; that<br>&gt;&gt;&gt;&gt;&gt; line // will be a contination of the string including the newline<br>&gt;&gt;&gt;&gt;&gt; character // (unless it is escaped). Interpolation and escapes<br>&gt;&gt;&gt;&gt;&gt; process as before // unless the first segment of the string is<br>&gt;&gt;&gt;&gt;&gt; modified by the &quot;e&quot; prefix.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // The advantage of this format allows you to indent while giving //<br>&gt;&gt;&gt;&gt;&gt; you precise control of exactly what is going into the literal.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; letauthor = &quot;Gambardella, Matthew&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; letxml = &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book id=\&quot;bk101\&quot;<br>&gt;&gt;&gt;&gt;&gt; empty=\&quot;\&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;       &lt;title&gt;XML<br>&gt;&gt;&gt;&gt;&gt; Developer&#39;s Guide&lt;/title&gt; &quot;       &lt;genre&gt;Computer&lt;/genre&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt; &quot;&quot; print(xml)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // Perhaps, to avoid the zera crossing effect in text editors due<br>&gt;&gt;&gt;&gt;&gt; to // the unbalanced quotes, the continuation character could be<br>&gt;&gt;&gt;&gt;&gt; &quot;|&quot;. // (newlines escaped with \ and blank lines are discarded.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( xml == &quot;\ |&lt;?xml version=\&quot;1.0\&quot;?&gt; |&lt;catalog&gt; |   &lt;book<br>&gt;&gt;&gt;&gt;&gt; id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt; |       &lt;author&gt;\(author)&lt;/author&gt; |<br>&gt;&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; |<br>&gt;&gt;&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; |       &lt;price&gt;44.95&lt;/price&gt; |<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; |       &lt;description&gt;An<br>&gt;&gt;&gt;&gt;&gt; in-depth look at creating \ |applications with XML.&lt;/description&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; |   &lt;/book&gt; |&lt;/catalog&gt; |&quot;)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // _&quot;&quot;_ quoted strings also suppport these behaviours but don&#39;t<br>&gt;&gt;&gt;&gt;&gt; require // escaping of embedded &quot; characters. Think of them as a<br>&gt;&gt;&gt;&gt;&gt; being modifier // on conventional string literals. They support<br>&gt;&gt;&gt;&gt;&gt; continuation quotes.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &quot;&lt;catalog&gt; &quot;   &lt;book<br>&gt;&gt;&gt;&gt;&gt; id=&quot;bk101&quot; empty=&quot;&quot;&gt; &quot;       &lt;author&gt;\(author)&lt;/author&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;genre&gt;Computer&lt;/genre&gt; &quot;       &lt;price&gt;44.95&lt;/price&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &quot;       &lt;description&gt;An<br>&gt;&gt;&gt;&gt;&gt; in-depth look at creating applications with XML.&lt;/description&gt; &quot;<br>&gt;&gt;&gt;&gt;&gt; &lt;/book&gt; &quot;&lt;/catalog&gt;\n&quot;_ )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // _&quot;strings&quot;_ could allow newlines and replace &quot;&quot;&quot;strings&quot;&quot;&quot;<br>&gt;&gt;&gt;&gt;&gt; discussed next<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( xml == _&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;_ )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // The triple quoted strings can contain newlines and, unless<br>&gt;&gt;&gt;&gt;&gt; modified by &quot;e&quot; // will process interpolations and not require<br>&gt;&gt;&gt;&gt;&gt; escaping of &quot;. To allow indenting, // any whitespace characters that<br>&gt;&gt;&gt;&gt;&gt; preceed the closing &quot;&quot;&quot; will be removed from // each line of the<br>&gt;&gt;&gt;&gt;&gt; final literal. A warning is shown if lines do not contain // the<br>&gt;&gt;&gt;&gt;&gt; exact same indentation characters. Any intial linefeed is also<br>&gt;&gt;&gt;&gt;&gt; removed.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // The advantage of this format is the &quot;&quot;&quot; introducer works well<br>&gt;&gt;&gt;&gt;&gt; when syntax // highlighting in external editors and github as quotes<br>&gt;&gt;&gt;&gt;&gt; are always balanced.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( xml == &quot;&quot;&quot; &lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( xml != e&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot;<br>&gt;&gt;&gt;&gt;&gt; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt; &lt;title&gt;XML Developer&#39;s<br>&gt;&gt;&gt;&gt;&gt; Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth<br>&gt;&gt;&gt;&gt;&gt; look at creating applications with XML.&lt;/description&gt; &lt;/book&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;/catalog&gt; &quot;&quot;&quot; )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // heredoc syntax comes in two variants &lt;&lt;&quot;TAG&quot; and &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt;&gt;&gt; (non-escaping, &quot;e&quot; prefix) // It applies the same indentation<br>&gt;&gt;&gt;&gt;&gt; removal rules as does &quot;&quot;&quot;. This change has wider // ramifications<br>&gt;&gt;&gt;&gt;&gt; for the toolchain as compiler tokens are no longer in file order //<br>&gt;&gt;&gt;&gt;&gt; and will take a while for a few problems to be ironed out. The more<br>&gt;&gt;&gt;&gt;&gt; consistent // &lt;&lt;e&quot;TAG&quot; is a rather clumsy alternative to &lt;&lt;&#39;TAG&#39;<br>&gt;&gt;&gt;&gt;&gt; for non-escaping strings.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // HEREDOC&#39;s advantage is that the literal no longer interrupts the<br>&gt;&gt;&gt;&gt;&gt; flow of your code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == xml + xml ) &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;catalog&gt; &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt; &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;description&gt;An in-depth look at creating applications with<br>&gt;&gt;&gt;&gt;&gt; XML.&lt;/description&gt; &lt;/book&gt; &lt;/catalog&gt; XML<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; // For text you do not want to contain newlines, escape them using<br>&gt;&gt;&gt;&gt;&gt; \<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; print( &lt;&lt;&quot;LOREM&quot; ) Lorem ipsum dolor sit amet, consectetur<br>&gt;&gt;&gt;&gt;&gt; adipiscing elit, sed do eiusmod tempor incididunt \ ut labore et<br>&gt;&gt;&gt;&gt;&gt; dolore magna aliqua. Ut enim ad minim veniam, quis nostrud<br>&gt;&gt;&gt;&gt;&gt; exercitation ullamco \ laboris nisi ut aliquip ex ea commodo<br>&gt;&gt;&gt;&gt;&gt; consequat. Duis aute irure dolor in reprehenderit in \ voluptate<br>&gt;&gt;&gt;&gt;&gt; velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint<br>&gt;&gt;&gt;&gt;&gt; occaecat cupidatat \ non proident, sunt in culpa qui officia<br>&gt;&gt;&gt;&gt;&gt; deserunt mollit anim id est laborum.\ LOREM<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt;&gt; mailing list swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 11, 2016 at 10:00:00pm</p></header><div class="content"><p>On May 11, 2016, at 2:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;&gt;                  &quot;NSString *lastName = @“Doe”;<br>&gt;&gt;                  “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt;&gt; %@“, firstName, lastName];&quot;@<br>&gt;&gt; <br>&gt;&gt; The one that would be a bit of a problem is the closing delimiter,<br>&gt; <br>&gt; Yes.. this is why I asked about `&quot;@` - closing delimiter<br>&gt; so.. what is the solution in your case ?<br></p><p>Hi Vladimir,<br></p><p>I don&#39;t really have a solution. Perhaps escaping the closing delimiter like this \&quot;@<br></p><p>It is not pretty but I can&#39;t think of anything else. I imagine the other alternatives, i.e.   the triple quote `&quot;&quot;&quot;` and the quote plus underscore `&quot;_ `  have the same problem. <br></p><p>If we make the continuation quote required then we don&#39;t need a closing delimiter. That would solve the problem. But I&#39;ve seen several people say they don&#39;t like the continuation quote because they want to be able to paste text and not have to worry much about formatting it afterwards.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a69f91816dae5f787bd9f58ceb7b70bd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Eduardo Mourey Lopez Ne</string> &lt;edmourey at icloud.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Something like this might work<br></p><p>//string ends on the first line that doesnt start with a &quot;<br>foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>       &quot;&lt;catalog&gt;<br>       &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>       &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>       &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>       &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>       &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>       &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>       &quot;       &lt;description&gt;An in-depth look at creating applications with    XML.&lt;/description&gt;<br>       &quot;   &lt;/book&gt;<br>       &quot;&lt;/catalog&gt;\n<br>    )<br></p><p>//additionally using a +&quot; could be used to indicate a line break<br>foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>      +&quot;&lt;catalog&gt;<br>      +&quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>      +&quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>      +&quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>      +&quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>      +&quot;       &lt;price&gt;44.95&lt;/price&gt;<br>      +&quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>      +&quot;       &lt;description&gt;An in-depth look at creating applications with    XML.&lt;/description&gt;<br>      +&quot;   &lt;/book&gt;<br>      +&quot;&lt;/catalog&gt;\n<br>    )<br></p><p>&gt; On May 11, 2016, at 9:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 11, 2016, at 2:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;&gt;&gt;                 &quot;NSString *lastName = @“Doe”;<br>&gt;&gt;&gt;                 “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt;&gt;&gt; %@“, firstName, lastName];&quot;@<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one that would be a bit of a problem is the closing delimiter,<br>&gt;&gt; <br>&gt;&gt; Yes.. this is why I asked about `&quot;@` - closing delimiter<br>&gt;&gt; so.. what is the solution in your case ?<br>&gt; <br>&gt; Hi Vladimir,<br>&gt; <br>&gt; I don&#39;t really have a solution. Perhaps escaping the closing delimiter like this \&quot;@<br>&gt; <br>&gt; It is not pretty but I can&#39;t think of anything else. I imagine the other alternatives, i.e.   the triple quote `&quot;&quot;&quot;` and the quote plus underscore `&quot;_ `  have the same problem. <br>&gt; <br>&gt; If we make the continuation quote required then we don&#39;t need a closing delimiter. That would solve the problem. But I&#39;ve seen several people say they don&#39;t like the continuation quote because they want to be able to paste text and not have to worry much about formatting it afterwards. <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/b6112c68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 12, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m not in favour of multiline strings. I believe such strings should be<br>stored in plain files and loaded as needed. It makes both the code and the<br>string cleaner to read and maintain. I&#39;ve had experiences with many<br>languages that offer that resource and I could see what your code can<br>become in terms of maintainability when you have such feature on the<br>language.<br></p><p>-1 from me.<br></p><p>- Leonardo<br></p><p>On 12 May 2016 at 01:05, Eduardo Mourey Lopez Ne via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Something like this might work<br>&gt;<br>&gt; //string ends on the first line that doesnt start with a &quot;<br>&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;        &quot;&lt;catalog&gt;<br>&gt;        &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;        &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;        &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;        &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;        &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;        &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;        &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt; with    XML.&lt;/description&gt;<br>&gt;        &quot;   &lt;/book&gt;<br>&gt;        &quot;&lt;/catalog&gt;\n<br>&gt;     )<br>&gt;<br>&gt; //additionally using a +&quot; could be used to indicate a line break<br>&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;       +&quot;&lt;catalog&gt;<br>&gt;       +&quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;       +&quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;       +&quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;       +&quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;       +&quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;       +&quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;       +&quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt; with    XML.&lt;/description&gt;<br>&gt;       +&quot;   &lt;/book&gt;<br>&gt;       +&quot;&lt;/catalog&gt;\n<br>&gt;     )<br>&gt;<br>&gt; On May 11, 2016, at 9:48 PM, Ricardo Parada via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 2:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt;<br>&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;                 &quot;NSString *lastName = @“Doe”;<br>&gt;                 “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt; %@“, firstName, lastName];&quot;@<br>&gt;<br>&gt; The one that would be a bit of a problem is the closing delimiter,<br>&gt;<br>&gt;<br>&gt; Yes.. this is why I asked about `&quot;@` - closing delimiter<br>&gt; so.. what is the solution in your case ?<br>&gt;<br>&gt;<br>&gt; Hi Vladimir,<br>&gt;<br>&gt; I don&#39;t really have a solution. Perhaps escaping the closing delimiter<br>&gt; like this \&quot;@<br>&gt;<br>&gt; It is not pretty but I can&#39;t think of anything else. I imagine the other<br>&gt; alternatives, i.e.   the triple quote `&quot;&quot;&quot;` and the quote plus underscore<br>&gt; `&quot;_ `  have the same problem.<br>&gt;<br>&gt; If we make the continuation quote required then we don&#39;t need a closing<br>&gt; delimiter. That would solve the problem. But I&#39;ve seen several people say<br>&gt; they don&#39;t like the continuation quote because they want to be able to<br>&gt; paste text and not have to worry much about formatting it afterwards.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/eef53260/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 13, 2016 at 12:00:00am</p></header><div class="content"><p>I don&#39;t think the intent of multi-line string literals is to replace files or templating libraries. I use those all the time and are superior. <br></p><p>I think it would be handy and make it more pleasant to use for simple cases. <br></p><p>Who has not run into a little multi-line literal in your code where you concatenate the pieces using +, add \n at the end of each line and have to escape quotes?<br></p><p><br>&gt; On May 12, 2016, at 12:36 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not in favour of multiline strings. I believe such strings should be stored in plain files and loaded as needed. It makes both the code and the string cleaner to read and maintain. I&#39;ve had experiences with many languages that offer that resource and I could see what your code can become in terms of maintainability when you have such feature on the language.<br>&gt; <br>&gt; -1 from me.<br>&gt; <br>&gt; - Leonardo<br>&gt; <br>&gt;&gt; On 12 May 2016 at 01:05, Eduardo Mourey Lopez Ne via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Something like this might work<br>&gt;&gt; <br>&gt;&gt; //string ends on the first line that doesnt start with a &quot;<br>&gt;&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;        &quot;&lt;catalog&gt;<br>&gt;&gt;        &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;        &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;        &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;        &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;        &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;        &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;        &quot;       &lt;description&gt;An in-depth look at creating applications with    XML.&lt;/description&gt;<br>&gt;&gt;        &quot;   &lt;/book&gt;<br>&gt;&gt;        &quot;&lt;/catalog&gt;\n<br>&gt;&gt;     )<br>&gt;&gt; <br>&gt;&gt; //additionally using a +&quot; could be used to indicate a line break<br>&gt;&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;       +&quot;&lt;catalog&gt;<br>&gt;&gt;       +&quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;       +&quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;       +&quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;       +&quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;       +&quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;       +&quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;       +&quot;       &lt;description&gt;An in-depth look at creating applications with    XML.&lt;/description&gt;<br>&gt;&gt;       +&quot;   &lt;/book&gt;<br>&gt;&gt;       +&quot;&lt;/catalog&gt;\n<br>&gt;&gt;     )<br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 9:48 PM, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 2:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;&gt;&gt;&gt;&gt;                 &quot;NSString *lastName = @“Doe”;<br>&gt;&gt;&gt;&gt;&gt;                 “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt;&gt;&gt;&gt;&gt; %@“, firstName, lastName];&quot;@<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The one that would be a bit of a problem is the closing delimiter,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes.. this is why I asked about `&quot;@` - closing delimiter<br>&gt;&gt;&gt;&gt; so.. what is the solution in your case ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Vladimir,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t really have a solution. Perhaps escaping the closing delimiter like this \&quot;@<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not pretty but I can&#39;t think of anything else. I imagine the other alternatives, i.e.   the triple quote `&quot;&quot;&quot;` and the quote plus underscore `&quot;_ `  have the same problem. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we make the continuation quote required then we don&#39;t need a closing delimiter. That would solve the problem. But I&#39;ve seen several people say they don&#39;t like the continuation quote because they want to be able to paste text and not have to worry much about formatting it afterwards. <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/0023d8ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 13, 2016 at 01:00:00pm</p></header><div class="content"><p>That&#39;s my point. You start with a little two-line string and when you see<br>you have those all over your code. A feature is never bad but a feature<br>that may be misused creates temptation to go for bad programming practices,<br>like &quot;I&#39;m using it just this once&quot; and once you&#39;re there you never stop.<br></p><p>You can still have multiline string in Swift by concatenating strings as<br>you already pointed but that discourages you from having too many lines<br>glued like this. The approach of loading them from a file makes the code<br>cleaner to read and the string cleaner to maintain and not having the means<br>to have the lines in your code will push you to do the right thing and load<br>them from a file from start.<br></p><p><br>On 13 May 2016 at 01:16, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br></p><p>&gt; I don&#39;t think the intent of multi-line string literals is to replace files<br>&gt; or templating libraries. I use those all the time and are superior.<br>&gt;<br>&gt; I think it would be handy and make it more pleasant to use for simple<br>&gt; cases.<br>&gt;<br>&gt; Who has not run into a little multi-line literal in your code where you<br>&gt; concatenate the pieces using +, add \n at the end of each line and have to<br>&gt; escape quotes?<br>&gt;<br>&gt;<br>&gt; On May 12, 2016, at 12:36 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt; I&#39;m not in favour of multiline strings. I believe such strings should be<br>&gt; stored in plain files and loaded as needed. It makes both the code and the<br>&gt; string cleaner to read and maintain. I&#39;ve had experiences with many<br>&gt; languages that offer that resource and I could see what your code can<br>&gt; become in terms of maintainability when you have such feature on the<br>&gt; language.<br>&gt;<br>&gt; -1 from me.<br>&gt;<br>&gt; - Leonardo<br>&gt;<br>&gt; On 12 May 2016 at 01:05, Eduardo Mourey Lopez Ne via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Something like this might work<br>&gt;&gt;<br>&gt;&gt; //string ends on the first line that doesnt start with a &quot;<br>&gt;&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;        &quot;&lt;catalog&gt;<br>&gt;&gt;        &quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;        &quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;        &quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;        &quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;        &quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;        &quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;        &quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with    XML.&lt;/description&gt;<br>&gt;&gt;        &quot;   &lt;/book&gt;<br>&gt;&gt;        &quot;&lt;/catalog&gt;\n<br>&gt;&gt;     )<br>&gt;&gt;<br>&gt;&gt; //additionally using a +&quot; could be used to indicate a line break<br>&gt;&gt; foo( @&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;&gt;       +&quot;&lt;catalog&gt;<br>&gt;&gt;       +&quot;   &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;&gt;       +&quot;       &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;&gt;       +&quot;       &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;&gt;       +&quot;       &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;&gt;       +&quot;       &lt;price&gt;44.95&lt;/price&gt;<br>&gt;&gt;       +&quot;       &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;&gt;       +&quot;       &lt;description&gt;An in-depth look at creating applications<br>&gt;&gt; with    XML.&lt;/description&gt;<br>&gt;&gt;       +&quot;   &lt;/book&gt;<br>&gt;&gt;       +&quot;&lt;/catalog&gt;\n<br>&gt;&gt;     )<br>&gt;&gt;<br>&gt;&gt; On May 11, 2016, at 9:48 PM, Ricardo Parada via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On May 11, 2016, at 2:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; letsourceCode =@“NSString *firstName = @“John”;<br>&gt;&gt;                 &quot;NSString *lastName = @“Doe”;<br>&gt;&gt;                 “NSString *fullName = [NSString stringWithFormat: @“%@<br>&gt;&gt; %@“, firstName, lastName];&quot;@<br>&gt;&gt;<br>&gt;&gt; The one that would be a bit of a problem is the closing delimiter,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes.. this is why I asked about `&quot;@` - closing delimiter<br>&gt;&gt; so.. what is the solution in your case ?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hi Vladimir,<br>&gt;&gt;<br>&gt;&gt; I don&#39;t really have a solution. Perhaps escaping the closing delimiter<br>&gt;&gt; like this \&quot;@<br>&gt;&gt;<br>&gt;&gt; It is not pretty but I can&#39;t think of anything else. I imagine the other<br>&gt;&gt; alternatives, i.e.   the triple quote `&quot;&quot;&quot;` and the quote plus underscore<br>&gt;&gt; `&quot;_ `  have the same problem.<br>&gt;&gt;<br>&gt;&gt; If we make the continuation quote required then we don&#39;t need a closing<br>&gt;&gt; delimiter. That would solve the problem. But I&#39;ve seen several people say<br>&gt;&gt; they don&#39;t like the continuation quote because they want to be able to<br>&gt;&gt; paste text and not have to worry much about formatting it afterwards.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/cb7ff188/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>May  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;         assert( xml != ei&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;             &lt;catalog&gt;<br>&gt;                &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                    &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                    &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                    &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                    &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                    &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                    &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;                &lt;/book&gt;<br>&gt;             &lt;/catalog&gt;<br>&gt;             &quot;&quot;&quot; )<br></p><p>The idea of auto-stripping whitespaces seemed nice initially, until I realized it&#39;s not at all clear where the stripped whitespaces end and the included whitespaces begin. It&#39;s already problematic for you own code (because even knowing your own intent doesn&#39;t completely overcome the lack of perspective this syntax offers), but imagine if it&#39;s someone else&#39;s. Will you be able to figure out what spacing is meant to be a part of the string and which is not? Quickly? Easily? Maybe, maybe not. It still won&#39;t be readily apparent, because there&#39;s no point of reference. You&#39;re potentially reduced to counting whitespaces to figure it out. Brent&#39;s proposal elegantly fixes this problem. You have a clear point of reference, there&#39;s no issue of spaces vs tabs, no trying to figure out exactly where the &quot;true&quot; whitespaces are beginning. Like was mentioned, it would probably have to be relative to the leading whitespaces on the closing delimiter line, but then there&#39;s no way to tell visually if those are spaces or tabs, or how many there are, AND you have to sort of mentally trace an invisible line upwards to &quot;see&quot; how the lines above relate. This would drive me crazy. With leading quotes, it&#39;s obvious which lines don&#39;t have included leading whitespaces, and the ones that do have a smaller relative distance to what is the &quot;left alignment margin&quot; (so to speak) indicated by the quotes.<br></p><p>This feels like we would be making it easier to make mistakes and harder to determine actual spacing just to eliminate some extra quotes. I think the proposal is the best balance of simplicity and practicality we&#39;re going to achieve for *short* multi line strings, which is what this proposal is tying to address. We can still introduce the &quot;&quot;&quot; or heredoc syntaxes for longer blocks of text in the future.<br></p><p>Cole<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/a4a52860/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>multi-line string literals.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 12:30 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt; <br>&gt; I just wanted to say that I have drafted a proposal that solves the issues that I have encountered. (It&#39;s here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016219.html )<br>&gt; - it allows pasting text as-is<br>&gt; - it allows creating string literals where leading space on each line is stripped (while keeping indentation differences intact)<br>&gt; - it allows creating string literals where leading space on each line is not stripped<br>&gt; - optionally it allows strings to be raw, without any string interpolation or escaping whatsoever<br>&gt; - in none of the literals you have to write &quot;&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;&quot;, you can just write &quot;&quot;&quot;&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;&quot;&quot;&quot;. This also lets you copy&amp;paste text out of the program source and back into a HTML file.<br>&gt; <br>&gt; It had the idea that maybe the motivation behind continuation quotes is to make using multiline strings harder to use; in order to discourage their use at all. Two points to consider:<br>&gt; - people who don&#39;t want to use MSL will not, even if you throw Python-like &quot;&quot;&quot;multi-line strings&quot;&quot;&quot; at them.<br>&gt; - people who want to use them do it, even if there is no MSL available. I saw that in Objective-C, with multiple lines of HTML and CSS wrapped into a big multiline objc-string-literal and thrown at a WebView. I could send the literal to the console before sending it to the WebView and it was basically unreadable. I eventually refactored it to put the thing into a file (also because the HTML grew in space, and the inline-literal became impractical)<br>&gt; - my most important point: if someone uses multiple lines of HTML or CSS or XML directly within the code, I want it to look okay. I don&#39;t want an MSL feature that is so unwieldy that people voluntarily not use it; it would be better to have no MSL at all.<br>&gt; <br>&gt; I don&#39;t think that multiline strings are a must-have feature for a language, because they are not used very often. (I included an example of a good use case in my proposal.) I acknowledge that in many programming cases it would be better to not put a huge pile of text directly into the source, but to load the text from a file at runtime. But even when these MSL are misused, I prefer to read a &quot;&quot;&quot;python multiline string&quot;&quot;&quot; over a &quot;concatenated\n&quot;+&quot;Java\n&quot;+&quot;String&quot;.<br>&gt; <br>&gt; -Michael<br></p><p><br>Hi Michael. hope this helps  https://gist.github.com/lmihalkovic/11f2b1b23b78bbb9cbf0292ffc480b3d<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May  6, 2016 at 12:00:00am</p></header><div class="content"><p>If we use triple quotes (i.e. &quot;&quot;&quot;) at the beginning of the multi line string literal and again at the end, it seems very unlikely that the heredoc notation would be needed. <br></p><p>I would simplify and remove the heredoc alternative from the proposal. <br></p><p>Also, for those of us who like the continuation quotes, I think the continuation quotes could be optional. For example this:<br></p><p>let html = &quot;&quot;&quot;&lt;html&gt;<br>    &quot;. &lt;body&gt;<br>    &quot;     &lt;h1&gt;\(title)&lt;h1&gt;<br>    &quot;.    &lt;p class=&quot;fancy&quot;&gt;A paragraph.&lt;p&gt;<br>    &quot;. &lt;/body&gt;<br>    &quot;&lt;/html&gt;<br>    &quot;&quot;&quot;<br></p><p>would be equivalent to:<br></p><p><br>let html = &quot;&quot;&quot;&lt;html&gt;<br>    . &lt;body&gt;<br>         &lt;h1&gt;\(title)&lt;h1&gt;<br>    .    &lt;p class=&quot;fancy&quot;&gt;A paragraph.&lt;p&gt;<br>    . &lt;/body&gt;<br>    &lt;/html&gt;<br>    &quot;&quot;&quot;<br></p><p>What do you think?<br></p><p><br></p><p>&gt; On May 5, 2016, at 2:13 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 5, 2016, at 12:30 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; it&#39;s not a secret that I&#39;m not a big fan of the proposal. The third draft doesn&#39;t change this and it&#39;s unlikely that any future draft will, because for me, the problem are the continuation quotes, and for Brent it seems like they are a must-have-feature (correct me if I&#39;m wrong.)<br>&gt;&gt; <br>&gt;&gt; I just wanted to say that I have drafted a proposal that solves the issues that I have encountered. (It&#39;s here: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016219.html )<br>&gt;&gt; - it allows pasting text as-is<br>&gt;&gt; - it allows creating string literals where leading space on each line is stripped (while keeping indentation differences intact)<br>&gt;&gt; - it allows creating string literals where leading space on each line is not stripped<br>&gt;&gt; - optionally it allows strings to be raw, without any string interpolation or escaping whatsoever<br>&gt;&gt; - in none of the literals you have to write &quot;&lt;book id=\&quot;bk101\&quot; empty=\&quot;\&quot;&gt;&quot;, you can just write &quot;&quot;&quot;&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;&quot;&quot;&quot;. This also lets you copy&amp;paste text out of the program source and back into a HTML file.<br>&gt;&gt; <br>&gt;&gt; It had the idea that maybe the motivation behind continuation quotes is to make using multiline strings harder to use; in order to discourage their use at all. Two points to consider:<br>&gt;&gt; - people who don&#39;t want to use MSL will not, even if you throw Python-like &quot;&quot;&quot;multi-line strings&quot;&quot;&quot; at them.<br>&gt;&gt; - people who want to use them do it, even if there is no MSL available. I saw that in Objective-C, with multiple lines of HTML and CSS wrapped into a big multiline objc-string-literal and thrown at a WebView. I could send the literal to the console before sending it to the WebView and it was basically unreadable. I eventually refactored it to put the thing into a file (also because the HTML grew in space, and the inline-literal became impractical)<br>&gt;&gt; - my most important point: if someone uses multiple lines of HTML or CSS or XML directly within the code, I want it to look okay. I don&#39;t want an MSL feature that is so unwieldy that people voluntarily not use it; it would be better to have no MSL at all.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that multiline strings are a must-have feature for a language, because they are not used very often. (I included an example of a good use case in my proposal.) I acknowledge that in many programming cases it would be better to not put a huge pile of text directly into the source, but to load the text from a file at runtime. But even when these MSL are misused, I prefer to read a &quot;&quot;&quot;python multiline string&quot;&quot;&quot; over a &quot;concatenated\n&quot;+&quot;Java\n&quot;+&quot;String&quot;.<br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt; <br>&gt; <br>&gt; Hi Michael. hope this helps  https://gist.github.com/lmihalkovic/11f2b1b23b78bbb9cbf0292ffc480b3d<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; It had the idea that maybe the motivation behind continuation quotes is to make using multiline strings harder to use; in order to discourage their use at all.<br></p><p>Absolutely not, and frankly I resent the implication.<br></p><p>I&#39;m looking at a space where (in my opinion) all existing designs are ugly and inelegant and trying to find something better. There are *reasons* Swift 2 doesn&#39;t allow newlines in quote marks; I&#39;m trying to address them, not ignore them. There are nasty formatting problems; I&#39;m trying to solve them, not tolerate them. There are significant context-sensitivity issues; I&#39;m trying to fix them, not punt the problem to a syntax highlighter that is absent or incorrect in half of our tools.<br></p><p>Here&#39;s a piece of code-generating code I once wrote, ported to this prototype:<br></p><p>	https://gist.github.com/brentdax/8a8ee1f6028230f68ed85b7f3ebc95bf<br></p><p>(The actual code generation starts on line 93.) <br></p><p>And here&#39;s the same code in (beta-era) Swift 2:<br></p><p>	https://github.com/brentdax/WebResponder/blob/master/WebResponderCore/WebResponderCore/codes2swift.swift<br></p><p>I think the new version is an improvement over the old. I think I like it better than I would with `&quot;&quot;&quot;` or heredocs forcing things against the left margin. I think it&#39;s nice that I can look at any line—out of context, random access—and see which parts are string literals. I think if I want to add a doc comment to each of the constants it generates, I have to do a little awkward code shuffling, but the result is worth it:<br></p><p>	for statusLine in statusLines {<br>	    code +=  &quot;    /// The HTTP \(statusLine.code) \(statusLine.message) status, used with `HTTPResponseType.status`.<br>	             &quot;    \(statusLine.constant)<br>	             &quot;    <br>	             &quot;&quot;<br>	}<br></p><p>Overall, I find this code a lot more pleasant to read than it was in Swift 2, and somewhat more pleasant than it would be with `&quot;&quot;&quot;` or a heredoc. Maybe you don&#39;t agree; maybe you&#39;d rather import some other language&#39;s warts. I understand—those warts come with convenience advantages, and you might prefer that convenience to the other things.<br></p><p>But at least have the basic respect for opposing viewpoints not to impugn my motives because you disagree with me or don&#39;t like what I suggest. That is just not nice.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/fa9c40b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May  5, 2016 at 04:00:00pm</p></header><div class="content"><p>I admit I have not been following this closely and have not read all proposals and counter proposals and concerns - but of course that isn’t going to stop me from tossing out my own suggestion!<br></p><p>My idea starts with this:<br></p><p>let code = #string // some code that we are generating<br>         + #string and some more code here<br>         + #string another line here<br>         + #string<br>         + #string including a blank line if we wanted<br>         + #string etc.<br></p><p>When used in this way, it simply generates a string literal from everything that follows “#string” up to and including the newline. To chain multiple lines together, it just uses string’s normal + operator. This would be the same as writing the following code:<br></p><p>let code = &quot;// some code that we are generating\n&quot;<br>         + &quot;and some more code here\n&quot;<br>         + &quot;another line here\n&quot;<br>         + &quot;\n&quot;<br>         + &quot;including a blank line if we wanted\n&quot;<br>         + &quot;etc.\n&quot;<br></p><p>I would then extend this to support some other useful approaches such as:<br></p><p>#string(THE_END)<br>blah blah blah   \\\   blah<br>  can  be anything \o/<br>what    ever!!<br>THE_END<br></p><p>Or to use the entire contents of an external file:<br></p><p>#string(“file.txt&quot;)<br></p><p>l8r<br>Sean<br></p><p><br></p><p><br></p><p>&gt; On May 5, 2016, at 3:51 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; It had the idea that maybe the motivation behind continuation quotes is to make using multiline strings harder to use; in order to discourage their use at all.<br>&gt; <br>&gt; Absolutely not, and frankly I resent the implication.<br>&gt; <br>&gt; I&#39;m looking at a space where (in my opinion) all existing designs are ugly and inelegant and trying to find something better. There are *reasons* Swift 2 doesn&#39;t allow newlines in quote marks; I&#39;m trying to address them, not ignore them. There are nasty formatting problems; I&#39;m trying to solve them, not tolerate them. There are significant context-sensitivity issues; I&#39;m trying to fix them, not punt the problem to a syntax highlighter that is absent or incorrect in half of our tools.<br>&gt; <br>&gt; Here&#39;s a piece of code-generating code I once wrote, ported to this prototype:<br>&gt; <br>&gt; 	https://gist.github.com/brentdax/8a8ee1f6028230f68ed85b7f3ebc95bf<br>&gt; <br>&gt; (The actual code generation starts on line 93.) <br>&gt; <br>&gt; And here&#39;s the same code in (beta-era) Swift 2:<br>&gt; <br>&gt; 	https://github.com/brentdax/WebResponder/blob/master/WebResponderCore/WebResponderCore/codes2swift.swift<br>&gt; <br>&gt; I think the new version is an improvement over the old. I think I like it better than I would with `&quot;&quot;&quot;` or heredocs forcing things against the left margin. I think it&#39;s nice that I can look at any line—out of context, random access—and see which parts are string literals. I think if I want to add a doc comment to each of the constants it generates, I have to do a little awkward code shuffling, but the result is worth it:<br>&gt; <br>&gt; 	for statusLine in statusLines {<br>&gt; 	    code +=  &quot;    /// The HTTP \(statusLine.code) \(statusLine.message) status, used with `HTTPResponseType.status`.<br>&gt; 	             &quot;    \(statusLine.constant)<br>&gt; 	             &quot;    <br>&gt; 	             &quot;&quot;<br>&gt; 	}<br>&gt; <br>&gt; Overall, I find this code a lot more pleasant to read than it was in Swift 2, and somewhat more pleasant than it would be with `&quot;&quot;&quot;` or a heredoc. Maybe you don&#39;t agree; maybe you&#39;d rather import some other language&#39;s warts. I understand—those warts come with convenience advantages, and you might prefer that convenience to the other things.<br>&gt; <br>&gt; But at least have the basic respect for opposing viewpoints not to impugn my motives because you disagree with me or don&#39;t like what I suggest. That is just not nice.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May  5, 2016 at 11:00:00pm</p></header><div class="content"><p>I think that is another one of the advantages of using the continuation quotes. <br></p><p>Sent from my iPhone<br></p><p>&gt; On May 5, 2016, at 4:51 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;   <br>&gt; I think it&#39;s nice that I can look at any line—out of context, random access—and see which parts are string literals.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 06.05.2016 um 05:24 schrieb Ricardo Parada &lt;rparada at mac.com&gt;:<br>&gt; <br>&gt; I think that is another one of the advantages of using the continuation quotes. <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 5, 2016, at 4:51 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s nice that I can look at any line—out of context, random access—and see which parts are string literals.<br></p><p>Hmm, I use syntax highlighting for this ;)<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/369d2e2eccdbec4dcebf5bd6f99abb3a?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Uli Kusterer</string> &lt;kusterer at orangejuiceliberationfront.com&gt;<p>April 27, 2016 at 03:00:00am</p></header><div class="content"><p>On 22 Apr 2016, at 18:59, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; https://github.com/apple/swift/pull/2275<br>&gt; <br>&gt; The approach taken is as simple as possible defining multi-line strings as being<br>&gt; delimited by “”” instead of “ and thereafter able to contain new line characters.<br></p><p> Just ignore me if that&#39;s been covered in the archives already (there is a lot there, I&#39;m still catching up), but is there a reason we can&#39;t just allow newlines in the existing string constants and be done with it? Since they&#39;ve been invalid so far, nobody has code that contains line breaks that could be broken. At worst the code formatter would have to be told not to indent such lines, but beyond that, why are newlines in strings not permitted?<br></p><p>Cheers,<br>-- Uli Kusterer<br>&quot;The Witnesses of TeachText are everywhere...&quot;<br>http://stacksmith.org<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Just ignore me if that&#39;s been covered in the archives already (there is a lot there, I&#39;m still catching up), but is there a reason we can&#39;t just allow newlines in the existing string constants and be done with it? Since they&#39;ve been invalid so far, nobody has code that contains line breaks that could be broken. At worst the code formatter would have to be told not to indent such lines, but beyond that, why are newlines in strings not permitted?<br></p><p>In short: Runaway strings. If you forget to include an ending &quot;, the resulting error may be miles away from where you actually made a mistake.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/369d2e2eccdbec4dcebf5bd6f99abb3a?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Uli Kusterer</string> &lt;kusterer at orangejuiceliberationfront.com&gt;<p>April 27, 2016 at 03:00:00am</p></header><div class="content"><p>On 27 Apr 2016, at 03:24, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; Just ignore me if that&#39;s been covered in the archives already (there is a lot there, I&#39;m still catching up), but is there a reason we can&#39;t just allow newlines in the existing string constants and be done with it? Since they&#39;ve been invalid so far, nobody has code that contains line breaks that could be broken. At worst the code formatter would have to be told not to indent such lines, but beyond that, why are newlines in strings not permitted?<br>&gt; <br>&gt; In short: Runaway strings. If you forget to include an ending &quot;, the resulting error may be miles away from where you actually made a mistake.<br></p><p> Doesn&#39;t strike me as a problem needing a solution, though. Strings are syntax-colored differently than actual code. So if it&#39;s really runaway, you&#39;re likely to notice the wrong color. And the likelihood  of the code actually still compiling after grabbing the next random quote to terminate its string is rather small, too.<br></p><p>Cheers,<br>-- Uli Kusterer<br>&quot;The Witnesses of TeachText are everywhere...&quot;<br>http://stacksmith.org<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Doesn&#39;t strike me as a problem needing a solution, though. Strings are syntax-colored differently than actual code. So if it&#39;s really runaway, you&#39;re likely to notice the wrong color. And the likelihood  of the code actually still compiling after grabbing the next random quote to terminate its string is rather small, too.<br></p><p>Personally, I&#39;ve noticed in the last few days that I don&#39;t actually trust syntax highlighting very much to tell me where the end of a complicated string literal is, particularly when it uses complex features like multiline strings, escapes, and interpolations. Xcode and TextMate *are* both usually pretty reliable, but not always, and I have a lot of experience with older text editors with worse highlighting. As a result, I seem to automatically dismiss &quot;obviously wrong&quot; highlighting.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
