<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[swift-user]Unexpected behavior of protocol extension.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 20, 2016 at 10:00:00am</p></header><div class="content"><p>See below code.<br></p><p>protocol Foo {<br></p><p>    func bar()<br></p><p>}<br></p><p><br>extension Foo {<br></p><p>    func bar() {<br></p><p>        print(&quot;I am bar.&quot;)<br></p><p>    }<br></p><p>}<br></p><p><br>class A:Foo {<br></p><p>    func output() {<br></p><p>        print(type(of:self)) // prints &quot;B&quot;.<br></p><p>        self.bar() // prints &quot;I am bar.&quot;<br></p><p>        (self as! B).bar() // prints &quot;I am B.&quot;<br></p><p>    }<br></p><p>}<br></p><p><br>class B:A {<br></p><p>    func bar() {<br></p><p>        print(&quot;I am B.&quot;)<br></p><p>    }<br></p><p>}<br></p><p><br>let b = B()<br></p><p>b.output()<br></p><p><br>I thought `self.bar()` would do the same as `(self as! B).bar()`. It<br>didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the<br>same, shouldn&#39;t they?<br></p><p><br>Zhaoxin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160920/8a6a40d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c45573c04087ddcfa76a22095bb0877b?s=50"></div><header><strong>[swift-user]Unexpected behavior of protocol extension.</strong> from <string>Игорь Никитин</string> &lt;devnikor at icloud.com&gt;<p>September 20, 2016 at 09:00:00am</p></header><div class="content"><p>Looks like a bug according to dispatch rules (here &lt;https://medium.com/ios-os-x-development/swift-protocol-extension-method-dispatch-6a6bf270ba94#.8zlhlu8s6&gt; and here &lt;https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future?utm_campaign=iOS+Dev+Weekly&amp;utm_medium=web&amp;utm_source=iOS_Dev_Weekly_Issue_203&gt;. Also similar question on SO &lt;http://stackoverflow.com/questions/34847318/swift-protocol-extension-method-dispatch-with-superclass-and-subclass&gt;)<br>It should call dynamic bar implementation<br></p><p>&gt; 20 сент. 2016 г., в 5:11, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; написал(а):<br>&gt; <br>&gt; See below code.<br>&gt; <br>&gt; protocol Foo {<br>&gt;     func bar()<br>&gt; }<br>&gt; <br>&gt; extension Foo {<br>&gt;     func bar() {<br>&gt;         print(&quot;I am bar.&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class A:Foo {<br>&gt;     func output() {<br>&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class B:A {<br>&gt;     func bar() {<br>&gt;         print(&quot;I am B.&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let b = B()<br>&gt; b.output()<br>&gt; <br>&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the same, shouldn&#39;t they?<br>&gt; <br>&gt; Zhaoxin<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160920/b293c91d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 20, 2016 at 10:00:00am</p></header><div class="content"><p>I can’t tell you the reason, but to me it feels like it’s doing the following thing:<br></p><p>+ - - (Type: B) - - +<br>|                   |<br>| func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>|               |                   |                                                                  |<br>+ - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>                |               |                         |                   |<br>                + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>                                |                         |<br>                                + - - - - - - - - - - - - +<br>class A:Foo {<br>     <br>    func bar() {}<br>     <br>    func output() {<br>        print(type(of:self))<br>        self.bar()<br>        (self as! B).bar()<br>    }<br>}<br></p><p>class B:A {<br></p><p>    override func bar() {<br>        print(&quot;I am B.&quot;)<br>    }<br>}<br>Would solve this temporarily.<br></p><p>And there we are again with the same discussion if custom implementation of protocol members, which have default implementation, should have the override keyword or not.<br></p><p>Imagine your code like this (not valid code):<br></p><p>protocol Foo {<br>    func bar()<br>}<br></p><p>extension Foo {<br>    func bar() {<br>        print(&quot;I am bar.&quot;)<br>    }<br>}<br></p><p>class A : Foo {<br>     <br>    func output() {<br>         <br>        print(type(of:self))<br>        default.bar() // fallback an call directly the default implementation whenever needed<br>        self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>        (self as! B).bar()<br>    }<br>}<br></p><p>class B : A {<br></p><p>    override func bar() {<br>        print(&quot;I am B.&quot;)<br>    }<br>}<br>I still think default implementations should be called through something like default. + whenever you override a default implementation you’d need override. There is a discussion going on: Mark protocol methods with their protocol. I clearly did not solved your issue, but I might have wake your interest to participate. ;)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (swift-users at swift.org) schrieb:<br></p><p>See below code.<br></p><p>protocol Foo {<br>    func bar()<br>}<br></p><p>extension Foo {<br>    func bar() {<br>        print(&quot;I am bar.&quot;)<br>    }<br>}<br></p><p>class A:Foo {<br>    func output() {<br>        print(type(of:self)) // prints &quot;B&quot;.<br>        self.bar() // prints &quot;I am bar.&quot;<br>        (self as! B).bar() // prints &quot;I am B.&quot;<br>    }<br>}<br></p><p>class B:A {<br>    func bar() {<br>        print(&quot;I am B.&quot;)<br>    }<br>}<br></p><p>let b = B()<br>b.output()<br></p><p>I thought `self.bar()` would do the same as `(self as! B).bar()`. It didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the same, shouldn&#39;t they?<br></p><p>Zhaoxin<br>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/20767f57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 20, 2016 at 08:00:00pm</p></header><div class="content"><p>Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself<br>for this behavior.<br></p><p>As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`, so<br>there is no `override func bar()` in class B`. My thought that  `self.bar()`<br>would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;,<br>which is basing on the `override`. Since there is no `override`, there is<br>no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic<br>type of `self`. It was not. I was wrong.<br></p><p>The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds<br>that there is no implementation of `bar()` in `class A`, so it calls the<br>`bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class<br>B` contains the implementation of `bar()`, the runtime calls it.<br></p><p>Zhaoxin<br></p><p>On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I can’t tell you the reason, but to me it feels like it’s doing the<br>&gt; following thing:<br>&gt;<br>&gt; + - - (Type: B) - - +<br>&gt; |                   |<br>&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt; |               |                   |                                                                  |<br>&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;                 |               |                         |                   |<br>&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;                                 |                         |<br>&gt;                                 + - - - - - - - - - - - - +<br>&gt;<br>&gt; class A:Foo {<br>&gt;<br>&gt;     func bar() {}<br>&gt;<br>&gt;     func output() {<br>&gt;         print(type(of:self))<br>&gt;         self.bar()<br>&gt;         (self as! B).bar()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class B:A {<br>&gt;<br>&gt;     override func bar() {<br>&gt;         print(&quot;I am B.&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Would solve this temporarily.<br>&gt;<br>&gt; And there we are again with the same discussion if custom implementation<br>&gt; of protocol members, which have default implementation, should have the<br>&gt; override keyword or not.<br>&gt;<br>&gt; Imagine your code like this (not valid code):<br>&gt;<br>&gt; protocol Foo {<br>&gt;     func bar()<br>&gt; }<br>&gt;<br>&gt; extension Foo {<br>&gt;     func bar() {<br>&gt;         print(&quot;I am bar.&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class A : Foo {<br>&gt;<br>&gt;     func output() {<br>&gt;<br>&gt;         print(type(of:self))<br>&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;         (self as! B).bar()<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class B : A {<br>&gt;<br>&gt;     override func bar() {<br>&gt;         print(&quot;I am B.&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; I still think default implementations should be called through something<br>&gt; like default. + whenever you override a default implementation you’d need<br>&gt; override. There is a discussion going on: Mark protocol methods with<br>&gt; their protocol. I clearly did not solved your issue, but I might have<br>&gt; wake your interest to participate. ;)<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (<br>&gt; swift-users at swift.org) schrieb:<br>&gt;<br>&gt; See below code.<br>&gt;<br>&gt; protocol Foo {<br>&gt;<br>&gt;     func bar()<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; extension Foo {<br>&gt;<br>&gt;     func bar() {<br>&gt;<br>&gt;         print(&quot;I am bar.&quot;)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; class A:Foo {<br>&gt;<br>&gt;     func output() {<br>&gt;<br>&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;<br>&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;<br>&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; class B:A {<br>&gt;<br>&gt;     func bar() {<br>&gt;<br>&gt;         print(&quot;I am B.&quot;)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let b = B()<br>&gt;<br>&gt; b.output()<br>&gt;<br>&gt;<br>&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It<br>&gt; didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the<br>&gt; same, shouldn&#39;t they?<br>&gt;<br>&gt;<br>&gt; Zhaoxin<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/c46874d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 20, 2016 at 11:00:00am</p></header><div class="content"><p>I think there is a deeper issue that may be worth exploring here.<br></p><p>Notably, when one class presents a member function, its subclasses ought to<br>use “override” when they reimplement that method themselves, regardless of<br>where the superclass’s version comes from.<br></p><p>In the original post, the class “A” expresses (by conforming to protocol<br>“Foo”) that it has a member function “bar()”, and “B” is a subclass of “A”<br>which wants its own definition of “bar()”.<br></p><p>It seems to me that “B” should not care whether “A” rolled its own<br>implementation of “bar()” or used the default implementation provided by<br>“Foo”.<br></p><p>&gt;From the perspective of “B”, its superclass “A” promises to have a member<br>function “bar()”, so “B” should need to use the `override` keyword just<br>like it would when overriding any other method.<br></p><p>To illustrate this more clearly, suppose that “Foo” and “A: Foo” are<br>defined in a 3rd-party library, while “B: A” is written in a client module.<br></p><p>If the library changes to give “A” its own custom implementation of<br>“bar()”, that *should not* affect client code—because the class “A” still<br>conforms to “Foo” so it still is known to have a “bar()” method—but right<br>now it *does*:<br></p><p>With the status quo, the simple change of moving a function between a<br>protocol extension and a conforming class currently requires downstream<br>source-code modifications in clients (in this case, adding `override` to<br>“B.bar()”).<br></p><p>I propose that `override` should be required in subclasses on any method<br>which the superclass proffers as a customization point, no matter the<br>provenance of that claim.<br></p><p>Nevin<br></p><p><br></p><p>On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself<br>&gt; for this behavior.<br>&gt;<br>&gt; As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`,<br>&gt; so there is no `override func bar()` in class B`. My thought that  `self.bar()`<br>&gt; would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;,<br>&gt; which is basing on the `override`. Since there is no `override`, there is<br>&gt; no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic<br>&gt; type of `self`. It was not. I was wrong.<br>&gt;<br>&gt; The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds<br>&gt; that there is no implementation of `bar()` in `class A`, so it calls the<br>&gt; `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class<br>&gt; B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I can’t tell you the reason, but to me it feels like it’s doing the<br>&gt;&gt; following thing:<br>&gt;&gt;<br>&gt;&gt; + - - (Type: B) - - +<br>&gt;&gt; |                   |<br>&gt;&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt;&gt; |               |                   |                                                                  |<br>&gt;&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;&gt;                 |               |                         |                   |<br>&gt;&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;&gt;                                 |                         |<br>&gt;&gt;                                 + - - - - - - - - - - - - +<br>&gt;&gt;<br>&gt;&gt; class A:Foo {<br>&gt;&gt;<br>&gt;&gt;     func bar() {}<br>&gt;&gt;<br>&gt;&gt;     func output() {<br>&gt;&gt;         print(type(of:self))<br>&gt;&gt;         self.bar()<br>&gt;&gt;         (self as! B).bar()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class B:A {<br>&gt;&gt;<br>&gt;&gt;     override func bar() {<br>&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Would solve this temporarily.<br>&gt;&gt;<br>&gt;&gt; And there we are again with the same discussion if custom implementation<br>&gt;&gt; of protocol members, which have default implementation, should have the<br>&gt;&gt; override keyword or not.<br>&gt;&gt;<br>&gt;&gt; Imagine your code like this (not valid code):<br>&gt;&gt;<br>&gt;&gt; protocol Foo {<br>&gt;&gt;     func bar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Foo {<br>&gt;&gt;     func bar() {<br>&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class A : Foo {<br>&gt;&gt;<br>&gt;&gt;     func output() {<br>&gt;&gt;<br>&gt;&gt;         print(type(of:self))<br>&gt;&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;&gt;         (self as! B).bar()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class B : A {<br>&gt;&gt;<br>&gt;&gt;     override func bar() {<br>&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I still think default implementations should be called through something<br>&gt;&gt; like default. + whenever you override a default implementation you’d<br>&gt;&gt; need override. There is a discussion going on: Mark protocol methods<br>&gt;&gt; with their protocol. I clearly did not solved your issue, but I might<br>&gt;&gt; have wake your interest to participate. ;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (<br>&gt;&gt; swift-users at swift.org) schrieb:<br>&gt;&gt;<br>&gt;&gt; See below code.<br>&gt;&gt;<br>&gt;&gt; protocol Foo {<br>&gt;&gt;<br>&gt;&gt;     func bar()<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; extension Foo {<br>&gt;&gt;<br>&gt;&gt;     func bar() {<br>&gt;&gt;<br>&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; class A:Foo {<br>&gt;&gt;<br>&gt;&gt;     func output() {<br>&gt;&gt;<br>&gt;&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;<br>&gt;&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;<br>&gt;&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; class B:A {<br>&gt;&gt;<br>&gt;&gt;     func bar() {<br>&gt;&gt;<br>&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let b = B()<br>&gt;&gt;<br>&gt;&gt; b.output()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It<br>&gt;&gt; didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the<br>&gt;&gt; same, shouldn&#39;t they?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Zhaoxin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/236349f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 20, 2016 at 09:00:00pm</p></header><div class="content"><p>This would make for hilarious debugging session if you have the misfortune of using a third party binary framework that gets updated and provide default implementations for some methods in the protocol extensions.<br></p><p>When Java 8 also decided to blur the lines between classes (implementations) and interfaces (equivalent of protocols on this side of the fence more or less... anyways they represent behaviours/API contracts), they also provided a very simple rule to determine on the code would behave at runtime.<br>&gt; Extending Interfaces That Contain Default Methods<br>&gt; <br>&gt; When you extend an interface that contains a default method, you can do the following:<br>&gt; <br>&gt; Not mention the default method at all, which lets your extended interface inherit the default method.<br>&gt; Redeclare the default method, which makes it abstract.<br>&gt; Redefine the default method, which overrides it.<br></p><p>https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html<br></p><p>I am not sure why protocol extension need to differ so much and present dispatch rules that are potentially very confusing. <br></p><p>Casting at runtime should *never* change what implementation of a method gets called. <br>For a safe by default language the fact that this can occur is quite puzzling and worrying. I am not sure the cost of implementing the current static/dynamic dispatch rules for default methods in protocol extensions is worth it to say it bluntly, but please enlighten me if I am missing an obvious huge pink elephant in the room here.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 20 Sep 2016, at 16:18, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think there is a deeper issue that may be worth exploring here.<br>&gt; <br>&gt; Notably, when one class presents a member function, its subclasses ought to use “override” when they reimplement that method themselves, regardless of where the superclass’s version comes from.<br>&gt; <br>&gt; In the original post, the class “A” expresses (by conforming to protocol “Foo”) that it has a member function “bar()”, and “B” is a subclass of “A” which wants its own definition of “bar()”.<br>&gt; <br>&gt; It seems to me that “B” should not care whether “A” rolled its own implementation of “bar()” or used the default implementation provided by “Foo”.<br>&gt; <br>&gt; From the perspective of “B”, its superclass “A” promises to have a member function “bar()”, so “B” should need to use the `override` keyword just like it would when overriding any other method.<br>&gt; <br>&gt; To illustrate this more clearly, suppose that “Foo” and “A: Foo” are defined in a 3rd-party library, while “B: A” is written in a client module.<br>&gt; <br>&gt; If the library changes to give “A” its own custom implementation of “bar()”, that *should not* affect client code—because the class “A” still conforms to “Foo” so it still is known to have a “bar()” method—but right now it *does*:<br>&gt; <br>&gt; With the status quo, the simple change of moving a function between a protocol extension and a conforming class currently requires downstream source-code modifications in clients (in this case, adding `override` to “B.bar()”).<br>&gt; <br>&gt; I propose that `override` should be required in subclasses on any method which the superclass proffers as a customization point, no matter the provenance of that claim.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself for this behavior.<br>&gt;&gt; <br>&gt;&gt; As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`, so there is no `override func bar()` in class B`. My thought that  `self.bar()` would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;, which is basing on the `override`. Since there is no `override`, there is no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic type of `self`. It was not. I was wrong.<br>&gt;&gt; <br>&gt;&gt; The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds that there is no implementation of `bar()` in `class A`, so it calls the `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;&gt; <br>&gt;&gt; Zhaoxin<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I can’t tell you the reason, but to me it feels like it’s doing the following thing:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; + - - (Type: B) - - +<br>&gt;&gt;&gt; |                   |<br>&gt;&gt;&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt;&gt;&gt; |               |                   |                                                                  |<br>&gt;&gt;&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;&gt;&gt;                 |               |                         |                   |<br>&gt;&gt;&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;&gt;&gt;                                 |                         |<br>&gt;&gt;&gt;                                 + - - - - - - - - - - - - +<br>&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;      <br>&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt;      <br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         self.bar()<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Would solve this temporarily.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And there we are again with the same discussion if custom implementation of protocol members, which have default implementation, should have the override keyword or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Imagine your code like this (not valid code):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A : Foo {<br>&gt;&gt;&gt;      <br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;          <br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;&gt;&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; I still think default implementations should be called through something like default. + whenever you override a default implementation you’d need override. There is a discussion going on: Mark protocol methods with their protocol. I clearly did not solved your issue, but I might have wake your interest to participate. ;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (swift-users at swift.org) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See below code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;&gt;&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;&gt;&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let b = B()<br>&gt;&gt;&gt;&gt; b.output()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the same, shouldn&#39;t they?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zhaoxin<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/b6a28703/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 21, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; I am not sure why protocol extension need to differ so much and present<br>dispatch rules that are potentially very confusing.<br></p><p>I think that both the Java and Swift designers want to get the benefits<br>of multiple inherences, in the meaning time, they don&#39;t want to support<br>multiple objects inherence.<br></p><p>For Java only, as Java allows implicit override, the `@override` is<br>optional. Related bugs are hard to find if you don&#39;t use  `@override`.<br></p><p>For me, the current rule is simple.<br>1. If there is a `override`, it is &quot;class dynamic binding&quot;. If there is no<br>`override`, it is not. The dynamic type of `self` is irrelevant.<br>2. The method in &#39;protocol extension` is default, which means fail safe. It<br>is not a method of a class until the class implements it.<br></p><p>Zhaoxin<br></p><p>On Wed, Sep 21, 2016 at 4:10 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt;<br>wrote:<br></p><p>&gt; This would make for hilarious debugging session if you have the misfortune<br>&gt; of using a third party binary framework that gets updated and provide<br>&gt; default implementations for some methods in the protocol extensions.<br>&gt;<br>&gt; When Java 8 also decided to blur the lines between classes<br>&gt; (implementations) and interfaces (equivalent of protocols on this side of<br>&gt; the fence more or less... anyways they represent behaviours/API contracts),<br>&gt; they also provided a very simple rule to determine on the code would behave<br>&gt; at runtime.<br>&gt;<br>&gt; Extending Interfaces That Contain Default Methods<br>&gt;<br>&gt; When you extend an interface that contains a default method, you can do<br>&gt; the following:<br>&gt;<br>&gt;    - Not mention the default method at all, which lets your extended<br>&gt;    interface inherit the default method.<br>&gt;    - Redeclare the default method, which makes it abstract.<br>&gt;    - Redefine the default method, which overrides it.<br>&gt;<br>&gt; https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html<br>&gt;<br>&gt; I am not sure why protocol extension need to differ so much and present<br>&gt; dispatch rules that are potentially very confusing.<br>&gt;<br>&gt; Casting at runtime should *never* change what implementation of a method<br>&gt; gets called.<br>&gt; For a safe by default language the fact that this can occur is quite<br>&gt; puzzling and worrying. I am not sure the cost of implementing the current<br>&gt; static/dynamic dispatch rules for default methods in protocol extensions is<br>&gt; worth it to say it bluntly, but please enlighten me if I am missing an<br>&gt; obvious huge pink elephant in the room here.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 20 Sep 2016, at 16:18, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think there is a deeper issue that may be worth exploring here.<br>&gt;<br>&gt; Notably, when one class presents a member function, its subclasses ought<br>&gt; to use “override” when they reimplement that method themselves, regardless<br>&gt; of where the superclass’s version comes from.<br>&gt;<br>&gt; In the original post, the class “A” expresses (by conforming to protocol<br>&gt; “Foo”) that it has a member function “bar()”, and “B” is a subclass of “A”<br>&gt; which wants its own definition of “bar()”.<br>&gt;<br>&gt; It seems to me that “B” should not care whether “A” rolled its own<br>&gt; implementation of “bar()” or used the default implementation provided by<br>&gt; “Foo”.<br>&gt;<br>&gt; From the perspective of “B”, its superclass “A” promises to have a member<br>&gt; function “bar()”, so “B” should need to use the `override` keyword just<br>&gt; like it would when overriding any other method.<br>&gt;<br>&gt; To illustrate this more clearly, suppose that “Foo” and “A: Foo” are<br>&gt; defined in a 3rd-party library, while “B: A” is written in a client module.<br>&gt;<br>&gt; If the library changes to give “A” its own custom implementation of<br>&gt; “bar()”, that *should not* affect client code—because the class “A” still<br>&gt; conforms to “Foo” so it still is known to have a “bar()” method—but right<br>&gt; now it *does*:<br>&gt;<br>&gt; With the status quo, the simple change of moving a function between a<br>&gt; protocol extension and a conforming class currently requires downstream<br>&gt; source-code modifications in clients (in this case, adding `override` to<br>&gt; “B.bar()”).<br>&gt;<br>&gt; I propose that `override` should be required in subclasses on any method<br>&gt; which the superclass proffers as a customization point, no matter the<br>&gt; provenance of that claim.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself<br>&gt;&gt; for this behavior.<br>&gt;&gt;<br>&gt;&gt; As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`,<br>&gt;&gt; so there is no `override func bar()` in class B`. My thought that  `self.bar()`<br>&gt;&gt; would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;,<br>&gt;&gt; which is basing on the `override`. Since there is no `override`, there is<br>&gt;&gt; no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic<br>&gt;&gt; type of `self`. It was not. I was wrong.<br>&gt;&gt;<br>&gt;&gt; The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds<br>&gt;&gt; that there is no implementation of `bar()` in `class A`, so it calls the<br>&gt;&gt; `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class<br>&gt;&gt; B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;&gt;<br>&gt;&gt; Zhaoxin<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I can’t tell you the reason, but to me it feels like it’s doing the<br>&gt;&gt;&gt; following thing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; + - - (Type: B) - - +<br>&gt;&gt;&gt; |                   |<br>&gt;&gt;&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt;&gt;&gt; |               |                   |                                                                  |<br>&gt;&gt;&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;&gt;&gt;                 |               |                         |                   |<br>&gt;&gt;&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;&gt;&gt;                                 |                         |<br>&gt;&gt;&gt;                                 + - - - - - - - - - - - - +<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         self.bar()<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would solve this temporarily.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And there we are again with the same discussion if custom implementation<br>&gt;&gt;&gt; of protocol members, which have default implementation, should have the<br>&gt;&gt;&gt; override keyword or not.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Imagine your code like this (not valid code):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A : Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;&gt;&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still think default implementations should be called through something<br>&gt;&gt;&gt; like default. + whenever you override a default implementation you’d<br>&gt;&gt;&gt; need override. There is a discussion going on: Mark protocol methods<br>&gt;&gt;&gt; with their protocol. I clearly did not solved your issue, but I might<br>&gt;&gt;&gt; have wake your interest to participate. ;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (<br>&gt;&gt;&gt; swift-users at swift.org) schrieb:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; See below code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let b = B()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; b.output()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It<br>&gt;&gt;&gt; didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the<br>&gt;&gt;&gt; same, shouldn&#39;t they?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Zhaoxin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/6f9410b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 21, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 21 Sep 2016, at 01:41, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; I am not sure why protocol extension need to differ so much and present dispatch rules that are potentially very confusing. <br>&gt; <br>&gt; I think that both the Java and Swift designers want to get the benefits of multiple inherences, in the meaning time, they don&#39;t want to support multiple objects inherence. <br>&gt; <br>&gt; For Java only, as Java allows implicit override, the `@override` is optional. Related bugs are hard to find if you don&#39;t use  `@override`.<br>&gt; <br>&gt; For me, the current rule is simple. <br>&gt; 1. If there is a `override`, it is &quot;class dynamic binding&quot;. If there is no `override`, it is not. The dynamic type of `self` is irrelevant.<br>&gt; 2. The method in &#39;protocol extension` is default, which means fail safe. It is not a method of a class until the class implements it.<br>&gt; <br></p><p>Classic dynamic binding has its charms yes ;).<br></p><p>To be on point, once you adopt the protocol, and thus the extensions that may also have been declared and the default methods, and you decide to override or happen to override the default implementation it is still not enough to make sure you will call your implementation in your own code. If the reference to the instance of the class is cast to the protocol type, I want other object to be aware of my API contract not the specific class instance, then the protocol default method gets called and that is several shades of not appropriate for me.<br></p><p>https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future (with subclassing this can get more complicated)<br></p><p>Reasoning:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html<br></p><p>... hence why turning protocol dispatching into dynamic dispatching, unless the user says otherwise (@Kevin: sometimes it makes the language easier to use without sacrificing speed if we renounce a tad of purity and accept a dedicated keyword as compiler hint... a simple @static or something would suffice).<br>Updating a version of a binary framework could be covered in extra perils you do not need.<br></p><p>&gt; Zhaoxin<br>&gt; <br>&gt;&gt; On Wed, Sep 21, 2016 at 4:10 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; This would make for hilarious debugging session if you have the misfortune of using a third party binary framework that gets updated and provide default implementations for some methods in the protocol extensions.<br>&gt;&gt; <br>&gt;&gt; When Java 8 also decided to blur the lines between classes (implementations) and interfaces (equivalent of protocols on this side of the fence more or less... anyways they represent behaviours/API contracts), they also provided a very simple rule to determine on the code would behave at runtime.<br>&gt;&gt;&gt; Extending Interfaces That Contain Default Methods<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you extend an interface that contains a default method, you can do the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not mention the default method at all, which lets your extended interface inherit the default method.<br>&gt;&gt;&gt; Redeclare the default method, which makes it abstract.<br>&gt;&gt;&gt; Redefine the default method, which overrides it.<br>&gt;&gt; <br>&gt;&gt; https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html<br>&gt;&gt; <br>&gt;&gt; I am not sure why protocol extension need to differ so much and present dispatch rules that are potentially very confusing. <br>&gt;&gt; <br>&gt;&gt; Casting at runtime should *never* change what implementation of a method gets called. <br>&gt;&gt; For a safe by default language the fact that this can occur is quite puzzling and worrying. I am not sure the cost of implementing the current static/dynamic dispatch rules for default methods in protocol extensions is worth it to say it bluntly, but please enlighten me if I am missing an obvious huge pink elephant in the room here.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 20 Sep 2016, at 16:18, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there is a deeper issue that may be worth exploring here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notably, when one class presents a member function, its subclasses ought to use “override” when they reimplement that method themselves, regardless of where the superclass’s version comes from.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the original post, the class “A” expresses (by conforming to protocol “Foo”) that it has a member function “bar()”, and “B” is a subclass of “A” which wants its own definition of “bar()”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that “B” should not care whether “A” rolled its own implementation of “bar()” or used the default implementation provided by “Foo”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the perspective of “B”, its superclass “A” promises to have a member function “bar()”, so “B” should need to use the `override` keyword just like it would when overriding any other method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To illustrate this more clearly, suppose that “Foo” and “A: Foo” are defined in a 3rd-party library, while “B: A” is written in a client module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the library changes to give “A” its own custom implementation of “bar()”, that *should not* affect client code—because the class “A” still conforms to “Foo” so it still is known to have a “bar()” method—but right now it *does*:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the status quo, the simple change of moving a function between a protocol extension and a conforming class currently requires downstream source-code modifications in clients (in this case, adding `override` to “B.bar()”).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that `override` should be required in subclasses on any method which the superclass proffers as a customization point, no matter the provenance of that claim.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself for this behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`, so there is no `override func bar()` in class B`. My thought that  `self.bar()` would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;, which is basing on the `override`. Since there is no `override`, there is no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic type of `self`. It was not. I was wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds that there is no implementation of `bar()` in `class A`, so it calls the `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Zhaoxin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I can’t tell you the reason, but to me it feels like it’s doing the following thing:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; + - - (Type: B) - - +<br>&gt;&gt;&gt;&gt;&gt; |                   |<br>&gt;&gt;&gt;&gt;&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt;&gt;&gt;&gt;&gt; |               |                   |                                                                  |<br>&gt;&gt;&gt;&gt;&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;&gt;&gt;&gt;&gt;                 |               |                         |                   |<br>&gt;&gt;&gt;&gt;&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;&gt;&gt;&gt;&gt;                                 |                         |<br>&gt;&gt;&gt;&gt;&gt;                                 + - - - - - - - - - - - - +<br>&gt;&gt;&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;&gt;&gt;         self.bar()<br>&gt;&gt;&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Would solve this temporarily.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And there we are again with the same discussion if custom implementation of protocol members, which have default implementation, should have the override keyword or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Imagine your code like this (not valid code):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class A : Foo {<br>&gt;&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;&gt;&gt;          <br>&gt;&gt;&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;&gt;&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;&gt;&gt;&gt;&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;&gt;&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; I still think default implementations should be called through something like default. + whenever you override a default implementation you’d need override. There is a discussion going on: Mark protocol methods with their protocol. I clearly did not solved your issue, but I might have wake your interest to participate. ;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (swift-users at swift.org) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; See below code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let b = B()<br>&gt;&gt;&gt;&gt;&gt;&gt; b.output()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the same, shouldn&#39;t they?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Zhaoxin<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/2f9781f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 21, 2016 at 01:00:00pm</p></header><div class="content"><p>On 21.09.2016 9:30, Goffredo Marocchi via swift-evolution wrote:<br>&gt; If the reference to the instance of the class is cast to the protocol type,<br>&gt; I want other object to be aware of my API contract not the specific class<br>&gt; instance, then the protocol default method gets called and that is several<br>&gt; shades of not appropriate for me.<br></p><p>Could you provide some example? I was not able to reproduce such <br>behavior(and was not expected to be able):<br>(Probably, you want to mention helper methods in protocol extension that <br>was not defined *in protocol itself*, then yes. But AFAIK not for the <br>*default implementation* of protocol requirement i.e. the method/prop that <br>*is* declared in &quot;main&quot; protocol definition)<br></p><p>protocol A {<br>     func foo()<br>}<br></p><p>extension A {<br>     func foo() { print(&quot;A&quot;) }<br>}<br></p><p>class C : A {<br>     func foo() { print(&quot;C&quot;) }<br>}<br></p><p><br>let a : A = C()<br>a.foo() // &quot;C&quot;<br></p><p><br>func f(a: A) {<br>     a.foo()<br>}<br>f(a: a) // &quot;C&quot;<br></p><p><br>func g&lt;T&gt;(a: T) where T : A {<br>     a.foo()<br>}<br>g(a: C()) // &quot;C&quot;<br></p><p><br>func h&lt;T: Sequence&gt;(a: T) where T.Iterator.Element : A {<br>     for e in a {<br>         e.foo()<br>     }<br>}<br>h(a: [C()]) // &quot;C&quot;<br></p><p><br>func i&lt;T: Sequence&gt;(a: T) where T.Iterator.Element == A {<br>     for e in a {<br>         e.foo()<br>     }<br>}<br>i(a: [a]) // &quot;C&quot;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 21, 2016 at 08:00:00am</p></header><div class="content"><p>I understand your point on &quot;adding additional `override` to<br>re-implementation of default method in protocol extension&quot;. However, I<br>don&#39;t stand for it.<br></p><p>If you use `override`, that means `B` could use `super.bar()` to get the<br>original `bar()` implementation. Then if  `class A` implement `bar()`<br>someday. The `super.bar()` call in `class B` will be ambitious, it could be<br>`A.bar()` or `Foo.bar()`. That ambiguity is the same as the multiple object<br>inherences languages like c++. We all know that Swift can only inherit to<br>one object. That is why the behavior is what it is now.<br></p><p>Zhaoxin<br></p><p>On Tue, Sep 20, 2016 at 11:18 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; I think there is a deeper issue that may be worth exploring here.<br>&gt;<br>&gt; Notably, when one class presents a member function, its subclasses ought<br>&gt; to use “override” when they reimplement that method themselves, regardless<br>&gt; of where the superclass’s version comes from.<br>&gt;<br>&gt; In the original post, the class “A” expresses (by conforming to protocol<br>&gt; “Foo”) that it has a member function “bar()”, and “B” is a subclass of “A”<br>&gt; which wants its own definition of “bar()”.<br>&gt;<br>&gt; It seems to me that “B” should not care whether “A” rolled its own<br>&gt; implementation of “bar()” or used the default implementation provided by<br>&gt; “Foo”.<br>&gt;<br>&gt; From the perspective of “B”, its superclass “A” promises to have a member<br>&gt; function “bar()”, so “B” should need to use the `override` keyword just<br>&gt; like it would when overriding any other method.<br>&gt;<br>&gt; To illustrate this more clearly, suppose that “Foo” and “A: Foo” are<br>&gt; defined in a 3rd-party library, while “B: A” is written in a client module.<br>&gt;<br>&gt; If the library changes to give “A” its own custom implementation of<br>&gt; “bar()”, that *should not* affect client code—because the class “A” still<br>&gt; conforms to “Foo” so it still is known to have a “bar()” method—but right<br>&gt; now it *does*:<br>&gt;<br>&gt; With the status quo, the simple change of moving a function between a<br>&gt; protocol extension and a conforming class currently requires downstream<br>&gt; source-code modifications in clients (in this case, adding `override` to<br>&gt; “B.bar()”).<br>&gt;<br>&gt; I propose that `override` should be required in subclasses on any method<br>&gt; which the superclass proffers as a customization point, no matter the<br>&gt; provenance of that claim.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince myself<br>&gt;&gt; for this behavior.<br>&gt;&gt;<br>&gt;&gt; As Adrian&#39;s example shows, there is no `bar()` implemented in `class A`,<br>&gt;&gt; so there is no `override func bar()` in class B`. My thought that  `self.bar()`<br>&gt;&gt; would do the same as `(self as! B).bar()`, is called &quot;dynamic binding&quot;,<br>&gt;&gt; which is basing on the `override`. Since there is no `override`, there is<br>&gt;&gt; no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot; was basing on dynamic<br>&gt;&gt; type of `self`. It was not. I was wrong.<br>&gt;&gt;<br>&gt;&gt; The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds<br>&gt;&gt; that there is no implementation of `bar()` in `class A`, so it calls the<br>&gt;&gt; `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as `class<br>&gt;&gt; B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;&gt;<br>&gt;&gt; Zhaoxin<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I can’t tell you the reason, but to me it feels like it’s doing the<br>&gt;&gt;&gt; following thing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; + - - (Type: B) - - +<br>&gt;&gt;&gt; |                   |<br>&gt;&gt;&gt; | func bar()    + - + (Type: A) - - +                        &lt; - - - - - - - - - - - - - - - - - - - - +<br>&gt;&gt;&gt; |               |                   |                                                                  |<br>&gt;&gt;&gt; + - - - - - - - + func output() + - + (Protocol: Foo) - - +  — - self.bar() - + - (self as! B).bar() - +<br>&gt;&gt;&gt;                 |               |                         |                   |<br>&gt;&gt;&gt;                 + - - - - - - - + (default) func bar()    |  &lt;- - - - - - - - +<br>&gt;&gt;&gt;                                 |                         |<br>&gt;&gt;&gt;                                 + - - - - - - - - - - - - +<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         self.bar()<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would solve this temporarily.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And there we are again with the same discussion if custom implementation<br>&gt;&gt;&gt; of protocol members, which have default implementation, should have the<br>&gt;&gt;&gt; override keyword or not.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Imagine your code like this (not valid code):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A : Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(type(of:self))<br>&gt;&gt;&gt;         default.bar() // fallback an call directly the default implementation whenever needed<br>&gt;&gt;&gt;         self.bar() // will print &quot;I am bar.&quot; on A().output() but should print &quot;I am B.&quot; if Self == B<br>&gt;&gt;&gt;         (self as! B).bar()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B : A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     override func bar() {<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still think default implementations should be called through something<br>&gt;&gt;&gt; like default. + whenever you override a default implementation you’d<br>&gt;&gt;&gt; need override. There is a discussion going on: Mark protocol methods<br>&gt;&gt;&gt; with their protocol. I clearly did not solved your issue, but I might<br>&gt;&gt;&gt; have wake your interest to participate. ;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users (<br>&gt;&gt;&gt; swift-users at swift.org) schrieb:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; See below code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(&quot;I am bar.&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A:Foo {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func output() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B:A {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func bar() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         print(&quot;I am B.&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let b = B()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; b.output()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I thought `self.bar()` would do the same as `(self as! B).bar()`. It<br>&gt;&gt;&gt; didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they should be the<br>&gt;&gt;&gt; same, shouldn&#39;t they?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Zhaoxin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/0cd466df/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[swift-users] [swift-user]Unexpected behavior of protocol extension.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 22, 2016 at 02:00:00pm</p></header><div class="content"><p>Btw,..<br></p><p>On 20.09.2016 18:18, Nevin Brackett-Rozinsky via swift-evolution wrote:<br>&gt; I think there is a deeper issue that may be worth exploring here.<br>&gt;<br>&gt; Notably, when one class presents a member function, its subclasses ought to<br>&gt; use “override” when they reimplement that method themselves, regardless of<br>&gt; where the superclass’s version comes from.<br>&gt;<br>&gt; In the original post, the class “A” expresses (by conforming to protocol<br>&gt; “Foo”) that it has a member function “bar()”, and “B” is a subclass of “A”<br>&gt; which wants its own definition of “bar()”.<br>&gt;<br>&gt; It seems to me that “B” should not care whether “A” rolled its own<br>&gt; implementation of “bar()” or used the default implementation provided by “Foo”.<br>&gt;<br>&gt; From the perspective of “B”, its superclass “A” promises to have a member<br>&gt; function “bar()”, so “B” should need to use the `override` keyword just<br>&gt; like it would when overriding any other method.<br></p><p>See how &quot;my&quot; suggestion regarding requiring a keyword for implementation of <br>protocol requirement (but with `override` keyword instead of `implement`) <br>can be very helpful here<br>(And Karl, seems like &quot;your&quot; suggestion will not help here - I mean we&#39;ll <br>have to change bar() definition in B in case A implement its own bar())<br></p><p>In this case, initially, B.bar() must be marked with &quot;override&quot; as it is <br>implementing protocol&#39;s requirement. *And* this will &quot;protect&quot; B class in <br>future if class A will implement its own bar() method:<br></p><p>protocol Foo {<br>	func bar()<br>}<br></p><p>extension Foo {<br>	func bar() {<br>		print(&quot;I am bar.&quot;)<br>	}<br>}<br></p><p>class A:Foo {<br>}<br></p><p>class B:A {<br>	*override* func bar() { // currently protocol impelentation<br>		print(&quot;I am B.&quot;)<br>	}<br>}<br></p><p>and then if<br></p><p>class A:Foo {<br>	override func bar() {...}<br>}<br></p><p>,B&#39;s definition will not be changed.<br></p><p>Then we have a question regarding super.bar() inside B.bar(), i.e. should <br>it be accessible or not. I believe we should consider if it could be <br>implemented, so in case A has no bar(), super.bar() will call protocol&#39;s <br>implementation, otherwise (if A contains bar()) - A.bar() will be called. <br>Don&#39;t know if this is what very hard to implement.<br>Probably as first step super.bar() will not be allowed inside of protocol <br>implementation.<br></p><p>Swift allows for protocols to have default *implementations* for <br>requirements. And *also* Swift allows you to *not* implement requirement <br>that has default implementation in conformed type.<br>When you don&#39;t implement such requirement in type - the type *inherits* <br>that implementation. We have classical inheritance scheme like in <br>inheritance of super type&#39;s method. When you override super type&#39;s method <br>you have to use `override`. I believe overriding the inherited default <br>implementation of requirement - also should be marked with `override`.<br></p><p>Then, Swift allows protocol to have extension in any source file in <br>project. You can have no default implementation *at moment of writing* your <br>type, but you can have such default implementation *at moment of <br>compilation*. So, as soon as we *can&#39;t* know if protocol&#39;s requirement will <br>*actually* have default implementation during the compilation - logically <br>that we should use `override` to mark each method/prop defined as <br>implementation of protocol, to suppose that there *is* default <br>implementation which will be *overridden* by our custom implementation.<br></p><p>&gt;<br>&gt; To illustrate this more clearly, suppose that “Foo” and “A: Foo” are<br>&gt; defined in a 3rd-party library, while “B: A” is written in a client module.<br>&gt;<br>&gt; If the library changes to give “A” its own custom implementation of<br>&gt; “bar()”, that *should not* affect client code—because the class “A” still<br>&gt; conforms to “Foo” so it still is known to have a “bar()” method—but right<br>&gt; now it *does*:<br>&gt;<br>&gt; With the status quo, the simple change of moving a function between a<br>&gt; protocol extension and a conforming class currently requires downstream<br>&gt; source-code modifications in clients (in this case, adding `override` to<br>&gt; “B.bar()”).<br>&gt;<br>&gt; I propose that `override` should be required in subclasses on any method<br>&gt; which the superclass proffers as a customization point, no matter the<br>&gt; provenance of that claim.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 8:01 AM, Zhao Xin via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Thank you to  Игорь Никитин and Adrian Zubarev. Now I can convince<br>&gt;     myself for this behavior.<br>&gt;<br>&gt;     As Adrian&#39;s example shows, there is no `bar()` implemented in `class<br>&gt;     A`, so there is no `override func bar()` in class B`. My thought<br>&gt;     that  `self.bar()` would do the same as `(self as! B).bar()`, is called<br>&gt;     &quot;dynamic binding&quot;, which is basing on the `override`. Since there is no<br>&gt;     `override`, there is no &quot;dynamic binding&quot;. I thought &quot;dynamic binding&quot;<br>&gt;     was basing on dynamic type of `self`. It was not. I was wrong.<br>&gt;<br>&gt;     The behavior is clear now. In class A&#39;s `self.bar()`, the runtime finds<br>&gt;     that there is no implementation of `bar()` in `class A`, so it calls<br>&gt;     the `bar` in protocol extension. In class A&#39;s `(self as! B).bar()`, as<br>&gt;     `class B` contains the implementation of `bar()`, the runtime calls it.<br>&gt;<br>&gt;     Zhaoxin<br>&gt;<br>&gt;     On Tue, Sep 20, 2016 at 4:21 PM, Adrian Zubarev via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;         I can’t tell you the reason, but to me it feels like it’s doing the<br>&gt;         following thing:<br>&gt;<br>&gt;         |+ - - (Type: B) - - + | | | func bar() + - + (Type: A) - - + &lt; - -<br>&gt;         - - - - - - - - - - - - - - - - - - + | | | | + - - - - - - - +<br>&gt;         func output() + - + (Protocol: Foo) - - + — - self.bar() - + -<br>&gt;         (self as! B).bar() - + | | | | + - - - - - - - + (default) func<br>&gt;         bar() | &lt;- - - - - - - - + | | + - - - - - - - - - - - - + |<br>&gt;<br>&gt;         |class A:Foo { func bar() {} func output() { print(type(of:self))<br>&gt;         self.bar() (self as! B).bar() } } class B:A { override func bar() {<br>&gt;         print(&quot;I am B.&quot;) } } |<br>&gt;<br>&gt;         Would solve this temporarily.<br>&gt;<br>&gt;         And there we are again with the same discussion if custom<br>&gt;         implementation of protocol members, which have default<br>&gt;         implementation, should have the |override| keyword or not.<br>&gt;<br>&gt;         Imagine your code like this (not valid code):<br>&gt;<br>&gt;         |protocol Foo { func bar() } extension Foo { func bar() { print(&quot;I<br>&gt;         am bar.&quot;) } } class A : Foo { func output() { print(type(of:self))<br>&gt;         default.bar() // fallback an call directly the default<br>&gt;         implementation whenever needed self.bar() // will print &quot;I am bar.&quot;<br>&gt;         on A().output() but should print &quot;I am B.&quot; if Self == B (self as!<br>&gt;         B).bar() } } class B : A { override func bar() { print(&quot;I am B.&quot;) } } |<br>&gt;<br>&gt;         I still think default implementations should be called through<br>&gt;         something like |default.| + whenever you override a default<br>&gt;         implementation you’d need |override|. There is a discussion going<br>&gt;         on: |Mark protocol methods with their protocol|. I clearly did not<br>&gt;         solved your issue, but I might have wake your interest to<br>&gt;         participate. ;)<br>&gt;<br>&gt;<br>&gt;<br>&gt;         --<br>&gt;         Adrian Zubarev<br>&gt;         Sent with Airmail<br>&gt;<br>&gt;         Am 20. September 2016 um 04:13:22, Zhao Xin via swift-users<br>&gt;         (swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;) schrieb:<br>&gt;<br>&gt;&gt;         See below code.<br>&gt;&gt;<br>&gt;&gt;         protocol Foo {<br>&gt;&gt;<br>&gt;&gt;             func bar()<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         extension Foo {<br>&gt;&gt;<br>&gt;&gt;             func bar() {<br>&gt;&gt;<br>&gt;&gt;                 print(&quot;I am bar.&quot;)<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         class A:Foo {<br>&gt;&gt;<br>&gt;&gt;             func output() {<br>&gt;&gt;<br>&gt;&gt;                 print(type(of:self)) // prints &quot;B&quot;.<br>&gt;&gt;<br>&gt;&gt;                 self.bar() // prints &quot;I am bar.&quot;<br>&gt;&gt;<br>&gt;&gt;                 (self as! B).bar() // prints &quot;I am B.&quot;<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         class B:A {<br>&gt;&gt;<br>&gt;&gt;             func bar() {<br>&gt;&gt;<br>&gt;&gt;                 print(&quot;I am B.&quot;)<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         let b = B()<br>&gt;&gt;<br>&gt;&gt;         b.output()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         I thought `self.bar()` would do the same as `(self as! B).bar()`.<br>&gt;&gt;         It didn&#39;t. In my opinion,  `type(of:self) is B.type`, so they<br>&gt;&gt;         should be the same, shouldn&#39;t they?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         Zhaoxin<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-users mailing list<br>&gt;&gt;         swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
