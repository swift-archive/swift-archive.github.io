<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>This is a re-post of a proposal I previously submitted to Radar. This seems like a more appropriate place for it, though, and since Apple seems to be planning a heuristic mechanism to rewrite Objective-C APIs to make them more idiomatic to Swift (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;), I thought I’d bounce this by the list.<br></p><p>Motivation:<br>Swift&#39;s system of getting rid of NSError ** parameters and turning them into something easier to deal with is great. However, NSError is not the only possible type of reference parameter that can appear in C and Objective-C APIs. Some extremely common APIs in the frameworks require passing C-style pointers, including the popular -[NSURL getResourceValue:forKey:error:]. These reference pointers are currently exposed as ugly UnsafeMutablePointer or AutoreleasingUnsafeMutablePointer constructs that seem quite out of place in a Swift public API.<br></p><p>Proposed Solution:<br></p><p>If an Objective-C method takes a reference parameter, and that parameter is marked &quot;out&quot; in the declaration, this guarantees that the parameter is purely for returning a value, and that its initial value will be ignored. Thus, we can eliminate the parameter entirely and move it to the method&#39;s return value. If the Objective-C method already has a return value, we can accommodate both return values by having the method return a tuple. So, something like this (assuming nonnull):<br> <br>- (NSString *)foo:(out NSString **)bar;  <br> <br>becomes something like this:<br> <br>func foo() -&gt; (String, String)  <br> <br>The Obj-C return value, if there is one, would always be the first element in the tuple, accessible via .0. For methods using the common Obj-C naming conventions for methods that return values by reference, the other elements in the tuple could be named. In this case, &quot;get&lt;name&gt;&quot; would remain the name of the method, but additional by-reference parameters and their names could be removed from the method name completely and moved to the return tuple. In both cases the argument label could be used to determine the name, like so:<br> <br>- (void)getFoo:(out NSString **)foo bar:(out NSString **)bar;  <br>- (NSString *)fooWithBar:(NSString *)bar baz:(out NSString **)baz;  <br>- (NSString *)fooAndReturnBar:(out NSString **)bar;  <br> <br>become:<br> <br>func getFoo() -&gt; (foo: String, bar: String)  <br>func fooWithBar(bar: String) -&gt; (String, baz: String)  <br>func foo() -&gt; (String, bar: String)  <br> <br>Methods that have void returns (or which have Boolean returns and an error parameter, which Swift will turn into a void return) don&#39;t even need a tuple:<br> <br>- (void)foo:(out NSString **)bar;  <br> <br>becomes<br> <br>func foo() -&gt; String  <br> <br>Furthermore, something like -[NSURL getResourceValue:forKey:error:] becomes this:<br> <br>func getResourceValueForKey() throws -&gt; AnyObject?  <br> <br>so that instead of this rather Byzantine-looking construction:<br> <br>var sizeObj: AnyObject? = nil  <br>  <br>try url.getResourceValue(&amp;sizeObj, forKey: NSURLFileSizeKey)  <br>  <br>if size = sizeObj as? NSNumber {  <br>   // do something with size  <br>}  <br> <br>you could just do this:<br> <br>if let size = try url.getResourceValueForKey(NSURLFileSizeKey) as? NSNumber {  <br>    // do something with size  <br>}  <br> <br>So much cleaner, and generally more &quot;swifty&quot;!<br> <br>The beauty of it all is that we don&#39;t even have to invent a new keyword for this, since Obj-C already has an &quot;out&quot; keyword (which was originally there for use with Distributed Objects, but I see no reason we couldn&#39;t repurpose it here). Many APIs, such as -[NSURL getResourceValue:forKey:error:] mentioned above, already use it. We could even wrap the call in an autoreleasepool to get rid of the autorelease on the returned-by-reference values, if the performance trade-off is deemed to be worth it.<br> <br>One possible objection could be raised regarding methods that can take NULL as the reference parameter, and skip doing the work to generate that value in this case; one could argue that the proposed change could make such methods inefficient in cases where you don&#39;t want one of the values. However, assuming the parameter is nullable, we could account for this as well by assigning one of the return values to _, like this:<br> <br>let (foo, bar: _) = someMethod()  <br> <br>or:<br> <br>let (foo, _) = someMethod()  <br> <br>and, seeing that a particular return value is not needed, Swift could pass NULL for the undesired reference parameter. (If the pointer were non-nullable, Swift would send it an actual pointer and simply ignore the result).<br> <br>Impact on Existing Code:<br></p><p>The impact is similar to the existing, accepted Objective-C translation proposal. It will break lots of existing use of Objective-C code, but since that is happening soon anyway, this seems like an appropriate time to consider other things such as this.<br></p><p>Further Discussion:<br></p><p>The proposal above discussed mainly Objective-C code; however, the logical next step may be to extend it to C as well. This would dramatically simplify the CoreFoundation interface as well, since that API relies extremely heavily on reference parameters to return things, with the actual return type often simply being a Boolean or an OSStatus. This would probably be more complicated, however, since you wouldn’t necessarily have the advantage of the naming conventions that exist in Objective-C for this type of API.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/396641c8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>Imho it sounds good, but I rarely encounter situations where I would benefit from the proposed change… and afair &quot;out&quot; is an Objective-C addition, so there would be no improvement for plain C.<br>So I would surely find use for the automatic conversion, but if I would have to write it on my own, I&#39;d rather take the lazy solution and stick with the status quo and write wrappers.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e18859caca1afb014ad58590415b638a?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>D. Felipe Torres</string> &lt;warorface at gmail.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>+ 1 on the automatic translation. Let&#39;s get Swifty.<br></p><p>On Wed, Dec 23, 2015 at 12:11 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Imho it sounds good, but I rarely encounter situations where I would<br>&gt; benefit from the proposed change… and afair &quot;out&quot; is an Objective-C<br>&gt; addition, so there would be no improvement for plain C.<br>&gt; So I would surely find use for the automatic conversion, but if I would<br>&gt; have to write it on my own, I&#39;d rather take the lazy solution and stick<br>&gt; with the status quo and write wrappers.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>++++++++++++++++++++++++++<br>Diego Torres.<br>Phone (Mobile Germany): +49 157 30070985<br>Phone (Landline Chile): +56 2 29790978<br>Web: dtorres.me<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/285bc2a6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 5:11 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Imho it sounds good, but I rarely encounter situations where I would benefit from the proposed change…<br></p><p>It does happen in the Objective-C frameworks; the NSURL example I provided is an aggravatingly common one, but there are plenty others (particularly anything that begins with “get”). In C, of course, it’s all over the place.<br></p><p>It would be handy for third-party code, as well. I’m currently converting a class hierarchy from Obj-C to Swift that returns multiple values, but since this code still has to be interoperable with Obj-C (for now), I can’t move it to returning a tuple yet, and all these UnsafeMutablePointers are driving me *crazy*.<br></p><p>&gt; and afair &quot;out&quot; is an Objective-C addition, so there would be no improvement for plain C.<br></p><p>While that’s true, Apple could use the same sort of solution that they have done in many other places; just use #ifdef checks to #define some constant like NS_OUT to ‘out’ for Objective-C, and to an empty string otherwise.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/4babc4ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>How would this work on the stack? I imagine returning a value in a tuple would make it a completely different location on the stack than where the original parameter would be where the ObjC side would be expecting it. This would break the calling convention.<br></p><p>-Kenny<br></p><p><br>&gt; On Dec 23, 2015, at 12:12 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 5:11 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Imho it sounds good, but I rarely encounter situations where I would benefit from the proposed change…<br>&gt; <br>&gt; It does happen in the Objective-C frameworks; the NSURL example I provided is an aggravatingly common one, but there are plenty others (particularly anything that begins with “get”). In C, of course, it’s all over the place.<br>&gt; <br>&gt; It would be handy for third-party code, as well. I’m currently converting a class hierarchy from Obj-C to Swift that returns multiple values, but since this code still has to be interoperable with Obj-C (for now), I can’t move it to returning a tuple yet, and all these UnsafeMutablePointers are driving me *crazy*.<br>&gt; <br>&gt;&gt; and afair &quot;out&quot; is an Objective-C addition, so there would be no improvement for plain C.<br>&gt; <br>&gt; While that’s true, Apple could use the same sort of solution that they have done in many other places; just use #ifdef checks to #define some constant like NS_OUT to ‘out’ for Objective-C, and to an empty string otherwise.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 7:52 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How would this work on the stack? I imagine returning a value in a tuple would make it a completely different location on the stack than where the original parameter would be where the ObjC side would be expecting it. This would break the calling convention.<br>&gt; <br>&gt; -Kenny<br></p><p>My thinking is that the Swift compiler would create a temporary variable, then pass a pointer to that to the Objective-C method. After the method is complete, the temporary variable would be copied into the tuple, and converted as needed.<br></p><p>You pretty much have to do it this way, because of the disparities between the types on the Swift side and the Objective-C side: Bool vs. BOOL, String, vs. NSString, etc. To ensure a good user experience, these things all need to be translated to their Swift counterparts before returning them.<br></p><p>Charles<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I’m currently converting a class hierarchy from Obj-C to Swift that returns multiple values, but since this code still has to be interoperable with Obj-C (for now), I can’t move it to returning a tuple yet, and all these UnsafeMutablePointers are driving me *crazy*.<br></p><p>As an implementation strategy, you might want to consider writing the Swift interface you want to support, and then declaring Objective-C-compatible cover methods matching the old interface. You can even get the Obj-C ones out of the way in autocomplete by giving them a common prefix:<br></p><p>	@nonobjc func getFooAndBar() -&gt; (Int, Int) {<br>		// Insert logic here<br>	}<br></p><p>	@objc(getFoo:andBar:) func _objc_getFoo(foo: UnsafeMutablePointer&lt;Int&gt;, andBar bar: UnsafeMutablePointer&lt;Int&gt;) {<br>		(foo.memory, bar.memory) = getFooAndBar()<br>	}<br></p><p>Once your code is all ported and using the Swifty interface, you can remove these cover methods. Or if they need to stay around, you could move them into extensions so they&#39;ll stay out of your way.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>We have put in a few experimental APIs into the swift-corelibs-foundation that try to remove some of these ugly spots.<br></p><p>I really thing that almost all cases of AutoreleasingUnsafeMutablePointer are either problematic or potentially incorrect (not to mention potentially unsafe). Most of these cases are really just a case of wanting an out parameter to the method or a fast array of elements. The use case of the fast array of elements is of dubious usage in swift (unless you are implementing Foundation itself), and there seem to be better accessors anyhow e.g. NSArray.getObjects(_:range:) perhaps should be subarrayWithRange or slice as a better usage case. Some of the NSCalendar APIs that had AUMPs have been replaced with experiments that are not only potentially vastly better Swift APIs but also potentially better ObjC APIs (win/win in my book).<br></p><p>The remainder seem to be cases of an out parameter. Granted ObjC does have the annotation of out (which is from distributed objects iirc) but if we had some sort of demarkation of this intent the APIs could be exposed as inout without mucking with potentially pitfall cases of misinterpreting the meaning of the API names.<br></p><p>If there are other APIs that are potentially pitfalls of this I would definitely be interested to see how they could be improved.<br></p><p>&gt; On Dec 22, 2015, at 11:50 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a re-post of a proposal I previously submitted to Radar. This seems like a more appropriate place for it, though, and since Apple seems to be planning a heuristic mechanism to rewrite Objective-C APIs to make them more idiomatic to Swift (https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md&gt;), I thought I’d bounce this by the list.<br>&gt; <br>&gt; Motivation:<br>&gt; Swift&#39;s system of getting rid of NSError ** parameters and turning them into something easier to deal with is great. However, NSError is not the only possible type of reference parameter that can appear in C and Objective-C APIs. Some extremely common APIs in the frameworks require passing C-style pointers, including the popular -[NSURL getResourceValue:forKey:error:]. These reference pointers are currently exposed as ugly UnsafeMutablePointer or AutoreleasingUnsafeMutablePointer constructs that seem quite out of place in a Swift public API.<br>&gt; <br>&gt; Proposed Solution:<br>&gt; <br>&gt; If an Objective-C method takes a reference parameter, and that parameter is marked &quot;out&quot; in the declaration, this guarantees that the parameter is purely for returning a value, and that its initial value will be ignored. Thus, we can eliminate the parameter entirely and move it to the method&#39;s return value. If the Objective-C method already has a return value, we can accommodate both return values by having the method return a tuple. So, something like this (assuming nonnull):<br>&gt;  <br>&gt; - (NSString *)foo:(out NSString **)bar;  <br></p><p>Cases like this are kinda cagey because you have to keep track of which string is which; is it the foo result string or the bar result string at .0 versus .1? I find myself always favoring struct or inout for clarity/safety.<br></p><p>&gt;  <br>&gt; becomes something like this:<br>&gt;  <br>&gt; func foo() -&gt; (String, String)  <br>&gt;  <br>&gt; The Obj-C return value, if there is one, would always be the first element in the tuple, accessible via .0. For methods using the common Obj-C naming conventions for methods that return values by reference, the other elements in the tuple could be named. In this case, &quot;get&lt;name&gt;&quot; would remain the name of the method, but additional by-reference parameters and their names could be removed from the method name completely and moved to the return tuple. In both cases the argument label could be used to determine the name, like so:<br>&gt;  <br>&gt; - (void)getFoo:(out NSString **)foo bar:(out NSString **)bar;  <br>&gt; - (NSString *)fooWithBar:(NSString *)bar baz:(out NSString **)baz;  <br>&gt; - (NSString *)fooAndReturnBar:(out NSString **)bar;  <br>&gt;  <br>&gt; become:<br>&gt;  <br>&gt; func getFoo() -&gt; (foo: String, bar: String)  <br>&gt; func fooWithBar(bar: String) -&gt; (String, baz: String)  <br>&gt; func foo() -&gt; (String, bar: String)  <br>&gt;  <br>&gt; Methods that have void returns (or which have Boolean returns and an error parameter, which Swift will turn into a void return) don&#39;t even need a tuple:<br>&gt;  <br>&gt; - (void)foo:(out NSString **)bar;  <br>&gt;  <br>&gt; becomes<br>&gt;  <br>&gt; func foo() -&gt; String  <br>&gt;  <br>&gt; Furthermore, something like -[NSURL getResourceValue:forKey:error:] becomes this:<br>&gt;  <br>&gt; func getResourceValueForKey() throws -&gt; AnyObject?  <br>&gt;  <br>&gt; so that instead of this rather Byzantine-looking construction:<br>&gt;  <br>&gt; var sizeObj: AnyObject? = nil  <br>&gt;   <br>&gt; try url.getResourceValue(&amp;sizeObj, forKey: NSURLFileSizeKey)  <br>&gt;   <br>&gt; if size = sizeObj as? NSNumber {  <br>&gt;    // do something with size  <br>&gt; }  <br>&gt;  <br>&gt; you could just do this:<br>&gt;  <br>&gt; if let size = try url.getResourceValueForKey(NSURLFileSizeKey) as? NSNumber {  <br>&gt;     // do something with size  <br>&gt; }  <br>&gt;  <br>&gt; So much cleaner, and generally more &quot;swifty&quot;!<br>&gt;  <br>&gt; The beauty of it all is that we don&#39;t even have to invent a new keyword for this, since Obj-C already has an &quot;out&quot; keyword (which was originally there for use with Distributed Objects, but I see no reason we couldn&#39;t repurpose it here). Many APIs, such as -[NSURL getResourceValue:forKey:error:] mentioned above, already use it. We could even wrap the call in an autoreleasepool to get rid of the autorelease on the returned-by-reference values, if the performance trade-off is deemed to be worth it.<br>&gt;  <br>&gt; One possible objection could be raised regarding methods that can take NULL as the reference parameter, and skip doing the work to generate that value in this case; one could argue that the proposed change could make such methods inefficient in cases where you don&#39;t want one of the values. However, assuming the parameter is nullable, we could account for this as well by assigning one of the return values to _, like this:<br>&gt;  <br>&gt; let (foo, bar: _) = someMethod()  <br>&gt;  <br>&gt; or:<br>&gt;  <br>&gt; let (foo, _) = someMethod()  <br>&gt;  <br>&gt; and, seeing that a particular return value is not needed, Swift could pass NULL for the undesired reference parameter. (If the pointer were non-nullable, Swift would send it an actual pointer and simply ignore the result).<br>&gt;  <br>&gt; Impact on Existing Code:<br>&gt; <br>&gt; The impact is similar to the existing, accepted Objective-C translation proposal. It will break lots of existing use of Objective-C code, but since that is happening soon anyway, this seems like an appropriate time to consider other things such as this.<br>&gt; <br>&gt; Further Discussion:<br>&gt; <br>&gt; The proposal above discussed mainly Objective-C code; however, the logical next step may be to extend it to C as well. This would dramatically simplify the CoreFoundation interface as well, since that API relies extremely heavily on reference parameters to return things, with the actual return type often simply being a Boolean or an OSStatus. This would probably be more complicated, however, since you wouldn’t necessarily have the advantage of the naming conventions that exist in Objective-C for this type of API.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/058da5af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pre-proposal: Convert reference params to tuples</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 8:05 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Cases like this are kinda cagey because you have to keep track of which string is which; is it the foo result string or the bar result string at .0 versus .1? I find myself always favoring struct or inout for clarity/safety.<br></p><p>In the case where the original API distinguishes between the two (-fooAndReturnBar:), you can return a named (or partially-named) tuple, like in one my later examples. In this case, the original API doesn’t have this information either, so we can’t translate it into something better (although I don’t believe this pattern is very common, so that helps).<br></p><p>In the more common case where you have something like fooWithBar: you can add a “bar:” label on the second parameter.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/a14959ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
