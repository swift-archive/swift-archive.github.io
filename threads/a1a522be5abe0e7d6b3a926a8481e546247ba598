<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Since we&#39;re talking a lot enums these days, I&#39;d like to bring into<br>discussion a proposal that has been briefly mentioned in another<br>thread to enable working with enums using their names.<br></p><p>This is currently possible in the language but it&#39;s a bit burdensome.<br>You can just interpolate the value of the enum into a string to get<br>its name/representation as a string but you have to write case by case<br>the init methods for each enum to convert the string back to its<br>value. For example:<br></p><p>|   enum Planet : Int {<br>|      case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune<br>|<br>|      init?(caseName name : String) {<br>|          switch name {<br>|              case &quot;Mercury&quot;:<br>|                  self = .Mercury<br>|              case &quot;Venus&quot;:<br>|                  self = .Venus<br>|              case &quot;Earth&quot;:<br>|                  self = .Earth<br>|              case &quot;Mars&quot;:<br>|                  self = .Mars<br>|              case &quot;Jupiter&quot;:<br>|                  self = .Jupiter<br>|              case &quot;Saturn&quot;:<br>|                  self = .Saturn<br>|              case &quot;Uranus&quot;:<br>|                  self = .Uranus<br>|              case &quot;Neptune&quot;:<br>|                  self = .Neptune<br>|              default:<br>|                  return nil<br>|          }<br>|      }<br>|   }<br>|<br>|   let planet = Planet(caseName: &quot;Earth&quot;)!<br>|   print(&quot;\(planet) = \(planet.rawValue)&quot;) // Earth = 3<br></p><p>My proposal here is to let the compiler create these initialisers<br>automatically, just like with rawValue.<br></p><p>The reasoning here is simple: Enums in their basics are values, like<br>Int values or Double values, but limited to a closed set and<br>referenced in code by a name. Although they *may* have raw value<br>equivalents not all do (they don&#39;t need to). Using the name of the<br>enum value instead of any value associated with it also benefits<br>persistence since these associated values can change overtime while<br>the name is less likely to change.<br></p><p>As an example of the importance of this proposal, I mention the<br>company I work for who chooses to store (DB) the names of enum values<br>where they are used in persisted data arguing it&#39;s easier to debug and<br>support, and several web services we work with send enumerated values<br>as the strings of their names which we have to convert back to the<br>enum value when we receive. This proposal would simplify writing such<br>parts of the apps.<br></p><p>In case you&#39;re thinking, enums with associated values can also have<br>their instances created this way because there seems to be a default<br>representation for them in string interpolation. It&#39;s possible to be<br>done manually but would require a lot more of code and effort to be<br>converted back:<br></p><p>|   enum Platform {<br>|      case OSX(version: String)<br>|      case iOS(version : Int)<br>|   }<br>|<br>|   let plat = Platform.iOS(version: 9)<br>|   print(&quot;\(plat)&quot;) // iOS(9)<br>|<br>|   let plat2 = Platform.OSX(version: &quot;10.10.4&quot;)<br>|   print(&quot;\(plat2)&quot;)  // OSX(&quot;10.10.4&quot;)<br></p><p>Furthermore, I&#39;m aware the output of the string interpolation may be<br>altered by adopting certain protocols so it should also be interesting<br>for this proposal to add a property like .caseName to all enums to<br>ensure the correct string representation that would be converted back<br>to the enum value.<br></p><p>I&#39;d like to hear your opinions before writing a proposal.<br>Thanks.<br></p><p>L<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; |   enum Planet : Int {<br>&gt; |      case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune<br>&gt; |<br>&gt; |      init?(caseName name : String) {<br></p><p>The compiler actually does this already through RawRepresentable if you put `String` as your raw type. So what&#39;s the use case for this? Code which needs both a non-String rawValue *and* needs to look up cases by name? How common do you think that is?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Working with enums by name</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 4:48 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; |   enum Planet : Int {<br>&gt;&gt; |      case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune<br>&gt;&gt; |<br>&gt;&gt; |      init?(caseName name : String) {<br>&gt; <br>&gt; The compiler actually does this already through RawRepresentable if you put `String` as your raw type. So what&#39;s the use case for this? Code which needs both a non-String rawValue *and* needs to look up cases by name? How common do you think that is?<br></p><p>How about a LogCategory enum:<br></p><p>• whose name is printed with each log entry (and thus wants a String raw type),<br>• which can be configured from command line or config file (and thus wants string-based lookup), but<br>• also wants OptionSetType-like behavior (and thus an Int raw type).<br></p><p>P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; • also wants OptionSetType-like behavior (and thus an Int raw type).<br></p><p>Then it&#39;s not an `enum`, it&#39;s a `struct`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Working with enums by name</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 4:07 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; • also wants OptionSetType-like behavior (and thus an Int raw type).<br>&gt; <br>&gt; Then it&#39;s not an `enum`, it&#39;s a `struct`.<br></p><p>You can get it for free as an array of enums and test with contains vs member<br></p><p>-- E, who has probably digressed more than she really should<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Working with enums by name</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>If we had generic protocols, you could implement RawRepresentable twice,<br>once using Ints and one using Strings. But that&#39;s probably never going to<br>happen.<br></p><p>/digression<br></p><p>Austin<br></p><p>On Tue, May 31, 2016 at 3:11 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 31, 2016, at 4:07 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; • also wants OptionSetType-like behavior (and thus an Int raw type).<br>&gt; &gt;<br>&gt; &gt; Then it&#39;s not an `enum`, it&#39;s a `struct`.<br>&gt;<br>&gt; You can get it for free as an array of enums and test with contains vs<br>&gt; member<br>&gt;<br>&gt; -- E, who has probably digressed more than she really should<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/feb93e42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 10:00:00pm</p></header><div class="content"><p>If I got the idea right, you would need to implement yourself the protocol methods to answer for both init(rawValue: Int) and init(rawValue: String) - which is how you have to do today only with the string part - while my proposed approach you&#39;d have to implement nothing yourself.<br></p><p>L<br></p><p>&gt; On 31 May 2016, at 7:19 pm, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If we had generic protocols, you could implement RawRepresentable twice, once using Ints and one using Strings. But that&#39;s probably never going to happen.<br>&gt; <br>&gt; /digression<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 3:11 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On May 31, 2016, at 4:07 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; • also wants OptionSetType-like behavior (and thus an Int raw type).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Then it&#39;s not an `enum`, it&#39;s a `struct`.<br>&gt;&gt; <br>&gt;&gt; You can get it for free as an array of enums and test with contains vs member<br>&gt;&gt; <br>&gt;&gt; -- E, who has probably digressed more than she really should<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/9e385be8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 31, 2016 at 10:00:00pm</p></header><div class="content"><p>Don&#39;t you think it&#39;s a bit of a waste to be repeating the name of the value as a string just to use init(rawValue:) with them? What if I need to store another string associated with the value of the enum e.g. I want to create an enum to represent options in a menu and the associated value is to be the name of the image file to be used for that option? I don&#39;t know how common that is, but I don&#39;t see how good it is for you to keep repeating yourself in your code when the value you want and need is right by your side (DRY principle) and can be used easily in one way (to string) but not the other (back to enum).<br></p><p>L<br></p><p>On 31 May 2016, at 6:48 pm, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; |   enum Planet : Int {<br>&gt;&gt; |      case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune<br>&gt;&gt; |<br>&gt;&gt; |      init?(caseName name : String) {<br>&gt; <br>&gt; The compiler actually does this already through RawRepresentable if you put `String` as your raw type. So what&#39;s the use case for this? Code which needs both a non-String rawValue *and* needs to look up cases by name? How common do you think that is?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Don&#39;t you think it&#39;s a bit of a waste to be repeating the name of the value as a string just to use init(rawValue:) with them?<br></p><p>Who said anything about repeating the name?<br></p><p>Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>  1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>  2&gt; Planet.mercury.rawValue<br>$R0: String = &quot;mercury&quot;<br></p><p>&gt; What if I need to store another string associated with the value of the enum e.g. I want to create an enum to represent options in a menu and the associated value is to be the name of the image file to be used for that option?<br></p><p>Use the instance as a key into a dictionary of images. (Or use the rawValue as a key into a plist dictionary of image names. Or just name the image after the rawValue.)<br></p><p>In any case, this sounds like we&#39;re back to your other thread, the one about attaching properties to cases. That&#39;s a great feature, but it&#39;s a different feature from this one.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Working with enums by name</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  1, 2016 at 05:00:00pm</p></header><div class="content"><p>I had no idea you could do this!!<br></p><p>&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Who said anything about repeating the name?<br>&gt; <br>&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;  1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;  2&gt; Planet.mercury.rawValue<br>&gt; $R0: String = &quot;mercury&quot;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 07:00:00am</p></header><div class="content"><p>Yes, you can do all this but you still have to do everything yourself by hand. Dictionary, plist, it even init as my initial example but you are the one responsible to control when e.g. you add a new value or rename another.<br></p><p>My proposal causes no big changes and no big overload on the compiler; it just adds an init method to find the equivalent enum value for a string. And yes this feature becomes a lot more interesting should the idea of using tuple typed enums goes forward but they are completely independent.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Patrick Smith&quot; &lt;pgwsmith at gmail.com&gt;<br>Sent: ‎01/‎06/‎2016 04:52 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;; &quot;Swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>I had no idea you could do this!!<br></p><p>&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Who said anything about repeating the name?<br>&gt; <br>&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;  1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;  2&gt; Planet.mercury.rawValue<br>&gt; $R0: String = &quot;mercury&quot;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/59a71108/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Working with enums by name</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br></p><p>For example, this:<br></p><p>enum Planet {<br>	case Earth<br>	case Mars<br>}<br></p><p>&quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br></p><p><br>Works as well. You don&#39;t need to have the represented value to be String.<br></p><p>Note that this:<br></p><p>- works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>- does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br></p><p>&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I had no idea you could do this!!<br>&gt; <br>&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt; <br>&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 03:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/7e154743/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Working with enums by name</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Sorry, must&#39;ve missed that.<br></p><p>&gt; On Jun 1, 2016, at 12:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt; <br>&gt; It&#39;s documented in &quot;The Swift Programming Language&quot;, in the same paragraphs where the `enum Planet` example we&#39;ve been working with comes from.<br>&gt; <br>&gt; “When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift will automatically assign the values for you.<br>&gt; &lt;snip&gt;<br>&gt; “When strings are used for raw values, the implicit value for each case is the text of that case’s name.”<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 07:00:00am</p></header><div class="content"><p>In this case of not using raw values in an enum, can you use init(rawValue:) as in my proposal?<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Charlie Monroe via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎01/‎06/‎2016 07:19 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;Swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>Sorry, must&#39;ve missed that.<br></p><p>&gt; On Jun 1, 2016, at 12:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt; <br>&gt; It&#39;s documented in &quot;The Swift Programming Language&quot;, in the same paragraphs where the `enum Planet` example we&#39;ve been working with comes from.<br>&gt; <br>&gt; “When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift will automatically assign the values for you.<br>&gt; &lt;snip&gt;<br>&gt; “When strings are used for raw values, the implicit value for each case is the text of that case’s name.”<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/37965785/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 07:00:00am</p></header><div class="content"><p>Just a fix. I&#39;ve just tried the following code and the compiler complained there is no .rawValue on the type.<br></p><p>|   enum Size { case Fit, Fill }<br>|   print(Size.Fit.rawValue)<br></p><p>Then, as I said before, you can only get the value name as a string from interpolation and need to do everything by hand the other way around.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Charlie Monroe via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎01/‎06/‎2016 07:19 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;Swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>Sorry, must&#39;ve missed that.<br></p><p>&gt; On Jun 1, 2016, at 12:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt; <br>&gt; It&#39;s documented in &quot;The Swift Programming Language&quot;, in the same paragraphs where the `enum Planet` example we&#39;ve been working with comes from.<br>&gt; <br>&gt; “When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift will automatically assign the values for you.<br>&gt; &lt;snip&gt;<br>&gt; “When strings are used for raw values, the implicit value for each case is the text of that case’s name.”<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/88b85894/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Working with enums by name</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Try this:<br></p><p>enum Size: String { case Fit, Fill }<br>print(Size.Fit.rawValue)<br></p><p>On 01.06.2016 13:42, Leonardo Pessoa via swift-evolution wrote:<br>&gt; Just a fix. I&#39;ve just tried the following code and the compiler complained<br>&gt; there is no .rawValue on the type.<br>&gt;<br>&gt; |   enum Size { case Fit, Fill }<br>&gt; |   print(Size.Fit.rawValue)<br>&gt;<br>&gt; Then, as I said before, you can only get the value name as a string from<br>&gt; interpolation and need to do everything by hand the other way around.<br>&gt;<br>&gt; L<br>&gt; ---------------------------------------------------------------------------<br>&gt; From: Charlie Monroe via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎01/‎06/‎2016 07:19 AM<br>&gt; To: Brent Royal-Gordon &lt;mailto:brent at architechies.com&gt;<br>&gt; Cc: Swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Working with enums by name<br>&gt;<br>&gt; Sorry, must&#39;ve missed that.<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 12:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler<br>&gt; behavior that isn&#39;t well documented.<br>&gt;&gt;<br>&gt;&gt; It&#39;s documented in &quot;The Swift Programming Language&quot;, in the same<br>&gt; paragraphs where the `enum Planet` example we&#39;ve been working with comes from.<br>&gt;&gt;<br>&gt;&gt; “When you’re working with enumerations that store integer or string raw<br>&gt; values, you don’t have to explicitly assign a raw value for each case. When<br>&gt; you don’t, Swift will automatically assign the values for you.<br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; “When strings are used for raw values, the implicit value for each case<br>&gt; is the text of that case’s name.”<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>This should work but feels like an ugly hack to me. What if I needed<br>the enum like this?<br></p><p>|   enum Size : Double {<br>|       case Fit = 0.5<br>|       case Fill = 3.0<br>|   }<br></p><p>Then I can no longer rely on the compiler to fill string raw values<br>for me to use.<br></p><p>L<br></p><p>On 1 June 2016 at 07:59, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; Try this:<br>&gt;<br>&gt; enum Size: String { case Fit, Fill }<br>&gt; print(Size.Fit.rawValue)<br>&gt;<br>&gt; On 01.06.2016 13:42, Leonardo Pessoa via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; Just a fix. I&#39;ve just tried the following code and the compiler complained<br>&gt;&gt; there is no .rawValue on the type.<br>&gt;&gt;<br>&gt;&gt; |   enum Size { case Fit, Fill }<br>&gt;&gt; |   print(Size.Fit.rawValue)<br>&gt;&gt;<br>&gt;&gt; Then, as I said before, you can only get the value name as a string from<br>&gt;&gt; interpolation and need to do everything by hand the other way around.<br>&gt;&gt;<br>&gt;&gt; L<br>&gt;&gt;<br>&gt;&gt; ---------------------------------------------------------------------------<br>&gt;&gt; From: Charlie Monroe via swift-evolution<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎01/‎06/‎2016 07:19 AM<br>&gt;&gt; To: Brent Royal-Gordon &lt;mailto:brent at architechies.com&gt;<br>&gt;&gt; Cc: Swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] Working with enums by name<br>&gt;&gt;<br>&gt;&gt; Sorry, must&#39;ve missed that.<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 1, 2016, at 12:17 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler<br>&gt;&gt;<br>&gt;&gt; behavior that isn&#39;t well documented.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It&#39;s documented in &quot;The Swift Programming Language&quot;, in the same<br>&gt;&gt;<br>&gt;&gt; paragraphs where the `enum Planet` example we&#39;ve been working with comes<br>&gt;&gt; from.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; “When you’re working with enumerations that store integer or string raw<br>&gt;&gt;<br>&gt;&gt; values, you don’t have to explicitly assign a raw value for each case.<br>&gt;&gt; When<br>&gt;&gt; you don’t, Swift will automatically assign the values for you.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt; “When strings are used for raw values, the implicit value for each case<br>&gt;&gt;<br>&gt;&gt; is the text of that case’s name.”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; This should work but feels like an ugly hack to me. What if I needed<br>&gt; the enum like this?<br>&gt; <br>&gt; |   enum Size : Double {<br>&gt; |       case Fit = 0.5<br>&gt; |       case Fill = 3.0<br>&gt; |   }<br></p><p>What if you needed both Int and Double rawValues? What if you needed rawValues that were cryptographically signed? We have to decide which use cases are common enough to support directly in the language, and I&#39;m not convinced that &quot;I need to look cases up by name, but I have no choice but to use rawValue for something else&quot; is one of them—that is, that it&#39;s *so* common that we need to direct our scarce engineering resources towards designing and implementing a separate feature merely to accommodate it. There are a whole lot of things that are *way* higher on our to-do list than this, arguably including metaprogramming features which would let you write this yourself instead of sticking it in the core language.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Working with enums by name</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  2, 2016 at 12:00:00am</p></header><div class="content"><p>Can&#39;t agree with Brent&#39;s opinion. For me the proposed init(caseName:String) <br>and .caseName property for enum case - seems like  base feature that enum <br>type must to have.<br></p><p>As for string as raw value for enum, please find this example:<br></p><p>enum E: String {<br>     case one = &quot;One&quot;<br>     case two = &quot;Two&quot;<br>}<br></p><p>print(E.one.rawValue)  // One<br>print(E(rawValue: &quot;one&quot;)) // nil<br>print(E(rawValue: &quot;One&quot;)) // Optional(main.E.one)<br></p><p>How do you suggest to transform the case name(&quot;one&quot;) to enum case variable? <br>`init(rawValue:)` will accept assigned rawValue, not case name. Even worse, <br>conforming to CustomStringConvertable can prevent you from have &quot;one&quot; as <br>result String(E.one).<br></p><p>On 02.06.2016 0:10, Brent Royal-Gordon wrote:<br>&gt;&gt; This should work but feels like an ugly hack to me. What if I needed<br>&gt;&gt; the enum like this?<br>&gt;&gt;<br>&gt;&gt; |   enum Size : Double {<br>&gt;&gt; |       case Fit = 0.5<br>&gt;&gt; |       case Fill = 3.0<br>&gt;&gt; |   }<br>&gt;<br>&gt; What if you needed both Int and Double rawValues? What if you needed rawValues that were cryptographically signed? We have to decide which use cases are common enough to support directly in the language, and I&#39;m not convinced that &quot;I need to look cases up by name, but I have no choice but to use rawValue for something else&quot; is one of them—that is, that it&#39;s *so* common that we need to direct our scarce engineering resources towards designing and implementing a separate feature merely to accommodate it. There are a whole lot of things that are *way* higher on our to-do list than this, arguably including metaprogramming features which would let you write this yourself instead of sticking it in the core language.<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>Brent, for needing &quot;both Int and Double values&quot; there is a proposal to add tuples instead of the current raw values or allowing assessor properties per case, you should check those out. Perhaps this could also be used to cryptoghaphically sign a raw value but I&#39;m not sure.<br></p><p>As for working with enum values by name a few examples have already been posted in today but I&#39;ve done a lot more research in the subject along the day and found there is a correlation between enums and nominal level values in statistics; we cannot test them for a particular order (this could also be interesting for statistic apps but it&#39;s another case) and no math with them is valid. So, e.g., the result of the following operation on the planets enum is nonsense:<br></p><p>|   let planet = Planet(rawValue: Planet.Mars.rawValue - Planet.Mercury.rawValue)<br></p><p>The result will be different if the enum values are zero based than if not. Also any change in list order or the base index or add a new element to the middle of the list will break your intended code if you&#39;re storing the raw value in a database. And we know these changes happen. Actually, given this characteristic of nominal types (statistic), we should vow to removing init(rawValue:) completely from the language.<br></p><p>The real value you&#39;re working with in enums is the enum case name not any associated values. By working with the name you&#39;re safe should any associated value change, should their order change, you&#39;ll only break your app if the case is removed/renamed (with the raw value, you risk having the wrong treatment being given should another enum case takes the value of a removed one).<br></p><p>I agree there are lots of important and more difficult things to review in the language but I wouldn&#39;t be wasting my time here if I didn&#39;t think this was equally important.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Sent: ‎01/‎06/‎2016 06:10 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>&gt; This should work but feels like an ugly hack to me. What if I needed<br>&gt; the enum like this?<br>&gt; <br>&gt; |   enum Size : Double {<br>&gt; |       case Fit = 0.5<br>&gt; |       case Fill = 3.0<br>&gt; |   }<br></p><p>What if you needed both Int and Double rawValues? What if you needed rawValues that were cryptographically signed? We have to decide which use cases are common enough to support directly in the language, and I&#39;m not convinced that &quot;I need to look cases up by name, but I have no choice but to use rawValue for something else&quot; is one of them—that is, that it&#39;s *so* common that we need to direct our scarce engineering resources towards designing and implementing a separate feature merely to accommodate it. There are a whole lot of things that are *way* higher on our to-do list than this, arguably including metaprogramming features which would let you write this yourself instead of sticking it in the core language.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/87ed1189/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Working with enums by name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Brent, for needing &quot;both Int and Double values&quot; there is a proposal to add tuples instead of the current raw values or allowing assessor properties per case, you should check those out. Perhaps this could also be used to cryptoghaphically sign a raw value but I&#39;m not sure.<br></p><p>I know; I was the one who suggested accessors.<br></p><p>&gt; As for working with enum values by name a few examples have already been posted in today but I&#39;ve done a lot more research in the subject along the day and found there is a correlation between enums and nominal level values in statistics; we cannot test them for a particular order (this could also be interesting for statistic apps but it&#39;s another case) and no math with them is valid. So, e.g., the result of the following operation on the planets enum is nonsense:<br>&gt; <br>&gt; |   let planet = Planet(rawValue: Planet.Mars.rawValue - Planet.Mercury.rawValue)<br>&gt; <br>&gt; The result will be different if the enum values are zero based than if not. Also any change in list order or the base index or add a new element to the middle of the list will break your intended code if you&#39;re storing the raw value in a database. And we know these changes happen.<br></p><p>All of this is true. And all of this is an argument that *you&#39;re using raw values wrong*.<br></p><p>Raw values are a serialization mechanism. You might be serializing merely within your process, or you might be writing out to disk, through IPC, or across the network, but in all cases you are serializing. You should not be doing arithmetic with a serialized representation (unless that arithmetic is a part of the serialization process, like an error-correcting code you&#39;re applying to it). You should not be sorting serialized representations. You should be either communicating the raw value or recreating the instance with it—nothing else.<br></p><p>In other words, all of these are arguments for putting the order of the Planet in a separate property rather than in the `rawValue`. This would free up the `rawValue` to be a `String` containing the case name. This is not an argument for having both an Int `rawValue` and a String `caseName`; this is an argument for having both a String `rawValue` and an Int property.<br></p><p>	enum Planet: String {<br>		accessor var order: Int<br>		<br>		case mercury { order = 0 }<br>		case venus { order = 1 }<br>		...etc...<br>	}<br></p><p>(Want it to be automatic? One could imagine having a compiler substitution for &quot;the index of this case&quot; which could be used as the default value for an accessor:<br></p><p>	enum Planet: String {<br>		accessor var order: Int = #caseIndex<br>		case mercury, venus, ...<br>	}<br></p><p>Or let you choose a base:<br></p><p>	enum Planet: String {<br>		accessor var order: Int = #caseOrder(from: 1)<br>		case mercury, venus, ...<br>	}<br></p><p>Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br></p><p>	enum Planet: String, ValuesEnumerable {<br>		var order: Int {<br>			return Planet.allValues.index(of: self)!<br>		}<br>		init(order: Int) {<br>			self = Planet.allValues[order]<br>		}<br>		case mercury, venus, …<br>	}<br></p><p>In short, there are several plausible mechanisms to automate assignment of these numbers, should you want to do that.)<br></p><p>&gt; Actually, given this characteristic of nominal types (statistic), we should vow to removing init(rawValue:) completely from the language.<br></p><p>That doesn&#39;t follow. The fact that changing something would break code doesn&#39;t mean that thing should be removed; it means you should be cautious about changing that thing. If you rename a case, its name changes; does that mean we shouldn&#39;t have case name lookups either? Changing any identifier could break something; maybe we should abolish all identifiers from Swift?<br></p><p>&gt; The real value you&#39;re working with in enums is the enum case name not any associated values. By working with the name you&#39;re safe should any associated value change, should their order change, you&#39;ll only break your app if the case is removed/renamed (with the raw value, you risk having the wrong treatment being given should another enum case takes the value of a removed one).<br></p><p>RawRepresentable is a serialization mechanism, so *of course* changing the raw value can break serialization. This is true whether you&#39;re using `Int` raw values or `String` raw values; it&#39;s just that `Int`s are a little easier to change.<br></p><p>If you create an enum with raw values, the raw values are more or less part of that enum&#39;s contract. You shouldn&#39;t expect things to continue to work properly if you change them, any more than you should expect them to continue to work properly if you delete a case. In fact, the library resilience document specifically calls out changing raw values as a &quot;binary-compatible source-breaking change&quot;: &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#enums&gt;<br></p><p>&gt; I agree there are lots of important and more difficult things to review in the language but I wouldn&#39;t be wasting my time here if I didn&#39;t think this was equally important.<br></p><p>I don&#39;t see how it&#39;s particularly important to solve this bizarre corner case of needing both a non-String raw value *and* a way to look up cases by name, particularly since you *still* have not provided a decent example where the non-String rawValue ought to be a rawValue at all.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Working with enums by name</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  2, 2016 at 03:00:00pm</p></header><div class="content"><p>Great points Brent. I think the ValuesEnumerable method would be the most straight forward. Also, the number of cases are likely only going to be in range of 6–20, so iterating would be fine I think. People can create something like `Dictionary(Planet.allValues.enumerated().lazy.map{ ($1, $0) })` (I think that’s right) if they really need.<br></p><p><br>&gt; On 2 Jun 2016, at 2:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br>&gt; <br>&gt; 	enum Planet: String, ValuesEnumerable {<br>&gt; 		var order: Int {<br>&gt; 			return Planet.allValues.index(of: self)!<br>&gt; 		}<br>&gt; 		init(order: Int) {<br>&gt; 			self = Planet.allValues[order]<br>&gt; 		}<br>&gt; 		case mercury, venus, …<br>&gt; 	}<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>There are several ways to solve this, which IMO is a basic functionality of enums, writing code that is currently possible and works. But that&#39;s the issue, you still have to write code to have a basic functionally. I don&#39;t remember not being able to do this out-of-the-box in any language I worked with.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Patrick Smith&quot; &lt;pgwsmith at gmail.com&gt;<br>Sent: ‎02/‎06/‎2016 02:07 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>Great points Brent. I think the ValuesEnumerable method would be the most straight forward. Also, the number of cases are likely only going to be in range of 6–20, so iterating would be fine I think. People can create something like `Dictionary(Planet.allValues.enumerated().lazy.map{ ($1, $0) })` (I think that’s right) if they really need.<br></p><p><br>&gt; On 2 Jun 2016, at 2:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br>&gt; <br>&gt; 	enum Planet: String, ValuesEnumerable {<br>&gt; 		var order: Int {<br>&gt; 			return Planet.allValues.index(of: self)!<br>&gt; 		}<br>&gt; 		init(order: Int) {<br>&gt; 			self = Planet.allValues[order]<br>&gt; 		}<br>&gt; 		case mercury, venus, …<br>&gt; 	}<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/e40def74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Working with enums by name</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  3, 2016 at 12:00:00pm</p></header><div class="content"><p>From what I understand, enums normally are represented internally by an offset — that is their truth. With RawRepresentable enums, you are saying “no, I want the truth to be something else”. But it seems that they are still represented internally by an offset, so you can’t reorder a RawRepresentable enum’s cases and maintain ABI compatibility either.<br></p><p>So what you are saying about the order of cases being an intrinsic part of an enum does make sense. I’m not sure if can still lead to confusing / fragile code though.<br></p><p>Patrick<br></p><p><br>&gt; On 2 Jun 2016, at 10:17 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; There are several ways to solve this, which IMO is a basic functionality of enums, writing code that is currently possible and works. But that&#39;s the issue, you still have to write code to have a basic functionally. I don&#39;t remember not being able to do this out-of-the-box in any language I worked with.<br>&gt; <br>&gt; L<br>&gt; From: Patrick Smith &lt;mailto:pgwsmith at gmail.com&gt;<br>&gt; Sent: ‎02/‎06/‎2016 02:07 AM<br>&gt; To: Brent Royal-Gordon &lt;mailto:brent at architechies.com&gt;<br>&gt; Cc: Leonardo Pessoa &lt;mailto:me at lmpessoa.com&gt;; swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] Working with enums by name<br>&gt; <br>&gt; Great points Brent. I think the ValuesEnumerable method would be the most straight forward. Also, the number of cases are likely only going to be in range of 6–20, so iterating would be fine I think. People can create something like `Dictionary(Planet.allValues.enumerated().lazy.map{ ($1, $0) })` (I think that’s right) if they really need.<br>&gt; <br>&gt; <br>&gt; &gt; On 2 Jun 2016, at 2:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br>&gt; &gt; <br>&gt; &gt; enum Planet: String, ValuesEnumerable {<br>&gt; &gt; var order: Int {<br>&gt; &gt; return Planet.allValues.index(of: self)!<br>&gt; &gt; }<br>&gt; &gt; init(order: Int) {<br>&gt; &gt; self = Planet.allValues[order]<br>&gt; &gt; }<br>&gt; &gt; case mercury, venus, …<br>&gt; &gt; }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/e7b14894/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Patrick, I never said the order of the enum was intrinsic. If the offset of the case were the truth of the enum as you said enums would be ordinal types and you could do tests like &quot;Planet.Mercury &gt; Planet.Venus&quot; without any extra code. But enums are nominal types not ordinal types so you can only distinguish the different values but they have no particular order or any other property. Two simple examples of nominal types are colours and cardinal points. Do they have any particular order? That&#39;s how enums are implemented in Swift (as a nominal type) and that&#39;s another reason why working with case names makes even more sense.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Patrick Smith&quot; &lt;pgwsmith at gmail.com&gt;<br>Sent: ‎02/‎06/‎2016 11:18 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>&gt;From what I understand, enums normally are represented internally by an offset — that is their truth. With RawRepresentable enums, you are saying “no, I want the truth to be something else”. But it seems that they are still represented internally by an offset, so you can’t reorder a RawRepresentable enum’s cases and maintain ABI compatibility either.<br></p><p><br>So what you are saying about the order of cases being an intrinsic part of an enum does make sense. I’m not sure if can still lead to confusing / fragile code though.<br></p><p><br>Patrick<br></p><p><br></p><p><br>On 2 Jun 2016, at 10:17 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p><br>There are several ways to solve this, which IMO is a basic functionality of enums, writing code that is currently possible and works. But that&#39;s the issue, you still have to write code to have a basic functionally. I don&#39;t remember not being able to do this out-of-the-box in any language I worked with.<br></p><p>L<br></p><p><br>From: Patrick Smith<br>Sent: ‎02/‎06/‎2016 02:07 AM<br>To: Brent Royal-Gordon<br>Cc: Leonardo Pessoa; swift-evolution<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p><br>Great points Brent. I think the ValuesEnumerable method would be the most straight forward. Also, the number of cases are likely only going to be in range of 6–20, so iterating would be fine I think. People can create something like `Dictionary(Planet.allValues.enumerated().lazy.map{ ($1, $0) })` (I think that’s right) if they really need.<br></p><p><br>&gt; On 2 Jun 2016, at 2:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br>&gt; <br>&gt; enum Planet: String, ValuesEnumerable {<br>&gt; var order: Int {<br>&gt; return Planet.allValues.index(of: self)!<br>&gt; }<br>&gt; init(order: Int) {<br>&gt; self = Planet.allValues[order]<br>&gt; }<br>&gt; case mercury, venus, …<br>&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/b6293045/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  2, 2016 at 09:00:00am</p></header><div class="content"><p>I understand you don&#39;t like to rely on the name of your enum cases in you code and that&#39;s fine, you can still work with them as is, you won&#39;t have to change the way you work just because you don&#39;t like the proposal but that doesn&#39;t mean everybody has the same opinion you do. But perhaps then instead of enums we should go back to using simple constants because that&#39;s exactly what enum cases become if their names are not how you&#39;re expected to reference, store and retrieve their values (yes, I understand there are other benefits to using enums instead of constants but that&#39;s just how you&#39;re using them).<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Sent: ‎02/‎06/‎2016 01:40 AM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Vladimir.S&quot; &lt;svabox at gmail.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] Working with enums by name<br></p><p>&gt; Brent, for needing &quot;both Int and Double values&quot; there is a proposal to add tuples instead of the current raw values or allowing assessor properties per case, you should check those out. Perhaps this could also be used to cryptoghaphically sign a raw value but I&#39;m not sure.<br></p><p>I know; I was the one who suggested accessors.<br></p><p>&gt; As for working with enum values by name a few examples have already been posted in today but I&#39;ve done a lot more research in the subject along the day and found there is a correlation between enums and nominal level values in statistics; we cannot test them for a particular order (this could also be interesting for statistic apps but it&#39;s another case) and no math with them is valid. So, e.g., the result of the following operation on the planets enum is nonsense:<br>&gt; <br>&gt; |   let planet = Planet(rawValue: Planet.Mars.rawValue - Planet.Mercury.rawValue)<br>&gt; <br>&gt; The result will be different if the enum values are zero based than if not. Also any change in list order or the base index or add a new element to the middle of the list will break your intended code if you&#39;re storing the raw value in a database. And we know these changes happen.<br></p><p>All of this is true. And all of this is an argument that *you&#39;re using raw values wrong*.<br></p><p>Raw values are a serialization mechanism. You might be serializing merely within your process, or you might be writing out to disk, through IPC, or across the network, but in all cases you are serializing. You should not be doing arithmetic with a serialized representation (unless that arithmetic is a part of the serialization process, like an error-correcting code you&#39;re applying to it). You should not be sorting serialized representations. You should be either communicating the raw value or recreating the instance with it—nothing else.<br></p><p>In other words, all of these are arguments for putting the order of the Planet in a separate property rather than in the `rawValue`. This would free up the `rawValue` to be a `String` containing the case name. This is not an argument for having both an Int `rawValue` and a String `caseName`; this is an argument for having both a String `rawValue` and an Int property.<br></p><p>	enum Planet: String {<br>		accessor var order: Int<br>		<br>		case mercury { order = 0 }<br>		case venus { order = 1 }<br>		...etc...<br>	}<br></p><p>(Want it to be automatic? One could imagine having a compiler substitution for &quot;the index of this case&quot; which could be used as the default value for an accessor:<br></p><p>	enum Planet: String {<br>		accessor var order: Int = #caseIndex<br>		case mercury, venus, ...<br>	}<br></p><p>Or let you choose a base:<br></p><p>	enum Planet: String {<br>		accessor var order: Int = #caseOrder(from: 1)<br>		case mercury, venus, ...<br>	}<br></p><p>Or the `ValuesEnumerable` proposal would give you a convenient, though slightly slow, way to do two-way lookup by order:<br></p><p>	enum Planet: String, ValuesEnumerable {<br>		var order: Int {<br>			return Planet.allValues.index(of: self)!<br>		}<br>		init(order: Int) {<br>			self = Planet.allValues[order]<br>		}<br>		case mercury, venus, …<br>	}<br></p><p>In short, there are several plausible mechanisms to automate assignment of these numbers, should you want to do that.)<br></p><p>&gt; Actually, given this characteristic of nominal types (statistic), we should vow to removing init(rawValue:) completely from the language.<br></p><p>That doesn&#39;t follow. The fact that changing something would break code doesn&#39;t mean that thing should be removed; it means you should be cautious about changing that thing. If you rename a case, its name changes; does that mean we shouldn&#39;t have case name lookups either? Changing any identifier could break something; maybe we should abolish all identifiers from Swift?<br></p><p>&gt; The real value you&#39;re working with in enums is the enum case name not any associated values. By working with the name you&#39;re safe should any associated value change, should their order change, you&#39;ll only break your app if the case is removed/renamed (with the raw value, you risk having the wrong treatment being given should another enum case takes the value of a removed one).<br></p><p>RawRepresentable is a serialization mechanism, so *of course* changing the raw value can break serialization. This is true whether you&#39;re using `Int` raw values or `String` raw values; it&#39;s just that `Int`s are a little easier to change.<br></p><p>If you create an enum with raw values, the raw values are more or less part of that enum&#39;s contract. You shouldn&#39;t expect things to continue to work properly if you change them, any more than you should expect them to continue to work properly if you delete a case. In fact, the library resilience document specifically calls out changing raw values as a &quot;binary-compatible source-breaking change&quot;: &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#enums&gt;<br></p><p>&gt; I agree there are lots of important and more difficult things to review in the language but I wouldn&#39;t be wasting my time here if I didn&#39;t think this was equally important.<br></p><p>I don&#39;t see how it&#39;s particularly important to solve this bizarre corner case of needing both a non-String raw value *and* a way to look up cases by name, particularly since you *still* have not provided a decent example where the non-String rawValue ought to be a rawValue at all.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160602/9ef30c54/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Working with enums by name</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  1, 2016 at 10:00:00am</p></header><div class="content"><p>IIRC, string interpolation prepends the module name if the enum belongs to a module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of compiler crashes, at least in the past.<br></p><p>Those two factors forced me into this ugliness: https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115<br></p><p>A clean, documented, supported way of exposing the enum case name that the runtime clearly already has available seems sensible — and should be independent of the raw type.<br></p><p>Cheers, P<br></p><p>&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt; <br>&gt; For example, this:<br>&gt; <br>&gt; enum Planet {<br>&gt; 	case Earth<br>&gt; 	case Mars<br>&gt; }<br>&gt; <br>&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt; <br>&gt; <br>&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt; <br>&gt; Note that this:<br>&gt; <br>&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I had no idea you could do this!!<br>&gt;&gt; <br>&gt;&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Paul, in all my tests for this thread printing the enum value only<br>produced the enum value&#39;s name (&quot;Mars&quot; in your example). The proposal<br>of having a .caseName (or should it better be .caseValue to cover<br>enums with associated values? any other suggestions?) will prevent<br>that changes to this behaviour crash apps in the future as this should<br>always produce the same result even if the string representation<br>changes.<br></p><p>L<br></p><p>On 1 June 2016 at 12:15, Paul Cantrell via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; IIRC, string interpolation prepends the module name if the enum belongs to a module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of compiler crashes, at least in the past.<br>&gt;<br>&gt; Those two factors forced me into this ugliness: https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115<br>&gt;<br>&gt; A clean, documented, supported way of exposing the enum case name that the runtime clearly already has available seems sensible — and should be independent of the raw type.<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt;&gt;<br>&gt;&gt; For example, this:<br>&gt;&gt;<br>&gt;&gt; enum Planet {<br>&gt;&gt;       case Earth<br>&gt;&gt;       case Mars<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt;&gt;<br>&gt;&gt; Note that this:<br>&gt;&gt;<br>&gt;&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>&gt;&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I had no idea you could do this!!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt;&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt;&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt;&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Working with enums by name</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  1, 2016 at 07:00:00pm</p></header><div class="content"><p>This will not print the name of case :<br></p><p>enum E: CustomStringConvertible {<br>     case one, two<br></p><p>     var description: String {return &quot;haha&quot;}<br>}<br></p><p>print(E.one)<br></p><p>So, for me, it seems like the good idea to have a standard(and built-in) <br>way to convert string&lt;-&gt;case i.e. to have<br></p><p>let e = E(caseName: &quot;one&quot;)!<br>and<br>let s = e.caseName // always the same as defined in enum type<br></p><p><br>On 01.06.2016 18:47, Leonardo Pessoa via swift-evolution wrote:<br>&gt; Paul, in all my tests for this thread printing the enum value only<br>&gt; produced the enum value&#39;s name (&quot;Mars&quot; in your example). The proposal<br>&gt; of having a .caseName (or should it better be .caseValue to cover<br>&gt; enums with associated values? any other suggestions?) will prevent<br>&gt; that changes to this behaviour crash apps in the future as this should<br>&gt; always produce the same result even if the string representation<br>&gt; changes.<br>&gt;<br>&gt; L<br>&gt;<br>&gt; On 1 June 2016 at 12:15, Paul Cantrell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; IIRC, string interpolation prepends the module name if the enum belongs to a module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of compiler crashes, at least in the past.<br>&gt;&gt;<br>&gt;&gt; Those two factors forced me into this ugliness: https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115<br>&gt;&gt;<br>&gt;&gt; A clean, documented, supported way of exposing the enum case name that the runtime clearly already has available seems sensible — and should be independent of the raw type.<br>&gt;&gt;<br>&gt;&gt; Cheers, P<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Planet {<br>&gt;&gt;&gt;       case Earth<br>&gt;&gt;&gt;       case Mars<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>&gt;&gt;&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I had no idea you could do this!!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt;&gt;&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt;&gt;&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt;&gt;&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Working with enums by name</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Indeed, you’re quite right: verified that I get “Mars” even when the enum is in a framework.<br></p><p>It took a little digging to get back what I was thinking of: it’s when the enum value is inside some other data structure that you get an annoyingly fully qualified name:<br></p><p>    enum CoinSide {<br>        case heads<br>        case tails<br>    }<br></p><p>    enum CoinState {<br>        case inAir<br>        case landed(showing: CoinSide)<br>    }<br></p><p>    print(CoinState.inAir)  // → &quot;inAir&quot;<br></p><p>    // …but…<br></p><p>    print(CoinState.landed(showing: .heads))  // → &quot;landed(CoinSide.heads)&quot;<br></p><p>    print([CoinSide.heads: 1])  // → &quot;[CoinSide.heads: 1]&quot;<br></p><p>This is the case I was thinking of where the module name comes into play. Drop those enums into a framework, and you’ll get &quot;landed(MyFramework.CoinSide.heads)&quot;. Ugh!<br></p><p>So what if you want those second two to print out as &quot;landed(heads)&quot; and &quot;[heads: 1]”? This does not work:<br></p><p>    enum CoinSide: CustomStringConvertible {<br>        case heads<br>        case tails<br>        <br>        var description: String {<br>            return String(self) // infinite recursion<br>        }<br>    }<br></p><p>There’s no automatically implemented description (or debugDescription) property we can delegate to. The conversion of .heads →  &quot;heads&quot; is apparently runtime magic that we lose access to as soon as we implement CustomStringConvertible or CustomDebugStringConvertible, and therefore AFAIK there&#39;s no way to do this other than switching on all the cases:<br></p><p>    enum CoinSide: CustomStringConvertible {<br>        case heads<br>        case tails<br>        <br>        var description: String {<br>            switch(self) {<br>                case heads: return &quot;heads&quot;<br>                case tails: return &quot;tails&quot;<br>            }<br>        }<br>    }<br></p><p>Is is true that there’s no better way? Is there some CustomVerboseDebugStringConvertible protocol we can override to change only the &quot;MyFramework.CoinSide.heads&quot; form?<br></p><p>If indeed there is no better way, it seems like a really good case for having the synthesized .caseName property. Even if there is a CustomVerboseDebugStringConvertible to override in the particular case above, being able to customize an enum’s description but still use the enum case name in that description seems like a compelling use case as well.<br></p><p>Cheers, P<br></p><p>&gt; On Jun 1, 2016, at 10:47 AM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; Paul, in all my tests for this thread printing the enum value only<br>&gt; produced the enum value&#39;s name (&quot;Mars&quot; in your example). The proposal<br>&gt; of having a .caseName (or should it better be .caseValue to cover<br>&gt; enums with associated values? any other suggestions?) will prevent<br>&gt; that changes to this behaviour crash apps in the future as this should<br>&gt; always produce the same result even if the string representation<br>&gt; changes.<br>&gt; <br>&gt; L<br>&gt; <br>&gt; On 1 June 2016 at 12:15, Paul Cantrell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; IIRC, string interpolation prepends the module name if the enum belongs to a module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of compiler crashes, at least in the past.<br>&gt;&gt; <br>&gt;&gt; Those two factors forced me into this ugliness: https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115<br>&gt;&gt; <br>&gt;&gt; A clean, documented, supported way of exposing the enum case name that the runtime clearly already has available seems sensible — and should be independent of the raw type.<br>&gt;&gt; <br>&gt;&gt; Cheers, P<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Planet {<br>&gt;&gt;&gt;      case Earth<br>&gt;&gt;&gt;      case Mars<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>&gt;&gt;&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I had no idea you could do this!!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt;&gt;&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt;&gt;&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt;&gt;&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/8bdc3cc6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Working with enums by name</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 12:53 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Indeed, you’re quite right: verified that I get “Mars” even when the enum is in a framework.<br>&gt; <br>&gt; It took a little digging to get back what I was thinking of: it’s when the enum value is inside some other data structure that you get an annoyingly fully qualified name:<br>&gt; <br>&gt;     enum CoinSide {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;     }<br>&gt; <br>&gt;     enum CoinState {<br>&gt;         case inAir<br>&gt;         case landed(showing: CoinSide)<br>&gt;     }<br>&gt; <br>&gt;     print(CoinState.inAir)  // → &quot;inAir&quot;<br>&gt; <br>&gt;     // …but…<br>&gt; <br>&gt;     print(CoinState.landed(showing: .heads))  // → &quot;landed(CoinSide.heads)&quot;<br>&gt; <br>&gt;     print([CoinSide.heads: 1])  // → &quot;[CoinSide.heads: 1]&quot;<br>&gt; <br>&gt; This is the case I was thinking of where the module name comes into play. Drop those enums into a framework, and you’ll get &quot;landed(MyFramework.CoinSide.heads)&quot;. Ugh!<br></p><p>This seems to be more of namespace “import” issue than a problem with enums specifically. Declaring enums within another entity is a useful. I take advantage of qualified naming to make short, possibly non-unique enum names.<br></p><p>&gt; <br>&gt; So what if you want those second two to print out as &quot;landed(heads)&quot; and &quot;[heads: 1]”? This does not work:<br>&gt; <br>&gt;     enum CoinSide: CustomStringConvertible {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;         <br>&gt;         var description: String {<br>&gt;             return String(self) // infinite recursion<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; There’s no automatically implemented description (or debugDescription) property we can delegate to. The conversion of .heads →  &quot;heads&quot; is apparently runtime magic that we lose access to as soon as we implement CustomStringConvertible or CustomDebugStringConvertible, and therefore AFAIK there&#39;s no way to do this other than switching on all the cases:<br>&gt; <br>&gt;     enum CoinSide: CustomStringConvertible {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;         <br>&gt;         var description: String {<br>&gt;             switch(self) {<br>&gt;                 case heads: return &quot;heads&quot;<br>&gt;                 case tails: return &quot;tails&quot;<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Is is true that there’s no better way? Is there some CustomVerboseDebugStringConvertible protocol we can override to change only the &quot;MyFramework.CoinSide.heads&quot; form?<br>&gt; <br>&gt; If indeed there is no better way, it seems like a really good case for having the synthesized .caseName property. Even if there is a CustomVerboseDebugStringConvertible to override in the particular case above, being able to customize an enum’s description but still use the enum case name in that description seems like a compelling use case as well.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 10:47 AM, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Paul, in all my tests for this thread printing the enum value only<br>&gt;&gt; produced the enum value&#39;s name (&quot;Mars&quot; in your example). The proposal<br>&gt;&gt; of having a .caseName (or should it better be .caseValue to cover<br>&gt;&gt; enums with associated values? any other suggestions?) will prevent<br>&gt;&gt; that changes to this behaviour crash apps in the future as this should<br>&gt;&gt; always produce the same result even if the string representation<br>&gt;&gt; changes.<br>&gt;&gt; <br>&gt;&gt; L<br>&gt;&gt; <br>&gt;&gt; On 1 June 2016 at 12:15, Paul Cantrell via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; IIRC, string interpolation prepends the module name if the enum belongs to a module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of compiler crashes, at least in the past.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those two factors forced me into this ugliness: https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115 &lt;https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A clean, documented, supported way of exposing the enum case name that the runtime clearly already has available seems sensible — and should be independent of the raw type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior that isn&#39;t well documented.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example, this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Planet {<br>&gt;&gt;&gt;&gt;      case Earth<br>&gt;&gt;&gt;&gt;      case Mars<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever raw value kind<br>&gt;&gt;&gt;&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I had no idea you could do this!!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Who said anything about repeating the name?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30). Type :help for assistance.<br>&gt;&gt;&gt;&gt;&gt;&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune }<br>&gt;&gt;&gt;&gt;&gt;&gt; 2&gt; Planet.mercury.rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt; $R0: String = &quot;mercury&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/ca969078/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Working with enums by name</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June  1, 2016 at 05:00:00pm</p></header><div class="content"><p>Enums outside frameworks will still rely on you as the programmer to<br>know to which enum the string representation belongs to (it does so<br>for the raw values) so I see no reason why the .caseName result should<br>have the name of any underlying type the case belongs to.<br></p><p>L<br></p><p>On 1 June 2016 at 16:20, Christopher Kornher via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jun 1, 2016, at 12:53 PM, Paul Cantrell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Indeed, you’re quite right: verified that I get “Mars” even when the enum is<br>&gt; in a framework.<br>&gt;<br>&gt; It took a little digging to get back what I was thinking of: it’s when the<br>&gt; enum value is inside some other data structure that you get an annoyingly<br>&gt; fully qualified name:<br>&gt;<br>&gt;     enum CoinSide {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;     }<br>&gt;<br>&gt;     enum CoinState {<br>&gt;         case inAir<br>&gt;         case landed(showing: CoinSide)<br>&gt;     }<br>&gt;<br>&gt;     print(CoinState.inAir)  // → &quot;inAir&quot;<br>&gt;<br>&gt;     // …but…<br>&gt;<br>&gt;     print(CoinState.landed(showing: .heads))  // → &quot;landed(CoinSide.heads)&quot;<br>&gt;<br>&gt;     print([CoinSide.heads: 1])  // → &quot;[CoinSide.heads: 1]&quot;<br>&gt;<br>&gt; This is the case I was thinking of where the module name comes into play.<br>&gt; Drop those enums into a framework, and you’ll get<br>&gt; &quot;landed(MyFramework.CoinSide.heads)&quot;. Ugh!<br>&gt;<br>&gt;<br>&gt; This seems to be more of namespace “import” issue than a problem with enums<br>&gt; specifically. Declaring enums within another entity is a useful. I take<br>&gt; advantage of qualified naming to make short, possibly non-unique enum names.<br>&gt;<br>&gt;<br>&gt; So what if you want those second two to print out as &quot;landed(heads)&quot; and<br>&gt; &quot;[heads: 1]”? This does not work:<br>&gt;<br>&gt;     enum CoinSide: CustomStringConvertible {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;<br>&gt;         var description: String {<br>&gt;             return String(self) // infinite recursion<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; There’s no automatically implemented description (or debugDescription)<br>&gt; property we can delegate to. The conversion of .heads →  &quot;heads&quot; is<br>&gt; apparently runtime magic that we lose access to as soon as we implement<br>&gt; CustomStringConvertible or CustomDebugStringConvertible, and therefore AFAIK<br>&gt; there&#39;s no way to do this other than switching on all the cases:<br>&gt;<br>&gt;     enum CoinSide: CustomStringConvertible {<br>&gt;         case heads<br>&gt;         case tails<br>&gt;<br>&gt;         var description: String {<br>&gt;             switch(self) {<br>&gt;                 case heads: return &quot;heads&quot;<br>&gt;                 case tails: return &quot;tails&quot;<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; Is is true that there’s no better way? Is there some<br>&gt; CustomVerboseDebugStringConvertible protocol we can override to change only<br>&gt; the &quot;MyFramework.CoinSide.heads&quot; form?<br>&gt;<br>&gt; If indeed there is no better way, it seems like a really good case for<br>&gt; having the synthesized .caseName property. Even if there is a<br>&gt; CustomVerboseDebugStringConvertible to override in the particular case<br>&gt; above, being able to customize an enum’s description but still use the enum<br>&gt; case name in that description seems like a compelling use case as well.<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt; On Jun 1, 2016, at 10:47 AM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt; Paul, in all my tests for this thread printing the enum value only<br>&gt; produced the enum value&#39;s name (&quot;Mars&quot; in your example). The proposal<br>&gt; of having a .caseName (or should it better be .caseValue to cover<br>&gt; enums with associated values? any other suggestions?) will prevent<br>&gt; that changes to this behaviour crash apps in the future as this should<br>&gt; always produce the same result even if the string representation<br>&gt; changes.<br>&gt;<br>&gt; L<br>&gt;<br>&gt; On 1 June 2016 at 12:15, Paul Cantrell via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; IIRC, string interpolation prepends the module name if the enum belongs to a<br>&gt; module: “MyLib.Mars” instead of just “Mars”. It’s also been a source of<br>&gt; compiler crashes, at least in the past.<br>&gt;<br>&gt; Those two factors forced me into this ugliness:<br>&gt; https://github.com/bustoutsolutions/siesta/blob/master/Source/ResourceObserver.swift#L106-L115<br>&gt;<br>&gt; A clean, documented, supported way of exposing the enum case name that the<br>&gt; runtime clearly already has available seems sensible — and should be<br>&gt; independent of the raw type.<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt; On Jun 1, 2016, at 5:10 AM, Charlie Monroe via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is, however, kind of a hack IMHO that relies on the compiler behavior<br>&gt; that isn&#39;t well documented.<br>&gt;<br>&gt; For example, this:<br>&gt;<br>&gt; enum Planet {<br>&gt;      case Earth<br>&gt;      case Mars<br>&gt; }<br>&gt;<br>&gt; &quot;\(Planet.Mars)&quot; // This is &quot;Mars&quot;<br>&gt;<br>&gt;<br>&gt; Works as well. You don&#39;t need to have the represented value to be String.<br>&gt;<br>&gt; Note that this:<br>&gt;<br>&gt; - works both when you have a plain enum, or enum Planet: Int, or whatever<br>&gt; raw value kind<br>&gt; - does not work (!) when declared as @objc - then the result is &quot;Planet&quot;.<br>&gt;<br>&gt; On Jun 1, 2016, at 9:52 AM, Patrick Smith via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I had no idea you could do this!!<br>&gt;<br>&gt; On 1 Jun 2016, at 12:32 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Who said anything about repeating the name?<br>&gt;<br>&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.30).<br>&gt; Type :help for assistance.<br>&gt; 1&gt; enum Planet: String { case mercury, venus, earth, mars, jupiter, saturn,<br>&gt; uranus, neptune }<br>&gt; 2&gt; Planet.mercury.rawValue<br>&gt; $R0: String = &quot;mercury&quot;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Working with enums by name</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 2:20 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 12:53 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is the case I was thinking of where the module name comes into play. Drop those enums into a framework, and you’ll get &quot;landed(MyFramework.CoinSide.heads)&quot;. Ugh!<br>&gt; <br>&gt; This seems to be more of namespace “import” issue than a problem with enums specifically. Declaring enums within another entity is a useful. I take advantage of qualified naming to make short, possibly non-unique enum names.<br></p><p>Yes, in _code_ fully qualified names are useful.<br></p><p>This thread is the need for unqualified names in _strings_ — for passing to external systems, logging, etc.<br></p><p>The problematic behavior I was pointing out is that enums get converted to a name-only string when they are at the _top_ level of a data structure, but a fully qualified Module.EnumType.caseName when they&#39;re _nested_ inside a collection or another enum. AFAIK, there&#39;s no way to override this behavior without manually coding a case statement to map enum values to strings. This proposal would solve that.<br></p><p>Cheers, P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/85a4a25d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>Working with enums by name</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Oops. I have wanted this feature and I have created `name` methods for non-String enums numerous times (whether I had to or not, I guess). If there is a formal proposal for this, I could not find it. I am obviously not familiar with the entire proposal but this is a feature that I have wanted almost from the first day I started using Swift.<br></p><p>I would prefer a `name`method for enums and not overload `description`.<br></p><p>A standard way of accessing the unique names of enum values would be compatible with a future variant of `enum` that would allow non-unique rawValue should Swift ever support that feature of C/C++ enums. (hint) It would become requirement for these enums, I think.<br></p><p>Accessing the names of enum values is extremely useful for diagnostics and quick and dirty UI e.g. playgrounds. <br></p><p>&gt; On Jun 1, 2016, at 3:07 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 2:20 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 12:53 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the case I was thinking of where the module name comes into play. Drop those enums into a framework, and you’ll get &quot;landed(MyFramework.CoinSide.heads)&quot;. Ugh!<br>&gt;&gt; <br>&gt;&gt; This seems to be more of namespace “import” issue than a problem with enums specifically. Declaring enums within another entity is a useful. I take advantage of qualified naming to make short, possibly non-unique enum names.<br>&gt; <br>&gt; Yes, in _code_ fully qualified names are useful.<br>&gt; <br>&gt; This thread is the need for unqualified names in _strings_ — for passing to external systems, logging, etc.<br>&gt; <br>&gt; The problematic behavior I was pointing out is that enums get converted to a name-only string when they are at the _top_ level of a data structure, but a fully qualified Module.EnumType.caseName when they&#39;re _nested_ inside a collection or another enum. AFAIK, there&#39;s no way to override this behavior without manually coding a case statement to map enum values to strings. This proposal would solve that.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/b35fd9bc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
