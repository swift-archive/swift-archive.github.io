<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 13, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Apr 13 2016, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Should this new operator form a new range? How can this range know about the<br>&gt; array&#39;s indices?<br>&gt;<br>&gt; A while ago there was a proposal (unfortunately it was not discussed enough)<br>&gt; which introduced safe array indexing:<br>&gt;<br>&gt; array[safe: 3] // returns nil if index out of bounds<br></p><p>Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>all Collections.<br></p><p>&gt; So another way to handle this issue would be to make another subscript like:<br>&gt;<br>&gt; array[truncate: -1...6]<br></p><p>That approach makes sense too.  But then do we add<br></p><p>  x[python: 0..&lt;-2] // all but the last two elements?<br></p><p>;^)<br></p><p>&gt; Best regards<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;         The idea of having a new operator following the principles of overflow<br>&gt;     operators looks great. Two distinct operators doing implicit and explicitly<br>&gt;     might really be a good way to go; it would be concise and wouldn&#39;t look like<br>&gt;     some magic happened behind the scenes. I&#39;d like to hear more opinions about<br>&gt;     it.<br>&gt;<br>&gt;     &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become [0<br>&gt;     ..&lt; 3] ? I think, the latter.<br>&gt;     I agree here, I&#39;d choose the latter.<br>&gt;<br>&gt;     From my perspective, the behaviour I&#39;m proposing is what a considerable<br>&gt;     number of users expect, especially if coming from other languages that<br>&gt;     follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;     considering the Swift principles of being a safer language, in my opinion<br>&gt;     we&#39;d rather have a partial slice than a crash in execution time (when the<br>&gt;     user is not totally aware of it).<br>&gt;<br>&gt;     Many thanks for all your additions so far. It&#39;s really good to see that<br>&gt;     these things are not set in stone yet.<br>&gt;<br>&gt;     - Luis<br>&gt;<br>&gt;     On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     +1 for the idea &quot;in general&quot;. But I also think that explicit is better than<br>&gt;         implicit, especially if we deal with possible errors. Just like we work<br>&gt;         in Swift with integer overflow : &#39;+&#39; will generate run time error, but<br>&gt;         saying &amp;+ we point Swift that we know what we do.<br>&gt;<br>&gt;         but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt;         become [0 ..&lt; 3] ? I think, the latter.<br>&gt;<br>&gt;         On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;<br>&gt;         I like the idea in theory, but the question is; is it really safer to<br>&gt;             return a result that the developer may not have wanted, versus an<br>&gt;             error<br>&gt;             indicating that a mistake may have been made? I wonder if perhaps<br>&gt;             there<br>&gt;             could be an alternative, such as a variation of the operator like<br>&gt;             so:<br>&gt;<br>&gt;             let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;             a.endIndex)],<br>&gt;             becomes let b = a[0 ..&lt; 3]<br>&gt;<br>&gt;             I’m just not sure that we can assume that an array index out of<br>&gt;             range error<br>&gt;             is okay without some kind of indication from the developer, as<br>&gt;             otherwise we<br>&gt;             could end up returning a partial slice, which could end up causing<br>&gt;             an error<br>&gt;             elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;<br>&gt;                         On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;                 swift-evolution<br>&gt;                 &lt;swift-evolution at swift.org<br>&gt;                 &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;                 wrote:<br>&gt;<br>&gt;                 This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;                 operator)<br>&gt;                 in order to avoid **Array index out of range** errors in<br>&gt;                 execution time.<br>&gt;<br>&gt;                 Here is my first draft for this proposal:<br>&gt;                 https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;<br>&gt;                 In short, doing that in Swift causes a runtime error:<br>&gt;<br>&gt;                 leta =[1,2,3]<br>&gt;                 letb =a[0..&lt;5]<br>&gt;                 print(b)<br>&gt;<br>&gt;                 &gt; Error running code:<br>&gt;                 &gt; fatal error: Array index out of range<br>&gt;<br>&gt;                 The proposed solution is to slice the array returning all<br>&gt;                 elements that<br>&gt;                 are below the half-open operator, even though the number of<br>&gt;                 elements is<br>&gt;                 lesser than the ending of the half-open operator. So the example<br>&gt;                 above<br>&gt;                 would return [1,2,3].<br>&gt;                 We can see this very behaviour in other languages, such as<br>&gt;                 Python and<br>&gt;                 Ruby as shown in the proposal draft.<br>&gt;<br>&gt;                 This would eliminate the need for verifications on the array<br>&gt;                 size before<br>&gt;                 slicing it -- and consequently runtime errors in cases when the<br>&gt;                 programmer didn&#39;t.<br>&gt;<br>&gt;                 Viewing that it is my very first proposal, any feedback will be<br>&gt;                 helpful.<br>&gt;<br>&gt;                 Thanks!<br>&gt;<br>&gt;                 Luis Henrique Borges<br>&gt;                 @luishborges<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org<br>&gt;                 &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 14, 2016 at 12:00:00pm</p></header><div class="content"><p>As I understand, currently Range &lt;start&gt; can not be greater than &lt;end&gt;. So <br>we just can&#39;t use 0..&lt;-2. And I don&#39;t think we should implement such thing <br>as it is not very explicit about what we are expecting.<br></p><p>On 14.04.2016 0:29, Dave Abrahams via swift-evolution wrote:<br>&gt; That approach makes sense too.  But then do we add<br>&gt;<br>&gt;    x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;<br>&gt; ;^)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 14, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Apr 14 2016, &quot;Vladimir.S&quot; &lt;svabox-AT-gmail.com&gt; wrote:<br></p><p>&gt; As I understand, currently Range &lt;start&gt; can not be greater than<br>&gt; &lt;end&gt;. So we just can&#39;t use 0..&lt;-2. And I don&#39;t think we should<br>&gt; implement such thing as it is not very explicit about what we are<br>&gt; expecting.<br>&gt;<br>&gt; On 14.04.2016 0:29, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt; That approach makes sense too.  But then do we add<br>&gt;&gt;<br>&gt;&gt;    x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;&gt;<br>&gt;&gt; ;^)<br></p><p>I agree; I was half-joking.<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 22, 2016 at 01:00:00pm</p></header><div class="content"><p>is this syntax reasonably simple to implement? Or is there another solution<br>that would work with less impact in terms of design?<br>I mean the subscript with a label on it, i.e. collection[label:<br>Range&lt;Index&gt;]<br></p><p>It&#39;s been a while since the last feedback, so I&#39;m doing some rewriting on<br>this proposal and still considering to submit it for review.<br></p><p>- Luis<br></p><p>On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Apr 13 2016, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; &gt; Should this new operator form a new range? How can this range know about<br>&gt; the<br>&gt; &gt; array&#39;s indices?<br>&gt; &gt;<br>&gt; &gt; A while ago there was a proposal (unfortunately it was not discussed<br>&gt; enough)<br>&gt; &gt; which introduced safe array indexing:<br>&gt; &gt;<br>&gt; &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt;<br>&gt; Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>&gt; all Collections.<br>&gt;<br>&gt; &gt; So another way to handle this issue would be to make another subscript<br>&gt; like:<br>&gt; &gt;<br>&gt; &gt; array[truncate: -1...6]<br>&gt;<br>&gt; That approach makes sense too.  But then do we add<br>&gt;<br>&gt;   x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;<br>&gt; ;^)<br>&gt;<br>&gt; &gt; Best regards<br>&gt; &gt; - Maximilian<br>&gt; &gt;<br>&gt; &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;         The idea of having a new operator following the principles of<br>&gt; overflow<br>&gt; &gt;     operators looks great. Two distinct operators doing implicit and<br>&gt; explicitly<br>&gt; &gt;     might really be a good way to go; it would be concise and wouldn&#39;t<br>&gt; look like<br>&gt; &gt;     some magic happened behind the scenes. I&#39;d like to hear more<br>&gt; opinions about<br>&gt; &gt;     it.<br>&gt; &gt;<br>&gt; &gt;     &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt; become [0<br>&gt; &gt;     ..&lt; 3] ? I think, the latter.<br>&gt; &gt;     I agree here, I&#39;d choose the latter.<br>&gt; &gt;<br>&gt; &gt;     From my perspective, the behaviour I&#39;m proposing is what a<br>&gt; considerable<br>&gt; &gt;     number of users expect, especially if coming from other languages<br>&gt; that<br>&gt; &gt;     follow that path. Of course I&#39;m not comparing languages here, but<br>&gt; &gt;     considering the Swift principles of being a safer language, in my<br>&gt; opinion<br>&gt; &gt;     we&#39;d rather have a partial slice than a crash in execution time<br>&gt; (when the<br>&gt; &gt;     user is not totally aware of it).<br>&gt; &gt;<br>&gt; &gt;     Many thanks for all your additions so far. It&#39;s really good to see<br>&gt; that<br>&gt; &gt;     these things are not set in stone yet.<br>&gt; &gt;<br>&gt; &gt;     - Luis<br>&gt; &gt;<br>&gt; &gt;     On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt; &gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     +1 for the idea &quot;in general&quot;. But I also think that explicit is<br>&gt; better than<br>&gt; &gt;         implicit, especially if we deal with possible errors. Just like<br>&gt; we work<br>&gt; &gt;         in Swift with integer overflow : &#39;+&#39; will generate run time<br>&gt; error, but<br>&gt; &gt;         saying &amp;+ we point Swift that we know what we do.<br>&gt; &gt;<br>&gt; &gt;         but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise<br>&gt; error or<br>&gt; &gt;         become [0 ..&lt; 3] ? I think, the latter.<br>&gt; &gt;<br>&gt; &gt;         On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt; &gt;<br>&gt; &gt;         I like the idea in theory, but the question is; is it really<br>&gt; safer to<br>&gt; &gt;             return a result that the developer may not have wanted,<br>&gt; versus an<br>&gt; &gt;             error<br>&gt; &gt;             indicating that a mistake may have been made? I wonder if<br>&gt; perhaps<br>&gt; &gt;             there<br>&gt; &gt;             could be an alternative, such as a variation of the operator<br>&gt; like<br>&gt; &gt;             so:<br>&gt; &gt;<br>&gt; &gt;             let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt; &gt;             a.endIndex)],<br>&gt; &gt;             becomes let b = a[0 ..&lt; 3]<br>&gt; &gt;<br>&gt; &gt;             I’m just not sure that we can assume that an array index out<br>&gt; of<br>&gt; &gt;             range error<br>&gt; &gt;             is okay without some kind of indication from the developer,<br>&gt; as<br>&gt; &gt;             otherwise we<br>&gt; &gt;             could end up returning a partial slice, which could end up<br>&gt; causing<br>&gt; &gt;             an error<br>&gt; &gt;             elsewhere where the size of the slice is assumed to be 5 but<br>&gt; isn’t.<br>&gt; &gt;<br>&gt; &gt;                         On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa<br>&gt; via<br>&gt; &gt;                 swift-evolution<br>&gt; &gt;                 &lt;swift-evolution at swift.org<br>&gt; &gt;                 &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;                 wrote:<br>&gt; &gt;<br>&gt; &gt;                 This proposal seeks to provide a safer ..&lt; (aka<br>&gt; half-open range<br>&gt; &gt;                 operator)<br>&gt; &gt;                 in order to avoid **Array index out of range** errors in<br>&gt; &gt;                 execution time.<br>&gt; &gt;<br>&gt; &gt;                 Here is my first draft for this proposal:<br>&gt; &gt;<br>&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt; &gt;<br>&gt; &gt;                 In short, doing that in Swift causes a runtime error:<br>&gt; &gt;<br>&gt; &gt;                 leta =[1,2,3]<br>&gt; &gt;                 letb =a[0..&lt;5]<br>&gt; &gt;                 print(b)<br>&gt; &gt;<br>&gt; &gt;                 &gt; Error running code:<br>&gt; &gt;                 &gt; fatal error: Array index out of range<br>&gt; &gt;<br>&gt; &gt;                 The proposed solution is to slice the array returning all<br>&gt; &gt;                 elements that<br>&gt; &gt;                 are below the half-open operator, even though the number<br>&gt; of<br>&gt; &gt;                 elements is<br>&gt; &gt;                 lesser than the ending of the half-open operator. So the<br>&gt; example<br>&gt; &gt;                 above<br>&gt; &gt;                 would return [1,2,3].<br>&gt; &gt;                 We can see this very behaviour in other languages, such<br>&gt; as<br>&gt; &gt;                 Python and<br>&gt; &gt;                 Ruby as shown in the proposal draft.<br>&gt; &gt;<br>&gt; &gt;                 This would eliminate the need for verifications on the<br>&gt; array<br>&gt; &gt;                 size before<br>&gt; &gt;                 slicing it -- and consequently runtime errors in cases<br>&gt; when the<br>&gt; &gt;                 programmer didn&#39;t.<br>&gt; &gt;<br>&gt; &gt;                 Viewing that it is my very first proposal, any feedback<br>&gt; will be<br>&gt; &gt;                 helpful.<br>&gt; &gt;<br>&gt; &gt;                 Thanks!<br>&gt; &gt;<br>&gt; &gt;                 Luis Henrique Borges<br>&gt; &gt;                 @luishborges<br>&gt; &gt;                 _______________________________________________<br>&gt; &gt;                 swift-evolution mailing list<br>&gt; &gt;                 swift-evolution at swift.org<br>&gt; &gt;                 &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;             _______________________________________________<br>&gt; &gt;             swift-evolution mailing list<br>&gt; &gt;             swift-evolution at swift.org<br>&gt; &gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;         _______________________________________________<br>&gt; &gt;         swift-evolution mailing list<br>&gt; &gt;         swift-evolution at swift.org<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160422/4c062d6f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
