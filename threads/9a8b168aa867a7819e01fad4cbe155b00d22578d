<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>NSRange and Range</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  8, 2016 at 11:00:00pm</p></header><div class="content"><p>Hello Swift-Evolution,<br></p><p>I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br></p><p>Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br></p><p>David.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>NSRange and Range</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift-Evolution,<br>&gt; <br>&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt; <br>&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br></p><p><br>One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>NSRange and Range</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>Why wouldn&#39;t it completely eliminate NSRange? Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br></p><p>&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt; <br>&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt; <br>&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt; <br>&gt; <br>&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt; <br>&gt;    - Doug<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>NSRange and Range</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May  9, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Why wouldn&#39;t it completely eliminate NSRange?<br></p><p>Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br></p><p>&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br></p><p>If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>NSRange and Range</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br></p><p>&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt; <br>&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt; <br>&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt; <br>&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>NSRange and Range</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May 10, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On May 10, 2016, at 12:14 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br></p><p>Yes, it&#39;s implementable. We do something similar to turn Darwin&#39;s BOOL into Swift&#39;s Bool even though they are representationally different. <br></p><p>  - Doug<br></p><p>&gt; <br>&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt; <br>&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt; <br>&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt; <br>&gt;&gt;    - Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Doug<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSRange and Range</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 10, 2016 at 09:00:00am</p></header><div class="content"><p>One particular concern we&#39;ve had is that many NSRanges aren’t Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things wouldn’t get any worse there, though.<br></p><p>Jordan<br></p><p><br>&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br>&gt; <br>&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt; <br>&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt; <br>&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt; <br>&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/7a174901/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>NSRange and Range</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Would it be feasible to annotate those and have them appropriately<br>converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge? Thinking<br>in particular of TextKit and friends — it&#39;d away with quite a lot of the<br>pain of, e.g., not having a native struct-y AttributedString.<br> <br>Cheers!<br>Zachary Waldowski<br>zach at waldowski.me<br> <br> <br>On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution wrote:<br>&gt; One particular concern we&#39;ve had is that many NSRanges aren’t<br>&gt; Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things<br>&gt; wouldn’t get any *worse* there, though.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if you<br>&gt;&gt; have already faced the same bridging concerns with NSArray/Array.<br>&gt;&gt; I’de really like this going forward, but I don’t know how confident I<br>&gt;&gt; am in writing a proposal.<br>&gt;&gt;<br>&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt;<br>&gt;&gt;&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as<br>&gt;&gt;&gt; Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than<br>&gt;&gt;&gt; Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that<br>&gt;&gt;&gt; (e.g.), an NSArray** parameter comes in as<br>&gt;&gt;&gt; UnsafeMutablePointer&lt;NSArray&gt; rather than<br>&gt;&gt;&gt; UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to<br>&gt;&gt;&gt;&gt; return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound<br>&gt;&gt;&gt; as a sentinel, yes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest<br>&gt;&gt;&gt;&gt;&gt;&gt; developement snapshot) and corelibs-foundation and I’ve hit one<br>&gt;&gt;&gt;&gt;&gt;&gt; major hurdle: passing and converting NSRange and Range around<br>&gt;&gt;&gt;&gt;&gt;&gt; between the different stdlib and Foundation APIs - specifically<br>&gt;&gt;&gt;&gt;&gt;&gt; in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all<br>&gt;&gt;&gt;&gt;&gt;&gt; corelibs-foundation APIs to accept/return Range on String instead<br>&gt;&gt;&gt;&gt;&gt;&gt; of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to<br>&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange<br>&gt;&gt;&gt;&gt;&gt; because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/1068c54a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSRange and Range</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>We thought about that too. The problem is that it’s not always obvious what NSString or NSAttributedString the indexes refer to. For example, most of the NSRegularExpression APIs produce matches in the form of NSTextCheckingResult, which then doesn’t have a reference to the original string.<br></p><p>Jordan<br></p><p><br>&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it be feasible to annotate those and have them appropriately converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge? Thinking in particular of TextKit and friends — it&#39;d away with quite a lot of the pain of, e.g., not having a native struct-y AttributedString.<br>&gt;  <br>&gt; Cheers!<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;  <br>&gt;  <br>&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution wrote:<br>&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things wouldn’t get any worse there, though.<br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/a71a76c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSRange and Range</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>By the way, this doesn’t mean it can’t be done, or that we can’t decide on some kind of partial solution! It just means that it needs to be carefully considered and explicitly addressed.<br></p><p>Jordan<br></p><p><br>&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; We thought about that too. The problem is that it’s not always obvious what NSString or NSAttributedString the indexes refer to. For example, most of the NSRegularExpression APIs produce matches in the form of NSTextCheckingResult, which then doesn’t have a reference to the original string.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it be feasible to annotate those and have them appropriately converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge? Thinking in particular of TextKit and friends — it&#39;d away with quite a lot of the pain of, e.g., not having a native struct-y AttributedString.<br>&gt;&gt;  <br>&gt;&gt; Cheers!<br>&gt;&gt;   Zachary Waldowski<br>&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution wrote:<br>&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things wouldn’t get any worse there, though.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/c7a1624c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>NSRange and Range</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Right, I 100% get it. :) This is a difficult problem space, and I&#39;m sure<br>you folks are aware that that difficulty is also reflected in how brutal<br>it is to use all of these derivative string-range-based things in Swift<br>right now. In this case, having no answer to this problem is worse than<br>not having the API at all — check Stack Overflow or GitHub for how often<br>a &quot;just paste this in&quot; String.Index.init(_: Int) comes up.<br> <br>As far as NSTextCheckingResult goes, its ranges are always in the<br>&quot;indices&quot; always in the space of the original string… do I have that<br>right? So it would be programmer error to use those ranges in the wrong<br>string just like it is with any Range&lt;String.UTF16Index&gt; today.<br> <br>Zach Waldowski<br> <br> <br>On Tue, May 10, 2016, at 06:51 PM, Jordan Rose wrote:<br>&gt; By the way, this doesn’t mean it can’t be done, or that we can’t<br>&gt; decide on some kind of partial solution! It just means that it needs<br>&gt; to be carefully considered and explicitly addressed.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We thought about that too. The problem is that it’s not always<br>&gt;&gt; obvious what NSString or NSAttributedString the indexes refer to. For<br>&gt;&gt; example, most of the NSRegularExpression APIs produce matches in the<br>&gt;&gt; form of NSTextCheckingResult, which then doesn’t have a reference to<br>&gt;&gt; the original string.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would it be feasible to annotate those and have them appropriately<br>&gt;&gt;&gt; converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge?<br>&gt;&gt;&gt; Thinking in particular of TextKit and friends — it&#39;d away with quite<br>&gt;&gt;&gt; a lot of the pain of, e.g., not having a native struct-y<br>&gt;&gt;&gt; AttributedString.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Cheers!<br>&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t<br>&gt;&gt;&gt;&gt; Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things<br>&gt;&gt;&gt;&gt; wouldn’t get any *worse* there, though.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if<br>&gt;&gt;&gt;&gt;&gt; you have already faced the same bridging concerns with<br>&gt;&gt;&gt;&gt;&gt; NSArray/Array. I’de really like this going forward, but I don’t<br>&gt;&gt;&gt;&gt;&gt; know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in<br>&gt;&gt;&gt;&gt;&gt;&gt; as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that<br>&gt;&gt;&gt;&gt;&gt;&gt; (e.g.), an NSArray** parameter comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;NSArray&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use<br>&gt;&gt;&gt;&gt;&gt;&gt; NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developement snapshot) and corelibs-foundation and I’ve hit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one major hurdle: passing and converting NSRange and Range<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around between the different stdlib and Foundation APIs -<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all corelibs-foundation APIs to accept/return Range on String<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of NSRange? In that case, can’t we get rid of NSRange<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/17f44b6e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSRange and Range</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>That’s correct, but how would you make the String.UTF16Index values without the reference String? They’re not (guaranteed to be) integers.<br></p><p>Jordan<br></p><p><br>&gt; On May 10, 2016, at 16:04, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; Right, I 100% get it. :) This is a difficult problem space, and I&#39;m sure you folks are aware that that difficulty is also reflected in how brutal it is to use all of these derivative string-range-based things in Swift right now. In this case, having no answer to this problem is worse than not having the API at all — check Stack Overflow or GitHub for how often a &quot;just paste this in&quot; String.Index.init(_: Int) comes up.<br>&gt;  <br>&gt; As far as NSTextCheckingResult goes, its ranges are always in the &quot;indices&quot; always in the space of the original string… do I have that right? So it would be programmer error to use those ranges in the wrong string just like it is with any Range&lt;String.UTF16Index&gt; today.<br>&gt;  <br>&gt; Zach Waldowski<br>&gt;  <br>&gt;  <br>&gt; On Tue, May 10, 2016, at 06:51 PM, Jordan Rose wrote:<br>&gt;&gt; By the way, this doesn’t mean it can’t be done, or that we can’t decide on some kind of partial solution! It just means that it needs to be carefully considered and explicitly addressed.<br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; We thought about that too. The problem is that it’s not always obvious what NSString or NSAttributedString the indexes refer to. For example, most of the NSRegularExpression APIs produce matches in the form of NSTextCheckingResult, which then doesn’t have a reference to the original string.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Would it be feasible to annotate those and have them appropriately converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge? Thinking in particular of TextKit and friends — it&#39;d away with quite a lot of the pain of, e.g., not having a native struct-y AttributedString.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Cheers!<br>&gt;&gt;&gt;&gt;   Zachary Waldowski<br>&gt;&gt;&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things wouldn’t get any worse there, though.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/aeee69d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>NSRange and Range</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Conceptually, yes, but is that not exactly how it is implemented?<br>https://github.com/apple/swift/blob/master/stdlib/public/core/StringUTF16.swift#L24<br> <br>Sincerely,<br>Zachary Waldowski<br>zach at waldowski.me<br> <br> <br>On Wed, May 11, 2016, at 01:13 PM, Jordan Rose wrote:<br>&gt; That’s correct, but how would you *make* the String.UTF16Index values<br>&gt; without the reference String? They’re not (guaranteed to be) integers.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On May 10, 2016, at 16:04, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Right, I 100% get it. :) This is a difficult problem space, and I&#39;m<br>&gt;&gt; sure you folks are aware that that difficulty is also reflected in<br>&gt;&gt; how brutal it is to use all of these derivative string-range-based<br>&gt;&gt; things in Swift right now. In this case, having no answer to this<br>&gt;&gt; problem is worse than not having the API at all — check Stack<br>&gt;&gt; Overflow or GitHub for how often a &quot;just paste this in&quot;<br>&gt;&gt; String.Index.init(_: Int) comes up.<br>&gt;&gt;<br>&gt;&gt; As far as NSTextCheckingResult goes, its ranges are always in the<br>&gt;&gt; &quot;indices&quot; always in the space of the original string… do I have that<br>&gt;&gt; right? So it would be programmer error to use those ranges in the<br>&gt;&gt; wrong string just like it is with any Range&lt;String.UTF16Index&gt; today.<br>&gt;&gt;<br>&gt;&gt; Zach Waldowski<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 10, 2016, at 06:51 PM, Jordan Rose wrote:<br>&gt;&gt;&gt; By the way, this doesn’t mean it can’t be done, or that we can’t<br>&gt;&gt;&gt; decide on some kind of partial solution! It just means that it needs<br>&gt;&gt;&gt; to be carefully considered and explicitly addressed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We thought about that too. The problem is that it’s not always<br>&gt;&gt;&gt;&gt; obvious what NSString or NSAttributedString the indexes refer to.<br>&gt;&gt;&gt;&gt; For example, most of the NSRegularExpression APIs produce matches<br>&gt;&gt;&gt;&gt; in the form of NSTextCheckingResult, which then doesn’t have a<br>&gt;&gt;&gt;&gt; reference to the original string.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Would it be feasible to annotate those and have them appropriately<br>&gt;&gt;&gt;&gt;&gt; converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge?<br>&gt;&gt;&gt;&gt;&gt; Thinking in particular of TextKit and friends — it&#39;d away with<br>&gt;&gt;&gt;&gt;&gt; quite a lot of the pain of, e.g., not having a native struct-y<br>&gt;&gt;&gt;&gt;&gt; AttributedString.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Cheers!<br>&gt;&gt;&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things<br>&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t get any *worse* there, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; you have already faced the same bridging concerns with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSArray/Array. I’de really like this going forward, but I don’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (start+length vs. start/end), a pointer-to-NSRange has to come<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g.), an NSArray** parameter comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;NSArray&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developement snapshot) and corelibs-foundation and I’ve hit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one major hurdle: passing and converting NSRange and Range<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; around between the different stdlib and Foundation APIs -<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all corelibs-foundation APIs to accept/return Range on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String instead of NSRange? In that case, can’t we get rid of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/e3a9023c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>NSRange and Range</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>I’m not sure we’re going to stick to that in the future. It’s possible we’ll want String to support UTF-8 buffers as well.<br></p><p>Jordan<br></p><p><br>&gt; On May 11, 2016, at 10:15, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; Conceptually, yes, but is that not exactly how it is implemented? https://github.com/apple/swift/blob/master/stdlib/public/core/StringUTF16.swift#L24 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/StringUTF16.swift#L24&gt;<br>&gt;  <br>&gt; Sincerely,<br>&gt;   Zachary Waldowski<br>&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;  <br>&gt;  <br>&gt; On Wed, May 11, 2016, at 01:13 PM, Jordan Rose wrote:<br>&gt;&gt; That’s correct, but how would you make the String.UTF16Index values without the reference String? They’re not (guaranteed to be) integers.<br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On May 10, 2016, at 16:04, Zach Waldowski &lt;zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Right, I 100% get it. :) This is a difficult problem space, and I&#39;m sure you folks are aware that that difficulty is also reflected in how brutal it is to use all of these derivative string-range-based things in Swift right now. In this case, having no answer to this problem is worse than not having the API at all — check Stack Overflow or GitHub for how often a &quot;just paste this in&quot; String.Index.init(_: Int) comes up.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; As far as NSTextCheckingResult goes, its ranges are always in the &quot;indices&quot; always in the space of the original string… do I have that right? So it would be programmer error to use those ranges in the wrong string just like it is with any Range&lt;String.UTF16Index&gt; today.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Zach Waldowski<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Tue, May 10, 2016, at 06:51 PM, Jordan Rose wrote:<br>&gt;&gt;&gt;&gt; By the way, this doesn’t mean it can’t be done, or that we can’t decide on some kind of partial solution! It just means that it needs to be carefully considered and explicitly addressed.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; We thought about that too. The problem is that it’s not always obvious what NSString or NSAttributedString the indexes refer to. For example, most of the NSRegularExpression APIs produce matches in the form of NSTextCheckingResult, which then doesn’t have a reference to the original string.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Would it be feasible to annotate those and have them appropriately converted to Range&lt;String.UTF16Index&gt; upon crossing the bridge? Thinking in particular of TextKit and friends — it&#39;d away with quite a lot of the pain of, e.g., not having a native struct-y AttributedString.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers!<br>&gt;&gt;&gt;&gt;&gt;&gt;   Zachary Waldowski<br>&gt;&gt;&gt;&gt;&gt;&gt;   zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things wouldn’t get any worse there, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes if you have already faced the same bridging concerns with NSArray/Array. I’de really like this going forward, but I don’t know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that (e.g.), an NSArray** parameter comes in as UnsafeMutablePointer&lt;NSArray&gt; rather than UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs to return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest developement snapshot) and corelibs-foundation and I’ve hit one major hurdle: passing and converting NSRange and Range around between the different stdlib and Foundation APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by converting all corelibs-foundation APIs to accept/return Range on String instead of NSRange? In that case, can’t we get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to Range&lt;Int&gt;, although it wouldn’t completely eliminate NSRange because the two types are not representationally identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/736dd97e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>NSRange and Range</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>That makes sense. However, wouldn&#39;t this still be workable in terms<br>of bridging? If UTF16Index had an alternate representation for Swift-<br>side UTF-8 storage, that wouldn&#39;t ever come up for roundtripping<br>across the bridge. The offsets that come back from Foundation would<br>always be &quot;UTF-16 indices how NSString understands it&quot;, which Swift<br>would necessarily understand because it implements -characterAtIndex:<br>for the bridge wrapper.<br> <br>Zach<br> <br>On Wed, May 11, 2016, at 01:19 PM, Jordan Rose wrote:<br>&gt; I’m not sure we’re going to stick to that in the future. It’s possible<br>&gt; we’ll want String to support UTF-8 buffers as well.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On May 11, 2016, at 10:15, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Conceptually, yes, but is that not exactly how it is implemented?<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/StringUTF16.swift#L24<br>&gt;&gt;<br>&gt;&gt; Sincerely,<br>&gt;&gt; Zachary Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, May 11, 2016, at 01:13 PM, Jordan Rose wrote:<br>&gt;&gt;&gt; That’s correct, but how would you *make* the String.UTF16Index<br>&gt;&gt;&gt; values without the reference String? They’re not (guaranteed to be)<br>&gt;&gt;&gt; integers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 10, 2016, at 16:04, Zach Waldowski &lt;zach at waldowski.me&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Right, I 100% get it. :) This is a difficult problem space, and I&#39;m<br>&gt;&gt;&gt;&gt; sure you folks are aware that that difficulty is also reflected in<br>&gt;&gt;&gt;&gt; how brutal it is to use all of these derivative string-range-based<br>&gt;&gt;&gt;&gt; things in Swift right now. In this case, having no answer to this<br>&gt;&gt;&gt;&gt; problem is worse than not having the API at all — check Stack<br>&gt;&gt;&gt;&gt; Overflow or GitHub for how often a &quot;just paste this in&quot;<br>&gt;&gt;&gt;&gt; String.Index.init(_: Int) comes up.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As far as NSTextCheckingResult goes, its ranges are always in the<br>&gt;&gt;&gt;&gt; &quot;indices&quot; always in the space of the original string… do I have<br>&gt;&gt;&gt;&gt; that right? So it would be programmer error to use those ranges in<br>&gt;&gt;&gt;&gt; the wrong string just like it is with any Range&lt;String.UTF16Index&gt;<br>&gt;&gt;&gt;&gt; today.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Zach Waldowski<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, May 10, 2016, at 06:51 PM, Jordan Rose wrote:<br>&gt;&gt;&gt;&gt;&gt; By the way, this doesn’t mean it can’t be done, or that we can’t<br>&gt;&gt;&gt;&gt;&gt; decide on some kind of partial solution! It just means that it<br>&gt;&gt;&gt;&gt;&gt; needs to be carefully considered and explicitly addressed.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 15:49, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; We thought about that too. The problem is that it’s not always<br>&gt;&gt;&gt;&gt;&gt;&gt; obvious what NSString or NSAttributedString the indexes refer to.<br>&gt;&gt;&gt;&gt;&gt;&gt; For example, most of the NSRegularExpression APIs produce matches<br>&gt;&gt;&gt;&gt;&gt;&gt; in the form of NSTextCheckingResult, which then doesn’t have a<br>&gt;&gt;&gt;&gt;&gt;&gt; reference to the original string.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 13:43, Zach Waldowski via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Would it be feasible to annotate those and have them<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; appropriately converted to Range&lt;String.UTF16Index&gt; upon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; crossing the bridge? Thinking in particular of TextKit and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; friends — it&#39;d away with quite a lot of the pain of, e.g., not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; having a native struct-y AttributedString.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Zachary Waldowski<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016, at 12:37 PM, Jordan Rose via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One particular concern we&#39;ve had is that many NSRanges aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;; they’re Range&lt;String.UTF16Index&gt;. I suppose things<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t get any *worse* there, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 00:14, David Hart via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it’s reasonably implementable? I guess the answer is yes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if you have already faced the same bridging concerns with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSArray/Array. I’de really like this going forward, but I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t know how confident I am in writing a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 08:29, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 9, 2016, at 11:23 PM, David Hart &lt;david at hartbit.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why wouldn&#39;t it completely eliminate NSRange?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Because NSRange has a different representation than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt; (start+length vs. start/end), a pointer-to-NSRange<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has to come in as Unsafe(Mutable)Pointer&lt;NSRange&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unsafe(Mutable)Pointer&lt;Range&lt;Int&gt;&gt;. It’s the same reason that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (e.g.), an NSArray** parameter comes in as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;NSArray&gt; rather than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; UnsafeMutablePointer&lt;[AnyObject]&gt;.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Are you thinking of NSNotFound? Could we migrate those APIs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to return an Optional Range&lt;Int&gt;?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you had annotations on the APIs to say that they use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSNotFound as a sentinel, yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 May 2016, at 05:49, Douglas Gregor<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 8, 2016, at 2:10 PM, David Hart via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift-Evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I spent some time coding on Linux with Swift 3 (latest<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; developement snapshot) and corelibs-foundation and I’ve<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; hit one major hurdle: passing and converting NSRange and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range around between the different stdlib and Foundation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; APIs - specifically in regards to String.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is there a plan to simplify those pain points by<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; converting all corelibs-foundation APIs to accept/return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range on String instead of NSRange? In that case, can’t we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; get rid of NSRange completely?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One idea that had come up before was to bridge NSRange to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Range&lt;Int&gt;, although it wouldn’t completely eliminate<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSRange because the two types are not representationally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identical.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/39b05732/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
