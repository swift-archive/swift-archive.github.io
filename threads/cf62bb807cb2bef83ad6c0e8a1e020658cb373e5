<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>[Proposal] Lock file for Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 20, 2015 at 02:00:00pm</p></header><div class="content"><p>Lock File for Swift Package ManagerIntroduction<br></p><p>A Package.lock file containing list of resolved dependencies generated by<br>swiftpm.<br>Motivation<br></p><p>Package.lock file can be helpful in situations like :<br>Reproduce exact versions of dependencies on different machine<br>* Multiple developers working on a package would want to use the exact<br>versions (including minor and patch) of the dependencies declared in the<br>manifest file<br>* Also helpful when a build is being performed on a remote machine eg CI<br>Pointing a dependency to an untagged commit<br>Sometimes it might be helpful to lock a dependency to a particular commit<br>ref for which a tagged version is unavailable in cases such as :<br></p><p>* Forking a 3rd party library and making it swiftpm compatible for<br>temporary use until officially supported by the author<br>* Package is in active development and not ready for a release tag<br>Proposed Solution<br></p><p>swiftpm generates a simple Package.lock file after resolving the dependency<br>graph for that package in some simple format.<br>Detailed Design<br>1. Initial$ swift build resolves the dependency graph and generates a<br>Package.lock file similar to :<br></p><p>ssh://github.com/foo/bar &quot;v1.2.3&quot;http://github.com/foo/baz &quot;v1.0.0&quot;<br>../local/git/repo &quot;v3.4.4&quot;<br></p><p>lock file will only be re-modified by $ swift build if Package.swift is<br>modified by the user.<br>$ swift build always ignores the lock file and uses local state of Packages<br>dir / Package.swift<br></p><p>2. User modifies the cloned packages in Packages dir and when satisfied<br>with the current code of the dependency, commits and pushes it.<br>To lock the current state of Packages user can run  $ swift build --lock which<br>might result something similar to<br></p><p>ssh://github.com/foo/bar<br>&quot;248441ff375a19c4365d00d6b0706e11173074f6&quot;http://github.com/foo/baz<br>&quot;v1.0.0&quot;<br>../local/git/repo &quot;v3.4.4&quot;<br></p><p>the lock file is committed into the package repo for others to use.<br></p><p>3. A command like $ swift build --bootstrap will always use the lock file<br>to fetch and checkout the dependencies.<br>This is useful because running  $ swift build might give a higher patch or<br>minor version of the dependency.<br></p><p>4. If some dependency depends on commit hash (ie non-tagged commit) the<br>author mentions that in their readme and the end user and maybe other<br>parallel dependencies will have to use only that commit hash in order to<br>avoid dependency hell.<br></p><p>5. Allow declaring a dependency without versions in the manifest file for<br>user wanting to use a untagged dependency. This should probably only be<br>allowed in debug configuration.<br>Impact on existing code<br>None as this would be additional functionality to swift package manager<br>Alternatives Considered<br>One alternative is to allow mentioning refs in manifest file while<br>declaring a dependency but as discussed in this<br>&lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt;<br>thread it might not be the best idea.<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/cf6273e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9211cc51e7e6f1221cce0842f653735a?s=50"></div><header><strong>[Proposal] Lock file for Swift Package Manager</strong> from <string>Thomas Guthrie</string> &lt;tomguthrie at gmail.com&gt;<p>December 20, 2015 at 03:00:00pm</p></header><div class="content"><p>Personally, I’d be more in favour of having something similar to Cargo (Rust’s package/crate manager):<br></p><p>1. `swift build`<br></p><p>Almost the same as it is now, expect if there’s no Package.lock it creates one and subsequent builds use the same dependencies.<br></p><p>2. `swift build --update` or maybe eventually `swift update`<br></p><p>Updates the dependencies in Package.lock to their newest versions and writes them to disk. It should probably build the project as well but possibly makes less sense if its `swift update`.<br></p><p>Similar to Bundler and Cargo you’d check in your Package.lock for app projects and ignore it for library projects.<br></p><p>I’m not really sure what their motivation was for having a lock file always created, it definitely favours “app” projects heavily, but I’ve been messing around with Rust recently and it works pretty well honestly. Maybe there’s a way of making the experience better when the package is solely a library? Personally, if you’re developing a library and `swift build` updates a dependency that breaks everything it’s probably better to know then, whereas with an app you probably want to be working to a lock file and checking what happens when you update dependencies individually.<br></p><p>As for the format of Package.lock, I think it might have to be more complicated than shown to be able to handle the possibility of multiple versions of a dependency etc? Haven’t had a chance to mess around with swiftpm enough yet to say though.<br></p><p>(/end ramble of first thoughts)<br></p><p>— Thomas<br></p><p>&gt; On 20 Dec 2015, at 09:01, Ankit Agarwal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Lock File for Swift Package Manager<br>&gt; Introduction<br>&gt; A Package.lock file containing list of resolved dependencies generated by swiftpm.<br>&gt; <br>&gt; Motivation<br>&gt; Package.lock file can be helpful in situations like : <br>&gt; <br>&gt; Reproduce exact versions of dependencies on different machine<br>&gt; <br>&gt; * Multiple developers working on a package would want to use the exact versions (including minor and patch) of the dependencies declared in the manifest file<br>&gt; * Also helpful when a build is being performed on a remote machine eg CI <br>&gt; Pointing a dependency to an untagged commit<br>&gt; <br>&gt; Sometimes it might be helpful to lock a dependency to a particular commit ref for which a tagged version is unavailable in cases such as :<br>&gt; <br>&gt; * Forking a 3rd party library and making it swiftpm compatible for temporary use until officially supported by the author<br>&gt; * Package is in active development and not ready for a release tag<br>&gt; Proposed Solution<br>&gt; swiftpm generates a simple Package.lock file after resolving the dependency graph for that package in some simple format.<br>&gt; <br>&gt; Detailed Design<br>&gt; 1. Initial$ swift build resolves the dependency graph and generates a Package.lock file similar to :<br>&gt; ssh://github.com/foo/bar &lt;http://github.com/foo/bar&gt; &quot;v1.2.3&quot;<br>&gt; http://github.com/foo/baz &lt;http://github.com/foo/baz&gt; &quot;v1.0.0&quot;<br>&gt; ../local/git/repo &quot;v3.4.4&quot;<br>&gt; lock file will only be re-modified by $ swift build if Package.swift is modified by the user.<br>&gt; $ swift build always ignores the lock file and uses local state of Packages dir / Package.swift<br>&gt; <br>&gt; 2. User modifies the cloned packages in Packages dir and when satisfied with the current code of the dependency, commits and pushes it.<br>&gt; To lock the current state of Packages user can run  $ swift build --lock which might result something similar to <br>&gt; ssh://github.com/foo/bar &lt;http://github.com/foo/bar&gt; &quot;248441ff375a19c4365d00d6b0706e11173074f6&quot;<br>&gt; http://github.com/foo/baz &lt;http://github.com/foo/baz&gt; &quot;v1.0.0&quot;<br>&gt; ../local/git/repo &quot;v3.4.4&quot;<br>&gt; the lock file is committed into the package repo for others to use.<br>&gt; <br>&gt; 3. A command like $ swift build --bootstrap will always use the lock file to fetch and checkout the dependencies.<br>&gt; This is useful because running  $ swift build might give a higher patch or minor version of the dependency.<br>&gt; <br>&gt; 4. If some dependency depends on commit hash (ie non-tagged commit) the author mentions that in their readme and the end user and maybe other parallel dependencies will have to use only that commit hash in order to avoid dependency hell.<br>&gt; <br>&gt; 5. Allow declaring a dependency without versions in the manifest file for user wanting to use a untagged dependency. This should probably only be allowed in debug configuration.<br>&gt; Impact on existing code<br>&gt; None as this would be additional functionality to swift package manager<br>&gt; Alternatives Considered<br>&gt; One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt; thread it might not be the best idea.<br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/74344d83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal] Lock file for Swift Package Manager</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 20, 2015 at 03:00:00pm</p></header><div class="content"><p>+1 for Ankit’s general idea. Details of the proposal aside, I’ll say from experience with bundler that it’s immensely useful — a lifesaver! — to know the exact version of the dependencies another author was using. This has saved my neck more than once.<br></p><p>IMO it’s useful to have a lock file checked in even for libraries — just not pushed forward to client projects. You still want to know what versions the library’s tests last passed against, both for CI and for diagnosing downstream breakage.<br></p><p>-1 to this:<br></p><p>&gt; [The] lock file will only be re-modified by $ swift build if Package.swift is modified by the user.<br>&gt; $ swift build always ignores the lock file and uses local state of Packages dir / Package.swift<br>&gt; …<br>&gt; To lock the current state of Packages user can run  $ swift build --lock<br></p><p><br>A couple of problems with that:<br></p><p>(1) Package.swift can specify a version range. You may want to update to the latest patch release without actually modifying Package.swift. I agree with Thomas: there should be a command to update dependencies to the latest matching version. This command should also be able update a single dependency:<br></p><p>	swift build --update SomePackage<br></p><p>(2) I don’t like the idea of the build system running in two separate modes, where sometimes the lock file is ignored and sometimes takes precedence. (If there’s a desire to run in an “unlocked” mode, how about it just doesn&#39;t generate the .lock if not already present, and always uses it if it is present?) In practice, though, I’ve found the bundler model works quite well: always generate .lock if absent, always use the locked version if present, and use a separate command to update the locked version.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>&gt; On Dec 20, 2015, at 9:51 AM, Thomas Guthrie via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Personally, I’d be more in favour of having something similar to Cargo (Rust’s package/crate manager):<br>&gt; <br>&gt; 1. `swift build`<br>&gt; <br>&gt; Almost the same as it is now, expect if there’s no Package.lock it creates one and subsequent builds use the same dependencies.<br>&gt; <br>&gt; 2. `swift build --update` or maybe eventually `swift update`<br>&gt; <br>&gt; Updates the dependencies in Package.lock to their newest versions and writes them to disk. It should probably build the project as well but possibly makes less sense if its `swift update`.<br>&gt; <br>&gt; Similar to Bundler and Cargo you’d check in your Package.lock for app projects and ignore it for library projects.<br>&gt; <br>&gt; I’m not really sure what their motivation was for having a lock file always created, it definitely favours “app” projects heavily, but I’ve been messing around with Rust recently and it works pretty well honestly. Maybe there’s a way of making the experience better when the package is solely a library? Personally, if you’re developing a library and `swift build` updates a dependency that breaks everything it’s probably better to know then, whereas with an app you probably want to be working to a lock file and checking what happens when you update dependencies individually.<br>&gt; <br>&gt; As for the format of Package.lock, I think it might have to be more complicated than shown to be able to handle the possibility of multiple versions of a dependency etc? Haven’t had a chance to mess around with swiftpm enough yet to say though.<br>&gt; <br>&gt; (/end ramble of first thoughts)<br>&gt; <br>&gt; — Thomas<br>&gt; <br>&gt;&gt; On 20 Dec 2015, at 09:01, Ankit Agarwal via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Lock File for Swift Package Manager<br>&gt;&gt; Introduction<br>&gt;&gt; A Package.lock file containing list of resolved dependencies generated by swiftpm.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; Package.lock file can be helpful in situations like : <br>&gt;&gt; <br>&gt;&gt; Reproduce exact versions of dependencies on different machine<br>&gt;&gt; <br>&gt;&gt; * Multiple developers working on a package would want to use the exact versions (including minor and patch) of the dependencies declared in the manifest file<br>&gt;&gt; * Also helpful when a build is being performed on a remote machine eg CI <br>&gt;&gt; Pointing a dependency to an untagged commit<br>&gt;&gt; <br>&gt;&gt; Sometimes it might be helpful to lock a dependency to a particular commit ref for which a tagged version is unavailable in cases such as :<br>&gt;&gt; <br>&gt;&gt; * Forking a 3rd party library and making it swiftpm compatible for temporary use until officially supported by the author<br>&gt;&gt; * Package is in active development and not ready for a release tag<br>&gt;&gt; Proposed Solution<br>&gt;&gt; swiftpm generates a simple Package.lock file after resolving the dependency graph for that package in some simple format.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; 1. Initial$ swift build resolves the dependency graph and generates a Package.lock file similar to :<br>&gt;&gt; ssh://github.com/foo/bar &lt;http://github.com/foo/bar&gt; &quot;v1.2.3&quot;<br>&gt;&gt; http://github.com/foo/baz &lt;http://github.com/foo/baz&gt; &quot;v1.0.0&quot;<br>&gt;&gt; ../local/git/repo &quot;v3.4.4&quot;<br>&gt;&gt; lock file will only be re-modified by $ swift build if Package.swift is modified by the user.<br>&gt;&gt; $ swift build always ignores the lock file and uses local state of Packages dir / Package.swift<br>&gt;&gt; <br>&gt;&gt; 2. User modifies the cloned packages in Packages dir and when satisfied with the current code of the dependency, commits and pushes it.<br>&gt;&gt; To lock the current state of Packages user can run  $ swift build --lock which might result something similar to <br>&gt;&gt; ssh://github.com/foo/bar &lt;http://github.com/foo/bar&gt; &quot;248441ff375a19c4365d00d6b0706e11173074f6&quot;<br>&gt;&gt; http://github.com/foo/baz &lt;http://github.com/foo/baz&gt; &quot;v1.0.0&quot;<br>&gt;&gt; ../local/git/repo &quot;v3.4.4&quot;<br>&gt;&gt; the lock file is committed into the package repo for others to use.<br>&gt;&gt; <br>&gt;&gt; 3. A command like $ swift build --bootstrap will always use the lock file to fetch and checkout the dependencies.<br>&gt;&gt; This is useful because running  $ swift build might give a higher patch or minor version of the dependency.<br>&gt;&gt; <br>&gt;&gt; 4. If some dependency depends on commit hash (ie non-tagged commit) the author mentions that in their readme and the end user and maybe other parallel dependencies will have to use only that commit hash in order to avoid dependency hell.<br>&gt;&gt; <br>&gt;&gt; 5. Allow declaring a dependency without versions in the manifest file for user wanting to use a untagged dependency. This should probably only be allowed in debug configuration.<br>&gt;&gt; Impact on existing code<br>&gt;&gt; None as this would be additional functionality to swift package manager<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; One alternative is to allow mentioning refs in manifest file while declaring a dependency but as discussed in this &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151214/000067.html&gt; thread it might not be the best idea.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Ankit<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/20b8f83a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
