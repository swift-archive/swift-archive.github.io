<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 18, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt; implementations at init time (functions taking in Elements), rather than<br>&gt; relying on Hashable/Comparable protocols?<br>&gt;<br>&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt; creating some sort of wrapper object.<br>&gt;<br>&gt; This particular case would be analogous to using NSHashTable with<br>&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;<br>&gt; Similarly, C++&#39;s unordered_map<br>&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends have<br>&gt; template parameters specifying the hash function and equality comparator,<br>&gt; which use std::hash and == by default.<br></p><p>It might make sense.  How bad is the wrapper solution for user code?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt;&gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt; relying on Hashable/Comparable protocols?<br>&gt;&gt; <br>&gt;&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt;&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt;&gt; creating some sort of wrapper object.<br>&gt;&gt; <br>&gt;&gt; This particular case would be analogous to using NSHashTable with<br>&gt;&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt;&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt;&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;&gt; <br>&gt;&gt; Similarly, C++&#39;s unordered_map<br>&gt;&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt;&gt; and friends have<br>&gt;&gt; template parameters specifying the hash function and equality comparator,<br>&gt;&gt; which use std::hash and == by default.<br>&gt; <br>&gt; It might make sense.  How bad is the wrapper solution for user code?<br></p><p>struct CustomHashableFoo: Hashable {<br>  var value: Foo<br>  func hash() -&gt; Int {<br>    // custom hash function here<br>  }<br>}<br>func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>  // custom == here<br>}<br></p><p>Really not that bad, although you do have to get &#39;value&#39; in and out of the box. It&#39;s also not reusable code—you have to rewrite the box for every type.<br></p><p>I&#39;d say you usually don&#39;t want to allow custom hash/== closures because (a) then you have to store them somewhere, and (b) the compiler won&#39;t usually be able to inline them away. You also end up with a Set&lt;Foo&gt; that doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you can insert equal-but-not-identical elements—which is bad if anyone&#39;s relying on normal Set-like guarantees.<br></p><p>-1 from me until we can put functions in generics, if ever.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/4d64712f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February 18, 2016 at 11:00:00pm</p></header><div class="content"><p>What do you mean by &quot;put functions in generics&quot;?<br></p><p>TJ<br></p><p>On Thu, Feb 18, 2016 at 11:04 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt; implementations at init time (functions taking in Elements), rather than<br>&gt; relying on Hashable/Comparable protocols?<br>&gt;<br>&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt; creating some sort of wrapper object.<br>&gt;<br>&gt; This particular case would be analogous to using NSHashTable with<br>&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;<br>&gt; Similarly, C++&#39;s unordered_map<br>&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends<br>&gt; have<br>&gt; template parameters specifying the hash function and equality comparator,<br>&gt; which use std::hash and == by default.<br>&gt;<br>&gt;<br>&gt; It might make sense.  How bad is the wrapper solution for user code?<br>&gt;<br>&gt;<br>&gt; struct CustomHashableFoo: Hashable {<br>&gt;   var value: Foo<br>&gt;   func hash() -&gt; Int {<br>&gt;     // custom hash function here<br>&gt;   }<br>&gt; }<br>&gt; func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>&gt;   // custom == here<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Really not that bad, although you do have to get &#39;value&#39; in and out of the<br>&gt; box. It&#39;s also not reusable code—you have to rewrite the box for every type.<br>&gt;<br>&gt; I&#39;d say you usually *don&#39;t* want to allow custom hash/== closures because<br>&gt; (a) then you have to store them somewhere, and (b) the compiler won&#39;t<br>&gt; usually be able to inline them away. You also end up with a Set&lt;Foo&gt; that<br>&gt; doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you can insert<br>&gt; equal-but-not-identical elements—which is bad if anyone&#39;s relying on normal<br>&gt; Set-like guarantees.<br>&gt;<br>&gt; -1 from me until we can put functions in generics, if ever.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/075904b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Uh, it wasn&#39;t particularly thought through, but basically some way to tie the type of the Set to the implementations of == and hash. This could be something like C++ non-type template parameters, or a way to provide a custom conformance (&quot;use this implementation of Hashable instead of the one that comes with the type&quot;) a la ML.*<br></p><p>I don&#39;t think either of these are near-term features, or possibly even far-term features. It was mostly just a way to say &quot;this belongs in the type system for both correctness and performance reasons&quot;.<br></p><p>Jordan<br></p><p>* I don&#39;t actually grok &lt;https://en.wiktionary.org/wiki/grok&gt; ML modules yet.<br></p><p><br>&gt; On Feb 18, 2016, at 20:23 , T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; What do you mean by &quot;put functions in generics&quot;?<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Thu, Feb 18, 2016 at 11:04 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt;&gt; parallel versions of the same data structure) that take custom hashValue/==<br>&gt;&gt;&gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt;&gt; relying on Hashable/Comparable protocols?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt;&gt;&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt;&gt;&gt; creating some sort of wrapper object.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This particular case would be analogous to using NSHashTable with<br>&gt;&gt;&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt;&gt;&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt;&gt;&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, C++&#39;s unordered_map<br>&gt;&gt;&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt;&gt; and friends have<br>&gt;&gt;&gt; template parameters specifying the hash function and equality comparator,<br>&gt;&gt;&gt; which use std::hash and == by default.<br>&gt;&gt; <br>&gt;&gt; It might make sense.  How bad is the wrapper solution for user code?<br>&gt; <br>&gt; struct CustomHashableFoo: Hashable {<br>&gt;   var value: Foo<br>&gt;   func hash() -&gt; Int {<br>&gt;     // custom hash function here<br>&gt;   }<br>&gt; }<br>&gt; func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>&gt;   // custom == here<br>&gt; }<br>&gt; <br>&gt; Really not that bad, although you do have to get &#39;value&#39; in and out of the box. It&#39;s also not reusable code—you have to rewrite the box for every type.<br>&gt; <br>&gt; I&#39;d say you usually don&#39;t want to allow custom hash/== closures because (a) then you have to store them somewhere, and (b) the compiler won&#39;t usually be able to inline them away. You also end up with a Set&lt;Foo&gt; that doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you can insert equal-but-not-identical elements—which is bad if anyone&#39;s relying on normal Set-like guarantees.<br>&gt; <br>&gt; -1 from me until we can put functions in generics, if ever.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/7cdab24f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>February 19, 2016 at 12:00:00am</p></header><div class="content"><p>Thank you for the clarification!<br></p><p>On Thu, Feb 18, 2016 at 11:33 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Uh, it wasn&#39;t particularly thought through, but basically some way to tie<br>&gt; the type of the Set to the implementations of == and hash. This could be<br>&gt; something like C++ non-type template parameters, or a way to provide a<br>&gt; custom conformance (&quot;use *this* implementation of Hashable instead of the<br>&gt; one that comes with the type&quot;) a la ML.*<br>&gt;<br>&gt; I don&#39;t think either of these are near-term features, or possibly even<br>&gt; far-term features. It was mostly just a way to say &quot;this belongs in the<br>&gt; type system for both correctness and performance reasons&quot;.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; * I don&#39;t actually grok &lt;https://en.wiktionary.org/wiki/grok&gt; ML modules<br>&gt; yet.<br>&gt;<br>&gt;<br>&gt; On Feb 18, 2016, at 20:23 , T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; What do you mean by &quot;put functions in generics&quot;?<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Thu, Feb 18, 2016 at 11:04 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 18, 2016, at 16:09 , Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Would it make sense for the standard library Set to provide variants (or<br>&gt;&gt; parallel versions of the same data structure) that take custom<br>&gt;&gt; hashValue/==<br>&gt;&gt; implementations at init time (functions taking in Elements), rather than<br>&gt;&gt; relying on Hashable/Comparable protocols?<br>&gt;&gt;<br>&gt;&gt; Use case: I want a set of objects that are compared for equality using ===<br>&gt;&gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt;&gt; creating some sort of wrapper object.<br>&gt;&gt;<br>&gt;&gt; This particular case would be analogous to using NSHashTable with<br>&gt;&gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is a<br>&gt;&gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt;&gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt;&gt;<br>&gt;&gt; Similarly, C++&#39;s unordered_map<br>&gt;&gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends<br>&gt;&gt; have<br>&gt;&gt; template parameters specifying the hash function and equality comparator,<br>&gt;&gt; which use std::hash and == by default.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It might make sense.  How bad is the wrapper solution for user code?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; struct CustomHashableFoo: Hashable {<br>&gt;&gt;   var value: Foo<br>&gt;&gt;   func hash() -&gt; Int {<br>&gt;&gt;     // custom hash function here<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; func ==(a: CustomHashableWrapped, b: CustomHashableWrapped) {<br>&gt;&gt;   // custom == here<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Really not that bad, although you do have to get &#39;value&#39; in and out of<br>&gt;&gt; the box. It&#39;s also not reusable code—you have to rewrite the box for every<br>&gt;&gt; type.<br>&gt;&gt;<br>&gt;&gt; I&#39;d say you usually *don&#39;t* want to allow custom hash/== closures<br>&gt;&gt; because (a) then you have to store them somewhere, and (b) the compiler<br>&gt;&gt; won&#39;t usually be able to inline them away. You also end up with a Set&lt;Foo&gt;<br>&gt;&gt; that doesn&#39;t behave like a normal Set&lt;Foo&gt;—maybe you can insert<br>&gt;&gt; equal-but-not-identical elements—which is bad if anyone&#39;s relying on normal<br>&gt;&gt; Set-like guarantees.<br>&gt;&gt;<br>&gt;&gt; -1 from me until we can put functions in generics, if ever.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/78b4ae41/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 19, 2016 at 07:00:00pm</p></header><div class="content"><p>*Wrapper Solution?*<br></p><p>I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>unique type per sort, or a block stored per element (unstable).<br></p><p>Similar overheads were discussed when an index needs to store a reference<br>to the parent. There&#39;s some work to fix it that makes indices moveable, so<br>instead of going index.successor() you use collection.next(index).<br></p><p>https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br></p><p>*Potential solution:*<br></p><p>The collection interfaces could change like this:<br></p><p>- struct Set&lt;Element: Hashable&gt; {<br>- struct Set&lt;Element&gt; {<br>    ...<br>-   public init() { ... }<br>+   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>      ...<br>    }<br>-   public init(minimumCapacity: Int) { ... }<br>+   public init&lt;H: Hashable&gt;(minimumCapacity: Int, elementHasher: Element<br>-&gt; H) {<br>      ...<br>    }<br>    ... (same for other public initialisers)<br>  }<br></p><p>Then the Hashable specific initialisers added back like this:<br></p><p>+ extension Set where Element: Hashable {<br>+   public init() { ... }<br>+   public init(minimumCapacity: Int) { ... }<br>+ }<br></p><p>*Potential Implementation*<br></p><p>I&#39;ve had a quick look at `HashedCollections.swift.gyb`, there&#39;s currently<br>two underlying implementations ObjC and Swift Native, it may be possible to<br>specialise (gyb) this Native implementation into two implementations<br>(HashableNative, ClosureNative).<br></p><p>The specialisation is probably just a one liner in `_bucket()` and<br>`hashValue` to use a different method to get the hash.<br></p><p>I don&#39;t think this would break any code, except new initialisers that may<br>need `where Hashable` added. I think it will provide the desired<br>functionality.<br></p><p>It may even be a fairly straightforward implementation (famous last words),<br>although I haven&#39;t got time to do much more at the moment.<br></p><p>On Friday, 19 February 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Feb 18 2016, Jacob Bandes-Storch &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Would it make sense for the standard library Set to provide variants (or<br>&gt; &gt; parallel versions of the same data structure) that take custom<br>&gt; hashValue/==<br>&gt; &gt; implementations at init time (functions taking in Elements), rather than<br>&gt; &gt; relying on Hashable/Comparable protocols?<br>&gt; &gt;<br>&gt; &gt; Use case: I want a set of objects that are compared for equality using<br>&gt; ===<br>&gt; &gt; rather than ==. This doesn&#39;t seem possible today, using Set, without<br>&gt; &gt; creating some sort of wrapper object.<br>&gt; &gt;<br>&gt; &gt; This particular case would be analogous to using NSHashTable with<br>&gt; &gt; NSPointerFunctionsObjectPointerPersonality. (Maybe all I&#39;m asking for is<br>&gt; a<br>&gt; &gt; Swiftier API for NSHashTable — including ArrayLiteralConvertible, using<br>&gt; &gt; generics instead of UnsafePointer&lt;Void&gt;, etc.)<br>&gt; &gt;<br>&gt; &gt; Similarly, C++&#39;s unordered_map<br>&gt; &gt; &lt;http://en.cppreference.com/w/cpp/container/unordered_map&gt; and friends<br>&gt; have<br>&gt; &gt; template parameters specifying the hash function and equality comparator,<br>&gt; &gt; which use std::hash and == by default.<br>&gt;<br>&gt; It might make sense.  How bad is the wrapper solution for user code?<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/aea5877c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>February 19, 2016 at 02:00:00am</p></header><div class="content"><p>On Fri, Feb 19, 2016 at 2:06 AM, Andrew Bennett via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Wrapper Solution?<br>&gt;<br>&gt; I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>&gt; unique type per sort, or a block stored per element (unstable).<br>&gt;<br>&gt; Similar overheads were discussed when an index needs to store a reference to<br>&gt; the parent. There&#39;s some work to fix it that makes indices moveable, so<br>&gt; instead of going index.successor() you use collection.next(index).<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br>&gt;<br>&gt; Potential solution:<br>&gt;<br>&gt; The collection interfaces could change like this:<br>&gt;<br>&gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt; - struct Set&lt;Element&gt; {<br>&gt;     ...<br>&gt; -   public init() { ... }<br>&gt; +   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>&gt;       ...<br>&gt;     }<br></p><p>How do you compare such sets?  That is, what does s1 == s2 mean, if<br>the two sets are constructed with a hashing closure?  We can&#39;t even<br>compare closures to find that they are the same.<br></p><p>Also, how would this affect algorithms on sets?  When handling a set,<br>you essentially wouldn&#39;t know the rules according to which it<br>operates, unless we expose this mapping function.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 19, 2016 at 07:00:00pm</p></header><div class="content"><p>Good points Dimitri,<br></p><p>I only wrote this quickly, so please look for other issues too, I don&#39;t<br>expect it to be complete by any means.<br></p><p>I think a way to get an element&#39;s hashValue should probably be exposed,<br>similar to `collection.next(index)` that I mentioned earlier. I think this<br>is useful, but I don&#39;t think it&#39;s actually necessary. Equatable is<br>sufficient to provide Set functionality, Hashable is just for performance<br></p><p>I&#39;m not aware of any algorithms that can&#39;t be built on top of the existing<br>set methods that would require the same hash value the element used for<br>binning.<br></p><p>I was initially thinking that you could compare the Hashable to determine<br>equality, but I agree that there is a potential for the closure to convert<br>to a narrower type.<br></p><p>A much stronger solution would change the interface slightly to require<br>Element to be `Equatable`, and provide `Element -&gt; Int` as the closure.<br>It&#39;s slightly less flexibly, but I do agree that a narrowing makes<br>Equatability of s1 == s2 ambiguous.<br></p><p>*In summary*:<br></p><p>- struct Set&lt;Element: Hashable&gt; {<br>- struct Set&lt;Element: Equatable&gt; {<br>    ...<br>-   public init() { ... }<br>+   public init(hashValueForElement: Element -&gt; Int) {<br>      ...<br>    }<br>-   public init(minimumCapacity: Int) { ... }<br>+   public init&lt;H: Hashable&gt;(minimumCapacity: Int, hashValueForElement:<br>Element -&gt; Int) {<br>      ...<br>    }<br>    ... (same for other public initialisers)<br>+   public func hashValueForElement(element: Element) -&gt; Int { ... }<br>  }<br></p><p>+ extension Set where Element: Hashable {<br>+   public init() { ... }<br>+   public init(minimumCapacity: Int) { ... }<br>+ }<br></p><p>-<br>Andrew Bennett<br></p><p><br>On Fri, Feb 19, 2016 at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Fri, Feb 19, 2016 at 2:06 AM, Andrew Bennett via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Wrapper Solution?<br>&gt; &gt;<br>&gt; &gt; I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>&gt; &gt; unique type per sort, or a block stored per element (unstable).<br>&gt; &gt;<br>&gt; &gt; Similar overheads were discussed when an index needs to store a<br>&gt; reference to<br>&gt; &gt; the parent. There&#39;s some work to fix it that makes indices moveable, so<br>&gt; &gt; instead of going index.successor() you use collection.next(index).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br>&gt; &gt;<br>&gt; &gt; Potential solution:<br>&gt; &gt;<br>&gt; &gt; The collection interfaces could change like this:<br>&gt; &gt;<br>&gt; &gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt; &gt; - struct Set&lt;Element&gt; {<br>&gt; &gt;     ...<br>&gt; &gt; -   public init() { ... }<br>&gt; &gt; +   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>&gt; &gt;       ...<br>&gt; &gt;     }<br>&gt;<br>&gt; How do you compare such sets?  That is, what does s1 == s2 mean, if<br>&gt; the two sets are constructed with a hashing closure?  We can&#39;t even<br>&gt; compare closures to find that they are the same.<br>&gt;<br>&gt; Also, how would this affect algorithms on sets?  When handling a set,<br>&gt; you essentially wouldn&#39;t know the rules according to which it<br>&gt; operates, unless we expose this mapping function.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/6a2fc7f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 19, 2016 at 02:00:00pm</p></header><div class="content"><p>Discussions on different index handling should belong to another thread if there isn&#39;t one already.<br></p><p>Your proposed Set change covers at least the custom Hashable behavior.<br>What about Equatable? I think it could be expressed as behaviors.<br></p><p>- Maximilian<br></p><p>&gt; Am 19.02.2016 um 11:58 schrieb Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Good points Dimitri,<br>&gt; <br>&gt; I only wrote this quickly, so please look for other issues too, I don&#39;t expect it to be complete by any means.<br>&gt; <br>&gt; I think a way to get an element&#39;s hashValue should probably be exposed, similar to `collection.next(index)` that I mentioned earlier. I think this is useful, but I don&#39;t think it&#39;s actually necessary. Equatable is sufficient to provide Set functionality, Hashable is just for performance<br>&gt; <br>&gt; I&#39;m not aware of any algorithms that can&#39;t be built on top of the existing set methods that would require the same hash value the element used for binning.<br>&gt; <br>&gt; I was initially thinking that you could compare the Hashable to determine equality, but I agree that there is a potential for the closure to convert to a narrower type.<br>&gt; <br>&gt; A much stronger solution would change the interface slightly to require Element to be `Equatable`, and provide `Element -&gt; Int` as the closure. It&#39;s slightly less flexibly, but I do agree that a narrowing makes Equatability of s1 == s2 ambiguous.<br>&gt; <br>&gt; In summary:<br>&gt; <br>&gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt; - struct Set&lt;Element: Equatable&gt; {<br>&gt;     ...<br>&gt; -   public init() { ... }<br>&gt; +   public init(hashValueForElement: Element -&gt; Int) {<br>&gt;       ... <br>&gt;     }<br>&gt; -   public init(minimumCapacity: Int) { ... }<br>&gt; +   public init&lt;H: Hashable&gt;(minimumCapacity: Int, hashValueForElement: Element -&gt; Int) {<br>&gt;       ... <br>&gt;     }<br>&gt;     ... (same for other public initialisers)<br>&gt; +   public func hashValueForElement(element: Element) -&gt; Int { ... }<br>&gt;   }<br>&gt; <br>&gt; + extension Set where Element: Hashable {<br>&gt; +   public init() { ... }<br>&gt; +   public init(minimumCapacity: Int) { ... }<br>&gt; + }<br>&gt; <br>&gt; -<br>&gt; Andrew Bennett<br>&gt; <br>&gt; <br>&gt;&gt; On Fri, Feb 19, 2016 at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:06 AM, Andrew Bennett via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Wrapper Solution?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>&gt;&gt; &gt; unique type per sort, or a block stored per element (unstable).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Similar overheads were discussed when an index needs to store a reference to<br>&gt;&gt; &gt; the parent. There&#39;s some work to fix it that makes indices moveable, so<br>&gt;&gt; &gt; instead of going index.successor() you use collection.next(index).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Potential solution:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The collection interfaces could change like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt;&gt; &gt; - struct Set&lt;Element&gt; {<br>&gt;&gt; &gt;     ...<br>&gt;&gt; &gt; -   public init() { ... }<br>&gt;&gt; &gt; +   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>&gt;&gt; &gt;       ...<br>&gt;&gt; &gt;     }<br>&gt;&gt; <br>&gt;&gt; How do you compare such sets?  That is, what does s1 == s2 mean, if<br>&gt;&gt; the two sets are constructed with a hashing closure?  We can&#39;t even<br>&gt;&gt; compare closures to find that they are the same.<br>&gt;&gt; <br>&gt;&gt; Also, how would this affect algorithms on sets?  When handling a set,<br>&gt;&gt; you essentially wouldn&#39;t know the rules according to which it<br>&gt;&gt; operates, unless we expose this mapping function.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/3796cb02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Maximillian,<br></p><p>On Friday, 19 February 2016, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;<br>wrote:<br></p><p>&gt; Discussions on different index handling should belong to another thread if<br>&gt; there isn&#39;t one already.<br>&gt;<br>I mentioned indices only to provide context :) the linked document (Swift<br>master) discusses an approach that fixes many of the issues with a custom<br>wrapper approaches mentioned here.<br></p><p><br>&gt; Your proposed Set change covers at least the custom Hashable behavior.<br>&gt; What about Equatable? I think it could be expressed as behaviors.<br>&gt;<br></p><p>Custom Equatable could also be implemented as a similar closure<br>(Element,Element)-&gt;Bool. I left it off, but I probably shouldn&#39;t have. My<br>main goal was to minimise changes to the existing interfaces and provide<br>similar performance.<br></p><p>I wonder if there&#39;s any cases someone would want anything other<br>than Equatable or pointer comparison.<br></p><p>As for your behaviour suggestion: I may be misinterpreting how it works. I<br>like the idea, but it seems like a much larger change than is necessary. It<br>may change all the type signatures in normal usage, and obsfucate the<br>Element type.<br></p><p>Ideally the sets type would only show the element type, not implementation<br>details like a custom hash algorithm.<br></p><p>If you&#39;re happy to change the Set&#39;s type signature for each hash/equality<br>algorithm then a wrapper like Nicola suggests is probably good enough.<br></p><p>Even easier if you&#39;re happy to manually wrap and unwrap:<br></p><p>class HashableReference&lt;T: AnyObject&gt;: Hashable {<br>    let object: T<br>    var hashValue: Int {<br>        return ObjectIdentifier(object).hashValue<br>    }<br>}<br>func ==&lt;T: AnyObject&gt;(lhs: HashableReference&lt;T&gt;, rhs: HashableReference&lt;T&gt;)<br>-&gt; Bool {<br>    return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>}<br></p><p>Apologies for any errors, this was done from my iPhone from memory.<br></p><p><br>&gt; - Maximilian<br>&gt;<br>&gt; Am 19.02.2016 um 11:58 schrieb Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Good points Dimitri,<br>&gt;<br>&gt; I only wrote this quickly, so please look for other issues too, I don&#39;t<br>&gt; expect it to be complete by any means.<br>&gt;<br>&gt; I think a way to get an element&#39;s hashValue should probably be exposed,<br>&gt; similar to `collection.next(index)` that I mentioned earlier. I think<br>&gt; this is useful, but I don&#39;t think it&#39;s actually necessary. Equatable is<br>&gt; sufficient to provide Set functionality, Hashable is just for performance<br>&gt;<br>&gt; I&#39;m not aware of any algorithms that can&#39;t be built on top of the existing<br>&gt; set methods that would require the same hash value the element used for<br>&gt; binning.<br>&gt;<br>&gt; I was initially thinking that you could compare the Hashable to determine<br>&gt; equality, but I agree that there is a potential for the closure to convert<br>&gt; to a narrower type.<br>&gt;<br>&gt; A much stronger solution would change the interface slightly to require<br>&gt; Element to be `Equatable`, and provide `Element -&gt; Int` as the closure.<br>&gt; It&#39;s slightly less flexibly, but I do agree that a narrowing makes<br>&gt; Equatability of s1 == s2 ambiguous.<br>&gt;<br>&gt; *In summary*:<br>&gt;<br>&gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt; - struct Set&lt;Element: Equatable&gt; {<br>&gt;     ...<br>&gt; -   public init() { ... }<br>&gt; +   public init(hashValueForElement: Element -&gt; Int) {<br>&gt;       ...<br>&gt;     }<br>&gt; -   public init(minimumCapacity: Int) { ... }<br>&gt; +   public init&lt;H: Hashable&gt;(minimumCapacity: Int, hashValueForElement:<br>&gt; Element -&gt; Int) {<br>&gt;       ...<br>&gt;     }<br>&gt;     ... (same for other public initialisers)<br>&gt; +   public func hashValueForElement(element: Element) -&gt; Int { ... }<br>&gt;   }<br>&gt;<br>&gt; + extension Set where Element: Hashable {<br>&gt; +   public init() { ... }<br>&gt; +   public init(minimumCapacity: Int) { ... }<br>&gt; + }<br>&gt;<br>&gt; -<br>&gt; Andrew Bennett<br>&gt;<br>&gt;<br>&gt; On Fri, Feb 19, 2016 at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:06 AM, Andrew Bennett via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; Wrapper Solution?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>&gt;&gt; &gt; unique type per sort, or a block stored per element (unstable).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Similar overheads were discussed when an index needs to store a<br>&gt;&gt; reference to<br>&gt;&gt; &gt; the parent. There&#39;s some work to fix it that makes indices moveable, so<br>&gt;&gt; &gt; instead of going index.successor() you use collection.next(index).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Potential solution:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The collection interfaces could change like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt;&gt; &gt; - struct Set&lt;Element&gt; {<br>&gt;&gt; &gt;     ...<br>&gt;&gt; &gt; -   public init() { ... }<br>&gt;&gt; &gt; +   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>&gt;&gt; &gt;       ...<br>&gt;&gt; &gt;     }<br>&gt;&gt;<br>&gt;&gt; How do you compare such sets?  That is, what does s1 == s2 mean, if<br>&gt;&gt; the two sets are constructed with a hashing closure?  We can&#39;t even<br>&gt;&gt; compare closures to find that they are the same.<br>&gt;&gt;<br>&gt;&gt; Also, how would this affect algorithms on sets?  When handling a set,<br>&gt;&gt; you essentially wouldn&#39;t know the rules according to which it<br>&gt;&gt; operates, unless we expose this mapping function.<br>&gt;&gt;<br>&gt;&gt; Dmitri<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/ad775b89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Custom equality/hash for Sets</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 19.02.2016 um 15:47 schrieb Andrew Bennett &lt;cacoyi at gmail.com&gt;:<br>&gt; <br>&gt; Hi Maximillian,<br>&gt; <br>&gt; On Friday, 19 February 2016, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;&gt;&gt; wrote:<br>&gt; Discussions on different index handling should belong to another thread if there isn&#39;t one already.<br>&gt; I mentioned indices only to provide context :) the linked document (Swift master) discusses an approach that fixes many of the issues with a custom wrapper approaches mentioned here.<br>&gt; <br></p><p>Is there already a thread on swift-evolution which discusses these index changes?<br></p><p>&gt; <br>&gt; Your proposed Set change covers at least the custom Hashable behavior.<br>&gt; What about Equatable? I think it could be expressed as behaviors.<br>&gt;  <br>&gt; Custom Equatable could also be implemented as a similar closure (Element,Element)-&gt;Bool. I left it off, but I probably shouldn&#39;t have. My main goal was to minimise changes to the existing interfaces and provide similar performance.<br>&gt; <br>&gt; I wonder if there&#39;s any cases someone would want anything other than Equatable or pointer comparison.<br>&gt; <br>&gt; As for your behaviour suggestion: I may be misinterpreting how it works. I like the idea, but it seems like a much larger change than is necessary. It may change all the type signatures in normal usage, and obsfucate the Element type.<br>&gt; <br>&gt; Ideally the sets type would only show the element type, not implementation details like a custom hash algorithm.<br>&gt; <br></p><p>I thought about &quot;Property behaviors&quot; (separate thread) where such an addition could be difficult to implement.<br></p><p>But if they are implemented we can then generalize them to a transparent wrapper type.<br></p><p>Pseudo implementation:<br></p><p>	var behavior pointerHashable&lt;Value: AnyObject&gt;: Value {}<br>	extension pointerHashable: Hashable {<br>		var hashValue: Int { return ObjectIdentifier(self).hashValue }<br>	}<br>	func ==&lt;T&gt;(lhs: pointerHashable&lt;T&gt;, rhs: pointerHashable&lt;T&gt;) -&gt; Bool {<br>		return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>	}<br></p><p>	//usage<br>	var set: Set&lt;pointerHashable&lt;MyClass&gt;&gt; = [MyClass(), MyClass()]<br>	let firstElement = set.first! // returns MyClass<br></p><p>&gt; If you&#39;re happy to change the Set&#39;s type signature for each hash/equality algorithm then a wrapper like Nicola suggests is probably good enough.<br>&gt; <br>&gt; Even easier if you&#39;re happy to manually wrap and unwrap:<br>&gt; <br></p><p>a behavior would implicitly wrap/unwrap<br></p><p>&gt; class HashableReference&lt;T: AnyObject&gt;: Hashable {<br>&gt;     let object: T<br>&gt;     var hashValue: Int {<br>&gt;         return ObjectIdentifier(object).hashValue<br>&gt;     }<br>&gt; }<br>&gt; func ==&lt;T: AnyObject&gt;(lhs: HashableReference&lt;T&gt;, rhs: HashableReference&lt;T&gt;) -&gt; Bool {<br>&gt;     return ObjectIdentifier(lhs) == ObjectIdentifier(rhs)<br>&gt; }<br>&gt; <br>&gt; Apologies for any errors, this was done from my iPhone from memory.<br></p><p>However if the behavior cannot be implemented easily this approach would be the best.<br></p><p>- Maximilian<br></p><p>&gt; <br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 19.02.2016 um 11:58 schrieb Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;&gt;&gt;:<br>&gt; <br>&gt;&gt; Good points Dimitri,<br>&gt;&gt; <br>&gt;&gt; I only wrote this quickly, so please look for other issues too, I don&#39;t expect it to be complete by any means.<br>&gt;&gt; <br>&gt;&gt; I think a way to get an element&#39;s hashValue should probably be exposed, similar to `collection.next(index)` that I mentioned earlier. I think this is useful, but I don&#39;t think it&#39;s actually necessary. Equatable is sufficient to provide Set functionality, Hashable is just for performance<br>&gt;&gt; <br>&gt;&gt; I&#39;m not aware of any algorithms that can&#39;t be built on top of the existing set methods that would require the same hash value the element used for binning.<br>&gt;&gt; <br>&gt;&gt; I was initially thinking that you could compare the Hashable to determine equality, but I agree that there is a potential for the closure to convert to a narrower type.<br>&gt;&gt; <br>&gt;&gt; A much stronger solution would change the interface slightly to require Element to be `Equatable`, and provide `Element -&gt; Int` as the closure. It&#39;s slightly less flexibly, but I do agree that a narrowing makes Equatability of s1 == s2 ambiguous.<br>&gt;&gt; <br>&gt;&gt; In summary:<br>&gt;&gt; <br>&gt;&gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt;&gt; - struct Set&lt;Element: Equatable&gt; {<br>&gt;&gt;     ...<br>&gt;&gt; -   public init() { ... }<br>&gt;&gt; +   public init(hashValueForElement: Element -&gt; Int) {<br>&gt;&gt;       ... <br>&gt;&gt;     }<br>&gt;&gt; -   public init(minimumCapacity: Int) { ... }<br>&gt;&gt; +   public init&lt;H: Hashable&gt;(minimumCapacity: Int, hashValueForElement: Element -&gt; Int) {<br>&gt;&gt;       ... <br>&gt;&gt;     }<br>&gt;&gt;     ... (same for other public initialisers)<br>&gt;&gt; +   public func hashValueForElement(element: Element) -&gt; Int { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; + extension Set where Element: Hashable {<br>&gt;&gt; +   public init() { ... }<br>&gt;&gt; +   public init(minimumCapacity: Int) { ... }<br>&gt;&gt; + }<br>&gt;&gt; <br>&gt;&gt; -<br>&gt;&gt; Andrew Bennett<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Feb 19, 2016 at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;&gt;&gt; wrote:<br>&gt;&gt; On Fri, Feb 19, 2016 at 2:06 AM, Andrew Bennett via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;&gt;&gt; wrote:<br>&gt;&gt; &gt; Wrapper Solution?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve had a go at a wrapper solution before and it seems to either need a<br>&gt;&gt; &gt; unique type per sort, or a block stored per element (unstable).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Similar overheads were discussed when an index needs to store a reference to<br>&gt;&gt; &gt; the parent. There&#39;s some work to fix it that makes indices moveable, so<br>&gt;&gt; &gt; instead of going index.successor() you use collection.next(index).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift &lt;https://github.com/apple/swift/blob/master/test/Prototypes/CollectionsMoveIndices.swift&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Potential solution:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The collection interfaces could change like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - struct Set&lt;Element: Hashable&gt; {<br>&gt;&gt; &gt; - struct Set&lt;Element&gt; {<br>&gt;&gt; &gt;     ...<br>&gt;&gt; &gt; -   public init() { ... }<br>&gt;&gt; &gt; +   public init&lt;H: Hashable&gt;(elementHasher: Element -&gt; H) {<br>&gt;&gt; &gt;       ...<br>&gt;&gt; &gt;     }<br>&gt;&gt; <br>&gt;&gt; How do you compare such sets?  That is, what does s1 == s2 mean, if<br>&gt;&gt; the two sets are constructed with a hashing closure?  We can&#39;t even<br>&gt;&gt; compare closures to find that they are the same.<br>&gt;&gt; <br>&gt;&gt; Also, how would this affect algorithms on sets?  When handling a set,<br>&gt;&gt; you essentially wouldn&#39;t know the rules according to which it<br>&gt;&gt; operates, unless we expose this mapping function.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;&gt;&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/ca1d523b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
