<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>March 16, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with the proposal of ‘inherited’ &amp; ‘declaration’ modifiers.<br></p><p>Current access modifiers actually guarantee access. Limiting access using scope means another file/module can just add a property/function to make the value public. Confusing type-based and file-based access is a step backwards, and any attempt to add type-based access shouldn&#39;t be a breaking change.<br></p><p>Replacing internal with private(module) also seems like a step backwards, to me, and in my opinion changes to the ‘internal’ keyword should be part of a separate proposal.<br></p><p>Inherited &amp; declaration modifiers compose well with existing access-modifiers, are clear in their purpose, can be applied to all access levels, and don&#39;t break existing code.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;CAPUwzK7YHzwDMTMuH1Qvbojz3+9+ikgJvna3xDhscESVO8YSNQ at mail.gmail.com&gt; <br></p><p>It&#39;s occurring to me, reading these recent posts, that we have two<br>orthogonal systems of access levels.<br></p><p>Swift&#39;s current access system is file based; a project file decides which<br>files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>determine whether a property is accessible to all, accessible only within<br>files of the module, or accessible only within a file. (This takes on an<br>extra dimension as files may belong to several modules).<br></p><p>The concept which began this discussion, and several of the proposed<br>concepts in this discussion, ask instead for a type-based access system<br>similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>to a type or subtypes.<br></p><p>I think it would be confusing if Swift applied &#39;public&#39; to a concept in the<br>file-based access system and &#39;private&#39; to a concept in the type-based<br>access system.<br></p><p>I would prefer clearer terms which actually mention the restrictions of the<br>level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties<br>accessible by a class and its subclasses; &#39;declaration&#39;, rather than<br>&#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>given type or extension declaration.<br></p><p>Since, at the moment, a declaration can only occur within one file, I think<br>this most-restricted level has managed to pass as a level of the file-based<br>access system. However, if the system is ever extended, we&#39;re going to run<br>into new syntax decisions where we have &#39;private module&#39; functions<br>(accessible only within the given type in the same module) trying to<br>communicate with &#39;protected file&#39; properties (accessible only with the type<br>and its subtypes in the same file), and that might lead to conflicts, so<br>perhaps we should decide how those might be declared now.<br></p><p>On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt;On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;<br>&gt;And again, moving the access control modification to the end just doesn&#39;t look<br>&gt;right to me or seem to enhance readability. :(<br>&gt;<br>&gt;I like Shawn’s proposal better for cases where there are custom<br>&gt;getter/setter implementations.  We should definitely be able to do:<br>&gt;<br>&gt;var foo:Int {<br>&gt;public get {…}<br>&gt;private(file) set {…}<br>&gt;}<br>&gt;<br>&gt;In fact, that is what I first tried to do before learning about<br>&gt;private(set).  But without the implementations, it just seems strange to<br>&gt;put the scoping after the rest of the declaration (they work above because<br>&gt;they are *before* the custom getter/setter).<br>&gt;<br>&gt;I still like the idea of having the option to use parameter-like syntax<br>&gt;for cases where you don’t have custom getters/setters:<br>&gt;<br>&gt;private var foo:Int<br>&gt;private(file) var foo:Int<br>&gt;private(set: file) var foo:Int<br>&gt;private(get: global, set: file) var foo:Int<br>&gt;<br>&gt;<br>&gt;I guess, if we had some way to represent the standard getter/setter, that<br>&gt;might work too.  I don’t love it, but maybe with better wording?<br>&gt;<br>&gt;var foo:Int{<br>&gt;public get useDefault<br>&gt;private(file) set {…}<br>&gt;}<br>&gt;<br>&gt;Thanks,<br>&gt;Jon<br>&gt;<br>&gt;<br>&gt;On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;<br>&gt;I like Shawn&#39;s proposal:<br>&gt;<br>&gt;<br>&gt;<br>&gt;var foo: Int { private(file) set }<br>&gt;<br>&gt;<br>&gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;<br>&gt;<br>&gt;For example, we already use<br>&gt;<br>&gt;var foo: Int { mutating get { ... } }<br>&gt;<br>&gt;and not<br>&gt;<br>&gt;mutating(get) var foo: Int { get { ... } }<br>&gt;<br>&gt;On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;<br>&gt;&gt;I like Shawn&#39;s proposal:<br>&gt;&gt;<br>&gt;&gt;var foo: Int { private(file) set }<br>&gt;&gt;<br>&gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;While I like private(get: file, set: module) idea, I think it just gets<br>&gt;&gt;too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt;<br>&gt;&gt;On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;*On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt;&gt;for setter access level, e.g. the current private(set). Options:<br>&gt;&gt;&gt;- Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt;&gt;private(set).<br>&gt;&gt;&gt;- Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt;&gt;set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt;&gt;- Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt;&gt;the other unification efforts going on to make everything look like<br>&gt;&gt;&gt;function calls.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;What about the following 3 forms?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;private(file) //both setter and getter have file scope<br>&gt;&gt;&gt;private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt;&gt;“private(set)&quot;<br>&gt;&gt;&gt;private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt;&gt;file scope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt;&gt;last form: private(get: public, set: module)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;Thanks,<br>&gt;&gt;&gt;Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;_______________________________________________<br>&gt;&gt;&gt;swift-evolution mailing list<br>&gt;&gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;_______________________________________________<br>&gt;swift-evolution mailing list<br>&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 16, 2016 at 11:00:00am</p></header><div class="content"><p>Type based access would be confusing, which is why the proposal was for<br>scoped based access. This means that something is visible only in the scope<br>in which it is defined and is completely sealed from outside of the scope.<br>This way you have to modify the scope to make something more visible, so<br>you can&#39;t just add another extension to make something more visible.<br></p><p>&gt; Limiting access using scope means another file/module can just add a<br>property/function to make the value public. Confusing type-based and<br>file-based access is a step backwards, and any attempt to add type-based<br>access shouldn&#39;t be a breaking change.<br></p><p>On Wed, Mar 16, 2016 at 6:52 AM James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with the proposal of ‘inherited’ &amp; ‘declaration’ modifiers.<br>&gt;<br>&gt; Current access modifiers actually guarantee access. Limiting access using<br>&gt; scope means another file/module can just add a property/function to make<br>&gt; the value public. Confusing type-based and file-based access is a step<br>&gt; backwards, and any attempt to add type-based access shouldn&#39;t be a breaking<br>&gt; change.<br>&gt;<br>&gt; Replacing internal with private(module) also seems like a step backwards,<br>&gt; to me, and in my opinion changes to the ‘internal’ keyword should be part<br>&gt; of a separate proposal.<br>&gt;<br>&gt; Inherited &amp; declaration modifiers compose well with existing<br>&gt; access-modifiers, are clear in their purpose, can be applied to all access<br>&gt; levels, and don&#39;t break existing code.<br>&gt;<br>&gt; ------------ Begin Message ------------<br>&gt; Group: gmane.comp.lang.swift.evolution<br>&gt; MsgID: &lt;CAPUwzK7YHzwDMTMuH1Qvbojz3+9+ikgJvna3xDhscESVO8YSNQ at mail.gmail.com<br>&gt; &gt;<br>&gt;<br>&gt; It&#39;s occurring to me, reading these recent posts, that we have two<br>&gt; orthogonal systems of access levels.<br>&gt;<br>&gt; Swift&#39;s current access system is file based; a project file decides which<br>&gt; files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>&gt; determine whether a property is accessible to all, accessible only within<br>&gt; files of the module, or accessible only within a file. (This takes on an<br>&gt; extra dimension as files may belong to several modules).<br>&gt;<br>&gt; The concept which began this discussion, and several of the proposed<br>&gt; concepts in this discussion, ask instead for a type-based access system<br>&gt; similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&gt; &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>&gt; to a type or subtypes.<br>&gt;<br>&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the<br>&gt; file-based access system and &#39;private&#39; to a concept in the type-based<br>&gt; access system.<br>&gt;<br>&gt; I would prefer clearer terms which actually mention the restrictions of the<br>&gt; level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties<br>&gt; accessible by a class and its subclasses; &#39;declaration&#39;, rather than<br>&gt; &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>&gt; given type or extension declaration.<br>&gt;<br>&gt; Since, at the moment, a declaration can only occur within one file, I think<br>&gt; this most-restricted level has managed to pass as a level of the file-based<br>&gt; access system. However, if the system is ever extended, we&#39;re going to run<br>&gt; into new syntax decisions where we have &#39;private module&#39; functions<br>&gt; (accessible only within the given type in the same module) trying to<br>&gt; communicate with &#39;protected file&#39; properties (accessible only with the type<br>&gt; and its subtypes in the same file), and that might lead to conflicts, so<br>&gt; perhaps we should decide how those might be declared now.<br>&gt;<br>&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;<br>&gt; &gt;On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;And again, moving the access control modification to the end just doesn&#39;t<br>&gt; look<br>&gt; &gt;right to me or seem to enhance readability. :(<br>&gt; &gt;<br>&gt; &gt;I like Shawn’s proposal better for cases where there are custom<br>&gt; &gt;getter/setter implementations.  We should definitely be able to do:<br>&gt; &gt;<br>&gt; &gt;var foo:Int {<br>&gt; &gt;public get {…}<br>&gt; &gt;private(file) set {…}<br>&gt; &gt;}<br>&gt; &gt;<br>&gt; &gt;In fact, that is what I first tried to do before learning about<br>&gt; &gt;private(set).  But without the implementations, it just seems strange to<br>&gt; &gt;put the scoping after the rest of the declaration (they work above because<br>&gt; &gt;they are *before* the custom getter/setter).<br>&gt; &gt;<br>&gt; &gt;I still like the idea of having the option to use parameter-like syntax<br>&gt; &gt;for cases where you don’t have custom getters/setters:<br>&gt; &gt;<br>&gt; &gt;private var foo:Int<br>&gt; &gt;private(file) var foo:Int<br>&gt; &gt;private(set: file) var foo:Int<br>&gt; &gt;private(get: global, set: file) var foo:Int<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;I guess, if we had some way to represent the standard getter/setter, that<br>&gt; &gt;might work too.  I don’t love it, but maybe with better wording?<br>&gt; &gt;<br>&gt; &gt;var foo:Int{<br>&gt; &gt;public get useDefault<br>&gt; &gt;private(file) set {…}<br>&gt; &gt;}<br>&gt; &gt;<br>&gt; &gt;Thanks,<br>&gt; &gt;Jon<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt; &gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;I like Shawn&#39;s proposal:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;var foo: Int { private(file) set }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;For example, we already use<br>&gt; &gt;<br>&gt; &gt;var foo: Int { mutating get { ... } }<br>&gt; &gt;<br>&gt; &gt;and not<br>&gt; &gt;<br>&gt; &gt;mutating(get) var foo: Int { get { ... } }<br>&gt; &gt;<br>&gt; &gt;On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt; &gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;I like Shawn&#39;s proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;var foo: Int { private(file) set }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;While I like private(get: file, set: module) idea, I think it just gets<br>&gt; &gt;&gt;too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; &gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;*On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;The only question is (as Sean mentioned) how this combines with the<br>&gt; syntax<br>&gt; &gt;&gt;&gt;for setter access level, e.g. the current private(set). Options:<br>&gt; &gt;&gt;&gt;- Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt; &gt;&gt;&gt;private(set).<br>&gt; &gt;&gt;&gt;- Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt; &gt;&gt;&gt;set), private(accessor: set). Less ambiguity but longer.<br>&gt; &gt;&gt;&gt;- Not using multiple arguments, but that&#39;d probably break consistency<br>&gt; with<br>&gt; &gt;&gt;&gt;the other unification efforts going on to make everything look like<br>&gt; &gt;&gt;&gt;function calls.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;What about the following 3 forms?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;private(file) //both setter and getter have file scope<br>&gt; &gt;&gt;&gt;private(set: file) //setter has file scope.  Equivalent to current<br>&gt; &gt;&gt;&gt;“private(set)&quot;<br>&gt; &gt;&gt;&gt;private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt; &gt;&gt;&gt;file scope<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt; &gt;&gt;&gt;last form: private(get: public, set: module)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;Thanks,<br>&gt; &gt;&gt;&gt;Jon<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;_______________________________________________<br>&gt; &gt;&gt;&gt;swift-evolution mailing list<br>&gt; &gt;&gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt; &gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;_______________________________________________<br>&gt; &gt;swift-evolution mailing list<br>&gt; &gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------- End Message -------------<br>&gt;<br>&gt;<br>&gt;<br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/2e57daf9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>SE-0025: Scoped Access Level, next steps</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>March 16, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for the clarification, I think this is the context I was missing. So this is a completely different type of access level, to either type-based or file-based? I&#39;m still against making breaking changes, but I now understand why so many are supporting changing private.<br></p><p>Rereading the message I quoted (I now realise how badly I misinterpreted it), I think it does present a good case for keeping this scope-based keyword a separate keyword from the current ones. Type-based access would be a good feature to include eventually, as an indication of a variable/function&#39;s intended use more than anything (such as internal variables meant to be used in extensions).<br></p><p>From James F<br></p><p>&gt; On 16 Mar 2016, at 11:11, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; Type based access would be confusing, which is why the proposal was for scoped based access. This means that something is visible only in the scope in which it is defined and is completely sealed from outside of the scope. This way you have to modify the scope to make something more visible, so you can&#39;t just add another extension to make something more visible.<br>&gt; <br>&gt; &gt; Limiting access using scope means another file/module can just add a property/function to make the value public. Confusing type-based and file-based access is a step backwards, and any attempt to add type-based access shouldn&#39;t be a breaking change.<br>&gt; <br>&gt;&gt; On Wed, Mar 16, 2016 at 6:52 AM James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I agree with the proposal of ‘inherited’ &amp; ‘declaration’ modifiers.<br>&gt;&gt; <br>&gt;&gt; Current access modifiers actually guarantee access. Limiting access using scope means another file/module can just add a property/function to make the value public. Confusing type-based and file-based access is a step backwards, and any attempt to add type-based access shouldn&#39;t be a breaking change.<br>&gt;&gt; <br>&gt;&gt; Replacing internal with private(module) also seems like a step backwards, to me, and in my opinion changes to the ‘internal’ keyword should be part of a separate proposal.<br>&gt;&gt; <br>&gt;&gt; Inherited &amp; declaration modifiers compose well with existing access-modifiers, are clear in their purpose, can be applied to all access levels, and don&#39;t break existing code.<br>&gt;&gt; <br>&gt;&gt; ------------ Begin Message ------------<br>&gt;&gt; Group: gmane.comp.lang.swift.evolution<br>&gt;&gt; MsgID: &lt;CAPUwzK7YHzwDMTMuH1Qvbojz3+9+ikgJvna3xDhscESVO8YSNQ at mail.gmail.com&gt;<br>&gt;&gt; <br>&gt;&gt; It&#39;s occurring to me, reading these recent posts, that we have two<br>&gt;&gt; orthogonal systems of access levels.<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s current access system is file based; a project file decides which<br>&gt;&gt; files comprise a module, and the terms &#39;public&#39;, &#39;internal&#39; and &#39;private&#39;<br>&gt;&gt; determine whether a property is accessible to all, accessible only within<br>&gt;&gt; files of the module, or accessible only within a file. (This takes on an<br>&gt;&gt; extra dimension as files may belong to several modules).<br>&gt;&gt; <br>&gt;&gt; The concept which began this discussion, and several of the proposed<br>&gt;&gt; concepts in this discussion, ask instead for a type-based access system<br>&gt;&gt; similar to those in other languages including Objective-C, where &#39;public&#39;,<br>&gt;&gt; &#39;protected&#39; and &#39;private&#39; are the terms of choice and they restrict access<br>&gt;&gt; to a type or subtypes.<br>&gt;&gt; <br>&gt;&gt; I think it would be confusing if Swift applied &#39;public&#39; to a concept in the<br>&gt;&gt; file-based access system and &#39;private&#39; to a concept in the type-based<br>&gt;&gt; access system.<br>&gt;&gt; <br>&gt;&gt; I would prefer clearer terms which actually mention the restrictions of the<br>&gt;&gt; level. For example, &#39;inherited&#39;, not &#39;protected&#39;, in the case of properties<br>&gt;&gt; accessible by a class and its subclasses; &#39;declaration&#39;, rather than<br>&gt;&gt; &#39;private&#39; or &#39;scoped&#39;, to refer to properties only accessible within a<br>&gt;&gt; given type or extension declaration.<br>&gt;&gt; <br>&gt;&gt; Since, at the moment, a declaration can only occur within one file, I think<br>&gt;&gt; this most-restricted level has managed to pass as a level of the file-based<br>&gt;&gt; access system. However, if the system is ever extended, we&#39;re going to run<br>&gt;&gt; into new syntax decisions where we have &#39;private module&#39; functions<br>&gt;&gt; (accessible only within the given type in the same module) trying to<br>&gt;&gt; communicate with &#39;protected file&#39; properties (accessible only with the type<br>&gt;&gt; and its subtypes in the same file), and that might lead to conflicts, so<br>&gt;&gt; perhaps we should decide how those might be declared now.<br>&gt;&gt; <br>&gt;&gt; On Tue, Mar 15, 2016 at 11:51 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;On Tue, Mar 15, 2016 at 2:33 PM Erica Sadun &lt;erica at ericasadun.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;And again, moving the access control modification to the end just doesn&#39;t look<br>&gt;&gt; &gt;right to me or seem to enhance readability. :(<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I like Shawn’s proposal better for cases where there are custom<br>&gt;&gt; &gt;getter/setter implementations.  We should definitely be able to do:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;var foo:Int {<br>&gt;&gt; &gt;public get {…}<br>&gt;&gt; &gt;private(file) set {…}<br>&gt;&gt; &gt;}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;In fact, that is what I first tried to do before learning about<br>&gt;&gt; &gt;private(set).  But without the implementations, it just seems strange to<br>&gt;&gt; &gt;put the scoping after the rest of the declaration (they work above because<br>&gt;&gt; &gt;they are *before* the custom getter/setter).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I still like the idea of having the option to use parameter-like syntax<br>&gt;&gt; &gt;for cases where you don’t have custom getters/setters:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;private var foo:Int<br>&gt;&gt; &gt;private(file) var foo:Int<br>&gt;&gt; &gt;private(set: file) var foo:Int<br>&gt;&gt; &gt;private(get: global, set: file) var foo:Int<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I guess, if we had some way to represent the standard getter/setter, that<br>&gt;&gt; &gt;might work too.  I don’t love it, but maybe with better wording?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;var foo:Int{<br>&gt;&gt; &gt;public get useDefault<br>&gt;&gt; &gt;private(file) set {…}<br>&gt;&gt; &gt;}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;Thanks,<br>&gt;&gt; &gt;Jon<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;On Mar 14, 2016, at 10:22 PM, Patrick Pijnappel &lt;<br>&gt;&gt; &gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;I like Shawn&#39;s proposal:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;var foo: Int { private(file) set }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;For example, we already use<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;var foo: Int { mutating get { ... } }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;and not<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;mutating(get) var foo: Int { get { ... } }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;On Tue, Mar 15, 2016 at 4:13 PM, Patrick Pijnappel &lt;<br>&gt;&gt; &gt;patrickpijnappel-Re5JQEeQqe8AvxtiuMwx3w at public.gmane.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;I like Shawn&#39;s proposal:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;var foo: Int { private(file) set }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;In fact it&#39;s probably more sensible than the current private(set) IMO.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;While I like private(get: file, set: module) idea, I think it just gets<br>&gt;&gt; &gt;&gt;too inconsistent with private(set: public) and private(set: private) (?!)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;On Tue, Mar 15, 2016 at 3:39 PM, Jonathan Hull via swift-evolution &lt;<br>&gt;&gt; &gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;*On Mar 14, 2016, at 8:36 PM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:*<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;The only question is (as Sean mentioned) how this combines with the syntax<br>&gt;&gt; &gt;&gt;&gt;for setter access level, e.g. the current private(set). Options:<br>&gt;&gt; &gt;&gt;&gt;- Unnamed 2nd argument, giving private(file), private(file, set),<br>&gt;&gt; &gt;&gt;&gt;private(set).<br>&gt;&gt; &gt;&gt;&gt;- Named 2nd argument, giving e.g. private(file), private(file, accessor:<br>&gt;&gt; &gt;&gt;&gt;set), private(accessor: set). Less ambiguity but longer.<br>&gt;&gt; &gt;&gt;&gt;- Not using multiple arguments, but that&#39;d probably break consistency with<br>&gt;&gt; &gt;&gt;&gt;the other unification efforts going on to make everything look like<br>&gt;&gt; &gt;&gt;&gt;function calls.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;What about the following 3 forms?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;private(file) //both setter and getter have file scope<br>&gt;&gt; &gt;&gt;&gt;private(set: file) //setter has file scope.  Equivalent to current<br>&gt;&gt; &gt;&gt;&gt;“private(set)&quot;<br>&gt;&gt; &gt;&gt;&gt;private(get: module, set: file) //getter has module scope &amp; setter has<br>&gt;&gt; &gt;&gt;&gt;file scope<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;It is a bit weird, but we should probably also allow “public&quot; in that<br>&gt;&gt; &gt;&gt;&gt;last form: private(get: public, set: module)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;Thanks,<br>&gt;&gt; &gt;&gt;&gt;Jon<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;_______________________________________________<br>&gt;&gt; &gt;&gt;&gt;swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt; &gt;&gt;&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;_______________________________________________<br>&gt;&gt; &gt;swift-evolution mailing list<br>&gt;&gt; &gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ------------- End Message -------------<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/110953cc/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
