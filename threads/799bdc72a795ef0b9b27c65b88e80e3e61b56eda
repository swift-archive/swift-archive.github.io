<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January  9, 2016 at 11:00:00pm</p></header><div class="content"><p>## Introduction<br></p><p>When using protocol, we usually need to use optional method or property. We propose to remove the <br>requirement of @objc keyword for such protocol.<br></p><p><br>## Motivation<br></p><p>objc protocol have many restriction to regular Swift protocol : they cannot use Swift s<br>specific feature. For example, methods cannot use struct, tuple, etc...<br></p><p>Example : <br>Considere the following code : <br></p><p>```swift<br>struct Person {<br>    let name:String<br>    let surname:String<br>}<br></p><p>protocol PersonRetrievable {<br>    var personDescription : String { get }<br>    func loadPerson() -&gt; Person<br>}<br></p><p>```<br></p><p>If we want to make the loadPerson() method optional, we need to add the attribut @objc <br>to the protocol :<br></p><p>```swift<br>@objc<br>protocol PersonRetrievable {<br>    var personDescription : String { get }<br>    optional func loadPerson() -&gt; Person<br>}<br>```<br></p><p>But this code not longer compiles because struct are not supported on objc protocol.<br></p><p>The only workaround is to transform Person struct to class which involve a major change <br>because Person is no longer a value type.<br></p><p>## Proposed solution<br>We propose to remove objc requirement for optional methods and properties in protocol and  <br>make this kind of code compilable :<br></p><p>```swift<br>struct Person {<br>    let name:String<br>    let surname:String<br>}<br></p><p>protocol PersonRetrievable {<br>    var personDescription : String { get }<br>    optional func loadPerson() -&gt; Person<br>}<br></p><p>```<br></p><p>## Detailed design<br>There&#39;s no specific design : A non-objc protocol is still not visible in ObjC code.<br></p><p>Type is mandatory for abstract properties since it cannot be inferred.<br></p><p>## Impact on existing code<br>This change has no impact on existing code, but might change the ABI that is being <br>stabilizing in Swift 3.0.<br></p><p>## Alternatives considered<br>Without this feature, we must use objc objects as parameters.<br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/799b6eda/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 2:00 PM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; When using protocol, we usually need to use optional method or property. We propose to remove the <br>&gt; requirement of @objc keyword for such protocol.<br></p><p>Hi David,<br></p><p>This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br></p><p>1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br></p><p>2. Protocols with default implementations provide the vastly most common use-cases for these.<br></p><p>3. They overload “optional” terminology in the language to mean something different.<br></p><p>4. They are non-sensical - how can something be a requirement and be optional? :)<br></p><p><br></p><p>Doug has it on his plate to explore what we can do about this, in the Swift 3 timeframe, but not in the immediate future.  IMO, it would be really great if we could make Objective-C optional requirements disappear in the Clang importer, and transform them into requirements with a default implementation.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 7:29 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 9, 2016, at 2:00 PM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When using protocol, we usually need to use optional method or property. We propose to remove the <br>&gt;&gt; requirement of @objc keyword for such protocol.<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br>&gt; <br>&gt; 1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br>&gt; <br>&gt; 2. Protocols with default implementations provide the vastly most common use-cases for these.<br>&gt; <br>&gt; 3. They overload “optional” terminology in the language to mean something different.<br>&gt; <br>&gt; 4. They are non-sensical - how can something be a requirement and be optional? :)<br>&gt; <br>&gt; <br>&gt; <br>&gt; Doug has it on his plate to explore what we can do about this, in the Swift 3 timeframe, but not in the immediate future.  IMO, it would be really great if we could make Objective-C optional requirements disappear in the Clang importer, and transform them into requirements with a default implementation.<br></p><p>+1 to this approach.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January 10, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Chris,<br></p><p>&gt; Le 10 janv. 2016 à 02:29, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt; <br>&gt; This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br>&gt; <br>&gt; 1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br>	You are right. I suggest that we restrict optional keyword in protocol to methods only to fix this issue and keep the actual meaning.<br>&gt; <br>&gt; 2. Protocols with default implementations provide the vastly most common use-cases for these.<br>&gt; <br>&gt; 3. They overload “optional” terminology in the language to mean something different.<br>&gt; <br>&gt; 4. They are non-sensical - how can something be a requirement and be optional? :)<br>	Actually, optional methods allow to add methods to interface without breaking existing code and for me, conforming to protocol means « you can optionally implement this methods but you must implements others ». Conforming does not mean implements all feature but the protocol defines minimum requirements.<br></p><p>&gt; <br>&gt; Doug has it on his plate to explore what we can do about this, in the Swift 3 timeframe, but not in the immediate future.  IMO, it would be really great if we could make Objective-C optional requirements disappear in the Clang importer, and transform them into requirements with a default implementation.<br>&gt; <br>	I agree that default implementation seems to be the right solution but I’m afraid it introduces other problems with scope.<br></p><p>	Consider the UITableViewDataSource protocol and the heightForRowAtIndexPath. The default implementation method uses UITableView internal properties and methods. Then, if we provide default implementation for this method in protocol, we will need to reference the called object in protocol.<br></p><p>	Actually, the default implementation may depend of the caller and can be different for each caller in the actual model. <br></p><p>	If you attach default implementation to protocol declaration, you will not be able to have caller specific default implementation and will have a basic and quite useless default implementation i.e. returning nil or invalid value.<br></p><p>	I thing this is a major issue because ObjC default implementation behavior is really powerful.<br></p><p>	One workaround would be to provided default implementation when declaring delegate attribute, but this would make syntax very complicated.<br></p><p>	Java has introduced default implementation in interface and it create confusion between classes and interfaces and does not solve the issue I exposed below.<br></p><p>	I think we should keep the actual model by limiting optional keyword to methods, which has really a meaning. <br></p><p>	Anyway, I did not think about this before Swift 3 or later.<br></p><p>David<br></p><p><br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/8fecb9f3/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 1:31 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt;&gt; Le 10 janv. 2016 à 02:29, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br>&gt;&gt; <br>&gt;&gt; 1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br>&gt; 	You are right. I suggest that we restrict optional keyword in protocol to methods only to fix this issue and keep the actual meaning.<br></p><p>That wasn’t Chris’s point. Compare<br></p><p>	protocol P {<br>	  optional func f() -&gt; Int<br>	}<br></p><p>with<br></p><p>	protocol P {<br>	  var f: (() -&gt; Int)? { get }<br>	}<br></p><p>	extension P {<br>	  var f: (() -&gt; Int)? { return nil }<br>	}<br></p><p>Both will have the same “call-side” syntax, e.g., accessing the “f” member of something that conforms to “P” gives you a value of type “(() -&gt; Int)?”. You can use ? to optionally call it like so:<br></p><p>	func testF&lt;T : P&gt;(t: T) {<br>	  let x = t.f?() // call “f’ if it is available.<br>	}<br></p><p><br></p><p>&gt;&gt; <br>&gt;&gt; 2. Protocols with default implementations provide the vastly most common use-cases for these.<br>&gt;&gt; <br>&gt;&gt; 3. They overload “optional” terminology in the language to mean something different.<br>&gt;&gt; <br>&gt;&gt; 4. They are non-sensical - how can something be a requirement and be optional? :)<br>&gt; 	Actually, optional methods allow to add methods to interface without breaking existing code and for me, conforming to protocol means « you can optionally implement this methods but you must implements others ». Conforming does not mean implements all feature but the protocol defines minimum requirements.<br></p><p>Although it’s not implemented now, one will be able to add new requirements to a protocol so long as those new requirements have a default implementation. The only thing “optional” requirements give you beyond default implementations is the ability to determine whether the requirement was fulfilled.<br></p><p>&gt;&gt; Doug has it on his plate to explore what we can do about this, in the Swift 3 timeframe, but not in the immediate future.  IMO, it would be really great if we could make Objective-C optional requirements disappear in the Clang importer, and transform them into requirements with a default implementation.<br>&gt;&gt; <br>&gt; 	I agree that default implementation seems to be the right solution but I’m afraid it introduces other problems with scope.<br>&gt; <br>&gt; 	Consider the UITableViewDataSource protocol and the heightForRowAtIndexPath. The default implementation method uses UITableView internal properties and methods. Then, if we provide default implementation for this method in protocol, we will need to reference the called object in protocol.<br></p><p>Given the tight integration between UITableViewDataSource and UITableView, it is completely reasonable for the default implementation of a requirement in UITableViewDataSource to use internal methods of UITableView.<br></p><p>&gt; <br>&gt; 	Actually, the default implementation may depend of the caller and can be different for each caller in the actual model. <br>&gt; <br>&gt; 	If you attach default implementation to protocol declaration, you will not be able to have caller specific default implementation and will have a basic and quite useless default implementation i.e. returning nil or invalid value.<br></p><p>If you need to distinguish between types that did or did not provide their own implementation, you can use a “nil” result or the property trick above.<br></p><p>&gt; 	I thing this is a major issue because ObjC default implementation behavior is really powerful.<br></p><p>Given that we can get the same behavior in Swift without optional requirements, it’s not any more powerful… it’s just more convenient for those cases. So, the question is whether those cases are common enough—or the workarounds awful enough—to warrant having two very similar features in Swift.<br></p><p>&gt; 	Java has introduced default implementation in interface and it create confusion between classes and interfaces and does not solve the issue I exposed below.<br></p><p>We already have default implementations for protocols (via extensions) as well as classes with implementation inheritance, so any related confusion is already there, so I don’t see how the comparison matters.<br></p><p>&gt; <br>&gt; 	I think we should keep the actual model by limiting optional keyword to methods, which has really a meaning. <br></p><p>I don’t see why you would limit it to methods. There are a number of optional properties in Cocoa[Touch], for example, and it “wrap the result in an extra level of optional” is a reasonable semantic approach here.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Le 11 janv. 2016 à 05:56, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 1:31 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt;&gt; Le 10 janv. 2016 à 02:29, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br>&gt;&gt; 	You are right. I suggest that we restrict optional keyword in protocol to methods only to fix this issue and keep the actual meaning.<br>&gt; <br>&gt; That wasn’t Chris’s point. Compare<br>&gt; <br>&gt; 	protocol P {<br>&gt; 	  optional func f() -&gt; Int<br>&gt; 	}<br>&gt; <br>&gt; with<br>&gt; <br>&gt; 	protocol P {<br>&gt; 	  var f: (() -&gt; Int)? { get }<br>&gt; 	}<br>&gt; <br>&gt; 	extension P {<br>&gt; 	  var f: (() -&gt; Int)? { return nil }<br>&gt; 	}<br>&gt; <br>&gt; Both will have the same “call-side” syntax, e.g., accessing the “f” member of something that conforms to “P” gives you a value of type “(() -&gt; Int)?”. You can use ? to optionally call it like so:<br>&gt; <br>&gt; 	func testF&lt;T : P&gt;(t: T) {<br>&gt; 	  let x = t.f?() // call “f’ if it is available.<br>&gt; 	}<br></p><p>	Yes, I agree with you…I didn’t read carefully the answer from Chris. But the implementation is more complex : <br></p><p>struct Person {<br>    let name:String<br>    let surname:String<br>}<br></p><p>protocol PersonRetrievable {<br>    var personDescription : String { get }<br>    var loadPerson:(() -&gt; Person)? { get }<br>}<br></p><p>extension PersonRetrievable {<br>    var loadPerson:(() -&gt; Person)? { return nil }<br>}<br></p><p>class GroupPerson : PersonRetrievable {<br>    var personDescription : String {<br>        return &quot;Hello World&quot;;<br>    }<br>    <br>    var loadPerson:(() -&gt; Person)? {<br>        return { return Person(name: &quot;Scrève&quot;, surname: &quot;David&quot;)}<br>    }<br>}<br></p><p>	Double returns is quite complex to write and understand..but I agree this problem can be solved like this.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; 	Java has introduced default implementation in interface and it create confusion between classes and interfaces and does not solve the issue I exposed below.<br>&gt; <br>&gt; We already have default implementations for protocols (via extensions) as well as classes with implementation inheritance, so any related confusion is already there, so I don’t see how the comparison matters.<br></p><p>	Another question is about priority : Is there any guarantee that implementation of protocol will be called instead of extension ? I don’t remembre reading this anywhere.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; 	I think we should keep the actual model by limiting optional keyword to methods, which has really a meaning. <br>&gt; <br>&gt; I don’t see why you would limit it to methods. There are a number of optional properties in Cocoa[Touch], for example, and it “wrap the result in an extra level of optional” is a reasonable semantic approach here.<br></p><p>	I wrote that because properties already have optional behavior with their type.<br></p><p>	Another idea would be to remove the optional keyword and use the same syntax for method with question mark : <br></p><p>    func loadPerson?()<br></p><p>	And the compiler generates the code with the double return and property. <br></p><p>	What do you think about this ?<br></p><p>David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e1349f29/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/e1349f29/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 12:08 AM, David Scrève &lt;david.screve at dlta-studio.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 11 janv. 2016 à 05:56, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 1:31 AM, David Scrève via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Chris,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 10 janv. 2016 à 02:29, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is certainly a glaring hole in the system, and one we need to discuss.  Here are some problems with making optional requirements a first class thing in Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. They overlap heavily (but are syntactically privileged) with optional properties, consider the difference between &quot;optional func f() -&gt; Int&quot;  vs &quot;var f : (() -&gt; Int)?  {get}”.<br>&gt;&gt;&gt; 	You are right. I suggest that we restrict optional keyword in protocol to methods only to fix this issue and keep the actual meaning.<br>&gt;&gt; <br>&gt;&gt; That wasn’t Chris’s point. Compare<br>&gt;&gt; <br>&gt;&gt; 	protocol P {<br>&gt;&gt; 	  optional func f() -&gt; Int<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; with<br>&gt;&gt; <br>&gt;&gt; 	protocol P {<br>&gt;&gt; 	  var f: (() -&gt; Int)? { get }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension P {<br>&gt;&gt; 	  var f: (() -&gt; Int)? { return nil }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Both will have the same “call-side” syntax, e.g., accessing the “f” member of something that conforms to “P” gives you a value of type “(() -&gt; Int)?”. You can use ? to optionally call it like so:<br>&gt;&gt; <br>&gt;&gt; 	func testF&lt;T : P&gt;(t: T) {<br>&gt;&gt; 	  let x = t.f?() // call “f’ if it is available.<br>&gt;&gt; 	}<br>&gt; <br>&gt; 	Yes, I agree with you…I didn’t read carefully the answer from Chris. But the implementation is more complex : <br>&gt; <br>&gt; struct Person {<br>&gt;     let name:String<br>&gt;     let surname:String<br>&gt; }<br>&gt; <br>&gt; protocol PersonRetrievable {<br>&gt;     var personDescription : String { get }<br>&gt;     var loadPerson:(() -&gt; Person)? { get }<br>&gt; }<br>&gt; <br>&gt; extension PersonRetrievable {<br>&gt;     var loadPerson:(() -&gt; Person)? { return nil }<br>&gt; }<br>&gt; <br>&gt; class GroupPerson : PersonRetrievable {<br>&gt;     var personDescription : String {<br>&gt;         return &quot;Hello World&quot;;<br>&gt;     }<br>&gt;     <br>&gt;     var loadPerson:(() -&gt; Person)? {<br>&gt;         return { return Person(name: &quot;Scrève&quot;, surname: &quot;David&quot;)}<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; 	Double returns is quite complex to write and understand..but I agree this problem can be solved like this.<br></p><p>Right. One could extend the language with a rule that allows a method to satisfy a read-only property requirement when that property is of (possibly optional) function type.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 	Java has introduced default implementation in interface and it create confusion between classes and interfaces and does not solve the issue I exposed below.<br>&gt;&gt; <br>&gt;&gt; We already have default implementations for protocols (via extensions) as well as classes with implementation inheritance, so any related confusion is already there, so I don’t see how the comparison matters.<br>&gt; <br>&gt; 	Another question is about priority : Is there any guarantee that implementation of protocol will be called instead of extension ? I don’t remembre reading this anywhere.<br></p><p>The rules are a little muddy and are being discussed in other threads (e.g., those about dynamic dispatch of members of protocol extensions).<br></p><p>&gt;&gt;&gt; 	I think we should keep the actual model by limiting optional keyword to methods, which has really a meaning. <br>&gt;&gt; <br>&gt;&gt; I don’t see why you would limit it to methods. There are a number of optional properties in Cocoa[Touch], for example, and it “wrap the result in an extra level of optional” is a reasonable semantic approach here.<br>&gt; <br>&gt; 	I wrote that because properties already have optional behavior with their type.<br>&gt; <br>&gt; 	Another idea would be to remove the optional keyword and use the same syntax for method with question mark : <br>&gt; <br>&gt;     func loadPerson?()<br>&gt; <br>&gt; 	And the compiler generates the code with the double return and property. <br>&gt; <br>&gt; 	What do you think about this ?<br></p><p>Per my first comment about about satisfying a read-only property of function type with a method, I don’t think we need a special syntax at all to make it easy to conform to these protocols.<br></p><p><br>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/5d0c98d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 11 janv. 2016 à 18:20, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt;     var loadPerson:(() -&gt; Person)? {<br>&gt;&gt;         return { return Person(name: &quot;Scrève&quot;, surname: &quot;David&quot;)}<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 	Double returns is quite complex to write and understand..but I agree this problem can be solved like this.<br>&gt; <br>&gt; Right. One could extend the language with a rule that allows a method to satisfy a read-only property requirement when that property is of (possibly optional) function type.<br>	Yes, this could be a really good solution…Should I post a proposal for that ?<br>&gt;&gt; <br>&gt;&gt; 	And the compiler generates the code with the double return and property. <br>&gt;&gt; <br>&gt;&gt; 	What do you think about this ?<br>&gt; <br>&gt; Per my first comment about about satisfying a read-only property of function type with a method, I don’t think we need a special syntax at all to make it easy to conform to these protocols.<br></p><p>	I agree :-)<br></p><p>David<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/de31155d/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/de31155d/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 12:24 PM, David Scrève &lt;david.screve at dlta-studio.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 11 janv. 2016 à 18:20, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var loadPerson:(() -&gt; Person)? {<br>&gt;&gt;&gt;         return { return Person(name: &quot;Scrève&quot;, surname: &quot;David&quot;)}<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Double returns is quite complex to write and understand..but I agree this problem can be solved like this.<br>&gt;&gt; <br>&gt;&gt; Right. One could extend the language with a rule that allows a method to satisfy a read-only property requirement when that property is of (possibly optional) function type.<br>&gt; 	Yes, this could be a really good solution…Should I post a proposal for that ?<br></p><p>If you want to tackle the larger proposal of “remove optional requirements” and the various pieces required to make that happen, sure. One issue I haven’t thought about much is how to deal with the argument labels when performing this transformation, because we cannot overload properties. For example, importing UITableViewDataSource would end up with several dozen things named “tableview” :)<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/84d766b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Proposal draft] Remove objc requirement for optional protocol methods/properties</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>January 11, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 11 janv. 2016 à 21:39, Douglas Gregor &lt;dgregor at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 12:24 PM, David Scrève &lt;david.screve at dlta-studio.com &lt;mailto:david.screve at dlta-studio.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 11 janv. 2016 à 18:20, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var loadPerson:(() -&gt; Person)? {<br>&gt;&gt;&gt;&gt;         return { return Person(name: &quot;Scrève&quot;, surname: &quot;David&quot;)}<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	Double returns is quite complex to write and understand..but I agree this problem can be solved like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right. One could extend the language with a rule that allows a method to satisfy a read-only property requirement when that property is of (possibly optional) function type.<br>&gt;&gt; 	Yes, this could be a really good solution…Should I post a proposal for that ?<br>&gt; <br>&gt; If you want to tackle the larger proposal of “remove optional requirements” and the various pieces required to make that happen, sure. One issue I haven’t thought about much is how to deal with the argument labels when performing this transformation, because we cannot overload properties. For example, importing UITableViewDataSource would end up with several dozen things named “tableview” :)<br></p><p>	Hum…not sure to have enough experience with Swift right now…But I’ll think about it :-)<br></p><p>David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3a5121b7/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3a5121b7/attachment.p7s&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
