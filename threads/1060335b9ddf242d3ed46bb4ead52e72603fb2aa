<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>part of the mix or cascading. In that light, I&#39;ve put together the following:<br></p><p>https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae&gt;<br></p><p>If the community demand is this high, I think we should re-consider pushing it before 3. <br>Feedback as always welcome, including criticism.<br></p><p>-- E<br></p><p>Introducing with to the Standard Library<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#introduction&gt;Introduction<br></p><p>This proposal introduces a with function to the standard library to simplify the initialization and modification of constants and Foundation-sourced complex objects.<br></p><p>Swift-evolution thread: What about a VBA style with Statement? &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br> &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#motivation&gt;Motivation<br></p><p>Closure-based initialization enables clean and highly directed set-up in Swift code. Numerous variations on the theme have been introduced on the Swift Evolution list and in third party github repositories. Although you can build solutions natively without functions, current Swift technology has drawbacks:<br></p><p>let questionLabel: UILabel = {<br>    $0.textAlignment = .Center<br>    $0.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>    $0.text = questionText<br>    $0.numberOfLines = 0<br>    return $0<br>}(UILabel())<br></p><p>let mySwitch : UISwitch = {<br>    view.addSubview($0)<br>    CenterViewInSuperview($0, horizontal: true, vertical: true)<br>    $0.addTarget(self, action: &quot;action&quot;, forControlEvents: .TouchUpInside)<br>    return $0<br>}(UISwitch())<br>Assignment must be explicitly typed.<br>The source item must be postpended to the set-up closure.<br>The closure must return the item.<br>This approach is better suited to setting up Foundation objects than modifying Swift constants. When duplicating and modifying a constant, the closure must create a var copy and modify that copy.<br>While the implementation is imperfect, the wins are notable. Code naturally groups into a clear set-up sequence. The scoped setup avoids clumpy redundant lines where the same variable is accessed over and over. <br></p><p>let questionLabel = UILabel()<br>questionLabel.textAlignment = .Center<br>questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>questionLabel.text = questionText<br>questionLabel.numberOfLines = 0<br>In the case of non-reference types, a constant&#39;s fields may be set-up sequentially without forcing the constant to be a variable.<br></p><p> &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#detailed-design&gt;Detailed Design<br></p><p>This proposal introduces a with function that enables modification and use of an instance using positional references. It&#39;s not quite as clean as a solution with implicit self but it offers sufficient utility that a vast swath of Swift developers have adopted this function in some form or another.<br></p><p>@discardableResult<br>public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>    var this = item; try update(&amp;this); return this<br>}<br>In use:<br></p><p>struct Person { var name: String, favoriteColor: UIColor }<br>let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>let jane = with(john){ $0.name = &quot;Jane&quot; }<br>print(jane) // Person(name: &quot;Jane&quot;, favoriteColor: UIDeviceRGBColorSpace 0 0 1 1)<br></p><p>struct Point { var (x, y) : (Double, Double) }<br>let p1 = Point(x: 2, y: 3)<br>let p2 = with(p1){ $0.y = 4 }<br>print(p1, p2) // Point(x: 2.0, y: 3.0) Point(x: 2.0, y: 4.0)<br> &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is purely additive and has no impact on existing code<br></p><p> &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#alternatives-considered&gt;Alternatives Considered<br></p><p>Not adopting this proposal<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/1060b2aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>May 25, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I really like this idea and appreciate the effort. However, I’d rather have a method similar to Ruby Object#tap &lt;http://apidock.com/rails/Object/tap&gt; and not a free function.<br></p><p>Well, since there’s no &quot;Object class&quot; in Swift, the way I see it is through a protocol, much like the Then &lt;https://github.com/devxoul/Then&gt; project is done.<br></p><p>— A<br></p><p>&gt; On May 25, 2016, at 2:28 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt; <br>&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae&gt;<br>&gt; <br>&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt; Feedback as always welcome, including criticism.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Introducing with to the Standard Library<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal introduces a with function to the standard library to simplify the initialization and modification of constants and Foundation-sourced complex objects.<br>&gt; <br>&gt; Swift-evolution thread: What about a VBA style with Statement? &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#motivation&gt;Motivation<br>&gt; <br>&gt; Closure-based initialization enables clean and highly directed set-up in Swift code. Numerous variations on the theme have been introduced on the Swift Evolution list and in third party github repositories. Although you can build solutions natively without functions, current Swift technology has drawbacks:<br>&gt; <br>&gt; let questionLabel: UILabel = {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     return $0<br>&gt; }(UILabel())<br>&gt; <br>&gt; let mySwitch : UISwitch = {<br>&gt;     view.addSubview($0)<br>&gt;     CenterViewInSuperview($0, horizontal: true, vertical: true)<br>&gt;     $0.addTarget(self, action: &quot;action&quot;, forControlEvents: .TouchUpInside)<br>&gt;     return $0<br>&gt; }(UISwitch())<br>&gt; Assignment must be explicitly typed.<br>&gt; The source item must be postpended to the set-up closure.<br>&gt; The closure must return the item.<br>&gt; This approach is better suited to setting up Foundation objects than modifying Swift constants. When duplicating and modifying a constant, the closure must create a var copy and modify that copy.<br>&gt; While the implementation is imperfect, the wins are notable. Code naturally groups into a clear set-up sequence. The scoped setup avoids clumpy redundant lines where the same variable is accessed over and over. <br>&gt; <br>&gt; let questionLabel = UILabel()<br>&gt; questionLabel.textAlignment = .Center<br>&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt; questionLabel.text = questionText<br>&gt; questionLabel.numberOfLines = 0<br>&gt; In the case of non-reference types, a constant&#39;s fields may be set-up sequentially without forcing the constant to be a variable.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; This proposal introduces a with function that enables modification and use of an instance using positional references. It&#39;s not quite as clean as a solution with implicit self but it offers sufficient utility that a vast swath of Swift developers have adopted this function in some form or another.<br>&gt; <br>&gt; @discardableResult<br>&gt; public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>&gt;     var this = item; try update(&amp;this); return this<br>&gt; }<br>&gt; In use:<br>&gt; <br>&gt; struct Person { var name: String, favoriteColor: UIColor }<br>&gt; let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>&gt; let jane = with(john){ $0.name = &quot;Jane&quot; }<br>&gt; print(jane) // Person(name: &quot;Jane&quot;, favoriteColor: UIDeviceRGBColorSpace 0 0 1 1)<br>&gt; <br>&gt; struct Point { var (x, y) : (Double, Double) }<br>&gt; let p1 = Point(x: 2, y: 3)<br>&gt; let p2 = with(p1){ $0.y = 4 }<br>&gt; print(p1, p2) // Point(x: 2.0, y: 3.0) Point(x: 2.0, y: 4.0)<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this proposal<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b84a4d99/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 1:00 PM, Adriano Ferreira &lt;adriano.ferreira at me.com&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I really like this idea and appreciate the effort. However, I’d rather have a method similar to Ruby Object#tap &lt;http://apidock.com/rails/Object/tap&gt; and not a free function.<br>&gt; <br>&gt; Well, since there’s no &quot;Object class&quot; in Swift, the way I see it is through a protocol, much like the Then &lt;https://github.com/devxoul/Then&gt; project is done.<br>&gt; <br>&gt; — A<br></p><p>In Swift, there&#39;s no root object like NSObject, which is what the Then project relies upon. I&#39;m unfamiliar with `tap` but it looks<br>similar to method cascading, which is on hold for Swift 4.<br></p><p>-- E<br></p><p><br>&gt; <br>&gt;&gt; On May 25, 2016, at 2:28 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt;&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt;&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae&gt;<br>&gt;&gt; <br>&gt;&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt;&gt; Feedback as always welcome, including criticism.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/d77e31f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; I&#39;m unfamiliar with `tap` but it looks<br>&gt; similar to method cascading, which is on hold for Swift 4.<br></p><p>I *am* familiar with `tap`. It&#39;s basically `with(_:update:)`, but as a method and not `inout`, which usually doesn&#39;t matter for Ruby since everything is an object in that language. Typically, though, `tap` is not used to mutate at all; instead, it&#39;s used to access an intermediate value in a method chain, for instance to log it.<br></p><p>I am very much in favor of `with(_:update:)`. Fundamentally, it is an operation which applies a mutating method to a copy to make it nonmutating; this seems like a very useful thing to have in the standard library. I could easily imagine the standard library itself using it to reduce boilerplate. For instance, if the FloatingPoint protocol currently offers this:<br></p><p>	extension FloatingPoint {<br>		func adding(_ other: Self) -&gt; Self {<br>			var selfCopy = self<br>			selfCopy.add(other)<br>			return selfCopy<br>		}<br>	}<br></p><p>`with(_:update:)` would allow us to instead shorten it to:<br></p><p>	extension FloatingPoint {<br>		func adding(_ other: Self) -&gt; Self {<br>			return with(self) { $0.add(other) }<br>		}<br>	}<br></p><p>I also think this is fairly future-proof. Many of the future proposals in this area, like `self` shadowing, will interoperate with `with(_:update:)` perfectly. Others, like method cascading, would supplant it in some uses, but still leave many others (like the `FloatingPoint` example above) untouched. But even without any other changes at all, this is a good, useful thing to have in the language.<br></p><p>I don&#39;t agree with those who argue that this should be a method. When Swift offers an operation on any instance, it very rarely does so as a member (and `dynamicType`, one of the few exceptions, seems to be going away); instead, it uses either a free function or an initializer on the result type, depending on the circumstance. A `with(_:update:)` free function thus matches a broader pattern in the language.<br></p><p>There are also implementation reasons not to go the method route. A free function can be trivially implemented in the standard library with no language changes at all. A method, on the other hand, would either have to be implemented as a keyword specially recognized by the parser and handled by the language (as `dynamicType` is), or would require us to allow the currently forbidden extension of `Any`. Either of these is vastly more difficult and risky than using a free function.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>I like this pretty well, and I think &quot;with()&quot; makes sense as a peer of<br>&quot;withUnsafePointer()&quot;, &quot;withExtendedLifetime()&quot;, etc.<br></p><p>I&#39;d also be okay with waiting for a comprehensive method-cascading<br>solution. I don&#39;t find this issue particularly urgent, because it&#39;s pretty<br>easily solvable with an extension or just using closures.<br></p><p>On Wed, May 25, 2016 at 11:28 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d<br>&gt; done on closure-based setup.<br>&gt; It&#39;s clear that a demand is out there and strong for this kind of<br>&gt; behavior, even without implicit `self` as<br>&gt; part of the mix or cascading. In that light, I&#39;ve put together the<br>&gt; following:<br>&gt;<br>&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae<br>&gt;<br>&gt; If the community demand is this high, I think we should re-consider<br>&gt; pushing it before 3.<br>&gt; Feedback as always welcome, including criticism.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Introducing with to the Standard Library<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal introduces a with function to the standard library to<br>&gt; simplify the initialization and modification of constants and<br>&gt; Foundation-sourced complex objects.<br>&gt;<br>&gt; Swift-evolution thread: What about a VBA style with Statement?<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br>&gt; &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Closure-based initialization enables clean and highly directed set-up in<br>&gt; Swift code. Numerous variations on the theme have been introduced on the<br>&gt; Swift Evolution list and in third party github repositories. Although you<br>&gt; can build solutions natively without functions, current Swift technology<br>&gt; has drawbacks:<br>&gt;<br>&gt; let questionLabel: UILabel = {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     return $0<br>&gt; }(UILabel())<br>&gt; let mySwitch : UISwitch = {<br>&gt;     view.addSubview($0)<br>&gt;     CenterViewInSuperview($0, horizontal: true, vertical: true)<br>&gt;     $0.addTarget(self, action: &quot;action&quot;, forControlEvents: .TouchUpInside)<br>&gt;     return $0<br>&gt; }(UISwitch())<br>&gt;<br>&gt;<br>&gt;    - Assignment must be explicitly typed.<br>&gt;    - The source item must be postpended to the set-up closure.<br>&gt;    - The closure must return the item.<br>&gt;    - This approach is better suited to setting up Foundation objects than<br>&gt;    modifying Swift constants. When duplicating and modifying a constant, the<br>&gt;    closure must create a var copy and modify that copy.<br>&gt;<br>&gt; While the implementation is imperfect, the wins are notable. Code<br>&gt; naturally groups into a clear set-up sequence. The scoped setup avoids<br>&gt; clumpy redundant lines where the same variable is accessed over and over.<br>&gt;<br>&gt; let questionLabel = UILabel()<br>&gt; questionLabel.textAlignment = .Center<br>&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt; questionLabel.text = questionText<br>&gt; questionLabel.numberOfLines = 0<br>&gt;<br>&gt; In the case of non-reference types, a constant&#39;s fields may be set-up<br>&gt; sequentially without forcing the constant to be a variable.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal introduces a with function that enables modification and<br>&gt; use of an instance using positional references. It&#39;s not quite as clean as<br>&gt; a solution with implicit self but it offers sufficient utility that a<br>&gt; vast swath of Swift developers have adopted this function in some form or<br>&gt; another.<br>&gt;<br>&gt; @discardableResult<br>&gt; public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>&gt;     var this = item; try update(&amp;this); return this<br>&gt; }<br>&gt;<br>&gt; In use:<br>&gt;<br>&gt; struct Person { var name: String, favoriteColor: UIColor }let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())let jane = with(john){ $0.name = &quot;Jane&quot; }print(jane) // Person(name: &quot;Jane&quot;, favoriteColor: UIDeviceRGBColorSpace 0 0 1 1)<br>&gt; struct Point { var (x, y) : (Double, Double) }let p1 = Point(x: 2, y: 3)let p2 = with(p1){ $0.y = 4 }print(p1, p2) // Point(x: 2.0, y: 3.0) Point(x: 2.0, y: 4.0)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive and has no impact on existing code<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not adopting this proposal<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c7d69068/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 3:48 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like this pretty well, and I think &quot;with()&quot; makes sense as a peer of &quot;withUnsafePointer()&quot;, &quot;withExtendedLifetime()&quot;, etc.<br>&gt; <br>&gt; I&#39;d also be okay with waiting for a comprehensive method-cascading solution. I don&#39;t find this issue particularly urgent, because it&#39;s pretty easily solvable with an extension or just using closures.<br></p><p>+1.  I’ve been playing around with it in my own code a little bit.  I’m still uncertain about when I think it is good style and when I think it is best avoided.  I would certainly feel more comfortable using it if it was in the standard library.  <br></p><p>At the same time, I think we can and should do better in the future.  If that is the plan, do we really want `with` in the standard library?  I don’t mind waiting for a better solution, especially if it means a better solution is more likely to happen and / or we aren’t left with an unnecessary and duplicative function in the standard library.<br></p><p>So I’m on the fence here.  <br></p><p>&gt; <br>&gt; On Wed, May 25, 2016 at 11:28 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt; <br>&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae&gt;<br>&gt; <br>&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt; Feedback as always welcome, including criticism.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Introducing with to the Standard Library<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal introduces a with function to the standard library to simplify the initialization and modification of constants and Foundation-sourced complex objects.<br>&gt; <br>&gt; Swift-evolution thread: What about a VBA style with Statement? &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#motivation&gt;Motivation<br>&gt; <br>&gt; Closure-based initialization enables clean and highly directed set-up in Swift code. Numerous variations on the theme have been introduced on the Swift Evolution list and in third party github repositories. Although you can build solutions natively without functions, current Swift technology has drawbacks:<br>&gt; <br>&gt; let questionLabel: UILabel = {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     return $0<br>&gt; }(UILabel())<br>&gt; <br>&gt; let mySwitch : UISwitch = {<br>&gt;     view.addSubview($0)<br>&gt;     CenterViewInSuperview($0, horizontal: true, vertical: true)<br>&gt;     $0.addTarget(self, action: &quot;action&quot;, forControlEvents: .TouchUpInside)<br>&gt;     return $0<br>&gt; }(UISwitch())<br>&gt; Assignment must be explicitly typed.<br>&gt; The source item must be postpended to the set-up closure.<br>&gt; The closure must return the item.<br>&gt; This approach is better suited to setting up Foundation objects than modifying Swift constants. When duplicating and modifying a constant, the closure must create a var copy and modify that copy.<br>&gt; While the implementation is imperfect, the wins are notable. Code naturally groups into a clear set-up sequence. The scoped setup avoids clumpy redundant lines where the same variable is accessed over and over. <br>&gt; <br>&gt; let questionLabel = UILabel()<br>&gt; questionLabel.textAlignment = .Center<br>&gt; questionLabel.font =  UIFont(name:&quot;DnealianManuscript&quot;, size: 72)<br>&gt; questionLabel.text = questionText<br>&gt; questionLabel.numberOfLines = 0<br>&gt; In the case of non-reference types, a constant&#39;s fields may be set-up sequentially without forcing the constant to be a variable.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; This proposal introduces a with function that enables modification and use of an instance using positional references. It&#39;s not quite as clean as a solution with implicit self but it offers sufficient utility that a vast swath of Swift developers have adopted this function in some form or another.<br>&gt; <br>&gt; @discardableResult<br>&gt; public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>&gt;     var this = item; try update(&amp;this); return this<br>&gt; }<br>&gt; In use:<br>&gt; <br>&gt; struct Person { var name: String, favoriteColor: UIColor }<br>&gt; let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>&gt; let jane = with(john){ $0.name = &quot;Jane&quot; }<br>&gt; print(jane) // Person(name: &quot;Jane&quot;, favoriteColor: UIDeviceRGBColorSpace 0 0 1 1)<br>&gt; <br>&gt; struct Point { var (x, y) : (Double, Double) }<br>&gt; let p1 = Point(x: 2, y: 3)<br>&gt; let p2 = with(p1){ $0.y = 4 }<br>&gt; print(p1, p2) // Point(x: 2.0, y: 3.0) Point(x: 2.0, y: 4.0)<br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this proposal<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/bcad2678/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 25, 2016 at 02:00:00pm</p></header><div class="content"><p>On May 25, 2016, at 2:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 3:48 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this pretty well, and I think &quot;with()&quot; makes sense as a peer of &quot;withUnsafePointer()&quot;, &quot;withExtendedLifetime()&quot;, etc.<br>&gt;&gt; <br>&gt;&gt; I&#39;d also be okay with waiting for a comprehensive method-cascading solution. I don&#39;t find this issue particularly urgent, because it&#39;s pretty easily solvable with an extension or just using closures.<br>&gt; <br>&gt; +1.  I’ve been playing around with it in my own code a little bit.  I’m still uncertain about when I think it is good style and when I think it is best avoided.  I would certainly feel more comfortable using it if it was in the standard library.  <br>&gt; <br>&gt; At the same time, I think we can and should do better in the future.  If that is the plan, do we really want `with` in the standard library?  I don’t mind waiting for a better solution, especially if it means a better solution is more likely to happen and / or we aren’t left with an unnecessary and duplicative function in the standard library.<br>&gt; <br>&gt; So I’m on the fence here.  <br></p><p>I wouldn&#39;t be pushing if I thought it wouldn&#39;t be useful after cascading. If no other reason, it offers a way to duplicate/modify value types to be stored into constants. That alone should argue for its value.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/6b5c029d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 3:56 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 25, 2016, at 2:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 3:48 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this pretty well, and I think &quot;with()&quot; makes sense as a peer of &quot;withUnsafePointer()&quot;, &quot;withExtendedLifetime()&quot;, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d also be okay with waiting for a comprehensive method-cascading solution. I don&#39;t find this issue particularly urgent, because it&#39;s pretty easily solvable with an extension or just using closures.<br>&gt;&gt; <br>&gt;&gt; +1.  I’ve been playing around with it in my own code a little bit.  I’m still uncertain about when I think it is good style and when I think it is best avoided.  I would certainly feel more comfortable using it if it was in the standard library.  <br>&gt;&gt; <br>&gt;&gt; At the same time, I think we can and should do better in the future.  If that is the plan, do we really want `with` in the standard library?  I don’t mind waiting for a better solution, especially if it means a better solution is more likely to happen and / or we aren’t left with an unnecessary and duplicative function in the standard library.<br>&gt;&gt; <br>&gt;&gt; So I’m on the fence here.  <br>&gt; <br>&gt; I wouldn&#39;t be pushing if I thought it wouldn&#39;t be useful after cascading. If no other reason, it offers a way to duplicate/modify value types to be stored into constants. That alone should argue for its value.<br></p><p>Can you point us to the latest draft of what you have in mind for cascading in the future?  <br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/e384385d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 3:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; On May 25, 2016, at 3:56 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; I wouldn&#39;t be pushing if I thought it wouldn&#39;t be useful after cascading. If no other reason, it offers a way to duplicate/modify value types to be stored into constants. That alone should argue for its value.<br>&gt; <br>&gt; Can you point us to the latest draft of what you have in mind for cascading in the future?  <br></p><p>Haven&#39;t really touched it since I got the &quot;sit and wait&quot; but I&#39;ve come around to preferring Dartism.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/27aede24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 4:31 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 3:29 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; On May 25, 2016, at 3:56 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I wouldn&#39;t be pushing if I thought it wouldn&#39;t be useful after cascading. If no other reason, it offers a way to duplicate/modify value types to be stored into constants. That alone should argue for its value.<br>&gt;&gt; <br>&gt;&gt; Can you point us to the latest draft of what you have in mind for cascading in the future?  <br>&gt; <br>&gt; Haven&#39;t really touched it since I got the &quot;sit and wait&quot; but I&#39;ve come around to preferring Dartism.<br></p><p>Got it.  I just looked up how Dart does this to refresh my memory.  <br></p><p>Are there cases where you think `with` would be a better option than method cascading other than the copy scenario?  <br></p><p>I think there are several ways we could handle the “copy and modify a value type” use case better than `with`.  The most obvious: if the primary reason for `with` to exist post-method cascading is to introduce a copy, I would prefer a `copy` function that could be used in conjunction with method cascading (which would then mutate and return the copy rather than the initial instance).<br></p><p>Brent’s example would go from:<br></p><p>	extension FloatingPoint {<br>		func adding(_ other: Self) -&gt; Self {<br>			return with(self) { $0.add(other) }<br>		}<br>	}<br></p><p>to: <br></p><p>	extension FloatingPoint {<br>		func adding(_ other: Self) -&gt; Self {<br>			return copy(self)..add(other)<br>		}<br>	}<br></p><p>This reads much better than the former IMO.<br></p><p>I’m interested in hearing about use cases where `with` is superior to method cascading plus `copy`.  I think that is the minimum bar that should be crossed if we’re going to add this to the standard library.  <br></p><p>I’m not opposed to it on principle, but I want to make sure it carries its weight long term if we put it in the standard library.  It’s easy enough to copy into our projects if it’s not there and we feel the need to use it.<br></p><p><br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/012879f1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 25 mai 2016 à 14:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt; <br>&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae<br>&gt; <br>&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt; Feedback as always welcome, including criticism.<br></p><p>Recently there was another possible &#39;with&#39; variant:<br>- instead of being a: with &#39;instance&#39; create new &#39;instance&#39; using &#39;closure&#39;<br>- it was a: with(/on) &#39;instance/s&#39; perform &#39;closure&#39; (same idea as the closure-based initialization, described in the motivation)<br></p><p>The thread &quot;What about a VBA style with Statement?&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384<br></p><p>In either case the &#39;with&#39; can be misleading/confusing; with, on its own doesn&#39;t suggest creation of a new entity, nor does it strongly suggest possible mutation.<br></p><p>Just mentioning it as to end up... with the proper name for this new function.<br></p><p>Dany<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/6ad04908/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>On May 25, 2016, at 5:34 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt; Le 25 mai 2016 à 14:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt;&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt;&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae &lt;https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae&gt;<br>&gt;&gt; <br>&gt;&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt;&gt; Feedback as always welcome, including criticism.<br>&gt;&gt; <br>&gt; <br>&gt; Recently there was another possible &#39;with&#39; variant:<br>&gt; - instead of being a: with &#39;instance&#39; create new &#39;instance&#39; using &#39;closure&#39;<br>&gt; - it was a: with(/on) &#39;instance/s&#39; perform &#39;closure&#39; (same idea as the closure-based initialization, described in the motivation)<br>&gt; <br>&gt; The thread &quot;What about a VBA style with Statement?&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br>&gt; <br>&gt; In either case the &#39;with&#39; can be misleading/confusing; with, on its own doesn&#39;t suggest creation of a new entity, nor does it strongly suggest possible mutation.<br>&gt; <br>&gt; Just mentioning it as to end up... with the proper name for this new function.<br>&gt; <br>&gt; Dany<br>&gt; <br></p><p>Naming can always be bikeshedded. <br>Brent&#39;s submitted a pull request: https://github.com/apple/swift-evolution/pull/346<br>Here&#39;s a gist: https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb<br>The current state of the proposal follows <br>-- E<br></p><p>Introducing with to the Standard Library<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;, Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#introduction&gt;Introduction<br></p><p>This proposal introduces a with function to the standard library. This function simplifies the initialization of objects and modification of value types.<br></p><p>Swift-evolution thread: What about a VBA style with Statement? &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384&gt;<br> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#motivation&gt;Motivation<br></p><p>When setting up or modifying an instance, developers sometimes use an immediately-called closure to introduce a short alias for the instance and group the modification code together. For example, they may initialize and customize a Cocoa object:<br></p><p>let questionLabel: UILabel = {<br>    $0.textAlignment = .Center<br>    $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    $0.text = questionText<br>    $0.numberOfLines = 0<br>    mainView.addSubview($0)<br>    return $0<br>}(UILabel())<br>Or they may duplicate and modify a constant value-typed instance:<br></p><p>let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>let jane: Person = { (var copy) in<br>    copy.name = &quot;Jane&quot;<br>    return copy<br>}(john)<br>This technique has many drawbacks:<br></p><p>The compiler cannot infer the return type.<br>You must explicitly return the modified instance.<br>The instance being used comes after, not before, the code using it.<br>Nevertheless, developers have created many variations on this theme, because they are drawn to its benefits:<br></p><p>The short, temporary name reduces noise compared to repeating a variable name like questionLabel.<br>The block groups together the initialization code.<br>The scope of mutability is limited.<br>SE-0003, which removes var parameters &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md&gt;, will make this situation even worse by requiring a second line of boilerplate for value types. And yet developers will probably keep using these sorts of tricks.<br></p><p>Fundamentally, this is a very simple and common pattern: creating a temporary mutable variable confined to a short scope, whose value will later be used immutably in a wider scope. Moreover, this pattern shortens the scopes of mutable variables, so it is something we should encourage. We believe it&#39;s worth codifying in the standard library.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#proposed-solution&gt;Proposed Solution<br></p><p>We propose introducing a function with the following simplified signature:<br></p><p>func with&lt;T&gt;(_: T, update: (inout T -&gt; Void)) -&gt; T<br>with assigns the value to a new variable, passes that variable as a parameter to the closure, and then returns the potentially modified variable. That means:<br></p><p>When used with value types, the closure can modify a copy of the original value.<br>When used with reference types, the closure can substitute a different instance for the original, perhaps by calling copy() or some non-Cocoa equivalent.<br>The closure does not actually have to modify the parameter; it can merely use it, or (for a reference type) modify the object without changing the reference.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#examples&gt;Examples<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#initializing-a-cocoa-object&gt;Initializing a Cocoa Object<br></p><p>Before:<br></p><p>let questionLabel: UILabel = {<br>    $0.textAlignment = .Center<br>    $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    $0.text = questionText<br>    $0.numberOfLines = 0<br>    mainView.addSubview($0)<br>    return $0<br>}(UILabel())<br>After:<br></p><p>let questionLabel = with(UILabel()) {<br>    $0.textAlignment = .Center<br>    $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    $0.text = questionText<br>    $0.numberOfLines = 0<br>    mainView.addSubview($0)<br>}<br>Using with here moves the UILabel() initialization to the top, allows the type of questionLabel to be inferred, and removes the return statement.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#copying-and-modifying-a-constant&gt;Copying and Modifying a Constant<br></p><p>Before (without var parameter):<br></p><p>let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>let jane: Person = {<br>    var copy = $0<br>    copy.name = &quot;Jane&quot;<br>    return copy<br>}(john)<br>After:<br></p><p>let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>let jane = with(john) {<br>    $0.name = &quot;Jane&quot;<br>}<br>In addition to the aforementioned benefits, with removes the var copy line.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#treating-a-mutable-method-as-a-copy-and-return-method&gt;Treating a Mutable Method As a Copy-and-Return Method<br></p><p>You would like to write this:<br></p><p>let fewerFoos = foos.removing(at: i)<br>But there is only a remove(at:) mutating method. Using with, you can write:<br></p><p>let fewerFoos = with(foos) { $0.remove(at: i) }<br> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#avoiding-mutable-shadowing&gt;Avoiding Mutable Shadowing<br></p><p>The standard library includes an operator &lt;https://github.com/apple/swift/blob/690d98a078a214557cd8f731b6215336bbc18a77/stdlib/public/core/RangeReplaceableCollection.swift.gyb#L1169&gt; for concatenating two RangeReplaceableCollections with this implementation:<br></p><p>var lhs = lhs<br>// FIXME: what if lhs is a reference type?  This will mutate it.<br>lhs.reserveCapacity(lhs.count + numericCast(rhs.count))<br>lhs.append(contentsOf: rhs)<br>return lhs<br>Using with, you can eliminate the shadowing of lhs:<br></p><p>// FIXME: what if lhs is a reference type?  This will mutate it.<br>return with(lhs) {<br>  $0.reserveCapacity($0.count + numericCast(rhs.count))<br>  $0.append(contentsOf: rhs)<br>}<br>It&#39;s important to note that with does not resolve the &quot;FIXME&quot; comment. Like the var lhs = lhs in the original code, with only copies value types, not reference types. If RangeReplaceableCollection included a Foundation-like copy()method that was guaranteed to return a copy even if it was a reference type, with would work nicely with that solution:<br></p><p>return with(lhs.copy()) {<br>  $0.reserveCapacity($0.count + numericCast(rhs.count))<br>  $0.append(contentsOf: rhs)<br>}<br> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#inspecting-an-intermediate-value&gt;Inspecting an Intermediate Value<br></p><p>Suppose you want to inspect a value in the middle of a long method chain. For instance, you&#39;re not sure this is retrieving the type of cell you expect:<br></p><p>let view = tableView.cellForRow(at: indexPath)?.contentView.withTag(42)<br>Currently, you would need to either split the statement in two so you could capture the return value of cellForRow(at:) in a constant, or insert a very clunky immediate-closure call in the middle of the statement. Using with, you can stay close to the original expression:<br></p><p>let view = with(tableView.cellForRow(at: indexPath)) { print($0) }?.contentView.withTag(42)<br>Because the closure doesn&#39;t alter $0, the cell passes through the with call unaltered, so it can be used by the rest of the method chain.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#detailed-design&gt;Detailed Design<br></p><p>We propose adding the following free function to the standard library:<br></p><p>/// Returns `item` after calling `update` to inspect and possibly <br>/// modify it.<br>/// <br>/// If `T` is a value type, `update` uses an independent copy <br>/// of `item`. If `T` is a reference type, `update` uses the <br>/// same instance passed in, but it can substitute a different <br>/// instance by setting its parameter to a new value.<br>@discardableResult<br>public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>  var this = item<br>  try update(&amp;this)<br>  return this<br>}<br>@discardableResult permits the use of with(_:update:) to create a scoped temporary copy of the value with a shorter name.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is purely additive and has no impact on existing code.<br></p><p> &lt;https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb#alternatives-considered&gt;Alternatives Considered<br></p><p>Doing nothing: with is a mere convenience; any code using it could be written another way. If rejected, users could continue to write code using the longhand form, the various closure-based techniques, or homegrown versions of with.<br></p><p>Using method syntax: Some list members preferred a syntax that looked more like a method call with a trailing closure:<br></p><p>let questionLabel = UILabel().with {<br>    $0.textAlignment = .Center<br>    $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    $0.numberOfLines = 0<br>    addSubview($0)<br>}<br>This would require a more drastic solution as it&#39;s not possible to add methods to all Swift types. Nor does it match the existing design of functions like withExtendedLifetime(_:_:), withUnsafePointer(_:_:), and reflect(_:).<br></p><p>Adding self rebinding: Some list members wanted a way to bind self to the passed argument, so that they can use implicit self to eliminate $0.:<br></p><p>let supView = self<br>let questionLabel = with(UILabel()) { <br>    self in<br>    textAlignment = .Center<br>    font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    numberOfLines = 0<br>    supView.addSubview(self)<br>}<br>We do not believe this is practical to propose in the Swift 3 timeframe, and we believe with would work well with this feature if it were added later.<br></p><p>Adding method cascades: A competing proposal was to introduce a way to use several methods or properties on the same instance; Dart and Smalltalk have features of this kind.<br></p><p>let questionLabel = UILabel()<br>    ..textAlignment = .Center<br>    ..font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>    ..numberOfLines = 0<br>addSubview(questionLabel)<br>Like rebinding self, we do not believe method cascades are practical for the Swift 3 timeframe. We also believe that many of with&#39;s use cases would not be subsumed by method cascades even if they were added.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/dc225a12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; Just mentioning it as to end up... with the proper name for this new function.<br>&gt; <br>&gt; Naming can always be bikeshedded. <br></p><p>One possibility is to split `with` in two:<br></p><p>- A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br></p><p>- A `withVar` whose parameter *is* mutable and which is *not* marked `@discardableResult`. (This would help with the fact that our use of `@discardableResult` is a little dangerous, in that people might expect mutations to affect the original variable even if it&#39;s a value type.)<br></p><p>`withVar` does, I think, make it pretty clear that you&#39;re working with a copy of the variable.<br></p><p>	/// Returns `item` after calling `use` to inspect it.<br>	/// <br>	/// If `T` is a value type, `use` is unable to mutate `item`.<br>	/// If `T` is a reference type, `use` may use members which <br>	/// change `item`, but cannot assign a different instance.<br>	@discardableResult<br>	public func with&lt;T&gt;(_ item: T, use: @noescape (T) throws -&gt; Void) rethrows -&gt; T {<br>	  try use(item)<br>	  return item<br>	}<br>	<br>	/// Returns `item` after calling `update` to inspect and possibly <br>	/// modify it.<br>	/// <br>	/// If `T` is a value type, `update` uses an independent copy <br>	/// of `item`. If `T` is a reference type, `update` uses the <br>	/// same instance passed in, but it can substitute a different <br>	/// instance by setting its parameter to a new value.<br>	public func withVar&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>	  var this = item<br>	  try update(&amp;this)<br>	  return this<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 5:12 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Just mentioning it as to end up... with the proper name for this new function.<br>&gt;&gt; <br>&gt;&gt; Naming can always be bikeshedded. <br>&gt; <br>&gt; One possibility is to split `with` in two:<br></p><p>I much prefer this direction.<br></p><p>&gt; <br>&gt; - A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br></p><p>I would like to see this version restricted to AnyObject.  It has extremely limited utility with value types.  It would usually be a mistake to call it with a value type.<br></p><p>If we want a non-copying version that works with value types it should look like this:<br></p><p>@discardableResult<br>public func with&lt;T&gt;(_ item: inout T, use: @noescape (inout T) throws -&gt; Void) rethrows {<br>    try use(&amp;item)<br>}<br></p><p>That said, I am not convinced these non-copying functions would be worth having after method cascades are introduced.  Are there any use cases left for them in that future?<br></p><p>&gt; <br>&gt; - A `withVar` whose parameter *is* mutable and which is *not* marked `@discardableResult`. (This would help with the fact that our use of `@discardableResult` is a little dangerous, in that people might expect mutations to affect the original variable even if it&#39;s a value type.)<br>&gt; <br>&gt; `withVar` does, I think, make it pretty clear that you&#39;re working with a copy of the variable.<br></p><p>One thing to consider in choosing a name here is the cases where this function would still be useful in a future that includes method cascades.  The one thing this function does that method cascades don’t is make a copy of the value before operating on it and returning it.  <br></p><p>With that in mind, I think it is worthwhile to consider the name `withCopy` and make the closure argument optional.<br></p><p>public func withCopy&lt;T&gt;(_ item: T, update: (@noescape (inout T) throws -&gt; Void)?) rethrows -&gt; T {<br>    var this = item<br>    try update?(&amp;this)<br>    return this<br>}<br></p><p>This function would be more clear and useful in conjunction with method cascades:<br></p><p>let bar = withCopy(foo)<br>    ..cascaded = “value&quot;<br>    ..operations()<br>    ..onFoo()<br></p><p><br></p><p>&gt; <br>&gt; 	/// Returns `item` after calling `use` to inspect it.<br>&gt; 	/// <br>&gt; 	/// If `T` is a value type, `use` is unable to mutate `item`.<br>&gt; 	/// If `T` is a reference type, `use` may use members which <br>&gt; 	/// change `item`, but cannot assign a different instance.<br>&gt; 	@discardableResult<br>&gt; 	public func with&lt;T&gt;(_ item: T, use: @noescape (T) throws -&gt; Void) rethrows -&gt; T {<br>&gt; 	  try use(item)<br>&gt; 	  return item<br>&gt; 	}<br>&gt; 	<br>&gt; 	/// Returns `item` after calling `update` to inspect and possibly <br>&gt; 	/// modify it.<br>&gt; 	/// <br>&gt; 	/// If `T` is a value type, `update` uses an independent copy <br>&gt; 	/// of `item`. If `T` is a reference type, `update` uses the <br>&gt; 	/// same instance passed in, but it can substitute a different <br>&gt; 	/// instance by setting its parameter to a new value.<br>&gt; 	public func withVar&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>&gt; 	  var this = item<br>&gt; 	  try update(&amp;this)<br>&gt; 	  return this<br>&gt; 	}<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; - A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br>&gt; <br>&gt; I would like to see this version restricted to AnyObject.  It has extremely limited utility with value types.  It would usually be a mistake to call it with a value type.<br></p><p>I would not. It gives you a way to give a value type a short, scoped, immutable alias:<br></p><p>	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>		print($0.turns)<br>		print($0.turnSpeed)<br>	}<br></p><p>And in this form, there is no danger of mistakenly mutating the value type, because mutating methods would not be allowed:<br></p><p>	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>		$0.turnRepeatedly(times: 3)	// Error: can&#39;t call mutating method on immutable parameter<br>	}<br></p><p>To be clear, I&#39;m not convinced there&#39;s a need to make any change from the proposed version at all. I&#39;m spitballing alternate designs here, trying to see if there might be something a little better out there. But so far, I think the proposal balances the feature size against strictness pretty well, whereas these stricter designs I&#39;m discussing increase the surface of the feature more than they improve it. This is a small (but significant!) convenience, and I feel pretty strongly that it should have a small implementation.<br></p><p>&gt; That said, I am not convinced these non-copying functions would be worth having after method cascades are introduced.  Are there any use cases left for them in that future?<br></p><p>Yes, absolutely. Method cascades have a narrow use case: methods on `self`. Not everything in Swift is a method, and not all methods are on `self`.<br></p><p>	with(tableView.cellForRow(at: indexPath).myLabel) { label in<br>		print(&quot;Constraining label: \(label)&quot;)<br>		<br>		NSLayoutConstraint.activate(<br>			NSLayoutConstraint.withVisualFormat(&quot;|-[label]-|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label]) +<br>			NSLayoutConstraint.withVisualFormat(&quot;V:|[label]|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label])<br>		)<br>		<br>		constrainedLabels.append(label)<br>	}<br></p><p>None of the calls in that `with` block would benefit from method cascades, but they all benefit from `with`.<br></p><p>&gt;&gt; - A `withVar` whose parameter *is* mutable and which is *not* marked `@discardableResult`. (This would help with the fact that our use of `@discardableResult` is a little dangerous, in that people might expect mutations to affect the original variable even if it&#39;s a value type.)<br>&gt;&gt; <br>&gt;&gt; `withVar` does, I think, make it pretty clear that you&#39;re working with a copy of the variable.<br>&gt; <br>&gt; One thing to consider in choosing a name here is the cases where this function would still be useful in a future that includes method cascades.  The one thing this function does that method cascades don’t is make a copy of the value before operating on it and returning it.  <br>&gt; <br>&gt; With that in mind, I think it is worthwhile to consider the name `withCopy` and make the closure argument optional.<br></p><p>I specifically considered and rejected `withCopy` because it only creates a copy of a value type, not a reference type. (Of course, it does create a copy of the reference itself, but that&#39;s a very subtle distinction.) I chose `withVar` to make it very clear that you&#39;re getting the same semantics as you would for a `var` temporary.<br></p><p>&gt; public func withCopy&lt;T&gt;(_ item: T, update: (@noescape (inout T) throws -&gt; Void)?) rethrows -&gt; T {<br>&gt;    var this = item<br>&gt;    try update?(&amp;this)<br>&gt;    return this<br>&gt; }<br>&gt; <br>&gt; This function would be more clear and useful in conjunction with method cascades:<br>&gt; <br>&gt; let bar = withCopy(foo)<br>&gt;    ..cascaded = “value&quot;<br>&gt;    ..operations()<br>&gt;    ..onFoo()<br></p><p>Honestly, I&#39;m not sure there&#39;s a coherent way to make method cascades work with your `withCopy` (or the `copy` function you mentioned upthread) at all.<br></p><p>Here&#39;s the problem. Suppose you have a property like this:<br></p><p>	var array: [Int]<br></p><p>And then you write this:<br></p><p>	array = [1, 2, 3]<br>	return array<br>			..remove(at: 1)<br>			..remove(at: 0)<br></p><p>I assume you think this should not only *return* `[3]`, but also *set* `array` to `[3]`. That&#39;s kind of implied by the fact that you think we need a `withCopy(array)` call to protect `array` from being affected by these calls.<br></p><p>But that means that in this version:<br></p><p>	array = [1, 2, 3]<br>	return withCopy(array)<br>			..remove(at: 1)<br>			..remove(at: 0)<br></p><p>You are trying to call `mutating` methods on an *immutable* value, the return value of `withCopy`. Normally, the compiler would reject that.<br></p><p>Perhaps you could say that method cascades operate on a copy if the receiver is immutable, but that makes code vague and its behavior subtle and easily changed by accident. For instance, if a property is `internal private(set)`, then moving a method cascade from code which can&#39;t see the setter to code which can would silently change the code from immutable to mutable. Similarly, adding the `private(set)` would not cause the code which previously modified it to produce an error; it would instead silently change to no longer mutate where it used to before. That&#39;s not acceptable behavior from a language feature.<br></p><p>About the only solution to this I can come up with is to make `withCopy` have an `inout` return. But this at best forms an attractive nuisance: If you use normal `mutating` method calls instead of method cascading, your changes are going to disappear into the ether. And depending on how `inout` returns are actually implemented, it could lead to worse misbehavior.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Just some alternate naming suggestions for with() and withVar(), as the naming guidelines suggest -ed/-ing:<br></p><p>withVar<br>altered() // Changes a value copy / reference and returns it<br>mutated() // Or this, but uses value-specific term ‘mutate’<br></p><p>with<br>inspect() // Works with an immutable copy, has @discardableResult<br>use()<br></p><p><br>&gt; On 28 May 2016, at 10:19 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; - A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br>&gt;&gt; <br>&gt;&gt; I would like to see this version restricted to AnyObject.  It has extremely limited utility with value types.  It would usually be a mistake to call it with a value type.<br>&gt; <br>&gt; I would not. It gives you a way to give a value type a short, scoped, immutable alias:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		print($0.turns)<br>&gt; 		print($0.turnSpeed)<br>&gt; 	}<br>&gt; <br>&gt; And in this form, there is no danger of mistakenly mutating the value type, because mutating methods would not be allowed:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		$0.turnRepeatedly(times: 3)	// Error: can&#39;t call mutating method on immutable parameter<br>&gt; 	}<br>&gt; <br>&gt; To be clear, I&#39;m not convinced there&#39;s a need to make any change from the proposed version at all. I&#39;m spitballing alternate designs here, trying to see if there might be something a little better out there. But so far, I think the proposal balances the feature size against strictness pretty well, whereas these stricter designs I&#39;m discussing increase the surface of the feature more than they improve it. This is a small (but significant!) convenience, and I feel pretty strongly that it should have a small implementation.<br>&gt; <br>&gt;&gt; That said, I am not convinced these non-copying functions would be worth having after method cascades are introduced.  Are there any use cases left for them in that future?<br>&gt; <br>&gt; Yes, absolutely. Method cascades have a narrow use case: methods on `self`. Not everything in Swift is a method, and not all methods are on `self`.<br>&gt; <br>&gt; 	with(tableView.cellForRow(at: indexPath).myLabel) { label in<br>&gt; 		print(&quot;Constraining label: \(label)&quot;)<br>&gt; 		<br>&gt; 		NSLayoutConstraint.activate(<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;|-[label]-|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label]) +<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;V:|[label]|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label])<br>&gt; 		)<br>&gt; 		<br>&gt; 		constrainedLabels.append(label)<br>&gt; 	}<br>&gt; <br>&gt; None of the calls in that `with` block would benefit from method cascades, but they all benefit from `with`.<br>&gt; <br>&gt;&gt;&gt; - A `withVar` whose parameter *is* mutable and which is *not* marked `@discardableResult`. (This would help with the fact that our use of `@discardableResult` is a little dangerous, in that people might expect mutations to affect the original variable even if it&#39;s a value type.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `withVar` does, I think, make it pretty clear that you&#39;re working with a copy of the variable.<br>&gt;&gt; <br>&gt;&gt; One thing to consider in choosing a name here is the cases where this function would still be useful in a future that includes method cascades.  The one thing this function does that method cascades don’t is make a copy of the value before operating on it and returning it.  <br>&gt;&gt; <br>&gt;&gt; With that in mind, I think it is worthwhile to consider the name `withCopy` and make the closure argument optional.<br>&gt; <br>&gt; I specifically considered and rejected `withCopy` because it only creates a copy of a value type, not a reference type. (Of course, it does create a copy of the reference itself, but that&#39;s a very subtle distinction.) I chose `withVar` to make it very clear that you&#39;re getting the same semantics as you would for a `var` temporary.<br>&gt; <br>&gt;&gt; public func withCopy&lt;T&gt;(_ item: T, update: (@noescape (inout T) throws -&gt; Void)?) rethrows -&gt; T {<br>&gt;&gt;   var this = item<br>&gt;&gt;   try update?(&amp;this)<br>&gt;&gt;   return this<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This function would be more clear and useful in conjunction with method cascades:<br>&gt;&gt; <br>&gt;&gt; let bar = withCopy(foo)<br>&gt;&gt;   ..cascaded = “value&quot;<br>&gt;&gt;   ..operations()<br>&gt;&gt;   ..onFoo()<br>&gt; <br>&gt; Honestly, I&#39;m not sure there&#39;s a coherent way to make method cascades work with your `withCopy` (or the `copy` function you mentioned upthread) at all.<br>&gt; <br>&gt; Here&#39;s the problem. Suppose you have a property like this:<br>&gt; <br>&gt; 	var array: [Int]<br>&gt; <br>&gt; And then you write this:<br>&gt; <br>&gt; 	array = [1, 2, 3]<br>&gt; 	return array<br>&gt; 			..remove(at: 1)<br>&gt; 			..remove(at: 0)<br>&gt; <br>&gt; I assume you think this should not only *return* `[3]`, but also *set* `array` to `[3]`. That&#39;s kind of implied by the fact that you think we need a `withCopy(array)` call to protect `array` from being affected by these calls.<br>&gt; <br>&gt; But that means that in this version:<br>&gt; <br>&gt; 	array = [1, 2, 3]<br>&gt; 	return withCopy(array)<br>&gt; 			..remove(at: 1)<br>&gt; 			..remove(at: 0)<br>&gt; <br>&gt; You are trying to call `mutating` methods on an *immutable* value, the return value of `withCopy`. Normally, the compiler would reject that.<br>&gt; <br>&gt; Perhaps you could say that method cascades operate on a copy if the receiver is immutable, but that makes code vague and its behavior subtle and easily changed by accident. For instance, if a property is `internal private(set)`, then moving a method cascade from code which can&#39;t see the setter to code which can would silently change the code from immutable to mutable. Similarly, adding the `private(set)` would not cause the code which previously modified it to produce an error; it would instead silently change to no longer mutate where it used to before. That&#39;s not acceptable behavior from a language feature.<br>&gt; <br>&gt; About the only solution to this I can come up with is to make `withCopy` have an `inout` return. But this at best forms an attractive nuisance: If you use normal `mutating` method calls instead of method cascading, your changes are going to disappear into the ether. And depending on how `inout` returns are actually implemented, it could lead to worse misbehavior.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/66f9ff0c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 7:19 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; - A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br>&gt;&gt; <br>&gt;&gt; I would like to see this version restricted to AnyObject.  It has extremely limited utility with value types.  It would usually be a mistake to call it with a value type.<br>&gt; <br>&gt; I would not. It gives you a way to give a value type a short, scoped, immutable alias:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		print($0.turns)<br>&gt; 		print($0.turnSpeed)<br>&gt; 	}<br>&gt; <br>&gt; And in this form, there is no danger of mistakenly mutating the value type, because mutating methods would not be allowed:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		$0.turnRepeatedly(times: 3)	// Error: can&#39;t call mutating method on immutable parameter<br>&gt; 	}<br>&gt; <br>&gt; To be clear, I&#39;m not convinced there&#39;s a need to make any change from the proposed version at all. I&#39;m spitballing alternate designs here, trying to see if there might be something a little better out there. But so far, I think the proposal balances the feature size against strictness pretty well, whereas these stricter designs I&#39;m discussing increase the surface of the feature more than they improve it. This is a small (but significant!) convenience, and I feel pretty strongly that it should have a small implementation.<br>&gt; <br>&gt;&gt; That said, I am not convinced these non-copying functions would be worth having after method cascades are introduced.  Are there any use cases left for them in that future?<br>&gt; <br>&gt; Yes, absolutely. Method cascades have a narrow use case: methods on `self`. Not everything in Swift is a method, and not all methods are on `self`.<br>&gt; <br>&gt; 	with(tableView.cellForRow(at: indexPath).myLabel) { label in<br>&gt; 		print(&quot;Constraining label: \(label)&quot;)<br>&gt; 		<br>&gt; 		NSLayoutConstraint.activate(<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;|-[label]-|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label]) +<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;V:|[label]|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label])<br>&gt; 		)<br>&gt; 		<br>&gt; 		constrainedLabels.append(label)<br>&gt; 	}<br>&gt; <br>&gt; None of the calls in that `with` block would benefit from method cascades, but they all benefit from `with`.<br>&gt; <br>&gt;&gt;&gt; - A `withVar` whose parameter *is* mutable and which is *not* marked `@discardableResult`. (This would help with the fact that our use of `@discardableResult` is a little dangerous, in that people might expect mutations to affect the original variable even if it&#39;s a value type.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `withVar` does, I think, make it pretty clear that you&#39;re working with a copy of the variable.<br>&gt;&gt; <br>&gt;&gt; One thing to consider in choosing a name here is the cases where this function would still be useful in a future that includes method cascades.  The one thing this function does that method cascades don’t is make a copy of the value before operating on it and returning it.  <br>&gt;&gt; <br>&gt;&gt; With that in mind, I think it is worthwhile to consider the name `withCopy` and make the closure argument optional.<br>&gt; <br>&gt; I specifically considered and rejected `withCopy` because it only creates a copy of a value type, not a reference type. (Of course, it does create a copy of the reference itself, but that&#39;s a very subtle distinction.) I chose `withVar` to make it very clear that you&#39;re getting the same semantics as you would for a `var` temporary.<br>&gt; <br>&gt;&gt; public func withCopy&lt;T&gt;(_ item: T, update: (@noescape (inout T) throws -&gt; Void)?) rethrows -&gt; T {<br>&gt;&gt;   var this = item<br>&gt;&gt;   try update?(&amp;this)<br>&gt;&gt;   return this<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This function would be more clear and useful in conjunction with method cascades:<br>&gt;&gt; <br>&gt;&gt; let bar = withCopy(foo)<br>&gt;&gt;   ..cascaded = “value&quot;<br>&gt;&gt;   ..operations()<br>&gt;&gt;   ..onFoo()<br>&gt; <br>&gt; Honestly, I&#39;m not sure there&#39;s a coherent way to make method cascades work with your `withCopy` (or the `copy` function you mentioned upthread) at all.<br>&gt; <br>&gt; Here&#39;s the problem. Suppose you have a property like this:<br>&gt; <br>&gt; 	var array: [Int]<br>&gt; <br>&gt; And then you write this:<br>&gt; <br>&gt; 	array = [1, 2, 3]<br>&gt; 	return array<br>&gt; 			..remove(at: 1)<br>&gt; 			..remove(at: 0)<br>&gt; <br>&gt; I assume you think this should not only *return* `[3]`, but also *set* `array` to `[3]`. That&#39;s kind of implied by the fact that you think we need a `withCopy(array)` call to protect `array` from being affected by these calls.<br>&gt; <br>&gt; But that means that in this version:<br>&gt; <br>&gt; 	array = [1, 2, 3]<br>&gt; 	return withCopy(array)<br>&gt; 			..remove(at: 1)<br>&gt; 			..remove(at: 0)<br>&gt; <br>&gt; You are trying to call `mutating` methods on an *immutable* value, the return value of `withCopy`. Normally, the compiler would reject that.<br></p><p>You are right, there would need to be an exception for method cascades.  That might be a reasonable exception to make because we already know the temporary is not just the subject of mutation but also the result of the expression.  The method cascade just operates on the temporary in-place before being used in the surrounding expression or statement .<br></p><p>&gt; <br>&gt; Perhaps you could say that method cascades operate on a copy if the receiver is immutable<br></p><p>This isn’t necessary with the previously mentioned exception for allowing mutating method cascades on temporaries.<br></p><p>&gt; , but that makes code vague and its behavior subtle and easily changed by accident. For instance, if a property is `internal private(set)`, then moving a method cascade from code which can&#39;t see the setter to code which can would silently change the code from immutable to mutable. Similarly, adding the `private(set)` would not cause the code which previously modified it to produce an error; it would instead silently change to no longer mutate where it used to before. That&#39;s not acceptable behavior from a language feature.<br>&gt; <br>&gt; About the only solution to this I can come up with is to make `withCopy` have an `inout` return. But this at best forms an attractive nuisance: If you use normal `mutating` method calls instead of method cascading, your changes are going to disappear into the ether. And depending on how `inout` returns are actually implemented, it could lead to worse misbehavior.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; You are trying to call `mutating` methods on an *immutable* value, the return value of `withCopy`. Normally, the compiler would reject that.<br>&gt; <br>&gt; You are right, there would need to be an exception for method cascades.  That might be a reasonable exception to make because we already know the temporary is not just the subject of mutation but also the result of the expression.  The method cascade just operates on the temporary in-place before being used in the surrounding expression or statement .<br>&gt; <br>&gt;&gt; Perhaps you could say that method cascades operate on a copy if the receiver is immutable<br>&gt; <br>&gt; This isn’t necessary with the previously mentioned exception for allowing mutating method cascades on temporaries.<br></p><p>I don&#39;t understand what you mean by &quot;temporary&quot;. Are you saying that Swift should distinguish between things which could be mutable but don&#39;t happen to be (variables and subscripts), and things which cannot ever be mutable (functions and methods)? Will this distinction hold up when we get `inout`-returning functions?<br></p><p>Basically, what principled rule makes Swift treat this:<br></p><p>	immutableVariable..mutatingMethod()<br></p><p>And this:<br></p><p>	functionCall()..mutatingMethod()<br></p><p>Differently?<br></p><p>Or is the distinction between this:<br></p><p>	immutableVariable..mutatingMethod()<br></p><p>And this:<br></p><p>	mutableVariable..mutatingMethod()<br></p><p>And if so, how is that not going to lead to bugs when people move code around?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 9:29 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; You are trying to call `mutating` methods on an *immutable* value, the return value of `withCopy`. Normally, the compiler would reject that.<br>&gt;&gt; <br>&gt;&gt; You are right, there would need to be an exception for method cascades.  That might be a reasonable exception to make because we already know the temporary is not just the subject of mutation but also the result of the expression.  The method cascade just operates on the temporary in-place before being used in the surrounding expression or statement .<br>&gt;&gt; <br>&gt;&gt;&gt; Perhaps you could say that method cascades operate on a copy if the receiver is immutable<br>&gt;&gt; <br>&gt;&gt; This isn’t necessary with the previously mentioned exception for allowing mutating method cascades on temporaries.<br>&gt; <br>&gt; I don&#39;t understand what you mean by &quot;temporary”.<br></p><p>I mean a return value.<br></p><p>&gt; Are you saying that Swift should distinguish between things which could be mutable but don&#39;t happen to be (variables and subscripts), and things which cannot ever be mutable (functions and methods)?<br></p><p>No.  I’m saying that whether the return value temporary is immutable or mutable is something the language defines (not something the user declares anywhere).  The language rules for method cascades could be defined such that they create a contextual type environment that allows the return value temporary to be mutable to allow the method cascade to operate on the temporary in place before it is used in the surrounding expression.  This makes sense for method cascades because by definition they return the original value.  It does not make sense for arbitrary operations because they will not return the original value.<br></p><p>Applying mutating method cascades to temporary value could be very handy.  You have an expression that returns a value and mutate the result before storing it in a binding or returning it from your function.  You can do this by binding the result to an explicit temporary and giving it a name.  Allowing you to do it with method cascades on the implicit temporary is great syntactic sugar and a big argument for making them work well with value types, not just reference types IMO.<br></p><p><br>&gt; Will this distinction hold up when we get `inout`-returning functions?<br></p><p>What I describe above would mean return values behave like a `var` argument used to (before they were removed) when the return value has a method cascade attached to it.  `inout` return values would work differently, writing back to the source storage.<br></p><p>&gt; <br>&gt; Basically, what principled rule makes Swift treat this:<br>&gt; <br>&gt; 	immutableVariable..mutatingMethod()<br>&gt; <br>&gt; And this:<br>&gt; <br>&gt; 	functionCall()..mutatingMethod()<br>&gt; <br>&gt; Differently?<br></p><p>The rule is that it is safe to mutate a return value temporary copy in place without impacting the semantics of any code that relies on immutability.  The mutation happens prior to any code getting a chance to do anything with the value.  The mutation is really part of the expression itself and the method cascade provides a safe syntactic and semantic environment for allowing this mutation.<br></p><p>&gt; <br>&gt; Or is the distinction between this:<br>&gt; <br>&gt; 	immutableVariable..mutatingMethod()<br>&gt; <br>&gt; And this:<br>&gt; <br>&gt; 	mutableVariable..mutatingMethod()<br>&gt; <br>&gt; And if so, how is that not going to lead to bugs when people move code around?<br></p><p>That distinction is absolutely critical.  The former is not allowed.  I am not suggesting allowing calling mutating methods on any `let` constants.  What I am saying is that the semantics of method cascades allow them to be safely used with return value temporaries even when they mutate the temporary.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>May 31, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On May 27, 2016, at 5:19 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; - A plain `with` whose closure parameter is not mutable and which is marked `@discardableResult`.<br>&gt;&gt; <br>&gt;&gt; I would like to see this version restricted to AnyObject.  It has extremely limited utility with value types.  It would usually be a mistake to call it with a value type.<br>&gt; <br>&gt; I would not. It gives you a way to give a value type a short, scoped, immutable alias:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		print($0.turns)<br>&gt; 		print($0.turnSpeed)<br>&gt; 	}<br>&gt; <br>&gt; And in this form, there is no danger of mistakenly mutating the value type, because mutating methods would not be allowed:<br>&gt; <br>&gt; 	with(RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]) {<br>&gt; 		$0.turnRepeatedly(times: 3)	// Error: can&#39;t call mutating method on immutable parameter<br>&gt; 	}<br>&gt; <br>&gt; To be clear, I&#39;m not convinced there&#39;s a need to make any change from the proposed version at all. I&#39;m spitballing alternate designs here, trying to see if there might be something a little better out there. But so far, I think the proposal balances the feature size against strictness pretty well, whereas these stricter designs I&#39;m discussing increase the surface of the feature more than they improve it. This is a small (but significant!) convenience, and I feel pretty strongly that it should have a small implementation.<br>&gt; <br>&gt;&gt; That said, I am not convinced these non-copying functions would be worth having after method cascades are introduced.  Are there any use cases left for them in that future?<br>&gt; <br>&gt; Yes, absolutely. Method cascades have a narrow use case: methods on `self`. Not everything in Swift is a method, and not all methods are on `self`.<br>&gt; <br>&gt; 	with(tableView.cellForRow(at: indexPath).myLabel) { label in<br>&gt; 		print(&quot;Constraining label: \(label)&quot;)<br>&gt; 		<br>&gt; 		NSLayoutConstraint.activate(<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;|-[label]-|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label]) +<br>&gt; 			NSLayoutConstraint.withVisualFormat(&quot;V:|[label]|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label])<br>&gt; 		)<br>&gt; 		<br>&gt; 		constrainedLabels.append(label)<br>&gt; 	}<br>&gt; <br>&gt; None of the calls in that `with` block would benefit from method cascades, but they all benefit from `with`.<br></p><p>What are the differences or benefits of the above examples over the existing `do { let ... }` form?<br></p><p>    do {<br>      let w = RareMagicalDeviceOwner.shared.spimsterWickets[randomIndex]<br>      print(w.turns)<br>      print(w.turnSpeed)<br>    }<br></p><p>    do {<br>      let label = tableView.cellForRow(at: indexPath).myLabel<br>      print(&quot;Constraining label: \(label)&quot;)<br>      NSLayoutConstraint.activate(<br>        NSLayoutConstraint.withVisualFormat(&quot;|-[label]-|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label]) +<br>        NSLayoutConstraint.withVisualFormat(&quot;V:|[label]|&quot;, options: [], metrics: [:], views: [&quot;label&quot;: label])<br>      )<br>      constrainedLabels.append(label)<br>    }<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Pitch] Circling back to `with`</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>May 27, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi,<br>I really like the proposal as it&#39;s in the last draft. And the examples are really good, specially the one that is similar to the Ruby tap.<br>I&#39;ve been using the Then extension for a while and makes the initialization much nicer. I also use a set of extensions that allow me to print intermediate objects in a chain of methods. Initially I was using it for FRP style but I ended up using it while developing on chain of functional methods on arrays. Is basically a specific implementation of what this proposal will generalize, which is cool.<br></p><p>My only concern is with the method cascading proposal. If that gets implement in the future how useful will this proposal be? I&#39;m not that familiar with method cascading to have a strong opinion on this, but I would like to see other members to speak about it.<br></p><p>Btw, thanks for adding the proposals directly in the email. Makes keeping up to date withthe list   much easier 👏🏻<br></p><p>Sent from my iPad<br></p><p>&gt; On 27 May 2016, at 20:42, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 25, 2016, at 5:34 PM, Dany St-Amant &lt;dsa.mls at icloud.com&gt; wrote:<br>&gt;&gt;&gt; Le 25 mai 2016 à 14:28, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Over the past couple of days, the Twitters have discovered some work I&#39;d done on closure-based setup. <br>&gt;&gt;&gt; It&#39;s clear that a demand is out there and strong for this kind of behavior, even without implicit `self` as <br>&gt;&gt;&gt; part of the mix or cascading. In that light, I&#39;ve put together the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/96d9c5bb4eaa3ed3b2ff82dc35aa8dae<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the community demand is this high, I think we should re-consider pushing it before 3. <br>&gt;&gt;&gt; Feedback as always welcome, including criticism.<br>&gt;&gt; <br>&gt;&gt; Recently there was another possible &#39;with&#39; variant:<br>&gt;&gt; - instead of being a: with &#39;instance&#39; create new &#39;instance&#39; using &#39;closure&#39;<br>&gt;&gt; - it was a: with(/on) &#39;instance/s&#39; perform &#39;closure&#39; (same idea as the closure-based initialization, described in the motivation)<br>&gt;&gt; <br>&gt;&gt; The thread &quot;What about a VBA style with Statement?&quot;: http://thread.gmane.org/gmane.comp.lang.swift.evolution/14384<br>&gt;&gt; <br>&gt;&gt; In either case the &#39;with&#39; can be misleading/confusing; with, on its own doesn&#39;t suggest creation of a new entity, nor does it strongly suggest possible mutation.<br>&gt;&gt; <br>&gt;&gt; Just mentioning it as to end up... with the proper name for this new function.<br>&gt;&gt; <br>&gt;&gt; Dany<br>&gt; <br>&gt; Naming can always be bikeshedded. <br>&gt; Brent&#39;s submitted a pull request: https://github.com/apple/swift-evolution/pull/346<br>&gt; Here&#39;s a gist: https://gist.github.com/brentdax/ce3272e3d35f5ccac56483666f86b8fb<br>&gt; The current state of the proposal follows <br>&gt; -- E<br>&gt; <br>&gt; Introducing with to the Standard Library<br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun, Brent Royal-Gordon<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces a with function to the standard library. This function simplifies the initialization of objects and modification of value types.<br>&gt; <br>&gt; Swift-evolution thread: What about a VBA style with Statement?<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; When setting up or modifying an instance, developers sometimes use an immediately-called closure to introduce a short alias for the instance and group the modification code together. For example, they may initialize and customize a Cocoa object:<br>&gt; <br>&gt; let questionLabel: UILabel = {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     mainView.addSubview($0)<br>&gt;     return $0<br>&gt; }(UILabel())<br>&gt; Or they may duplicate and modify a constant value-typed instance:<br>&gt; <br>&gt; let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>&gt; let jane: Person = { (var copy) in<br>&gt;     copy.name = &quot;Jane&quot;<br>&gt;     return copy<br>&gt; }(john)<br>&gt; This technique has many drawbacks:<br>&gt; <br>&gt; The compiler cannot infer the return type.<br>&gt; You must explicitly return the modified instance.<br>&gt; The instance being used comes after, not before, the code using it.<br>&gt; Nevertheless, developers have created many variations on this theme, because they are drawn to its benefits:<br>&gt; <br>&gt; The short, temporary name reduces noise compared to repeating a variable name like questionLabel.<br>&gt; The block groups together the initialization code.<br>&gt; The scope of mutability is limited.<br>&gt; SE-0003, which removes var parameters, will make this situation even worse by requiring a second line of boilerplate for value types. And yet developers will probably keep using these sorts of tricks.<br>&gt; <br>&gt; Fundamentally, this is a very simple and common pattern: creating a temporary mutable variable confined to a short scope, whose value will later be used immutably in a wider scope. Moreover, this pattern shortens the scopes of mutable variables, so it is something we should encourage. We believe it&#39;s worth codifying in the standard library.<br>&gt; <br>&gt; Proposed Solution<br>&gt; <br>&gt; We propose introducing a function with the following simplified signature:<br>&gt; <br>&gt; func with&lt;T&gt;(_: T, update: (inout T -&gt; Void)) -&gt; T<br>&gt; with assigns the value to a new variable, passes that variable as a parameter to the closure, and then returns the potentially modified variable. That means:<br>&gt; <br>&gt; When used with value types, the closure can modify a copy of the original value.<br>&gt; When used with reference types, the closure can substitute a different instance for the original, perhaps by calling copy() or some non-Cocoa equivalent.<br>&gt; The closure does not actually have to modify the parameter; it can merely use it, or (for a reference type) modify the object without changing the reference.<br>&gt; <br>&gt; Examples<br>&gt; <br>&gt; Initializing a Cocoa Object<br>&gt; <br>&gt; Before:<br>&gt; <br>&gt; let questionLabel: UILabel = {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     mainView.addSubview($0)<br>&gt;     return $0<br>&gt; }(UILabel())<br>&gt; After:<br>&gt; <br>&gt; let questionLabel = with(UILabel()) {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.text = questionText<br>&gt;     $0.numberOfLines = 0<br>&gt;     mainView.addSubview($0)<br>&gt; }<br>&gt; Using with here moves the UILabel() initialization to the top, allows the type of questionLabel to be inferred, and removes the return statement.<br>&gt; <br>&gt; Copying and Modifying a Constant<br>&gt; <br>&gt; Before (without var parameter):<br>&gt; <br>&gt; let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>&gt; let jane: Person = {<br>&gt;     var copy = $0<br>&gt;     copy.name = &quot;Jane&quot;<br>&gt;     return copy<br>&gt; }(john)<br>&gt; After:<br>&gt; <br>&gt; let john = Person(name: &quot;John&quot;, favoriteColor: .blueColor())<br>&gt; let jane = with(john) {<br>&gt;     $0.name = &quot;Jane&quot;<br>&gt; }<br>&gt; In addition to the aforementioned benefits, with removes the var copy line.<br>&gt; <br>&gt; Treating a Mutable Method As a Copy-and-Return Method<br>&gt; <br>&gt; You would like to write this:<br>&gt; <br>&gt; let fewerFoos = foos.removing(at: i)<br>&gt; But there is only a remove(at:) mutating method. Using with, you can write:<br>&gt; <br>&gt; let fewerFoos = with(foos) { $0.remove(at: i) }<br>&gt; Avoiding Mutable Shadowing<br>&gt; <br>&gt; The standard library includes an operator for concatenating two RangeReplaceableCollections with this implementation:<br>&gt; <br>&gt; var lhs = lhs<br>&gt; // FIXME: what if lhs is a reference type?  This will mutate it.<br>&gt; lhs.reserveCapacity(lhs.count + numericCast(rhs.count))<br>&gt; lhs.append(contentsOf: rhs)<br>&gt; return lhs<br>&gt; Using with, you can eliminate the shadowing of lhs:<br>&gt; <br>&gt; // FIXME: what if lhs is a reference type?  This will mutate it.<br>&gt; return with(lhs) {<br>&gt;   $0.reserveCapacity($0.count + numericCast(rhs.count))<br>&gt;   $0.append(contentsOf: rhs)<br>&gt; }<br>&gt; It&#39;s important to note that with does not resolve the &quot;FIXME&quot; comment. Like the var lhs = lhs in the original code, with only copies value types, not reference types. If RangeReplaceableCollection included a Foundation-like copy()method that was guaranteed to return a copy even if it was a reference type, with would work nicely with that solution:<br>&gt; <br>&gt; return with(lhs.copy()) {<br>&gt;   $0.reserveCapacity($0.count + numericCast(rhs.count))<br>&gt;   $0.append(contentsOf: rhs)<br>&gt; }<br>&gt; Inspecting an Intermediate Value<br>&gt; <br>&gt; Suppose you want to inspect a value in the middle of a long method chain. For instance, you&#39;re not sure this is retrieving the type of cell you expect:<br>&gt; <br>&gt; let view = tableView.cellForRow(at: indexPath)?.contentView.withTag(42)<br>&gt; Currently, you would need to either split the statement in two so you could capture the return value of cellForRow(at:) in a constant, or insert a very clunky immediate-closure call in the middle of the statement. Using with, you can stay close to the original expression:<br>&gt; <br>&gt; let view = with(tableView.cellForRow(at: indexPath)) { print($0) }?.contentView.withTag(42)<br>&gt; Because the closure doesn&#39;t alter $0, the cell passes through the with call unaltered, so it can be used by the rest of the method chain.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; We propose adding the following free function to the standard library:<br>&gt; <br>&gt; /// Returns `item` after calling `update` to inspect and possibly <br>&gt; /// modify it.<br>&gt; /// <br>&gt; /// If `T` is a value type, `update` uses an independent copy <br>&gt; /// of `item`. If `T` is a reference type, `update` uses the <br>&gt; /// same instance passed in, but it can substitute a different <br>&gt; /// instance by setting its parameter to a new value.<br>&gt; @discardableResult<br>&gt; public func with&lt;T&gt;(_ item: T, update: @noescape (inout T) throws -&gt; Void) rethrows -&gt; T {<br>&gt;   var this = item<br>&gt;   try update(&amp;this)<br>&gt;   return this<br>&gt; }<br>&gt; @discardableResult permits the use of with(_:update:) to create a scoped temporary copy of the value with a shorter name.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; Doing nothing: with is a mere convenience; any code using it could be written another way. If rejected, users could continue to write code using the longhand form, the various closure-based techniques, or homegrown versions of with.<br>&gt; <br>&gt; Using method syntax: Some list members preferred a syntax that looked more like a method call with a trailing closure:<br>&gt; <br>&gt; let questionLabel = UILabel().with {<br>&gt;     $0.textAlignment = .Center<br>&gt;     $0.font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     $0.numberOfLines = 0<br>&gt;     addSubview($0)<br>&gt; }<br>&gt; This would require a more drastic solution as it&#39;s not possible to add methods to all Swift types. Nor does it match the existing design of functions like withExtendedLifetime(_:_:), withUnsafePointer(_:_:), and reflect(_:).<br>&gt; <br>&gt; Adding self rebinding: Some list members wanted a way to bind self to the passed argument, so that they can use implicit self to eliminate $0.:<br>&gt; <br>&gt; let supView = self<br>&gt; let questionLabel = with(UILabel()) { <br>&gt;     self in<br>&gt;     textAlignment = .Center<br>&gt;     font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     numberOfLines = 0<br>&gt;     supView.addSubview(self)<br>&gt; }<br>&gt; We do not believe this is practical to propose in the Swift 3 timeframe, and we believe with would work well with this feature if it were added later.<br>&gt; <br>&gt; Adding method cascades: A competing proposal was to introduce a way to use several methods or properties on the same instance; Dart and Smalltalk have features of this kind.<br>&gt; <br>&gt; let questionLabel = UILabel()<br>&gt;     ..textAlignment = .Center<br>&gt;     ..font = UIFont(name: &quot;DnealianManuscript&quot;, size: 72)<br>&gt;     ..numberOfLines = 0<br>&gt; addSubview(questionLabel)<br>&gt; Like rebinding self, we do not believe method cascades are practical for the Swift 3 timeframe. We also believe that many of with&#39;s use cases would not be subsumed by method cascades even if they were added.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/53541636/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
