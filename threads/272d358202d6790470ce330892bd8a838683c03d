<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0126: Refactor Metatypes, repurpose T.self and Mirror&quot; begins now and runs through July 24. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 21, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:18 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>I think this proposal is a huge mess. I don&#39;t understand why the split between `Type` and `Metatype` exists. I think `Mirror` seems half-baked; it ought to be omitted entirely until we can actually design a reflection system.<br></p><p>And *I can&#39;t even tell if these are actual problems*. It&#39;s possible that the design is just fine, but the proposal explains it poorly. At minimum, the proposal should be rewritten and the type names reconsidered. I&#39;m not a person who gets confused by metatypes, but I simply cannot make heads or tails of this proposal.<br></p><p>My general sense of this area is that the main problem is the dual meaning of T.Type. T.Type wants to simultaneously be the type of the type instance and the supertype of all subtype type instances. But this breaks down with protocols, because protocol existentials don&#39;t conform to themselves. So we end up with `T.Protocol`, which gets confusingly renamed when it crosses generic boundaries.<br></p><p>I think the answer here is to split these two roles:<br></p><p>1. `Metatype&lt;T&gt;` is the type of the type instance. `T.self` is of type `Metatype&lt;T&gt;`. (Yes, we can call it `T.metatype` if we want.) Subtype-supertype relationships don&#39;t translate directly to metaclasses; `Metatype&lt;Subclass&gt;` is not a subtype of `Metatype&lt;Superclass&gt;`.<br></p><p>2. `T.Subtype` (or `T.SubtypeMetatype`? `T.Conforming`? this needs bikeshedding) is the supertype of all metatypes for `T` and its subtypes. `T.Subtype` is sort of like a protocol, in that there are no concrete instances of it, so it makes no sense to instantiate it. For classes, it only includes required (i.e. inherited) initializers.<br></p><p>Happily, I believe—though I may be wrong—that we can mostly resyntax to fix this immediate problem. Adding new capabilities, like extending the metatypes of specific types and adding universal members, can wait (or mostly wait) for another day.<br></p><p>(But in general, I would like to see those added directly on `Metatype`, and I would like extending `Metatype&lt;T&gt;` with instance members to be equivalent to extending `T` with static/class members. I&#39;d also like to conform metatypes to protocols, to somehow define `Metatype` in the standard library as a relatively ordinary Swift type, and to have a pony.)<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>I have no idea, because I can&#39;t understand the proposal.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most metatype (well, metaclass) systems I&#39;ve worked with have been in more dynamic, runtime-oriented languages like Objective-C and Ruby. <br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve been following the threads since the beginning. (And I still don&#39;t understand the proposal.) I haven&#39;t been able to articulate my objections; honestly, I still can&#39;t, but I&#39;ve run out of time to wait and see if I can figure things out.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>said as much privately (just not that colorfully though) to author, trying to hint at a number of problems that limited its usefulness.<br></p><p>Regards<br>LM<br>(From mobile)<br></p><p>On Jul 21, 2016, at 11:30 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 20, 2016, at 5:18 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt; <br>&gt; I think this proposal is a huge mess. I don&#39;t understand why the split between `Type` and `Metatype` exists. I think `Mirror` seems half-baked; it ought to be omitted entirely until we can actually design a reflection system.<br>&gt; <br>&gt; And *I can&#39;t even tell if these are actual problems*. It&#39;s possible that the design is just fine, but the proposal explains it poorly. At minimum, the proposal should be rewritten and the type names reconsidered. I&#39;m not a person who gets confused by metatypes, but I simply cannot make heads or tails of this proposal.<br>&gt; <br>&gt; My general sense of this area is that the main problem is the dual meaning of T.Type. T.Type wants to simultaneously be the type of the type instance and the supertype of all subtype type instances. But this breaks down with protocols, because protocol existentials don&#39;t conform to themselves. So we end up with `T.Protocol`, which gets confusingly renamed when it crosses generic boundaries.<br>&gt; <br>&gt; I think the answer here is to split these two roles:<br>&gt; <br>&gt; 1. `Metatype&lt;T&gt;` is the type of the type instance. `T.self` is of type `Metatype&lt;T&gt;`. (Yes, we can call it `T.metatype` if we want.) Subtype-supertype relationships don&#39;t translate directly to metaclasses; `Metatype&lt;Subclass&gt;` is not a subtype of `Metatype&lt;Superclass&gt;`.<br>&gt; <br>&gt; 2. `T.Subtype` (or `T.SubtypeMetatype`? `T.Conforming`? this needs bikeshedding) is the supertype of all metatypes for `T` and its subtypes. `T.Subtype` is sort of like a protocol, in that there are no concrete instances of it, so it makes no sense to instantiate it. For classes, it only includes required (i.e. inherited) initializers.<br>&gt; <br>&gt; Happily, I believe—though I may be wrong—that we can mostly resyntax to fix this immediate problem. Adding new capabilities, like extending the metatypes of specific types and adding universal members, can wait (or mostly wait) for another day.<br>&gt; <br>&gt; (But in general, I would like to see those added directly on `Metatype`, and I would like extending `Metatype&lt;T&gt;` with instance members to be equivalent to extending `T` with static/class members. I&#39;d also like to conform metatypes to protocols, to somehow define `Metatype` in the standard library as a relatively ordinary Swift type, and to have a pony.)<br>&gt; <br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I have no idea, because I can&#39;t understand the proposal.<br>&gt; <br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Most metatype (well, metaclass) systems I&#39;ve worked with have been in more dynamic, runtime-oriented languages like Objective-C and Ruby. <br>&gt; <br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;ve been following the threads since the beginning. (And I still don&#39;t understand the proposal.) I haven&#39;t been able to articulate my objections; honestly, I still can&#39;t, but I&#39;ve run out of time to wait and see if I can figure things out.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 21, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 2:30 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 5:18 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; I think this proposal is a huge mess. I don&#39;t understand why the split between `Type` and `Metatype` exists. I think `Mirror` seems half-baked; it ought to be omitted entirely until we can actually design a reflection system.<br>&gt; <br>&gt; And *I can&#39;t even tell if these are actual problems*. It&#39;s possible that the design is just fine, but the proposal explains it poorly. At minimum, the proposal should be rewritten and the type names reconsidered. I&#39;m not a person who gets confused by metatypes, but I simply cannot make heads or tails of this proposal.<br>&gt; <br>&gt; My general sense of this area is that the main problem is the dual meaning of T.Type. T.Type wants to simultaneously be the type of the type instance and the supertype of all subtype type instances.<br></p><p>It&#39;s not quite as general as that; it wants to be the supertype of subclass metatypes.<br></p><p>&gt; But this breaks down with protocols, because protocol existentials don&#39;t conform to themselves. So we end up with `T.Protocol`, which gets confusingly renamed when it crosses generic boundaries.<br></p><p>That&#39;s not why you need T.Protocol, but it&#39;s not that important here.<br></p><p>John.<br></p><p>&gt; <br>&gt; I think the answer here is to split these two roles:<br>&gt; <br>&gt; 1. `Metatype&lt;T&gt;` is the type of the type instance. `T.self` is of type `Metatype&lt;T&gt;`. (Yes, we can call it `T.metatype` if we want.) Subtype-supertype relationships don&#39;t translate directly to metaclasses; `Metatype&lt;Subclass&gt;` is not a subtype of `Metatype&lt;Superclass&gt;`.<br>&gt; <br>&gt; 2. `T.Subtype` (or `T.SubtypeMetatype`? `T.Conforming`? this needs bikeshedding) is the supertype of all metatypes for `T` and its subtypes. `T.Subtype` is sort of like a protocol, in that there are no concrete instances of it, so it makes no sense to instantiate it. For classes, it only includes required (i.e. inherited) initializers.<br>&gt; <br>&gt; Happily, I believe—though I may be wrong—that we can mostly resyntax to fix this immediate problem. Adding new capabilities, like extending the metatypes of specific types and adding universal members, can wait (or mostly wait) for another day.<br>&gt; <br>&gt; (But in general, I would like to see those added directly on `Metatype`, and I would like extending `Metatype&lt;T&gt;` with instance members to be equivalent to extending `T` with static/class members. I&#39;d also like to conform metatypes to protocols, to somehow define `Metatype` in the standard library as a relatively ordinary Swift type, and to have a pony.)<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; I have no idea, because I can&#39;t understand the proposal.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Most metatype (well, metaclass) systems I&#39;ve worked with have been in more dynamic, runtime-oriented languages like Objective-C and Ruby. <br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I&#39;ve been following the threads since the beginning. (And I still don&#39;t understand the proposal.) I haven&#39;t been able to articulate my objections; honestly, I still can&#39;t, but I&#39;ve run out of time to wait and see if I can figure things out.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/a2b9a5f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Brent, thank you for your feedback on the review process of our proposal.<br></p><p>I think this proposal is a huge mess. I don’t understand why the split between Type and Metatype exists. I think Mirror seems half-baked; it ought to be omitted entirely until we can actually design a reflection system.<br>The reason why we took Mirror here, is because there can be metatypes that pretend to reflect T where the actual metatype could reflect U with relationship like U : T:<br></p><p>class Superclass {}<br>class Subclass : Superclass {}<br></p><p>let hidden: Any = Subclass()<br>let dynamicMetatype = hidden.dynamicType // Any.Type<br>dynamicMetatype as? Any.Type              //=&gt; NOT nil<br>dynamicMetatype as? Superclass.Type       //=&gt; NOT nil<br>dynamicMetatype as? Subclass.Type         //=&gt; NOT nil<br>That is the reason why a standalone non-generic type was needed to solve the problem with the ‘current’ Swift.<br></p><p>And I can’t even tell if these are actual problems. It’s possible that the design is just fine, but the proposal explains it poorly. At minimum, the proposal should be rewritten and the type names reconsidered. I’m not a person who gets confused by metatypes, but I simply cannot make heads or tails of this proposal.<br></p><p>My general sense of this area is that the main problem is the dual meaning of T.Type. T.Type wants to simultaneously be the type of the type instance and the supertype of all subtype type instances. But this breaks down with protocols, because protocol existentials don’t conform to themselves. So we end up with T.Protocol, which gets confusingly renamed when it crosses generic boundaries.<br></p><p>I think the answer here is to split these two roles:<br></p><p>Metatype&lt;T&gt; is the type of the type instance. T.self is of type Metatype&lt;T&gt;. (Yes, we can call it T.metatype if we want.)<br>If we don’t go into the direction of Type&lt;T&gt; there is no need to rename the current T.self magic to T.metatype, that was only considered for the Type&lt;T&gt; model. .self will be removed one day anyways (hopefully).<br></p><p>Subtype-supertype relationships don’t translate directly to metaclasses; Metatype&lt;Subclass&gt; is not a subtype of Metatype&lt;Superclass&gt;.<br>Why is that so, see the example above?!<br></p><p>T.Subtype (or T.SubtypeMetatype? T.Conforming? this needs bikeshedding) is the supertype of all metatypes for T and its subtypes. T.Subtype is sort of like a protocol, in that there are no concrete instances of it, so it makes no sense to instantiate it. For classes, it only includes required (i.e. inherited) initializers.<br>Happily, I believe—though I may be wrong—that we can mostly resyntax to fix this immediate problem. Adding new capabilities, like extending the metatypes of specific types and adding universal members, can wait (or mostly wait) for another day.<br></p><p>(But in general, I would like to see those added directly on Metatype, and I would like extending Metatype&lt;T&gt; with instance members to be equivalent to extending T with static/class members. I’d also like to conform metatypes to protocols, to somehow define Metatype in the standard library as a relatively ordinary Swift type, and to have a pony.)<br>This is an interesting suggestion you mentioned there. But I think that would imply that every member you’d add on the generic Metatype&lt;T&gt; would be automatically not available on any Swift type:<br></p><p>// Bikeshedding example:<br></p><p>buildin Metatype&lt;T&gt; : Hashable {<br>    var hashValue: Int { .. }<br>}<br></p><p>struct New {<br>    // NOT available anymore - even if it&#39;s needed for a different purpose<br>    static hashValue: Int { .. }  <br>}<br>The issue can be solve if metatypes gain a bottleneck access to the type T, like Type&lt;T&gt;.metatype for example.<br></p><p>// Bikeshedding example:<br></p><p>buildin Metatype&lt;T&gt; : Hashable {<br>    var hashValue: Int { .. }<br>    var somethingToAccessT: T_XYZ { .. }<br>}<br></p><p>struct New {<br>    static hashValue: Int { .. } // available again<br>}<br>If we now compare this to our Type&lt;T&gt; model, we realize that the huge downside of Type&lt;T&gt; is that we cannot cast it around like we’d do with metatypes.<br></p><p>I’d appreciate the renaming of T.Type to Metatype&lt;T&gt;, but I believe this can’t be done without solving the issue with .Protocol first. Feel free to correct me, if I’m wrong here. :)<br></p><p>In SE–0101 rationale Chris said, that the core team considered to move size to types but dropped the idea because it would require T.self.<br></p><p>If the core team and the community strongly feels it would be better to introduce a new scoped buildin type (not necessarily named buildin), which would be only visible in stdlib, we might revision our proposal and shrink it down to the minimum breaking changes for Swift 3. Of course such a new scoped type can be introduces post Swift 3 to gain extensibility.<br></p><p>Steps I have in my mind are:<br></p><p>Rename T.Type to Metatype&lt;T&gt; today and resolve the issue with .Protocol somehow (I’m not a compiler expert).<br>I’d rename type(of:) from SE–0096 to metatype(of:) (or better dynamicMetatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;; not sure why ‘dynamic’ was dropped)<br>Drop the idea with Mirror, see below.<br>Come back post Swift 3 and talk about a new buildin extensible scoped type for metatypes with implicit inheritance ability like U : T, which merges the static and dynamic parts of Mirror and Type&lt;T&gt;.<br>// Future bikeshedding:<br></p><p>buildin Metatype&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    /// Creates an instance that reflects `T`.<br>    /// Example: `let type = T.self`<br>    public init()<br>     <br>    public static var somethingToAccessT: T_XYZ { get }<br>    public var somethingToAccessT: T_XYZ { get }<br></p><p>    public static var size: Int { get }<br>    public static var stride: Int { get }<br>    public static var alignment: Int { get }<br></p><p>    public var size: Int { get }<br>    public var stride: Int { get }<br>    public var alignment: Int { get }<br>     <br>    public var hashValue: Int { get }<br>    public var description: String { get }<br>    public var debugDescription: String { get }<br>}<br></p><p>func ==&lt;T&gt;(lhs: Metatype&lt;T&gt;, rhs: Metatype&lt;T&gt;) -&gt; Bool {<br>    return lhs.hashValue == rhs.hashValue<br>}<br>If we can introduce this later, we might be able to drop the closed MemoryLayout enum then.<br></p><p>let metatype: Metatype&lt;SomeType&gt; = SomeType.self // or SomeType when `.self` is dropped<br>metatype.size // returns the size of `SomeType`<br>metatype.somethingToAccessT.staticMemember // from SomeType<br>metatype.somethingToAccessT.init // from SomeType<br></p><p>let hiddenMetatype: Metatype&lt;Any&gt; = metatype<br></p><p>(hiddenMetatype as? SomeType)?.somethingToAccessT<br></p><p>[Metatype&lt;Any&gt;: String] = [Int.self: &quot;hello&quot;, Any.self: &quot;swift&quot;]  <br>The last ideas are my personal ideas which I do believe reflects some of your suggestions.<br></p><p>Anton might have a different point of view here.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/d108d93a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 21, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br></p><p>&gt; On Jul 21, 2016, at 4:59 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Brent, thank you for your feedback on the review process of our proposal.<br>&gt; <br>&gt; I think this proposal is a huge mess. I don’t understand why the split between Type and Metatype exists. I think Mirror seems half-baked; it ought to be omitted entirely until we can actually design a reflection system.<br>&gt; The reason why we took Mirror here, is because there can be metatypes that pretend to reflect T where the actual metatype could reflect U with relationship like U : T:<br>&gt; <br>&gt; class Superclass {}<br>&gt; class Subclass : Superclass {}<br>&gt; <br>&gt; let hidden: Any = Subclass()<br>&gt; let dynamicMetatype = hidden.dynamicType // Any.Type<br>&gt; dynamicMetatype as? Any.Type              //=&gt; NOT nil<br>&gt; dynamicMetatype as? Superclass.Type       //=&gt; NOT nil<br>&gt; dynamicMetatype as? Subclass.Type         //=&gt; NOT nil<br>&gt; That is the reason why a standalone non-generic type was needed to solve the problem with the ‘current’ Swift.<br>&gt; <br>&gt; And I can’t even tell if these are actual problems. It’s possible that the design is just fine, but the proposal explains it poorly. At minimum, the proposal should be rewritten and the type names reconsidered. I’m not a person who gets confused by metatypes, but I simply cannot make heads or tails of this proposal.<br></p><p>The most immediate issue is that this is a set of possible tactical moves without a strategy to justify why they are the right ones. There is no doubt that some are good, but without a clear plan of what reflection is intended to provide in swift, then it looks like a random exercise.<br></p><p>Joe&#39;s idea of slicing them apart is interesting and likely what will happen if he says so, but in my mind it will push further away the fundamental question of giving a scope to reflection in swift. As i said privately, there are a lot of good papers out there exploring the different facets. The answer belongs to the core team: if swift is mostly for all 7-to-77 with an ipad, then what&#39;s in swift today is already too much, if on the other hand the goal is to help with writing efficient dynamic language runtimes in swift, then this proposal will need lots of TLC.<br></p><p><br>&gt; My general sense of this area is that the main problem is the dual meaning of T.Type. T.Type wants to simultaneously be the type of the type instance and the supertype of all subtype type instances. But this breaks down with protocols, because protocol existentials don’t conform to themselves. So we end up with T.Protocol, which gets confusingly renamed when it crosses generic boundaries.<br>&gt; <br>&gt; I think the answer here is to split these two roles:<br>&gt; <br>&gt; Metatype&lt;T&gt; is the type of the type instance. T.self is of type Metatype&lt;T&gt;. (Yes, we can call it T.metatype if we want.)<br>&gt; If we don’t go into the direction of Type&lt;T&gt; there is no need to rename the current T.self magic to T.metatype, that was only considered for the Type&lt;T&gt; model. .self will be removed one day anyways (hopefully).<br>&gt; <br>&gt; Subtype-supertype relationships don’t translate directly to metaclasses; Metatype&lt;Subclass&gt; is not a subtype of Metatype&lt;Superclass&gt;.<br>&gt; Why is that so, see the example above?!<br>&gt; <br>&gt; T.Subtype (or T.SubtypeMetatype? T.Conforming? this needs bikeshedding) is the supertype of all metatypes for T and its subtypes. T.Subtype is sort of like a protocol, in that there are no concrete instances of it, so it makes no sense to instantiate it. For classes, it only includes required (i.e. inherited) initializers.<br>&gt; Happily, I believe—though I may be wrong—that we can mostly resyntax to fix this immediate problem. Adding new capabilities, like extending the metatypes of specific types and adding universal members, can wait (or mostly wait) for another day.<br>&gt; <br>&gt; (But in general, I would like to see those added directly on Metatype, and I would like extending Metatype&lt;T&gt; with instance members to be equivalent to extending T with static/class members. I’d also like to conform metatypes to protocols, to somehow define Metatype in the standard library as a relatively ordinary Swift type, and to have a pony.)<br>&gt; This is an interesting suggestion you mentioned there. But I think that would imply that every member you’d add on the generic Metatype&lt;T&gt; would be automatically not available on any Swift type:<br>&gt; <br>&gt; // Bikeshedding example:<br>&gt; <br>&gt; buildin Metatype&lt;T&gt; : Hashable {<br>&gt;     var hashValue: Int { .. }<br>&gt; }<br>&gt; <br>&gt; struct New {<br>&gt;     // NOT available anymore - even if it&#39;s needed for a different purpose<br>&gt;     static hashValue: Int { .. }  <br>&gt; }<br>&gt; The issue can be solve if metatypes gain a bottleneck access to the type T, like Type&lt;T&gt;.metatype for example.<br>&gt; <br>&gt; // Bikeshedding example:<br>&gt; <br>&gt; buildin Metatype&lt;T&gt; : Hashable {<br>&gt;     var hashValue: Int { .. }<br>&gt;     var somethingToAccessT: T_XYZ { .. }<br>&gt; }<br>&gt; <br>&gt; struct New {<br>&gt;     static hashValue: Int { .. } // available again<br>&gt; }<br>&gt; If we now compare this to our Type&lt;T&gt; model, we realize that the huge downside of Type&lt;T&gt; is that we cannot cast it around like we’d do with metatypes.<br>&gt; <br>&gt; I’d appreciate the renaming of T.Type to Metatype&lt;T&gt;, but I believe this can’t be done without solving the issue with .Protocol first. Feel free to correct me, if I’m wrong here. :)<br>&gt; <br>&gt; In SE–0101 rationale Chris said, that the core team considered to move size to types but dropped the idea because it would require T.self.<br>&gt; <br>&gt; If the core team and the community strongly feels it would be better to introduce a new scoped buildin type (not necessarily named buildin), which would be only visible in stdlib, we might revision our proposal and shrink it down to the minimum breaking changes for Swift 3. Of course such a new scoped type can be introduces post Swift 3 to gain extensibility.<br>&gt; <br>&gt; Steps I have in my mind are:<br>&gt; <br>&gt; Rename T.Type to Metatype&lt;T&gt; today and resolve the issue with .Protocol somehow (I’m not a compiler expert).<br>&gt; I’d rename type(of:) from SE–0096 to metatype(of:) (or better dynamicMetatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;; not sure why ‘dynamic’ was dropped)<br>&gt; Drop the idea with Mirror, see below.<br>&gt; Come back post Swift 3 and talk about a new buildin extensible scoped type for metatypes with implicit inheritance ability like U : T, which merges the static and dynamic parts of Mirror and Type&lt;T&gt;.<br>&gt; // Future bikeshedding:<br>&gt; <br>&gt; buildin Metatype&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt; <br>&gt;     /// Creates an instance that reflects `T`.<br>&gt;     /// Example: `let type = T.self`<br>&gt;     public init()<br>&gt;      <br>&gt;     public static var somethingToAccessT: T_XYZ { get }<br>&gt;     public var somethingToAccessT: T_XYZ { get }<br>&gt; <br>&gt;     public static var size: Int { get }<br>&gt;     public static var stride: Int { get }<br>&gt;     public static var alignment: Int { get }<br>&gt; <br>&gt;     public var size: Int { get }<br>&gt;     public var stride: Int { get }<br>&gt;     public var alignment: Int { get }<br>&gt;      <br>&gt;     public var hashValue: Int { get }<br>&gt;     public var description: String { get }<br>&gt;     public var debugDescription: String { get }<br>&gt; }<br>&gt; <br>&gt; func ==&lt;T&gt;(lhs: Metatype&lt;T&gt;, rhs: Metatype&lt;T&gt;) -&gt; Bool {<br>&gt;     return lhs.hashValue == rhs.hashValue<br>&gt; }<br>&gt; If we can introduce this later, we might be able to drop the closed MemoryLayout enum then.<br>&gt; <br>&gt; let metatype: Metatype&lt;SomeType&gt; = SomeType.self // or SomeType when `.self` is dropped<br>&gt; metatype.size // returns the size of `SomeType`<br>&gt; metatype.somethingToAccessT.staticMemember // from SomeType<br>&gt; metatype.somethingToAccessT.init // from SomeType<br>&gt; <br>&gt; let hiddenMetatype: Metatype&lt;Any&gt; = metatype<br>&gt; <br>&gt; (hiddenMetatype as? SomeType)?.somethingToAccessT<br>&gt; <br>&gt; [Metatype&lt;Any&gt;: String] = [Int.self: &quot;hello&quot;, Any.self: &quot;swift&quot;]  <br>&gt; The last ideas are my personal ideas which I do believe reflects some of your suggestions.<br>&gt; <br>&gt; Anton might have a different point of view here.<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/9810f3e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Sliced revision is almost done. We would like to focus on two things: `Metatype&lt;T&gt;` and `metype(of:)`. I’ll post it here soon before submitting a PR. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/f4d76b0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Here is the new revised draft: https://gist.github.com/DevAndArtist/f7da7d7338eedb40adb9c5631a34aee1<br></p><p>We’d like to hear your feedback before we submit this revision. It’s unusual for such a quick revision, but it’s clearly was asked by Joe Groff and the feedback from the community.<br></p><p>Introduction<br></p><p>This proposal renames the current metatype T.Type notation and the global function from SE–0096 to match the changes.<br></p><p>Swift-evolution threads:<br></p><p>[Review] SE–0126: Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>Motivation<br></p><p>In Swift metatypes have the following notation: T.Type<br></p><p>As already showed in SE–0096 and SE–0090 the Swift community strongly is in favor of (re)moving magical intstance or type properties.<br></p><p>SE–0096 moves instanceOfT.dynamicType to type&lt;T&gt;(of: T) -&gt; T.Type.<br></p><p>SE–0090 aims to remove .self completely.<br></p><p>We propose to rename T.Type to a generic-like notation Metatype&lt;T&gt;. To be able to achieve this notation we have to resolve a few issues first.<br></p><p>Known issues of metatypes:<br></p><p>Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>   return Int.self is T.Type<br>}<br></p><p>intConforms(to: CustomStringConvertible.self) //=&gt; false<br></p><p>Int.self is CustomStringConvertible.Type      //=&gt; true<br>[1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br></p><p>[2] There isn’t a way to generically expression P.Type yet.<br></p><p>[3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br></p><p>Written by Joe Groff: [1] [2] [3]<br>A possible workaround might look like the example below, but does not allow to decompose P.Type:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>  return Int.self is T<br>}<br></p><p>intConforms(to: CustomStringConvertible.Type.self) //=&gt; true<br>We can extend this issue and find the second problem by checking against the metatype of Any:<br></p><p>func intConforms&lt;T&gt;(to _: T.Type) -&gt; Bool {<br>    return Int.self is T<br>}<br></p><p>intConforms(to: Any.Type.self) //=&gt; true<br></p><p>intConforms(to: Any.self)      //=&gt; true<br></p><p>Int.self is Any.Type           //=&gt; Always true<br>When using Any the compiler does not require .Type at all and returns true for both variations.<br></p><p>The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br></p><p>protocol P {}<br>protocol R : P {}<br></p><p>func rIsSubtype&lt;T&gt;(of _: T.Type) -&gt; Bool {<br>    return R.self is T<br>}<br></p><p>rIsSubtype(of: P.Type.self) //=&gt; false<br></p><p>R.self is Any.Type //=&gt; Always true<br>R.self is P.Type   //=&gt; true<br>R.self is R.Type   //=&gt; true<br>We also believe that this issue is the reason why the current global functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br></p><p>Proposed solution<br></p><p>Rename any occurrence of T.Type and T.Protocol to Metatype&lt;T&gt;.<br></p><p>Revise metatypes internally.<br></p><p>When T is a protocol, T.self should always return an instance of Metatype&lt;T&gt; (old T.Type) and never a T.Protocol. Furthermore, metatypes should reflect the same type relationship behavior like the actual types themselves.<br></p><p>To match the correct meaning and usage of the noun ‘Metatype’ from this proposal, we also propose to rename the global function from SE–0096:<br></p><p>before: public func type&lt;T&gt;(of instance: T) -&gt; T.Type<br>after: public func metatype&lt;T&gt;(of instance: T) -&gt; Metatype&lt;T&gt;<br>Examples:<br></p><p>protocol P {}<br>protocol R : P {}<br>class A : P {}<br>class B : A, R {}<br></p><p>func `is`&lt;T&gt;(metatype: Metatype&lt;Any&gt;, also _: Metatype&lt;T&gt; ) -&gt; Bool {<br>    return metatype is Metatype&lt;T&gt;<br>}<br></p><p>`is`(metatype: R.self, also: Any.self) //=&gt; true | Currently: false<br>`is`(metatype: R.self, also: P.self)   //=&gt; true | Currently: false<br>`is`(metatype: R.self, also: R.self)   //=&gt; true<br></p><p>`is`(metatype: B.self, also: Any.self) //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: P.self)   //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: R.self)   //=&gt; true | Currently: false<br>`is`(metatype: B.self, also: A.self)   //=&gt; true<br>`is`(metatype: B.self, also: B.self)   //=&gt; true<br></p><p>func cast&lt;T&gt;(metatype: Metatype&lt;Any&gt;, to _: Metatype&lt;T&gt;) -&gt; Metatype&lt;T&gt;? {<br>    return metatype as? Metatype&lt;T&gt;<br>}<br></p><p>cast(metatype: R.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>cast(metatype: R.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>cast(metatype: R.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br></p><p>let anyR: Any.Type = R.self<br>let r = cast(metatype: anyR, to: R.self) //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: an Optional&lt;R.Protocol&gt;<br></p><p>cast(metatype: B.self, to: Any.self)     //=&gt; an Optional&lt;Metatype&lt;Any&gt;&gt; | Currently: nil<br>cast(metatype: B.self, to: P.self)       //=&gt; an Optional&lt;Metatype&lt;P&gt;&gt;   | Currently: nil<br>cast(metatype: B.self, to: R.self)       //=&gt; an Optional&lt;Metatype&lt;R&gt;&gt;   | Currently: nil<br>cast(metatype: B.self, to: A.self)       //=&gt; an Optional&lt;Metatype&lt;A&gt;&gt;<br>cast(metatype: B.self, to: B.self)       //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br></p><p>let pB: P.Type = B.self<br>let b = cast(metatype: pB, to: B.self)   //=&gt; an Optional&lt;Metatype&lt;B&gt;&gt;<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator. Any occurrence of T.Type or T.Protocol will be simply renamed to Metatype&lt;T&gt;.<br></p><p>Alternatives considered<br></p><p>Alternatively it’s reasonable to consider to rename T.self to T.metatype.<br>It was considered to reserve Type&lt;T&gt; for different usage in the future.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. Juli 2016 um 22:22:38, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Sliced revision is almost done. We would like to focus on two things: `Metatype&lt;T&gt;` and `metype(of:)`. I’ll post it here soon before submitting a PR. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/282fcf54/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July 21, 2016 at 08:00:00am</p></header><div class="content"><p>Before passing judgment on any particular ideas, I want to say that this proposal is huge, and I see no realistic way we can evaluate and implement this in the remaining week for source-breaking changes to Swift 3. I would recommend:<br></p><p>- Breaking it up into smaller proposals. There are quite a few orthogonal points that deserve independent evaluation, including:<br>	- Renaming T.Type and T.Protocol to Type&lt;T&gt;, or something similar<br>	- Splitting the responsibility of metatypes into two separate concepts<br>	- Folding MemoryLayout into one of those concepts<br>	- Renaming Mirror<br></p><p>- Since it&#39;s unlikely we can take this for Swift 3, sketching out a migration plan to bring the functionality to a future version of Swift. We will need a deprecation period where both the old and new functionality are supported. We will also need to ensure the implementation and runtime can remain compatible with deployed binaries using the Swift 3 behavior.<br></p><p>The latter point should probably be a requirement for all proposals going forward.<br></p><p>-Joe<br></p><p>&gt; On Jul 20, 2016, at 5:18 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0126: Refactor Metatypes, repurpose T.self and Mirror&quot; begins now and runs through July 24. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0126: Refactor Metatypes, repurpose T.self and Mirror</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 21, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:18 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0126: Refactor Metatypes, repurpose T.self and Mirror&quot; begins now and runs through July 24. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md<br></p><p>As mentioned on another thread, this proposal has been withdrawn.  Thanks,<br></p><p>-Chris<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
