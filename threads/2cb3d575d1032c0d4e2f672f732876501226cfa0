<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May  8, 2016 at 11:00:00pm</p></header><div class="content"><p>There was some previous discussion under &quot;[Discussion] Enforce argument<br>labels on tuples<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br></p><p>Halfway through the thread, Haravikk clearly stated the key point:<br></p><p>On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think the important thing to remember is that the label check is<br>&gt; intended to prevent cases like this:<br>&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt; var b:(right:Int, left:Int) = a<br>&gt; While the two tuples are compatible by type, the meaning of the values<br>&gt; may differ due to the different labels; in this case the values are<br>&gt; represented in a different order that a developer should have to explicitly<br>&gt; reverse to ensure they aren’t making a mistake, or they could represent<br>&gt; radically different concepts altogether.<br></p><p><br></p><p>I agree there&#39;s a potential for confusion here, and I suggest we should add<br>an error (or warning) imploring the user to make the conversion explicit,<br>when the source tuple is labeled:<br></p><p>    func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br></p><p>    let (left: a, right: b) = foo()  // ok, labels match<br></p><p>    var x = 0, y = 0<br>    (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br></p><p>    let (c, d) = foo()<br>    // error: conversion between tuple types &#39;(left: Int, right: Int)&#39; and<br>&#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>    // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br></p><p>    let (right: e, left: f) = foo()<br>    // error: conversion between tuple types &#39;(left: Int, right: Int)&#39; and<br>&#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>    // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>left: Int)&quot;<br></p><p><br>Thoughts?<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/2cb3cfa0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 07:00:00am</p></header><div class="content"><p>A sensible solution, IMO. Error with Fix-It when attempting to convert<br>implicitly between tuples with mismatched labels.<br></p><p>On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There was some previous discussion under &quot;[Discussion] Enforce argument<br>&gt; labels on tuples<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;<br>&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;<br>&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt; intended to prevent cases like this:<br>&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt; While the two tuples are compatible by type, the meaning of the values<br>&gt;&gt; may differ due to the different labels; in this case the values are<br>&gt;&gt; represented in a different order that a developer should have to explicitly<br>&gt;&gt; reverse to ensure they aren’t making a mistake, or they could represent<br>&gt;&gt; radically different concepts altogether.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I agree there&#39;s a potential for confusion here, and I suggest we should<br>&gt; add an error (or warning) imploring the user to make the conversion<br>&gt; explicit, when the source tuple is labeled:<br>&gt;<br>&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;<br>&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;<br>&gt;     var x = 0, y = 0<br>&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;<br>&gt;     let (c, d) = foo()<br>&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39; and<br>&gt; &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;<br>&gt;     let (right: e, left: f) = foo()<br>&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39; and<br>&gt; &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>&gt; left: Int)&quot;<br>&gt;<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/26cbc5a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May  9, 2016 at 12:00:00am</p></header><div class="content"><p>... and one might also want to require labels when passing values *to* a<br>labeled tuple:<br></p><p>    func foo() -&gt; (left: Int, right: Int) {<br>        return (3, 4)  // error: conversion between tuple types &#39;(Int,<br>Int)&#39; and &#39;(left: Int, right: Int)&#39; requires explicit &#39;as&#39; operator<br>    }<br></p><p>I&#39;ve personally been bitten by a typo of this sort (mistakenly swapping the<br>values) before.<br>Jacob<br></p><p>On Mon, May 9, 2016 at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; A sensible solution, IMO. Error with Fix-It when attempting to convert<br>&gt; implicitly between tuples with mismatched labels.<br>&gt;<br>&gt; On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; There was some previous discussion under &quot;[Discussion] Enforce argument<br>&gt;&gt; labels on tuples<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;&gt;<br>&gt;&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;&gt;<br>&gt;&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt;&gt; intended to prevent cases like this:<br>&gt;&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt;&gt; While the two tuples are compatible by type, the meaning of the values<br>&gt;&gt;&gt; may differ due to the different labels; in this case the values are<br>&gt;&gt;&gt; represented in a different order that a developer should have to explicitly<br>&gt;&gt;&gt; reverse to ensure they aren’t making a mistake, or they could represent<br>&gt;&gt;&gt; radically different concepts altogether.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I agree there&#39;s a potential for confusion here, and I suggest we should<br>&gt;&gt; add an error (or warning) imploring the user to make the conversion<br>&gt;&gt; explicit, when the source tuple is labeled:<br>&gt;&gt;<br>&gt;&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;&gt;<br>&gt;&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;&gt;<br>&gt;&gt;     var x = 0, y = 0<br>&gt;&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;&gt;<br>&gt;&gt;     let (c, d) = foo()<br>&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt; and &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;&gt;<br>&gt;&gt;     let (right: e, left: f) = foo()<br>&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt; and &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>&gt;&gt; left: Int)&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/88912362/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 02:00:00am</p></header><div class="content"><p>Hmm, not as sure about that one. To my mind it&#39;s a clear expression of<br>intent there. You&#39;re saying you know what the labels are and you&#39;re<br>choosing not to repeat them. I think it should be on you if you express<br>that intent and you&#39;re just plain wrong.<br></p><p><br>On Mon, May 9, 2016 at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; ... and one might also want to require labels when passing values *to* a<br>&gt; labeled tuple:<br>&gt;<br>&gt;     func foo() -&gt; (left: Int, right: Int) {<br>&gt;         return (3, 4)  // error: conversion between tuple types &#39;(Int,<br>&gt; Int)&#39; and &#39;(left: Int, right: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;     }<br>&gt;<br>&gt; I&#39;ve personally been bitten by a typo of this sort (mistakenly swapping<br>&gt; the values) before.<br>&gt; Jacob<br>&gt;<br>&gt; On Mon, May 9, 2016 at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; A sensible solution, IMO. Error with Fix-It when attempting to convert<br>&gt;&gt; implicitly between tuples with mismatched labels.<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; There was some previous discussion under &quot;[Discussion] Enforce argument<br>&gt;&gt;&gt; labels on tuples<br>&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt;&gt;&gt; intended to prevent cases like this:<br>&gt;&gt;&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt;&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt;&gt;&gt; While the two tuples are compatible by type, the meaning of the values<br>&gt;&gt;&gt;&gt; may differ due to the different labels; in this case the values are<br>&gt;&gt;&gt;&gt; represented in a different order that a developer should have to explicitly<br>&gt;&gt;&gt;&gt; reverse to ensure they aren’t making a mistake, or they could represent<br>&gt;&gt;&gt;&gt; radically different concepts altogether.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree there&#39;s a potential for confusion here, and I suggest we should<br>&gt;&gt;&gt; add an error (or warning) imploring the user to make the conversion<br>&gt;&gt;&gt; explicit, when the source tuple is labeled:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var x = 0, y = 0<br>&gt;&gt;&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let (c, d) = foo()<br>&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt; and &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let (right: e, left: f) = foo()<br>&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt; and &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>&gt;&gt;&gt; left: Int)&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/4f2e7a63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 04:00:00am</p></header><div class="content"><p>Also--I didn&#39;t read this carefully enough in your initial example--I<br>disagree that either (left: Int, right: Int) to (Int, Int) or vice versa<br>should require explicit casting, and I think previous conversations on the<br>topic showed that at least some on the list felt the same way.<br></p><p>Mismatched labels, yes, because IMO it&#39;s alarming without a more explicit<br>indication of intent to assume that a user intends to swap labels going<br>from (left: Int, right: Int) to (right: Int, left: Int). But to work around<br>that restriction, I should be able to erase labels and affix new ones<br>without using &quot;as&quot;, since no unintentional label swapping can occur in<br>either direction.<br></p><p><br>On Mon, May 9, 2016 at 2:57 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Hmm, not as sure about that one. To my mind it&#39;s a clear expression of<br>&gt; intent there. You&#39;re saying you know what the labels are and you&#39;re<br>&gt; choosing not to repeat them. I think it should be on you if you express<br>&gt; that intent and you&#39;re just plain wrong.<br>&gt;<br>&gt;<br>&gt; On Mon, May 9, 2016 at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; ... and one might also want to require labels when passing values *to* a<br>&gt;&gt; labeled tuple:<br>&gt;&gt;<br>&gt;&gt;     func foo() -&gt; (left: Int, right: Int) {<br>&gt;&gt;         return (3, 4)  // error: conversion between tuple types &#39;(Int,<br>&gt;&gt; Int)&#39; and &#39;(left: Int, right: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; I&#39;ve personally been bitten by a typo of this sort (mistakenly swapping<br>&gt;&gt; the values) before.<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; A sensible solution, IMO. Error with Fix-It when attempting to convert<br>&gt;&gt;&gt; implicitly between tuples with mismatched labels.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There was some previous discussion under &quot;[Discussion] Enforce<br>&gt;&gt;&gt;&gt; argument labels on tuples<br>&gt;&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt;&gt;&gt;&gt; intended to prevent cases like this:<br>&gt;&gt;&gt;&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt;&gt;&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt;&gt;&gt;&gt; While the two tuples are compatible by type, the meaning of the<br>&gt;&gt;&gt;&gt;&gt; values may differ due to the different labels; in this case the<br>&gt;&gt;&gt;&gt;&gt; values are represented in a different order that a developer should have to<br>&gt;&gt;&gt;&gt;&gt; explicitly reverse to ensure they aren’t making a mistake, or they could<br>&gt;&gt;&gt;&gt;&gt; represent radically different concepts altogether.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree there&#39;s a potential for confusion here, and I suggest we should<br>&gt;&gt;&gt;&gt; add an error (or warning) imploring the user to make the conversion<br>&gt;&gt;&gt;&gt; explicit, when the source tuple is labeled:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     var x = 0, y = 0<br>&gt;&gt;&gt;&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let (c, d) = foo()<br>&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt;&gt; and &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let (right: e, left: f) = foo()<br>&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt;&gt; and &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>&gt;&gt;&gt;&gt; left: Int)&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/d20e96a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 05:00:00am</p></header><div class="content"><p>Two more points to be made:<br></p><p>First, there are types where current behavior allowing implicit erasure and<br>affixing of labels is a definite win. Consider:<br></p><p>```<br>typealias CartesianCoordinate = (x: Int, y: Int)<br>let c: CartesianCoordinate = (0, 1)<br>print(c.x)<br></p><p>typealias PolarCoordinate = (r: Double, theta: Double)<br>let p: PolarCoordinate = (0.0, M_PI)<br>print(p.theta)<br>```<br></p><p>Second, your examples involving pattern matching are not correct. Since<br>it&#39;s a tuple *pattern*, you&#39;ll find that `let (right: e, left: f) = (left:<br>1, right: 2)` has the same effect as writing `let (left: f, right: e) =<br>(left: 1, right: 2)`. Which is to say, left goes with left and right goes<br>with right irrespective of the order of labels on the LHS.<br></p><p><br>On Mon, May 9, 2016 at 4:00 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Also--I didn&#39;t read this carefully enough in your initial example--I<br>&gt; disagree that either (left: Int, right: Int) to (Int, Int) or vice versa<br>&gt; should require explicit casting, and I think previous conversations on the<br>&gt; topic showed that at least some on the list felt the same way.<br>&gt;<br>&gt; Mismatched labels, yes, because IMO it&#39;s alarming without a more explicit<br>&gt; indication of intent to assume that a user intends to swap labels going<br>&gt; from (left: Int, right: Int) to (right: Int, left: Int). But to work around<br>&gt; that restriction, I should be able to erase labels and affix new ones<br>&gt; without using &quot;as&quot;, since no unintentional label swapping can occur in<br>&gt; either direction.<br>&gt;<br>&gt;<br>&gt; On Mon, May 9, 2016 at 2:57 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hmm, not as sure about that one. To my mind it&#39;s a clear expression of<br>&gt;&gt; intent there. You&#39;re saying you know what the labels are and you&#39;re<br>&gt;&gt; choosing not to repeat them. I think it should be on you if you express<br>&gt;&gt; that intent and you&#39;re just plain wrong.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; ... and one might also want to require labels when passing values *to* a<br>&gt;&gt;&gt; labeled tuple:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) {<br>&gt;&gt;&gt;         return (3, 4)  // error: conversion between tuple types &#39;(Int,<br>&gt;&gt;&gt; Int)&#39; and &#39;(left: Int, right: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve personally been bitten by a typo of this sort (mistakenly swapping<br>&gt;&gt;&gt; the values) before.<br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, May 9, 2016 at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; A sensible solution, IMO. Error with Fix-It when attempting to convert<br>&gt;&gt;&gt;&gt; implicitly between tuples with mismatched labels.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There was some previous discussion under &quot;[Discussion] Enforce<br>&gt;&gt;&gt;&gt;&gt; argument labels on tuples<br>&gt;&gt;&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt;&gt;&gt;&gt;&gt; intended to prevent cases like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt;&gt;&gt;&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt;&gt;&gt;&gt;&gt; While the two tuples are compatible by type, the meaning of the<br>&gt;&gt;&gt;&gt;&gt;&gt; values may differ due to the different labels; in this case the<br>&gt;&gt;&gt;&gt;&gt;&gt; values are represented in a different order that a developer should have to<br>&gt;&gt;&gt;&gt;&gt;&gt; explicitly reverse to ensure they aren’t making a mistake, or they could<br>&gt;&gt;&gt;&gt;&gt;&gt; represent radically different concepts altogether.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I agree there&#39;s a potential for confusion here, and I suggest we<br>&gt;&gt;&gt;&gt;&gt; should add an error (or warning) imploring the user to make the conversion<br>&gt;&gt;&gt;&gt;&gt; explicit, when the source tuple is labeled:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     var x = 0, y = 0<br>&gt;&gt;&gt;&gt;&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     let (c, d) = foo()<br>&gt;&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt;&gt;&gt; and &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     let (right: e, left: f) = foo()<br>&gt;&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right: Int)&#39;<br>&gt;&gt;&gt;&gt;&gt; and &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right: Int,<br>&gt;&gt;&gt;&gt;&gt; left: Int)&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/22f5ac26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Require tuple conversions to be explicit when labels don&#39;t match</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>Hmm. I&#39;m also having second thoughts about that Fix-It. I wonder if the<br>&quot;fix&quot; that&#39;s automatically provided is little more than &quot;press here to make<br>the red thingy go away and do nothing else.&quot;<br></p><p>The way I see it, if the error is restricted to mismatched labels, then the<br>presumption is that someone got the order of the labels wrong. So the error<br>is basically: &quot;Hey, we think you accidentally swapped your labels. Do you<br>want us to fix it?&quot; And the default fix, which some people are guaranteed<br>to choose without even reading the error very carefully, shouldn&#39;t be<br>&quot;Leave the labels swapped even though it looks wrong, and just rewrite that<br>line so the error disappears!&quot;<br>On Mon, May 9, 2016 at 05:09 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Two more points to be made:<br>&gt;<br>&gt; First, there are types where current behavior allowing implicit erasure<br>&gt; and affixing of labels is a definite win. Consider:<br>&gt;<br>&gt; ```<br>&gt; typealias CartesianCoordinate = (x: Int, y: Int)<br>&gt; let c: CartesianCoordinate = (0, 1)<br>&gt; print(c.x)<br>&gt;<br>&gt; typealias PolarCoordinate = (r: Double, theta: Double)<br>&gt; let p: PolarCoordinate = (0.0, M_PI)<br>&gt; print(p.theta)<br>&gt; ```<br>&gt;<br>&gt; Second, your examples involving pattern matching are not correct. Since<br>&gt; it&#39;s a tuple *pattern*, you&#39;ll find that `let (right: e, left: f) = (left:<br>&gt; 1, right: 2)` has the same effect as writing `let (left: f, right: e) =<br>&gt; (left: 1, right: 2)`. Which is to say, left goes with left and right goes<br>&gt; with right irrespective of the order of labels on the LHS.<br>&gt;<br>&gt;<br>&gt; On Mon, May 9, 2016 at 4:00 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Also--I didn&#39;t read this carefully enough in your initial example--I<br>&gt;&gt; disagree that either (left: Int, right: Int) to (Int, Int) or vice versa<br>&gt;&gt; should require explicit casting, and I think previous conversations on the<br>&gt;&gt; topic showed that at least some on the list felt the same way.<br>&gt;&gt;<br>&gt;&gt; Mismatched labels, yes, because IMO it&#39;s alarming without a more explicit<br>&gt;&gt; indication of intent to assume that a user intends to swap labels going<br>&gt;&gt; from (left: Int, right: Int) to (right: Int, left: Int). But to work around<br>&gt;&gt; that restriction, I should be able to erase labels and affix new ones<br>&gt;&gt; without using &quot;as&quot;, since no unintentional label swapping can occur in<br>&gt;&gt; either direction.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, May 9, 2016 at 2:57 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hmm, not as sure about that one. To my mind it&#39;s a clear expression of<br>&gt;&gt;&gt; intent there. You&#39;re saying you know what the labels are and you&#39;re<br>&gt;&gt;&gt; choosing not to repeat them. I think it should be on you if you express<br>&gt;&gt;&gt; that intent and you&#39;re just plain wrong.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, May 9, 2016 at 2:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ... and one might also want to require labels when passing values *to*<br>&gt;&gt;&gt;&gt; a labeled tuple:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) {<br>&gt;&gt;&gt;&gt;         return (3, 4)  // error: conversion between tuple types &#39;(Int,<br>&gt;&gt;&gt;&gt; Int)&#39; and &#39;(left: Int, right: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ve personally been bitten by a typo of this sort (mistakenly swapping<br>&gt;&gt;&gt;&gt; the values) before.<br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, May 9, 2016 at 12:23 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; A sensible solution, IMO. Error with Fix-It when attempting to convert<br>&gt;&gt;&gt;&gt;&gt; implicitly between tuples with mismatched labels.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mon, May 9, 2016 at 01:47 Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There was some previous discussion under &quot;[Discussion] Enforce<br>&gt;&gt;&gt;&gt;&gt;&gt; argument labels on tuples<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14910&gt;&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Halfway through the thread, Haravikk clearly stated the key point:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Apr 21, 2016 at 12:14 AM, Haravikk via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the important thing to remember is that the label check is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; intended to prevent cases like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let a:(left:Int, right:Int) = (1, 2)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var b:(right:Int, left:Int) = a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; While the two tuples are compatible by type, the meaning of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; values may differ due to the different labels; in this case the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; values are represented in a different order that a developer should have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; explicitly reverse to ensure they aren’t making a mistake, or they could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; represent radically different concepts altogether.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I agree there&#39;s a potential for confusion here, and I suggest we<br>&gt;&gt;&gt;&gt;&gt;&gt; should add an error (or warning) imploring the user to make the conversion<br>&gt;&gt;&gt;&gt;&gt;&gt; explicit, when the source tuple is labeled:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     func foo() -&gt; (left: Int, right: Int) { return (3, 4) }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     let (left: a, right: b) = foo()  // ok, labels match<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     var x = 0, y = 0<br>&gt;&gt;&gt;&gt;&gt;&gt;     (left: x, right: y) = (1, 3)  // ok, source is unlabeled<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     let (c, d) = foo()<br>&gt;&gt;&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right:<br>&gt;&gt;&gt;&gt;&gt;&gt; Int)&#39; and &#39;(Int, Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (c, d) = foo() as (Int, Int)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     let (right: e, left: f) = foo()<br>&gt;&gt;&gt;&gt;&gt;&gt;     // error: conversion between tuple types &#39;(left: Int, right:<br>&gt;&gt;&gt;&gt;&gt;&gt; Int)&#39; and &#39;(right: Int, left: Int)&#39; requires explicit &#39;as&#39; operator<br>&gt;&gt;&gt;&gt;&gt;&gt;     // suggested fix: &quot;let (right: e, left: f) = foo() as (right:<br>&gt;&gt;&gt;&gt;&gt;&gt; Int, left: Int)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/029bd656/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
