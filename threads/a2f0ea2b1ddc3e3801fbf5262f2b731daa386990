<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 16, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi there,<br></p><p>I&#39;m not really sure whether this is appropriate, considering that Swift 4 should be basically focusing purely on ABI compatibility and a few other issues mentioned by Chris, but I&#39;ve been thinking about this for some time and would make a lot of lives easier, so it could be part of 3.x.<br></p><p>I&#39;ve written a proposal draft here: https://gist.github.com/charlieMonroe/0752cd61f7937f714b689137daf9de21<br></p><p>In brevity:<br></p><p>Currently, if you want consistent sorting of some entities, you either declare them Comparable and decide under which key do they sort and then use entities.sorted().<br></p><p>Unfortunately, this isn&#39;t really clear under what key do the entities sort. For example:<br></p><p>class Person {<br>    var age: Int = 21<br>    var firstName: String = &quot;John&quot;<br>    var lastName: String = &quot;Doe&quot;<br>}<br></p><p>If this were Comparable, would it sort by first name, last name or age? What if you wanted to be able to sort using all the properties? You&#39;d probably resort to writing an extension on sequence:<br></p><p>extension Sequence where Self.Iterator.Element: MyClass {<br>    func sortedByFirstName() -&gt; [Self.Iterator.Element] {<br>        return self.sorted(isOrderedBefore: { $0.firstName &lt; $1.firstName })<br>    }<br>    func sortedByLastName() -&gt; [Self.Iterator.Element] {<br>        return self.sorted(isOrderedBefore: { $0.lastName &lt; $1.lastName })<br>    }<br>    func sortedByAge() -&gt; [Self.Iterator.Element] {<br>        return self.sorted(isOrderedBefore: { $0.age &lt; $1.age })<br>    }<br>}<br></p><p>This is fairly tedious, however. What I propose is to add a @sortable attribute to properties, which would automatically generate the code for you. It - of course - requires the property to conform to Comparable...<br></p><p>Any thoughts on this?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>A core team-driven proposal that didn&#39;t get sufficiently refined before the<br>Swift 3 cutoff was to refine Equatable and Comparable. The direction that<br>the core team was going was this: if your class is Comparable, then it<br>defines a total order, and `sort()` and `sorted()` are to be a stable sort<br>based on that total order.<br></p><p>Now, as to sorting based on particular properties, Dave has implemented the<br>renaming of predicate labels so it&#39;s not so onerous anymore to write<br>`self.sorted { $0.age &lt; $1.age }` or even `self.sorted(by: { $0.age &lt;<br>$1.age })`. Why are you generating your own wrapper functions for these at<br>all? Once refinements to Equatable and Comparable go in, it&#39;s easy to see<br>how one might have a syntax where you might have `self.sorted(.ascending,<br>by: { $0.age })`. So I guess, I don&#39;t know that this sugar is gaining too<br>much because I don&#39;t see the motivation for generating these wrapper<br>methods at all...<br></p><p><br>On Tue, Aug 16, 2016 at 3:51 PM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi there,<br>&gt;<br>&gt; I&#39;m not really sure whether this is appropriate, considering that Swift 4<br>&gt; should be basically focusing purely on ABI compatibility and a few other<br>&gt; issues mentioned by Chris, but I&#39;ve been thinking about this for some time<br>&gt; and would make a lot of lives easier, so it could be part of 3.x.<br>&gt;<br>&gt; I&#39;ve written a proposal draft here: https://gist.github.com/charlieMonroe/<br>&gt; 0752cd61f7937f714b689137daf9de21<br>&gt;<br>&gt; In brevity:<br>&gt;<br>&gt; Currently, if you want consistent sorting of some entities, you either<br>&gt; declare them Comparable and decide under which key do they sort and then<br>&gt; use entities.sorted().<br>&gt;<br>&gt; Unfortunately, this isn&#39;t really clear under what key do the entities<br>&gt; sort. For example:<br>&gt;<br>&gt; class Person {<br>&gt;     var age: Int = 21<br>&gt;     var firstName: String = &quot;John&quot;<br>&gt;     var lastName: String = &quot;Doe&quot;<br>&gt; }<br>&gt;<br>&gt; If this were Comparable, would it sort by first name, last name or age?<br>&gt; What if you wanted to be able to sort using all the properties? You&#39;d<br>&gt; probably resort to writing an extension on sequence:<br>&gt;<br>&gt; extension Sequence where Self.Iterator.Element: MyClass {<br>&gt;     func sortedByFirstName() -&gt; [Self.Iterator.Element] {<br>&gt;         return self.sorted(isOrderedBefore: { $0.firstName &lt; $1.firstName<br>&gt; })<br>&gt;     }<br>&gt;     func sortedByLastName() -&gt; [Self.Iterator.Element] {<br>&gt;         return self.sorted(isOrderedBefore: { $0.lastName &lt; $1.lastName })<br>&gt;     }<br>&gt;     func sortedByAge() -&gt; [Self.Iterator.Element] {<br>&gt;         return self.sorted(isOrderedBefore: { $0.age &lt; $1.age })<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This is fairly tedious, however. What I propose is to add a @sortable<br>&gt; attribute to properties, which would automatically generate the code for<br>&gt; you. It - of course - requires the property to conform to Comparable...<br>&gt;<br>&gt; Any thoughts on this?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/5da04a50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>What we need here is  sort_by  from Ruby. How about adding these overloads?<br></p><p>func sort&lt;U: Comparable&gt;(by: (T) -&gt; U)<br>func sorted&lt;U: Comparable&gt;(by: (T) -&gt; U) -&gt; [T]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/15127316/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tue, Aug 16, 2016 at 5:35 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>wrote:<br></p><p>&gt; What we need here is  sort_by  from Ruby. How about adding these overloads?<br>&gt;<br>&gt; func sort&lt;U: Comparable&gt;(by: (T) -&gt; U)<br>&gt; func sorted&lt;U: Comparable&gt;(by: (T) -&gt; U) -&gt; [T]<br>&gt;<br></p><p>I&#39;d be in favor. We&#39;d need another name, since the current closure<br>predicate is already standardized to `by:`.<br>(Or, as I propose above, once `Ordering` comes to the stdlib, we can just<br>have it as `func sort&lt;U: Comparable&gt;(_ ordering: Ordering, by: (T) -&gt; U)`,<br>called like `sort(.ascending) { $0.age }`.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/3d28e922/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>2016-08-17 1:45 GMT+03:00 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt;:<br></p><p>&gt; On Tue, Aug 16, 2016 at 5:35 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; What we need here is  sort_by  from Ruby. How about adding these<br>&gt;&gt; overloads?<br>&gt;&gt;<br>&gt;&gt; func sort&lt;U: Comparable&gt;(by: (T) -&gt; U)<br>&gt;&gt; func sorted&lt;U: Comparable&gt;(by: (T) -&gt; U) -&gt; [T]<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure<br>&gt; predicate is already standardized to `by:`.<br>&gt; (Or, as I propose above, once `Ordering` comes to the stdlib, we can just<br>&gt; have it as `func sort&lt;U: Comparable&gt;(_ ordering: Ordering, by: (T) -&gt; U)`,<br>&gt; called like `sort(.ascending) { $0.age }`.)<br>&gt;<br></p><p>Agreed, because we wouldn&#39;t be able to perform a descending sort otherwise.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/d23023f5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d70261de9ede916a945117d7087b9178?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Silvan Mosberger</string> &lt;infinisil at icloud.com&gt;<p>August 17, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure predicate is already standardized to `by:`.<br></p><p>Haskell uses &quot;on&quot; for sorting with a mapping. There are both<br></p><p>sortOn :: Ord b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]<br></p><p>and<br></p><p>sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]<br></p><p>in Haskell.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/fe58314d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 17, 2016 at 12:00:00am</p></header><div class="content"><p>Perfect. I use the phrase &quot;sort on&quot; often and was thinking of suggesting<br>that, but I was afraid it was just jargon in my line of work.<br>On Tue, Aug 16, 2016 at 19:17 Silvan Mosberger &lt;infinisil at icloud.com&gt; wrote:<br></p><p>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure<br>&gt; predicate is already standardized to `by:`.<br>&gt;<br>&gt;<br>&gt; Haskell uses &quot;on&quot; for sorting with a mapping. There are both<br>&gt;<br>&gt; sortOn :: Ord<br>&gt; &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ord&gt; b<br>&gt; =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]<br>&gt;<br>&gt; and<br>&gt;<br>&gt; sortBy :: (a -&gt; a -&gt; Ordering<br>&gt; &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ordering&gt;)<br>&gt; -&gt; [a] -&gt; [a]<br>&gt;<br>&gt; in Haskell.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/b56c7a73/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>August 17, 2016 at 10:00:00am</p></header><div class="content"><p>Haskell also has a `comparing` function<br></p><p>    comparing :: (Ord a) =&gt; (b -&gt; a) -&gt; b -&gt; b -&gt; Ordering<br></p><p>which applies a function on both the left hand side and the right hand side to get two values that can be compared/ordered. <br>This makes the call site look something like this:<br></p><p>    sortBy (comparing length) names<br></p><p>The same can be done in Swift, resulting in a similar and very English-like calls site:<br></p><p>    names.sort(by: comparing { $0.characters.count })<br></p><p>That said. While this (the `comparing` function) is a fun exercise in higher order functions, a more Swifty syntax for this is probably a separate overload of the sort/ed/ function.<br></p><p>- David<br></p><p>&gt; On 17 Aug 2016, at 02:17, Silvan Mosberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure predicate is already standardized to `by:`.<br>&gt; <br>&gt; Haskell uses &quot;on&quot; for sorting with a mapping. There are both<br>&gt; <br>&gt; sortOn &lt;&gt; :: Ord &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ord&gt; b =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]<br>&gt; <br>&gt; and<br>&gt; <br>&gt; sortBy &lt;&gt; :: (a -&gt; a -&gt; Ordering &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ordering&gt;) -&gt; [a] -&gt; [a]<br>&gt; <br>&gt; in Haskell.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/66617c76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>August 17, 2016 at 03:00:00pm</p></header><div class="content"><p>I think a first class sort descriptor style would robustly solve most<br>complex sorting needs. It can deal with multiple sort dimensions, etc.<br>which an attribute wouldn&#39;t really solve without language complexity.<br></p><p>On Wed, Aug 17, 2016 at 1:12 AM David Rönnqvist &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Haskell also has a `comparing` function<br>&gt;<br>&gt;     comparing :: (Ord a) =&gt; (b -&gt; a) -&gt; b -&gt; b -&gt; Ordering<br>&gt;<br>&gt; which applies a function on both the left hand side and the right hand<br>&gt; side to get two values that can be compared/ordered.<br>&gt; This makes the call site look something like this:<br>&gt;<br>&gt;     sortBy (comparing length) names<br>&gt;<br>&gt; The same *can* be done in Swift, resulting in a similar and very<br>&gt; English-like calls site:<br>&gt;<br>&gt;     names.sort(by: comparing { $0.characters.count })<br>&gt;<br>&gt; That said. While this (the `comparing` function) is a fun exercise in<br>&gt; higher order functions, a more Swifty syntax for this is probably a<br>&gt; separate overload of the sort/ed/ function.<br>&gt;<br>&gt; - David<br>&gt;<br>&gt; On 17 Aug 2016, at 02:17, Silvan Mosberger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure<br>&gt; predicate is already standardized to `by:`.<br>&gt;<br>&gt;<br>&gt; Haskell uses &quot;on&quot; for sorting with a mapping. There are both<br>&gt;<br>&gt; sortOn :: Ord<br>&gt; &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ord&gt; b<br>&gt; =&gt; (a -&gt; b) -&gt; [a] -&gt; [a]<br>&gt;<br>&gt; and<br>&gt;<br>&gt; sortBy :: (a -&gt; a -&gt; Ordering<br>&gt; &lt;http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ordering&gt;)<br>&gt; -&gt; [a] -&gt; [a]<br>&gt;<br>&gt; in Haskell.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/05a1963e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 17, 2016 at 06:00:00am</p></header><div class="content"><p>My original intention was to get rid of re-defining what should be the sequence sorted by. For example, if self.sorted { $0.age &lt; $1.age } was at 10 places in code, I would not consider it a good coding technique and would definitely suggest the person to create a method for this - sortedByAge().<br></p><p>self.sorted(.ascending) { $0.age } is a bit better, but I still feel that there is a lot of duplicate code and if one used this in 10 places over the project, a method for this should be created instead.<br></p><p>Don&#39;t you agree that people.sortedByAge() reads better than self.sorted(.ascending) { $0.age }?<br></p><p>What I was also aiming at is possibly something that could replace e.g. NSSortDescriptor, which can be handy in the UI, but requires dynamic (@objc) properties in order to work. <br></p><p>What I&#39;m suggesting, would also emit a function symbol for sorting the array by a particular key, so the sorting could actually be dynamic - supply a key (using #keyPath()) which is @sortable, given name mangling is stable in Swift 4, you can create the well-defined function symbol name, make a lookup via dyld and call it.<br></p><p>Note that the NSSortDescriptor is just an example and given most of my development is on macOS, I use bindings and NSArrayController where the sort descriptors are fairly common unlike with iOS... But the usage of this can be extended to many other areas given that you *know* that there is a function out there, with that particular signature that will sort the array...<br></p><p><br>&gt; On Aug 17, 2016, at 12:45 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Aug 16, 2016 at 5:35 PM, Anton Zhilin &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; wrote:<br>&gt; What we need here is  sort_by  from Ruby. How about adding these overloads?<br>&gt; <br>&gt; func sort&lt;U: Comparable&gt;(by: (T) -&gt; U)<br>&gt; func sorted&lt;U: Comparable&gt;(by: (T) -&gt; U) -&gt; [T]<br>&gt; <br>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure predicate is already standardized to `by:`.<br>&gt; (Or, as I propose above, once `Ordering` comes to the stdlib, we can just have it as `func sort&lt;U: Comparable&gt;(_ ordering: Ordering, by: (T) -&gt; U)`, called like `sort(.ascending) { $0.age }`.)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/bc902cbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Discussion] Sortable Attribute</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 11:00:00pm</p></header><div class="content"><p>On Tue, Aug 16, 2016 at 11:31 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; My original intention was to get rid of re-defining what should be the<br>&gt; sequence sorted by. For example, if self.sorted { $0.age &lt; $1.age } was at<br>&gt; 10 places in code, I would not consider it a good coding technique and<br>&gt; would definitely suggest the person to create a method for this -<br>&gt; sortedByAge().<br>&gt;<br>&gt; self.sorted(.ascending) { $0.age } is a bit better, but I still feel that<br>&gt; there is a lot of duplicate code and if one used this in 10 places over the<br>&gt; project, a method for this should be created instead.<br>&gt;<br>&gt; Don&#39;t you agree that people.sortedByAge() reads better than<br>&gt; self.sorted(.ascending) { $0.age }?<br>&gt;<br>&gt; What I was also aiming at is possibly something that could replace e.g.<br>&gt; NSSortDescriptor, which can be handy in the UI, but requires dynamic<br>&gt; (@objc) properties in order to work.<br>&gt;<br>&gt; What I&#39;m suggesting, would also emit a function symbol for sorting the<br>&gt; array by a particular key, so the sorting could actually be dynamic -<br>&gt; supply a key (using #keyPath()) which is @sortable, given name mangling is<br>&gt; stable in Swift 4, you can create the well-defined function symbol name,<br>&gt; make a lookup via dyld and call it.<br>&gt;<br>&gt; Note that the NSSortDescriptor is just an example and given most of my<br>&gt; development is on macOS, I use bindings and NSArrayController where the<br>&gt; sort descriptors are fairly common unlike with iOS... But the usage of this<br>&gt; can be extended to many other areas given that you *know* that there is a<br>&gt; function out there, with that particular signature that will sort the<br>&gt; array...<br>&gt;<br>&gt;<br>That does not strike me as a facility I would want. It seems like a lot of<br>special code to generate a wrapper for a very specific single line of code.<br></p><p>On Aug 17, 2016, at 12:45 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 5:35 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; What we need here is  sort_by  from Ruby. How about adding these<br>&gt;&gt; overloads?<br>&gt;&gt;<br>&gt;&gt; func sort&lt;U: Comparable&gt;(by: (T) -&gt; U)<br>&gt;&gt; func sorted&lt;U: Comparable&gt;(by: (T) -&gt; U) -&gt; [T]<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;d be in favor. We&#39;d need another name, since the current closure<br>&gt; predicate is already standardized to `by:`.<br>&gt; (Or, as I propose above, once `Ordering` comes to the stdlib, we can just<br>&gt; have it as `func sort&lt;U: Comparable&gt;(_ ordering: Ordering, by: (T) -&gt; U)`,<br>&gt; called like `sort(.ascending) { $0.age }`.)<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/4dc5061e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
