<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 22, 2016 at 04:00:00pm</p></header><div class="content"><p>Thank you everyone for the feedback. I think that suppressing the warnings generated by this is something that Swift doesn’t support at all right now. Therefore, I think that if/when the ability to suppress warnings is added, it will work for this as well. I don’t think this proposal needs to say anything about being able to suppress the warning, because it would be done at the call site anyway.<br></p><p>@plx: Given the examples you provided and my thoughts above, I think in this case you would just see the warning and just need to ignore it, because you know that you are doing it correctly. I think that is probably best at this point. The real solution would be to really enforce that member variables are not mutated according to the start/end parameter, but I don’t think that is really necessary as the warning can be ignored in these cases.<br></p><p>@haravikk: I still don’t see a reason to have a parameter for saying that it is required, since as we both agreed, it makes sense that only when the attribute is defined, is it required. Having the attribute declared but not have required would basically be invalid. I think baking it into the name like I originally suggested is probably best, as @super by itself is probably not explicit enough. The naming of these attributes and casing are being debated in a different thread, so I think I will just submit my suggestion with the idea that it can be corrected to fit what they decide in the other thread.<br></p><p>Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br></p><p># Enforcing Calling Super<br></p><p>* Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>* Author(s): [Kyle Sherman](https://github.com/drumnkyle)<br>* Status: **Awaiting review**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called either before any other implementation in the method (similar to initialization rules) or as the last line in the method.<br></p><p>Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010509.html)<br></p><p>## Motivation<br></p><p>A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br></p><p>Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br></p><p>## Proposed solution<br></p><p>The solution proposed here would be to use an attribute similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br></p><p>The compiler would use the information from the attribute to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the attribute. The compiler would also need to ensure that any method that was going to use this attribute had the same access control level as the class that contains it.<br></p><p>This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br></p><p>## Detailed design<br></p><p>A possible implementation of this may look like this:<br></p><p>```<br>class MyClass {<br>    @requiresSuper func foo1() { }<br></p><p>    @requiresSuper(start) func foo2() { }<br></p><p>    @requiresSuper(end) func foo3() { }<br>}<br>```<br></p><p>Now, if the developer were to create a subclass and not call the super method, the compiler should display a warning. The warnings that should be displayed should be similar to: <br>Overridden method must call the superclass’s implementation<br>Overridden method must call the superclass’s implementation as the first line of the method.<br>Overridden method must call the superclass’s implementation as the last line of the method.<br>for the cases of `@requiresSuper`, `@requiresSuper(start)`, and `@requiresSuper(end)` respectively.<br></p><p>The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br></p><p>```<br>public class MyClass {<br>    @requiresSuper func foo() { }<br>}<br>```<br></p><p>The compiler should show a warning, such as “A method using @requiresSuper must have access control set to be at least as accessible as the class that contains it”.<br></p><p>There can also be a simple fix-it that adds in the call to the super’s method. The specifics of the exact name and syntax is flexible as long as it has the 3 features proposed and produces a warning.<br></p><p>## Impact on existing code<br></p><p>The good thing about this change is that it will not have any impact on existing Swift code. This is an optional attribute provided by the developer. Therefore, if the attribute is not used, nothing is changed.<br></p><p>Unfortunately, there is no good way to automatically migrate code to use this new attribute, because the information would have only been embedded in comments previously. Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability attributes to Objective-C.<br></p><p>It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br></p><p>## Alternatives considered<br></p><p>The alternative would simply be to not implement this feature.<br></p><p>&gt; I hope we will be able to use something like the clang diagnostic macro&#39;s to do that...<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 18 Feb 2016, at 15:02, plx via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; <br>&gt; &gt; I think something like this making it into Swift at some point would be great, even if it’s just the `@requiresSuper` form; the positional variants would be even better.<br>&gt; &gt; <br>&gt; &gt; However, I think any proposal like this will be *unusable* unless it *also* includes some way of explicitly marking a specific super-call as “OK, despite how it looks!”…and this is true even if you spec the feature out to only produce warnings, b/c even then you may want to silence those warnings at specific, “known-no-problem” call sites.<br>&gt; &gt; <br>&gt; &gt; Here are two concrete examples:<br>&gt; &gt; <br>&gt; &gt; // suppose `updateConstraints` has `@super(end)` applied to it:<br>&gt; &gt; override func updateConstraints() {<br>&gt; &gt; // figure out where a bug is coming from:<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#before constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#beforeconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; self.updateMyLocalConstraints()<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#after constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#afterconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; super.updateConstraints() //&lt;- not last call, but actually ok<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#final constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; debugLog(“&lt;ISSUE 124&gt;#finalconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; // suppose `layoutSubviews` has `@super(begin)` applied to it:<br>&gt; &gt; override func layoutSubviews() {<br>&gt; &gt; // capture timing info in debug runs:<br>&gt; &gt; #if DEBUG<br>&gt; &gt; self.performTimedBlock(“updateConstraints”) {<br>&gt; &gt; super.layoutSubviews() //&lt;- not “first call”, but actually ok<br>&gt; &gt; self.layoutMyCustomSubviews()<br>&gt; &gt; }<br>&gt; &gt; #else<br>&gt; &gt; super.layoutSubviews()<br>&gt; &gt; self.layoutMyCustomSubviews()<br>&gt; &gt; #endif<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; …and I picked these because they’re examples where we are actually obeying the “spirit&quot; of the @super annotation.<br>&gt; &gt; <br>&gt; &gt; Such an annotation could either be applied to the method (something like: `@force(@super(end):true)`?), or perhaps an annotation applied to the specific call-site…but right now, I don’t think Swift has anything at all that uses a &quot;call-site” attribute.<br>&gt; &gt; <br>&gt; &gt; Are there any?<br>&gt; &gt; <br>&gt; &gt; &gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The link to the original discussion is here:https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The subject was: “Replace the override keyword by ‘extend’ and ‘replace’ or add an annotation like @SuppressSuperCall”<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; -Kyle<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; # Enforcing Calling Super<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)<br>&gt; &gt; &gt; * Author(s): [Swift Developer](https://github.com/swiftdev)<br>&gt; &gt; &gt; * Status: **Awaiting review**<br>&gt; &gt; &gt; * Review manager: TBD<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; ## Introduction<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules).<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution)<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; ## Motivation<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift.<br>&gt; &gt; &gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail.<br>&gt; &gt; &gt; ## Proposed solution<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method.<br>&gt; &gt; &gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt; &gt; &gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; ## Detailed design<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; A possible implementation of this may look like this:<br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt; class MyClass {<br>&gt; &gt; &gt; @requiredSuper func foo1() { }<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; @requiredSuper(start) func foo2() { }<br>&gt; &gt; &gt; @requiredSuper(end) func foo3() { }<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to:<br>&gt; &gt; &gt; Overridden method must call the superclass’s implementation<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt; public class MyClass {<br>&gt; &gt; &gt; @requiredSuper func foo() { }<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; ```<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; The compiler should show an error, such as “A method using @requiredSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; ## Impact on existing code<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt; &gt; &gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; ## Alternatives considered<br>&gt; &gt; &gt; The alternative would simply be to not implement this feature.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160222/bef69440/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>February 23, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 23 Feb 2016, at 00:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br></p><p>You could mention the `objc_requires_super` attribute in your proposal.<br></p><p>&lt;http://clang.llvm.org/docs/AttributeReference.html#objc-requires-super&gt;<br></p><p>But I haven&#39;t found it used in Apple&#39;s frameworks.<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3679b974d53f17b3b684fc9cadb99fa3?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Kyle Sherman</string> &lt;kyledsherman at gmail.com&gt;<p>February 22, 2016 at 05:00:00pm</p></header><div class="content"><p>Good call Ben! I never knew about that. Seems like maybe Apple even forgot about it. Lol<br></p><p>Sent from my iPhone<br></p><p>On Feb 22, 2016, at 5:14 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br></p><p><br>&gt; On 23 Feb 2016, at 00:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br></p><p>You could mention the `objc_requires_super` attribute in your proposal.<br></p><p>&lt;http://clang.llvm.org/docs/AttributeReference.html#objc-requires-super&gt;<br></p><p>But I haven&#39;t found it used in Apple&#39;s frameworks.<br></p><p>-- Ben<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 5:14 PM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 23 Feb 2016, at 00:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br>&gt; <br>&gt; You could mention the `objc_requires_super` attribute in your proposal.<br>&gt; <br>&gt; &lt;http://clang.llvm.org/docs/AttributeReference.html#objc-requires-super&gt;<br>&gt; <br>&gt; But I haven&#39;t found it used in Apple&#39;s frameworks.<br></p><p>Foundation.h wraps it as NS_REQUIRES_SUPER. That spelling is used in most places. There was no deliberate effort to annotate old API so it is likely that many potential uses were not updated.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 23 Feb 2016, at 00:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; @haravikk: I still don’t see a reason to have a parameter for saying that it is required, since as we both agreed, it makes sense that only when the attribute is defined, is it required. Having the attribute declared but not have required would basically be invalid. I think baking it into the name like I originally suggested is probably best, as @super by itself is probably not explicit enough. The naming of these attributes and casing are being debated in a different thread, so I think I will just submit my suggestion with the idea that it can be corrected to fit what they decide in the other thread.<br></p><p>My reasoning was that it may make sense to have a distinction between required and other restriction types, for example:<br></p><p>optional: super call can be included if desired (this is the default, but IMO before/after should default to being requirements, so this would be useful for changing that).<br>required: super call *must* be included or an error is produced<br>warn: downgrades errors to warnings, implies required by default (i.e- super call *should* be included or a warning is produced)<br>replace: super call should not be included or an error is produced (i.e- the requirement is that overriding methods must be a total replacement)<br></p><p>While the proposal doesn’t have to push for these up front, I think that they still make sense as possible extensions of the feature, and adding @warnSuper, @optionalSuper etc. would make things more unwieldy. But the added flexibility would be very useful, for example:<br></p><p>	@super(optional, before)	// super call isn’t required, but if it is included it must come first.<br>	@super(replace, warn)		// downgrades replace to a warning, so a developer can still use the super call if they like, but should be very sure they know what they’re doing.<br></p><p>Personally I think @super is clear enough, though @includeSuper or such may be more-so. I just think that @requireSuper is too specific, especially if the default for the proposal is to generate a warning, since as mentioned we may want to push an error if we know that our parent class will break horribly if its method(s) aren’t called.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/29bfc316/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 23, 2016 at 01:00:00pm</p></header><div class="content"><p>My 5c on this topic: I would be ok with adding a directive like @requiredSuper (even though I am afraid it will be abused). However, I am very much agains any more precise annotations or implicit super calls. I do not think it adds much utility to the language, however it most certainly allows more ways to mess with the users of your library. <br></p><p>Best, <br></p><p> Taras<br></p><p>&gt; On 23 Feb 2016, at 10:02, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 23 Feb 2016, at 00:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; @haravikk: I still don’t see a reason to have a parameter for saying that it is required, since as we both agreed, it makes sense that only when the attribute is defined, is it required. Having the attribute declared but not have required would basically be invalid. I think baking it into the name like I originally suggested is probably best, as @super by itself is probably not explicit enough. The naming of these attributes and casing are being debated in a different thread, so I think I will just submit my suggestion with the idea that it can be corrected to fit what they decide in the other thread.<br>&gt; <br>&gt; My reasoning was that it may make sense to have a distinction between required and other restriction types, for example:<br>&gt; <br>&gt; optional: super call can be included if desired (this is the default, but IMO before/after should default to being requirements, so this would be useful for changing that).<br>&gt; required: super call *must* be included or an error is produced<br>&gt; warn: downgrades errors to warnings, implies required by default (i.e- super call *should* be included or a warning is produced)<br>&gt; replace: super call should not be included or an error is produced (i.e- the requirement is that overriding methods must be a total replacement)<br>&gt; <br>&gt; While the proposal doesn’t have to push for these up front, I think that they still make sense as possible extensions of the feature, and adding @warnSuper, @optionalSuper etc. would make things more unwieldy. But the added flexibility would be very useful, for example:<br>&gt; <br>&gt; 	@super(optional, before)	// super call isn’t required, but if it is included it must come first.<br>&gt; 	@super(replace, warn)		// downgrades replace to a warning, so a developer can still use the super call if they like, but should be very sure they know what they’re doing.<br>&gt; <br>&gt; Personally I think @super is clear enough, though @includeSuper or such may be more-so. I just think that @requireSuper is too specific, especially if the default for the proposal is to generate a warning, since as mentioned we may want to push an error if we know that our parent class will break horribly if its method(s) aren’t called.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/a70ff4ed/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 23, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Feb 22, 2016, at 6:51 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you everyone for the feedback. I think that suppressing the warnings generated by this is something that Swift doesn’t support at all right now. Therefore, I think that if/when the ability to suppress warnings is added, it will work for this as well. I don’t think this proposal needs to say anything about being able to suppress the warning, because it would be done at the call site anyway.<br>&gt; <br>&gt; @plx: Given the examples you provided and my thoughts above, I think in this case you would just see the warning and just need to ignore it, because you know that you are doing it correctly. I think that is probably best at this point. The real solution would be to really enforce that member variables are not mutated according to the start/end parameter, but I don’t think that is really necessary as the warning can be ignored in these cases.<br></p><p>I do understand your point, but at the same time I wouldn’t be able to really use this feature until either “local warning suppression” (as a general feature, e.g. a Swift form of `#pragma clang diagnostic push` and so on...) or call-site annotations (e.g. as could be used to say “this counts as super(begin)”).<br></p><p>This is a policy issue (e.g. a policy of “all checked-in code must compile w/out warnings”) and not really a language issue specific to this feature, but it’d still a blocker in (for me) in terms of actually making use of such annotations.<br></p><p>One thing I want to make explicit is that even if it’s just @requireSuper w/out the positional features, the closure example is problematic:<br></p><p>// assume @requireSuper has been added<br>override func layoutSubviews() {<br>  self.performMeasuredAction(“layout”) {<br>    super.layoutSubviews()<br>    self.layoutLocalSubviews()<br>  }<br>}<br></p><p>…does `performMeasuredAction` actually call that closure? <br></p><p>How would the compiler know?<br></p><p>Anyways I think even the most basic version of a feature like this is a win, but practically-speaking it’s a win I may not be able to use in general w/out a corresponding feature to annotate call sites (or locally suppress warnings, etc.).<br></p><p>&gt; @haravikk: I still don’t see a reason to have a parameter for saying that it is required, since as we both agreed, it makes sense that only when the attribute is defined, is it required. Having the attribute declared but not have required would basically be invalid. I think baking it into the name like I originally suggested is probably best, as @super by itself is probably not explicit enough. The naming of these attributes and casing are being debated in a different thread, so I think I will just submit my suggestion with the idea that it can be corrected to fit what they decide in the other thread.<br>&gt; <br>&gt; Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br>&gt; <br>&gt; # Enforcing Calling Super<br>&gt; <br>&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; * Author(s): [Kyle Sherman](https://github.com/drumnkyle &lt;https://github.com/drumnkyle&gt;)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called either before any other implementation in the method (similar to initialization rules) or as the last line in the method.<br>&gt; <br>&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010509.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010509.html&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt; <br>&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; The solution proposed here would be to use an attribute similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt; <br>&gt; The compiler would use the information from the attribute to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the attribute. The compiler would also need to ensure that any method that was going to use this attribute had the same access control level as the class that contains it.<br>&gt; <br>&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; A possible implementation of this may look like this:<br>&gt; <br>&gt; ```<br>&gt; class MyClass {<br>&gt;     @requiresSuper func foo1() { }<br>&gt; <br>&gt;     @requiresSuper(start) func foo2() { }<br>&gt; <br>&gt;     @requiresSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display a warning. The warnings that should be displayed should be similar to: <br>&gt; Overridden method must call the superclass’s implementation<br>&gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt; for the cases of `@requiresSuper`, `@requiresSuper(start)`, and `@requiresSuper(end)` respectively.<br>&gt; <br>&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt; <br>&gt; ```<br>&gt; public class MyClass {<br>&gt;     @requiresSuper func foo() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The compiler should show a warning, such as “A method using @requiresSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt; <br>&gt; There can also be a simple fix-it that adds in the call to the super’s method. The specifics of the exact name and syntax is flexible as long as it has the 3 features proposed and produces a warning.<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; The good thing about this change is that it will not have any impact on existing Swift code. This is an optional attribute provided by the developer. Therefore, if the attribute is not used, nothing is changed.<br>&gt; <br>&gt; Unfortunately, there is no good way to automatically migrate code to use this new attribute, because the information would have only been embedded in comments previously. Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability attributes to Objective-C.<br>&gt; <br>&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; The alternative would simply be to not implement this feature.<br>&gt; <br>&gt; &gt; I hope we will be able to use something like the clang diagnostic macro&#39;s to do that...<br>&gt; &gt; <br>&gt; &gt; Sent from my iPhone<br>&gt; &gt; <br>&gt; &gt; On 18 Feb 2016, at 15:02, plx via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; &gt; I think something like this making it into Swift at some point would be great, even if it’s just the `@requiresSuper` form; the positional variants would be even better.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; However, I think any proposal like this will be *unusable* unless it *also* includes some way of explicitly marking a specific super-call as “OK, despite how it looks!”…and this is true even if you spec the feature out to only produce warnings, b/c even then you may want to silence those warnings at specific, “known-no-problem” call sites.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Here are two concrete examples:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; // suppose `updateConstraints` has `@super(end)` applied to it:<br>&gt; &gt; &gt; override func updateConstraints() {<br>&gt; &gt; &gt; // figure out where a bug is coming from:<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#before constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#beforeconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; &gt; self.updateMyLocalConstraints()<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#after constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#afterconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; &gt; super.updateConstraints() //&lt;- not last call, but actually ok<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#final constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#finalconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; // suppose `layoutSubviews` has `@super(begin)` applied to it:<br>&gt; &gt; &gt; override func layoutSubviews() {<br>&gt; &gt; &gt; // capture timing info in debug runs:<br>&gt; &gt; &gt; #if DEBUG<br>&gt; &gt; &gt; self.performTimedBlock(“updateConstraints”) {<br>&gt; &gt; &gt; super.layoutSubviews() //&lt;- not “first call”, but actually ok<br>&gt; &gt; &gt; self.layoutMyCustomSubviews()<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; #else<br>&gt; &gt; &gt; super.layoutSubviews()<br>&gt; &gt; &gt; self.layoutMyCustomSubviews()<br>&gt; &gt; &gt; #endif<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; …and I picked these because they’re examples where we are actually obeying the “spirit&quot; of the @super annotation.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Such an annotation could either be applied to the method (something like: `@force(@super(end):true)`?), or perhaps an annotation applied to the specific call-site…but right now, I don’t think Swift has anything at all that uses a &quot;call-site” attribute.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Are there any?<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt; &gt; &gt; &gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; The link to the original discussion is here:https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;http://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; The subject was: “Replace the override keyword by ‘extend’ and ‘replace’ or add an annotation like @SuppressSuperCall”<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; -Kyle<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; # Enforcing Calling Super<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt; &gt; &gt; &gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt; &gt; &gt; &gt; * Status: **Awaiting review**<br>&gt; &gt; &gt; &gt; * Review manager: TBD<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; ## Introduction<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules).<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; ## Motivation<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift.<br>&gt; &gt; &gt; &gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail.<br>&gt; &gt; &gt; &gt; ## Proposed solution<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method.<br>&gt; &gt; &gt; &gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt; &gt; &gt; &gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; ## Detailed design<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; A possible implementation of this may look like this:<br>&gt; &gt; &gt; &gt; ```<br>&gt; &gt; &gt; &gt; class MyClass {<br>&gt; &gt; &gt; &gt; @requiredSuper func foo1() { }<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; @requiredSuper(start) func foo2() { }<br>&gt; &gt; &gt; &gt; @requiredSuper(end) func foo3() { }<br>&gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; ```<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to:<br>&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt; &gt; &gt; &gt; ```<br>&gt; &gt; &gt; &gt; public class MyClass {<br>&gt; &gt; &gt; &gt; @requiredSuper func foo() { }<br>&gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt; ```<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; The compiler should show an error, such as “A method using @requiredSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; ## Impact on existing code<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt; &gt; &gt; &gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; ## Alternatives considered<br>&gt; &gt; &gt; &gt; The alternative would simply be to not implement this feature.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/b214fd4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 23, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 23 févr. 2016 à 09:18, plx via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 22, 2016, at 6:51 PM, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you everyone for the feedback. I think that suppressing the warnings generated by this is something that Swift doesn’t support at all right now. Therefore, I think that if/when the ability to suppress warnings is added, it will work for this as well. I don’t think this proposal needs to say anything about being able to suppress the warning, because it would be done at the call site anyway.<br>&gt;&gt; <br>&gt;&gt; @plx: Given the examples you provided and my thoughts above, I think in this case you would just see the warning and just need to ignore it, because you know that you are doing it correctly. I think that is probably best at this point. The real solution would be to really enforce that member variables are not mutated according to the start/end parameter, but I don’t think that is really necessary as the warning can be ignored in these cases.<br>&gt; <br>&gt; I do understand your point, but at the same time I wouldn’t be able to really use this feature until either “local warning suppression” (as a general feature, e.g. a Swift form of `#pragma clang diagnostic push` and so on...) or call-site annotations (e.g. as could be used to say “this counts as super(begin)”).<br>&gt; <br>&gt; This is a policy issue (e.g. a policy of “all checked-in code must compile w/out warnings”) and not really a language issue specific to this feature, but it’d still a blocker in (for me) in terms of actually making use of such annotations.<br>&gt; <br>&gt; One thing I want to make explicit is that even if it’s just @requireSuper w/out the positional features, the closure example is problematic:<br>&gt; <br>&gt; // assume @requireSuper has been added<br>&gt; override func layoutSubviews() {<br>&gt;   self.performMeasuredAction(“layout”) {<br>&gt;     super.layoutSubviews()<br>&gt;     self.layoutLocalSubviews()<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; …does `performMeasuredAction` actually call that closure? <br>&gt; <br>&gt; How would the compiler know?<br>&gt; <br></p><p>I think that what was discussed under Guaranteed closure execution (aka @noescape(once)) (https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md &lt;https://github.com/zneak/swift-evolution/blob/master/proposals/00xx-noescape-once.md&gt;) could be able to detect that the super requirement is met in this particular scenario.<br></p><p>Dany<br></p><p>&gt; Anyways I think even the most basic version of a feature like this is a win, but practically-speaking it’s a win I may not be able to use in general w/out a corresponding feature to annotate call sites (or locally suppress warnings, etc.).<br>&gt; <br>&gt;&gt; @haravikk: I still don’t see a reason to have a parameter for saying that it is required, since as we both agreed, it makes sense that only when the attribute is defined, is it required. Having the attribute declared but not have required would basically be invalid. I think baking it into the name like I originally suggested is probably best, as @super by itself is probably not explicit enough. The naming of these attributes and casing are being debated in a different thread, so I think I will just submit my suggestion with the idea that it can be corrected to fit what they decide in the other thread.<br>&gt;&gt; <br>&gt;&gt; Here is an updated version of the proposal. If no one has any other comments. Please review and let me know, because I would like to submit it for a review after I get comments on this version.<br>&gt;&gt; <br>&gt;&gt; # Enforcing Calling Super<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt; * Author(s): [Kyle Sherman](https://github.com/drumnkyle &lt;https://github.com/drumnkyle&gt;)<br>&gt;&gt; * Status: **Awaiting review**<br>&gt;&gt; * Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called either before any other implementation in the method (similar to initialization rules) or as the last line in the method.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010509.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010509.html&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift. <br>&gt;&gt; <br>&gt;&gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail. <br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution proposed here would be to use an attribute similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method. <br>&gt;&gt; <br>&gt;&gt; The compiler would use the information from the attribute to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the attribute. The compiler would also need to ensure that any method that was going to use this attribute had the same access control level as the class that contains it.<br>&gt;&gt; <br>&gt;&gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; A possible implementation of this may look like this:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; class MyClass {<br>&gt;&gt;     @requiresSuper func foo1() { }<br>&gt;&gt; <br>&gt;&gt;     @requiresSuper(start) func foo2() { }<br>&gt;&gt; <br>&gt;&gt;     @requiresSuper(end) func foo3() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display a warning. The warnings that should be displayed should be similar to: <br>&gt;&gt; Overridden method must call the superclass’s implementation<br>&gt;&gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt;&gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt;&gt; for the cases of `@requiresSuper`, `@requiresSuper(start)`, and `@requiresSuper(end)` respectively.<br>&gt;&gt; <br>&gt;&gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; public class MyClass {<br>&gt;&gt;     @requiresSuper func foo() { }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The compiler should show a warning, such as “A method using @requiresSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt;&gt; <br>&gt;&gt; There can also be a simple fix-it that adds in the call to the super’s method. The specifics of the exact name and syntax is flexible as long as it has the 3 features proposed and produces a warning.<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The good thing about this change is that it will not have any impact on existing Swift code. This is an optional attribute provided by the developer. Therefore, if the attribute is not used, nothing is changed.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, there is no good way to automatically migrate code to use this new attribute, because the information would have only been embedded in comments previously. Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability attributes to Objective-C.<br>&gt;&gt; <br>&gt;&gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The alternative would simply be to not implement this feature.<br>&gt;&gt; <br>&gt;&gt; &gt; I hope we will be able to use something like the clang diagnostic macro&#39;s to do that...<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; On 18 Feb 2016, at 15:02, plx via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &gt; I think something like this making it into Swift at some point would be great, even if it’s just the `@requiresSuper` form; the positional variants would be even better.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; However, I think any proposal like this will be *unusable* unless it *also* includes some way of explicitly marking a specific super-call as “OK, despite how it looks!”…and this is true even if you spec the feature out to only produce warnings, b/c even then you may want to silence those warnings at specific, “known-no-problem” call sites.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Here are two concrete examples:<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; // suppose `updateConstraints` has `@super(end)` applied to it:<br>&gt;&gt; &gt; &gt; override func updateConstraints() {<br>&gt;&gt; &gt; &gt; // figure out where a bug is coming from:<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#before constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#beforeconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt;&gt; &gt; &gt; self.updateMyLocalConstraints()<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#after constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#afterconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt;&gt; &gt; &gt; super.updateConstraints() //&lt;- not last call, but actually ok<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#final constraints.horizontal: \(self.constraintsAffectingLayoutForAxis(.Horizontal))”)<br>&gt;&gt; &gt; &gt; debugLog(“&lt;ISSUE 124&gt;#finalconstraints.vertical: \(self.constraintsAffectingLayoutForAxis(.Vertical))”)<br>&gt;&gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; // suppose `layoutSubviews` has `@super(begin)` applied to it:<br>&gt;&gt; &gt; &gt; override func layoutSubviews() {<br>&gt;&gt; &gt; &gt; // capture timing info in debug runs:<br>&gt;&gt; &gt; &gt; #if DEBUG<br>&gt;&gt; &gt; &gt; self.performTimedBlock(“updateConstraints”) {<br>&gt;&gt; &gt; &gt; super.layoutSubviews() //&lt;- not “first call”, but actually ok<br>&gt;&gt; &gt; &gt; self.layoutMyCustomSubviews()<br>&gt;&gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; #else<br>&gt;&gt; &gt; &gt; super.layoutSubviews()<br>&gt;&gt; &gt; &gt; self.layoutMyCustomSubviews()<br>&gt;&gt; &gt; &gt; #endif<br>&gt;&gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; …and I picked these because they’re examples where we are actually obeying the “spirit&quot; of the @super annotation.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Such an annotation could either be applied to the method (something like: `@force(@super(end):true)`?), or perhaps an annotation applied to the specific call-site…but right now, I don’t think Swift has anything at all that uses a &quot;call-site” attribute.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Are there any?<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; On Feb 17, 2016, at 12:02 PM, Kyle Sherman via swift-evolution&lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt; I just saw that there was a discussion started about this topic just recently while I was developing this idea with my colleague Peter Livesey. So, I figured I would submit this proposal for discussion.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; The link to the original discussion is here:https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html &lt;http://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160215/010310.html&gt;<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; The subject was: “Replace the override keyword by ‘extend’ and ‘replace’ or add an annotation like @SuppressSuperCall”<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; -Kyle<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; # Enforcing Calling Super<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; * Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;)<br>&gt;&gt; &gt; &gt; &gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt;&gt; &gt; &gt; &gt; * Status: **Awaiting review**<br>&gt;&gt; &gt; &gt; &gt; * Review manager: TBD<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; ## Introduction<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Many times when creating a subclass the superclass has reasons for certain overridden methods to call the superclass’s version of the method. This change would enforce that the subclass called the superclass&#39;s method in its overridden version at compile time. Also, it would optionally enforce that the superclass&#39;s version would be called before any other implementation in the method (similar to initialization rules).<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Swift-evolution thread: [link to the discussion thread for that proposal](https://lists.swift.org/pipermail/swift-evolution &lt;https://lists.swift.org/pipermail/swift-evolution&gt;)<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; ## Motivation<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; A concrete example of the type of problem this solves can be taken from simple iOS code. When creating a subclass of UIViewController, you often need to override methods like viewDidLoad or viewWillAppear. You are supposed to call super.viewDidLoad or super.viewWillAppear, respectively, in your overridden implementation. If you don&#39;t, you will have undefined behavior and run into issues. Of course, this type of situation can be extrapolated to any class created in Swift.<br>&gt;&gt; &gt; &gt; &gt; Currently, the only way this can be enforced is by commenting the superclass&#39;s code and making a note in the documentation. Quite obviously this can cause many issues as mistakes can be made by new developers quite easily who didn&#39;t look at the documentation for the method or even seasoned developers who simply overlooked this small detail.<br>&gt;&gt; &gt; &gt; &gt; ## Proposed solution<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; The solution proposed here would be to use an annotation similar to @available and @noescape in order to convey this information. Optionally, the developer can also choose to specify that the super method must be called as the first line or last line of the overridden method.<br>&gt;&gt; &gt; &gt; &gt; The compiler would use the information from the annotation to ensure that any overridden version of the method must call super at the appropriate time according to the information given in the annotation. The compiler would also need to ensure that any method that was going to use this annotation had the same access control level as the class that contains it.<br>&gt;&gt; &gt; &gt; &gt; This solution will be much safer than what is currently available, because there is currently no way to enforce super being called in an overridden method. This bug happens constantly for iOS developers.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; ## Detailed design<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; A possible implementation of this may look like this:<br>&gt;&gt; &gt; &gt; &gt; ```<br>&gt;&gt; &gt; &gt; &gt; class MyClass {<br>&gt;&gt; &gt; &gt; &gt; @requiredSuper func foo1() { }<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; @requiredSuper(start) func foo2() { }<br>&gt;&gt; &gt; &gt; &gt; @requiredSuper(end) func foo3() { }<br>&gt;&gt; &gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; &gt; ```<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display an error. The errors that should be displayed should be similar to:<br>&gt;&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; for the cases of `@requiredSuper`, `@requiredSuper(start)`, and `@requiredSuper(end)` respectively.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; The compiler would also need to display an error in this case where the access control of the method is stricter than that of the class:<br>&gt;&gt; &gt; &gt; &gt; ```<br>&gt;&gt; &gt; &gt; &gt; public class MyClass {<br>&gt;&gt; &gt; &gt; &gt; @requiredSuper func foo() { }<br>&gt;&gt; &gt; &gt; &gt; }<br>&gt;&gt; &gt; &gt; &gt; ```<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; The compiler should show an error, such as “A method using @requiredSuper must have access control set to be at least as accessible as the class that contains it”.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; ## Impact on existing code<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; Implementation of this feature by the developer is completely optional. Therefore, existing code will be unaffected and no migration of code will be necessary. However, when APIs are updated to use this new feature, some code will not compile if the developer did not use the APIs correctly. This should be a welcomed compilation error as it will result in less buggy code at runtime. The impact of this change is similar to adding nullability annotations to Objective-C.<br>&gt;&gt; &gt; &gt; &gt; It will be impossible to migrate code automatically, because this information cannot be derived in any way aside from reading comments if and only if the API author documented it.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; ## Alternatives considered<br>&gt;&gt; &gt; &gt; &gt; The alternative would simply be to not implement this feature.<br>&gt;&gt; &gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt;&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;(mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;)<br>&gt;&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/00507fdb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 22 févr. 2016 à 19:51, Kyle Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; A possible implementation of this may look like this:<br>&gt; <br>&gt; ```<br>&gt; class MyClass {<br>&gt;     @requiresSuper func foo1() { }<br>&gt; <br>&gt;     @requiresSuper(start) func foo2() { }<br>&gt; <br>&gt;     @requiresSuper(end) func foo3() { }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Now, if the developer were to create a subclass and not call the super method, the compiler should display a warning. The warnings that should be displayed should be similar to: <br>&gt; Overridden method must call the superclass’s implementation<br>&gt; Overridden method must call the superclass’s implementation as the first line of the method.<br>&gt; Overridden method must call the superclass’s implementation as the last line of the method.<br>&gt; for the cases of `@requiresSuper`, `@requiresSuper(start)`, and `@requiresSuper(end)` respectively.<br>&gt; <br></p><p>Been following the many discussions on this topic and I do not think  that these start/end requirements will ever fly. Imposing such a specific location on the sub-classes will cause a lot of troubles, whether it being unable to add debug log, or to tweak parameters before passing them to super, in the end the developer of the main class won’t dare use such specification, to avoid pushing away potential sub-class developer, and as a way to preemptively mute their complaining.<br></p><p>OTOH, my guts are telling me that, some similar form of control may be desired on some occasion mainly when playing with resources, maybe for a setup-like method where super should be call before any other methods provided by the class, and or for close-like method, the reverse.  Unfortunately, unless such rules are made rigid (all or nothing) such syntax would likely be too convoluted and long; super.close() must be call after super.read(), super.write(), ...<br></p><p>A possible syntax for the rigid rules would be:<br></p><p>@requiresSuper(before: methods)<br>@requiresSuper(after: methods, propertiesSetter)<br>@requiresSuper(before: methods, propertiesGetter)<br></p><p>But, I do not have any examples in mind to corroborate that such options are better than the proposed @requiresSuper(start) and @requiresSuper(end). IMHO, I just think that @requiresSuper(start) and @requiresSuper(end) should be drop as too intransigent, which will cause them to be rarely used.<br></p><p>Dany<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160223/b0ce7ad9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforcing Calling Super</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 24 Feb 2016, at 02:07, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Been following the many discussions on this topic and I do not think  that these start/end requirements will ever fly. Imposing such a specific location on the sub-classes will cause a lot of troubles, whether it being unable to add debug log, or to tweak parameters before passing them to super, in the end the developer of the main class won’t dare use such specification, to avoid pushing away potential sub-class developer, and as a way to preemptively mute their complaining.<br></p><p>I mentioned in the previous discussion that before/after shouldn’t really be used in a general sense right now, but when we get abstract classes they will make a lot more sense depending upon what aspect of a type an abstract method actually implements. They shouldn’t be all that common, but when you’re absolutely certain that they’re need then they are important; for example if a parent class could be in an inconsistent state if its super method isn’t called first (meaning any other methods it implements could give undefined results if also used within the child class).<br></p><p>There are definitely use cases for these requirements, they just aren’t the most common, so shouldn’t be placed as restrictions unless you know you absolutely need them. That said, this is partly why the proposals seem to be erring toward issuing a warning as the default behaviour, as this means that a developer can still just ignore it and do what they like anyway, albeit accepting the risks it may involve.<br></p><p>Regarding putting things before the super call such as debug logs and parameter tweaks; this could still be possible if we can think of a good way to handle them, i.e- anything non-mutating could be fine, but the question is how to detect that; I’m not sure if adding such detection is worth the effort to allow niche usage around a niche requirement which, as a warning, you can just ignore anyway.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
