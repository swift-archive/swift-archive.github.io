<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 05:00:00pm</p></header><div class="content"><p>In Swift, we cannot compile:<br></p><p>_ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br></p><p>The reason for the compile-time error is that we are not in fact creating an array, but a tree – a more general structure of which arrays are only a special case. Given the well-deserved and growing reputation of Swift, one would hope that in this instance the compiler would be able to default to something like a:<br></p><p>enum Tree&lt;Value&gt; {<br>	case Leaf(Value)<br>	case Branches([Tree])<br>}<br></p><p>extension Tree : ArrayLiteralConvertible {<br>	init(arrayLiteral elements: Tree...) {<br>		self = .Branches(elements)<br>	}<br>}<br></p><p>For this to work in the playground, however, we must manually lift the values into the world of trees first. And to make that chore in turn easier on the eye we can introduce a:<br></p><p>prefix operator ◊ {} // looks a bit like a leaf (us/uk kbd: ⎇⇧V)<br>prefix func ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br></p><p>let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br></p><p>The point here is that if adding such a fundamental type to the Standard Library would not be a priority at present, it is not the end of the world since we can easily enough write it ourselves… What we cannot do ourselves, however, is to get rid of the need for that operator in the common scenario of initialising with literal values. For this we need a literal-convertible protocol requiring two initialisers:<br></p><p>protocol TreeLiteralConvertible {<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: Self...)<br>}<br></p><p>Then we could simply:<br></p><p>let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br></p><p>And, whilst we are at it, we could also get rid of the need for that operator in the case of nested associative arrays (again, you can try this in the playground):<br></p><p>enum DictionaryTree&lt;Key, Value&gt; {<br>	case Leaf(Value)<br>	case Branches([(Key, DictionaryTree)])<br>}<br></p><p>extension DictionaryTree : DictionaryLiteralConvertible {<br>	init(dictionaryLiteral pairs: (Key, DictionaryTree)...) {<br>		self = .Branches(pairs)<br>	}<br>}<br></p><p>prefix func ◊ &lt;Key, Value&gt; (leaf: Value) -&gt; DictionaryTree&lt;Key, Value&gt; { return .Leaf(leaf) }<br></p><p>let map: DictionaryTree&lt;String,Int&gt; = [<br>	&quot;A&quot; : [:],<br>	&quot;B&quot; : [<br>		&quot;Ba&quot; : ◊0,<br>		&quot;Bb&quot; : ◊0,<br>		&quot;Bc&quot; : [<br>			&quot;Bc1&quot; : ◊0,<br>			&quot;Bc2&quot; : ◊0,<br>			&quot;Bc3&quot; : ◊0<br>		]<br>	]<br>]<br></p><p>… by introducing an analogous protocol:<br></p><p>protocol DictionaryTreeLiteralConvertible {<br>	associatedtype Key<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: (Key, Self)...)<br>}<br></p><p>Please note: I do understand that fleshing out these structures (along with all the juicy methods, operators and lazy alternatives) may not currently be a priority for Swift. The two literal-convertible protocols however, may be a much less daunting task, which would open to us some very useful programming idioms…<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/3b81c4ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 14, 2016 at 08:00:00pm</p></header><div class="content"><p>Well, actually we can compile :<br></p><p>var zz : [Any] = [[Int](), 1,  [2, 3], [[4, 5], [6, 7], [8, 9]]]<br></p><p>[] - is empty array of unknown type, I think this is why you can&#39;t compile.<br></p><p>We need good language tools to process such kind of array, I agree with you.<br></p><p>As for your proposal.. I have no idea if this all is used often and can <br>make our life easier. Probably some other can provide us with opinion.<br></p><p>On 14.04.2016 19:27, Milos Rankovic via swift-evolution wrote:<br>&gt; In Swift, we cannot compile:<br>&gt;<br>&gt; _ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt;<br>&gt; The reason for the compile-time error is that we are not in fact creating<br>&gt; an array, but a tree – a more general structure of which arrays are only a<br>&gt; special case. Given the well-deserved and growing reputation of Swift, one<br>&gt; would hope that in this instance the compiler would be able to default to<br>&gt; something like a:<br>&gt;<br>&gt; enum Tree&lt;Value&gt; {<br>&gt; case Leaf(Value)<br>&gt; case Branches([Tree])<br>&gt; }<br>&gt;<br>&gt; extensionTree : ArrayLiteralConvertible {<br>&gt; init(arrayLiteral elements: Tree...) {<br>&gt; self = .Branches(elements)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; For this to work in the playground, however, we must manually lift the<br>&gt; values into the world of trees first. And to make that chore in turn easier<br>&gt; on the eye we can introduce a:<br>&gt;<br>&gt; prefixoperator ◊ {} // looks a bit like a leaf (us/uk kbd: *⎇⇧*V)<br>&gt; prefixfunc ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br>&gt;<br>&gt; let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br>&gt;<br>&gt; The point here is that if adding such a fundamental type to the Standard<br>&gt; Library would not be a priority at present, it is not the end of the world<br>&gt; since we can easily enough write it ourselves… What we cannot do ourselves,<br>&gt; however, is to get rid of the need for that operator in the common scenario<br>&gt; of initialising with literal values. For this we need a literal-convertible<br>&gt; protocol requiring *two* initialisers:<br>&gt;<br>&gt; protocolTreeLiteralConvertible {<br>&gt; associatedtypeLeafValue<br>&gt; init(literal: Self.LeafValue...)<br>&gt; init(literal: Self...)<br>&gt; }<br>&gt;<br>&gt; Then we could simply:<br>&gt;<br>&gt; let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt;<br>&gt; And, whilst we are at it, we could also get rid of the need for that<br>&gt; operator in the case of nested associative arrays (again, you can try this<br>&gt; in the playground):<br>&gt;<br>&gt; enumDictionaryTree&lt;Key, Value&gt; {<br>&gt; case Leaf(Value)<br>&gt; case Branches([(Key, DictionaryTree)])<br>&gt; }<br>&gt;<br>&gt; extensionDictionaryTree : DictionaryLiteralConvertible {<br>&gt; init(dictionaryLiteral pairs: (Key, DictionaryTree)...) {<br>&gt; self = .Branches(pairs)<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; prefixfunc ◊ &lt;Key, Value&gt; (leaf: Value) -&gt; DictionaryTree&lt;Key, Value&gt; {<br>&gt; return .Leaf(leaf) }<br>&gt;<br>&gt; let map: DictionaryTree&lt;String,Int&gt; = [<br>&gt; &quot;A&quot; : [:],<br>&gt; &quot;B&quot; : [<br>&gt; &quot;Ba&quot; : ◊0,<br>&gt; &quot;Bb&quot; : ◊0,<br>&gt; &quot;Bc&quot; : [<br>&gt; &quot;Bc1&quot; : ◊0,<br>&gt; &quot;Bc2&quot; : ◊0,<br>&gt; &quot;Bc3&quot; : ◊0<br>&gt; ]<br>&gt; ]<br>&gt; ]<br>&gt;<br>&gt; … by introducing an analogous protocol:<br>&gt;<br>&gt; protocolDictionaryTreeLiteralConvertible {<br>&gt; associatedtypeKey<br>&gt; associatedtypeLeafValue<br>&gt; init(literal: Self.LeafValue...)<br>&gt; init(literal: (Key, Self)...)<br>&gt; }<br>&gt;<br>&gt; Please note: I do understand that fleshing out these structures (along with<br>&gt; all the juicy methods, operators and lazy alternatives) may not currently<br>&gt; be a priority for Swift. The two literal-convertible protocols however, may<br>&gt; be a much less daunting task, which would open to us some very useful<br>&gt; programming idioms…<br>&gt;<br>&gt; milos<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks for the comment, Vladimir. <br></p><p>&gt; On 14 Apr 2016, at 18:14, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well, actually we can compile :<br>&gt; <br>&gt; var zz : [Any] = [[Int](), 1,  [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>Sure. I just wasn’t sure it was worth mentioning (it was a long post anyway): annotating the variable with `[Any]` is not preserving the leaf type nor does it do justice to the overall structure.<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/798631c1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>Hey, Milos!<br></p><p>Can you please give us a few real-world examples where initializing a nontrivial tree-like data structure in code would be useful?<br></p><p>It&#39;s an honest question — I have never felt the need in my life, and I always preferred to move the data into something like a bundled json or CSV, rather than providing it in code.<br></p><p>A.<br></p><p><br>&gt; On Apr 14, 2016, at 10:27 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Swift, we cannot compile:<br>&gt; <br>&gt; _ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt; The reason for the compile-time error is that we are not in fact creating an array, but a tree – a more general structure of which arrays are only a special case. Given the well-deserved and growing reputation of Swift, one would hope that in this instance the compiler would be able to default to something like a:<br>&gt; <br>&gt; enum Tree&lt;Value&gt; {<br>&gt; 	case Leaf(Value)<br>&gt; 	case Branches([Tree])<br>&gt; }<br>&gt; <br>&gt; extension Tree : ArrayLiteralConvertible {<br>&gt; 	init(arrayLiteral elements: Tree...) {<br>&gt; 		self = .Branches(elements)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; For this to work in the playground, however, we must manually lift the values into the world of trees first. And to make that chore in turn easier on the eye we can introduce a:<br>&gt; <br>&gt; prefix operator ◊ {} // looks a bit like a leaf (us/uk kbd: ⎇⇧V)<br>&gt; prefix func ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br>&gt; <br>&gt; The point here is that if adding such a fundamental type to the Standard Library would not be a priority at present, it is not the end of the world since we can easily enough write it ourselves… What we cannot do ourselves, however, is to get rid of the need for that operator in the common scenario of initialising with literal values. For this we need a literal-convertible protocol requiring two initialisers:<br>&gt; <br>&gt; protocol TreeLiteralConvertible {<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: Self...)<br>&gt; }<br>&gt; <br>&gt; Then we could simply:<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt; And, whilst we are at it, we could also get rid of the need for that operator in the case of nested associative arrays (again, you can try this in the playground):<br>&gt; <br>&gt; enum DictionaryTree&lt;Key, Value&gt; {<br>&gt; 	case Leaf(Value)<br>&gt; 	case Branches([(Key, DictionaryTree)])<br>&gt; }<br>&gt; <br>&gt; extension DictionaryTree : DictionaryLiteralConvertible {<br>&gt; 	init(dictionaryLiteral pairs: (Key, DictionaryTree)...) {<br>&gt; 		self = .Branches(pairs)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; prefix func ◊ &lt;Key, Value&gt; (leaf: Value) -&gt; DictionaryTree&lt;Key, Value&gt; { return .Leaf(leaf) }<br>&gt; <br>&gt; let map: DictionaryTree&lt;String,Int&gt; = [<br>&gt; 	&quot;A&quot; : [:],<br>&gt; 	&quot;B&quot; : [<br>&gt; 		&quot;Ba&quot; : ◊0,<br>&gt; 		&quot;Bb&quot; : ◊0,<br>&gt; 		&quot;Bc&quot; : [<br>&gt; 			&quot;Bc1&quot; : ◊0,<br>&gt; 			&quot;Bc2&quot; : ◊0,<br>&gt; 			&quot;Bc3&quot; : ◊0<br>&gt; 		]<br>&gt; 	]<br>&gt; ]<br>&gt; <br>&gt; … by introducing an analogous protocol:<br>&gt; <br>&gt; protocol DictionaryTreeLiteralConvertible {<br>&gt; 	associatedtype Key<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: (Key, Self)...)<br>&gt; }<br>&gt; <br>&gt; Please note: I do understand that fleshing out these structures (along with all the juicy methods, operators and lazy alternatives) may not currently be a priority for Swift. The two literal-convertible protocols however, may be a much less daunting task, which would open to us some very useful programming idioms…<br>&gt; <br>&gt; milos<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/756a4183/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 8:23 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, Milos!<br>&gt; <br>&gt; Can you please give us a few real-world examples where initializing a nontrivial tree-like data structure in code would be useful?<br>&gt; <br>&gt; It&#39;s an honest question — I have never felt the need in my life, and I always preferred to move the data into something like a bundled json or CSV, rather than providing it in code.<br>&gt; <br>&gt; A.<br>&gt; <br></p><p><br>ditto. <br>This is where in the simplest case I write a simple text(json) file, and in the more extreme cases, write a custom DSL+Eclipse Editor to deal with a complete custom file format (I said extreme.. but I did do it). I would even go further.. I’d rather the language do NOT make it easy to have complex literals initializations to avoid having to chase critical CONFIG elements in the source code. D has an interesting concept if you REALLY want do data in code: import (“data_in_code.d”) <br></p><p>&gt; <br>&gt;&gt; On Apr 14, 2016, at 10:27 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In Swift, we cannot compile:<br>&gt;&gt; <br>&gt;&gt; _ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt;&gt; <br>&gt;&gt; The reason for the compile-time error is that we are not in fact creating an array, but a tree – a more general structure of which arrays are only a special case. Given the well-deserved and growing reputation of Swift, one would hope that in this instance the compiler would be able to default to something like a:<br>&gt;&gt; <br>&gt;&gt; enum Tree&lt;Value&gt; {<br>&gt;&gt; 	case Leaf(Value)<br>&gt;&gt; 	case Branches([Tree])<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Tree : ArrayLiteralConvertible {<br>&gt;&gt; 	init(arrayLiteral elements: Tree...) {<br>&gt;&gt; 		self = .Branches(elements)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; For this to work in the playground, however, we must manually lift the values into the world of trees first. And to make that chore in turn easier on the eye we can introduce a:<br>&gt;&gt; <br>&gt;&gt; prefix operator ◊ {} // looks a bit like a leaf (us/uk kbd: ⎇⇧V)<br>&gt;&gt; prefix func ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br>&gt;&gt; <br>&gt;&gt; let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br>&gt;&gt; <br>&gt;&gt; The point here is that if adding such a fundamental type to the Standard Library would not be a priority at present, it is not the end of the world since we can easily enough write it ourselves… What we cannot do ourselves, however, is to get rid of the need for that operator in the common scenario of initialising with literal values. For this we need a literal-convertible protocol requiring two initialisers:<br>&gt;&gt; <br>&gt;&gt; protocol TreeLiteralConvertible {<br>&gt;&gt; 	associatedtype LeafValue<br>&gt;&gt; 	init(literal: Self.LeafValue...)<br>&gt;&gt; 	init(literal: Self...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then we could simply:<br>&gt;&gt; <br>&gt;&gt; let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt;&gt; <br>&gt;&gt; And, whilst we are at it, we could also get rid of the need for that operator in the case of nested associative arrays (again, you can try this in the playground):<br>&gt;&gt; <br>&gt;&gt; enum DictionaryTree&lt;Key, Value&gt; {<br>&gt;&gt; 	case Leaf(Value)<br>&gt;&gt; 	case Branches([(Key, DictionaryTree)])<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension DictionaryTree : DictionaryLiteralConvertible {<br>&gt;&gt; 	init(dictionaryLiteral pairs: (Key, DictionaryTree)...) {<br>&gt;&gt; 		self = .Branches(pairs)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; prefix func ◊ &lt;Key, Value&gt; (leaf: Value) -&gt; DictionaryTree&lt;Key, Value&gt; { return .Leaf(leaf) }<br>&gt;&gt; <br>&gt;&gt; let map: DictionaryTree&lt;String,Int&gt; = [<br>&gt;&gt; 	&quot;A&quot; : [:],<br>&gt;&gt; 	&quot;B&quot; : [<br>&gt;&gt; 		&quot;Ba&quot; : ◊0,<br>&gt;&gt; 		&quot;Bb&quot; : ◊0,<br>&gt;&gt; 		&quot;Bc&quot; : [<br>&gt;&gt; 			&quot;Bc1&quot; : ◊0,<br>&gt;&gt; 			&quot;Bc2&quot; : ◊0,<br>&gt;&gt; 			&quot;Bc3&quot; : ◊0<br>&gt;&gt; 		]<br>&gt;&gt; 	]<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; … by introducing an analogous protocol:<br>&gt;&gt; <br>&gt;&gt; protocol DictionaryTreeLiteralConvertible {<br>&gt;&gt; 	associatedtype Key<br>&gt;&gt; 	associatedtype LeafValue<br>&gt;&gt; 	init(literal: Self.LeafValue...)<br>&gt;&gt; 	init(literal: (Key, Self)...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Please note: I do understand that fleshing out these structures (along with all the juicy methods, operators and lazy alternatives) may not currently be a priority for Swift. The two literal-convertible protocols however, may be a much less daunting task, which would open to us some very useful programming idioms…<br>&gt;&gt; <br>&gt;&gt; milos<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/4be13dd5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Andrey and Laurent,<br></p><p>&gt; On 14 Apr 2016, at 19:23, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; <br>&gt; Can you please give us a few real-world examples where initializing a nontrivial tree-like data structure in code would be useful?<br>&gt; <br>&gt; It&#39;s an honest question — I have never felt the need in my life, and I always preferred to move the data into something like a bundled json or CSV, rather than providing it in code.<br></p><p>I suppose we always prefer to move *all* data into databases or files with dedicated data formats, *including* arrays, strings, dictionaries, etc. Sure. But it would be rather underwhelming if you could not also just instantiate an array or a string from a literal.<br></p><p>&gt; On 14 Apr 2016, at 19:33, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’d rather the language do NOT make it easy to have complex literals initializations<br></p><p><br>I agree, except, something like `[1, [2]]` doesn’t immediately strike me by its complexity. Likewise, I find it a little deflating that I cannot express a piece of JSON in code. My example structures do allow you to write:<br></p><p>let _: DictionaryTree&lt;String, String&gt; =<br>[<br>	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>	&quot;address&quot;: [<br>		&quot;streetAddress&quot;: ◊&quot;21 2nd Street&quot;,<br>		&quot;city&quot;: ◊&quot;New York&quot;<br>	]<br>]<br></p><p>… but I cannot get rid of that prefix operator without the additional literal-convertible protocols. Given the *simplicity* of these structures, it seems it should not be beyond Swift to represent them in code with ease and elegance. And to begin with, all we need are those couple of protocols.<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/cb18c380/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 12:01 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi Andrey and Laurent,<br>&gt; <br>&gt;&gt; On 14 Apr 2016, at 19:23, Andrey Tarantsov &lt;andrey at tarantsov.com &lt;mailto:andrey at tarantsov.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you please give us a few real-world examples where initializing a nontrivial tree-like data structure in code would be useful?<br>&gt;&gt; <br>&gt;&gt; It&#39;s an honest question — I have never felt the need in my life, and I always preferred to move the data into something like a bundled json or CSV, rather than providing it in code.<br>&gt; <br>&gt; I suppose we always prefer to move *all* data into databases or files with dedicated data formats, *including* arrays, strings, dictionaries, etc. Sure. But it would be rather underwhelming if you could not also just instantiate an array or a string from a literal.<br>&gt; <br>&gt;&gt; On 14 Apr 2016, at 19:33, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d rather the language do NOT make it easy to have complex literals initializations<br>&gt; <br>&gt; <br>&gt; I agree, except, something like `[1, [2]]` doesn’t immediately strike me by its complexity. Likewise, I find it a little deflating that I cannot express a piece of JSON in code. My example structures do allow you to write:<br>&gt; <br>&gt; let _: DictionaryTree&lt;String, String&gt; =<br>&gt; [<br>&gt; 	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>&gt; 	&quot;address&quot;: [<br>&gt; 		&quot;streetAddress&quot;: ◊&quot;21 2nd Street&quot;,<br>&gt; 		&quot;city&quot;: ◊&quot;New York&quot;<br>&gt; 	]<br>&gt; ]<br>&gt; <br>&gt; … but I cannot get rid of that prefix operator without the additional literal-convertible protocols. Given the *simplicity* of these structures, it seems it should not be beyond Swift to represent them in code with ease and elegance. And to begin with, all we need are those couple of protocols.<br></p><p>I mean, you could just make your Tree type implement all the individual literal-convertible protocols.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/31743b9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi John,<br></p><p>&gt; On 14 Apr 2016, at 21:09, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; I mean, you could just make your Tree type implement all the individual literal-convertible protocols.<br></p><p>It does sound like something like that should be doable, but it isn’t. The literal-convertible protocols only require one initialiser, but you need two: one that lifts leaf values to Self and the other that actually takes Self elements (it is this last one that provides for recursion). In other words, we’d need to overload our conformance:<br></p><p>extension Tree : ArrayLiteralConvertible { // error: does not conform!<br>	init(arrayLiteral elements: Tree...) {<br>		self = .Branches(elements)<br>	}<br>	init(arrayLiteral elements: Value...) {<br>		if elements.count == 1 { self = .Leaf(elements[0]) }<br>		else { self = .Branches(elements.map{ .Leaf($0) }) }<br>	}<br>}<br></p><p>But you can only conform in one or the other way, but not both! Therefore, for trees, we need something like:<br></p><p>protocol TreeLiteralConvertible {<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: Self...)<br>}<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/007db728/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 1:34 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; Hi John,<br>&gt; <br>&gt;&gt; On 14 Apr 2016, at 21:09, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I mean, you could just make your Tree type implement all the individual literal-convertible protocols.<br>&gt; <br>&gt; It does sound like something like that should be doable, but it isn’t. The literal-convertible protocols only require one initialiser, but you need two: one that lifts leaf values to Self and the other that actually takes Self elements (it is this last one that provides for recursion). In other words, we’d need to overload our conformance:<br>&gt; <br>&gt; extension Tree : ArrayLiteralConvertible { // error: does not conform!<br>&gt; 	init(arrayLiteral elements: Tree...) {<br>&gt; 		self = .Branches(elements)<br>&gt; 	}<br>&gt; 	init(arrayLiteral elements: Value...) {<br>&gt; 		if elements.count == 1 { self = .Leaf(elements[0]) }<br>&gt; 		else { self = .Branches(elements.map{ .Leaf($0) }) }<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; But you can only conform in one or the other way, but not both! Therefore, for trees, we need something like:<br>&gt; <br>&gt; protocol TreeLiteralConvertible {<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: Self...)<br>&gt; }<br></p><p>No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br></p><p>This would be easily done with conditional conformance; as it is, you&#39;ll simply have to make your Tree less generic, e.g. by always requiring Value to be IntegerLiteralConvertible.  Of course, this would not be a problem for a JSON tree, which would not be generic at all.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/d080fe48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 14 Apr 2016, at 21:36, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br></p><p>You mean this:<br></p><p>public enum IntTree {<br>	case Leaf(Int)<br>	case Branches([IntTree])<br>}<br></p><p>extension IntTree : ArrayLiteralConvertible {<br>	public init(arrayLiteral elements: IntTree...) {<br>		self = .Branches(elements)<br>	}<br>}<br></p><p>extension IntTree : IntegerLiteralConvertible {<br>	public init(integerLiteral value: IntegerLiteralType) {<br>		self = .Leaf(value)<br>	}<br>}<br></p><p>let tree: IntTree = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br></p><p>&gt; you&#39;ll simply have to make your Tree less generic<br></p><p><br>Yep, that’s the rub… With generic trees you can express yourself freely, whether you feel like:<br></p><p>import SpriteKit<br></p><p>let actionTree: Tree&lt;SKAction&gt; = [<br>	◊.waitForDuration(1),<br>	[<br>		◊.fadeInWithDuration(1),<br>		◊.scaleTo(1, duration: 1)<br>	],<br>	◊.playSoundFileNamed(&quot;TaDa&quot;, waitForCompletion: false)<br>]<br></p><p>… or:<br></p><p>let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>[<br>	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>	&quot;age&quot;: ◊25,<br>	&quot;address&quot;: [<br>		&quot;house_number&quot;: ◊21,<br>		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>		&quot;city&quot;: ◊&quot;New York&quot;<br>	]<br>]<br></p><p>I’d just love to get rid of that prefix operator…<br></p><p>milos<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/2a13170e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 2:03 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt;&gt; On 14 Apr 2016, at 21:36, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br>&gt; <br>&gt; You mean this:<br>&gt; <br>&gt; public enum IntTree {<br>&gt; 	case Leaf(Int)<br>&gt; 	case Branches([IntTree])<br>&gt; }<br>&gt; <br>&gt; extension IntTree : ArrayLiteralConvertible {<br>&gt; 	public init(arrayLiteral elements: IntTree...) {<br>&gt; 		self = .Branches(elements)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; extension IntTree : IntegerLiteralConvertible {<br>&gt; 	public init(integerLiteral value: IntegerLiteralType) {<br>&gt; 		self = .Leaf(value)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; let tree: IntTree = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt;&gt; you&#39;ll simply have to make your Tree less generic<br>&gt; <br>&gt; <br>&gt; Yep, that’s the rub… With generic trees you can express yourself freely, whether you feel like:<br>&gt; <br>&gt; import SpriteKit<br>&gt; <br>&gt; let actionTree: Tree&lt;SKAction&gt; = [<br>&gt; 	◊.waitForDuration(1),<br>&gt; 	[<br>&gt; 		◊.fadeInWithDuration(1),<br>&gt; 		◊.scaleTo(1, duration: 1)<br>&gt; 	],<br>&gt; 	◊.playSoundFileNamed(&quot;TaDa&quot;, waitForCompletion: false)<br>&gt; ]<br>&gt; <br>&gt; … or:<br>&gt; <br>&gt; let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>&gt; [<br>&gt; 	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>&gt; 	&quot;age&quot;: ◊25,<br>&gt; 	&quot;address&quot;: [<br>&gt; 		&quot;house_number&quot;: ◊21,<br>&gt; 		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>&gt; 		&quot;city&quot;: ◊&quot;New York&quot;<br>&gt; 	]<br>&gt; ]<br>&gt; <br>&gt; I’d just love to get rid of that prefix operator…<br></p><p>Note that all of your examples rely not just on recursion but on heterogeneous recursion, so the multiple-conformance idea doesn&#39;t work.  Fundamentally, your trees have a payload type that needs to be constructible from different kinds of literal.  It&#39;s appropriate to model that with conformance to multiple protocols.  The ability to do that conditionally based on whether another type declares a conformance is called &quot;conditional conformance&quot;, and it&#39;s already something we&#39;re strongly considering for the future; it&#39;s just not an easy feature to actually implement.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/e949949c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi John and Brent, <br></p><p>&gt; On 14 Apr 2016, at 22:22, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; multiple-conformance idea doesn&#39;t work<br></p><p><br>The idea is not multiple-conformance (or overloading), but multiple (two) initialisers required by the literal-convertible protocols:<br></p><p>protocol TreeLiteralConvertible {<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: Self...)<br>}<br></p><p>… and:<br></p><p>protocol DictionaryTreeLiteralConvertible {<br>	associatedtype Key<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: (Key, Self)...)<br>}<br></p><p>&gt; Note that all of your examples rely not just on recursion but on heterogeneous recursion<br></p><p>The crux of the matter is not heterogeneity in general, but of the leaf value in particular. This is what Brent is addressing. All my examples, save one, had a uniform leaf value type (even the Tree&lt;SKAction&gt; example). The one exception is my second JSON example. There I did not post the lift operator overload as you can probably imagine it. Minimally:<br></p><p>enum JSONValue {<br>	case Text(String)<br>	case Integer(Int)<br>}<br></p><p>prefix func ◊ &lt;Key&gt; (leaf: String) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>	return .Leaf(.Text(leaf))<br>}<br></p><p>prefix func ◊ &lt;Key&gt; (leaf: Int) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>	return .Leaf(.Integer(leaf))<br>}<br></p><p><br>let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>[<br>	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>	&quot;age&quot;: ◊25,<br>	&quot;address&quot;: [<br>		&quot;house_number&quot;: ◊21,<br>		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>		&quot;city&quot;: ◊&quot;New York&quot;<br>	]<br>]<br></p><p>Notice in particular how much contextual information you are getting from the expected return type. Still though, as Brent, points out, this won’t work with the two literal-convertable protocols. Nevertheless, I’d be very happy if they could be added as a first step since I suspect that would be the easiest option and one that would still allow for all my examples so far to work without the lift operator; all except this `JSONValue` example.<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/81d4e166/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 2:56 PM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt; Hi John and Brent, <br>&gt; <br>&gt;&gt; On 14 Apr 2016, at 22:22, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; multiple-conformance idea doesn&#39;t work<br>&gt; <br>&gt; <br>&gt; The idea is not multiple-conformance (or overloading), but multiple (two) initialisers required by the literal-convertible protocols:<br>&gt; <br>&gt; protocol TreeLiteralConvertible {<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: Self...)<br>&gt; }<br>&gt; <br>&gt; … and:<br>&gt; <br>&gt; protocol DictionaryTreeLiteralConvertible {<br>&gt; 	associatedtype Key<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: (Key, Self)...)<br>&gt; }<br>&gt; <br>&gt;&gt; Note that all of your examples rely not just on recursion but on heterogeneous recursion<br>&gt; <br>&gt; The crux of the matter is not heterogeneity in general, but of the leaf value in particular. This is what Brent is addressing. All my examples, save one, had a uniform leaf value type (even the Tree&lt;SKAction&gt; example).<br></p><p>The heterogeneity that I&#39;m referring to is the mix of sub-trees and leaves at a single level.<br></p><p>&gt; The one exception is my second JSON example. There I did not post the lift operator overload as you can probably imagine it. Minimally:<br></p><p>It&#39;s pretty implausible that we&#39;d ever add a &quot;tree literal&quot; concept that serves exactly your use case, so I&#39;m looking for ways to capture it that fit within the existing language framework, or at least take advantage of a more general addition to the language.<br></p><p>Your JSON literal example is already pretty well modeled by simply making a JSONValue type that conforms to all the literal protocols.  It is completely unclear why you would even want to model this with some generic Tree structure.  Note that neither your tree-literal-protocol proposal nor Brent&#39;s lifting-protocol proposal is actually adequate for embedding non-literal Int/Double/Bool values in the structure because they both only allow a single &quot;leaf&quot; type.<br></p><p>Your other examples could be modeled with either a lifting protocol or a conditional conformance.  I was just noting that the conditional conformance would be adequate if you were willing to manually lift non-literal values, and conditional conformances are a feature that&#39;s already basically planned, as opposed to a new research project.<br></p><p>John.<br></p><p><br></p><p><br></p><p><br>&gt; <br>&gt; enum JSONValue {<br>&gt; 	case Text(String)<br>&gt; 	case Integer(Int)<br>&gt; }<br>&gt; <br>&gt; prefix func ◊ &lt;Key&gt; (leaf: String) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>&gt; 	return .Leaf(.Text(leaf))<br>&gt; }<br>&gt; <br>&gt; prefix func ◊ &lt;Key&gt; (leaf: Int) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>&gt; 	return .Leaf(.Integer(leaf))<br>&gt; }<br>&gt; <br>&gt; <br>&gt; let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>&gt; [<br>&gt; 	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>&gt; 	&quot;age&quot;: ◊25,<br>&gt; 	&quot;address&quot;: [<br>&gt; 		&quot;house_number&quot;: ◊21,<br>&gt; 		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>&gt; 		&quot;city&quot;: ◊&quot;New York&quot;<br>&gt; 	]<br>&gt; ]<br>&gt; <br>&gt; Notice in particular how much contextual information you are getting from the expected return type. Still though, as Brent, points out, this won’t work with the two literal-convertable protocols. Nevertheless, I’d be very happy if they could be added as a first step since I suspect that would be the easiest option and one that would still allow for all my examples so far to work without the lift operator; all except this `JSONValue` example.<br>&gt; <br>&gt; milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/c1cf8b22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 15 Apr 2016, at 03:22, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; The heterogeneity that I&#39;m referring to is the mix of sub-trees and leaves at a single level.<br>… which is why I was making the point that that part of the heterogeneity problem is solved.<br></p><p>&gt; Your JSON literal example is already pretty well modeled by simply making a JSONValue type that conforms to all the literal protocols.  It is completely unclear why you would even want to model this with some generic Tree structure. <br>Because JSON has the structure of a tree. A dictionary of the type `[String:AnyObject]` does not express that structure even if at run-time it turns out that some of those any-objects are themselves dictionaries. `Tree&lt;String, JSONValue&gt;`, in contrast, precisely expresses the structure of JSON objects. `[String:JSONValue]` is flat so it is not worth talking about, whilst some dedicated `JSON` enum is just that, a dedicated type that is the symptom of a language incapable of representing things like `[1, [2]]` as such. <br></p><p>You do have a good point about conforming JSONValue type to the literal-convertible protocols. That is important here because it reminds us that the question of converting Int and String values to JSONValue type in my example is a completely separate issue from my proposal. This in turn shows that the two tree literal-convertable protocols I’d love to see added to the Standard Library would be sufficient in all cases. For instance (assuming the code from my original post is already in the context):<br></p><p>enum JSONValue {<br>	case Integer(Int)<br>	case Text(String)<br>	case URL(NSURL)<br></p><p>	init(_ string: String) {<br>		if let url = NSURL(string: string) {<br>			self = .URL(url)<br>		} else {<br>			self = .Text(string)<br>		}<br>	}<br>}<br></p><p>extension JSONValue : UnicodeScalarLiteralConvertible {<br>	init(unicodeScalarLiteral value: String) { self.init(value) }<br>}<br>extension JSONValue : ExtendedGraphemeClusterLiteralConvertible {<br>	init(extendedGraphemeClusterLiteral value: String) { self.init(value) }<br>}<br>extension JSONValue : StringLiteralConvertible {<br>	init(stringLiteral value: String){ self.init(value) }<br>}<br></p><p>extension JSONValue : IntegerLiteralConvertible {<br>	init(integerLiteral value: Int) { self = .Integer(value) }<br>}<br></p><p>let city: JSONValue = .Text(&quot;New York&quot;)<br></p><p>let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>[<br>	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>	&quot;age&quot;: ◊25,<br>	&quot;github&quot;: ◊&quot;http://github.com/apple/swift-evolution&quot;,<br>	&quot;address&quot;: [<br>		&quot;number&quot;: ◊21,<br>		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>		&quot;city&quot;: ◊city<br>	]<br>]<br></p><p>This is what we can do already (try it in the playground - even the url is read as a url). However, if we were also given the following protocol:<br></p><p>protocol DictionaryTreeLiteralConvertible {<br>	associatedtype Key<br>	associatedtype LeafValue<br>	init(literal: Self.LeafValue...)<br>	init(literal: (Key, Self)...)<br>}<br></p><p>… then the lifting of the JSONValue-s into the recursive world of trees would be done by the `init(literal: Self.LeafValue…)` and we would no longer need the lifting operator ◊.<br></p><p>Finally, it is worth mentioning that the two proposed protocols, TreeLiteralConvertible and DictionaryTreeLiteralConvertible, should be simple to implement, would not affect existing code, and would allow us to work with all kinds of trees and nested associative arrays with ease, safety and elegance we are growing accustomed to when programming in Swift.<br></p><p>milos<br></p><p><br>&gt; On 15 Apr 2016, at 03:22, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 2:56 PM, Milos Rankovic &lt;milos at milos-and-slavica.net &lt;mailto:milos at milos-and-slavica.net&gt;&gt; wrote:<br>&gt;&gt; Hi John and Brent, <br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Apr 2016, at 22:22, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; multiple-conformance idea doesn&#39;t work<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The idea is not multiple-conformance (or overloading), but multiple (two) initialisers required by the literal-convertible protocols:<br>&gt;&gt; <br>&gt;&gt; protocol TreeLiteralConvertible {<br>&gt;&gt; 	associatedtype LeafValue<br>&gt;&gt; 	init(literal: Self.LeafValue...)<br>&gt;&gt; 	init(literal: Self...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; … and:<br>&gt;&gt; <br>&gt;&gt; protocol DictionaryTreeLiteralConvertible {<br>&gt;&gt; 	associatedtype Key<br>&gt;&gt; 	associatedtype LeafValue<br>&gt;&gt; 	init(literal: Self.LeafValue...)<br>&gt;&gt; 	init(literal: (Key, Self)...)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; Note that all of your examples rely not just on recursion but on heterogeneous recursion<br>&gt;&gt; <br>&gt;&gt; The crux of the matter is not heterogeneity in general, but of the leaf value in particular. This is what Brent is addressing. All my examples, save one, had a uniform leaf value type (even the Tree&lt;SKAction&gt; example).<br>&gt; <br>&gt; The heterogeneity that I&#39;m referring to is the mix of sub-trees and leaves at a single level.<br>&gt; <br>&gt;&gt; The one exception is my second JSON example. There I did not post the lift operator overload as you can probably imagine it. Minimally:<br>&gt; <br>&gt; It&#39;s pretty implausible that we&#39;d ever add a &quot;tree literal&quot; concept that serves exactly your use case, so I&#39;m looking for ways to capture it that fit within the existing language framework, or at least take advantage of a more general addition to the language.<br>&gt; <br>&gt; Your JSON literal example is already pretty well modeled by simply making a JSONValue type that conforms to all the literal protocols.  It is completely unclear why you would even want to model this with some generic Tree structure.  Note that neither your tree-literal-protocol proposal nor Brent&#39;s lifting-protocol proposal is actually adequate for embedding non-literal Int/Double/Bool values in the structure because they both only allow a single &quot;leaf&quot; type.<br>&gt; <br>&gt; Your other examples could be modeled with either a lifting protocol or a conditional conformance.  I was just noting that the conditional conformance would be adequate if you were willing to manually lift non-literal values, and conditional conformances are a feature that&#39;s already basically planned, as opposed to a new research project.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; enum JSONValue {<br>&gt;&gt; 	case Text(String)<br>&gt;&gt; 	case Integer(Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; prefix func ◊ &lt;Key&gt; (leaf: String) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>&gt;&gt; 	return .Leaf(.Text(leaf))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; prefix func ◊ &lt;Key&gt; (leaf: Int) -&gt; DictionaryTree&lt;Key, JSONValue&gt; {<br>&gt;&gt; 	return .Leaf(.Integer(leaf))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>&gt;&gt; [<br>&gt;&gt; 	&quot;name&quot;: ◊&quot;Johnny Appleseed&quot;,<br>&gt;&gt; 	&quot;age&quot;: ◊25,<br>&gt;&gt; 	&quot;address&quot;: [<br>&gt;&gt; 		&quot;house_number&quot;: ◊21,<br>&gt;&gt; 		&quot;street&quot;: ◊&quot;2nd Street&quot;,<br>&gt;&gt; 		&quot;city&quot;: ◊&quot;New York&quot;<br>&gt;&gt; 	]<br>&gt;&gt; ]<br>&gt;&gt; <br>&gt;&gt; Notice in particular how much contextual information you are getting from the expected return type. Still though, as Brent, points out, this won’t work with the two literal-convertable protocols. Nevertheless, I’d be very happy if they could be added as a first step since I suspect that would be the easiest option and one that would still allow for all my examples so far to work without the lift operator; all except this `JSONValue` example.<br>&gt;&gt; <br>&gt;&gt; milos<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/0564592f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 1:29 AM, Milos Rankovic &lt;milos at milos-and-slavica.net&gt; wrote:<br>&gt;&gt; On 15 Apr 2016, at 03:22, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br></p><p>&gt;&gt; Your JSON literal example is already pretty well modeled by simply making a JSONValue type that conforms to all the literal protocols.  It is completely unclear why you would even want to model this with some generic Tree structure. <br>&gt; Because JSON has the structure of a tree.  A dictionary of the type `[String:AnyObject]` does not express that structure even if at run-time it turns out that some of those any-objects are themselves dictionaries. `Tree&lt;String, JSONValue&gt;`, in contrast, precisely expresses the structure of JSON objects.<br></p><p>No, it&#39;s actually a very strange way to model it.  The JSONValue type needs to be able to embed both JSON arrays and JSON objects, so if you represent a JSON object as a DictionaryTree&lt;String, JSONValue&gt;, you&#39;ll end up with two different ways to represent { &quot;x&quot; : { &quot;y&quot; : 1 } }.  It&#39;s much better to use the &quot;flat&quot; representation of Dictionary&lt;String, JSONValue&gt; and allow the JSONValue enum&#39;s natural recursiveness to express nested objects.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/2525776a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 15, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 15 Apr 2016, at 16:48, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  The JSONValue type needs to be able to embed both JSON arrays and JSON objects,<br></p><p>Aren’t JSON arrays and objects actually the same thing? They’re both essentially just ordered dictionaries, with objects mapping keys to properties, functions etc., while arrays are just a dictionary where the keys are consecutive integer (or should be, as long as you don’t mess with them), compilers will optimise them behind the scenes if they can, but there’s essentially no specific array type in Javascript, the array functions are just manipulating a dictionary in an array-like fashion.<br></p><p>Anyway, this is probably a reason why Swift dictionaries shouldn’t be used to implement a tree in this way, as they have no strict ordering, but the order of values in JSON is important, particularly when it comes to duplicate keys (the last always one takes precedence), and it’s technically okay to parse multiple duplicates values and combine them together if you want.<br></p><p><br>While the original post is an interesting way to define this structure, I think a specialised type is required to really capture this usefully.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 15 Apr 2016, at 19:54, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; While the original post is an interesting way to define this structure, I think a specialised type is required to really capture this usefully.<br></p><p>Sure. I never meant it as a replacement. It was a response to someone’s challenge whether one could express a piece of JSON data as a literal using the two example tree enums. The two protocols I’m proposing, however, could be implemented by many different kind of tree types, some of which could just as well have properties that fit JSON perfectly. It would then be a joy instantiating short JSON snippets as literals.<br></p><p>Still, as John anticipated, I could get this to compile too (keeping in mind that the lift operator ◊ would disappear if we get the two proposed protocols):<br></p><p>let johnny: DictionaryTree&lt;String, JSONValue&gt; =<br>[<br>	&quot;children&quot;: ◊[&quot;George&quot;, &quot;Ann&quot;, &quot;Percy&quot;],<br>	&quot;phoneNumbers&quot;: ◊[<br>		◊[<br>			&quot;type&quot;: ◊&quot;home&quot;,<br>			&quot;number&quot;: ◊&quot;212 555-1234&quot;<br>		],<br>		◊[<br>			&quot;type&quot;: ◊&quot;office&quot;,<br>			&quot;number&quot;: ◊&quot;646 555-4567&quot;<br>		],<br>	]<br>]<br></p><p>… where:<br></p><p>enum JSONValue {<br>	case Text(String)<br>	case Array([JSONValue])<br>	indirect case Object(DictionaryTree&lt;String, JSONValue&gt;)<br>}<br></p><p>milos<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/c115781b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Aren’t JSON arrays and objects actually the same thing? They’re both essentially just ordered dictionaries, with objects mapping keys to properties, functions etc., while arrays are just a dictionary where the keys are consecutive integer (or should be, as long as you don’t mess with them)<br></p><p>You&#39;re confusing JSON with JavaScript.<br></p><p>JSON is a wire format which includes support for certain, specific types: objects (basically, dictionaries with string keys and heterogenous values), arrays (with heterogenous values), strings, booleans, doubles, and nulls. JSON has nothing to say about how these things are represented in memory once they&#39;re parsed out of the wire format.<br></p><p>JavaScript is a language with a prototype-based object system and a literal syntax which happens to be a superset of JSON. The statements you make about how &quot;arrays are just objects with consecutive integer keys&quot; and so on are true of JavaScript arrays, but they have nothing to do with JSON, merely with how JSON is conventionally represented once it&#39;s read into JavaScript.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br></p><p>That not only doesn&#39;t work if your type isn&#39;t a LiteralConvertible, it also doesn&#39;t work if you want to build a literal with variables:<br></p><p>	let myTree: Tree = [1, [2, three]]<br></p><p>The real missing feature here is implicit lifting like Optional offers. With a LiftingConvertible protocol, you could say something like this:<br></p><p>	enum Tree&lt;Value&gt; {<br>		case leaf(Value)<br>		case branches([Tree&lt;Value&gt;])<br>	}<br>	<br>	extension Tree: ArrayLiteralConvertible {<br>		init(arrayLiteral branches: Tree&lt;Value&gt;...) {<br>			self = .branches(branches)<br>		}<br>	}<br>	<br>	extension Tree: LiftingConvertible {<br>		init(lifting value: Value) {<br>			self = .leaf(value)<br>		}<br>	}<br></p><p>However, even without implicit lifting, you should still be able to write trees with just ArrayLiteralConvertible by explicitly lifting the leaves:<br></p><p>	let myTree: Tree = [.leaf(1), [.leaf(2), .leaf(three)]]<br></p><p>That isn&#39;t great, but it&#39;s not awful, either.<br></p><p>For that matter, you could write a semi-implicit lifting feature:<br></p><p>	protocol LiftingConvertible {<br>		associatedtype Lifted<br>		init(lifting value: Lifted)<br>	}<br>	<br>	prefix operator ^ {}<br>	prefix func ^ &lt;Lifting: LiftingConvertible&gt; (lifted: Lifting.Lifted) -&gt; Lifting {<br>		return Lifting(lifting: lifted)<br>	}<br>	<br>	let myTree: Tree = [^1, [^2, ^three]]<br></p><p>That&#39;s actually not so bad.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 2:20 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br>&gt; <br>&gt; That not only doesn&#39;t work if your type isn&#39;t a LiteralConvertible, it also doesn&#39;t work if you want to build a literal with variables:<br>&gt; <br>&gt; 	let myTree: Tree = [1, [2, three]]<br>&gt; <br>&gt; The real missing feature here is implicit lifting like Optional offers. With a LiftingConvertible protocol, you could say something like this:<br>&gt; <br>&gt; 	enum Tree&lt;Value&gt; {<br>&gt; 		case leaf(Value)<br>&gt; 		case branches([Tree&lt;Value&gt;])<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension Tree: ArrayLiteralConvertible {<br>&gt; 		init(arrayLiteral branches: Tree&lt;Value&gt;...) {<br>&gt; 			self = .branches(branches)<br>&gt; 		}<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension Tree: LiftingConvertible {<br>&gt; 		init(lifting value: Value) {<br>&gt; 			self = .leaf(value)<br>&gt; 		}<br>&gt; 	}<br></p><p>Another name for this feature is &quot;user-defined implicit conversions&quot;.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 14, 2016 at 04:00:00pm</p></header><div class="content"><p>The topic’s come up before. I’m in favor of it, but IIRC there are two problems that need to be resolved first:<br></p><p>(I *think* I’m remembering this correctly… don’t quote me on this…)<br></p><p>First, it can cause the type-checker to become “pathological”.<br>Second, it can cause some *very* unexpected behavior if things are implicitly converted through different types than you thought.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 14, 2016, at 4:24 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 2:20 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; No, you just need Tree to conform to both ArrayLiteralConvertible and IntegerLiteralConvertible, and it implements the latter by building a Value out of it.<br>&gt;&gt; <br>&gt;&gt; That not only doesn&#39;t work if your type isn&#39;t a LiteralConvertible, it also doesn&#39;t work if you want to build a literal with variables:<br>&gt;&gt; <br>&gt;&gt; 	let myTree: Tree = [1, [2, three]]<br>&gt;&gt; <br>&gt;&gt; The real missing feature here is implicit lifting like Optional offers. With a LiftingConvertible protocol, you could say something like this:<br>&gt;&gt; <br>&gt;&gt; 	enum Tree&lt;Value&gt; {<br>&gt;&gt; 		case leaf(Value)<br>&gt;&gt; 		case branches([Tree&lt;Value&gt;])<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	extension Tree: ArrayLiteralConvertible {<br>&gt;&gt; 		init(arrayLiteral branches: Tree&lt;Value&gt;...) {<br>&gt;&gt; 			self = .branches(branches)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	extension Tree: LiftingConvertible {<br>&gt;&gt; 		init(lifting value: Value) {<br>&gt;&gt; 			self = .leaf(value)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt; <br>&gt; Another name for this feature is &quot;user-defined implicit conversions&quot;.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; 	extension Tree: LiftingConvertible {<br>&gt;&gt; 		init(lifting value: Value) {<br>&gt;&gt; 			self = .leaf(value)<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt; <br>&gt; Another name for this feature is &quot;user-defined implicit conversions&quot;.<br></p><p>This is absolutely a form of user-defined implicit conversion. It&#39;s a limited form (one possible `Lifted` for each `LiftingConvertible`), which may help make it more feasible, and it is basically a generalization of the special-cased Optional lifting, but it is a user-defined implicit conversion.<br></p><p>I understand and agree with the reasons for deferring implicit conversions. What I&#39;m saying is that seeing this as a &quot;tree literals&quot; feature is a very narrow view of the overall problem.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Hey!<br></p><p>&gt;&gt; Can you please give us a few real-world examples where initializing a nontrivial tree-like data structure in code would be useful?<br>&gt; <br>&gt; I suppose we always prefer to move *all* data into databases or files with dedicated data formats, *including* arrays, strings, dictionaries, etc. Sure. But it would be rather underwhelming if you could not also just instantiate an array or a string from a literal.<br></p><p>&gt; Likewise, I find it a little deflating that I cannot express a piece of JSON in code. <br>&gt; <br>&gt; Given the *simplicity* of these structures, it seems it should not be beyond Swift to represent them in code with ease and elegance. And to begin with, all we need are those couple of protocols.<br></p><p><br>Did you just... sidestep the question? :-)<br></p><p>The reason we want dictionary and array literals is that because they&#39;re needed in the real code bases, everywhere, not just for the abstract beauty of the langauge. I can certainly list many specific use cases for both array and dictionary literals, with code examples.<br></p><p>I can&#39;t think of any real use cases for the kind of literals you want, though, hence the question. (And I don&#39;t think it&#39;s worth adding just for computer science playground experiments alone.)<br></p><p>And, FWIW, JSON objects can absolutely be represented in Swift as Dictionary&lt;String, AnyObject&gt;. I even typealias that as JSONObject, and have a lot of code parsing and producing these. While TreeDictionary&lt;String, String&gt; looks superficially safer, I doubt it&#39;s worth the trouble. But again, I&#39;d like to be proven wrong; the burden is on you to present the use cases!<br></p><p>I&#39;m appalled by the fascination of Swift community with JSONValue-like enums. They produce the most horrible code on the parsing side, and seem to be an academic experiment in type safety. See this framework for what I believe to be the right approach to dealing with JSON in Swift: https://github.com/ExpressiveSwift/ExpressiveCasting<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/3df0874e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April 15, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 15 Apr 2016, at 08:24, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; On 14 Apr 2016, at 19:23, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can you please give us a few real-world examples… <br>&gt; <br>&gt; I can&#39;t think of any real use cases for the kind of literals you want, though, hence the question. (And I don&#39;t think it&#39;s worth adding just for computer science playground experiments alone.)<br></p><p>let example: Tree&lt;String&gt; = <br>[<br>	&quot;Don&#39;t Cha Wish Your Language Was Hot Like Me?&quot;,<br>	[<br>		&quot;Is it hard to come up with good examples of tree literals?&quot;,<br>		&quot;Why is that? It’s trees we work with every day:&quot;,<br>		[<br>			&quot;views&quot;,<br>			&quot;directories&quot;,<br>			&quot;decision trees&quot;<br>		],<br>		&quot;What if we can&#39;t come up with good examples because&quot;,<br>		&quot;our imagination is limited by our medium? What if&quot;,<br>		&quot;we can&#39;t think of it because we do not think like it?&quot;<br>	]<br>]<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/96842ca7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 14, 2016 at 04:00:00pm</p></header><div class="content"><p>I think a better solution than just adding a TreeLiteral (and the accompanying TreeLiteralConvertible protocol) would be to allow user-defined literal types using regex (or something similar). This would not only allow for tremendous flexibility, but it’d remove some compiler magic as well.<br></p><p>There’d have to be some rules regarding overlapping definitions… The simplest I can think of is make it an error to not do type annotation when there’s more than one way to parse a literal, but I’m not sure that’s necessarily the best.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 14, 2016, at 11:27 AM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Swift, we cannot compile:<br>&gt; <br>&gt; _ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt; The reason for the compile-time error is that we are not in fact creating an array, but a tree – a more general structure of which arrays are only a special case. Given the well-deserved and growing reputation of Swift, one would hope that in this instance the compiler would be able to default to something like a:<br>&gt; <br>&gt; enum Tree&lt;Value&gt; {<br>&gt; 	case Leaf(Value)<br>&gt; 	case Branches([Tree])<br>&gt; }<br>&gt; <br>&gt; extension Tree : ArrayLiteralConvertible {<br>&gt; 	init(arrayLiteral elements: Tree...) {<br>&gt; 		self = .Branches(elements)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; For this to work in the playground, however, we must manually lift the values into the world of trees first. And to make that chore in turn easier on the eye we can introduce a:<br>&gt; <br>&gt; prefix operator ◊ {} // looks a bit like a leaf (us/uk kbd: ⎇⇧V)<br>&gt; prefix func ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br>&gt; <br>&gt; The point here is that if adding such a fundamental type to the Standard Library would not be a priority at present, it is not the end of the world since we can easily enough write it ourselves… What we cannot do ourselves, however, is to get rid of the need for that operator in the common scenario of initialising with literal values. For this we need a literal-convertible protocol requiring two initialisers:<br>&gt; <br>&gt; protocol TreeLiteralConvertible {<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: Self...)<br>&gt; }<br>&gt; <br>&gt; Then we could simply:<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt; And, whilst we are at it, we could also get rid of the need for that operator in the case of nested associative arrays (again, you can try this in the playground):<br>&gt; <br>&gt; enum DictionaryTree&lt;Key, Value&gt; {<br>&gt; 	case Leaf(Value)<br>&gt; 	case Branches([(Key, DictionaryTree)])<br>&gt; }<br>&gt; <br>&gt; extension DictionaryTree : DictionaryLiteralConvertible {<br>&gt; 	init(dictionaryLiteral pairs: (Key, DictionaryTree)...) {<br>&gt; 		self = .Branches(pairs)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; prefix func ◊ &lt;Key, Value&gt; (leaf: Value) -&gt; DictionaryTree&lt;Key, Value&gt; { return .Leaf(leaf) }<br>&gt; <br>&gt; let map: DictionaryTree&lt;String,Int&gt; = [<br>&gt; 	&quot;A&quot; : [:],<br>&gt; 	&quot;B&quot; : [<br>&gt; 		&quot;Ba&quot; : ◊0,<br>&gt; 		&quot;Bb&quot; : ◊0,<br>&gt; 		&quot;Bc&quot; : [<br>&gt; 			&quot;Bc1&quot; : ◊0,<br>&gt; 			&quot;Bc2&quot; : ◊0,<br>&gt; 			&quot;Bc3&quot; : ◊0<br>&gt; 		]<br>&gt; 	]<br>&gt; ]<br>&gt; <br>&gt; … by introducing an analogous protocol:<br>&gt; <br>&gt; protocol DictionaryTreeLiteralConvertible {<br>&gt; 	associatedtype Key<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: (Key, Self)...)<br>&gt; }<br>&gt; <br>&gt; Please note: I do understand that fleshing out these structures (along with all the juicy methods, operators and lazy alternatives) may not currently be a priority for Swift. The two literal-convertible protocols however, may be a much less daunting task, which would open to us some very useful programming idioms…<br>&gt; <br>&gt; milos<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/511080e5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>TreeLiteralConvertible</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:27 AM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Swift, we cannot compile:<br>&gt; <br>&gt; _ = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br>&gt; <br>&gt; The reason for the compile-time error is that we are not in fact creating an array, but a tree – a more general structure of which arrays are only a special case. Given the well-deserved and growing reputation of Swift, one would hope that in this instance the compiler would be able to default to something like a:<br></p><p>Actually this error can be simplified to <br></p><p>_ = []<br></p><p>As the compiler says, the expression is ambiguous. Without an element type, the array literal cannot be used to create an array.<br></p><p>On the other hand:<br></p><p>_ = [[1]]<br></p><p>is fine -  the system assumes the literal your literal was defining an array of int, so the outer type is Array&lt;Array&lt;Int&gt;&gt;<br></p><p>&gt; For this to work in the playground, however, we must manually lift the values into the world of trees first. And to make that chore in turn easier on the eye we can introduce a:<br>&gt; <br>&gt; prefix operator ◊ {} // looks a bit like a leaf (us/uk kbd: ⎇⇧V)<br>&gt; prefix func ◊ &lt;T&gt; (leaf: T) -&gt; Tree&lt;T&gt; { return .Leaf(leaf) }<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], ◊1, [◊2, ◊3], [[◊4, ◊5], [◊6, ◊7], [◊8, ◊9]]]<br></p><p>Yes, because there is no way to have one type be cast implicitly into another type except for the cases the compiler supports via Optional or the various LiteralConvertible protocols/initializers.<br></p><p>So as other point out, if you actually defined a Integer-only tree, you could define that a .leaf was created from integer literals. Then this works without your wrapping operator.<br></p><p>&gt; <br>&gt; The point here is that if adding such a fundamental type to the Standard Library would not be a priority at present, it is not the end of the world since we can easily enough write it ourselves… What we cannot do ourselves, however, is to get rid of the need for that operator in the common scenario of initialising with literal values. For this we need a literal-convertible protocol requiring two initialisers:<br>&gt; <br>&gt; protocol TreeLiteralConvertible {<br>&gt; 	associatedtype LeafValue<br>&gt; 	init(literal: Self.LeafValue...)<br>&gt; 	init(literal: Self...)<br>&gt; }<br>&gt; <br>&gt; Then we could simply:<br>&gt; <br>&gt; let tree: Tree&lt;Int&gt; = [[], 1, [2, 3], [[4, 5], [6, 7], [8, 9]]]<br></p><p>If my tree is of Pear objects, there is no “Pear” literal in the language. So I don’t think you are asking for tree literals. I suspect you are asking for implicit type coercion, which if present could possibly replace some of the existing LiteralConvertible protocols..<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/e066a621/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
