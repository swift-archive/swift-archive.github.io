<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>Handling Windows C library Matrix</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>June 29, 2016 at 07:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Windows has an interesting (different) model for handling the C library.<br>There are *four* different libraries and you select the library you want<br>across two axis.  Traditionally the driver controls the selected library<br>via flags (and options exposed to the developer via the IDE).  Im not sure<br>what is the best way to handle that with swift.<br></p><p>This table explains how the library selection works:<br></p><p>                           Debug         |      Release<br>                  +----------------------+--------------------+<br>statically linked |  libcmtd.lib (/MTd)  |  libcmt.lib (/MT)<br>dyamically linked |  msvcrtdl.lib (MDd)  |  msvcrt.lib (/MD)<br></p><p>Now, there are certain advantages to both linkage models.  The static<br>linkage means that you don&#39;t have any dependency on the VC runtime<br>redistributable at the cost of small binary.  The dynamic linkage means<br>that you have a dependency on the VC runtime redistributable, but you have<br>a smaller binary and future updates can update libc.<br></p><p>The library selection unfortunately goes further than just linkage.  The<br>flags control other flags which matter for the C library interfaces (DLL<br>storage).<br></p><p>The crux of the issue is, how to model this behavior in the swift driver,<br>since the only places where this matters will be the ClangImporter and the<br>standard library build, but the latter can be addressed much more easily as<br>it would be internal to the build and not exposed to the users.<br></p><p>If we are looking for precedent, the clang driver introduced a<br>`--dependent-lib` CC1 option (mapping /MTd, /MT, /MDd, /MD to it<br>appropriately).<br></p><p>Note that I am *NOT* advocating a second driver interface, because I think<br>that will just cause unnecessary work and confusion.  As long as we have<br>options or some means t control the interface, I think having a single<br>unified driver interface is a significantly better approach.<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160629/ded2859d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Handling Windows C library Matrix</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  6, 2016 at 10:00:00am</p></header><div class="content"><p>For anyone watching this thread, Saleem broke it down a little further for me in https://github.com/apple/swift/pull/3326. For now we decided to just add an autolink flag to the frontend (not the driver) to make sure we don&#39;t get the &quot;wrong&quot; C library by accident. We&#39;ll need to discuss further how this actually affects Swift, and what form this choice should be presented to the user.<br></p><p>I found https://msdn.microsoft.com/en-us/library/ms235460.aspx which talks about the costs of mixing C libraries, and I&#39;m a little concerned about allowing this at all. While swiftCore doesn&#39;t (currently) vend any pointers into the C runtime, it seems like any other library very well might (including a hypothetical Libc module).<br></p><p>Jordan<br></p><p><br>&gt; On Jun 29, 2016, at 7:44, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Windows has an interesting (different) model for handling the C library.  There are *four* different libraries and you select the library you want across two axis.  Traditionally the driver controls the selected library via flags (and options exposed to the developer via the IDE).  Im not sure what is the best way to handle that with swift.<br>&gt; <br>&gt; This table explains how the library selection works:<br>&gt; <br>&gt;                            Debug         |      Release<br>&gt;                   +----------------------+--------------------+<br>&gt; statically linked |  libcmtd.lib (/MTd)  |  libcmt.lib (/MT)<br>&gt; dyamically linked |  msvcrtdl.lib (MDd)  |  msvcrt.lib (/MD)<br>&gt; <br>&gt; Now, there are certain advantages to both linkage models.  The static linkage means that you don&#39;t have any dependency on the VC runtime redistributable at the cost of small binary.  The dynamic linkage means that you have a dependency on the VC runtime redistributable, but you have a smaller binary and future updates can update libc.<br>&gt; <br>&gt; The library selection unfortunately goes further than just linkage.  The flags control other flags which matter for the C library interfaces (DLL storage).<br>&gt; <br>&gt; The crux of the issue is, how to model this behavior in the swift driver, since the only places where this matters will be the ClangImporter and the standard library build, but the latter can be addressed much more easily as it would be internal to the build and not exposed to the users.<br>&gt; <br>&gt; If we are looking for precedent, the clang driver introduced a `--dependent-lib` CC1 option (mapping /MTd, /MT, /MDd, /MD to it appropriately).<br>&gt; <br>&gt; Note that I am *NOT* advocating a second driver interface, because I think that will just cause unnecessary work and confusion.  As long as we have options or some means t control the interface, I think having a single unified driver interface is a significantly better approach.<br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
