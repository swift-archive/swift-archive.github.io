<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f3bc5bf6cf42cccb4f6ce19e34035e2d?s=50"></div><header><strong>Netty would be a good framework to look at</strong> from <string>Andrew Akira Toulouse</string> &lt;andrew at atoulou.se&gt;<p>October 29, 2016 at 06:00:00pm</p></header><div class="content"><p>I don&#39;t know to what degree I&#39;m preaching to the choir, but I was<br>encouraged by an acquaintance on the Swift team to put my thoughts out<br>there whether or not I drop the mic and step away afterwards. So:<br></p><p>I&#39;ve used a couple of networking/server/web frameworks over the years, and<br>the one that stands out for me is Netty. Netty is a highly asynchronous<br>Java framework used in very high-performance applications (including hedge<br>funds and Wall Stree, for example).<br></p><p>==aside==<br>I&#39;ve looked at: Jersey (JAX-RS), JSR 356, Wangle (Facebook&#39;s Netty-ish C++<br>framework that only really runs on Linux), Finagle (Twitter&#39;s Scala layer<br>on top of Netty), writing my own with POSIX sockets + libdispatch, and<br>writing my own with CFSockets (once each in ObjC and Swift). I also wrote<br>my own client-side networking framework at a previous job, modeling it very<br>roughly after the client bits of Netty (the product for which it was<br>implemented was never released however).<br></p><p>So, while I don&#39;t think I am the most qualified to suggest what a server<br>API&#39;s final form might look like (i&#39;ve personally dabbled a bunch but I&#39;ve<br>invested more heavily in client-side programming than server-side), I have<br>a couple of thoughts from an API consumer&#39;s side of things.<br>==end aside==<br></p><p>The common thread I&#39;ve found to help with stability and reduce code churn<br>is the composability of layers of the stack. At a high level, the pattern I<br>found most useful was channels and pipelines. A pipeline would have a chain<br>of handlers to control the flow of data, and a channel would have the<br>specific instantiation of input-&gt;handler-&gt;handler-&gt;output. For example,<br>here&#39;s a sample pipeline:<br></p><p>==extended example==<br></p><p>* bitstream OR packet stream input (i.e. data sourced from disk, from<br>network, from a socket, or whatever)<br>* Frame Decoder, which buffers the bytes until a successful decode<br>* Text Decoder: decodes the frame into text. This is an example, but it<br>could otherwise some higher level message, could be some encoding other<br>than UTF8, Maybe it&#39;s a tightly packed set of bytes, maybe it&#39;s text<br>* JSON Decoder: parses JSON. Maybe it even goes directly to creating<br>structs, or maybe it creates a dictionary and passes it to...<br>* Model Decoder: inspects the dictionary and decides how to turn that into<br>an object or struct.<br>* Application logic<br>* Custom error handler (each handler decides if it can handle the message<br>passed down each stage, and errors can pass through or perhaps a previous<br>stage can be retried, with some context dictionary of metadata to track<br>previous failed attempts)<br>* Callback for output so that stateful things can be updated<br></p><p>Caching handlers would be insertable at will to bypass some pipeline<br>stages; statefulness would be possible to encapsulate within a given stage,<br>but by and large statefulness would express itself as a context parameter<br>rather than the handlers being stateful themselves. Clients would prefer<br>the above pipeline; servers would continue on to construct responses and<br>return, and none of these stages would be required to be run synchronously<br>(but pipeline allowing, they can) or on the same queue (they could draw on<br>thread/queue pools as executors).<br></p><p>Maybe the wire format changes from JSON to XML or to MessagePack or<br>whatever, but otherwise stays the same – swap that layer out. Maybe the<br>model framework changes from hand-rolled to autogenerated, or maybe an app<br>developer changed from an Objective-C model framework like Mantle to a<br>Swift one – swap that layer out. Maybe the developer created an<br>authentication layer that they insert for specific API calls that augments<br>the context metadata so API calls further down the pipeline can make use of<br>them (and maybe they support multiple concurrent users so they don&#39;t want<br>to initialize the handlers with auth data). And so on.<br></p><p>==end extended example==<br></p><p>This pattern has worked for me on servers, as well as on an iOS app (I<br>managed to get 0 frame drops in a very layout, network, and image-heavy app<br>with the approach, with transparent caching and guarantees of thread<br>safety), and from what I have seen, works also for API proxies, i.e.<br>Thrift-to-HTTP, or vice-versa, or protobuf, or whatever format you throw a<br>decoder or encoder on for.<br></p><p>So, that&#39;s a lot of background. Here&#39;s the TL;DR of my suggestions for the<br>network/server APIs:<br></p><p>1) Please highly prioritize composability. A good abstraction will allow<br>components to be composed upfront rather than creating sloppy asynchronous<br>calls that are very difficult to trace or debug.<br>2) Please heavily isolate state; or statelessness where reasonable.<br>3) It might spend some extra cycles, but being asynchronous (beyond just<br>nonblocking I/O) typically works better for apps and non-CPU-bound servers<br>– I think CPU-heavy synchronous workloads will tend to write their own<br>framework from low-level primitives anyways), so please build it around<br>that.<br></p><p>So, that&#39;s it for the lower-level server stuff. For the higher-level server<br>stuff, Dropwizard is a batteries-included framework (and the batteries are<br>good) that incorporates Jersey, and is an opinionated and incredibly fun<br>web/API framework. Dropwizard was built by Yammer, and has a number of good<br>ideas built in on top of the straightforward way of creating server<br>endpoints with it. The downside is that I didn&#39;t see anything like Jersey<br>which did an especially good job supporting WebSockets.<br></p><p>Hope you can take inspiration from those (Netty and Dropwizard) when<br>creating the Server APIs. I look forward to it!<br></p><p>Thanks,<br>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161029/bfa14a04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>Netty would be a good framework to look at</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>October 30, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 30 Oct 2016, at 01:01, Andrew Akira Toulouse via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve used a couple of networking/server/web frameworks over the years, and the one that stands out for me is Netty. Netty is a highly asynchronous Java framework used in very high-performance applications (including hedge funds and Wall Street, for example).<br></p><p>Yes, Netty is an excellent framework and there have been some discussions already with some of the Netty team. One open question is how to map the asynchronous behaviour into supported constructs in Swift, such as libdispatch, which means it isn&#39;t just a drop in API but needs further investigation. <br></p><p>Alex<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d00f5acbaa7d24e0900e5045462e008?s=50"></div><header><strong>Netty would be a good framework to look at</strong> from <string>Chris Bailey</string> &lt;BAILEYC at uk.ibm.com&gt;<p>October 30, 2016 at 06:00:00pm</p></header><div class="content"><p>As Alex says, we actually have some of the contributors/committers for <br>Netty signed up to the work group - Tom Doron is one of them.<br></p><p>That means being able to build a highly performing async framework is very <br>much in our minds. We are also trying to build functional APIs though, <br>meaning we also have to make sure we support wider use cases - including <br>providing the ability to create a framework that does thread based <br>blocking I/O if you want to.<br></p><p>Chris<br></p><p><br></p><p><br>From:   Alex Blewitt via swift-server-dev &lt;swift-server-dev at swift.org&gt;<br>To:     Andrew Akira Toulouse &lt;andrew at atoulou.se&gt;<br>Cc:     swift-server-dev &lt;swift-server-dev at swift.org&gt;<br>Date:   30/10/2016 08:40<br>Subject:        Re: [swift-server-dev] Netty would be a good framework to <br>look at<br>Sent by:        swift-server-dev-bounces at swift.org<br></p><p><br></p><p><br>&gt; On 30 Oct 2016, at 01:01, Andrew Akira Toulouse via swift-server-dev <br>&lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve used a couple of networking/server/web frameworks over the years, <br>and the one that stands out for me is Netty. Netty is a highly <br>asynchronous Java framework used in very high-performance applications <br>(including hedge funds and Wall Street, for example).<br></p><p>Yes, Netty is an excellent framework and there have been some discussions <br>already with some of the Netty team. One open question is how to map the <br>asynchronous behaviour into supported constructs in Swift, such as <br>libdispatch, which means it isn&#39;t just a drop in API but needs further <br>investigation. <br></p><p>Alex<br>_______________________________________________<br>swift-server-dev mailing list<br>swift-server-dev at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-server-dev<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161030/ba51749a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d23c2d6c1ccb724044f09d449772ff2?s=50"></div><header><strong>Netty would be a good framework to look at</strong> from <string>Helge Heß</string> &lt;me at helgehess.eu&gt;<p>October 30, 2016 at 11:00:00am</p></header><div class="content"><p>On 30 Oct 2016, at 02:01, Andrew Akira Toulouse via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; ==extended example==<br></p><p>This goes back to my original question (https://lists.swift.org/pipermail/swift-server-dev/Week-of-Mon-20161024/000030.html):<br></p><p>  3) Do you really want just a Socket, or is what you really want<br>     a (byte) stream framework?<br></p><p>I’m not sure what people really want here (as part of this effort). There wasn’t a lot of feedback yet, but I think most of it was ‘just a basic socket’.<br></p><p><br>What you describe is similar to what I’m prototyping as Noze.io for Swift, it is described a little over here:<br></p><p>  http://noze.io/noze4nonnode/<br></p><p>It is not optimised for speed (yet) nor is the API geared towards Swift API style guides, but it does provide a pretty high level batch streaming framework that is completely asynchronous, provides piping and back pressure support. It has a type safe streaming API for arbitrary types (all your ‘frame decoder’, ‘text decoder’, ‘JSON decoder’ things). Maybe this is an OK demo, notice how the pipe input is UInt8 and the pipe output are RedisValue&#39;s:<br></p><p>  https://github.com/NozeIO/Noze.io/blob/master/Sources/redis/RedisParser.swift<br></p><p>Echo-Daemon with a user-level transform:<br></p><p>  https://github.com/NozeIO/Noze.io/blob/master/Samples/echozd/main.swift<br></p><p><br>Just to be clear: I’m _not_ suggesting to use this as the ‘socket’ for this project :-) But I think the basic concept of the streams may be applicable and worth considering IF the goal here is to actually provide something that high level.<br></p><p>hh<br></p><p>P.S.: A Swift Netty clone sounds excellent to me as well :-)<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161030/a68f95a3/attachment.sig&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
