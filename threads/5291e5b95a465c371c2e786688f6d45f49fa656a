<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268e1090c88890a4ed2387a4d22c661c?s=50"></div><header><strong>initializer with alternative</strong> from <string>J.E. Schotsman</string> &lt;jeschot at xs4all.nl&gt;<p>July 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I have a class that can be initialized from a file.<br>I would like to add a convenience init that uses a backup file if necessary.<br>Writing a function for this is easy, but I can’t manage to turn this into an init function.<br></p><p>import Foundation<br></p><p>class TestClass<br>	{<br>	init( fromFile file:NSURL ) throws<br>		{<br>		<br>		}<br>	<br>	convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>		{<br>		do { try self.init( fromFile:file ) }<br>		catch {<br>			do { try self.init( fromFile:backupFile ) } // error: &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>			}<br>		}<br>	}<br></p><p>func MakeTestClass( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws -&gt; TestClass<br>	{<br>	do { return try TestClass( fromFile:file ) } <br>	catch { do { return try TestClass( fromFile:backupFile ) } } <br>	}<br></p><p>Any suggestions?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4a21b05bbabd7a8a23358b79129ea7d?s=50"></div><header><strong>initializer with alternative</strong> from <string>Doug Hill</string> &lt;swiftusers at breaqz.com&gt;<p>July 25, 2016 at 01:00:00pm</p></header><div class="content"><p>If your self.init method fails by throwing an exception, the state of the class is essentially unknown. Trying to recover inside the convenience init method by calling another initializer seems problematic since you don&#39;t know what the state will be after the second init. Therefor, it&#39;s probably more correct to do the exception handling outside of this class like you did in the MakeTestClass function.<br></p><p>But just for the heck of it, I tried taking the second init outside the catch block, and put a flag that something failed. But Swift won&#39;t allow any uses of self after the first catch. For example (with errors on the lines the compiler reports):<br></p><p>convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>{<br>    var firstInitFailed = false<br></p><p>    do {<br>        try self.init( fromFile:file ) <br>    } catch {<br>        do {<br>       	    firstInitFailed = true<br>		}<br>	}<br></p><p>    if  firstInitFailed == false {<br>	try self.init( fromFile:backupFile) // &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>	}<br>} // &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>This might be a bug in the compiler since the error message isn&#39;t correct; self isn&#39;t referenced in the catch block. Also the error message on the closing brace is puzzling.<br></p><p>In any case, this appears to imply that in Swift you can&#39;t do any error recovery that involves self inside of an init method, even if you get an exception from something other than calling self.init. This doesn&#39;t seem right if the throw was for something that doesn&#39;t affect the object state. For example, if you had a file system call that tried to create &#39;fromFile&#39; and that call threw an exception. This shouldn&#39;t affect anything with class state and should be possible to handle it without affecting object initialization.<br></p><p>The third option is to move this file handling outside of the init method. For example:<br></p><p>convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>{<br>    try self.init(fromFile: file)<br></p><p>    self.openFile(fromFile: file, fromBackupFile: backupFile)<br>}<br></p><p>func openFile( fromFile file:NSURL, fromBackupFile backupFile:NSURL )<br>{<br>    do {<br>        // try to open the fromFile<br>    } catch {<br>        do {<br>            // try to open the backupFile<br>        }<br>    }<br>}<br></p><p>However, this changes the class&#39; init behavior since the designated initializer can&#39;t do the file opening/handling. I&#39;m guessing your best bet is going with the separate function to handle this. Or make it a type method.<br></p><p>Doug Hill<br></p><p><br></p><p>&gt; On Jul 25, 2016, at 10:46 AM, J.E. Schotsman via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I have a class that can be initialized from a file.<br>&gt; I would like to add a convenience init that uses a backup file if necessary.<br>&gt; Writing a function for this is easy, but I can’t manage to turn this into an init function.<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; class TestClass<br>&gt; 	{<br>&gt; 	init( fromFile file:NSURL ) throws<br>&gt; 		{<br>&gt; 		<br>&gt; 		}<br>&gt; 	<br>&gt; 	convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>&gt; 		{<br>&gt; 		do { try self.init( fromFile:file ) }<br>&gt; 		catch {<br>&gt; 			do { try self.init( fromFile:backupFile ) } // error: &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; func MakeTestClass( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws -&gt; TestClass<br>&gt; 	{<br>&gt; 	do { return try TestClass( fromFile:file ) } <br>&gt; 	catch { do { return try TestClass( fromFile:backupFile ) } } <br>&gt; 	}<br>&gt; <br>&gt; Any suggestions?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160725/8b67dbc9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>initializer with alternative</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>July 26, 2016 at 02:00:00pm</p></header><div class="content"><p>I would probably approach it like Doug suggested and use a class method.<br></p><p>class TestClass<br>{<br>    required init( fromFile file:NSURL ) throws<br>    {<br>    }<br></p><p>    class func makeTestClass( fromFile file:NSURL, fromBackupFile backupFile: NSURL ) throws -&gt; TestClass {<br>        do { return try self.init( fromFile:file ) }<br>        catch { do { return try self.init( fromFile:backupFile ) } }<br>    }<br>}<br></p><p><br>From: &lt;swift-users-bounces at swift.org&gt; on behalf of Doug Hill via swift-users &lt;swift-users at swift.org&gt;<br>Reply-To: Doug Hill &lt;swiftusers at breaqz.com&gt;<br>Date: Monday, July 25, 2016 at 4:41 PM<br>To: &quot;J.E. Schotsman&quot; &lt;jeschot at xs4all.nl&gt;<br>Cc: &quot;swift-users at swift.org&quot; &lt;swift-users at swift.org&gt;<br>Subject: Re: [swift-users] initializer with alternative<br></p><p>If your self.init method fails by throwing an exception, the state of the class is essentially unknown. Trying to recover inside the convenience init method by calling another initializer seems problematic since you don&#39;t know what the state will be after the second init. Therefor, it&#39;s probably more correct to do the exception handling outside of this class like you did in the MakeTestClass function.<br></p><p>But just for the heck of it, I tried taking the second init outside the catch block, and put a flag that something failed. But Swift won&#39;t allow any uses of self after the first catch. For example (with errors on the lines the compiler reports):<br></p><p>convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>{<br>    var firstInitFailed = false<br></p><p>    do {<br>        try self.init( fromFile:file )<br>    } catch {<br>        do {<br></p><p>    firstInitFailed = true<br>}<br>}<br></p><p>    if  firstInitFailed == false {<br>try self.init( fromFile:backupFile) // &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>}<br>} // &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>This might be a bug in the compiler since the error message isn&#39;t correct; self isn&#39;t referenced in the catch block. Also the error message on the closing brace is puzzling.<br></p><p>In any case, this appears to imply that in Swift you can&#39;t do any error recovery that involves self inside of an init method, even if you get an exception from something other than calling self.init. This doesn&#39;t seem right if the throw was for something that doesn&#39;t affect the object state. For example, if you had a file system call that tried to create &#39;fromFile&#39; and that call threw an exception. This shouldn&#39;t affect anything with class state and should be possible to handle it without affecting object initialization.<br></p><p>The third option is to move this file handling outside of the init method. For example:<br></p><p>convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>{<br>    try self.init(fromFile: file)<br></p><p>    self.openFile(fromFile: file, fromBackupFile: backupFile)<br>}<br></p><p>func openFile( fromFile file:NSURL, fromBackupFile backupFile:NSURL )<br>{<br>    do {<br>        // try to open the fromFile<br>    } catch {<br>        do {<br>            // try to open the backupFile<br>        }<br>    }<br>}<br></p><p>However, this changes the class&#39; init behavior since the designated initializer can&#39;t do the file opening/handling. I&#39;m guessing your best bet is going with the separate function to handle this. Or make it a type method.<br></p><p>Doug Hill<br></p><p><br></p><p>On Jul 25, 2016, at 10:46 AM, J.E. Schotsman via swift-users &lt;swift-users at swift.org&lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br></p><p>Hello,<br></p><p>I have a class that can be initialized from a file.<br>I would like to add a convenience init that uses a backup file if necessary.<br>Writing a function for this is easy, but I can’t manage to turn this into an init function.<br></p><p>import Foundation<br></p><p>class TestClass<br>{<br>init( fromFile file:NSURL ) throws<br>{<br></p><p>}<br></p><p>convenience init( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws<br>{<br>do { try self.init( fromFile:file ) }<br>catch {<br>do { try self.init( fromFile:backupFile ) } // error: &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>}<br>}<br>}<br></p><p>func MakeTestClass( fromFile file:NSURL, fromBackupFile backupFile:NSURL ) throws -&gt; TestClass<br>{<br>do { return try TestClass( fromFile:file ) }<br>catch { do { return try TestClass( fromFile:backupFile ) } }<br>}<br></p><p>Any suggestions?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268e1090c88890a4ed2387a4d22c661c?s=50"></div><header><strong>initializer with alternative</strong> from <string>J.E. Schotsman</string> &lt;jeschot at xs4all.nl&gt;<p>July 27, 2016 at 11:00:00am</p></header><div class="content"><p>On Jul 26, 2016, at 4:15 PM, Doug Hill wrote:<br></p><p>&gt; I&#39;m guessing your best bet is going with the separate function to  <br>&gt; handle this. Or make it a type method.<br></p><p><br>Of course. I didn&#39;t think of the type method approach.<br></p><p>&gt; // &#39;self&#39; used inside &#39;catch&#39; block reachable from self.init call<br>&gt; This might be a bug in the compiler since the error message isn&#39;t  <br>&gt; correct; self isn&#39;t referenced in the catch block. Also the error  <br>&gt; message on the closing brace is puzzling.<br></p><p>I got this message too inside an if err {} block.<br>I don&#39;t think I&#39;ll file a bug as this is probably  a rare case.<br></p><p>Jan E.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
