<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Initialization of default values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>I am working on a proposal for flexible memberwise initialization and would like to understand how Swift currently handles initialization of members that have a default specified in the declaration when an initializer does not explicitly initialize them.  Can someone familiar with this provide a brief summary or point me in the right direction to learn more (either documentation or compiler code).<br></p><p>Thanks,<br>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Initialization of default values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 3:28 PM, Matthew Johnson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I am working on a proposal for flexible memberwise initialization and would like to understand how Swift currently handles initialization of members that have a default specified in the declaration when an initializer does not explicitly initialize them.  Can someone familiar with this provide a brief summary or point me in the right direction to learn more (either documentation or compiler code).<br></p><p>This is under flux. Currently the compiler emits a default argument generator function for each defaulted argument, and emits a corresponding call at any call site that uses the default argument. The idea behind this was that the value of the argument could be changed without breaking ABI, but in practice this has been problematic, and constrains resilience in other undesirable ways. We&#39;re planning to move to a more C++-like model, where the default argument expression is instantiated at each call site. I think Doug and Jordan would be the best ones to discuss both the current model and our planned final design.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Initialization of default values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br></p><p>Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br></p><p>This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br></p><p>struct S {<br>    let d: Double<br>    let s: String = &quot;default&quot;<br>    <br>    // actual compiler generated signature is init(d: Double, s: String)<br>    init(d: Double) {<br>        // compiler generated initialization of s<br>        // self.s = s<br>        self.d = d<br>    }<br>    // current state compiler generated default value function<br>    static func sDefault() -&gt; String { return &quot;default&quot; }<br>}<br></p><p>// current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>// future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>let s = S(d: 1)<br></p><p>Thanks,<br>Matthew<br></p><p><br>&gt; On Dec 10, 2015, at 10:28 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:28 PM, Matthew Johnson via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am working on a proposal for flexible memberwise initialization and would like to understand how Swift currently handles initialization of members that have a default specified in the declaration when an initializer does not explicitly initialize them.  Can someone familiar with this provide a brief summary or point me in the right direction to learn more (either documentation or compiler code).<br>&gt; <br>&gt; This is under flux. Currently the compiler emits a default argument generator function for each defaulted argument, and emits a corresponding call at any call site that uses the default argument. The idea behind this was that the value of the argument could be changed without breaking ABI, but in practice this has been problematic, and constrains resilience in other undesirable ways. We&#39;re planning to move to a more C++-like model, where the default argument expression is instantiated at each call site. I think Doug and Jordan would be the best ones to discuss both the current model and our planned final design.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Initialization of default values</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:13 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br>&gt; <br>&gt; Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br>&gt; <br>&gt; This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br>&gt; <br>&gt; struct S {<br>&gt;    let d: Double<br>&gt;    let s: String = &quot;default&quot;<br>&gt; <br>&gt;    // actual compiler generated signature is init(d: Double, s: String)<br>&gt;    init(d: Double) {<br>&gt;        // compiler generated initialization of s<br>&gt;        // self.s = s<br>&gt;        self.d = d<br>&gt;    }<br>&gt;    // current state compiler generated default value function<br>&gt;    static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt; }<br>&gt; <br>&gt; // current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>&gt; // future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>&gt; let s = S(d: 1)<br></p><p><br>Right now, we’re doing what Joe describes for default arguments of parameters only. So if you had written:<br></p><p>	struct S {<br>	  let d: Double<br>	  let s: String<br></p><p>	  init(d: Double, s: String = “default”) { … }<br>	}<br></p><p>	let s = S(d: 1)<br></p><p>the compiler would generate<br></p><p>&gt;   // current state compiler generated default value function<br>&gt;    static func sDefault() -&gt; String { return &quot;default&quot; }<br></p><p>and call<br></p><p>	S(d: 1, s: sDefault())<br></p><p>The future state isn’t actually settled. We’re not thrilled with the idea of having to serialize expressions into Swift modules, which is what we would need to do to have the compiler turn the caller into<br></p><p>	S(d: 1, s: “default”)<br></p><p>The alternative that (IIRC) we’re currently favoring is to mark the SIL functions created as the default argument generators as “transparent”, so the SIL itself gets serialized into the Swift module and inlined into the call site (always). This is actually a smaller change to achieve the same effect, and avoids a lot of otherwise-unnecessary work to define the serialization of statements and expressions into Swift modules.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Initialization of default values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Thanks Doug, that makes sense.  I was wondering if Joe&#39;s answer might have been referring to arguments with defaults.  <br></p><p>What are you doing for members with default values specific (and therefore not initialized by code in an initializer)?  Do you plan changes to this as well?<br></p><p>Matthew<br></p><p><br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 11, 2015, at 5:11 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:13 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br>&gt;&gt; <br>&gt;&gt; Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br>&gt;&gt; <br>&gt;&gt; This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let d: Double<br>&gt;&gt;   let s: String = &quot;default&quot;<br>&gt;&gt; <br>&gt;&gt;   // actual compiler generated signature is init(d: Double, s: String)<br>&gt;&gt;   init(d: Double) {<br>&gt;&gt;       // compiler generated initialization of s<br>&gt;&gt;       // self.s = s<br>&gt;&gt;       self.d = d<br>&gt;&gt;   }<br>&gt;&gt;   // current state compiler generated default value function<br>&gt;&gt;   static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>&gt;&gt; // future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>&gt;&gt; let s = S(d: 1)<br>&gt; <br>&gt; <br>&gt; Right now, we’re doing what Joe describes for default arguments of parameters only. So if you had written:<br>&gt; <br>&gt;    struct S {<br>&gt;      let d: Double<br>&gt;      let s: String<br>&gt; <br>&gt;      init(d: Double, s: String = “default”) { … }<br>&gt;    }<br>&gt; <br>&gt;    let s = S(d: 1)<br>&gt; <br>&gt; the compiler would generate<br>&gt; <br>&gt;&gt;  // current state compiler generated default value function<br>&gt;&gt;   static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt; <br>&gt; and call<br>&gt; <br>&gt;    S(d: 1, s: sDefault())<br>&gt; <br>&gt; The future state isn’t actually settled. We’re not thrilled with the idea of having to serialize expressions into Swift modules, which is what we would need to do to have the compiler turn the caller into<br>&gt; <br>&gt;    S(d: 1, s: “default”)<br>&gt; <br>&gt; The alternative that (IIRC) we’re currently favoring is to mark the SIL functions created as the default argument generators as “transparent”, so the SIL itself gets serialized into the Swift module and inlined into the call site (always). This is actually a smaller change to achieve the same effect, and avoids a lot of otherwise-unnecessary work to define the serialization of statements and expressions into Swift modules.<br>&gt; <br>&gt;    - Doug<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Initialization of default values</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Members with initial values get their initialization synthesized into the body of the type&#39;s initializer. I think we do this during SILGen, i.e. when we go to emit a SIL body for the ConstructorDecl AST node.<br></p><p>(We use the term &quot;initial value&quot; for &quot;the thing on the right side of the equal sign for a variable or constant&quot; and &quot;default value&quot; for &quot;the thing on the right side of the equal side for a parameter&quot;.)<br></p><p>Jordan<br></p><p><br>&gt; On Dec 11, 2015, at 16:28 , Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks Doug, that makes sense.  I was wondering if Joe&#39;s answer might have been referring to arguments with defaults.  <br>&gt; <br>&gt; What are you doing for members with default values specific (and therefore not initialized by code in an initializer)?  Do you plan changes to this as well?<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 5:11 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 10:13 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;  let d: Double<br>&gt;&gt;&gt;  let s: String = &quot;default&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  // actual compiler generated signature is init(d: Double, s: String)<br>&gt;&gt;&gt;  init(d: Double) {<br>&gt;&gt;&gt;      // compiler generated initialization of s<br>&gt;&gt;&gt;      // self.s = s<br>&gt;&gt;&gt;      self.d = d<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt;  // current state compiler generated default value function<br>&gt;&gt;&gt;  static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>&gt;&gt;&gt; // future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>&gt;&gt;&gt; let s = S(d: 1)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Right now, we’re doing what Joe describes for default arguments of parameters only. So if you had written:<br>&gt;&gt; <br>&gt;&gt;   struct S {<br>&gt;&gt;     let d: Double<br>&gt;&gt;     let s: String<br>&gt;&gt; <br>&gt;&gt;     init(d: Double, s: String = “default”) { … }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   let s = S(d: 1)<br>&gt;&gt; <br>&gt;&gt; the compiler would generate<br>&gt;&gt; <br>&gt;&gt;&gt; // current state compiler generated default value function<br>&gt;&gt;&gt;  static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt; <br>&gt;&gt; and call<br>&gt;&gt; <br>&gt;&gt;   S(d: 1, s: sDefault())<br>&gt;&gt; <br>&gt;&gt; The future state isn’t actually settled. We’re not thrilled with the idea of having to serialize expressions into Swift modules, which is what we would need to do to have the compiler turn the caller into<br>&gt;&gt; <br>&gt;&gt;   S(d: 1, s: “default”)<br>&gt;&gt; <br>&gt;&gt; The alternative that (IIRC) we’re currently favoring is to mark the SIL functions created as the default argument generators as “transparent”, so the SIL itself gets serialized into the Swift module and inlined into the call site (always). This is actually a smaller change to achieve the same effect, and avoids a lot of otherwise-unnecessary work to define the serialization of statements and expressions into Swift modules.<br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Initialization of default values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks Jordan.  I was guessing a synthesis like this was happening but didn&#39;t want to assume without asking.<br></p><p>Is the initialization of members with initial values synthesized at the beginning of the initializer body before any user code?  If not, at what point in the initializer does this happen?<br></p><p>Also, thanks for filling me in on the terminology distinction.  I&#39;ll try to remember that!<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 11, 2015, at 8:26 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Members with initial values get their initialization synthesized into the body of the type&#39;s initializer. I think we do this during SILGen, i.e. when we go to emit a SIL body for the ConstructorDecl AST node.<br>&gt; <br>&gt; (We use the term &quot;initial value&quot; for &quot;the thing on the right side of the equal sign for a variable or constant&quot; and &quot;default value&quot; for &quot;the thing on the right side of the equal side for a parameter&quot;.)<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 16:28 , Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks Doug, that makes sense.  I was wondering if Joe&#39;s answer might have been referring to arguments with defaults.  <br>&gt;&gt; <br>&gt;&gt; What are you doing for members with default values specific (and therefore not initialized by code in an initializer)?  Do you plan changes to this as well?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 5:11 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:13 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt; let d: Double<br>&gt;&gt;&gt;&gt; let s: String = &quot;default&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // actual compiler generated signature is init(d: Double, s: String)<br>&gt;&gt;&gt;&gt; init(d: Double) {<br>&gt;&gt;&gt;&gt;     // compiler generated initialization of s<br>&gt;&gt;&gt;&gt;     // self.s = s<br>&gt;&gt;&gt;&gt;     self.d = d<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // current state compiler generated default value function<br>&gt;&gt;&gt;&gt; static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>&gt;&gt;&gt;&gt; // future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>&gt;&gt;&gt;&gt; let s = S(d: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, we’re doing what Joe describes for default arguments of parameters only. So if you had written:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  struct S {<br>&gt;&gt;&gt;    let d: Double<br>&gt;&gt;&gt;    let s: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    init(d: Double, s: String = “default”) { … }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let s = S(d: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the compiler would generate<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // current state compiler generated default value function<br>&gt;&gt;&gt;&gt; static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and call<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  S(d: 1, s: sDefault())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The future state isn’t actually settled. We’re not thrilled with the idea of having to serialize expressions into Swift modules, which is what we would need to do to have the compiler turn the caller into<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  S(d: 1, s: “default”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The alternative that (IIRC) we’re currently favoring is to mark the SIL functions created as the default argument generators as “transparent”, so the SIL itself gets serialized into the Swift module and inlined into the call site (always). This is actually a smaller change to achieve the same effect, and avoids a lot of otherwise-unnecessary work to define the serialization of statements and expressions into Swift modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  - Doug<br>&gt;&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Initialization of default values</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>December 11, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 7:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks Jordan.  I was guessing a synthesis like this was happening but didn&#39;t want to assume without asking.<br>&gt; <br>&gt; Is the initialization of members with initial values synthesized at the beginning of the initializer body before any user code?  If not, at what point in the initializer does this happen?<br></p><p>At the beginning. See SILGenFunction::emitMemberInitializers.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Also, thanks for filling me in on the terminology distinction.  I&#39;ll try to remember that!<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 8:26 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Members with initial values get their initialization synthesized into the body of the type&#39;s initializer. I think we do this during SILGen, i.e. when we go to emit a SIL body for the ConstructorDecl AST node.<br>&gt;&gt; <br>&gt;&gt; (We use the term &quot;initial value&quot; for &quot;the thing on the right side of the equal sign for a variable or constant&quot; and &quot;default value&quot; for &quot;the thing on the right side of the equal side for a parameter&quot;.)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 16:28 , Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks Doug, that makes sense.  I was wondering if Joe&#39;s answer might have been referring to arguments with defaults.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What are you doing for members with default values specific (and therefore not initialized by code in an initializer)?  Do you plan changes to this as well?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 11, 2015, at 5:11 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:13 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks Joe.  It sounds like in both current state and future state the compiler synthesizes additional arguments to the initializers for the type.  Is that correct?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doug and Jordan, if you’re able to offer any additional insights that would be much appreciated as well.  I want to make sure my proposal aligns well with how you’re handling this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is some code showing my understand of how you describe current and future state.  Can you confirm if this is correct?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;&gt; let d: Double<br>&gt;&gt;&gt;&gt;&gt; let s: String = &quot;default&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // actual compiler generated signature is init(d: Double, s: String)<br>&gt;&gt;&gt;&gt;&gt; init(d: Double) {<br>&gt;&gt;&gt;&gt;&gt;    // compiler generated initialization of s<br>&gt;&gt;&gt;&gt;&gt;    // self.s = s<br>&gt;&gt;&gt;&gt;&gt;    self.d = d<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // current state compiler generated default value function<br>&gt;&gt;&gt;&gt;&gt; static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // current state: actual compiler generated call is S(d: 1, s: S.sDefault())<br>&gt;&gt;&gt;&gt;&gt; // future state: actual compiler generated call is S(d: 1, s: &quot;default&quot;)<br>&gt;&gt;&gt;&gt;&gt; let s = S(d: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now, we’re doing what Joe describes for default arguments of parameters only. So if you had written:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;&gt;   let d: Double<br>&gt;&gt;&gt;&gt;   let s: String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(d: Double, s: String = “default”) { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let s = S(d: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the compiler would generate<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // current state compiler generated default value function<br>&gt;&gt;&gt;&gt;&gt; static func sDefault() -&gt; String { return &quot;default&quot; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and call<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; S(d: 1, s: sDefault())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The future state isn’t actually settled. We’re not thrilled with the idea of having to serialize expressions into Swift modules, which is what we would need to do to have the compiler turn the caller into<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; S(d: 1, s: “default”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The alternative that (IIRC) we’re currently favoring is to mark the SIL functions created as the default argument generators as “transparent”, so the SIL itself gets serialized into the Swift module and inlined into the call site (always). This is actually a smaller change to achieve the same effect, and avoids a lot of otherwise-unnecessary work to define the serialization of statements and expressions into Swift modules.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
