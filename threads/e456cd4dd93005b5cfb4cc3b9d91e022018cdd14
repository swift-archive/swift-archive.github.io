<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Disallow implicit conversion between function/closure with a list of parameters and with tuple parameter. Remove function type inconsistency.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 25, 2016 at 06:00:00pm</p></header><div class="content"><p>I believe this should be done for Swift 3.0 release as this is a *source <br>breaking change* and IMO it is very important to remove the inconsistency <br>mentioned below.<br></p><p>We removed tuple splatting on caller side and IMO we must complete this job <br>to delete the implicit connection between tuple and list of parameters in <br>closures/functions.<br></p><p><br>Currently we have these &quot;features&quot; :<br>====================================<br></p><p>1. Single tuple as parameter is allowed when list of parameters are required:<br></p><p>let ft1 : (Int,Int) -&gt; Void = { x in print(x.0, x.1)}<br></p><p>(but this causes crash:<br>let ft2 : (Int,Int) -&gt; Void = { x in print(x) }<br>)<br></p><p>Opinion: this should not be allowed. Parameter list is required.<br>`(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` are two different types.<br></p><p><br>2. Parameter list in closure is allowed when single tuple parameter is <br>required:<br></p><p>typealias IntInt = (Int,Int)<br>typealias IntIntToVoid = (IntInt) -&gt; Void<br></p><p>let tuple : IntInt = (1,2)<br></p><p>func foo(block: IntIntToVoid) { block(tuple) }<br></p><p>foo { x, y in print(x,y)}<br>foo { (x, y) in print(x, y)}<br></p><p>Opinion: this should not be allowed. Tuple parameter is required.<br>`((Int,Int)) -&gt; Void` and `(Int,Int) -&gt; Void` are two different types.<br>Swift should require this syntax to assign tuple parameter&#39;s sub-values to <br>variables in closure: `{ ((x, y)) in ..}`<br></p><p><br>3. Inconsistent (and just wrong) function type when a list of parameters <br>required(not tuple) :<br></p><p>typealias t1 = (Int, Int) -&gt; Int // clearly here are list of parameters<br>typealias t2 = ((Int, Int)) -&gt; Int // clearly here is a tuple parameter<br></p><p>print(t1.self) // Prints ((Int, Int)) -&gt; Int  why?<br>print(t2.self) // Prints ((Int, Int)) -&gt; Int<br>print(t1.self == t2.self) // true<br></p><p>Opinion: `(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` should be two <br>different separate types that can not be implicitly converted to each <br>other. Swift&#39;s typesystem should separate these types.<br></p><p><br>4. If the type is the same, why behavior differs :<br></p><p>let add_list:  (Int, Int) -&gt; Int = (+)<br>let add_tuple: ((Int, Int)) -&gt; Int = (+)<br></p><p>print(add_list.dynamicType == add_tuple.dynamicType) // true<br></p><p>print( add_list(1,2) )<br>//print( add_list((1,2)) ) // missing argument for parameter #2 in call<br></p><p>//print( add_tuple(1,2) ) // extra argument in call<br>print( add_tuple((1,2)) )<br></p><p><br>Proposal:<br>===============<br></p><p>1. Separate function types with parameter list and a tuple parameter. They <br>should be two separate types.<br></p><p>2. Require this syntax to assign tuple parameter&#39;s sub-values to variables <br>in func/closure: `{ ((x, y)) in ..}`, otherwise (i.e. if `{ (x, y) in ..`) <br>treat function/closure as having list of parameters.<br></p><p>3. Disallow implicit conversion between function/closure with a list of <br>parameters and function/closure where single tuple is required.<br>This will stop confusion and make the language consistent how it deal with <br>tuples and list of parameters in func/closure.<br></p><p>4. It seems like we should keep the ability to explicitly convert one to <br>another as some(many?) code can depend on this current behavior and so we <br>need a way to convert old code to new.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Disallow implicit conversion between function/closure with a list of parameters and with tuple parameter. Remove function type inconsistency.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 04:00:00am</p></header><div class="content"><p>+1. I had this same problem when using map with enumerated-both $1 and<br>$0.offset worked. I can see how this can be confusing to beginners.<br></p><p><br>On Sat, Jun 25, 2016 at 8:36 AM Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I believe this should be done for Swift 3.0 release as this is a *source<br>&gt; breaking change* and IMO it is very important to remove the inconsistency<br>&gt; mentioned below.<br>&gt;<br>&gt; We removed tuple splatting on caller side and IMO we must complete this job<br>&gt; to delete the implicit connection between tuple and list of parameters in<br>&gt; closures/functions.<br>&gt;<br>&gt;<br>&gt; Currently we have these &quot;features&quot; :<br>&gt; ====================================<br>&gt;<br>&gt; 1. Single tuple as parameter is allowed when list of parameters are<br>&gt; required:<br>&gt;<br>&gt; let ft1 : (Int,Int) -&gt; Void = { x in print(x.0, x.1)}<br>&gt;<br>&gt; (but this causes crash:<br>&gt; let ft2 : (Int,Int) -&gt; Void = { x in print(x) }<br>&gt; )<br>&gt;<br>&gt; Opinion: this should not be allowed. Parameter list is required.<br>&gt; `(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` are two different types.<br>&gt;<br>&gt;<br>&gt; 2. Parameter list in closure is allowed when single tuple parameter is<br>&gt; required:<br>&gt;<br>&gt; typealias IntInt = (Int,Int)<br>&gt; typealias IntIntToVoid = (IntInt) -&gt; Void<br>&gt;<br>&gt; let tuple : IntInt = (1,2)<br>&gt;<br>&gt; func foo(block: IntIntToVoid) { block(tuple) }<br>&gt;<br>&gt; foo { x, y in print(x,y)}<br>&gt; foo { (x, y) in print(x, y)}<br>&gt;<br>&gt; Opinion: this should not be allowed. Tuple parameter is required.<br>&gt; `((Int,Int)) -&gt; Void` and `(Int,Int) -&gt; Void` are two different types.<br>&gt; Swift should require this syntax to assign tuple parameter&#39;s sub-values to<br>&gt; variables in closure: `{ ((x, y)) in ..}`<br>&gt;<br>&gt;<br>&gt; 3. Inconsistent (and just wrong) function type when a list of parameters<br>&gt; required(not tuple) :<br>&gt;<br>&gt; typealias t1 = (Int, Int) -&gt; Int // clearly here are list of parameters<br>&gt; typealias t2 = ((Int, Int)) -&gt; Int // clearly here is a tuple parameter<br>&gt;<br>&gt; print(t1.self) // Prints ((Int, Int)) -&gt; Int  why?<br>&gt; print(t2.self) // Prints ((Int, Int)) -&gt; Int<br>&gt; print(t1.self == t2.self) // true<br>&gt;<br>&gt; Opinion: `(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` should be two<br>&gt; different separate types that can not be implicitly converted to each<br>&gt; other. Swift&#39;s typesystem should separate these types.<br>&gt;<br>&gt;<br>&gt; 4. If the type is the same, why behavior differs :<br>&gt;<br>&gt; let add_list:  (Int, Int) -&gt; Int = (+)<br>&gt; let add_tuple: ((Int, Int)) -&gt; Int = (+)<br>&gt;<br>&gt; print(add_list.dynamicType == add_tuple.dynamicType) // true<br>&gt;<br>&gt; print( add_list(1,2) )<br>&gt; //print( add_list((1,2)) ) // missing argument for parameter #2 in call<br>&gt;<br>&gt; //print( add_tuple(1,2) ) // extra argument in call<br>&gt; print( add_tuple((1,2)) )<br>&gt;<br>&gt;<br>&gt; Proposal:<br>&gt; ===============<br>&gt;<br>&gt; 1. Separate function types with parameter list and a tuple parameter. They<br>&gt; should be two separate types.<br>&gt;<br>&gt; 2. Require this syntax to assign tuple parameter&#39;s sub-values to variables<br>&gt; in func/closure: `{ ((x, y)) in ..}`, otherwise (i.e. if `{ (x, y) in ..`)<br>&gt; treat function/closure as having list of parameters.<br>&gt;<br>&gt; 3. Disallow implicit conversion between function/closure with a list of<br>&gt; parameters and function/closure where single tuple is required.<br>&gt; This will stop confusion and make the language consistent how it deal with<br>&gt; tuples and list of parameters in func/closure.<br>&gt;<br>&gt; 4. It seems like we should keep the ability to explicitly convert one to<br>&gt; another as some(many?) code can depend on this current behavior and so we<br>&gt; need a way to convert old code to new.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a77358ab/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Disallow implicit conversion between function/closure with a list of parameters and with tuple parameter. Remove function type inconsistency.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>+1 to this; I seem to keep running into cases of this, and it crops up especially when Swift is having difficulty inferring a type, which can be tricky to debug as it is, so I think it&#39;s better to just be consistent and explicit, with double brackets for all tuple type closures as proposed.<br></p><p>&gt; On 25 Jun 2016, at 16:35, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe this should be done for Swift 3.0 release as this is a *source breaking change* and IMO it is very important to remove the inconsistency mentioned below.<br>&gt; <br>&gt; We removed tuple splatting on caller side and IMO we must complete this job to delete the implicit connection between tuple and list of parameters in closures/functions.<br>&gt; <br>&gt; <br>&gt; Currently we have these &quot;features&quot; :<br>&gt; ====================================<br>&gt; <br>&gt; 1. Single tuple as parameter is allowed when list of parameters are required:<br>&gt; <br>&gt; let ft1 : (Int,Int) -&gt; Void = { x in print(x.0, x.1)}<br>&gt; <br>&gt; (but this causes crash:<br>&gt; let ft2 : (Int,Int) -&gt; Void = { x in print(x) }<br>&gt; )<br>&gt; <br>&gt; Opinion: this should not be allowed. Parameter list is required.<br>&gt; `(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` are two different types.<br>&gt; <br>&gt; <br>&gt; 2. Parameter list in closure is allowed when single tuple parameter is required:<br>&gt; <br>&gt; typealias IntInt = (Int,Int)<br>&gt; typealias IntIntToVoid = (IntInt) -&gt; Void<br>&gt; <br>&gt; let tuple : IntInt = (1,2)<br>&gt; <br>&gt; func foo(block: IntIntToVoid) { block(tuple) }<br>&gt; <br>&gt; foo { x, y in print(x,y)}<br>&gt; foo { (x, y) in print(x, y)}<br>&gt; <br>&gt; Opinion: this should not be allowed. Tuple parameter is required.<br>&gt; `((Int,Int)) -&gt; Void` and `(Int,Int) -&gt; Void` are two different types.<br>&gt; Swift should require this syntax to assign tuple parameter&#39;s sub-values to variables in closure: `{ ((x, y)) in ..}`<br>&gt; <br>&gt; <br>&gt; 3. Inconsistent (and just wrong) function type when a list of parameters required(not tuple) :<br>&gt; <br>&gt; typealias t1 = (Int, Int) -&gt; Int // clearly here are list of parameters<br>&gt; typealias t2 = ((Int, Int)) -&gt; Int // clearly here is a tuple parameter<br>&gt; <br>&gt; print(t1.self) // Prints ((Int, Int)) -&gt; Int  why?<br>&gt; print(t2.self) // Prints ((Int, Int)) -&gt; Int<br>&gt; print(t1.self == t2.self) // true<br>&gt; <br>&gt; Opinion: `(Int,Int) -&gt; Void` and `((Int,Int)) -&gt; Void` should be two different separate types that can not be implicitly converted to each other. Swift&#39;s typesystem should separate these types.<br>&gt; <br>&gt; <br>&gt; 4. If the type is the same, why behavior differs :<br>&gt; <br>&gt; let add_list:  (Int, Int) -&gt; Int = (+)<br>&gt; let add_tuple: ((Int, Int)) -&gt; Int = (+)<br>&gt; <br>&gt; print(add_list.dynamicType == add_tuple.dynamicType) // true<br>&gt; <br>&gt; print( add_list(1,2) )<br>&gt; //print( add_list((1,2)) ) // missing argument for parameter #2 in call<br>&gt; <br>&gt; //print( add_tuple(1,2) ) // extra argument in call<br>&gt; print( add_tuple((1,2)) )<br>&gt; <br>&gt; <br>&gt; Proposal:<br>&gt; ===============<br>&gt; <br>&gt; 1. Separate function types with parameter list and a tuple parameter. They should be two separate types.<br>&gt; <br>&gt; 2. Require this syntax to assign tuple parameter&#39;s sub-values to variables in func/closure: `{ ((x, y)) in ..}`, otherwise (i.e. if `{ (x, y) in ..`) treat function/closure as having list of parameters.<br>&gt; <br>&gt; 3. Disallow implicit conversion between function/closure with a list of parameters and function/closure where single tuple is required.<br>&gt; This will stop confusion and make the language consistent how it deal with tuples and list of parameters in func/closure.<br>&gt; <br>&gt; 4. It seems like we should keep the ability to explicitly convert one to another as some(many?) code can depend on this current behavior and so we need a way to convert old code to new.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
