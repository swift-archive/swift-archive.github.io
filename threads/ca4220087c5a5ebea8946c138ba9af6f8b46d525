<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi swift-evolutionaries,<br></p><p>I&#39;m sorry to bring a proposal late to the table, but this could make a big difference to the Swift 3 migration experience.<br></p><p>This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br></p><p>Proposal:<br></p><p>https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md &lt;https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md&gt;<br></p><p><br></p><p>Intro:<br></p><p>[SE-0107: UnsafeRawPointer](https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md) formalized Swift&#39;s memory model with respect to strict aliasing and prevented arbitrary conversion between `UnsafePointer` types. When moving to Swift 3, users will need to migrate much of their code dealing with `UnsafePointer`s. The new `UnsafeRawPointer` makes that possible. It provides a legal means to operate on raw memory (independent of the type of values in memory), and it provides an API for binding memory to a type for subsequent normal typed access. However, migrating to these new APIs is not always straightforward. It has become customary to use `[UInt8]` in APIs that deal with a buffer of bytes and are agnostic to the type of values held by the buffer. However, converting between `UInt8` and the client&#39;s element type at every API transition is difficult to do safely. See the [WIP UnsafeRawPointer Migration Guide]().<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/ca42d525/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: NNNN-UnsafeBytes.md<br>Type: text/markdown<br>Size: 32215 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/ca42d525/attachment.bin&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/ca42d525/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 13, 2016 at 02:00:00am</p></header><div class="content"><p>Only very recently, I remember running into the very issue identified in<br>this write-up regarding the Data API. I&#39;m glad that this proposal is aiming<br>to address some of that.<br></p><p>Question, though: In what sense is UnsafeBytes unsafe?<br></p><p><br></p><p>On Fri, Aug 12, 2016 at 20:12 Andrew Trick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi swift-evolutionaries,<br>&gt;<br>&gt; I&#39;m sorry to bring a proposal late to the table, but this could make a big<br>&gt; difference to the Swift 3 migration experience.<br>&gt;<br>&gt; This proposal adds basic usability for working with raw memory without<br>&gt; breaking source. The need to provide higher level API for working with raw<br>&gt; memory buffers has always been evident, but making improvements in this<br>&gt; area depended on first introducing `UnsafeRawPointer`. It was not clear<br>&gt; until the final week of source-breaking changes whether SE-0107 would make<br>&gt; it into Swift 3. Now that it has, we should use the little remaining time<br>&gt; to improve the migration experience and encourage correct use of the memory<br>&gt; model by introducing a low-risk additive API.<br>&gt;<br>&gt; Proposal:<br>&gt;<br>&gt;<br>&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt;<br>&gt;<br>&gt; Intro:<br>&gt;<br>&gt; [SE-0107: UnsafeRawPointer](<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md)<br>&gt; formalized Swift&#39;s memory model with respect to strict aliasing and<br>&gt; prevented arbitrary conversion between `UnsafePointer` types. When moving<br>&gt; to Swift 3, users will need to migrate much of their code dealing with<br>&gt; `UnsafePointer`s. The new `UnsafeRawPointer` makes that possible. It<br>&gt; provides a legal means to operate on raw memory (independent of the type of<br>&gt; values in memory), and it provides an API for binding memory to a type for<br>&gt; subsequent normal typed access. However, migrating to these new APIs is not<br>&gt; always straightforward. It has become customary to use `[UInt8]` in APIs<br>&gt; that deal with a buffer of bytes and are agnostic to the type of values<br>&gt; held by the buffer. However, converting between `UInt8` and the client&#39;s<br>&gt; element type at every API transition is difficult to do safely. See the<br>&gt; [WIP UnsafeRawPointer Migration Guide]().<br>&gt;<br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160813/4fb23e4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 7:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Only very recently, I remember running into the very issue identified in this write-up regarding the Data API. I&#39;m glad that this proposal is aiming to address some of that.<br>&gt; <br>&gt; Question, though: In what sense is UnsafeBytes unsafe?<br></p><p>It’s not reference counted. UnsafeBytes is really a slice into raw memory that someone else is managing.<br></p><p>It might be nice to have a reference counted wrapper for this, but that’s *much* lower priority and it’s not nearly as clear how that should be done.<br>All the use cases I’ve looked at so far want to use manual allocation/deallocation (for a simple temp buffer) or `Data` or [UInt8] to persist the memory.<br></p><p>Note that [UInt8] can work well now as a temporary buffer as long as you’re using UnsafeBytes to copy data in:<br></p><p>var buffer = [UInt8]()<br></p><p>struct S {<br>  var x: Int<br>}<br></p><p>var s = S(x:3)<br></p><p>withUnsafeBytes(of: &amp;s) {<br>  buffer += $0<br>}<br></p><p>-Andy<br></p><p>&gt; On Fri, Aug 12, 2016 at 20:12 Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi swift-evolutionaries,<br>&gt; <br>&gt; I&#39;m sorry to bring a proposal late to the table, but this could make a big difference to the Swift 3 migration experience.<br>&gt; <br>&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md &lt;https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md&gt;<br>&gt; <br>&gt; <br>&gt; Intro:<br>&gt; <br>&gt; [SE-0107: UnsafeRawPointer](https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;) formalized Swift&#39;s memory model with respect to strict aliasing and prevented arbitrary conversion between `UnsafePointer` types. When moving to Swift 3, users will need to migrate much of their code dealing with `UnsafePointer`s. The new `UnsafeRawPointer` makes that possible. It provides a legal means to operate on raw memory (independent of the type of values in memory), and it provides an API for binding memory to a type for subsequent normal typed access. However, migrating to these new APIs is not always straightforward. It has become customary to use `[UInt8]` in APIs that deal with a buffer of bytes and are agnostic to the type of values held by the buffer. However, converting between `UInt8` and the client&#39;s element type at every API transition is difficult to do safely. See the [WIP UnsafeRawPointer Migration Guide]().<br>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/bfaaa225/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt; <br>&gt; Proposal:<br>&gt; <br>&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt; <br>&gt; &lt;NNNN-UnsafeBytes.md&gt;<br></p><p>I&#39;ve only read a little but so far, but: Is the difference between this and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 12, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 7:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt;&gt; <br>&gt;&gt; Proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt;&gt; <br>&gt;&gt; &lt;NNNN-UnsafeBytes.md&gt;<br>&gt; <br>&gt; I&#39;ve only read a little but so far, but: Is the difference between this and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br></p><p>Yes that’s exactly right. Semantically, reads or writes on `UnsafeBytes` are untyped memory accesses. So you can get bytes into or out of it without binding memory.<br></p><p>But as you’ll see from the interfaces and examples I’ve shown, `UnsafeMutableRawBufferPointer` would be a terrible name. There’s no reason from the user’s point of view to link this type to `UnsafeBufferPointer` and that names conveys no additionally useful information.  It’s often viewed as just a collection of Bytes and potentially an important type for a number of public interfaces.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 7:47 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 12, 2016, at 7:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;NNNN-UnsafeBytes.md&gt;<br>&gt;&gt; <br>&gt;&gt; I&#39;ve only read a little but so far, but: Is the difference between this and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br>&gt; <br>&gt; Yes that’s exactly right. Semantically, reads or writes on `UnsafeBytes` are untyped memory accesses. So you can get bytes into or out of it without binding memory.<br>&gt; <br>&gt; But as you’ll see from the interfaces and examples I’ve shown, `UnsafeMutableRawBufferPointer` would be a terrible name. There’s no reason from the user’s point of view to link this type to `UnsafeBufferPointer` and that names conveys no additionally useful information.  It’s often viewed as just a collection of Bytes and potentially an important type for a number of public interfaces.<br></p><p><br>I can give you a less dissmissive answer to this, because there is potential for confusion given that the value is actually a view over the bytes, not the bytes. I just don&#39;t think a longer name will clarify the semantics:<br></p><p>- `Bytes` sufficiently conveys a region of raw memory.<br></p><p>- The `Unsafe` already hints that this is only a &quot;view&quot; into memory,<br>  not a copy of the Bytes, and suggests that the developer needs to<br>  consult the doc comment if using it in a non-idiomatic way.<br></p><p>- In the expected idioms (see examples) this simple name will be far<br>  more meaningful and less distracting.<br></p><p>- Adding `Raw` to the name is purely redundant and adding `Buffer`,<br>  and `Pointer` into the name would cause confusion.<br></p><p>I think both your and Xiaodi&#39;s comments can be addressed by clarifying<br>the doc comments:<br></p><p>/// A non-owning view of raw memory as a collection of `UInt8` bytes.<br>///<br>/// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>/// do no require binding the memory to `UInt8`.<br>///<br>/// In addition to the `Collection` interface, this provides a bounds-checked<br>/// version of `UnsafeMutableRawPointer`&#39;s interface to raw memory:<br>/// `load(fromByteOffset:as:)`, `storeBytes(of:toByteOffset:as:)`, and<br>/// `copyBytes(from:count:)`.<br>///<br>/// Because this is only a view into memory, and does not own the memory,<br>/// copying a value of type `UnsafeMutableBytes` does not copy the underlying<br>/// memory. However, assigning into `UnsafeMutableBytes` via a subscript copies<br>/// bytes into the memory, and assigning an `UnsafeMutableBytes` into a<br>/// value-based collection, such as `[UInt8]` copies bytes out of memory.<br>///<br>/// Example:<br>///<br>///   // View a slice of memory at someBytes.<br>///   var destBytes = someBytes[0..&lt;n]<br>///<br>///   // Copy `n` bytes of data from sourceBytes into that view.<br>///   destBytes[0..&lt;n] = sourceBytes<br>///<br>///   // View a different slice memory at someBytes.<br>///   destBytes = someBytes[n..&lt;m]<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/c82320be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 12, 2016 at 09:00:00pm</p></header><div class="content"><p>Can we do a quick recap? Please correct me if I&#39;m wrong.<br></p><p>UnsafePointer: pointer to memory that the compiler may assume to be typed. Bounds unknown.<br>UnsafeBufferPointer: pointer to several objects that the compiler may assume to be typed Bounds known.<br>UnsafeRawPointer: pointer to memory that the compiler cannot assume to be typed. Bounds unknown.<br></p><p>I think that I&#39;m coming to the same conclusion as Brent, that UnsafeBytes is to UnsafeRawPointer what UnsafeBufferPointer is to UnsafePointer.<br></p><p>It seems to me that this could be neatly laid out in a matrix, and to me that kind of justifies giving similar names.<br></p><p>            One logical object    Many logical objects<br>Typed       UnsafePointer         UnsafeBufferPointer<br>Untyped     UnsafeRawPointer      UnsafeBytes<br></p><p>One thing that I don&#39;t really like about UnsafeBytes is that it poorly conveys that the memory is not typed. In fact, it looks like it&#39;s typed to be UInt8. (From what I recall, C++&#39;s strict aliasing does an exception for arrays of chars, but that&#39;s not a reason to import that notion in Swift.)<br></p><p>Félix<br></p><p>&gt; Le 12 août 2016 à 19:47:36, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 12, 2016, at 7:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;NNNN-UnsafeBytes.md&gt;<br>&gt;&gt; <br>&gt;&gt; I&#39;ve only read a little but so far, but: Is the difference between this and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br>&gt; <br>&gt; Yes that’s exactly right. Semantically, reads or writes on `UnsafeBytes` are untyped memory accesses. So you can get bytes into or out of it without binding memory.<br>&gt; <br>&gt; But as you’ll see from the interfaces and examples I’ve shown, `UnsafeMutableRawBufferPointer` would be a terrible name. There’s no reason from the user’s point of view to link this type to `UnsafeBufferPointer` and that names conveys no additionally useful information.  It’s often viewed as just a collection of Bytes and potentially an important type for a number of public interfaces.<br>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/ae8f0a7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 9:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Can we do a quick recap? Please correct me if I&#39;m wrong.<br>&gt; <br>&gt; UnsafePointer: pointer to memory that the compiler may assume to be typed. Bounds unknown.<br>&gt; UnsafeBufferPointer: pointer to several objects that the compiler may assume to be typed Bounds known.<br>&gt; UnsafeRawPointer: pointer to memory that the compiler cannot assume to be typed. Bounds unknown.<br>&gt; <br>&gt; I think that I&#39;m coming to the same conclusion as Brent, that UnsafeBytes is to UnsafeRawPointer what UnsafeBufferPointer is to UnsafePointer.<br>&gt; <br>&gt; It seems to me that this could be neatly laid out in a matrix, and to me that kind of justifies giving similar names.<br>&gt; <br>&gt;             One logical object    Many logical objects<br>&gt; Typed       UnsafePointer         UnsafeBufferPointer<br>&gt; Untyped     UnsafeRawPointer      UnsafeBytes<br>&gt; <br>&gt; One thing that I don&#39;t really like about UnsafeBytes is that it poorly conveys that the memory is not typed. In fact, it looks like it&#39;s typed to be UInt8. (From what I recall, C++&#39;s strict aliasing does an exception for arrays of chars, but that&#39;s not a reason to import that notion in Swift.)<br>&gt; <br>&gt; Félix<br></p><p>That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. But the memory access used to read or write those elements is untyped. It’s precisely for code that needs to stream bytes into or out of an object without thinking about binding memory to a type.<br></p><p>`bytes` is already our commonly used label for either untyped memory of UInt8 sized values, or for `UnsafeBufferPointer&lt;UInt8&gt;`. But these two things are frustratingly incompatible. `UnsafeBytes` is much more important than filling in that square in your matrix. It also does away with the now common, but incorrect use of `UnsafeBufferPointer&lt;UInt8&gt;` all over the place.<br></p><p>Look at the examples, imagine you’ve never heard of an UnsafeRawPointer, and see if you can come up with a better API. This all makes perfect sense when you approach the problem from the common use cases, rather than from a standard library implementer’s point of view.<br></p><p>-Andy<br></p><p>&gt;&gt; Le 12 août 2016 à 19:47:36, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 12, 2016, at 7:32 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md &lt;https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;NNNN-UnsafeBytes.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve only read a little but so far, but: Is the difference between this and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br>&gt;&gt; <br>&gt;&gt; Yes that’s exactly right. Semantically, reads or writes on `UnsafeBytes` are untyped memory accesses. So you can get bytes into or out of it without binding memory.<br>&gt;&gt; <br>&gt;&gt; But as you’ll see from the interfaces and examples I’ve shown, `UnsafeMutableRawBufferPointer` would be a terrible name. There’s no reason from the user’s point of view to link this type to `UnsafeBufferPointer` and that names conveys no additionally useful information.  It’s often viewed as just a collection of Bytes and potentially an important type for a number of public interfaces.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160812/f73f76cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 13, 2016 at 04:00:00am</p></header><div class="content"><p>I have to agree here that UnsafeBytes reads much better and makes more<br>intuitive sense at call sites than any of the alternatives.<br>On Fri, Aug 12, 2016 at 23:34 Andrew Trick via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Aug 12, 2016, at 9:13 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt; Can we do a quick recap? Please correct me if I&#39;m wrong.<br>&gt;<br>&gt;<br>&gt;    - UnsafePointer: pointer to memory that the compiler may assume to be<br>&gt;    typed. Bounds unknown.<br>&gt;    - UnsafeBufferPointer: pointer to several objects that the compiler<br>&gt;    may assume to be typed Bounds known.<br>&gt;    - UnsafeRawPointer: pointer to memory that the compiler cannot assume<br>&gt;    to be typed. Bounds unknown.<br>&gt;<br>&gt;<br>&gt; I think that I&#39;m coming to the same conclusion as Brent, that UnsafeBytes<br>&gt; is to UnsafeRawPointer what UnsafeBufferPointer is to UnsafePointer.<br>&gt;<br>&gt; It seems to me that this could be neatly laid out in a matrix, and to me<br>&gt; that kind of justifies giving similar names.<br>&gt;<br>&gt;             One logical object    Many logical objects<br>&gt; Typed       UnsafePointer         UnsafeBufferPointer<br>&gt; Untyped     UnsafeRawPointer      UnsafeBytes<br>&gt;<br>&gt; One thing that I don&#39;t really like about UnsafeBytes is that it poorly<br>&gt; conveys that the memory is not typed. In fact, it looks like it&#39;s typed to<br>&gt; be UInt8. (From what I recall, C++&#39;s strict aliasing does an exception for<br>&gt; arrays of chars, but that&#39;s not a reason to import that notion in Swift.)<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;<br>&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be<br>&gt; in the lower right. But it would be nothing more than a raw pointer with<br>&gt; length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful<br>&gt; abstraction on top of what we just called UnsafeRawBufferPointer. It is a<br>&gt; collection of typed elements `UInt8`. But the memory access used to read or<br>&gt; write those elements is untyped. It’s precisely for code that needs to<br>&gt; stream bytes into or out of an object without thinking about binding memory<br>&gt; to a type.<br>&gt;<br>&gt; `bytes` is already our commonly used label for either untyped memory of<br>&gt; UInt8 sized values, or for `UnsafeBufferPointer&lt;UInt8&gt;`. But these two<br>&gt; things are frustratingly incompatible. `UnsafeBytes` is much more important<br>&gt; than filling in that square in your matrix. It also does away with the now<br>&gt; common, but incorrect use of `UnsafeBufferPointer&lt;UInt8&gt;` all over the<br>&gt; place.<br>&gt;<br>&gt; Look at the examples, imagine you’ve never heard of an UnsafeRawPointer,<br>&gt; and see if you can come up with a better API. This all makes perfect sense<br>&gt; when you approach the problem from the common use cases, rather than from a<br>&gt; standard library implementer’s point of view.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt; Le 12 août 2016 à 19:47:36, Andrew Trick via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt;<br>&gt; On Aug 12, 2016, at 7:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Aug 12, 2016, at 6:12 PM, Andrew Trick via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This proposal adds basic usability for working with raw memory without<br>&gt; breaking source. The need to provide higher level API for working with raw<br>&gt; memory buffers has always been evident, but making improvements in this<br>&gt; area depended on first introducing `UnsafeRawPointer`. It was not clear<br>&gt; until the final week of source-breaking changes whether SE-0107 would make<br>&gt; it into Swift 3. Now that it has, we should use the little remaining time<br>&gt; to improve the migration experience and encourage correct use of the memory<br>&gt; model by introducing a low-risk additive API.<br>&gt;<br>&gt; Proposal:<br>&gt;<br>&gt;<br>&gt; https://github.com/atrick/swift-evolution/blob/unsafebytes/proposals/NNNN-UnsafeBytes.md<br>&gt;<br>&gt; &lt;NNNN-UnsafeBytes.md&gt;<br>&gt;<br>&gt;<br>&gt; I&#39;ve only read a little but so far, but: Is the difference between this<br>&gt; and UnsafeBufferPointer that it&#39;s built around a raw pointer rather than a<br>&gt; bound pointer? If so, would UnsafeRawBufferPointer be a better name?<br>&gt;<br>&gt;<br>&gt; Yes that’s exactly right. Semantically, reads or writes on `UnsafeBytes`<br>&gt; are untyped memory accesses. So you can get bytes into or out of it without<br>&gt; binding memory.<br>&gt;<br>&gt; But as you’ll see from the interfaces and examples I’ve shown,<br>&gt; `UnsafeMutableRawBufferPointer` would be a terrible name. There’s no reason<br>&gt; from the user’s point of view to link this type to `UnsafeBufferPointer`<br>&gt; and that names conveys no additionally useful information.  It’s often<br>&gt; viewed as just a collection of Bytes and potentially an important type for<br>&gt; a number of public interfaces.<br>&gt;<br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160813/d25f7e3c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br></p><p>But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 13, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 13, 2016, at 12:17 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br>&gt; <br>&gt; But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br></p><p><br>Giving UnsafeRawPointer a memory size doesn’t imply a collection of any specific type. You’re supposed to used bindMemory(to:capacity:) to get a collection out of it. Giving UnsafeBytes a name analogous to UnsafeBufferPointer only exposes that subtle difference, which is actually irrelevant. In the common case, users don’t need to know how UnsafeRawPointer works, so why start with that analogy?<br></p><p>The use cases justify the name. `UnsafeBytes` is what developers have been trying to get all along with `UnsafeBufferPointer&lt;UInt8&gt;`. The concept already exists to developers, but we have failed to give them a distinct, simple, and intuitive name for it, not to mention a correct implementation.<br></p><p>-Andy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 13, 2016 at 07:00:00am</p></header><div class="content"><p>And then, we can&#39;t really use UnsafeBufferPointer&lt;UInt8&gt; for the purpose of UnsafeBytes because we want to expose a different API. Is that right?<br></p><p>Félix<br></p><p>&gt; Le 13 août 2016 à 01:44:28, Andrew Trick &lt;atrick at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 13, 2016, at 12:17 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br>&gt;&gt; <br>&gt;&gt; But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br>&gt; <br>&gt; <br>&gt; Giving UnsafeRawPointer a memory size doesn’t imply a collection of any specific type. You’re supposed to used bindMemory(to:capacity:) to get a collection out of it. Giving UnsafeBytes a name analogous to UnsafeBufferPointer only exposes that subtle difference, which is actually irrelevant. In the common case, users don’t need to know how UnsafeRawPointer works, so why start with that analogy?<br>&gt; <br>&gt; The use cases justify the name. `UnsafeBytes` is what developers have been trying to get all along with `UnsafeBufferPointer&lt;UInt8&gt;`. The concept already exists to developers, but we have failed to give them a distinct, simple, and intuitive name for it, not to mention a correct implementation.<br>&gt; <br>&gt; -Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160813/8cc6176e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 13, 2016, at 7:12 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; And then, we can&#39;t really use UnsafeBufferPointer&lt;UInt8&gt; for the purpose of UnsafeBytes because we want to expose a different API. Is that right?<br></p><p>UnsafeBufferPointer&lt;UInt8&gt; should be used in the same situation that UnsafePointer&lt;T&gt; is used for any T. A view over an array of UInt8 that can bypasses release bounds checks and can interoperate with C.<br></p><p>UnsafeBufferPointer&lt;UInt8&gt; should not be used to erase the memory’s pointee type.<br></p><p>UnsafeBytes erases the pointee type and gives algorithms a collection of bytes to work with. It turns out to be an important use case that I very much want to distinguish from the UnsafeBufferPointer use case. I don’t want to present users with a false analogy to UnsafeBufferPointer.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; Le 13 août 2016 à 01:44:28, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 13, 2016, at 12:17 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Giving UnsafeRawPointer a memory size doesn’t imply a collection of any specific type. You’re supposed to used bindMemory(to:capacity:) to get a collection out of it. Giving UnsafeBytes a name analogous to UnsafeBufferPointer only exposes that subtle difference, which is actually irrelevant. In the common case, users don’t need to know how UnsafeRawPointer works, so why start with that analogy?<br>&gt;&gt; <br>&gt;&gt; The use cases justify the name. `UnsafeBytes` is what developers have been trying to get all along with `UnsafeBufferPointer&lt;UInt8&gt;`. The concept already exists to developers, but we have failed to give them a distinct, simple, and intuitive name for it, not to mention a correct implementation.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160813/7bf0ed21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>August 15, 2016 at 11:00:00am</p></header><div class="content"><p>It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br></p><p><br>/// A non-owning view of raw memory as a collection of bytes.<br>///<br>/// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>/// do no require binding the memory to a type. These operations are expressed <br>/// in terms of `UInt8`, though the underlying memory is untyped.<br></p><p>…<br></p><p>You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br></p><p><br>&gt; On Aug 13, 2016, at 9:34 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 13, 2016, at 7:12 AM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And then, we can&#39;t really use UnsafeBufferPointer&lt;UInt8&gt; for the purpose of UnsafeBytes because we want to expose a different API. Is that right?<br>&gt; <br>&gt; UnsafeBufferPointer&lt;UInt8&gt; should be used in the same situation that UnsafePointer&lt;T&gt; is used for any T. A view over an array of UInt8 that can bypasses release bounds checks and can interoperate with C.<br>&gt; <br>&gt; UnsafeBufferPointer&lt;UInt8&gt; should not be used to erase the memory’s pointee type.<br>&gt; <br>&gt; UnsafeBytes erases the pointee type and gives algorithms a collection of bytes to work with. It turns out to be an important use case that I very much want to distinguish from the UnsafeBufferPointer use case. I don’t want to present users with a false analogy to UnsafeBufferPointer.<br>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 13 août 2016 à 01:44:28, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 13, 2016, at 12:17 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Giving UnsafeRawPointer a memory size doesn’t imply a collection of any specific type. You’re supposed to used bindMemory(to:capacity:) to get a collection out of it. Giving UnsafeBytes a name analogous to UnsafeBufferPointer only exposes that subtle difference, which is actually irrelevant. In the common case, users don’t need to know how UnsafeRawPointer works, so why start with that analogy?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The use cases justify the name. `UnsafeBytes` is what developers have been trying to get all along with `UnsafeBufferPointer&lt;UInt8&gt;`. The concept already exists to developers, but we have failed to give them a distinct, simple, and intuitive name for it, not to mention a correct implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Andy<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/63f9b94f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks i&#39;ll try to clarify in the comments that The memory is read out as UInt8 but the memory is untyped. <br></p><p>Andy<br></p><p>&gt; On Aug 15, 2016, at 11:55 AM, Michael Ilseman &lt;milseman at apple.com&gt; wrote:<br>&gt; <br>&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt; <br>&gt; <br>&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt; ///<br>&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt; <br>&gt; …<br>&gt; <br>&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Aug 13, 2016, at 9:34 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 13, 2016, at 7:12 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And then, we can&#39;t really use UnsafeBufferPointer&lt;UInt8&gt; for the purpose of UnsafeBytes because we want to expose a different API. Is that right?<br>&gt;&gt; <br>&gt;&gt; UnsafeBufferPointer&lt;UInt8&gt; should be used in the same situation that UnsafePointer&lt;T&gt; is used for any T. A view over an array of UInt8 that can bypasses release bounds checks and can interoperate with C.<br>&gt;&gt; <br>&gt;&gt; UnsafeBufferPointer&lt;UInt8&gt; should not be used to erase the memory’s pointee type.<br>&gt;&gt; <br>&gt;&gt; UnsafeBytes erases the pointee type and gives algorithms a collection of bytes to work with. It turns out to be an important use case that I very much want to distinguish from the UnsafeBufferPointer use case. I don’t want to present users with a false analogy to UnsafeBufferPointer.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 13 août 2016 à 01:44:28, Andrew Trick &lt;atrick at apple.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 13, 2016, at 12:17 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 12, 2016, at 9:34 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That matrix is the correct starting point. UnsafeRawBufferPointer would be in the lower right. But it would be nothing more than a raw pointer with length. It wouldn’t be a collection of anything. UnsafeBytes is a powerful abstraction on top of what we just called UnsafeRawBufferPointer. It is a collection of typed elements `UInt8`. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But how is that different from UnsafeBufferPointer? Put another way, what is it about the UnsafeRawPointer -&gt; UnsafeBytes relationship that isn&#39;t true about UnsafePointer -&gt; UnsafeBufferPointer, and that therefore justifies the different name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Giving UnsafeRawPointer a memory size doesn’t imply a collection of any specific type. You’re supposed to used bindMemory(to:capacity:) to get a collection out of it. Giving UnsafeBytes a name analogous to UnsafeBufferPointer only exposes that subtle difference, which is actually irrelevant. In the common case, users don’t need to know how UnsafeRawPointer works, so why start with that analogy?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The use cases justify the name. `UnsafeBytes` is what developers have been trying to get all along with `UnsafeBufferPointer&lt;UInt8&gt;`. The concept already exists to developers, but we have failed to give them a distinct, simple, and intuitive name for it, not to mention a correct implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Andy<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/a86809d7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; <br>&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt; <br>&gt; <br>&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt; ///<br>&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt; <br>&gt; …<br>&gt; <br>&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br></p><p>I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 17, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt; ///<br>&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt; <br>&gt;&gt; …<br>&gt;&gt; <br>&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt; <br>&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>‘Byte’ is sufficient, I think.<br></p><p>In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/fe71ec4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; ‘Byte’ is sufficient, I think.<br>&gt; <br>&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br></p><p>Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br></p><p>Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br></p><p>The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/9bbead36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8dfc6932943f38e7a7de48be3194f13c?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Michael Ilseman</string> &lt;milseman at apple.com&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 10:35 AM, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt; <br>&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt; <br>&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt; <br>&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt; <br></p><p>I agree, and sorry for the diversion.<br></p><p>&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/4a2d45ab/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt; <br>&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt; <br>&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt; <br>&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt; <br>&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt; <br>&gt; -Andy<br></p><p>Well, a byte is a numerical type as much as a UInt8 is. We attach meaning to it (e.g. a memory location), but it’s just a number. Perhaps it shouldn’t be a typealias then (if the alias would have some kind of impure semantics), but its own type which is exactly the same as UInt8. Typing raw memory accesses with `Byte` to indicate that the number was read from raw memory is a good idea for type-safety IMO.<br></p><p>You’d wonder if we could have initialisers for other integer types which take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That wouldn’t make as much sense with two UInt8s.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/22b871f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 19, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; It seems like there’s a potential for confusion here, in that people may<br>&gt; see “UInt8” and assume there is some kind of typed-ness, even though the<br>&gt; whole point is that this is untyped. Adjusting the header comments slightly<br>&gt; might help:<br>&gt;<br>&gt;<br>&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt; ///<br>&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations<br>&gt; that<br>&gt; /// do no require binding the memory to a type. These operations are<br>&gt; expressed<br>&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;<br>&gt; …<br>&gt;<br>&gt; You could go even further towards hinting this fact with a `typealias Byte<br>&gt; = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too<br>&gt; excessive.<br>&gt;<br>&gt;<br>&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say<br>&gt; that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home<br>&gt; the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a<br>&gt; side effect of CPUs generally not having support for types *other* than<br>&gt; ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;<br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; ‘Byte’ is sufficient, I think.<br>&gt;<br>&gt; In some sense, it is typed as bytes. It reflects the fact that anything<br>&gt; that is representable to the computer must be expressible as a sequence of<br>&gt; bits (the same way we have string de/serialisation — which of course is not<br>&gt; to say that the byte representation is good for serialisation purposes).<br>&gt; “withUnsafeBytes” can be seen as doing a reversible type conversion the<br>&gt; same way LosslessStringConvertible does; only in this case the conversion<br>&gt; is free.<br>&gt;<br>&gt;<br>&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But<br>&gt; typealias Byte = UInt8 would imply the opposite of what needs to be<br>&gt; conveyed. The name Byte refers to raw memory being accessed, not the value<br>&gt; being returned by the collection. The in-memory value&#39;s bytes are loaded<br>&gt; from memory and reinterpreted as UInt8 values. UInt8 is the correct type<br>&gt; for the value after it is loaded. Calling the collection’s element type<br>&gt; Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be<br>&gt; nonsense.<br>&gt;<br>&gt; Keep in mind the important use case is code that needs to work with a<br>&gt; collection of UInt8 values without knowing the type of the values in<br>&gt; memory. This makes it intuitive and convenient to implement correctly<br>&gt; without needing to reason about the Swift-specific notions of raw vs. typed<br>&gt; pointers and binding memory to a type.<br>&gt;<br>&gt; The documentation should be fixed to clarify that the in-memory value is<br>&gt; not the same as the loaded value.<br>&gt;<br>&gt; -Andy<br>&gt;<br>&gt;<br>&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning<br>&gt; to it (e.g. a memory location), but it’s just a number.<br>&gt;<br></p><p>But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the<br>usage of the word byte to mean raw memory and not a number?<br></p><p><br>&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some<br>&gt; kind of impure semantics), but its own type which is exactly the same as<br>&gt; UInt8. Typing raw memory accesses with `Byte` to indicate that the number<br>&gt; was read from raw memory is a good idea for type-safety IMO.<br>&gt;<br>&gt; You’d wonder if we could have initialisers for other integer types which<br>&gt; take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That<br>&gt; wouldn’t make as much sense with two UInt8s.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/a5c18e7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 12:43 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Aug 19, 2016 at 2:32 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 19 Aug 2016, at 19:35, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 7:13 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 16 Aug 2016, at 01:14, David Sweeris via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 15, 2016, at 13:55, Michael Ilseman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems like there’s a potential for confusion here, in that people may see “UInt8” and assume there is some kind of typed-ness, even though the whole point is that this is untyped. Adjusting the header comments slightly might help:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// A non-owning view of raw memory as a collection of bytes.<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// Reads and writes on memory via `UnsafeBytes` are untyped operations that<br>&gt;&gt;&gt;&gt;&gt; /// do no require binding the memory to a type. These operations are expressed <br>&gt;&gt;&gt;&gt;&gt; /// in terms of `UInt8`, though the underlying memory is untyped.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You could go even further towards hinting this fact with a `typealias Byte = UInt8`, and use Byte throughout. But, I don’t know if that’s getting too excessive.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think that&#39;s too excessive at all. I might even go further and say that we should call it &quot;Untyped&quot; instead of &quot;Byte&quot;, to really drive home the point (many people see &quot;byte&quot; and think &quot;8-bit int&quot;, which is merely a side effect of CPUs generally not having support for types *other* than ints and floats, rather than a reflection of the true &quot;type&quot; of the data).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; ‘Byte’ is sufficient, I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In some sense, it is typed as bytes. It reflects the fact that anything that is representable to the computer must be expressible as a sequence of bits (the same way we have string de/serialisation — which of course is not to say that the byte representation is good for serialisation purposes). “withUnsafeBytes” can be seen as doing a reversible type conversion the same way LosslessStringConvertible does; only in this case the conversion is free.<br>&gt;&gt; <br>&gt;&gt; Yes. Byte clearly refers to a value&#39;s in-memory representation. But typealias Byte = UInt8 would imply the opposite of what needs to be conveyed. The name Byte refers to raw memory being accessed, not the value being returned by the collection. The in-memory value&#39;s bytes are loaded from memory and reinterpreted as UInt8 values. UInt8 is the correct type for the value after it is loaded. Calling the collection’s element type Byte sends the wrong message. e.g. [Byte] or UnsafePointer&lt;Byte&gt; would be nonsense.<br>&gt;&gt; <br>&gt;&gt; Keep in mind the important use case is code that needs to work with a collection of UInt8 values without knowing the type of the values in memory. This makes it intuitive and convenient to implement correctly without needing to reason about the Swift-specific notions of raw vs. typed pointers and binding memory to a type.<br>&gt;&gt; <br>&gt;&gt; The documentation should be fixed to clarify that the in-memory value is not the same as the loaded value.<br>&gt;&gt; <br>&gt;&gt; -Andy<br>&gt; <br>&gt; Well, a byte is a numerical type as much as a UInt8 is. We attach meaning to it (e.g. a memory location), but it’s just a number.<br>&gt; <br>&gt; But I thought what Andy&#39;s saying is that he&#39;s proposing to standardize the usage of the word byte to mean raw memory and not a number?<br></p><p>That’s right. That’s exactly how the name “bytes” is being used in APIs and method names. A byte is not itself a number but it is common practice to reinterpret a byte as a number in [0,256). IMO this isn’t a problem that needs to be fixed.<br></p><p>&gt; Perhaps it shouldn’t be a typealias then (if the alias would have some kind of impure semantics), but its own type which is exactly the same as UInt8. Typing raw memory accesses with `Byte` to indicate that the number was read from raw memory is a good idea for type-safety IMO.<br>&gt; <br>&gt; You’d wonder if we could have initialisers for other integer types which take a fixed-size array of `Byte`s - e.g. UInt16(_: [2 * Byte]). That wouldn’t make as much sense with two UInt8s.<br></p><p>You would always go through memory to reinterpret the bits. There’s nothing wrong with this if you know the underlying pointer is aligned:<br></p><p>  bytes.load(as: UInt16.self)<br></p><p>UInt8 is the right default for the collection API because it’s common practice to work with buffers of [UInt8].<br></p><p>Most use cases are not going to exercise the numeric properties of UInt8, but I don’t see that as a problem in practice.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/653abb59/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>August 13, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br></p><p>As I wrote during the UnsafeRawPointer review, which seems to apply to this proposal as well (forgive me if I have totally misunderstood the proposal):<br></p><p>When glancing at the examples, they strike me as mostly being marshalling, which in my opinion would be better served by a safe marshalling API followed by unsafe handling of the resulting buffer, and vice versa for unmarshalling. I think it is very important (in the long run) that code that doesn&#39;t interact with C directly has safe ways of doing inherently safe operations, and not take the unsafe route just because that is the only API available.<br></p><p>My question is, how does this API fit into the bigger picture of marshalling, and what are the benefits of using this API instead of marshalling with safe buffers?<br></p><p>/Magnus<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[late pitch] UnsafeBytes proposal</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 13, 2016, at 2:56 AM, Magnus Ahltorp &lt;map at kth.se&gt; wrote:<br>&gt; <br>&gt;&gt; This proposal adds basic usability for working with raw memory without breaking source. The need to provide higher level API for working with raw memory buffers has always been evident, but making improvements in this area depended on first introducing `UnsafeRawPointer`. It was not clear until the final week of source-breaking changes whether SE-0107 would make it into Swift 3. Now that it has, we should use the little remaining time to improve the migration experience and encourage correct use of the memory model by introducing a low-risk additive API.<br>&gt; <br>&gt; As I wrote during the UnsafeRawPointer review, which seems to apply to this proposal as well (forgive me if I have totally misunderstood the proposal):<br>&gt; <br>&gt; When glancing at the examples, they strike me as mostly being marshalling, which in my opinion would be better served by a safe marshalling API followed by unsafe handling of the resulting buffer, and vice versa for unmarshalling. I think it is very important (in the long run) that code that doesn&#39;t interact with C directly has safe ways of doing inherently safe operations, and not take the unsafe route just because that is the only API available.<br>&gt; <br>&gt; My question is, how does this API fit into the bigger picture of marshalling, and what are the benefits of using this API instead of marshalling with safe buffers?<br>&gt; <br>&gt; /Magnus<br></p><p>I agree. This proposal has `Unsafe` in its name because it’s not the final solution. It fills an important hole in these use cases—all of which currently interoperate with C—but leaves lifetime management of the memory on the table. It leaves the design of the marshalling feature up to the user intentionally because the primary goal is to migrate existing code. What you’re proposing is more of a new feature and less of a Swift 3 migration usability bug.<br></p><p>-Andy<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
