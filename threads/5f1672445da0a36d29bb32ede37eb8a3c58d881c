<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/01c828c6eedd53b8e6a6432170a6dc31?s=50"></div><header><strong>[Idea] Type erasure for protocols with Self or associated type requirements.</strong> from <string>Vatsal Manot</string> &lt;vatsal.manot at yahoo.com&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>(This is my first time on swift-evolution / Mailman, I apologize for any formatting errors)<br></p><p>As we know, the following fails:<br>​<br>protocol _Protocol<br>{<br>    static var _Parameter: Any.Type { get }<br>    <br>    var nonGenericVariable: Int { get }<br>    var _parameter: Any { get set }<br>    <br>    func _inputParameter(_: Any) -&gt; Any?<br>}<br>​<br>Protocol.self<br>​<br>with the error:<br>​<br>protocol &#39;Protocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>​<br>For quite some time, I have been using a particular workaround for this:<br>​<br>protocol _Protocol<br>{<br>    static var _Parameter: Any.Type { get }<br>    <br>    var nonGenericVariable: Int { get }<br>    var _parameter: Any { get set }<br>    <br>    func _inputParameter(_: Any) -&gt; Any?<br>}<br>​<br>extension _Protocol where Self: Protocol<br>{<br>    static var _Parameter: Any.Type<br>    {<br>        return Parameter.self<br>    }<br>    <br>    var _parameter: Any<br>    {<br>        get<br>        {<br>            return parameter<br>        }<br>        <br>        set<br>        {<br>            parameter = newValue as! Parameter<br>        }<br>    }<br>    <br>    func _inputParameter(parameter: Any) -&gt; Any?<br>    {<br>        return (parameter as? Parameter).map(inputParameter)<br>    }<br>}<br>​<br>protocol Protocol: _Protocol<br>{<br>    typealias Parameter<br>    <br>    var nonGenericVariable: Int { get }<br>    var parameter: Parameter { get set }<br>    <br>    func inputParameter(_: Parameter) -&gt; Parameter<br>}<br>​<br>And it has worked well so far. <br>​<br>The idea is to let the compiler generate these type-erased ‘versions’ on demand, using syntax like:<br></p><p>Protocol.Opaque <br>​<br>The rough procedure of creating a type-erased version for a given protocol is as follows:<br></p><p>- Create a protocol with an underscore prefixed to the name of the target protocol.<br></p><p>- Expose all the non-ATD (self or associated type dependent) constructs as requirements (essentially just copying the declarations) <br></p><p>- Expose all the ATD constructs as requirements with associated types replaced with “Any”, with an underscore prefixed to their name changing the return value of functions accepting ATD inputs to an optional version of the same type.  <br></p><p>- Extend the target protocol with implementations of these type-erased ‘versions’ of ATD constructs. For variables, a computed property is provided which returns the target variable, and force casts newValue in the setter (if any) to the required ATD type. For functions, the parameters undergo an attempted cast to the required ATD types, and are then mapped over the original implementation. Functions without ATD parameters can return just Any, because there is no casting involved. <br></p><p>- Initializers become static functions with prefixed underscores, returning an Optional&lt;Protocol.Opaque&gt;<br></p><p>I admit that I don’t have a plan on how this should be implemented. My fear is that it require tremendous amounts of metadata, bloating the binary size, and so I have submitted this as an idea and not a proposal.<br></p><p>I have created a gist (https://gist.github.com/vmanot/888afc3f26caf142cd21 &lt;https://gist.github.com/vmanot/888afc3f26caf142cd21&gt;) as a demonstration. <br></p><p>This pattern has helped on innumerable occasions, and is used in my projects to allow some runtime tricks. It also helps me forward implementations in a way similar (behavior-wise) to “AnyGenerator” <br></p><p>import Swift<br></p><p>struct AnyGenerator&lt;Element&gt;<br>{<br>    var base: _GeneratorType<br>    <br>    init&lt;G: protocol&lt;_GeneratorType, GeneratorType&gt; where G.Element == Element&gt;(base: G)<br>    {<br>        self.base = base<br>    }<br>    <br>    mutating func next() -&gt; Element?<br>    {<br>        return (base._next() as! Optional&lt;Element&gt;)<br>    }<br>}<br></p><p>AnyGenerator(base: [1, 2, 3].generate())<br></p><p>(I have tested this with an actual_GeneratorType implementation, and it works)<br></p><p>Please let me know what you think of this idea, and whether it is viable or not.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/5f16881c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Idea] Type erasure for protocols with Self or associated type requirements.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 12, 2016 at 08:00:00pm</p></header><div class="content"><p>I have proposed something very similar:<br></p><p>    [swift-evolution] Make generics covariant and add generics to	protocols  &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006367.html&gt;  &lt;&gt;<br></p><p>Although I didn’t mention this in the proposal I am aware that if that proposal was accepted then Self could become a shorthand for the type name and loose all its ‘magic’ properties and would be in effect what you are suggesting.<br></p><p><br>&gt; On 12 Jan 2016, at 5:44 PM, Vatsal Manot via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (This is my first time on swift-evolution / Mailman, I apologize for any formatting errors)<br>&gt; <br>&gt; As we know, the following fails:<br>&gt; ​<br>&gt; protocol _Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type { get }<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var _parameter: Any { get set }<br>&gt;     <br>&gt;     func _inputParameter(_: Any) -&gt; Any?<br>&gt; }<br>&gt; ​<br>&gt; Protocol.self<br>&gt; ​<br>&gt; with the error:<br>&gt; ​<br>&gt; protocol &#39;Protocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; ​<br>&gt; For quite some time, I have been using a particular workaround for this:<br>&gt; ​<br>&gt; protocol _Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type { get }<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var _parameter: Any { get set }<br>&gt;     <br>&gt;     func _inputParameter(_: Any) -&gt; Any?<br>&gt; }<br>&gt; ​<br>&gt; extension _Protocol where Self: Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type<br>&gt;     {<br>&gt;         return Parameter.self<br>&gt;     }<br>&gt;     <br>&gt;     var _parameter: Any<br>&gt;     {<br>&gt;         get<br>&gt;         {<br>&gt;             return parameter<br>&gt;         }<br>&gt;         <br>&gt;         set<br>&gt;         {<br>&gt;             parameter = newValue as! Parameter<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func _inputParameter(parameter: Any) -&gt; Any?<br>&gt;     {<br>&gt;         return (parameter as? Parameter).map(inputParameter)<br>&gt;     }<br>&gt; }<br>&gt; ​<br>&gt; protocol Protocol: _Protocol<br>&gt; {<br>&gt;     typealias Parameter<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var parameter: Parameter { get set }<br>&gt;     <br>&gt;     func inputParameter(_: Parameter) -&gt; Parameter<br>&gt; }<br>&gt; ​<br>&gt; And it has worked well so far. <br>&gt; ​<br>&gt; The idea is to let the compiler generate these type-erased ‘versions’ on demand, using syntax like:<br>&gt; <br>&gt; Protocol.Opaque <br>&gt; ​<br>&gt; The rough procedure of creating a type-erased version for a given protocol is as follows:<br>&gt; <br>&gt; - Create a protocol with an underscore prefixed to the name of the target protocol.<br>&gt; <br>&gt; - Expose all the non-ATD (self or associated type dependent) constructs as requirements (essentially just copying the declarations) <br>&gt; <br>&gt; - Expose all the ATD constructs as requirements with associated types replaced with “Any”, with an underscore prefixed to their name changing the return value of functions accepting ATD inputs to an optional version of the same type.  <br>&gt; <br>&gt; - Extend the target protocol with implementations of these type-erased ‘versions’ of ATD constructs. For variables, a computed property is provided which returns the target variable, and force casts newValue in the setter (if any) to the required ATD type. For functions, the parameters undergo an attempted cast to the required ATD types, and are then mapped over the original implementation. Functions without ATD parameters can return just Any, because there is no casting involved. <br>&gt; <br>&gt; - Initializers become static functions with prefixed underscores, returning an Optional&lt;Protocol.Opaque&gt;<br>&gt; <br>&gt; I admit that I don’t have a plan on how this should be implemented. My fear is that it require tremendous amounts of metadata, bloating the binary size, and so I have submitted this as an idea and not a proposal.<br>&gt; <br>&gt; I have created a gist (https://gist.github.com/vmanot/888afc3f26caf142cd21 &lt;https://gist.github.com/vmanot/888afc3f26caf142cd21&gt;) as a demonstration. <br>&gt; <br>&gt; This pattern has helped on innumerable occasions, and is used in my projects to allow some runtime tricks. It also helps me forward implementations in a way similar (behavior-wise) to “AnyGenerator” <br>&gt; <br>&gt; import Swift<br>&gt; <br>&gt; struct AnyGenerator&lt;Element&gt;<br>&gt; {<br>&gt;     var base: _GeneratorType<br>&gt;     <br>&gt;     init&lt;G: protocol&lt;_GeneratorType, GeneratorType&gt; where G.Element == Element&gt;(base: G)<br>&gt;     {<br>&gt;         self.base = base<br>&gt;     }<br>&gt;     <br>&gt;     mutating func next() -&gt; Element?<br>&gt;     {<br>&gt;         return (base._next() as! Optional&lt;Element&gt;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; AnyGenerator(base: [1, 2, 3].generate())<br>&gt; <br>&gt; (I have tested this with an actual_GeneratorType implementation, and it works)<br>&gt; <br>&gt; Please let me know what you think of this idea, and whether it is viable or not.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/6a892159/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Idea] Type erasure for protocols with Self or associated type requirements.</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 10:44 PM, Vatsal Manot via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; (This is my first time on swift-evolution / Mailman, I apologize for any formatting errors)<br>&gt; <br>&gt; As we know, the following fails:<br>&gt; ​<br>&gt; protocol _Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type { get }<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var _parameter: Any { get set }<br>&gt;     <br>&gt;     func _inputParameter(_: Any) -&gt; Any?<br>&gt; }<br>&gt; ​<br>&gt; Protocol.self<br>&gt; ​<br>&gt; with the error:<br>&gt; ​<br>&gt; protocol &#39;Protocol&#39; can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; ​<br>&gt; For quite some time, I have been using a particular workaround for this:<br>&gt; ​<br>&gt; protocol _Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type { get }<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var _parameter: Any { get set }<br>&gt;     <br>&gt;     func _inputParameter(_: Any) -&gt; Any?<br>&gt; }<br>&gt; ​<br>&gt; extension _Protocol where Self: Protocol<br>&gt; {<br>&gt;     static var _Parameter: Any.Type<br>&gt;     {<br>&gt;         return Parameter.self<br>&gt;     }<br>&gt;     <br>&gt;     var _parameter: Any<br>&gt;     {<br>&gt;         get<br>&gt;         {<br>&gt;             return parameter<br>&gt;         }<br>&gt;         <br>&gt;         set<br>&gt;         {<br>&gt;             parameter = newValue as! Parameter<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func _inputParameter(parameter: Any) -&gt; Any?<br>&gt;     {<br>&gt;         return (parameter as? Parameter).map(inputParameter)<br>&gt;     }<br>&gt; }<br>&gt; ​<br>&gt; protocol Protocol: _Protocol<br>&gt; {<br>&gt;     typealias Parameter<br>&gt;     <br>&gt;     var nonGenericVariable: Int { get }<br>&gt;     var parameter: Parameter { get set }<br>&gt;     <br>&gt;     func inputParameter(_: Parameter) -&gt; Parameter<br>&gt; }<br>&gt; ​<br>&gt; And it has worked well so far. <br>&gt; ​<br>&gt; The idea is to let the compiler generate these type-erased ‘versions’ on demand, using syntax like:<br>&gt; <br>&gt; Protocol.Opaque <br>&gt; ​<br>&gt; The rough procedure of creating a type-erased version for a given protocol is as follows:<br>&gt; <br>&gt; - Create a protocol with an underscore prefixed to the name of the target protocol.<br>&gt; <br>&gt; - Expose all the non-ATD (self or associated type dependent) constructs as requirements (essentially just copying the declarations) <br>&gt; <br>&gt; - Expose all the ATD constructs as requirements with associated types replaced with “Any”, with an underscore prefixed to their name changing the return value of functions accepting ATD inputs to an optional version of the same type.  <br>&gt; <br>&gt; - Extend the target protocol with implementations of these type-erased ‘versions’ of ATD constructs. For variables, a computed property is provided which returns the target variable, and force casts newValue in the setter (if any) to the required ATD type. For functions, the parameters undergo an attempted cast to the required ATD types, and are then mapped over the original implementation. Functions without ATD parameters can return just Any, because there is no casting involved. <br>&gt; <br>&gt; - Initializers become static functions with prefixed underscores, returning an Optional&lt;Protocol.Opaque&gt;<br>&gt; <br>&gt; I admit that I don’t have a plan on how this should be implemented. My fear is that it require tremendous amounts of metadata, bloating the binary size, and so I have submitted this as an idea and not a proposal.<br></p><p>We’re already slowly progressing towards an implementation design which will allow us to simply lift some of these restrictions.  The work will be done in the Swift 3 time-frame; whether we actually lift the restrictions on existential types significantly in this release is a lot less certain, but there’s not much point in having the discussion right now, I think.<br></p><p>John.<br></p><p>&gt; <br>&gt; I have created a gist (https://gist.github.com/vmanot/888afc3f26caf142cd21 &lt;https://gist.github.com/vmanot/888afc3f26caf142cd21&gt;) as a demonstration. <br>&gt; <br>&gt; This pattern has helped on innumerable occasions, and is used in my projects to allow some runtime tricks. It also helps me forward implementations in a way similar (behavior-wise) to “AnyGenerator” <br>&gt; <br>&gt; import Swift<br>&gt; <br>&gt; struct AnyGenerator&lt;Element&gt;<br>&gt; {<br>&gt;     var base: _GeneratorType<br>&gt;     <br>&gt;     init&lt;G: protocol&lt;_GeneratorType, GeneratorType&gt; where G.Element == Element&gt;(base: G)<br>&gt;     {<br>&gt;         self.base = base<br>&gt;     }<br>&gt;     <br>&gt;     mutating func next() -&gt; Element?<br>&gt;     {<br>&gt;         return (base._next() as! Optional&lt;Element&gt;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; AnyGenerator(base: [1, 2, 3].generate())<br>&gt; <br>&gt; (I have tested this with an actual_GeneratorType implementation, and it works)<br>&gt; <br>&gt; Please let me know what you think of this idea, and whether it is viable or not.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/f5577ff9/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
