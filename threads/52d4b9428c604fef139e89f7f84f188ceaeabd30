<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt; right way.<br>&gt;<br>&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt; type-safe.  <br></p><p>There are two choices when you erase static type relationships:<br></p><p>1. Acheive type-safety by trapping at runtime<br></p><p>  FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br></p><p>2. Don&#39;t expose protocol requirements that involve these relationships,<br>   which would prevent the code above from compiling and prevent<br>   FloatingPoint from conforming to itself.<br></p><p>&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt; think they want when they don’t fully understand what is happening...<br></p><p>I don&#39;t know what you mean here.  I think generalized existentials will<br>be nice to have, but I think most people will want them to do something<br>they can&#39;t possibly do.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt; right way.<br>&gt;&gt; <br>&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; type-safe.  <br>&gt; <br>&gt; There are two choices when you erase static type relationships:<br>&gt; <br>&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; <br>&gt;  FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt; <br>&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;   which would prevent the code above from compiling and prevent<br>&gt;   FloatingPoint from conforming to itself.<br>&gt; <br>&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt; <br>&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt; be nice to have, but I think most people will want them to do something<br>&gt; they can&#39;t possibly do.<br></p><p>Exactly.  What I meant is that people think they want that expression to compile because they don’t understand that the only thing it can do is trap.  I said “hypothetical” because producing a compile time error rather than a runtime trap is the only sane thing to do.  Your comment surprised me because I can’t imagine we would move forward in Swift with the approach of trapping.<br></p><p>The low hanging fruit in the “protocols whose existentials conform to the protocol” space is simple protocols that can already by existentials today (like CustomStringConvertible).  I don’t know enough about Swift’s implementation to comment on how complex it is there, but there aren’t any theoretical problems with making their existentials conform. <br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  7, 2016 at 07:00:00pm</p></header><div class="content"><p>on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt; type-safe.  <br>&gt;&gt; <br>&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; <br>&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; <br>&gt;&gt;  FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; <br>&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;   which would prevent the code above from compiling and prevent<br>&gt;&gt;   FloatingPoint from conforming to itself.<br>&gt;&gt; <br>&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt; they can&#39;t possibly do.<br>&gt;<br>&gt; Exactly.  What I meant is that people think they want that expression<br>&gt; to compile because they don’t understand that the only thing it can do<br>&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt; with the approach of trapping.<br></p><p>I would very much like to be able to create instances of “Collection<br>where Element == Int” so we can throw away the wrappers in the stdlib.<br>That will require some type mismatches to be caught at runtime via<br>trapping.<br></p><p>&gt;<br>&gt; The low hanging fruit in the “protocols whose existentials conform to<br>&gt; the protocol” space is simple protocols that can already by<br>&gt; existentials today (like CustomStringConvertible).  I don’t know<br>&gt; enough about Swift’s implementation to comment on how complex it is<br>&gt; there, but there aren’t any theoretical problems with making their<br>&gt; existentials conform.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;  which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;  FloatingPoint from conforming to itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; <br>&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; with the approach of trapping.<br>&gt; <br>&gt; I would very much like to be able to create instances of “Collection<br>&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt; That will require some type mismatches to be caught at runtime via<br>&gt; trapping.<br></p><p>For invalid index because the existential accepts a type erased index?<br></p><p>How do you decide where to draw the line here?  It feels like a very slippery slope for a language where safety is a stated priority to start adopting a strategy of runtime trapping for something as fundamental as how you expose members on an existential.  <br></p><p>IMO you should *have* to introduce unsafe behavior like that manually.  Collection indices are already something that isn’t fully statically safe so I understand why you might want to allow this.  But I don’t think having the language&#39;s existentials do this automatically is the right approach.  Maybe there is another approach that could be used in targeted use cases where the less safe behavior makes sense and is carefully designed.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; The low hanging fruit in the “protocols whose existentials conform to<br>&gt;&gt; the protocol” space is simple protocols that can already by<br>&gt;&gt; existentials today (like CustomStringConvertible).  I don’t know<br>&gt;&gt; enough about Swift’s implementation to comment on how complex it is<br>&gt;&gt; there, but there aren’t any theoretical problems with making their<br>&gt;&gt; existentials conform.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/2c6bc6c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 9:27 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;  which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;  FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; <br>&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; trapping.<br></p><p>BTW, Austin’s generalized existentials proposal has several examples of how existential collections would work: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#protocol-apis-and-associated-types &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#protocol-apis-and-associated-types&gt;.  <br></p><p>In what ways do you find this functionality insufficient?  What operations do you want to be able to do that this doesn’t support (and can only be supported in an unsafe way that must trap for invalid input)?<br></p><p>&gt; <br>&gt; For invalid index because the existential accepts a type erased index?<br>&gt; <br>&gt; How do you decide where to draw the line here?  It feels like a very slippery slope for a language where safety is a stated priority to start adopting a strategy of runtime trapping for something as fundamental as how you expose members on an existential.  <br>&gt; <br>&gt; IMO you should *have* to introduce unsafe behavior like that manually.  Collection indices are already something that isn’t fully statically safe so I understand why you might want to allow this.  But I don’t think having the language&#39;s existentials do this automatically is the right approach.  Maybe there is another approach that could be used in targeted use cases where the less safe behavior makes sense and is carefully designed.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The low hanging fruit in the “protocols whose existentials conform to<br>&gt;&gt;&gt; the protocol” space is simple protocols that can already by<br>&gt;&gt;&gt; existentials today (like CustomStringConvertible).  I don’t know<br>&gt;&gt;&gt; enough about Swift’s implementation to comment on how complex it is<br>&gt;&gt;&gt; there, but there aren’t any theoretical problems with making their<br>&gt;&gt;&gt; existentials conform.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/c502530e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 11:00:00am</p></header><div class="content"><p>on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;  which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;  FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; <br>&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; trapping.<br>&gt;<br>&gt; For invalid index because the existential accepts a type erased index?<br></p><p>Exactly.<br></p><p>&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt; slippery slope for a language where safety is a stated priority to<br>&gt; start adopting a strategy of runtime trapping for something as<br>&gt; fundamental as how you expose members on an existential.<br></p><p>If you don&#39;t do this, the alternative is that “Collection where Element<br>== Int” does not conform to Collection.  That&#39;s weird and not very<br>useful.  You could expose all the methods that were on protocol<br>extensions of Collection on this existential, unless they used<br>associated types other than the element type.  But you couldn&#39;t pass the<br>existential to a generic function like<br></p><p>   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br></p><p>&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br></p><p>  Collection where Element == Int &amp; Index == *<br></p><p>?<br></p><p>&gt; Collection indices are already something that isn’t fully statically<br>&gt; safe so I understand why you might want to allow this.  <br></p><p>By the same measure, so are Ints :-)<br></p><p>The fact that a type&#39;s methods have preconditions does *not* make it<br>“statically unsafe.”<br></p><p>&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; automatically is the right approach.  Maybe there is another approach<br>&gt; that could be used in targeted use cases where the less safe behavior<br>&gt; makes sense and is carefully designed.<br></p><p>Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>little point in generalizing existentials if the result isn&#39;t very useful.<br>The way to find out is to take a look at the examples we currently have<br>of protocols with associated types or Self requirements and consider<br>what you&#39;d be able to do with their existentials if type relationships<br>couldn&#39;t be erased.  <br></p><p>We have known use-cases, currently emulated in the standard library, for<br>existentials with erased type relationships.  *If* these represent the<br>predominant use cases for something like generalized existentials, it<br>seems to me that the language feature should support that.  Note: I have<br>not seen anyone build an emulation of the other kind of generalized<br>existential.  My theory: there&#39;s a good reason for that :-).<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt; trapping.<br>&gt;&gt; <br>&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt; <br>&gt; Exactly.<br>&gt; <br>&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; fundamental as how you expose members on an existential.<br>&gt; <br>&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; useful.  You could expose all the methods that were on protocol<br>&gt; extensions of Collection on this existential, unless they used<br>&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt; existential to a generic function like<br>&gt; <br>&gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br></p><p>I don’t understand. Why couldn’t an existential be passed to that function?<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt; <br>&gt;  Collection where Element == Int &amp; Index == *<br>&gt; <br>&gt; ?<br>&gt; <br>&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt; <br>&gt; By the same measure, so are Ints :-)<br>&gt; <br>&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; “statically unsafe.”<br>&gt; <br>&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; makes sense and is carefully designed.<br>&gt; <br>&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt; The way to find out is to take a look at the examples we currently have<br>&gt; of protocols with associated types or Self requirements and consider<br>&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; couldn&#39;t be erased.  <br>&gt; <br>&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt; existentials with erased type relationships.  *If* these represent the<br>&gt; predominant use cases for something like generalized existentials, it<br>&gt; seems to me that the language feature should support that.  Note: I have<br>&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 12:00:00pm</p></header><div class="content"><p>It&#39;s not possible, even with Swift&#39;s current implementation of<br>existentials. A protocol type P isn&#39;t considered to conform to itself, thus<br>the following is rejected:<br></p><p>let a : MyProtocol = // ...<br>func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>  // ....<br>}<br>myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>MyProtocol&quot;<br></p><p>Changing how this works is probably worth a proposal by itself.<br></p><p>Austin<br></p><p><br>On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;<br>&gt; http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt; appear to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt; relationships,<br>&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt; happening...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials<br>&gt; will<br>&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt; something<br>&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt; &gt;&gt;&gt; trapping.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt; &gt;<br>&gt; &gt; Exactly.<br>&gt; &gt;<br>&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt; &gt;<br>&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt; &gt; existential to a generic function like<br>&gt; &gt;<br>&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;<br>&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt; &gt;<br>&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt; &gt;<br>&gt; &gt; ?<br>&gt; &gt;<br>&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt; &gt;<br>&gt; &gt; By the same measure, so are Ints :-)<br>&gt; &gt;<br>&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; &gt; “statically unsafe.”<br>&gt; &gt;<br>&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt; &gt;<br>&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt; &gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt; useful.<br>&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; &gt; couldn&#39;t be erased.<br>&gt; &gt;<br>&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/d49e236f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>Ah, thanks, I forgot! <br>I still consider this a bug, though (will have to read up again what the reasons are for that behavior).<br></p><p>-Thorsten<br></p><p><br>&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; <br>&gt; It&#39;s not possible, even with Swift&#39;s current implementation of existentials. A protocol type P isn&#39;t considered to conform to itself, thus the following is rejected:<br>&gt; <br>&gt; let a : MyProtocol = // ...<br>&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;   // ....<br>&gt; }<br>&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt; <br>&gt; Changing how this works is probably worth a proposal by itself.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt; &gt;&gt;&gt; trapping.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt; &gt;<br>&gt; &gt; Exactly.<br>&gt; &gt;<br>&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt; &gt;<br>&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt; &gt; existential to a generic function like<br>&gt; &gt;<br>&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt; <br>&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt;<br>&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt; &gt;<br>&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt; &gt;<br>&gt; &gt; ?<br>&gt; &gt;<br>&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt; &gt;<br>&gt; &gt; By the same measure, so are Ints :-)<br>&gt; &gt;<br>&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; &gt; “statically unsafe.”<br>&gt; &gt;<br>&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt; &gt;<br>&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt; &gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; &gt; couldn&#39;t be erased.<br>&gt; &gt;<br>&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/e4de4084/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s not possible, even with Swift&#39;s current implementation of existentials. A protocol type P isn&#39;t considered to conform to itself, thus the following is rejected:<br></p><p>The rules are not that simple, I seem to recall reading in sourcecode that there are criteria that decide if that is true or not. And by default the variable conform_to_self is even TRUE<br></p><p><br>&gt; <br>&gt; let a : MyProtocol = // ...<br>&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;   // ....<br>&gt; }<br>&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt; <br>&gt; Changing how this works is probably worth a proposal by itself.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Exactly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; &gt; existential to a generic function like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; <br>&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt; “statically unsafe.”<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; &gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; &gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/bc6907c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 11:00:00pm</p></header><div class="content"><p>According to that code (which is in Decl.cpp), AnyObject (and Any) conforms to itself; no non- at objc protocol is allowed to conform to itself. An @objc protocol may or may not conform to itself, depending on some other conditions.<br></p><p>&gt; On Jun 8, 2016, at 9:19 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 8, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of existentials. A protocol type P isn&#39;t considered to conform to itself, thus the following is rejected:<br>&gt; <br>&gt; The rules are not that simple, I seem to recall reading in sourcecode that there are criteria that decide if that is true or not. And by default the variable conform_to_self is even TRUE<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt;   // ....<br>&gt;&gt; }<br>&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt;&gt; <br>&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Exactly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; &gt; existential to a generic function like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; <br>&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt; “statically unsafe.”<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; &gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; &gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/082d2951/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 8:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; According to that code (which is in Decl.cpp), AnyObject (and Any) conforms to itself; no non- at objc protocol is allowed to conform to itself. An @objc protocol may or may not conform to itself, depending on some other conditions.<br></p><p>Like I said... more sub-cases than your original statement, right?!<br></p><p>&gt; <br>&gt;&gt; On Jun 8, 2016, at 9:19 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of existentials. A protocol type P isn&#39;t considered to conform to itself, thus the following is rejected:<br>&gt;&gt; <br>&gt;&gt; The rules are not that simple, I seem to recall reading in sourcecode that there are criteria that decide if that is true or not. And by default the variable conform_to_self is even TRUE<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt;&gt;   // ....<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Exactly.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt;&gt;&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt; &gt; existential to a generic function like<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; ?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt; &gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt;&gt;&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt;&gt;&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt; &gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt; &gt; couldn&#39;t be erased.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/fc517ed6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>Yes, you were correct. Thanks for spotting that and apologies for not<br>acknowledging you sooner.<br></p><p>Austin<br></p><p>On Thu, Jun 9, 2016 at 1:13 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jun 9, 2016, at 8:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; According to that code (which is in Decl.cpp), AnyObject (and Any)<br>&gt; conforms to itself; no non- at objc protocol is allowed to conform to<br>&gt; itself. An @objc protocol may or may not conform to itself, depending on<br>&gt; some other conditions.<br>&gt;<br>&gt;<br>&gt; Like I said... more sub-cases than your original statement, right?!<br>&gt;<br>&gt;<br>&gt; On Jun 8, 2016, at 9:19 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jun 8, 2016, at 9:43 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt; existentials. A protocol type P isn&#39;t considered to conform to itself, thus<br>&gt; the following is rejected:<br>&gt;<br>&gt;<br>&gt; The rules are not that simple, I seem to recall reading in sourcecode that<br>&gt; there are criteria that decide if that is true or not. And by default the<br>&gt; variable conform_to_self is even TRUE<br>&gt;<br>&gt;<br>&gt;<br>&gt; let a : MyProtocol = // ...<br>&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;   // ....<br>&gt; }<br>&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt; MyProtocol&quot;<br>&gt;<br>&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt;&gt; appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt;&gt; relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt;&gt; happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials<br>&gt;&gt; will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt;&gt; something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can<br>&gt;&gt; do<br>&gt;&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time<br>&gt;&gt; error<br>&gt;&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt;&gt; comment<br>&gt;&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Exactly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; &gt; existential to a generic function like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;<br>&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt;&gt; function?<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt; “statically unsafe.”<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; &gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt;&gt; useful.<br>&gt;&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; &gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/a4fdf153/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt; trapping.<br>&gt;&gt; <br>&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt; <br>&gt; Exactly.<br>&gt; <br>&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; fundamental as how you expose members on an existential.<br>&gt; <br>&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt; == Int” does not conform to Collection.  <br></p><p>This isn’t directly related to having self or associated type requirements.  It is true of all existentials.  If that changes for simple existentials and generalized existentials expose all members (as in the latest draft of the proposal) maybe it will be possible for all existentials to conform to their protocol.  <br></p><p>&gt; That&#39;s weird and not very<br>&gt; useful.  You could expose all the methods that were on protocol<br>&gt; extensions of Collection on this existential, unless they used<br>&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt; existential to a generic function like<br>&gt; <br>&gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt; <br>&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt; <br>&gt;  Collection where Element == Int &amp; Index == *<br>&gt; <br>&gt; ?<br></p><p>I didn’t mean directly through the type of the existential.<br></p><p>One obvious mechanism for introducing unsafe behavior is to write manual type erasure wrappers like we do today.  <br></p><p>Another possibility would be to allow extending the existential type (not the protocol).  This would allow you to write overloads on the Collection existential that takes some kind of type erased index if that is what you want and either trap if you receive an invalid index or better (IMO) return an `Element?`.  I’m not sure how extensions on existentials might be implemented, but this is an example of the kind of operation you might want available on it that you wouldn’t want available on all Collection types.<br></p><p>&gt; <br>&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt; <br>&gt; By the same measure, so are Ints :-)<br>&gt; <br>&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; “statically unsafe.”<br></p><p>That depends on what you mean by safe.  Sure, those methods aren’t going corrupt memory, but they *are* going to explicitly and intentionally crash for some inputs.  That doesn’t qualify as “fully safe” IMO.<br></p><p>&gt; <br>&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; makes sense and is carefully designed.<br>&gt; <br>&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br></p><p>Usefulness depends on your perspective.  I have run into several scenarios where they would be very useful without needing to be prone to crashes when used incorrectly.  One obvious basic use case is storing things in a heterogenous collection where you bind .<br></p><p>&gt; The way to find out is to take a look at the examples we currently have<br>&gt; of protocols with associated types or Self requirements and consider<br>&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; couldn&#39;t be erased.  <br>&gt; <br>&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt; existentials with erased type relationships.  *If* these represent the<br>&gt; predominant use cases for something like generalized existentials, it<br>&gt; seems to me that the language feature should support that.  Note: I have<br>&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; existential.  My theory: there&#39;s a good reason for that :-).<br></p><p>AFAIK (and I could be wrong) the only rules in the language that require the compiler to synthesize a trap except using a nil IUO, `!` on a nil Optional, and an invalid `as` cast .  These are all syntactically explicit unsafe / dangerous operations.  All other traps are in the standard library (array index, overflow, etc).  Most important about all of these cases is that they have received direct human consideration.  <br></p><p>Introducing a language (not library) mechanism that exposes members on generalized existentials in a way that relies on runtime traps for type safety feels to me like a pretty dramatic turn agains the stated priority of safety.  It will mean you must understand exactly what is going on and be extremely careful to use generalized existentials without causing crashes.  This will either make Swift code much more crashy or will scare people away from using generalized existentials (and maybe both).  Neither of those outcomes is good.  <br></p><p>Collection indices are a somewhat special case as there is already a strong precondition that people are familiar with because it would be too costly to performance and arguably too annoying to deal with an Optional result in every array lookup.  IMO that is why the library is able to get away with it in the current type erased AnyCollection.  But this is not a good model for exposing any members on an existential that do not already have a strong precondition that causes a trap when violated.<br></p><p>I think a big reason why you maybe haven’t seen a lot of examples of people writing type erased “existentials&quot; is because it is a huge pain in the neck to write this stuff manually today.  People may be designing around the need for them.  I haven’t seen a huge sampling of type erased “existentials&quot; other people are writing but I haven’t written any that introduce a trap like this.  The only traps are in the “abstract&quot; base class whose methods will never be called (and wouldn’t even be implemented if they could be marked abstract).<br></p><p>What specific things do you think we need to be able to do that rely on the compiler synthesizing a trap in the way it exposes the members of the existential?  <br></p><p>Here are a few examples from Austin’s proposal that safely use existential collections.  I don’t understand why you think this approach is insufficient.  Maybe you could supply a concrete example of a use case that can’t be written with the mechanism in Austin’s proposal.<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;<br></p><p>let a : Any&lt;Collection&gt;<br></p><p>// A variable whose type is the Index associated type of the underlying<br>// concrete type of &#39;a&#39;.<br>let theIndex : a.Index = ...<br></p><p>// A variable whose type is the Element associated type of the underlying<br>// concrete type of &#39;a&#39;.<br>let theElement : a.Element = ...<br></p><p>// Given a mutable collection, swap its first and last items.<br>// Not a generic function. <br>func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>    // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>    guard let firstIndex = collection.startIndex,<br>        lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>            print(&quot;Nothing to do&quot;)<br>            return<br>    }<br></p><p>    // oldFirstItem has type &quot;collection.Element&quot;<br>    let oldFirstItem = collection[firstIndex]<br></p><p>    collection[firstIndex] = collection[lastIndex]<br>    collection[lastIndex] = oldFirstItem<br>}<br></p><p>var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br></p><p>let input = &quot;West Meoley&quot;<br></p><p>// Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>// A fully constrained anonymous associated type is synonymous with the concrete<br>// type it&#39;s forced to take on, and the two are interchangeable.<br>// However, &#39;as&#39; casting is still available if desired.<br>let anonymousInput = input as a.Element<br></p><p>a[a.startIndex] = anonymousInput<br></p><p>// as mentioned, this also works:<br>a[a.startIndex] = input<br></p><p>// If the collection allows it, set the first element in the collection to a given string.<br>func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>    if let element = string as? collection.Element {<br>        // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>        collection[collection.startIndex] = element<br>    }<br>}<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/536e4e22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 07:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; <br>&gt;&gt; Exactly.<br>&gt;&gt; <br>&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; <br>&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; == Int” does not conform to Collection.  <br>&gt;<br>&gt; This isn’t directly related to having self or associated type<br>&gt; requirements.  It is true of all existentials.  <br></p><p>That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>about here would make it impossible for some to do that.<br></p><p>&gt; If that changes for simple existentials and generalized existentials<br>&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt; will be possible for all existentials to conform to their protocol.<br></p><p>Not without introducing runtime traps.  See my “subscript function”<br>example.<br></p><p>&gt;<br>&gt;&gt; That&#39;s weird and not very<br>&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; existential to a generic function like<br>&gt;&gt; <br>&gt;&gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; <br>&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; <br>&gt;&gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;<br>&gt; I didn’t mean directly through the type of the existential.<br></p><p>My question is, why not?  That is still explicit.<br></p><p>&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt; manual type erasure wrappers like we do today.<br>&gt;<br>&gt; Another possibility would be to allow extending the existential type<br>&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt; Collection existential that takes some kind of type erased index if<br>&gt; that is what you want and either trap if you receive an invalid index<br>&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt; existentials might be implemented, but this is an example of the kind<br>&gt; of operation you might want available on it that you wouldn’t want<br>&gt; available on all Collection types.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt; <br>&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt; <br>&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; “statically unsafe.”<br>&gt;<br>&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt; safe” IMO.<br></p><p>Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>array indexes and integers are.  When you violate a precondition, it<br>traps.<br></p><p>The user doesn&#39;t do anything “manual” to introduce that trapping<br>behavior for integers.  Preconditions are a natural part of most types.<br></p><p>&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; <br>&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;<br>&gt; Usefulness depends on your perspective.  <br></p><p>Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br></p><p>&gt; I have run into several scenarios where they would be very useful<br>&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt; where you bind .<br></p><p>bind what?<br></p><p>&gt;<br>&gt;<br>&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt; <br>&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;<br>&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt; important about all of these cases is that they have received direct<br>&gt; human consideration.<br></p><p>There is no distinction in the user model between what might be<br>synthesized by the language and what appears on standard library types.<br></p><p>&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt; generalized existentials in a way that relies on runtime traps for<br>&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt; going on and be extremely careful to use generalized existentials<br>&gt; without causing crashes.  This will either make Swift code much more<br>&gt; crashy or will scare people away from using generalized existentials<br>&gt; (and maybe both).  <br></p><p>I don&#39;t accept either of those statements without seeing some analysis<br>of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>index type with a collection is very, very low.  I&#39;m less certain of<br>what happens with Self requirements in real cases.<br></p><p>&gt; Neither of those outcomes is good.<br>&gt;<br>&gt; Collection indices are a somewhat special case as there is already a<br>&gt; strong precondition that people are familiar with because it would be<br>&gt; too costly to performance and arguably too annoying to deal with an<br>&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt; able to get away with it in the current type erased AnyCollection.<br>&gt; But this is not a good model for exposing any members on an<br>&gt; existential that do not already have a strong precondition that causes<br>&gt; a trap when violated.<br>&gt;<br>&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt; in the neck to write this stuff manually today.  People may be<br>&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt; written any that introduce a trap like this.  The only traps are in<br>&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;<br>&gt; What specific things do you think we need to be able to do that rely<br>&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt; of the existential?<br></p><p>I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>well enough to make a determination.<br></p><p>&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt; existential collections.  I don’t understand why you think this<br>&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt; proposal.<br>&gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;<br>&gt;<br>&gt; let a : Any&lt;Collection&gt;<br>&gt;<br>&gt; // A variable whose type is the Index associated type of the underlying<br>&gt; // concrete type of &#39;a&#39;.<br>&gt; let theIndex : a.Index = ...<br>&gt;<br>&gt; // A variable whose type is the Element associated type of the underlying<br>&gt; // concrete type of &#39;a&#39;.<br>&gt; let theElement : a.Element = ...<br>&gt;<br>&gt; // Given a mutable collection, swap its first and last items.<br>&gt; // Not a generic function. <br>&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;     // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;     guard let firstIndex = collection.startIndex,<br>&gt;         lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;             print(&quot;Nothing to do&quot;)<br>&gt;             return<br>&gt;     }<br>&gt;<br>&gt;     // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;     let oldFirstItem = collection[firstIndex]<br>&gt;<br>&gt;     collection[firstIndex] = collection[lastIndex]<br>&gt;     collection[lastIndex] = oldFirstItem<br>&gt; }<br>&gt;<br>&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;<br>&gt; let input = &quot;West Meoley&quot;<br>&gt;<br>&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt; let anonymousInput = input as a.Element<br>&gt;<br>&gt; a[a.startIndex] = anonymousInput<br>&gt;<br>&gt; // as mentioned, this also works:<br>&gt; a[a.startIndex] = input<br>&gt;<br>&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;     if let element = string as? collection.Element {<br>&gt;         // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;         collection[collection.startIndex] = element<br>&gt;     }<br>&gt; }<br></p><p>Neither of these look like they actually make *use* of the fact that<br>there&#39;s type erasure involved (and therefore should probably be written<br>as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>purposes of this discussion, arise when you have multiple instances of<br>the same existential type that wrap different concrete types.<br></p><p>Another problem I see: in this new world, what is the model for choosing<br>whether to write a function as a protocol extension/generic, or as a<br>regular function taking existential parameters?  Given that either of<br>the above could have been written either way, we need to be able to<br>answer that question.  When existentials don&#39;t conform to their<br>protocols, it seems to me that the most general thing to do is use<br>existentials whenever you can, and only resort to using generics when<br>forced by the type system.  This does not seem like a particularly good<br>programming model to me, but I might be convinced otherwise.<br></p><p>Anyway, my overall point is that this all seems like something we *can*<br>do and that nicely fills gaps in the type system, but not necessarily<br>something we *should* do until we better understand what it&#39;s actually<br>*for* and how it affects the programming model.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt; <br>&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt; requirements.  It is true of all existentials.  <br>&gt; <br>&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt; about here would make it impossible for some to do that.<br></p><p>If it is just an implementation limitation I am happy to hear that.<br></p><p>&gt; <br>&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt; <br>&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt; example.<br></p><p><br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt; <br>&gt; My question is, why not?  That is still explicit.<br></p><p>It’s not explicit in the sense that nobody wrote `fatalError` or similar in their code.  It’s too easy to write something like that without realizing that it introduces the possibility of a crash.  If we adopt syntax like that to introduce an existential that introduces traps we should at least require members that can be trap to be invoked using a `!` suffix or something like that to make it clear to users that a trap will happen if they are not extremely careful when using that member.  <br></p><p>More generally though, I don’t want the rules of the language to be written in a way that causes the compiler to synthesize traps in such a general way.<br></p><p>The existential should not introduce a precondition that isn’t already present in the semantics of the protocol itself.  If the semantics of the protocol do not place preconditions on arguments beyond their type (such as “must be a valid index into this specific instance”) the compiler should not allow the existential to conform if a trap is required in some circumstances.  That is a new precondition and therefore the existential does not actually fulfill the requirements of the protocol.<br></p><p>I could *maybe* live with a solution where protocol requirements are marked as trapping, etc depending on the specific argument received at runtime.  This is a total straw man syntax, but maybe `IndexableBase` would declare the subscript `@trapping` (probably something different but I hope this communicates the idea).  This alerts users to the fact that they need to be extra careful - not any value of `Self.Index` is valid and you can get a crash if you’re not careful.  <br></p><p>Having this semantic explicit in the definition of the protocol opens the door to maybe considering an existential synthesized by the compiler that traps because it doesn’t introduce a new precondition that wasn’t already present in the protocol.  <br></p><p>I would want to give consideration to specific details of a proposal along these lines before deciding how I feel about it, but I have a more open mind to this approach than introducing traps not present in the preconditions of the protocol.<br></p><p>/// You can subscript a collection with any valid index other than the<br>/// collection&#39;s end index. The end index refers to the position one past<br>/// the last element of a collection, so it doesn&#39;t correspond with an<br>/// element.<br>///<br>/// - Parameter position: The position of the element to access. `position`<br>///   must be a valid index of the collection that is not equal to the<br>///   `endIndex` property.<br>@trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br></p><p>&gt; <br>&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt; <br>&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt; available on all Collection types.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; <br>&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt; safe” IMO.<br>&gt; <br>&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt; traps.<br></p><p>I am happy to use any word you like here.<br></p><p>Can you clarify what you mean by the word safe in Swift?  It doesn’t appear to be limited to memory safety in the public about page https://swift.org/about/ &lt;https://swift.org/about/&gt;:<br></p><p>Safe. The most obvious way to write code should also behave in a safe manner. Undefined behavior is the enemy of safety, and developer mistakes should be caught before software is in production. Opting for safety sometimes means Swift will feel strict, but we believe that clarity saves time in the long run.<br></p><p>Safety<br></p><p>Swift was designed from the outset to be safer than C-based languages, and eliminates entire classes of unsafe code. Variables are always initialized before use, arrays and integers are checked for overflow, and memory is managed automatically. Syntax is tuned to make it easy to define your intent — for example, simple three-character keywords define a variable (var) or constant (let).<br></p><p>Another safety feature is that by default Swift objects can never be nil, and trying to make or use a nil object will results in a compile-time error. This makes writing code much cleaner and safer, and prevents a common cause of runtime crashes. However, there are cases where nil is appropriate, and for these situations Swift has an innovative feature known as optionals. An optional may contain nil, but Swift syntax forces you to safely deal with it using ? to indicate to the compiler you understand the behavior and will handle it safely.<br></p><p>This positioning statement makes it appear as if preventing common causes of crashes falls within the meaning of safe that Swift is using.  Having existentials introduce new preconditions and traps when they are not met does not seem aligned with that goal IMO.<br></p><p>&gt; <br>&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt; behavior for integers.  Preconditions are a natural part of most types.<br></p><p>The user doesn’t, but isn’t the overflow trap implemented in the standard library?  Regardless, this is a specific case that has been given explicit design attention by humans.  The precondition is designed, not introduced by compiler rules that haven’t considered the specific case in question.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; <br>&gt;&gt; Usefulness depends on your perspective.  <br>&gt; <br>&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br></p><p>Agree.  We can consider those in depth when the time comes to ramp up discussion of Austin’s proposal.<br></p><p>&gt; <br>&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt; where you bind .<br>&gt; <br>&gt; bind what?<br></p><p>Sorry, I must have gotten distracted and not finished that paragraph.  I meant to say bind the associated types that are necessary for your use case.  Sometimes you bind *all* of the associated types to concrete types and the protocol has no `Self` requirements.  In that case there is no trouble at all in conforming the type-erased “existential&quot; to the protocol itself.  Austin’s proposal would eliminate the need to manually write these “existentials” manually.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; <br>&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt; human consideration.<br>&gt; <br>&gt; There is no distinction in the user model between what might be<br>&gt; synthesized by the language and what appears on standard library types.<br></p><p>Maybe I shouldn’t have made that distinction.  <br></p><p>The point I am trying to emphasize is that each of these are special cases that have received direct human consideration.  The potential for a trap is not introduced by language rules that apply to user-defined constructs in without consideration of the specific details of that construct.<br></p><p>&gt; <br>&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt; (and maybe both).  <br>&gt; <br>&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt; what happens with Self requirements in real cases.<br></p><p>But again, I believe this is an exceptional case as the precondition is explicitly stated in the semantics of the protocol.<br></p><p>IMO the burden of proof should be on the side that proposes a mechanism to introduce traps, not the side that proposes avoiding them.<br></p><p>&gt; <br>&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt; <br>&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt; a trap when violated.<br>&gt;&gt; <br>&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt; <br>&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt; of the existential?<br>&gt; <br>&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt; well enough to make a determination.<br></p><p>That’s fair.  I agree that use cases should be carefully considered.  <br></p><p>&gt; <br>&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt; proposal.<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt; <br>&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt; <br>&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt; <br>&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt; // Not a generic function. <br>&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;    // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;    guard let firstIndex = collection.startIndex,<br>&gt;&gt;        lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;            print(&quot;Nothing to do&quot;)<br>&gt;&gt;            return<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;    let oldFirstItem = collection[firstIndex]<br>&gt;&gt; <br>&gt;&gt;    collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;    collection[lastIndex] = oldFirstItem<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt; <br>&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt; <br>&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt; <br>&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt; <br>&gt;&gt; // as mentioned, this also works:<br>&gt;&gt; a[a.startIndex] = input<br>&gt;&gt; <br>&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;    if let element = string as? collection.Element {<br>&gt;&gt;        // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;        collection[collection.startIndex] = element<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; Neither of these look like they actually make *use* of the fact that<br>&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt; the same existential type that wrap different concrete types.<br></p><p>One use case I have found is to work around the lack of higher-kinder types.  If you have a protocol where specific implementations will return different types, but all conform to a second protocol you can define the protocol in terms of a generic type-erased wrapper which conforms to the second protocol and accepts type arguments that match the associated types (thus binding the associated types to concrete types).  I have found this to be a useful technique (granted it is a workaround and I’m not sure how useful it would continue to be if Swift eventually gets higher-kinder types).<br></p><p>&gt; <br>&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt; regular function taking existential parameters?  Given that either of<br>&gt; the above could have been written either way, we need to be able to<br>&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt; protocols, it seems to me that the most general thing to do is use<br>&gt; existentials whenever you can, and only resort to using generics when<br>&gt; forced by the type system.  This does not seem like a particularly good<br>&gt; programming model to me, but I might be convinced otherwise.<br></p><p>That doesn’t seem like a particularly good programming model to me either. <br></p><p>The rule of thumb I am operating with for protocols with Self or associated type requirements is to prefer generics and use type erasure / existentials when that isn’t possible.  For example, when heterogeneity is required or when you can’t form the necessary type in a protocol requirement (as in the preceding example).  <br></p><p>This heuristic has been working out pretty well for me thus far.  The primary impact of introducing a language mechanism for generalized existentials in my code would be to eliminate a lot of manual type erasing boilerplate. <br></p><p>&gt; <br>&gt; Anyway, my overall point is that this all seems like something we *can*<br>&gt; do and that nicely fills gaps in the type system, but not necessarily<br>&gt; something we *should* do until we better understand what it&#39;s actually<br>&gt; *for* and how it affects the programming model.<br></p><p>That’s a very fair position to take.  :)<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/cd8f6f8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt; <br>&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt; about here would make it impossible for some to do that.<br>&gt;<br>&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt; <br>&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt; example.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt; <br>&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;<br>&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt; similar in their code.  It’s too easy to write something like that<br>&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt; traps we should at least require members that can be trap to be<br>&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt; users that a trap will happen if they are not extremely careful when<br>&gt; using that member.<br>&gt;<br>&gt; More generally though, I don’t want the rules of the language to be<br>&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt; a general way.<br>&gt;<br>&gt; The existential should not introduce a precondition that isn’t already<br>&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt; (such as “must be a valid index into this specific instance”) the<br>&gt; compiler should not allow the existential to conform if a trap is<br>&gt; required in some circumstances.  That is a new precondition and<br>&gt; therefore the existential does not actually fulfill the requirements<br>&gt; of the protocol.<br>&gt;<br>&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt; marked as trapping, etc depending on the specific argument received at<br>&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt; would declare the subscript `@trapping` (probably something different<br>&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt; valid and you can get a crash if you’re not careful.<br>&gt;<br>&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt; the door to maybe considering an existential synthesized by the<br>&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt; that wasn’t already present in the protocol.<br>&gt;<br>&gt; I would want to give consideration to specific details of a proposal<br>&gt; along these lines before deciding how I feel about it, but I have a<br>&gt; more open mind to this approach than introducing traps not present in<br>&gt; the preconditions of the protocol.<br>&gt;<br>&gt; /// You can subscript a collection with any valid index other than the<br>&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt; /// element.<br>&gt; ///<br>&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt; ///   `endIndex` property.<br>&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt; safe” IMO.<br>&gt;&gt; <br>&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt; traps.<br>&gt;<br>&gt; I am happy to use any word you like here.<br>&gt;<br>&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt; appear to be limited to memory safety in the public about page<br>&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt;:<br></p><p>I mean memory- and type-safe.<br></p><p>&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt; mistakes should be caught before software is in production. Opting for<br>&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt; clarity saves time in the long run.<br>&gt;<br>&gt; Safety<br>&gt;<br>&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt; to define your intent — for example, simple three-character keywords<br>&gt; define a variable (var) or constant (let).<br>&gt;<br>&gt; Another safety feature is that by default Swift objects can never be<br>&gt; nil, and trying to make or use a nil object will results in a<br>&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;<br>&gt; This positioning statement makes it appear as if preventing common<br>&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt; they are not met does not seem aligned with that goal IMO.<br></p><p>Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>mean that an operation that traps on a failed precondition check is<br>“unsafe.”<br></p><p>&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;<br>&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt; standard library?  <br></p><p>Whether it is or is not is an implementation detail.<br></p><p>&gt; Regardless, this is a specific case that has been given explicit<br>&gt; design attention by humans.  The precondition is designed, not<br>&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt; in question.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt; <br>&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;<br>&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt; discussion of Austin’s proposal.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt; where you bind .<br>&gt;&gt; <br>&gt;&gt; bind what?<br>&gt;<br>&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt; I meant to say bind the associated types that are necessary for your<br>&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt; case there is no trouble at all in conforming the type-erased<br>&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt; eliminate the need to manually write these “existentials” manually.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt; human consideration.<br>&gt;&gt; <br>&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;<br>&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;<br>&gt; The point I am trying to emphasize is that each of these are special<br>&gt; cases that have received direct human consideration.  The potential<br>&gt; for a trap is not introduced by language rules that apply to<br>&gt; user-defined constructs in without consideration of the specific<br>&gt; details of that construct.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt; <br>&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt; what happens with Self requirements in real cases.<br>&gt;<br>&gt; But again, I believe this is an exceptional case as the precondition<br>&gt; is explicitly stated in the semantics of the protocol.<br></p><p>IIUC, it has been cited by Doug as the exemplar of the<br>predominantly-requested case by a 10:1 ratio!<br></p><p>&gt; IMO the burden of proof should be on the side that proposes a<br>&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt; them.<br></p><p>If you really want to make this about sides and burdens, the burden of<br>proof always rests with the side proposing to extend the language.  We<br>shouldn&#39;t be making changes without understanding how they will play out<br>in real use-cases.<br></p><p>&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt; of the existential?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt; well enough to make a determination.<br>&gt;<br>&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;    // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;    guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;        lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;            print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;            return<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;    let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;    collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;    if let element = string as? collection.Element {<br>&gt;&gt;&gt;        // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;        collection[collection.startIndex] = element<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;<br>&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt; types.  <br></p><p>Really, now: a use-case for feature A that is a workaround for the lack<br>of feature B hardly justifies adding feature A!  We do want to add<br>higher-kinded types eventually.<br></p><p>&gt; If you have a protocol where specific implementations will return<br>&gt; different types, but all conform to a second protocol you can define<br>&gt; the protocol in terms of a generic type-erased wrapper which conforms<br>&gt; to the second protocol and accepts type arguments that match the<br>&gt; associated types (thus binding the associated types to concrete<br>&gt; types).  I have found this to be a useful technique (granted it is a<br>&gt; workaround and I’m not sure how useful it would continue to be if<br>&gt; Swift eventually gets higher-kinder types).<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt;&gt; the above could have been written either way, we need to be able to<br>&gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt;<br>&gt; That doesn’t seem like a particularly good programming model to me either. <br>&gt;<br>&gt; The rule of thumb I am operating with for protocols with Self or<br>&gt; associated type requirements is to prefer generics and use type<br>&gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt; a protocol requirement (as in the preceding example).<br>&gt;<br>&gt; This heuristic has been working out pretty well for me thus far.  <br></p><p>I do worry a bit that people will choose the opposite heuristic.<br></p><p>It would be somewhat reassuring to me if we could prove to ourselves<br>that, using your heuristic, one is never forced to copy/paste a generic<br>function implementation into a corresponding function that uses<br>existentials.<br></p><p>&gt; The primary impact of introducing a language mechanism for generalized<br>&gt; existentials in my code would be to eliminate a lot of manual type<br>&gt; erasing boilerplate.<br></p><p>If your code has many manual type erasing wrappers corresponding to<br>protocols with associated types and/or Self requirements that also never<br>have to trap type mismatches, that would certainly be instructive<br>empirical data.  Would you care to share the protocols and wrappers you<br>are talking about?<br></p><p>&gt;&gt; Anyway, my overall point is that this all seems like something we *can*<br>&gt;&gt; do and that nicely fills gaps in the type system, but not necessarily<br>&gt;&gt; something we *should* do until we better understand what it&#39;s actually<br>&gt;&gt; *for* and how it affects the programming model.<br>&gt;<br>&gt; That’s a very fair position to take.  :)<br>&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>On Thu, Jun 9, 2016 at 9:42 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt; &gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt; &gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt; &gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt; &gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt; &gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt; &gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt; &gt;&gt;&gt; (and maybe both).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt; &gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt; &gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt; &gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt; &gt;&gt; what happens with Self requirements in real cases.<br>&gt; &gt;<br>&gt; &gt; But again, I believe this is an exceptional case as the precondition<br>&gt; &gt; is explicitly stated in the semantics of the protocol.<br>&gt;<br>&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;<br></p><p>At the risk of sounding waffly, I see both sides of the argument.<br></p><p>Java is typesafe in the formal sense (can&#39;t perform an operation on a type<br>that doesn&#39;t actually support it); almost certainly moreso than Swift<br>(which lets you do wonderful things like reinterpret casting, C-style<br>direct memory manipulation...).<br></p><p>However, in many cases Swift provides better compile-time assurances than<br>Java. In Java, any reference might actually be a null reference waiting to<br>cause a NullPointerException unless you explicitly check it in code (and<br>what if you forget to check it somewhere?). In Swift, (aside from IUOs and<br>a few other features) if your program compiles successfully the type<br>checker has proven that your software will never try calling a method upon<br>nil. And if you do use IUOs the postfix exclamation marks clearly mark<br>spots in your code that might cause trouble.<br></p><p>In the same way I don&#39;t think trapping at runtime if an existential<br>satisfying a generic type parameter causes a type error is the best<br>solution to this problem. What we are doing is allowing a type that makes a<br>weak guarantee to stand in for a type that makes a strong guarantee, and<br>catching mismatches between those guarantees if/when they pop up. There&#39;s<br>no easy way for someone perusing the code to tell that such a mismatch<br>might occur, equivalent to IUO&#39;s postfix !.<br></p><p>What I prefer is to explicitly &quot;promote&quot; the type with the weak guarantee<br>to a type with the stronger guarantee using the existential opening<br>mechanism that we&#39;ve been throwing around. That way, it&#39;s very clear what<br>is going on: if the existentials in question can&#39;t serve as generic<br>parameters to the function you want to pass them to, you can fatalError()<br>or do something else. Or you can try force-opening with `as!` and mark a<br>potential trouble spot in the same way an IUO does. Once it succeeds you<br>know you have the strong guarantees that will cause your generic member to<br>alway work the way it should.<br></p><p>With the proposed mechanism, I expect that Any&lt;Collection where .Element ==<br>T&gt; should be less prone to runtime trapping than AnyCollection&lt;T&gt;, because<br>we can reify the concept that each instance of the existential has a<br>concrete Index type associated with it, rather than relying upon a<br>type-erased AnyIndex shared among all AnyCollections. (That being said, I<br>don&#39;t know if AnyCollection is particularly problematic in practical use. I<br>also don&#39;t know if other type-erased wrappers users might define might be<br>more or less prone to this type of issue.)<br></p><p><br>&gt; &gt; IMO the burden of proof should be on the side that proposes a<br>&gt; &gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt; &gt; them.<br>&gt;<br>&gt; If you really want to make this about sides and burdens, the burden of<br>&gt; proof always rests with the side proposing to extend the language.  We<br>&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt; in real use-cases.<br>&gt;<br>&gt;<br>Yes, I really want to see real-world use cases.<br></p><p><br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt; &gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt; &gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt; &gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt; &gt;&gt; the same existential type that wrap different concrete types.<br>&gt; &gt;<br>&gt; &gt; One use case I have found is to work around the lack of higher-kinder<br>&gt; &gt; types.<br>&gt;<br>&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt; higher-kinded types eventually.<br>&gt;<br></p><p>I just want to say, this made my day.<br></p><p>Most of the examples in the document Matthew linked were meant to be<br>didactic, not practical. I would love to swap them out for more useful<br>ones.<br></p><p><br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt; &gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt; &gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt; &gt;&gt; the above could have been written either way, we need to be able to<br>&gt; &gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt; &gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt; &gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt; &gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt; &gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt; &gt;<br>&gt; &gt; That doesn’t seem like a particularly good programming model to me<br>&gt; either.<br>&gt; &gt;<br>&gt; &gt; The rule of thumb I am operating with for protocols with Self or<br>&gt; &gt; associated type requirements is to prefer generics and use type<br>&gt; &gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt; &gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt; &gt; a protocol requirement (as in the preceding example).<br>&gt; &gt;<br>&gt; &gt; This heuristic has been working out pretty well for me thus far.<br>&gt;<br>&gt; I do worry a bit that people will choose the opposite heuristic.<br>&gt;<br></p><p>If we are to introduce this feature, I expect that the community would go<br>through another &quot;reference vs value types - which is right for you?&quot; type<br>discussion. It&#39;s true you can model a lot of things with classes where<br>structs would be more appropriate, but this doesn&#39;t seem to be a big issue.<br></p><p>I would be very interested in affordances that can steer people towards<br>using generics when the dynamic nature of existentials isn&#39;t necessary.<br></p><p><br>&gt;<br>&gt;<br>&gt; ______________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/3496a876/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 19:24 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Thu, Jun 9, 2016 at 9:42 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote: <br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt; &gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt; &gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt; &gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt; &gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt; &gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt; &gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt; &gt;&gt;&gt; (and maybe both).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt; &gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt; &gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt; &gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt; &gt;&gt; what happens with Self requirements in real cases.<br>&gt; &gt;<br>&gt; &gt; But again, I believe this is an exceptional case as the precondition<br>&gt; &gt; is explicitly stated in the semantics of the protocol.<br>&gt; <br>&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt; predominantly-requested case by a 10:1 ratio!<br>&gt; <br>&gt; At the risk of sounding waffly, I see both sides of the argument.<br>&gt; <br>&gt; Java is typesafe in the formal sense (can&#39;t perform an operation on a type that doesn&#39;t actually support it); almost certainly moreso than Swift (which lets you do wonderful things like reinterpret casting, C-style direct memory manipulation...).<br>&gt; <br>&gt; However, in many cases Swift provides better compile-time assurances than Java. In Java, any reference might actually be a null reference waiting to cause a NullPointerException unless you explicitly check it in code (and what if you forget to check it somewhere?). In Swift, (aside from IUOs and a few other features) if your program compiles successfully the type checker has proven that your software will never try calling a method upon nil. And if you do use IUOs the postfix exclamation marks clearly mark spots in your code that might cause trouble.<br>&gt; <br>&gt; In the same way I don&#39;t think trapping at runtime if an existential satisfying a generic type parameter causes a type error is the best solution to this problem. What we are doing is allowing a type that makes a weak guarantee to stand in for a type that makes a strong guarantee, and catching mismatches between those guarantees if/when they pop up. There&#39;s no easy way for someone perusing the code to tell that such a mismatch might occur, equivalent to IUO&#39;s postfix !.<br>&gt; <br>&gt; What I prefer is to explicitly &quot;promote&quot; the type with the weak guarantee to a type with the stronger guarantee using the existential opening mechanism that we&#39;ve been throwing around. That way, it&#39;s very clear what is going on: if the existentials in question can&#39;t serve as generic parameters to the function you want to pass them to, you can fatalError() or do something else. Or you can try force-opening with `as!` and mark a potential trouble spot in the same way an IUO does. Once it succeeds you know you have the strong guarantees that will cause your generic member to alway work the way it should.<br></p><p>Yes, there should never be crashes for calling a wrong method. That is what *type* safety means.<br>You still can have crashes when calling a method with wrong arguments. To make that type safe you would need a type system with dependent typing.<br></p><p>I think that Swift should not only always be safe but that it should always be type safe, too.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; With the proposed mechanism, I expect that Any&lt;Collection where .Element == T&gt; should be less prone to runtime trapping than AnyCollection&lt;T&gt;, because we can reify the concept that each instance of the existential has a concrete Index type associated with it, rather than relying upon a type-erased AnyIndex shared among all AnyCollections. (That being said, I don&#39;t know if AnyCollection is particularly problematic in practical use. I also don&#39;t know if other type-erased wrappers users might define might be more or less prone to this type of issue.)<br>&gt; <br>&gt; <br>&gt; &gt; IMO the burden of proof should be on the side that proposes a<br>&gt; &gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt; &gt; them.<br>&gt; <br>&gt; If you really want to make this about sides and burdens, the burden of<br>&gt; proof always rests with the side proposing to extend the language.  We<br>&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt; in real use-cases.<br>&gt; <br>&gt; <br>&gt; Yes, I really want to see real-world use cases.<br>&gt;  <br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt; &gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt; &gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt; &gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt; &gt;&gt; the same existential type that wrap different concrete types.<br>&gt; &gt;<br>&gt; &gt; One use case I have found is to work around the lack of higher-kinder<br>&gt; &gt; types.<br>&gt; <br>&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt; higher-kinded types eventually.<br>&gt; <br>&gt; I just want to say, this made my day.<br>&gt; <br>&gt; Most of the examples in the document Matthew linked were meant to be didactic, not practical. I would love to swap them out for more useful ones. <br>&gt; <br>&gt; <br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt; &gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt; &gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt; &gt;&gt; the above could have been written either way, we need to be able to<br>&gt; &gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt; &gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt; &gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt; &gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt; &gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt; &gt;<br>&gt; &gt; That doesn’t seem like a particularly good programming model to me either.<br>&gt; &gt;<br>&gt; &gt; The rule of thumb I am operating with for protocols with Self or<br>&gt; &gt; associated type requirements is to prefer generics and use type<br>&gt; &gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt; &gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt; &gt; a protocol requirement (as in the preceding example).<br>&gt; &gt;<br>&gt; &gt; This heuristic has been working out pretty well for me thus far.<br>&gt; <br>&gt; I do worry a bit that people will choose the opposite heuristic.<br>&gt; <br>&gt; If we are to introduce this feature, I expect that the community would go through another &quot;reference vs value types - which is right for you?&quot; type discussion. It&#39;s true you can model a lot of things with classes where structs would be more appropriate, but this doesn&#39;t seem to be a big issue.<br>&gt; <br>&gt; I would be very interested in affordances that can steer people towards using generics when the dynamic nature of existentials isn&#39;t necessary.<br>&gt;  <br>&gt; <br>&gt; <br>&gt; ______________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/d6e8b9b4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt; <br>&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt; example.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt; <br>&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt; using that member.<br>&gt;&gt; <br>&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt; a general way.<br>&gt;&gt; <br>&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt; of the protocol.<br>&gt;&gt; <br>&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt; <br>&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt; <br>&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt; the preconditions of the protocol.<br>&gt;&gt; <br>&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt; /// element.<br>&gt;&gt; ///<br>&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt; ///   `endIndex` property.<br>&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt; traps.<br>&gt;&gt; <br>&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt; <br>&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt; <br>&gt; I mean memory- and type-safe.<br>&gt; <br>&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt; clarity saves time in the long run.<br>&gt;&gt; <br>&gt;&gt; Safety<br>&gt;&gt; <br>&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt; <br>&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt; <br>&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt; <br>&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt; mean that an operation that traps on a failed precondition check is<br>&gt; “unsafe.”<br>&gt; <br>&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt; <br>&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt; standard library?  <br>&gt; <br>&gt; Whether it is or is not is an implementation detail.<br>&gt; <br>&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt; in question.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt; <br>&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bind what?<br>&gt;&gt; <br>&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt; <br>&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt; <br>&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt; details of that construct.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt; <br>&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt; <br>&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt; predominantly-requested case by a 10:1 ratio!<br></p><p>In terms of forming the existential, storing it in variables, accepting arguments of that type, etc yes.  I don’t know how many of those requests expect it to conform to the protocol and expect to be able to use it in generic code constrained to the protocol.<br></p><p>&gt; <br>&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt; them.<br>&gt; <br>&gt; If you really want to make this about sides and burdens, the burden of<br>&gt; proof always rests with the side proposing to extend the language.  We<br>&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt; in real use-cases.<br></p><p>I agree with this.  But if we are discussing two different options for extending the language I think the option that doesn’t introduce crashes should be preferred without pretty compelling reasons to choose the option that can introduce crashes.<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt; <br>&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;   // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;   guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;       lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;           print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;           return<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;   let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;   collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;   if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;       // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;       collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt; <br>&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt; types.  <br>&gt; <br>&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt; higher-kinded types eventually.<br> <br>Good to know.  I thought higher-kinder types were on the “maybe if someone shows a compelling enough use case” list.  AFAIK this is the first time a member of the core team has stated the intent to add them.  If that is the case I agree that this use case isn’t relevant.  The workaround isn’t great because it loses type information that is critical to the optimizer (but it’s all we have available today).<br></p><p>&gt; <br>&gt;&gt; If you have a protocol where specific implementations will return<br>&gt;&gt; different types, but all conform to a second protocol you can define<br>&gt;&gt; the protocol in terms of a generic type-erased wrapper which conforms<br>&gt;&gt; to the second protocol and accepts type arguments that match the<br>&gt;&gt; associated types (thus binding the associated types to concrete<br>&gt;&gt; types).  I have found this to be a useful technique (granted it is a<br>&gt;&gt; workaround and I’m not sure how useful it would continue to be if<br>&gt;&gt; Swift eventually gets higher-kinder types).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt;&gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt;&gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt;&gt;&gt; the above could have been written either way, we need to be able to<br>&gt;&gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt;&gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt;&gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt;&gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt;&gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt;&gt; <br>&gt;&gt; That doesn’t seem like a particularly good programming model to me either. <br>&gt;&gt; <br>&gt;&gt; The rule of thumb I am operating with for protocols with Self or<br>&gt;&gt; associated type requirements is to prefer generics and use type<br>&gt;&gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt;&gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt;&gt; a protocol requirement (as in the preceding example).<br>&gt;&gt; <br>&gt;&gt; This heuristic has been working out pretty well for me thus far.  <br>&gt; <br>&gt; I do worry a bit that people will choose the opposite heuristic.<br>&gt; <br>&gt; It would be somewhat reassuring to me if we could prove to ourselves<br>&gt; that, using your heuristic, one is never forced to copy/paste a generic<br>&gt; function implementation into a corresponding function that uses<br>&gt; existentials.<br>&gt; <br>&gt;&gt; The primary impact of introducing a language mechanism for generalized<br>&gt;&gt; existentials in my code would be to eliminate a lot of manual type<br>&gt;&gt; erasing boilerplate.<br>&gt; <br>&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt; protocols with associated types and/or Self requirements that also never<br>&gt; have to trap type mismatches, that would certainly be instructive<br>&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt; are talking about?<br></p><p>I put together a sample implementation of a Cocoa-like responder chain in Swift a while ago when the “Swift dynamism” debate was raging.  <br></p><p>It isn&#39;t intended to be a Swifty design.  It is intended to be similar to Cocoa and show techniques that can be used to do things similar to Cocoa’s responder chain and targer-action in Swift.  It uses a type erased wrapper for actions that binds `Sender` while hiding the concrete `Action` type and also the `Handler` associated type.  It cannot and should not conform to the protocol it is derived from and could be replaced with the generalized existentials in Austin’s proposal.<br></p><p>https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e &lt;https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e&gt;<br></p><p>This is a good example to start with because it is related to a topic that has been hotly debated and is clearly something a lot of people want to be able to do.<br></p><p>&gt; <br>&gt;&gt;&gt; Anyway, my overall point is that this all seems like something we *can*<br>&gt;&gt;&gt; do and that nicely fills gaps in the type system, but not necessarily<br>&gt;&gt;&gt; something we *should* do until we better understand what it&#39;s actually<br>&gt;&gt;&gt; *for* and how it affects the programming model.<br>&gt;&gt; <br>&gt;&gt; That’s a very fair position to take.  :)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/ea04db9c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt;&gt; using that member.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt;&gt; a general way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt;&gt; of the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt;&gt; the preconditions of the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt;&gt; /// element.<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt;&gt; ///   `endIndex` property.<br>&gt;&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt;&gt; traps.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I mean memory- and type-safe.<br>&gt;&gt; <br>&gt;&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt;&gt; clarity saves time in the long run.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Safety<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt;&gt; <br>&gt;&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt;&gt; mean that an operation that traps on a failed precondition check is<br>&gt;&gt; “unsafe.”<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt;&gt; standard library?  <br>&gt;&gt; <br>&gt;&gt; Whether it is or is not is an implementation detail.<br>&gt;&gt; <br>&gt;&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt;&gt; in question.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; bind what?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt;&gt; details of that construct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt;&gt; <br>&gt;&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt;&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;<br>&gt; In terms of forming the existential, storing it in variables,<br>&gt; accepting arguments of that type, etc yes.  I don’t know how many of<br>&gt; those requests expect it to conform to the protocol and expect to be<br>&gt; able to use it in generic code constrained to the protocol.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt;&gt; them.<br>&gt;&gt; <br>&gt;&gt; If you really want to make this about sides and burdens, the burden of<br>&gt;&gt; proof always rests with the side proposing to extend the language.  We<br>&gt;&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt;&gt; in real use-cases.<br>&gt;<br>&gt; I agree with this.  But if we are discussing two different options for<br>&gt; extending the language I think the option that doesn’t introduce<br>&gt; crashes should be preferred without pretty compelling reasons to<br>&gt; choose the option that can introduce crashes.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;&gt;   // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;&gt;   guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;&gt;       lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;&gt;           print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;&gt;           return<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;   let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;&gt;   collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;&gt;   if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;&gt;       // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;       collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt;&gt; types.  <br>&gt;&gt; <br>&gt;&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt;&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt;&gt; higher-kinded types eventually.<br>&gt;<br>&gt; Good to know.  I thought higher-kinder types were on the “maybe if<br>&gt; someone shows a compelling enough use case” list.  AFAIK this is the<br>&gt; first time a member of the core team has stated the intent to add<br>&gt; them.  <br></p><p>Well, please don&#39;t take this as a formal statement on behalf of the<br>team.  IIUC, the team is generally interested in having this feature.<br></p><p>&gt; If that is the case I agree that this use case isn’t relevant.  The<br>&gt; workaround isn’t great because it loses type information that is<br>&gt; critical to the optimizer (but it’s all we have available today).<br>&gt;&gt; <br>&gt;&gt;&gt; If you have a protocol where specific implementations will return<br>&gt;&gt;&gt; different types, but all conform to a second protocol you can define<br>&gt;&gt;&gt; the protocol in terms of a generic type-erased wrapper which conforms<br>&gt;&gt;&gt; to the second protocol and accepts type arguments that match the<br>&gt;&gt;&gt; associated types (thus binding the associated types to concrete<br>&gt;&gt;&gt; types).  I have found this to be a useful technique (granted it is a<br>&gt;&gt;&gt; workaround and I’m not sure how useful it would continue to be if<br>&gt;&gt;&gt; Swift eventually gets higher-kinder types).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt;&gt;&gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt;&gt;&gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt;&gt;&gt;&gt; the above could have been written either way, we need to be able to<br>&gt;&gt;&gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt;&gt;&gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt;&gt;&gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt;&gt;&gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt;&gt;&gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That doesn’t seem like a particularly good programming model to me either. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rule of thumb I am operating with for protocols with Self or<br>&gt;&gt;&gt; associated type requirements is to prefer generics and use type<br>&gt;&gt;&gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt;&gt;&gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt;&gt;&gt; a protocol requirement (as in the preceding example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This heuristic has been working out pretty well for me thus far.  <br>&gt;&gt; <br>&gt;&gt; I do worry a bit that people will choose the opposite heuristic.<br>&gt;&gt; <br>&gt;&gt; It would be somewhat reassuring to me if we could prove to ourselves<br>&gt;&gt; that, using your heuristic, one is never forced to copy/paste a generic<br>&gt;&gt; function implementation into a corresponding function that uses<br>&gt;&gt; existentials.<br>&gt;&gt; <br>&gt;&gt;&gt; The primary impact of introducing a language mechanism for generalized<br>&gt;&gt;&gt; existentials in my code would be to eliminate a lot of manual type<br>&gt;&gt;&gt; erasing boilerplate.<br>&gt;&gt; <br>&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt; are talking about?<br>&gt;<br>&gt; I put together a sample implementation of a Cocoa-like responder chain<br>&gt; in Swift a while ago when the “Swift dynamism” debate was raging.<br>&gt;<br>&gt; It isn&#39;t intended to be a Swifty design.  It is intended to be similar<br>&gt; to Cocoa and show techniques that can be used to do things similar to<br>&gt; Cocoa’s responder chain and targer-action in Swift.  It uses a type<br>&gt; erased wrapper for actions that binds `Sender` while hiding the<br>&gt; concrete `Action` type and also the `Handler` associated type.  It<br>&gt; cannot and should not conform to the protocol it is derived from and<br>&gt; could be replaced with the generalized existentials in Austin’s<br>&gt; proposal.<br>&gt;<br>&gt; https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e<br>&gt; &lt;https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e&gt;<br>&gt;<br>&gt; This is a good example to start with because it is related to a topic<br>&gt; that has been hotly debated and is clearly something a lot of people<br>&gt; want to be able to do.<br></p><p>It&#39;s great to start with, but if this is just one example, we still<br>technically have more examples in the standard library of the other kind<br>of wrapper.  You said it would eliminate a lot of manual boilerplate.  I<br>presume that means you have lots more examples like this one?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 3:05 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 11:42 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jun 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 9:55 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements.  It is true of all existentials.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt;&gt;&gt;&gt;&gt; about here would make it impossible for some to do that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If it is just an implementation limitation I am happy to hear that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt;&gt;&gt;&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My question is, why not?  That is still explicit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not explicit in the sense that nobody wrote `fatalError` or<br>&gt;&gt;&gt;&gt; similar in their code.  It’s too easy to write something like that<br>&gt;&gt;&gt;&gt; without realizing that it introduces the possibility of a crash.  If<br>&gt;&gt;&gt;&gt; we adopt syntax like that to introduce an existential that introduces<br>&gt;&gt;&gt;&gt; traps we should at least require members that can be trap to be<br>&gt;&gt;&gt;&gt; invoked using a `!` suffix or something like that to make it clear to<br>&gt;&gt;&gt;&gt; users that a trap will happen if they are not extremely careful when<br>&gt;&gt;&gt;&gt; using that member.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More generally though, I don’t want the rules of the language to be<br>&gt;&gt;&gt;&gt; written in a way that causes the compiler to synthesize traps in such<br>&gt;&gt;&gt;&gt; a general way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The existential should not introduce a precondition that isn’t already<br>&gt;&gt;&gt;&gt; present in the semantics of the protocol itself.  If the semantics of<br>&gt;&gt;&gt;&gt; the protocol do not place preconditions on arguments beyond their type<br>&gt;&gt;&gt;&gt; (such as “must be a valid index into this specific instance”) the<br>&gt;&gt;&gt;&gt; compiler should not allow the existential to conform if a trap is<br>&gt;&gt;&gt;&gt; required in some circumstances.  That is a new precondition and<br>&gt;&gt;&gt;&gt; therefore the existential does not actually fulfill the requirements<br>&gt;&gt;&gt;&gt; of the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could *maybe* live with a solution where protocol requirements are<br>&gt;&gt;&gt;&gt; marked as trapping, etc depending on the specific argument received at<br>&gt;&gt;&gt;&gt; runtime.  This is a total straw man syntax, but maybe `IndexableBase`<br>&gt;&gt;&gt;&gt; would declare the subscript `@trapping` (probably something different<br>&gt;&gt;&gt;&gt; but I hope this communicates the idea).  This alerts users to the fact<br>&gt;&gt;&gt;&gt; that they need to be extra careful - not any value of `Self.Index` is<br>&gt;&gt;&gt;&gt; valid and you can get a crash if you’re not careful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Having this semantic explicit in the definition of the protocol opens<br>&gt;&gt;&gt;&gt; the door to maybe considering an existential synthesized by the<br>&gt;&gt;&gt;&gt; compiler that traps because it doesn’t introduce a new precondition<br>&gt;&gt;&gt;&gt; that wasn’t already present in the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would want to give consideration to specific details of a proposal<br>&gt;&gt;&gt;&gt; along these lines before deciding how I feel about it, but I have a<br>&gt;&gt;&gt;&gt; more open mind to this approach than introducing traps not present in<br>&gt;&gt;&gt;&gt; the preconditions of the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// You can subscript a collection with any valid index other than the<br>&gt;&gt;&gt;&gt; /// collection&#39;s end index. The end index refers to the position one past<br>&gt;&gt;&gt;&gt; /// the last element of a collection, so it doesn&#39;t correspond with an<br>&gt;&gt;&gt;&gt; /// element.<br>&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt; /// - Parameter position: The position of the element to access. `position`<br>&gt;&gt;&gt;&gt; ///   must be a valid index of the collection that is not equal to the<br>&gt;&gt;&gt;&gt; ///   `endIndex` property.<br>&gt;&gt;&gt;&gt; @trapping public subscript(position: Self.Index) -&gt; Self._Element { get }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt;&gt;&gt;&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt;&gt;&gt;&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt;&gt;&gt;&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt;&gt;&gt;&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt;&gt;&gt;&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt;&gt;&gt;&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt;&gt;&gt;&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt;&gt;&gt;&gt;&gt; available on all Collection types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt;&gt;&gt;&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt;&gt;&gt;&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt;&gt;&gt;&gt;&gt; safe” IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt;&gt;&gt;&gt;&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt;&gt;&gt;&gt;&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt;&gt;&gt;&gt;&gt; traps.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am happy to use any word you like here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you clarify what you mean by the word safe in Swift?  It doesn’t<br>&gt;&gt;&gt;&gt; appear to be limited to memory safety in the public about page<br>&gt;&gt;&gt;&gt; https://swift.org/about/ &lt;https://swift.org/about/&gt; &lt;https://swift.org/about/ &lt;https://swift.org/about/&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mean memory- and type-safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Safe. The most obvious way to write code should also behave in a safe<br>&gt;&gt;&gt;&gt; manner. Undefined behavior is the enemy of safety, and developer<br>&gt;&gt;&gt;&gt; mistakes should be caught before software is in production. Opting for<br>&gt;&gt;&gt;&gt; safety sometimes means Swift will feel strict, but we believe that<br>&gt;&gt;&gt;&gt; clarity saves time in the long run.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Safety<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift was designed from the outset to be safer than C-based languages,<br>&gt;&gt;&gt;&gt; and eliminates entire classes of unsafe code. Variables are always<br>&gt;&gt;&gt;&gt; initialized before use, arrays and integers are checked for overflow,<br>&gt;&gt;&gt;&gt; and memory is managed automatically. Syntax is tuned to make it easy<br>&gt;&gt;&gt;&gt; to define your intent — for example, simple three-character keywords<br>&gt;&gt;&gt;&gt; define a variable (var) or constant (let).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another safety feature is that by default Swift objects can never be<br>&gt;&gt;&gt;&gt; nil, and trying to make or use a nil object will results in a<br>&gt;&gt;&gt;&gt; compile-time error. This makes writing code much cleaner and safer,<br>&gt;&gt;&gt;&gt; and prevents a common cause of runtime crashes. However, there are<br>&gt;&gt;&gt;&gt; cases where nil is appropriate, and for these situations Swift has an<br>&gt;&gt;&gt;&gt; innovative feature known as optionals. An optional may contain nil,<br>&gt;&gt;&gt;&gt; but Swift syntax forces you to safely deal with it using ? to indicate<br>&gt;&gt;&gt;&gt; to the compiler you understand the behavior and will handle it safely.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This positioning statement makes it appear as if preventing common<br>&gt;&gt;&gt;&gt; causes of crashes falls within the meaning of safe that Swift is<br>&gt;&gt;&gt;&gt; using.  Having existentials introduce new preconditions and traps when<br>&gt;&gt;&gt;&gt; they are not met does not seem aligned with that goal IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Static typing “increases safety,” in the casual sense.  That doesn&#39;t<br>&gt;&gt;&gt; mean that an operation that traps on a failed precondition check is<br>&gt;&gt;&gt; “unsafe.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt;&gt;&gt;&gt;&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The user doesn’t, but isn’t the overflow trap implemented in the<br>&gt;&gt;&gt;&gt; standard library?  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether it is or is not is an implementation detail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regardless, this is a specific case that has been given explicit<br>&gt;&gt;&gt;&gt; design attention by humans.  The precondition is designed, not<br>&gt;&gt;&gt;&gt; introduced by compiler rules that haven’t considered the specific case<br>&gt;&gt;&gt;&gt; in question.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach that could be used in targeted use cases where the less<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; safe behavior makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Usefulness depends on your perspective.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agree.  We can consider those in depth when the time comes to ramp up<br>&gt;&gt;&gt;&gt; discussion of Austin’s proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt;&gt;&gt;&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt;&gt;&gt;&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt;&gt;&gt;&gt;&gt; where you bind .<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; bind what?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, I must have gotten distracted and not finished that paragraph.<br>&gt;&gt;&gt;&gt; I meant to say bind the associated types that are necessary for your<br>&gt;&gt;&gt;&gt; use case.  Sometimes you bind *all* of the associated types to<br>&gt;&gt;&gt;&gt; concrete types and the protocol has no `Self` requirements.  In that<br>&gt;&gt;&gt;&gt; case there is no trouble at all in conforming the type-erased<br>&gt;&gt;&gt;&gt; “existential&quot; to the protocol itself.  Austin’s proposal would<br>&gt;&gt;&gt;&gt; eliminate the need to manually write these “existentials” manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt;&gt;&gt;&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt;&gt;&gt;&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt;&gt;&gt;&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt;&gt;&gt;&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt;&gt;&gt;&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt;&gt;&gt;&gt;&gt; human consideration.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is no distinction in the user model between what might be<br>&gt;&gt;&gt;&gt;&gt; synthesized by the language and what appears on standard library types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe I shouldn’t have made that distinction.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The point I am trying to emphasize is that each of these are special<br>&gt;&gt;&gt;&gt; cases that have received direct human consideration.  The potential<br>&gt;&gt;&gt;&gt; for a trap is not introduced by language rules that apply to<br>&gt;&gt;&gt;&gt; user-defined constructs in without consideration of the specific<br>&gt;&gt;&gt;&gt; details of that construct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt;&gt;&gt;&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt;&gt;&gt;&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt;&gt;&gt;&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt;&gt;&gt;&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt;&gt;&gt;&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt;&gt;&gt;&gt;&gt; (and maybe both).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt;&gt;&gt;&gt;&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt;&gt;&gt;&gt;&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt;&gt;&gt;&gt;&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt;&gt;&gt;&gt;&gt; what happens with Self requirements in real cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But again, I believe this is an exceptional case as the precondition<br>&gt;&gt;&gt;&gt; is explicitly stated in the semantics of the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIUC, it has been cited by Doug as the exemplar of the<br>&gt;&gt;&gt; predominantly-requested case by a 10:1 ratio!<br>&gt;&gt; <br>&gt;&gt; In terms of forming the existential, storing it in variables,<br>&gt;&gt; accepting arguments of that type, etc yes.  I don’t know how many of<br>&gt;&gt; those requests expect it to conform to the protocol and expect to be<br>&gt;&gt; able to use it in generic code constrained to the protocol.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO the burden of proof should be on the side that proposes a<br>&gt;&gt;&gt;&gt; mechanism to introduce traps, not the side that proposes avoiding<br>&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you really want to make this about sides and burdens, the burden of<br>&gt;&gt;&gt; proof always rests with the side proposing to extend the language.  We<br>&gt;&gt;&gt; shouldn&#39;t be making changes without understanding how they will play out<br>&gt;&gt;&gt; in real use-cases.<br>&gt;&gt; <br>&gt;&gt; I agree with this.  But if we are discussing two different options for<br>&gt;&gt; extending the language I think the option that doesn’t introduce<br>&gt;&gt; crashes should be preferred without pretty compelling reasons to<br>&gt;&gt; choose the option that can introduce crashes.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt;&gt;&gt;&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt;&gt;&gt;&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt;&gt;&gt;&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt;&gt;&gt;&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt;&gt;&gt;&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt;&gt;&gt;&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt;&gt;&gt;&gt;&gt; a trap when violated.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt;&gt;&gt;&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt;&gt;&gt;&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt;&gt;&gt;&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt;&gt;&gt;&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt;&gt;&gt;&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt;&gt;&gt;&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt;&gt;&gt;&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt;&gt;&gt;&gt;&gt; of the existential?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt;&gt;&gt;&gt;&gt; well enough to make a determination.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s fair.  I agree that use cases should be carefully considered.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt;&gt;&gt;&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt;&gt;&gt;&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt;&gt;&gt;&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt;&gt;&gt;&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt;&gt;&gt;&gt;&gt; // Not a generic function. <br>&gt;&gt;&gt;&gt;&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;  guard let firstIndex = collection.startIndex,<br>&gt;&gt;&gt;&gt;&gt;&gt;      lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;&gt;&gt;&gt;&gt;          print(&quot;Nothing to do&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt;          return<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;  let oldFirstItem = collection[firstIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;&gt;&gt;&gt;&gt;  collection[lastIndex] = oldFirstItem<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt;&gt;&gt;&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt;&gt;&gt;&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt;&gt;&gt;&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt;&gt;&gt;&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // as mentioned, this also works:<br>&gt;&gt;&gt;&gt;&gt;&gt; a[a.startIndex] = input<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt;&gt;&gt;&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;  if let element = string as? collection.Element {<br>&gt;&gt;&gt;&gt;&gt;&gt;      // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;      collection[collection.startIndex] = element<br>&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Neither of these look like they actually make *use* of the fact that<br>&gt;&gt;&gt;&gt;&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt;&gt;&gt;&gt;&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt;&gt;&gt;&gt;&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt;&gt;&gt;&gt;&gt; the same existential type that wrap different concrete types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One use case I have found is to work around the lack of higher-kinder<br>&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Really, now: a use-case for feature A that is a workaround for the lack<br>&gt;&gt;&gt; of feature B hardly justifies adding feature A!  We do want to add<br>&gt;&gt;&gt; higher-kinded types eventually.<br>&gt;&gt; <br>&gt;&gt; Good to know.  I thought higher-kinder types were on the “maybe if<br>&gt;&gt; someone shows a compelling enough use case” list.  AFAIK this is the<br>&gt;&gt; first time a member of the core team has stated the intent to add<br>&gt;&gt; them.  <br>&gt; <br>&gt; Well, please don&#39;t take this as a formal statement on behalf of the<br>&gt; team.  IIUC, the team is generally interested in having this feature.<br></p><p>Of course not.  The only official plan of record for Swift is approved proposals.  But it’s always interesting to know the opinions of the core team about potential features.  Previously my impression had been that the general leaning was towards skepticism that the practical benefits of HKT would pay for the complexity.  Maybe that was (or is now) not correct and the opinion is generally favorable.  That is great news.<br></p><p>&gt; <br>&gt;&gt; If that is the case I agree that this use case isn’t relevant.  The<br>&gt;&gt; workaround isn’t great because it loses type information that is<br>&gt;&gt; critical to the optimizer (but it’s all we have available today).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have a protocol where specific implementations will return<br>&gt;&gt;&gt;&gt; different types, but all conform to a second protocol you can define<br>&gt;&gt;&gt;&gt; the protocol in terms of a generic type-erased wrapper which conforms<br>&gt;&gt;&gt;&gt; to the second protocol and accepts type arguments that match the<br>&gt;&gt;&gt;&gt; associated types (thus binding the associated types to concrete<br>&gt;&gt;&gt;&gt; types).  I have found this to be a useful technique (granted it is a<br>&gt;&gt;&gt;&gt; workaround and I’m not sure how useful it would continue to be if<br>&gt;&gt;&gt;&gt; Swift eventually gets higher-kinder types).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt;&gt;&gt;&gt;&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt;&gt;&gt;&gt;&gt; regular function taking existential parameters?  Given that either of<br>&gt;&gt;&gt;&gt;&gt; the above could have been written either way, we need to be able to<br>&gt;&gt;&gt;&gt;&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt;&gt;&gt;&gt;&gt; protocols, it seems to me that the most general thing to do is use<br>&gt;&gt;&gt;&gt;&gt; existentials whenever you can, and only resort to using generics when<br>&gt;&gt;&gt;&gt;&gt; forced by the type system.  This does not seem like a particularly good<br>&gt;&gt;&gt;&gt;&gt; programming model to me, but I might be convinced otherwise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That doesn’t seem like a particularly good programming model to me either. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rule of thumb I am operating with for protocols with Self or<br>&gt;&gt;&gt;&gt; associated type requirements is to prefer generics and use type<br>&gt;&gt;&gt;&gt; erasure / existentials when that isn’t possible.  For example, when<br>&gt;&gt;&gt;&gt; heterogeneity is required or when you can’t form the necessary type in<br>&gt;&gt;&gt;&gt; a protocol requirement (as in the preceding example).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This heuristic has been working out pretty well for me thus far.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do worry a bit that people will choose the opposite heuristic.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be somewhat reassuring to me if we could prove to ourselves<br>&gt;&gt;&gt; that, using your heuristic, one is never forced to copy/paste a generic<br>&gt;&gt;&gt; function implementation into a corresponding function that uses<br>&gt;&gt;&gt; existentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The primary impact of introducing a language mechanism for generalized<br>&gt;&gt;&gt;&gt; existentials in my code would be to eliminate a lot of manual type<br>&gt;&gt;&gt;&gt; erasing boilerplate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt;&gt;&gt; protocols with associated types and/or Self requirements that also never<br>&gt;&gt;&gt; have to trap type mismatches, that would certainly be instructive<br>&gt;&gt;&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt;&gt;&gt; are talking about?<br>&gt;&gt; <br>&gt;&gt; I put together a sample implementation of a Cocoa-like responder chain<br>&gt;&gt; in Swift a while ago when the “Swift dynamism” debate was raging.<br>&gt;&gt; <br>&gt;&gt; It isn&#39;t intended to be a Swifty design.  It is intended to be similar<br>&gt;&gt; to Cocoa and show techniques that can be used to do things similar to<br>&gt;&gt; Cocoa’s responder chain and targer-action in Swift.  It uses a type<br>&gt;&gt; erased wrapper for actions that binds `Sender` while hiding the<br>&gt;&gt; concrete `Action` type and also the `Handler` associated type.  It<br>&gt;&gt; cannot and should not conform to the protocol it is derived from and<br>&gt;&gt; could be replaced with the generalized existentials in Austin’s<br>&gt;&gt; proposal.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e<br>&gt;&gt; &lt;https://gist.github.com/anandabits/ec26f67f682093cf18b170c21bcf433e&gt;<br>&gt;&gt; <br>&gt;&gt; This is a good example to start with because it is related to a topic<br>&gt;&gt; that has been hotly debated and is clearly something a lot of people<br>&gt;&gt; want to be able to do.<br>&gt; <br>&gt; It&#39;s great to start with, but if this is just one example, we still<br>&gt; technically have more examples in the standard library of the other kind<br>&gt; of wrapper.  You said it would eliminate a lot of manual boilerplate.  I<br>&gt; presume that means you have lots more examples like this one?<br></p><p>There are variations on the command / responder chain pattern that are useful in various contexts.  Another related example would be using this technique to do something similar to the Elm architecture (http://www.elm-lang.org &lt;http://www.elm-lang.org/&gt;), but without requiring switch statements to do the dispatching.  <br></p><p>Another common pattern where existentials can be useful is when you want to hide implementation details of an API.  This can be just because you want the concrete type to be private, but it can also be similar to class clusters without the inheritance where the concrete type actually differs for one reason or another.<br></p><p>public protocol Foo {<br>    associatedtype Bar<br>}<br>public struct AnyFoo&lt;T&gt; : Foo {<br>    typealias Bar = T<br>    private var base: AnyFooBase&lt;T&gt;<br>    init&lt;F: Foo where Bar == T&gt;(foo: F) { … }<br>}<br>// assume the rest of the type erasure machinery<br></p><p>public func myFunc&lt;T&gt;(t: T) -&gt; AnyFoo&lt;T&gt; {<br>    // create an instance of of a private type<br>    // which implements Foo and return <br>    // it wrapped in AnyFoo<br>}<br></p><p>As has been mentioned already, another common case where you need existentials like this is if you need a heterogeneous collection.<br></p><p>There have been several blog posts and conference talks on type erasure in Swift.  I don’t have time to review all of them right now but they may also be fruitful sources of additional good examples.<br></p><p>But really what I mean by a lot of manual boilerplate is three types each with an implementation of each member you want to expose every time you want to form an existential with types that conform to a protocol with associated types.  This adds up quickly and is annoying to have to write.  In terms of percentage of total lines of code it isn’t huge, but in terms of percentage of lines of boilerplate code it can be a lot.  It is one of the bigger sources of boilerplate in Swift and probably steers people away from designs they might prefer because they just aren’t willing to tolerate the boilerplate.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/2182a65b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 9:42 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; If your code has many manual type erasing wrappers corresponding to<br>&gt; protocols with associated types and/or Self requirements that also never<br>&gt; have to trap type mismatches, that would certainly be instructive<br>&gt; empirical data.  Would you care to share the protocols and wrappers you<br>&gt; are talking about?<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p><br></p><p>Part of the problem is you get used to living inside the cell and forget what life might be like on the outside. I don’t run in to many cases anymore because I know they won’t work and pre-emotively constrain my designs to fit into the existing restrictions.<br></p><p>Sorry for the long bit of code, I tried to boil it down to the absolute minimum. It has the advantage of being actual shipping code:<br></p><p>public protocol AnyMutationOperation {<br>    func __mutate(object: Any) -&gt; Any<br>}<br></p><p>public protocol MutationOperation: AnyMutationOperation {<br>    associatedtype ObjectType: MutatableSyncable<br>    func _mutate(object: ObjectType) -&gt; ObjectType<br>}<br></p><p>public protocol MutatableSyncable {<br>    var _operations: [AnyMutationOperation] { get set }<br>    mutating func mutate&lt;T: MutationOperation where T.ObjectType == Self&gt;(mutation: T) -&gt; Self<br>}<br></p><p>extension MutatableSyncable {<br>    mutating func mutate&lt;T: MutationOperation where T.ObjectType == Self&gt;(mutation: T) -&gt; Self { <br>        self._operations.append(mutation)<br>        return mutation._mutate(self)<br>    }<br>    mutating func _mutate(mutation: AnyMutationOperation) -&gt; Self {<br>        return mutation.__mutate(self) as! Self<br>    }<br>}<br></p><p>extension MutationOperation {<br>    func __mutate(object: Any) -&gt; Any {<br>        return self._mutate(object as! ObjectType)<br>    }<br>}<br></p><p>struct Model: MutatableSyncable {<br>    var _operations: [AnyMutationOperation] = []<br>    var name: String = &quot;&quot;<br>}<br></p><p>struct ChangeNameOperation: MutationOperation {<br>    var newName: String<br>    func _mutate(object: Model) -&gt; Model {<br>        var copy = object<br>        copy.name = self.newName<br>        return object<br>    }<br>}<br></p><p><br>AnyMutationOperation, the force casting, etc are all to work around the inability to call MutatableSyncable.mutate() with MutationOperations that came from the database. <br></p><p>// at local point of mutation, works fine<br>var model = Model()<br>let op = ChangeNameOperation(newName: &quot;bob&quot;)<br>model.mutate(op)<br></p><p><br>// when trying to rollback/rollforward in sync manager, which handles many model and mutation types<br>var model: MutatableSyncable = …<br>// this can&#39;t even be MutationOperation<br>let op: AnyMutationOperation = …<br></p><p>// ERROR, can&#39;t do that!<br>//model.mutate(op)<br></p><p>// Better hope none of those force casts trap!<br>model._mutate(op)<br></p><p>We didn’t want to encode a massive list of 100s of types in a big ol’ switch statement because we’re modeling every single mutable field as a separate MutationOperation. All we know in the sync manager is we have a MutatableSyncable and some MutationOperation (but in our type-erased AnyMutationOperation). So we have a fragile system that traps if anyone makes a mistake. I’d much rather be able to unwrap the existential and validate that the operation’s ObjectType matches the model’s concrete type, then call the generic version of mutate().<br></p><p>There is another place where we want to find the ObjectManager&lt;T: ModelType&gt; for the model type T, then call it but we run into the same associated types problem. We couldn’t create a Dictionary&lt;ModelType, ObjectManager&lt;ModelType&gt;&gt; because ObjectManager has associated types.<br></p><p>In that case the list of model types was constrained enough we went for the big switch statement but it takes Any so is completely unchecked by the compiler even though we know that we could constrain it to be type safe:<br></p><p>func saveFromServer(model: Any) throws {<br>    switch model {<br>    case let model as PGReportTypeFullModel:<br>        try self.reportTypeManager.saveFromServer(model)<br>    // lots of others here ...<br>    }<br>}<br></p><p><br>I’ll see if I can find some more examples later.<br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/f5ded78d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 4:55 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 1:33 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt; == Int” does not conform to Collection.  <br>&gt;&gt; <br>&gt;&gt; This isn’t directly related to having self or associated type<br>&gt;&gt; requirements.  It is true of all existentials.  <br>&gt; <br>&gt; That is just an implementation limitation today, IIUC.  What I&#39;m talking<br>&gt; about here would make it impossible for some to do that.<br>&gt; <br>&gt;&gt; If that changes for simple existentials and generalized existentials<br>&gt;&gt; expose all members (as in the latest draft of the proposal) maybe it<br>&gt;&gt; will be possible for all existentials to conform to their protocol.<br>&gt; <br>&gt; Not without introducing runtime traps.  See my “subscript function”<br>&gt; example.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; That&#39;s weird and not very<br>&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; I didn’t mean directly through the type of the existential.<br>&gt; <br>&gt; My question is, why not?  That is still explicit.<br>&gt; <br>&gt;&gt; One obvious mechanism for introducing unsafe behavior is to write<br>&gt;&gt; manual type erasure wrappers like we do today.<br>&gt;&gt; <br>&gt;&gt; Another possibility would be to allow extending the existential type<br>&gt;&gt; (not the protocol).  This would allow you to write overloads on the<br>&gt;&gt; Collection existential that takes some kind of type erased index if<br>&gt;&gt; that is what you want and either trap if you receive an invalid index<br>&gt;&gt; or better (IMO) return an `Element?`.  I’m not sure how extensions on<br>&gt;&gt; existentials might be implemented, but this is an example of the kind<br>&gt;&gt; of operation you might want available on it that you wouldn’t want<br>&gt;&gt; available on all Collection types.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; <br>&gt;&gt; That depends on what you mean by safe.  Sure, those methods aren’t<br>&gt;&gt; going corrupt memory, but they *are* going to explicitly and<br>&gt;&gt; intentionally crash for some inputs.  That doesn’t qualify as “fully<br>&gt;&gt; safe” IMO.<br>&gt; <br>&gt; Please pick a term other than “unsafe” here; it&#39;s not unsafe in the<br>&gt; sense we mean the word in Swift.  It&#39;s safe in exactly the same way that<br>&gt; array indexes and integers are.  When you violate a precondition, it<br>&gt; traps.<br>&gt; <br>&gt; The user doesn&#39;t do anything “manual” to introduce that trapping<br>&gt; behavior for integers.  Preconditions are a natural part of most types.<br>&gt; <br>&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; <br>&gt;&gt; Usefulness depends on your perspective.  <br>&gt; <br>&gt; Of course.  As I&#39;ve said, let&#39;s look at the use cases.<br>&gt; <br>&gt;&gt; I have run into several scenarios where they would be very useful<br>&gt;&gt; without needing to be prone to crashes when used incorrectly.  One<br>&gt;&gt; obvious basic use case is storing things in a heterogenous collection<br>&gt;&gt; where you bind .<br>&gt; <br>&gt; bind what?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt; couldn&#39;t be erased.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; <br>&gt;&gt; AFAIK (and I could be wrong) the only rules in the language that<br>&gt;&gt; require the compiler to synthesize a trap except using a nil IUO, `!`<br>&gt;&gt; on a nil Optional, and an invalid `as` cast .  These are all<br>&gt;&gt; syntactically explicit unsafe / dangerous operations.  All other traps<br>&gt;&gt; are in the standard library (array index, overflow, etc).  Most<br>&gt;&gt; important about all of these cases is that they have received direct<br>&gt;&gt; human consideration.<br>&gt; <br>&gt; There is no distinction in the user model between what might be<br>&gt; synthesized by the language and what appears on standard library types.<br>&gt; <br>&gt;&gt; Introducing a language (not library) mechanism that exposes members on<br>&gt;&gt; generalized existentials in a way that relies on runtime traps for<br>&gt;&gt; type safety feels to me like a pretty dramatic turn agains the stated<br>&gt;&gt; priority of safety.  It will mean you must understand exactly what is<br>&gt;&gt; going on and be extremely careful to use generalized existentials<br>&gt;&gt; without causing crashes.  This will either make Swift code much more<br>&gt;&gt; crashy or will scare people away from using generalized existentials<br>&gt;&gt; (and maybe both).  <br>&gt; <br>&gt; I don&#39;t accept either of those statements without seeing some analysis<br>&gt; of the use-cases.  For example, I don&#39;t believe that AnyCollection et al<br>&gt; are particularly crash-prone.  The likelihood that you&#39;ll use the wrong<br>&gt; index type with a collection is very, very low.  I&#39;m less certain of<br>&gt; what happens with Self requirements in real cases.<br>&gt; <br>&gt;&gt; Neither of those outcomes is good.<br>&gt;&gt; <br>&gt;&gt; Collection indices are a somewhat special case as there is already a<br>&gt;&gt; strong precondition that people are familiar with because it would be<br>&gt;&gt; too costly to performance and arguably too annoying to deal with an<br>&gt;&gt; Optional result in every array lookup.  IMO that is why the library is<br>&gt;&gt; able to get away with it in the current type erased AnyCollection.<br>&gt;&gt; But this is not a good model for exposing any members on an<br>&gt;&gt; existential that do not already have a strong precondition that causes<br>&gt;&gt; a trap when violated.<br>&gt;&gt; <br>&gt;&gt; I think a big reason why you maybe haven’t seen a lot of examples of<br>&gt;&gt; people writing type erased “existentials&quot; is because it is a huge pain<br>&gt;&gt; in the neck to write this stuff manually today.  People may be<br>&gt;&gt; designing around the need for them.  I haven’t seen a huge sampling of<br>&gt;&gt; type erased “existentials&quot; other people are writing but I haven’t<br>&gt;&gt; written any that introduce a trap like this.  The only traps are in<br>&gt;&gt; the “abstract&quot; base class whose methods will never be called (and<br>&gt;&gt; wouldn’t even be implemented if they could be marked abstract).<br>&gt;&gt; <br>&gt;&gt; What specific things do you think we need to be able to do that rely<br>&gt;&gt; on the compiler synthesizing a trap in the way it exposes the members<br>&gt;&gt; of the existential?<br>&gt; <br>&gt; I don&#39;t know.  I&#39;m saying, I don&#39;t think we understand the use-cases<br>&gt; well enough to make a determination.<br>&gt; <br>&gt;&gt; Here are a few examples from Austin’s proposal that safely use<br>&gt;&gt; existential collections.  I don’t understand why you think this<br>&gt;&gt; approach is insufficient.  Maybe you could supply a concrete example<br>&gt;&gt; of a use case that can’t be written with the mechanism in Austin’s<br>&gt;&gt; proposal.<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt; &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; let a : Any&lt;Collection&gt;<br>&gt;&gt; <br>&gt;&gt; // A variable whose type is the Index associated type of the underlying<br>&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt; let theIndex : a.Index = ...<br>&gt;&gt; <br>&gt;&gt; // A variable whose type is the Element associated type of the underlying<br>&gt;&gt; // concrete type of &#39;a&#39;.<br>&gt;&gt; let theElement : a.Element = ...<br>&gt;&gt; <br>&gt;&gt; // Given a mutable collection, swap its first and last items.<br>&gt;&gt; // Not a generic function. <br>&gt;&gt; func swapFirstAndLast(inout collection: Any&lt;BidirectionalMutableCollection&gt;) {<br>&gt;&gt;    // firstIndex and lastIndex both have type &quot;collection.Index&quot;<br>&gt;&gt;    guard let firstIndex = collection.startIndex,<br>&gt;&gt;        lastIndex = collection.endIndex?.predecessor(collection) where lastIndex != firstIndex else {<br>&gt;&gt;            print(&quot;Nothing to do&quot;)<br>&gt;&gt;            return<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    // oldFirstItem has type &quot;collection.Element&quot;<br>&gt;&gt;    let oldFirstItem = collection[firstIndex]<br>&gt;&gt; <br>&gt;&gt;    collection[firstIndex] = collection[lastIndex]<br>&gt;&gt;    collection[lastIndex] = oldFirstItem<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var a : Any&lt;BidirectionalMutableCollection where .Element == String&gt; = ...<br>&gt;&gt; <br>&gt;&gt; let input = &quot;West Meoley&quot;<br>&gt;&gt; <br>&gt;&gt; // Not actually necessary, since the compiler knows &quot;a.Element&quot; is String.<br>&gt;&gt; // A fully constrained anonymous associated type is synonymous with the concrete<br>&gt;&gt; // type it&#39;s forced to take on, and the two are interchangeable.<br>&gt;&gt; // However, &#39;as&#39; casting is still available if desired.<br>&gt;&gt; let anonymousInput = input as a.Element<br>&gt;&gt; <br>&gt;&gt; a[a.startIndex] = anonymousInput<br>&gt;&gt; <br>&gt;&gt; // as mentioned, this also works:<br>&gt;&gt; a[a.startIndex] = input<br>&gt;&gt; <br>&gt;&gt; // If the collection allows it, set the first element in the collection to a given string.<br>&gt;&gt; func setFirstElementIn(inout collection: Any&lt;Collection&gt; toString string: String) {<br>&gt;&gt;    if let element = string as? collection.Element {<br>&gt;&gt;        // At this point, &#39;element&#39; is of type &quot;collection.Element&quot;<br>&gt;&gt;        collection[collection.startIndex] = element<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; Neither of these look like they actually make *use* of the fact that<br>&gt; there&#39;s type erasure involved (and therefore should probably be written<br>&gt; as generics?).  The interesting cases with Any&lt;Collection...&gt;, for the<br>&gt; purposes of this discussion, arise when you have multiple instances of<br>&gt; the same existential type that wrap different concrete types.<br>&gt; <br>&gt; Another problem I see: in this new world, what is the model for choosing<br>&gt; whether to write a function as a protocol extension/generic, or as a<br>&gt; regular function taking existential parameters?  Given that either of<br>&gt; the above could have been written either way, we need to be able to<br>&gt; answer that question.  When existentials don&#39;t conform to their<br>&gt; protocols, it seems to me that the most general thing to do is use<br>&gt; existentials whenever you can, and only resort to using generics when<br>&gt; forced by the type system.  This does not seem like a particularly good<br>&gt; programming model to me, but I might be convinced otherwise.<br>&gt; <br>&gt; Anyway, my overall point is that this all seems like something we *can*<br>&gt; do and that nicely fills gaps in the type system, but not necessarily<br>&gt; something we *should* do until we better understand what it&#39;s actually<br>&gt; *for* and how it affects the programming model.<br>&gt; <br></p><p>playing with a different syntax.<br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p>what’s missing is the syntax for opening such that it is possible to deal safely with the underlying concrete type (e.g. when dealing with 2 Equatable). But Doug had a nice strawman that can be streamlined.<br></p><p><br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/d55b8861/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
