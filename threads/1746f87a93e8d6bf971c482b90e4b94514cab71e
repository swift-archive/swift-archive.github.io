<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80cc9ac2aefba975bdbf2881e3df8238?s=50"></div><header><strong>Idea: Allow/require &quot;let&quot; in property setter name declarations</strong> from <string>Ian Partridge</string> &lt;ipartridge at gmail.com&gt;<p>May  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Currently, the syntax for explicitly naming property setters is:<br></p><p>class Square {<br>  var sideLength: Double = 0.0<br></p><p>  var perimeter: Double {<br>    get {<br>      return sideLength * 4.0<br>    }<br>    set(newPerimeter) { // declares newPerimeter parameter, &quot;let&quot; not<br>allowed<br>      sideLength = newPerimeter / 4.0<br>    }<br>  }<br>}<br></p><p>Compare this with how extraction of associated values from enumerations<br>looks:<br></p><p>enum ServerResponse {<br>  case Failure(String)<br>  case Result(Int)<br>}<br>let response = ServerResponse.Result(404)<br></p><p>switch response {<br>case .Failure(let reason): // let is required here<br>  print(reason)<br>case .Result(let code):<br>  print(code)<br>}<br></p><p>For consistency, would it be better to allow/require:<br></p><p>class Square {<br>  var sideLength: Double = 0.0<br></p><p>  var perimeter: Double {<br>    get {<br>      return sideLength * 4.0<br>    }<br>    set(*let* newPerimeter) {  // declares newPerimeter parameter<br>        sideLength = newPerimeter / 4.0<br>    }<br>  }<br>}<br></p><p>The idea would apply to didSet{} and willSet{} too.<br></p><p>-- <br>Ian Partridge<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/1746b71e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Idea: Allow/require &quot;let&quot; in property setter name declarations</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Actually a setter has more in common with a function, in which case the let implicit, the difference is that a setters type is also implicit. In fact, you don’t even need to specify a name in a setter at all, as the default is newValue and you can just use that.<br></p><p>I’m more curious whether we even need a named new value at all, or if setters should just look like the following instead:<br></p><p>	set { sideLength = $0 / 4.0 }<br></p><p>As this would be more consistent with anonymous closure arguments, rather than using newValue which is arbitrary. I’ve never encountered an occasion where I’ve needed a custom name, and I only use external vs internal names on functions where I can make an external name that flows better, but perhaps doesn’t mesh with my other internal variable names.<br></p><p>&gt; On 6 May 2016, at 12:09, Ian Partridge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, the syntax for explicitly naming property setters is:<br>&gt; <br>&gt; class Square {<br>&gt;   var sideLength: Double = 0.0<br>&gt; <br>&gt;   var perimeter: Double {<br>&gt;     get {<br>&gt;       return sideLength * 4.0<br>&gt;     }<br>&gt;     set(newPerimeter) { // declares newPerimeter parameter, &quot;let&quot; not allowed<br>&gt;       sideLength = newPerimeter / 4.0<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Compare this with how extraction of associated values from enumerations looks:<br>&gt; <br>&gt; enum ServerResponse {<br>&gt;   case Failure(String)<br>&gt;   case Result(Int)<br>&gt; }<br>&gt; let response = ServerResponse.Result(404)<br>&gt; <br>&gt; switch response {<br>&gt; case .Failure(let reason): // let is required here<br>&gt;   print(reason)<br>&gt; case .Result(let code):<br>&gt;   print(code)<br>&gt; }<br>&gt; <br>&gt; For consistency, would it be better to allow/require:<br>&gt; <br>&gt; class Square {<br>&gt;   var sideLength: Double = 0.0<br>&gt; <br>&gt;   var perimeter: Double {<br>&gt;     get {<br>&gt;       return sideLength * 4.0<br>&gt;     }<br>&gt;     set(let newPerimeter) {  // declares newPerimeter parameter<br>&gt;         sideLength = newPerimeter / 4.0<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The idea would apply to didSet{} and willSet{} too.<br>&gt; <br>&gt; -- <br>&gt; Ian Partridge<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/dd162e21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>Idea: Allow/require &quot;let&quot; in property setter name declarations</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>May  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Comments below<br></p><p>&gt; Am 06.05.2016 um 13:48 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Actually a setter has more in common with a function, in which case the let implicit, the difference is that a setters type is also implicit. In fact, you don’t even need to specify a name in a setter at all, as the default is newValue and you can just use that.<br>&gt; <br>&gt; I’m more curious whether we even need a named new value at all, or if setters should just look like the following instead:<br>&gt; <br>&gt; 	set { sideLength = $0 / 4.0 }<br></p><p>This is great!<br>Why not have the opportunity to name the variable like in closures, but have it default to $0:<br></p><p>class Square {<br>  var sideLength: Double = 0.0<br>  var perimeter: Double {<br>    set { newPerimeter in<br>      sideLength = newPerimeter / 4.0<br>    }<br>  }<br>}<br></p><p>&gt; <br>&gt; As this would be more consistent with anonymous closure arguments, rather than using newValue which is arbitrary. I’ve never encountered an occasion where I’ve needed a custom name, and I only use external vs internal names on functions where I can make an external name that flows better, but perhaps doesn’t mesh with my other internal variable names.<br>&gt; <br>&gt;&gt; On 6 May 2016, at 12:09, Ian Partridge via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, the syntax for explicitly naming property setters is:<br>&gt;&gt; <br>&gt;&gt; class Square {<br>&gt;&gt;   var sideLength: Double = 0.0<br>&gt;&gt; <br>&gt;&gt;   var perimeter: Double {<br>&gt;&gt;     get {<br>&gt;&gt;       return sideLength * 4.0<br>&gt;&gt;     }<br>&gt;&gt;     set(newPerimeter) { // declares newPerimeter parameter, &quot;let&quot; not allowed<br>&gt;&gt;       sideLength = newPerimeter / 4.0<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Compare this with how extraction of associated values from enumerations looks:<br>&gt;&gt; <br>&gt;&gt; enum ServerResponse {<br>&gt;&gt;   case Failure(String)<br>&gt;&gt;   case Result(Int)<br>&gt;&gt; }<br>&gt;&gt; let response = ServerResponse.Result(404)<br>&gt;&gt; <br>&gt;&gt; switch response {<br>&gt;&gt; case .Failure(let reason): // let is required here<br>&gt;&gt;   print(reason)<br>&gt;&gt; case .Result(let code):<br>&gt;&gt;   print(code)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; For consistency, would it be better to allow/require:<br>&gt;&gt; <br>&gt;&gt; class Square {<br>&gt;&gt;   var sideLength: Double = 0.0<br>&gt;&gt; <br>&gt;&gt;   var perimeter: Double {<br>&gt;&gt;     get {<br>&gt;&gt;       return sideLength * 4.0<br>&gt;&gt;     }<br>&gt;&gt;     set(let newPerimeter) {  // declares newPerimeter parameter<br>&gt;&gt;         sideLength = newPerimeter / 4.0<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The idea would apply to didSet{} and willSet{} too.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ian Partridge<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/05a10429/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 455 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/05a10429/attachment.sig&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Idea: Allow/require &quot;let&quot; in property setter name declarations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  6, 2016 at 06:00:00pm</p></header><div class="content"><p>On May 6, 2016, at 4:09 AM, Ian Partridge via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Currently, the syntax for explicitly naming property setters is:<br>&gt; <br>&gt;     set(newPerimeter) { // declares newPerimeter parameter, &quot;let&quot; not allowed<br>&gt;       sideLength = newPerimeter / 4.0<br>&gt;     }<br>&gt; Compare this with how extraction of associated values from enumerations looks:<br>&gt; <br>&gt; switch response {<br>&gt; case .Failure(let reason): // let is required here<br>&gt;   print(reason)<br>&gt; case .Result(let code):<br>&gt;   print(code)<br>&gt; }<br></p><p>I understand what you’re saying, and this would be a logical direction for ML or Haskell, which use patterns for their parameter grammars.  In Swift, function parameters (including setter parameters, subscript indexes, etc) do not allow the general pattern matching or destructuring grammar that you can use in ‘case’ patterns, and thus you don’t have to write:<br></p><p>func f(let x : Int) {}<br></p><p>This is one of the reasons that led to SE-0003.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/5da5be50/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
