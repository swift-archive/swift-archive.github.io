<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br></p><p>I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for “FloatingPointRoundingRule”, “FloatingPointClassification” and “FloatingPointSign”. They would probably be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br></p><p>so to summarise, newly legal would be:<br></p><p>class MyClass {<br></p><p>    protocol Delegate {<br>    }<br>}<br></p><p>and also:<br></p><p>protocol MyProto {<br></p><p>    enum SomeValue {<br>    }<br></p><p>    protocol Delegate {<br>        associatedType ExpectedContent<br></p><p>	func receive(_: ExpectedContent, for: SomeValue)<br></p><p>        protocol SecondaryTarget {<br>            func receive(_ : ExpectedContent)<br>        }<br>    }<br>}<br></p><p>When conforming to a nested protocol, you can just use the name of the protocol:<br></p><p>class Host : MyProto.Delegate {<br>}<br></p><p>Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example — MyClass.Delegate):<br></p><p>class SecondaryProcessor : Host.SecondaryTarget {<br>}<br></p><p>If we’re good with this, I’ll write up a proposal.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e6aaafc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I like it!<br></p><p>I haven’t thought through the ramifications regarding associated types yet<br>though.<br></p><p>Is your vision that each conforming type would have to provide its own<br>nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: … {<br>    enum RoundingRule {<br>        // Do I put an implementation here?<br>    }<br>}<br></p><p>Nevin<br></p><p><br></p><p>On Mon, Oct 17, 2016 at 1:59 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was just doing some googling, turns out there was a discussion about<br>&gt; nesting protocols in other types that seemed to go positively a long time<br>&gt; ago: https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160425/016074.html<br>&gt;<br>&gt; I would additionally like to propose that protocols be allowed to contain<br>&gt; nested types (including other protocols). Relevant ABI issue is that the<br>&gt; standard library contains enums for “FloatingPointRoundingRule”,<br>&gt; “FloatingPointClassification” and “FloatingPointSign”. They would probably<br>&gt; be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br>&gt;<br>&gt; so to summarise, newly legal would be:<br>&gt;<br>&gt; class MyClass {<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; and also:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;<br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt;<br>&gt; func receive(_: ExpectedContent, for: SomeValue)<br>&gt;<br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; When conforming to a nested protocol, you can just use the name of the<br>&gt; protocol:<br>&gt;<br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt;<br>&gt; Except if a protocol in the chain has associated types, then you must use<br>&gt; a concrete, conforming type instead (as you would in the first example —<br>&gt; MyClass.Delegate):<br>&gt;<br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt;<br>&gt; If we’re good with this, I’ll write up a proposal.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/6be960eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 17 Oct 2016, at 20:13, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like it!<br>&gt; <br>&gt; I haven’t thought through the ramifications regarding associated types yet though.<br>&gt; <br></p><p>Associated types are tricky. The example I gave maybe wasn’t the most practical, as to use it you’d have to write something like:<br></p><p>class A&lt;T&gt; : MyProto where T : A.Delegate, T.ExpectedContent == String {}<br></p><p>which then locks you to using one static type for your delegate. Moving the associatedType up a level to MyProto means we would implement it by writing:<br></p><p>class A : MyProto {<br>    typealias ExpectedContent = String<br></p><p>    var delegate : A.Delegate<br></p><p>    func notify() {<br>        delegate.receive(“a string”, for: .someCase)<br>    }<br>}<br></p><p>class B : MyProto {<br>    typealias ExpectedContent = Int<br></p><p>    var delegate : B.Delegate<br></p><p>    func notify() {<br>        delegate.receive(42, for: .someCase)<br>    }<br>}<br></p><p>Still, I think the general answer to protocols with associated types for this case is: “use a concrete type in its place”.<br></p><p>&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt; <br>&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt; <br>&gt; protocol FloatingPoint: … {<br>&gt;     enum RoundingRule {<br>&gt;         // Do I put an implementation here?<br>&gt;     }<br>&gt; }<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>    protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>    associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>    enum RoundingRule : _RoundingRule {<br>        func round(_ val: Float) -&gt; Float {<br>            /* switch self, perform rounding… */ <br>        }<br>    }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br></p><p>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Oct 17, 2016 at 1:59 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br>&gt; <br>&gt; I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for “FloatingPointRoundingRule”, “FloatingPointClassification” and “FloatingPointSign”. They would probably be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br>&gt; <br>&gt; so to summarise, newly legal would be:<br>&gt; <br>&gt; class MyClass {<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; and also:<br>&gt; <br>&gt; protocol MyProto {<br>&gt; <br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt; <br>&gt; 	func receive(_: ExpectedContent, for: SomeValue)<br>&gt; <br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; When conforming to a nested protocol, you can just use the name of the protocol:<br>&gt; <br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt; <br>&gt; Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example — MyClass.Delegate):<br>&gt; <br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt; <br>&gt; If we’re good with this, I’ll write up a proposal.<br>&gt; <br>&gt; - Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e9d384a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>     <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>  <br>    struct InnerType {}<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: … {<br>    enum RoundingRule {<br>        // Do I put an implementation here?<br>    }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>    protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>    associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>    enum RoundingRule : _RoundingRule {<br>        func round(_ val: Float) -&gt; Float {<br>            /* switch self, perform rounding… */ <br>        }<br>    }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/3eb62232/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 03:00:00am</p></header><div class="content"><p>I had a go at writing this up formally:<br></p><p>https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622 &lt;https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622&gt;<br></p><p>Is there anything I missed?<br></p><p>- Karl<br></p><p>&gt; On 17 Oct 2016, at 20:44, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt; <br>&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt; <br>&gt; protocol ProtocolName {<br>&gt;      <br>&gt;     associatedtype AssociatedType<br>&gt; }<br>&gt; <br>&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;   <br>&gt;     struct InnerType {}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt; <br>&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;     enum RoundingRule {<br>&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt; <br>&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/946454b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 03:00:00am</p></header><div class="content"><p>Hi Karl,<br></p><p>I just saw your draft after sending my first reply earlier; I posted some additional comments on the gist.<br></p><p>Also I remembered that Jordan Rose and I were talking about this recently in the context of the ClangImporter, so I&#39;m CCing him in case he wants to share some thoughts.<br></p><p>&gt; On Oct 21, 2016, at 6:21 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I had a go at writing this up formally:<br>&gt; <br>&gt; https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622 &lt;https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622&gt;<br>&gt; <br>&gt; Is there anything I missed?<br>&gt; <br>&gt; - Karl<br>&gt; <br>&gt;&gt; On 17 Oct 2016, at 20:44, Adrian Zubarev &lt;adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt; <br>&gt;&gt; protocol ProtocolName {<br>&gt;&gt;      <br>&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;   <br>&gt;&gt;     struct InnerType {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d9cd1ceb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October 21, 2016 at 08:00:00pm</p></header><div class="content"><p>But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt; <br>&gt; protocol ProtocolName {<br>&gt;      <br>&gt;     associatedtype AssociatedType<br>&gt; }<br>&gt; <br>&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;   <br>&gt;     struct InnerType {}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt; <br>&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;     enum RoundingRule {<br>&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt; <br>&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/4761fff2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt; <br>&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>&gt; <br>&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt; <br>&gt;&gt; protocol ProtocolName {<br>&gt;&gt;      <br>&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;   <br>&gt;&gt;     struct InnerType {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/b4c90281/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br>&gt; <br>&gt; You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br>&gt; <br>&gt; struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br>&gt; <br>&gt; let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that’s wrong. I got confused for a second. You’re right; it would have to be a private type.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol ProtocolName {<br>&gt;&gt;&gt;      <br>&gt;&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;     struct InnerType {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/e2e8b9d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br>&gt;&gt; <br>&gt;&gt; You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br>&gt;&gt; <br>&gt;&gt; struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br>&gt;&gt; <br>&gt;&gt; let _ = MyValue&lt;Int&gt;().InnerType()<br>&gt; <br>&gt; No, wait - sorry, that’s wrong. I got confused for a second. You’re right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That’s consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist 👍 ProtocolName.InnerType isn’t really very meaningful otherwise.<br></p><p>- Karl<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol ProtocolName {<br>&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;     struct InnerType {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FloatingPoint: … {<br>&gt;&gt;&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;&gt;&gt;             /* switch self, perform rounding… */ <br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/f59b3e8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 22, 2016 at 10:00:00am</p></header><div class="content"><p>First of all, thank you for writing the formal proposal.<br></p><p>To begin with, I’d like to remember you that type nesting is not only done through nesting types directly in concrete types. A commonly used pattern to reduce clustering is nesting inside extensions:<br></p><p>extension TypeName {<br>     <br>    class InnerTypeName { … }<br>}<br>Next up:<br></p><p>protocol Outer {<br>     protocol Inner {<br>         associatedtype Huh // why would you do this?<br>     }<br>}<br>I disagree with this: why would you want to restrict this?<br></p><p>The Outer protocol might be simple by the inner protocol is not. If you’d move the associatedtype Huh into Outer protocol you’d automatically break the intended simplicity of the Outer protocol.<br></p><p>The following example is kept simple just to show that the outer protocol is in our case intended to be simple where the inner is not.<br></p><p>protocol Building {<br>     <br>    protocol Room {<br></p><p>        associatedtype Person<br>    }<br></p><p>    var numberOfRooms: Int { get }<br>}<br></p><p>struct Pupil {}<br>struct Student {}<br></p><p>struct University : Building {<br>     <br>    let numberOfRooms: Int = 1000<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Student<br>    }<br>}<br></p><p>struct School : Building {<br>     <br>    let numberOfRooms: Int = 100<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Pupil<br>    }<br>}<br></p><p>let buildings: [Building] = [University(), School()] // fine because `Building` is simple<br>The inner types in this example are different from each other, but this wasn’t the main point anyways.<br></p><p>Unless this restriction would have other technical reasons than “It is hard to think of a valid reason why a nested protocol might want to be more generic than its parent”, I’m against it.<br></p><p>At the very beginning I said that nesting is also done through extensions. Let’s rewrite the above example from your draft that way and see what we good.<br></p><p>protocol Outer {} // Simple<br></p><p>extension Outer {<br>     <br>    // Complex<br>    protocol Inner {<br>     associatedtype Huh // why would you do this?<br>  }<br>}<br></p><p>// new name spacing `Outer.Inner`<br>From this perspective it’s much clearer now that the Outer protocol type in out case is intended to be simple.<br></p><p>About associatedtypes with extensions:<br></p><p>In Swift 3.0 this code compiles:<br></p><p>public class Class {}<br></p><p>public protocol Outer {<br>    associatedtype AAA : Class<br>}<br></p><p>extension Outer {<br>    public typealias AAA = Int<br>}<br>This does mean that the associatedtype is lost in extensions and can be reused as an inner type for nesting. This also means that the inner type wouldn’t be able to capture the associatedtype from the outer type and might be simple.<br></p><p>protocol Outer {<br></p><p>   associatedtype AAA<br>}<br></p><p>extension Outer {<br>    protocol Inner {} // Simple because nesting from within extensions seems to ignore the associatedtype from the `Outer` type<br>}<br>You can compare this to todays workarounds where you only want to create a nice name space but want to keep the inner type simple.<br></p><p>// Implementation artifact<br>protocol _Inner {} // simple<br></p><p>// Complex<br>protocol Outer {<br>    associatedtype Anything<br>}<br></p><p>extension Outer {<br>    typealias Inner = _Inner<br>}<br></p><p>// Free to use `Outer.Inner`<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 04:18:25, Karl (razielim at gmail.com) schrieb:<br></p><p><br>On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br></p><p>But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that’s wrong. I got confused for a second. You’re right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That’s consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist 👍 ProtocolName.InnerType isn’t really very meaningful otherwise.<br></p><p>- Karl<br></p><p><br></p><p><br>On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>      <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>   <br>    struct InnerType {}<br>}<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: … {<br>    enum RoundingRule {<br>        // Do I put an implementation here?<br>    }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>    protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>    associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>    enum RoundingRule : _RoundingRule {<br>        func round(_ val: Float) -&gt; Float {<br>            /* switch self, perform rounding… */ <br>        }<br>    }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/cda025e6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 22, 2016 at 11:00:00am</p></header><div class="content"><p>There are a few more things I forget to mention in my previous post.<br></p><p>Consider these examples:<br></p><p>public protocol A {<br>    protocol B {}<br>}<br></p><p>// means A.B is public<br></p><p>extension A {<br>    protocol C {}<br>}<br></p><p>// means `A.C` is internal<br>Without extensions this wouldn’t be possible. This flexibility must exist, because we don’t allow access modifier inside protocols.<br></p><p>Plus it’s interesting to see what we could build with constrained extensions.<br></p><p>protocol Proto {}<br></p><p>extension Proto where Self : SomethingElse {<br>     <br>      class Inner {}<br>}<br>And the last but not least. I already started a topic about the inconsistency of public/open access modifier to protocols. I my world I think this should be possible:<br></p><p>public class Something {<br>     <br>    open protocol Delegate { … }<br>     <br>    public protocol Interface { … }<br>}<br>In a different module it’s possible to use the Something class but you cannot subclass it.<br></p><p>We should be able to conform in a different module to Something.Delegate.<br></p><p>We cannot conform to Something.Interface, but can use it as an interface for a specific purpose.<br></p><p><br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 10:14:17, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>First of all, thank you for writing the formal proposal.<br></p><p>To begin with, I’d like to remember you that type nesting is not only done through nesting types directly in concrete types. A commonly used pattern to reduce clustering is nesting inside extensions:<br></p><p>extension TypeName {<br>      <br>    class InnerTypeName { … }<br>}<br>Next up:<br></p><p>protocol Outer {<br>     protocol Inner {<br>         associatedtype Huh // why would you do this?<br>     }<br>}<br>I disagree with this: why would you want to restrict this?<br></p><p>The Outer protocol might be simple by the inner protocol is not. If you’d move the associatedtype Huh into Outer protocol you’d automatically break the intended simplicity of the Outer protocol.<br></p><p>The following example is kept simple just to show that the outer protocol is in our case intended to be simple where the inner is not.<br></p><p>protocol Building {<br>      <br>    protocol Room {<br></p><p>        associatedtype Person<br>    }<br></p><p>    var numberOfRooms: Int { get }<br>}<br></p><p>struct Pupil {}<br>struct Student {}<br></p><p>struct University : Building {<br>      <br>    let numberOfRooms: Int = 1000<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Student<br>    }<br>}<br></p><p>struct School : Building {<br>      <br>    let numberOfRooms: Int = 100<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Pupil<br>    }<br>}<br></p><p>let buildings: [Building] = [University(), School()] // fine because `Building` is simple<br>The inner types in this example are different from each other, but this wasn’t the main point anyways.<br></p><p>Unless this restriction would have other technical reasons than “It is hard to think of a valid reason why a nested protocol might want to be more generic than its parent”, I’m against it.<br></p><p>At the very beginning I said that nesting is also done through extensions. Let’s rewrite the above example from your draft that way and see what we good.<br></p><p>protocol Outer {} // Simple<br></p><p>extension Outer {<br>      <br>    // Complex<br>    protocol Inner {<br>     associatedtype Huh // why would you do this?<br>  }<br>}<br></p><p>// new name spacing `Outer.Inner`<br>From this perspective it’s much clearer now that the Outer protocol type in out case is intended to be simple.<br></p><p>About associatedtypes with extensions:<br></p><p>In Swift 3.0 this code compiles:<br></p><p>public class Class {}<br></p><p>public protocol Outer {<br>    associatedtype AAA : Class<br>}<br></p><p>extension Outer {<br>    public typealias AAA = Int<br>}<br>This does mean that the associatedtype is lost in extensions and can be reused as an inner type for nesting. This also means that the inner type wouldn’t be able to capture the associatedtype from the outer type and might be simple.<br></p><p>protocol Outer {<br></p><p>   associatedtype AAA<br>}<br></p><p>extension Outer {<br>    protocol Inner {} // Simple because nesting from within extensions seems to ignore the associatedtype from the `Outer` type<br>}<br>You can compare this to todays workarounds where you only want to create a nice name space but want to keep the inner type simple.<br></p><p>// Implementation artifact<br>protocol _Inner {} // simple<br></p><p>// Complex<br>protocol Outer {<br>    associatedtype Anything<br>}<br></p><p>extension Outer {<br>    typealias Inner = _Inner<br>}<br></p><p>// Free to use `Outer.Inner`<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 04:18:25, Karl (razielim at gmail.com) schrieb:<br></p><p><br>On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br></p><p>But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn’t always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there’s a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that’s wrong. I got confused for a second. You’re right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That’s consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist 👍 ProtocolName.InnerType isn’t really very meaningful otherwise.<br></p><p>- Karl<br></p><p><br></p><p><br>On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>       <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>    <br>    struct InnerType {}<br>}<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: … {<br>    enum RoundingRule {<br>        // Do I put an implementation here?<br>    }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>    protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>    associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>    enum RoundingRule : _RoundingRule {<br>        func round(_ val: Float) -&gt; Float {<br>            /* switch self, perform rounding… */ <br>        }<br>    }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used “Super” here).<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/2595b30d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Two weeks ago there was a similar pitch here https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon–20161003/027643.html<br></p><p>In general I’m in favor of this feature, but I don’t know any technical issues this might have or does already have.<br></p><p>As I said in the other thread.<br></p><p>I’m for nested everything.<br></p><p>Nested extensions to reduce noise at some point, BUT this should not remove extension A.B { … } completely.<br></p><p>class A {<br>         <br>    class B { … }<br>         <br>    extension B { … } // extends A.B<br>}<br>We already have A.B syntax for extensions, why don’t we allow it for type declarations to reduce nesting (sometimes you don’t want to cluster everything)? Basically something like class A.B { … } would be a shortcut for extension A { class B { … } } and is bounded by the access modifier of A. (This is probably additive.)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 19:59:54, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html<br></p><p>I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for “FloatingPointRoundingRule”, “FloatingPointClassification” and “FloatingPointSign”. They would probably be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br></p><p>so to summarise, newly legal would be:<br></p><p>class MyClass {<br></p><p>    protocol Delegate {<br>    }<br>}<br></p><p>and also:<br></p><p>protocol MyProto {<br></p><p>    enum SomeValue {<br>    }<br></p><p>    protocol Delegate {<br>        associatedType ExpectedContent<br></p><p>func receive(_: ExpectedContent, for: SomeValue)<br></p><p>        protocol SecondaryTarget {<br>            func receive(_ : ExpectedContent)<br>        }<br>    }<br>}<br></p><p>When conforming to a nested protocol, you can just use the name of the protocol:<br></p><p>class Host : MyProto.Delegate {<br>}<br></p><p>Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example — MyClass.Delegate):<br></p><p>class SecondaryProcessor : Host.SecondaryTarget {<br>}<br></p><p>If we’re good with this, I’ll write up a proposal.<br></p><p>- Karl<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e679fb90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I want this feature. Both class in protocol and protocol in class could<br>clean up many relationships but I think that a blocking concern is &quot;How<br>does this interact with generics?&quot; Nesting types in generic types is<br>already disallowed and how different is this feature from that?<br></p><p>On Mon, Oct 17, 2016 at 2:20 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Two weeks ago there was a similar pitch here https://lists.swift.org/<br>&gt; pipermail/swift-evolution/Week-of-Mon–20161003/027643.html<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027643.html&gt;<br>&gt;<br>&gt; In general I’m in favor of this feature, but I don’t know any technical<br>&gt; issues this might have or does already have.<br>&gt;<br>&gt; As I said in the other thread.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    I’m for nested everything.<br>&gt;    -<br>&gt;<br>&gt;    Nested extensions to reduce noise at some point, BUT this should not<br>&gt;    remove extension A.B { … } completely.<br>&gt;<br>&gt;    class A {<br>&gt;<br>&gt;        class B { … }<br>&gt;<br>&gt;        extension B { … } // extends A.B<br>&gt;    }<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    We already have A.B syntax for extensions, why don’t we allow it for<br>&gt;    type declarations to reduce nesting (sometimes you don’t want to cluster<br>&gt;    everything)? Basically something like class A.B { … } would be a<br>&gt;    shortcut for extension A { class B { … } } and is bounded by the<br>&gt;    access modifier of A. (This is probably additive.)<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 17. Oktober 2016 um 19:59:54, Karl via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; I was just doing some googling, turns out there was a discussion about<br>&gt; nesting protocols in other types that seemed to go positively a long time<br>&gt; ago: https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160425/016074.html<br>&gt;<br>&gt; I would additionally like to propose that protocols be allowed to contain<br>&gt; nested types (including other protocols). Relevant ABI issue is that the<br>&gt; standard library contains enums for “FloatingPointRoundingRule”,<br>&gt; “FloatingPointClassification” and “FloatingPointSign”. They would probably<br>&gt; be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br>&gt;<br>&gt; so to summarise, newly legal would be:<br>&gt;<br>&gt; class MyClass {<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; and also:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;<br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt;<br>&gt; func receive(_: ExpectedContent, for: SomeValue)<br>&gt;<br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; When conforming to a nested protocol, you can just use the name of the<br>&gt; protocol:<br>&gt;<br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt;<br>&gt; Except if a protocol in the chain has associated types, then you must use<br>&gt; a concrete, conforming type instead (as you would in the first example —<br>&gt; MyClass.Delegate):<br>&gt;<br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt;<br>&gt; If we’re good with this, I’ll write up a proposal.<br>&gt;<br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/fed334aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>That’s also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics)<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com) schrieb:<br></p><p>I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/7eeff7e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 17 Oct 2016, at 20:31, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>And even partially implemented, behind the flag “-enable-experimental-nested-generic-types”. I don’t know what’s missing from it, but it seemed to work in some simple cases last time I tried.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/475a2f78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 11:35 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 17 Oct 2016, at 20:31, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That’s also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; And even partially implemented, behind the flag “-enable-experimental-nested-generic-types”. I don’t know what’s missing from it, but it seemed to work in some simple cases last time I tried.<br></p><p>This flag implements nesting non-protocol generic types inside other non-protocol generic types, except for some bugs I need to fix before I can just enable this all by default.<br></p><p>However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br></p><p>The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br></p><p>If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br></p><p>struct A&lt;T&gt; {<br>  protocol P {<br>    func requirement() -&gt; T<br>  }<br>}<br></p><p>Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br></p><p>The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br></p><p>protocol P {<br>  associatedtype A<br></p><p>  struct T {<br>    var value: A<br>  }<br>}<br></p><p>Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br></p><p>Protocols nested inside protocols also have the same issue.<br></p><p>Also note that even with the experimental flag, generic types nested inside generic *functions* are not supported either. Here, again, the difficulty is with captured generic parameters. The semantics are clear but the implementation needs some work.<br></p><p>Slava<br></p><p>&gt; <br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d4548136/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br>&gt; <br>&gt; The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt; <br>&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br>&gt; <br>&gt; struct A&lt;T&gt; {<br>&gt;   protocol P {<br>&gt;     func requirement() -&gt; T<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br>&gt; <br>&gt; The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A<br>&gt; <br>&gt;   struct T {<br>&gt;     var value: A<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt; <br>&gt; Protocols nested inside protocols also have the same issue.<br></p><p>FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br></p><p>Here’s a real life example pared down. I wish I could do this:<br></p><p>    public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br></p><p>      public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>        ...<br>      }<br></p><p>      public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>        case error<br>        case skip<br>        case skipIfOutputTypeMatches<br>      }<br></p><p>    }<br></p><p>InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br></p><p>What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br></p><p>Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br></p><p>    public struct S&lt;T&gt; {<br>      public enum Foo {<br>        case yin<br>        case yang<br>      }<br>    }<br></p><p>…but this wouldn’t:<br></p><p>    public struct S&lt;T&gt; {<br>      public enum Foo {<br>        case yin(thing: T)  // capture of T illegal (for now)<br>        case yang<br>      }<br>    }<br></p><p>Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br>&gt;&gt; <br>&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt; <br>&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br>&gt;&gt; <br>&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;  protocol P {<br>&gt;&gt;    func requirement() -&gt; T<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br>&gt;&gt; <br>&gt;&gt; The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  associatedtype A<br>&gt;&gt; <br>&gt;&gt;  struct T {<br>&gt;&gt;    var value: A<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt; <br>&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt; <br>&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt; <br>&gt; Here’s a real life example pared down. I wish I could do this:<br>&gt; <br>&gt;    public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt; <br>&gt;      public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;        ...<br>&gt;      }<br>&gt; <br>&gt;      public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;        case error<br>&gt;        case skip<br>&gt;        case skipIfOutputTypeMatches<br>&gt;      }<br>&gt; <br>&gt;    }<br>&gt; <br>&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt; <br>&gt; What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt; <br>&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br>&gt; <br>&gt;    public struct S&lt;T&gt; {<br>&gt;      public enum Foo {<br>&gt;        case yin<br>&gt;        case yang<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt; …but this wouldn’t:<br>&gt; <br>&gt;    public struct S&lt;T&gt; {<br>&gt;      public enum Foo {<br>&gt;        case yin(thing: T)  // capture of T illegal (for now)<br>&gt;        case yang<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Yeah, this makes sense for a first cut at this feature.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func requirement() -&gt; T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;   var value: A<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt; <br>&gt;&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt; <br>&gt;&gt; Here’s a real life example pared down. I wish I could do this:<br>&gt;&gt; <br>&gt;&gt;   public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt; <br>&gt;&gt;     public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;       case error<br>&gt;&gt;       case skip<br>&gt;&gt;       case skipIfOutputTypeMatches<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt; <br>&gt;&gt; What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt; <br>&gt;&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br>&gt;&gt; <br>&gt;&gt;   public struct S&lt;T&gt; {<br>&gt;&gt;     public enum Foo {<br>&gt;&gt;       case yin<br>&gt;&gt;       case yang<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; …but this wouldn’t:<br>&gt;&gt; <br>&gt;&gt;   public struct S&lt;T&gt; {<br>&gt;&gt;     public enum Foo {<br>&gt;&gt;       case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;       case yang<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt; <br>&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt; <br>&gt; Slava<br></p><p>Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter “OK if no captures” approach?) Eager to help; don’t want to be in the way.<br></p><p>P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>November  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;  func requirement() -&gt; T<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;&gt;  var value: A<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a real life example pared down. I wish I could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;&gt;      case error<br>&gt;&gt;&gt;      case skip<br>&gt;&gt;&gt;      case skipIfOutputTypeMatches<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct S&lt;T&gt; {<br>&gt;&gt;&gt;    public enum Foo {<br>&gt;&gt;&gt;      case yin<br>&gt;&gt;&gt;      case yang<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …but this wouldn’t:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct S&lt;T&gt; {<br>&gt;&gt;&gt;    public enum Foo {<br>&gt;&gt;&gt;      case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;&gt;      case yang<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt;&gt; <br>&gt;&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt; <br>&gt; Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter “OK if no captures” approach?) Eager to help; don’t want to be in the way.<br></p><p>Just speaking for myself and not the whole team — I think you can submit the proposal at any time, we’re unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‘no captures’ it’s “trivial”).<br></p><p>Slava<br></p><p>&gt; <br>&gt; P<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2 Nov 2016, at 20:54, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; func requirement() -&gt; T<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;&gt;&gt; var value: A<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a real life example pared down. I wish I could do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;&gt;&gt;     case error<br>&gt;&gt;&gt;&gt;     case skip<br>&gt;&gt;&gt;&gt;     case skipIfOutputTypeMatches<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct S&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   public enum Foo {<br>&gt;&gt;&gt;&gt;     case yin<br>&gt;&gt;&gt;&gt;     case yang<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …but this wouldn’t:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct S&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   public enum Foo {<br>&gt;&gt;&gt;&gt;     case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;&gt;&gt;     case yang<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt; Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter “OK if no captures” approach?) Eager to help; don’t want to be in the way.<br>&gt; <br>&gt; Just speaking for myself and not the whole team — I think you can submit the proposal at any time, we’re unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‘no captures’ it’s “trivial”).<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; P<br></p><p><br>Sorry, let this slip. Proposal sent - https://github.com/apple/swift-evolution/pull/552<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161105/729f9fe5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>November  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Disappointed to see that you just ignored everything I pitched to you. The proposal does not cover extensions nor it it sees the problem with access modifier which it creates.<br></p><p>public protocol A {<br>     <br>    // Not allowed to use any access modifier here at all<br>    struct B {<br>        // Nor here<br>        var something: C = …<br>    }<br>}<br>Everything will be public here. Try to build a true singleton like this for example.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. November 2016 um 10:44:27, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>On 2 Nov 2016, at 20:54, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p><br>On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ’Self’ type.<br></p><p>The hard part of getting nested generics right is what to do if a nested type ‘captures’ generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br></p><p>If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‘closes over’ generic parameters of the outer type. For example,<br></p><p>struct A&lt;T&gt; {<br>protocol P {<br>func requirement() -&gt; T<br>}<br>}<br></p><p>Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ’T’?<br></p><p>The other case is problematic too — the nested type might refer to an associated type of the outer protocol:<br></p><p>protocol P {<br>associatedtype A<br></p><p>struct T {<br>var value: A<br>}<br>}<br></p><p>Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‘Self’ generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br></p><p>Protocols nested inside protocols also have the same issue.<br></p><p>FWIW, in almost all the situations where I’ve wanted to nest types inside protocols and generic types, it’s only as a namespacing convenience. Most often, it’s an enum type that’s used only by a single method, and having it at the top of the module namespace adds clutter.<br></p><p>Here’s a real life example pared down. I wish I could do this:<br></p><p>public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br></p><p>  public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>    ...<br>  }<br></p><p>  public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>    case error<br>    case skip<br>    case skipIfOutputTypeMatches<br>  }<br></p><p>}<br></p><p>InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br></p><p>What do you think about providing a “no captures” modifier for nested types — like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br></p><p>Alternatively, what if (1) outer types aren’t capture unless they’re referenced, and (2) nesting is only illegal if there’s a capture? Then my code above would compile, as would this:<br></p><p>public struct S&lt;T&gt; {<br>  public enum Foo {<br>    case yin<br>    case yang<br>  }<br>}<br></p><p>…but this wouldn’t:<br></p><p>public struct S&lt;T&gt; {<br>  public enum Foo {<br>    case yin(thing: T)  // capture of T illegal (for now)<br>    case yang<br>  }<br>}<br></p><p>Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Yeah, this makes sense for a first cut at this feature.<br></p><p>Slava<br></p><p>Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter “OK if no captures” approach?) Eager to help; don’t want to be in the way.<br></p><p>Just speaking for myself and not the whole team — I think you can submit the proposal at any time, we’re unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‘no captures’ it’s “trivial”).<br></p><p>Slava<br></p><p><br>P<br></p><p><br>Sorry, let this slip. Proposal sent - https://github.com/apple/swift-evolution/pull/552<br></p><p>- Karl<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161105/fcda828e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Extremely strong +1.<br></p><p>I’ve got a bunch of Objective-C-style really long type names of the sort “MyProtocol”, “MyProtocolSomeTypeEnum”, “MyProtocolSomeOptionsEnum”, etc. It would be really nice to make those Swiftier.<br></p><p>Charles<br></p><p>&gt; On Oct 17, 2016, at 12:59 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br>&gt; <br>&gt; I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for “FloatingPointRoundingRule”, “FloatingPointClassification” and “FloatingPointSign”. They would probably be better expressed as “FloatingPoint.RoundingRule”, “.Sign&quot;, etc.<br>&gt; <br>&gt; so to summarise, newly legal would be:<br>&gt; <br>&gt; class MyClass {<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; and also:<br>&gt; <br>&gt; protocol MyProto {<br>&gt; <br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt; <br>&gt; 	func receive(_: ExpectedContent, for: SomeValue)<br>&gt; <br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; When conforming to a nested protocol, you can just use the name of the protocol:<br>&gt; <br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt; <br>&gt; Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example — MyClass.Delegate):<br>&gt; <br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt; <br>&gt; If we’re good with this, I’ll write up a proposal.<br>&gt; <br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/0e38d986/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
