<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br></p><p>I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù, ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br></p><p>so to summarise, newly legal would be:<br></p><p>class MyClass {<br></p><p>    protocol Delegate {<br>    }<br>}<br></p><p>and also:<br></p><p>protocol MyProto {<br></p><p>    enum SomeValue {<br>    }<br></p><p>    protocol Delegate {<br>        associatedType ExpectedContent<br></p><p>	func receive(_: ExpectedContent, for: SomeValue)<br></p><p>        protocol SecondaryTarget {<br>            func receive(_ : ExpectedContent)<br>        }<br>    }<br>}<br></p><p>When conforming to a nested protocol, you can just use the name of the protocol:<br></p><p>class Host : MyProto.Delegate {<br>}<br></p><p>Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example ‚Äî MyClass.Delegate):<br></p><p>class SecondaryProcessor : Host.SecondaryTarget {<br>}<br></p><p>If we‚Äôre good with this, I‚Äôll write up a proposal.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e6aaafc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I like it!<br></p><p>I haven‚Äôt thought through the ramifications regarding associated types yet<br>though.<br></p><p>Is your vision that each conforming type would have to provide its own<br>nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: ‚Ä¶ {<br>    enum RoundingRule {<br>        // Do I put an implementation here?<br>    }<br>}<br></p><p>Nevin<br></p><p><br></p><p>On Mon, Oct 17, 2016 at 1:59 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was just doing some googling, turns out there was a discussion about<br>&gt; nesting protocols in other types that seemed to go positively a long time<br>&gt; ago: https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160425/016074.html<br>&gt;<br>&gt; I would additionally like to propose that protocols be allowed to contain<br>&gt; nested types (including other protocols). Relevant ABI issue is that the<br>&gt; standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù,<br>&gt; ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably<br>&gt; be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br>&gt;<br>&gt; so to summarise, newly legal would be:<br>&gt;<br>&gt; class MyClass {<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; and also:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;<br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt;<br>&gt; func receive(_: ExpectedContent, for: SomeValue)<br>&gt;<br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; When conforming to a nested protocol, you can just use the name of the<br>&gt; protocol:<br>&gt;<br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt;<br>&gt; Except if a protocol in the chain has associated types, then you must use<br>&gt; a concrete, conforming type instead (as you would in the first example ‚Äî<br>&gt; MyClass.Delegate):<br>&gt;<br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt;<br>&gt; If we‚Äôre good with this, I‚Äôll write up a proposal.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/6be960eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 17 Oct 2016, at 20:13, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like it!<br>&gt; <br>&gt; I haven‚Äôt thought through the ramifications regarding associated types yet though.<br>&gt; <br></p><p>Associated types are tricky. The example I gave maybe wasn‚Äôt the most practical, as to use it you‚Äôd have to write something like:<br></p><p>class A&lt;T&gt; : MyProto where T : A.Delegate, T.ExpectedContent == String {}<br></p><p>which then locks you to using one static type for your delegate. Moving the associatedType up a level to MyProto means we would implement it by writing:<br></p><p>class A : MyProto {<br>    typealias ExpectedContent = String<br></p><p>    var delegate : A.Delegate<br></p><p>    func notify() {<br>        delegate.receive(‚Äúa string‚Äù, for: .someCase)<br>    }<br>}<br></p><p>class B : MyProto {<br>    typealias ExpectedContent = Int<br></p><p>    var delegate : B.Delegate<br></p><p>    func notify() {<br>        delegate.receive(42, for: .someCase)<br>    }<br>}<br></p><p>Still, I think the general answer to protocols with associated types for this case is: ‚Äúuse a concrete type in its place‚Äù.<br></p><p>&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt; <br>&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt; <br>&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;     enum RoundingRule {<br>&gt;         // Do I put an implementation here?<br>&gt;     }<br>&gt; }<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>    protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>    associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>    enum RoundingRule : _RoundingRule {<br>        func round(_ val: Float) -&gt; Float {<br>            /* switch self, perform rounding‚Ä¶ */ <br>        }<br>    }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br></p><p>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Oct 17, 2016 at 1:59 PM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br>&gt; <br>&gt; I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù, ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br>&gt; <br>&gt; so to summarise, newly legal would be:<br>&gt; <br>&gt; class MyClass {<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; and also:<br>&gt; <br>&gt; protocol MyProto {<br>&gt; <br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt; <br>&gt; 	func receive(_: ExpectedContent, for: SomeValue)<br>&gt; <br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; When conforming to a nested protocol, you can just use the name of the protocol:<br>&gt; <br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt; <br>&gt; Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example ‚Äî MyClass.Delegate):<br>&gt; <br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt; <br>&gt; If we‚Äôre good with this, I‚Äôll write up a proposal.<br>&gt; <br>&gt; - Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e9d384a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>     <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>  <br>    struct InnerType {}<br>}<br></p><p><br>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: ‚Ä¶ {<br>¬† ¬† enum RoundingRule {<br>¬† ¬† ¬† ¬† // Do I put an implementation here?<br>¬† ¬† }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>¬† ¬† protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>¬† ¬† associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>¬† ¬† enum RoundingRule : _RoundingRule {<br>¬† ¬† ¬† ¬† func round(_ val: Float) -&gt; Float {<br>¬† ¬† ¬† ¬† ¬† ¬† /* switch self, perform rounding‚Ä¶ */¬†<br>¬† ¬† ¬† ¬† }<br>¬† ¬† }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/3eb62232/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 03:00:00am</p></header><div class="content"><p>I had a go at writing this up formally:<br></p><p>https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622 &lt;https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622&gt;<br></p><p>Is there anything I missed?<br></p><p>- Karl<br></p><p>&gt; On 17 Oct 2016, at 20:44, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt; <br>&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt; <br>&gt; protocol ProtocolName {<br>&gt;      <br>&gt;     associatedtype AssociatedType<br>&gt; }<br>&gt; <br>&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;   <br>&gt;     struct InnerType {}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt; <br>&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;     enum RoundingRule {<br>&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt; <br>&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/946454b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 03:00:00am</p></header><div class="content"><p>Hi Karl,<br></p><p>I just saw your draft after sending my first reply earlier; I posted some additional comments on the gist.<br></p><p>Also I remembered that Jordan Rose and I were talking about this recently in the context of the ClangImporter, so I&#39;m CCing him in case he wants to share some thoughts.<br></p><p>&gt; On Oct 21, 2016, at 6:21 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I had a go at writing this up formally:<br>&gt; <br>&gt; https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622 &lt;https://gist.github.com/karwa/4c6bff75f8fa84b16df2c8caae97d622&gt;<br>&gt; <br>&gt; Is there anything I missed?<br>&gt; <br>&gt; - Karl<br>&gt; <br>&gt;&gt; On 17 Oct 2016, at 20:44, Adrian Zubarev &lt;adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt; <br>&gt;&gt; protocol ProtocolName {<br>&gt;&gt;      <br>&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;   <br>&gt;&gt;     struct InnerType {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d9cd1ceb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October 21, 2016 at 08:00:00pm</p></header><div class="content"><p>But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt; <br>&gt; protocol ProtocolName {<br>&gt;      <br>&gt;     associatedtype AssociatedType<br>&gt; }<br>&gt; <br>&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;   <br>&gt;     struct InnerType {}<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; <br>&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt; <br>&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;     enum RoundingRule {<br>&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt; <br>&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt; <br>&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/4761fff2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br>&gt; <br>&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>&gt; <br>&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt; <br>&gt;&gt; protocol ProtocolName {<br>&gt;&gt;      <br>&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;   <br>&gt;&gt;     struct InnerType {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/b4c90281/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br>&gt; <br>&gt; You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br>&gt; <br>&gt; struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br>&gt; <br>&gt; let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that‚Äôs wrong. I got confused for a second. You‚Äôre right; it would have to be a private type.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol ProtocolName {<br>&gt;&gt;&gt;      <br>&gt;&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt;     struct InnerType {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/e2e8b9d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 22, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com &lt;mailto:raziel.im+swift-evo at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But what would that mean?  If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning.  In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code.  I suspect it would only work if that InnerType was mandated to be `private`.<br>&gt;&gt; <br>&gt;&gt; You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br>&gt;&gt; <br>&gt;&gt; struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br>&gt;&gt; <br>&gt;&gt; let _ = MyValue&lt;Int&gt;().InnerType()<br>&gt; <br>&gt; No, wait - sorry, that‚Äôs wrong. I got confused for a second. You‚Äôre right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That‚Äôs consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist üëç ProtocolName.InnerType isn‚Äôt really very meaningful otherwise.<br></p><p>- Karl<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That option should not be disallowed. Here is a simple example you might want to build at some point:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol ProtocolName {<br>&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;     associatedtype AssociatedType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension ProtocolName where AssociatedType == Int {<br>&gt;&gt;&gt;&gt;   <br>&gt;&gt;&gt;&gt;     struct InnerType {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or could the protocol itself define a nested type and anything could use it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FloatingPoint: ‚Ä¶ {<br>&gt;&gt;&gt;&gt;&gt;     enum RoundingRule {<br>&gt;&gt;&gt;&gt;&gt;         // Do I put an implementation here?<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you wanted something like that, you could do it with a nested protocol + associated type:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FloatingPoint {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>&gt;&gt;&gt;&gt;&gt;     associatedType RoundingRule : _RoundingRule<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct Float : FloatingPoint {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     enum RoundingRule : _RoundingRule {<br>&gt;&gt;&gt;&gt;&gt;         func round(_ val: Float) -&gt; Float {<br>&gt;&gt;&gt;&gt;&gt;             /* switch self, perform rounding‚Ä¶ */ <br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/f59b3e8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 22, 2016 at 10:00:00am</p></header><div class="content"><p>First of all, thank you for writing the formal proposal.<br></p><p>To begin with, I‚Äôd like to remember you that type nesting is not only done through nesting types directly in concrete types. A commonly used pattern to reduce clustering is nesting inside extensions:<br></p><p>extension TypeName {<br>     <br>    class InnerTypeName { ‚Ä¶ }<br>}<br>Next up:<br></p><p>protocol Outer {<br>     protocol Inner {<br>         associatedtype Huh // why would you do this?<br>     }<br>}<br>I disagree with this: why would you want to restrict this?<br></p><p>The Outer protocol might be simple by the inner protocol is not. If you‚Äôd move the associatedtype Huh into Outer protocol you‚Äôd automatically break the intended simplicity of the Outer protocol.<br></p><p>The following example is kept simple just to show that the outer protocol is in our case intended to be simple where the inner is not.<br></p><p>protocol Building {<br>     <br>    protocol Room {<br></p><p>        associatedtype Person<br>    }<br></p><p>    var numberOfRooms: Int { get }<br>}<br></p><p>struct Pupil {}<br>struct Student {}<br></p><p>struct University : Building {<br>     <br>    let numberOfRooms: Int = 1000<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Student<br>    }<br>}<br></p><p>struct School : Building {<br>     <br>    let numberOfRooms: Int = 100<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Pupil<br>    }<br>}<br></p><p>let buildings: [Building] = [University(), School()] // fine because `Building` is simple<br>The inner types in this example are different from each other, but this wasn‚Äôt the main point anyways.<br></p><p>Unless this restriction would have other technical reasons than ‚ÄúIt is hard to think of a valid reason why a nested protocol might want to be more generic than its parent‚Äù, I‚Äôm against it.<br></p><p>At the very beginning I said that nesting is also done through extensions. Let‚Äôs rewrite the above example from your draft that way and see what we good.<br></p><p>protocol Outer {} // Simple<br></p><p>extension Outer {<br>     <br>    // Complex<br>    protocol Inner {<br>     associatedtype Huh // why would you do this?<br>  }<br>}<br></p><p>// new name spacing `Outer.Inner`<br>From this perspective it‚Äôs much clearer now that the Outer protocol type in out case is intended to be simple.<br></p><p>About associatedtypes with extensions:<br></p><p>In Swift 3.0 this code compiles:<br></p><p>public class Class {}<br></p><p>public protocol Outer {<br>    associatedtype AAA : Class<br>}<br></p><p>extension Outer {<br>    public typealias AAA = Int<br>}<br>This does mean that the associatedtype is lost in extensions and can be reused as an inner type for nesting. This also means that the inner type wouldn‚Äôt be able to capture the associatedtype from the outer type and might be simple.<br></p><p>protocol Outer {<br></p><p>   associatedtype AAA<br>}<br></p><p>extension Outer {<br>    protocol Inner {} // Simple because nesting from within extensions seems to ignore the associatedtype from the `Outer` type<br>}<br>You can compare this to todays workarounds where you only want to create a nice name space but want to keep the inner type simple.<br></p><p>// Implementation artifact<br>protocol _Inner {} // simple<br></p><p>// Complex<br>protocol Outer {<br>    associatedtype Anything<br>}<br></p><p>extension Outer {<br>    typealias Inner = _Inner<br>}<br></p><p>// Free to use `Outer.Inner`<br></p><p><br>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 04:18:25, Karl (razielim at gmail.com) schrieb:<br></p><p><br>On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br></p><p>But what would that mean? ¬†If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning. ¬†In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code. ¬†I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that‚Äôs wrong. I got confused for a second. You‚Äôre right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That‚Äôs consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist üëç ProtocolName.InnerType isn‚Äôt really very meaningful otherwise.<br></p><p>- Karl<br></p><p><br></p><p><br>On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>      <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>   <br>    struct InnerType {}<br>}<br></p><p><br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: ‚Ä¶ {<br>¬† ¬† enum RoundingRule {<br>¬† ¬† ¬† ¬† // Do I put an implementation here?<br>¬† ¬† }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>¬† ¬† protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>¬† ¬† associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>¬† ¬† enum RoundingRule : _RoundingRule {<br>¬† ¬† ¬† ¬† func round(_ val: Float) -&gt; Float {<br>¬† ¬† ¬† ¬† ¬† ¬† /* switch self, perform rounding‚Ä¶ */¬†<br>¬† ¬† ¬† ¬† }<br>¬† ¬† }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/cda025e6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 22, 2016 at 11:00:00am</p></header><div class="content"><p>There are a few more things I forget to mention in my previous post.<br></p><p>Consider these examples:<br></p><p>public protocol A {<br>    protocol B {}<br>}<br></p><p>// means A.B is public<br></p><p>extension A {<br>    protocol C {}<br>}<br></p><p>// means `A.C` is internal<br>Without extensions this wouldn‚Äôt be possible. This flexibility must exist, because we don‚Äôt allow access modifier inside protocols.<br></p><p>Plus it‚Äôs interesting to see what we could build with constrained extensions.<br></p><p>protocol Proto {}<br></p><p>extension Proto where Self : SomethingElse {<br>     <br>      class Inner {}<br>}<br>And the last but not least. I already started a topic about the inconsistency of public/open access modifier to protocols. I my world I think this should be possible:<br></p><p>public class Something {<br>     <br>    open protocol Delegate { ‚Ä¶ }<br>     <br>    public protocol Interface { ‚Ä¶ }<br>}<br>In a different module it‚Äôs possible to use the Something class but you cannot subclass it.<br></p><p>We should be able to conform in a different module to Something.Delegate.<br></p><p>We cannot conform to Something.Interface, but can use it as an interface for a specific purpose.<br></p><p><br></p><p><br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 10:14:17, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>First of all, thank you for writing the formal proposal.<br></p><p>To begin with, I‚Äôd like to remember you that type nesting is not only done through nesting types directly in concrete types. A commonly used pattern to reduce clustering is nesting inside extensions:<br></p><p>extension TypeName {<br>      <br>    class InnerTypeName { ‚Ä¶ }<br>}<br>Next up:<br></p><p>protocol Outer {<br>     protocol Inner {<br>         associatedtype Huh // why would you do this?<br>     }<br>}<br>I disagree with this: why would you want to restrict this?<br></p><p>The Outer protocol might be simple by the inner protocol is not. If you‚Äôd move the associatedtype Huh into Outer protocol you‚Äôd automatically break the intended simplicity of the Outer protocol.<br></p><p>The following example is kept simple just to show that the outer protocol is in our case intended to be simple where the inner is not.<br></p><p>protocol Building {<br>      <br>    protocol Room {<br></p><p>        associatedtype Person<br>    }<br></p><p>    var numberOfRooms: Int { get }<br>}<br></p><p>struct Pupil {}<br>struct Student {}<br></p><p>struct University : Building {<br>      <br>    let numberOfRooms: Int = 1000<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Student<br>    }<br>}<br></p><p>struct School : Building {<br>      <br>    let numberOfRooms: Int = 100<br></p><p>    struct Room : Building.Room {<br></p><p>        typealias Person = Pupil<br>    }<br>}<br></p><p>let buildings: [Building] = [University(), School()] // fine because `Building` is simple<br>The inner types in this example are different from each other, but this wasn‚Äôt the main point anyways.<br></p><p>Unless this restriction would have other technical reasons than ‚ÄúIt is hard to think of a valid reason why a nested protocol might want to be more generic than its parent‚Äù, I‚Äôm against it.<br></p><p>At the very beginning I said that nesting is also done through extensions. Let‚Äôs rewrite the above example from your draft that way and see what we good.<br></p><p>protocol Outer {} // Simple<br></p><p>extension Outer {<br>      <br>    // Complex<br>    protocol Inner {<br>     associatedtype Huh // why would you do this?<br>  }<br>}<br></p><p>// new name spacing `Outer.Inner`<br>From this perspective it‚Äôs much clearer now that the Outer protocol type in out case is intended to be simple.<br></p><p>About associatedtypes with extensions:<br></p><p>In Swift 3.0 this code compiles:<br></p><p>public class Class {}<br></p><p>public protocol Outer {<br>    associatedtype AAA : Class<br>}<br></p><p>extension Outer {<br>    public typealias AAA = Int<br>}<br>This does mean that the associatedtype is lost in extensions and can be reused as an inner type for nesting. This also means that the inner type wouldn‚Äôt be able to capture the associatedtype from the outer type and might be simple.<br></p><p>protocol Outer {<br></p><p>   associatedtype AAA<br>}<br></p><p>extension Outer {<br>    protocol Inner {} // Simple because nesting from within extensions seems to ignore the associatedtype from the `Outer` type<br>}<br>You can compare this to todays workarounds where you only want to create a nice name space but want to keep the inner type simple.<br></p><p>// Implementation artifact<br>protocol _Inner {} // simple<br></p><p>// Complex<br>protocol Outer {<br>    associatedtype Anything<br>}<br></p><p>extension Outer {<br>    typealias Inner = _Inner<br>}<br></p><p>// Free to use `Outer.Inner`<br></p><p><br>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Oktober 2016 um 04:18:25, Karl (razielim at gmail.com) schrieb:<br></p><p><br>On 22 Oct 2016, at 04:12, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:07, Karl &lt;raziel.im+swift-evo at gmail.com&gt; wrote:<br></p><p><br>On 22 Oct 2016, at 04:02, Braeden Profile &lt;jhaezhyr12 at gmail.com&gt; wrote:<br></p><p>But what would that mean? ¬†If I reference `ProtocolName.InnerType`, that doesn‚Äôt always have meaning. ¬†In fact, if you have two different extensions where AssociatedType equals something else, there‚Äôs a type ambiguity from other code. ¬†I suspect it would only work if that InnerType was mandated to be `private`.<br></p><p>You would need a reference to a (ProtocolName where AssociatedType == Int), which you can get either from a `self` inside the extension or from a generic parameter:<br></p><p>struct MyValue&lt;T&gt; : ProtocolName { typealias AssociatedType = T }<br></p><p>let _ = MyValue&lt;Int&gt;().InnerType()<br></p><p>No, wait - sorry, that‚Äôs wrong. I got confused for a second. You‚Äôre right; it would have to be a private type.<br></p><p>Actually I think I take that back (I was just writing, lots of snippets floating around my head) - ProtocolName is a generic protocol, so types inside of it would become types on the concrete conformers. That‚Äôs consistent with the Editor.Delegate example in the draft proposal I linked to.<br></p><p>So MyValue&lt;Int&gt;.InnerType would exist üëç ProtocolName.InnerType isn‚Äôt really very meaningful otherwise.<br></p><p>- Karl<br></p><p><br></p><p><br>On Oct 17, 2016, at 12:44 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That option should not be disallowed. Here is a simple example you might want to build at some point:<br></p><p>protocol ProtocolName {<br>       <br>    associatedtype AssociatedType<br>}<br></p><p>extension ProtocolName where AssociatedType == Int {<br>    <br>    struct InnerType {}<br>}<br></p><p><br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:30:58, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Is your vision that each conforming type would have to provide its own nested type as specified by the protocol?<br></p><p>Or could the protocol itself define a nested type and anything could use it?<br></p><p>protocol FloatingPoint: ‚Ä¶ {<br>¬† ¬† enum RoundingRule {<br>¬† ¬† ¬† ¬† // Do I put an implementation here?<br>¬† ¬† }<br>}<br></p><p>No, types which are defined inside the protocol are implemented there. Providing your own types to satisfy a conformance is what associated types are for.<br></p><p>If you wanted something like that, you could do it with a nested protocol + associated type:<br></p><p>protocol FloatingPoint {<br></p><p>¬† ¬† protocol _RoundingRule { func round(_ : Super) -&gt; Super }<br>¬† ¬† associatedType RoundingRule : _RoundingRule<br>}<br></p><p>struct Float : FloatingPoint {<br></p><p>¬† ¬† enum RoundingRule : _RoundingRule {<br>¬† ¬† ¬† ¬† func round(_ val: Float) -&gt; Float {<br>¬† ¬† ¬† ¬† ¬† ¬† /* switch self, perform rounding‚Ä¶ */¬†<br>¬† ¬† ¬† ¬† }<br>¬† ¬† }<br>}<br></p><p>That brings up an interesting point, though - we would need a way to refer to the outer protocol (I used ‚ÄúSuper‚Äù here).<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/2595b30d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Two weeks ago there was a similar pitch here https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon‚Äì20161003/027643.html<br></p><p>In general I‚Äôm in favor of this feature, but I don‚Äôt know any technical issues this might have or does already have.<br></p><p>As I said in the other thread.<br></p><p>I‚Äôm for nested everything.<br></p><p>Nested extensions to reduce noise at some point, BUT this should not remove extension A.B { ‚Ä¶ } completely.<br></p><p>class A {<br>         <br>    class B { ‚Ä¶ }<br>         <br>    extension B { ‚Ä¶ } // extends A.B<br>}<br>We already have A.B syntax for extensions, why don‚Äôt we allow it for type declarations to reduce nesting (sometimes you don‚Äôt want to cluster everything)? Basically something like class A.B { ‚Ä¶ } would be a shortcut for extension A { class B { ‚Ä¶ } } and is bounded by the access modifier of A. (This is probably additive.)<br></p><p><br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 19:59:54, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago:¬†https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html<br></p><p>I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù, ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br></p><p>so to summarise, newly legal would be:<br></p><p>class MyClass {<br></p><p>¬† ¬† protocol Delegate {<br>¬† ¬† }<br>}<br></p><p>and also:<br></p><p>protocol MyProto {<br></p><p>¬† ¬† enum SomeValue {<br>¬† ¬† }<br></p><p>¬† ¬† protocol Delegate {<br>¬† ¬† ¬† ¬† associatedType ExpectedContent<br></p><p>func receive(_: ExpectedContent, for: SomeValue)<br></p><p>¬† ¬† ¬† ¬† protocol SecondaryTarget {<br>¬† ¬† ¬† ¬† ¬† ¬† func receive(_ : ExpectedContent)<br>¬† ¬† ¬† ¬† }<br>¬† ¬† }<br>}<br></p><p>When conforming to a nested protocol, you can just use the name of the protocol:<br></p><p>class Host : MyProto.Delegate {<br>}<br></p><p>Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example ‚Äî MyClass.Delegate):<br></p><p>class SecondaryProcessor : Host.SecondaryTarget {<br>}<br></p><p>If we‚Äôre good with this, I‚Äôll write up a proposal.<br></p><p>- Karl<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/e679fb90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 17, 2016 at 02:00:00pm</p></header><div class="content"><p>I want this feature. Both class in protocol and protocol in class could<br>clean up many relationships but I think that a blocking concern is &quot;How<br>does this interact with generics?&quot; Nesting types in generic types is<br>already disallowed and how different is this feature from that?<br></p><p>On Mon, Oct 17, 2016 at 2:20 PM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Two weeks ago there was a similar pitch here https://lists.swift.org/<br>&gt; pipermail/swift-evolution/Week-of-Mon‚Äì20161003/027643.html<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027643.html&gt;<br>&gt;<br>&gt; In general I‚Äôm in favor of this feature, but I don‚Äôt know any technical<br>&gt; issues this might have or does already have.<br>&gt;<br>&gt; As I said in the other thread.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    I‚Äôm for nested everything.<br>&gt;    -<br>&gt;<br>&gt;    Nested extensions to reduce noise at some point, BUT this should not<br>&gt;    remove extension A.B { ‚Ä¶ } completely.<br>&gt;<br>&gt;    class A {<br>&gt;<br>&gt;        class B { ‚Ä¶ }<br>&gt;<br>&gt;        extension B { ‚Ä¶ } // extends A.B<br>&gt;    }<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    We already have A.B syntax for extensions, why don‚Äôt we allow it for<br>&gt;    type declarations to reduce nesting (sometimes you don‚Äôt want to cluster<br>&gt;    everything)? Basically something like class A.B { ‚Ä¶ } would be a<br>&gt;    shortcut for extension A { class B { ‚Ä¶ } } and is bounded by the<br>&gt;    access modifier of A. (This is probably additive.)<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 17. Oktober 2016 um 19:59:54, Karl via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; I was just doing some googling, turns out there was a discussion about<br>&gt; nesting protocols in other types that seemed to go positively a long time<br>&gt; ago: https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160425/016074.html<br>&gt;<br>&gt; I would additionally like to propose that protocols be allowed to contain<br>&gt; nested types (including other protocols). Relevant ABI issue is that the<br>&gt; standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù,<br>&gt; ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably<br>&gt; be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br>&gt;<br>&gt; so to summarise, newly legal would be:<br>&gt;<br>&gt; class MyClass {<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; and also:<br>&gt;<br>&gt; protocol MyProto {<br>&gt;<br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt;<br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt;<br>&gt; func receive(_: ExpectedContent, for: SomeValue)<br>&gt;<br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; When conforming to a nested protocol, you can just use the name of the<br>&gt; protocol:<br>&gt;<br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt;<br>&gt; Except if a protocol in the chain has associated types, then you must use<br>&gt; a concrete, conforming type instead (as you would in the first example ‚Äî<br>&gt; MyClass.Delegate):<br>&gt;<br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt;<br>&gt; If we‚Äôre good with this, I‚Äôll write up a proposal.<br>&gt;<br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/fed334aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>That‚Äôs also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics)<br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com) schrieb:<br></p><p>I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/7eeff7e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 17 Oct 2016, at 20:31, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That‚Äôs also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>And even partially implemented, behind the flag ‚Äú-enable-experimental-nested-generic-types‚Äù. I don‚Äôt know what‚Äôs missing from it, but it seemed to work in some simple cases last time I tried.<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/475a2f78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 11:35 AM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 17 Oct 2016, at 20:31, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That‚Äôs also on the line: [https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;](https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 17. Oktober 2016 um 20:26:47, T.J. Usiyan (griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; I want this feature. Both class in protocol and protocol in class could clean up many relationships but I think that a blocking concern is &quot;How does this interact with generics?&quot; Nesting types in generic types is already disallowed and how different is this feature from that?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; And even partially implemented, behind the flag ‚Äú-enable-experimental-nested-generic-types‚Äù. I don‚Äôt know what‚Äôs missing from it, but it seemed to work in some simple cases last time I tried.<br></p><p>This flag implements nesting non-protocol generic types inside other non-protocol generic types, except for some bugs I need to fix before I can just enable this all by default.<br></p><p>However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br></p><p>The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br></p><p>If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br></p><p>struct A&lt;T&gt; {<br>  protocol P {<br>    func requirement() -&gt; T<br>  }<br>}<br></p><p>Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br></p><p>The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br></p><p>protocol P {<br>  associatedtype A<br></p><p>  struct T {<br>    var value: A<br>  }<br>}<br></p><p>Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br></p><p>Protocols nested inside protocols also have the same issue.<br></p><p>Also note that even with the experimental flag, generic types nested inside generic *functions* are not supported either. Here, again, the difficulty is with captured generic parameters. The semantics are clear but the implementation needs some work.<br></p><p>Slava<br></p><p>&gt; <br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d4548136/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br>&gt; <br>&gt; The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt; <br>&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br>&gt; <br>&gt; struct A&lt;T&gt; {<br>&gt;   protocol P {<br>&gt;     func requirement() -&gt; T<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br>&gt; <br>&gt; The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br>&gt; <br>&gt; protocol P {<br>&gt;   associatedtype A<br>&gt; <br>&gt;   struct T {<br>&gt;     var value: A<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt; <br>&gt; Protocols nested inside protocols also have the same issue.<br></p><p>FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br></p><p>Here‚Äôs a real life example pared down. I wish I could do this:<br></p><p>    public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br></p><p>      public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>        ...<br>      }<br></p><p>      public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>        case error<br>        case skip<br>        case skipIfOutputTypeMatches<br>      }<br></p><p>    }<br></p><p>InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br></p><p>What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br></p><p>Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br></p><p>    public struct S&lt;T&gt; {<br>      public enum Foo {<br>        case yin<br>        case yang<br>      }<br>    }<br></p><p>‚Ä¶but this wouldn‚Äôt:<br></p><p>    public struct S&lt;T&gt; {<br>      public enum Foo {<br>        case yin(thing: T)  // capture of T illegal (for now)<br>        case yang<br>      }<br>    }<br></p><p>Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Cheers,<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>October 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br>&gt;&gt; <br>&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt; <br>&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br>&gt;&gt; <br>&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;  protocol P {<br>&gt;&gt;    func requirement() -&gt; T<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br>&gt;&gt; <br>&gt;&gt; The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;  associatedtype A<br>&gt;&gt; <br>&gt;&gt;  struct T {<br>&gt;&gt;    var value: A<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt; <br>&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt; <br>&gt; FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt; <br>&gt; Here‚Äôs a real life example pared down. I wish I could do this:<br>&gt; <br>&gt;    public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt; <br>&gt;      public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;        ...<br>&gt;      }<br>&gt; <br>&gt;      public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;        case error<br>&gt;        case skip<br>&gt;        case skipIfOutputTypeMatches<br>&gt;      }<br>&gt; <br>&gt;    }<br>&gt; <br>&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt; <br>&gt; What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt; <br>&gt; Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br>&gt; <br>&gt;    public struct S&lt;T&gt; {<br>&gt;      public enum Foo {<br>&gt;        case yin<br>&gt;        case yang<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt; ‚Ä¶but this wouldn‚Äôt:<br>&gt; <br>&gt;    public struct S&lt;T&gt; {<br>&gt;      public enum Foo {<br>&gt;        case yin(thing: T)  // capture of T illegal (for now)<br>&gt;        case yang<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Yeah, this makes sense for a first cut at this feature.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>November  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func requirement() -&gt; T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;   var value: A<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt; <br>&gt;&gt; FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt; <br>&gt;&gt; Here‚Äôs a real life example pared down. I wish I could do this:<br>&gt;&gt; <br>&gt;&gt;   public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt; <br>&gt;&gt;     public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;       ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;       case error<br>&gt;&gt;       case skip<br>&gt;&gt;       case skipIfOutputTypeMatches<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt; <br>&gt;&gt; What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt; <br>&gt;&gt; Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br>&gt;&gt; <br>&gt;&gt;   public struct S&lt;T&gt; {<br>&gt;&gt;     public enum Foo {<br>&gt;&gt;       case yin<br>&gt;&gt;       case yang<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; ‚Ä¶but this wouldn‚Äôt:<br>&gt;&gt; <br>&gt;&gt;   public struct S&lt;T&gt; {<br>&gt;&gt;     public enum Foo {<br>&gt;&gt;       case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;       case yang<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt; <br>&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt; <br>&gt; Slava<br></p><p>Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter ‚ÄúOK if no captures‚Äù approach?) Eager to help; don‚Äôt want to be in the way.<br></p><p>P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>November  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;  func requirement() -&gt; T<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;&gt;  var value: A<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here‚Äôs a real life example pared down. I wish I could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;&gt;      case error<br>&gt;&gt;&gt;      case skip<br>&gt;&gt;&gt;      case skipIfOutputTypeMatches<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct S&lt;T&gt; {<br>&gt;&gt;&gt;    public enum Foo {<br>&gt;&gt;&gt;      case yin<br>&gt;&gt;&gt;      case yang<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ‚Ä¶but this wouldn‚Äôt:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public struct S&lt;T&gt; {<br>&gt;&gt;&gt;    public enum Foo {<br>&gt;&gt;&gt;      case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;&gt;      case yang<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt;&gt; <br>&gt;&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt; <br>&gt; Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter ‚ÄúOK if no captures‚Äù approach?) Eager to help; don‚Äôt want to be in the way.<br></p><p>Just speaking for myself and not the whole team ‚Äî I think you can submit the proposal at any time, we‚Äôre unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‚Äòno captures‚Äô it‚Äôs ‚Äútrivial‚Äù).<br></p><p>Slava<br></p><p>&gt; <br>&gt; P<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>November  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 2 Nov 2016, at 20:54, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct A&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; func requirement() -&gt; T<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;&gt; associatedtype A<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; struct T {<br>&gt;&gt;&gt;&gt;&gt; var value: A<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols nested inside protocols also have the same issue.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here‚Äôs a real life example pared down. I wish I could do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   public enum InputTypeMismatchAction {  // Does not depend on generic types above<br>&gt;&gt;&gt;&gt;     case error<br>&gt;&gt;&gt;&gt;     case skip<br>&gt;&gt;&gt;&gt;     case skipIfOutputTypeMatches<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct S&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   public enum Foo {<br>&gt;&gt;&gt;&gt;     case yin<br>&gt;&gt;&gt;&gt;     case yang<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ‚Ä¶but this wouldn‚Äôt:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public struct S&lt;T&gt; {<br>&gt;&gt;&gt;&gt;   public enum Foo {<br>&gt;&gt;&gt;&gt;     case yin(thing: T)  // capture of T illegal (for now)<br>&gt;&gt;&gt;&gt;     case yang<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, this makes sense for a first cut at this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt; Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter ‚ÄúOK if no captures‚Äù approach?) Eager to help; don‚Äôt want to be in the way.<br>&gt; <br>&gt; Just speaking for myself and not the whole team ‚Äî I think you can submit the proposal at any time, we‚Äôre unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‚Äòno captures‚Äô it‚Äôs ‚Äútrivial‚Äù).<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; P<br></p><p><br>Sorry, let this slip. Proposal sent - https://github.com/apple/swift-evolution/pull/552<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161105/729f9fe5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>November  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Disappointed to see that you just ignored everything I pitched to you. The proposal does not cover extensions nor it it sees the problem with access modifier which it creates.<br></p><p>public protocol A {<br>     <br>    // Not allowed to use any access modifier here at all<br>    struct B {<br>        // Nor here<br>        var something: C = ‚Ä¶<br>    }<br>}<br>Everything will be public here. Try to build a true singleton like this for example.<br></p><p><br></p><p>--¬†<br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 5. November 2016 um 10:44:27, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>On 2 Nov 2016, at 20:54, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p><br>On Nov 2, 2016, at 8:32 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 4:43 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 8:12 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p><br>On Oct 24, 2016, at 5:09 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>However protocols nested inside types and types nested inside protocols is still not supported, because protocols introduce a separate series of issues involving associated types and the ‚ÄôSelf‚Äô type.<br></p><p>The hard part of getting nested generics right is what to do if a nested type ‚Äòcaptures‚Äô generic parameters of the outer type. For non-protocol types, the behavior here is pretty straightforward.<br></p><p>If we allow protocols to be nested inside other types, we have to decide what to do if the protocol ‚Äòcloses over‚Äô generic parameters of the outer type. For example,<br></p><p>struct A&lt;T&gt; {<br>protocol P {<br>func requirement() -&gt; T<br>}<br>}<br></p><p>Presumably A&lt;Int&gt;.P and A&lt;String&gt;.P are distinct types, and A.P has a hidden associated type corresponding to the type parameter ‚ÄôT‚Äô?<br></p><p>The other case is problematic too ‚Äî the nested type might refer to an associated type of the outer protocol:<br></p><p>protocol P {<br>associatedtype A<br></p><p>struct T {<br>var value: A<br>}<br>}<br></p><p>Now writing P.T does not make sense, for the same reason that we cannot form an existential of type P.A. We could prohibit references to outer associated types of this form, or we could figure out some way to give it a meaning. If C is a concrete type conforming to P, then certainly C.T makes sense, for instance. Internally, the nested type A.T could have a hidden ‚ÄòSelf‚Äô generic type parameter, so that writing C.T is really the same as P.T&lt;C&gt;.<br></p><p>Protocols nested inside protocols also have the same issue.<br></p><p>FWIW, in almost all the situations where I‚Äôve wanted to nest types inside protocols and generic types, it‚Äôs only as a namespacing convenience. Most often, it‚Äôs an enum type that‚Äôs used only by a single method, and having it at the top of the module namespace adds clutter.<br></p><p>Here‚Äôs a real life example pared down. I wish I could do this:<br></p><p>public struct ResponseContentTransformer&lt;InputContentType, OutputContentType&gt;: ResponseTransformer {<br></p><p>¬†¬†public init(onInputTypeMismatch mismatchAction: InputTypeMismatchAction = .error) {<br>¬†¬†¬†¬†...<br>¬†¬†}<br></p><p>¬†¬†public enum InputTypeMismatchAction { ¬†// Does not depend on generic types above<br>¬†¬†¬†¬†case error<br>¬†¬†¬†¬†case skip<br>¬†¬†¬†¬†case skipIfOutputTypeMatches<br>¬†¬†}<br></p><p>}<br></p><p>InputTypeMismatchAction is tightly associated with ResponseContentTransformer, and is confusing as a top-level type.<br></p><p>What do you think about providing a ‚Äúno captures‚Äù modifier for nested types ‚Äî like static inner classes in Java? Then Swift could provide the namespace nesting I wish for this without having to resolve the trickier type capture questions yet.<br></p><p>Alternatively, what if (1) outer types aren‚Äôt capture unless they‚Äôre referenced, and (2) nesting is only illegal if there‚Äôs a capture? Then my code above would compile, as would this:<br></p><p>public struct S&lt;T&gt; {<br>¬†¬†public enum Foo {<br>¬†¬†¬†¬†case yin<br>¬†¬†¬†¬†case yang<br>¬†¬†}<br>}<br></p><p>‚Ä¶but this wouldn‚Äôt:<br></p><p>public struct S&lt;T&gt; {<br>¬†¬†public enum Foo {<br>¬†¬†¬†¬†case yin(thing: T) ¬†// capture of T illegal (for now)<br>¬†¬†¬†¬†case yang<br>¬†¬†}<br>}<br></p><p>Either of these approaches would allow hygienic namespacing now while leaving the door open to outer type capture in the future.<br></p><p>Yeah, this makes sense for a first cut at this feature.<br></p><p>Slava<br></p><p>Should I take a crack at writing up a proposal for this? Now? After ABI work is done? (Probably the latter ‚ÄúOK if no captures‚Äù approach?) Eager to help; don‚Äôt want to be in the way.<br></p><p>Just speaking for myself and not the whole team ‚Äî I think you can submit the proposal at any time, we‚Äôre unlikely to get around to doing it, if you want to take a crack that would be great (again, with ‚Äòno captures‚Äô it‚Äôs ‚Äútrivial‚Äù).<br></p><p>Slava<br></p><p><br>P<br></p><p><br>Sorry, let this slip. Proposal sent -¬†https://github.com/apple/swift-evolution/pull/552<br></p><p>- Karl<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161105/fcda828e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Nested types in protocols (and nesting protocols in types)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 17, 2016 at 01:00:00pm</p></header><div class="content"><p>Extremely strong +1.<br></p><p>I‚Äôve got a bunch of Objective-C-style really long type names of the sort ‚ÄúMyProtocol‚Äù, ‚ÄúMyProtocolSomeTypeEnum‚Äù, ‚ÄúMyProtocolSomeOptionsEnum‚Äù, etc. It would be really nice to make those Swiftier.<br></p><p>Charles<br></p><p>&gt; On Oct 17, 2016, at 12:59 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was just doing some googling, turns out there was a discussion about nesting protocols in other types that seemed to go positively a long time ago: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160425/016074.html&gt;<br>&gt; <br>&gt; I would additionally like to propose that protocols be allowed to contain nested types (including other protocols). Relevant ABI issue is that the standard library contains enums for ‚ÄúFloatingPointRoundingRule‚Äù, ‚ÄúFloatingPointClassification‚Äù and ‚ÄúFloatingPointSign‚Äù. They would probably be better expressed as ‚ÄúFloatingPoint.RoundingRule‚Äù, ‚Äú.Sign&quot;, etc.<br>&gt; <br>&gt; so to summarise, newly legal would be:<br>&gt; <br>&gt; class MyClass {<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; and also:<br>&gt; <br>&gt; protocol MyProto {<br>&gt; <br>&gt;     enum SomeValue {<br>&gt;     }<br>&gt; <br>&gt;     protocol Delegate {<br>&gt;         associatedType ExpectedContent<br>&gt; <br>&gt; 	func receive(_: ExpectedContent, for: SomeValue)<br>&gt; <br>&gt;         protocol SecondaryTarget {<br>&gt;             func receive(_ : ExpectedContent)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; When conforming to a nested protocol, you can just use the name of the protocol:<br>&gt; <br>&gt; class Host : MyProto.Delegate {<br>&gt; }<br>&gt; <br>&gt; Except if a protocol in the chain has associated types, then you must use a concrete, conforming type instead (as you would in the first example ‚Äî MyClass.Delegate):<br>&gt; <br>&gt; class SecondaryProcessor : Host.SecondaryTarget {<br>&gt; }<br>&gt; <br>&gt; If we‚Äôre good with this, I‚Äôll write up a proposal.<br>&gt; <br>&gt; - Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/0e38d986/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
