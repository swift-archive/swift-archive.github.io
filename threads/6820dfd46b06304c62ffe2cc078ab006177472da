<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>C dependencies</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>I noticed the README for the package manager seems to take a strong view of source distribution:<br></p><p>&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br></p><p>I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br></p><p>What is the vision for distributing this software with the package manager?<br></p><p>1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>    1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br>2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br>3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br>4.  Is it a design goal to distribute Foundation via the package manager?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>C dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December 12, 2015 at 09:00:00am</p></header><div class="content"><p>I would say that our main goals are two fold:<br>1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br></p><p>As a good example of #1, it would be awesome if in the future that even a project like the Swift compiler itself -- with its complicated dependency tree and build process -- could be configured and built with the package manager.<br></p><p>The goals here are mostly oriented around how do we give the best possible developer experience for constructing source code. I strongly believe that the &quot;container&quot; / &quot;sandbox&quot; model is the right way to go in order to build tools which give reproducible results, allow for easy sharing and deployment, and encourage modular development. If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br></p><p>Goal #2 of trying to stay out of the system package manager business (installing built software) is more out of trying to maintain a clear focus and emphasis than anything else. We already have a ton of work to do on the package manager even within that scope, so it just makes sense for now to leave this problem to existing projects better suited to the task.<br></p><p>FWIW, I am working on a proposal for our initial support for *building* C family sources as part of Swift packages. Depending on exactly how complicated your dependencies are (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br></p><p>&gt; On Dec 12, 2015, at 5:04 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I noticed the README for the package manager seems to take a strong view of source distribution:<br>&gt; <br>&gt;&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt;&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br>&gt; <br>&gt; I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br>&gt; <br>&gt; What is the vision for distributing this software with the package manager?<br>&gt; <br>&gt; 1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>&gt;    1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br></p><p>Yes, it would barf. We are open to improving the reliability of the &quot;system modules&quot; mechanism to be more robust. We do need to support interoperating with installed libraries, and it would be great to make this as smooth as possible.<br></p><p>&gt; 2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br></p><p>We don&#39;t have such a mechanism, and as I said the goal of the package manager is to build your project, not distribute it as installable packages. I can imagine adding mechanisms to *help you create* an easily installable product, but I think the actual installation of that product should be left to other tools.<br></p><p>&gt; 3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br></p><p>Not currently. What exactly are you envisioning here?<br></p><p>&gt; 4.  Is it a design goal to distribute Foundation via the package manager?<br></p><p>I&#39;m not sure what you mean. Foundation itself is a special case, it is something we consider part of the Swift corelibs and will ship with the Swift compiler.<br></p><p>We *would* like to be able to build the Foundation project with the package manager, but there are a lot of things that need to get sorted out before that can happen.<br></p><p>HTH,<br> - Daniel<br></p><p>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>C dependencies</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 12, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br></p><p>Okay, this is good information.  The output of the package manager is a .a (or .so, .dylib, Mach-O executable, etc.) and it is your job to install that to a path on your system, or not.  This seems like a good model.  I might suggest updating the README in some way that explains this.<br></p><p>This is actually vaguely analogous to Rust&#39;s cargo, so I would suggest looking there for design concepts, as they are quite a bit further ahead of us on this problem.<br></p><p>&gt; If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br></p><p>I&#39;m (sadly) intimately familiar.  It is not really all that easy, primarily because of binary hell, as anyone who has googled how to install pycairo can attest.  I really want to do better on this problem than Python does.<br></p><p>Here&#39;s a concrete question: how would we advise a hypothetical swiftcairo project to package themselves in the package manager?  Should they:<br></p><p>1.  Call out to a shell script that does `brew install cairo` on OSX, `apt-get install cairo` on Debian, etc.<br>2.  Print some error telling them to come back when they&#39;ve installed cairo somewhere on their system.  Good luck, kid<br>3.  Write a shell script that downloads and builds cairo from source including all its dependencies<br>4.  Create a tree in the swift package manager like<br></p><p>swiftcairo &lt;-- cairo &lt;-------pixman<br>                     &lt;-------freetype<br>                     &lt;-------fontconfig<br>                     &lt;-------libpng<br>                     &lt;-------glib<br>  Where each of these &quot;packages&quot; are mostly a shell script that runs a lot of `curl -O` `tar xf` `configure` `make` etc.<br>5.  Do we try and second-guess what libpng&#39;s autotools want to do?  (Bad, bad, idea.  Build the way libpng decided to build, don&#39;t try to guess based on the arrangement of .c files in a folder)<br>6.  Other ideas?<br></p><p>A vision for the pathological case like Cairo will illuminate the simpler cases.  IMO it would be nice if &quot;depends: swiftcairo&quot; would &#39;just work&#39;, but that may be out of scope.<br></p><p>&gt;  (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br></p><p>NaOH &lt;https://code.sealedabstract.com/drewcrawford/NaOH&gt; is a good test case.  It&#39;s a framework that statically links libsodium.  My current (terrible) workflow is:<br></p><p>1.  Download libsodium-xx.tar.gz &lt;https://github.com/jedisct1/libsodium/releases&gt; from GitHub<br>2.  ./configure &amp;&amp; make<br>3.  Move binaries + .h around to where Xcode can find them<br>4.  Check into source control<br>5.  Build<br></p><p>Would love to automate this and get it building with the package manager.  There&#39;s actually been an issue open &lt;https://code.sealedabstract.com/drewcrawford/NaOH/issues/1&gt; since pretty much day 1 to get this working.  That is the problem that motivated me to post.  <br></p><p><br></p><p><br>&gt; On Dec 12, 2015, at 11:02 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; I would say that our main goals are two fold:<br>&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt; <br>&gt; As a good example of #1, it would be awesome if in the future that even a project like the Swift compiler itself -- with its complicated dependency tree and build process -- could be configured and built with the package manager.<br>&gt; <br>&gt; The goals here are mostly oriented around how do we give the best possible developer experience for constructing source code. I strongly believe that the &quot;container&quot; / &quot;sandbox&quot; model is the right way to go in order to build tools which give reproducible results, allow for easy sharing and deployment, and encourage modular development. If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt; <br>&gt; Goal #2 of trying to stay out of the system package manager business (installing built software) is more out of trying to maintain a clear focus and emphasis than anything else. We already have a ton of work to do on the package manager even within that scope, so it just makes sense for now to leave this problem to existing projects better suited to the task.<br>&gt; <br>&gt; FWIW, I am working on a proposal for our initial support for *building* C family sources as part of Swift packages. Depending on exactly how complicated your dependencies are (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 5:04 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I noticed the README for the package manager seems to take a strong view of source distribution:<br>&gt;&gt; <br>&gt;&gt;&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt;&gt;&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br>&gt;&gt; <br>&gt;&gt; I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br>&gt;&gt; <br>&gt;&gt; What is the vision for distributing this software with the package manager?<br>&gt;&gt; <br>&gt;&gt; 1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>&gt;&gt;   1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br>&gt; <br>&gt; Yes, it would barf. We are open to improving the reliability of the &quot;system modules&quot; mechanism to be more robust. We do need to support interoperating with installed libraries, and it would be great to make this as smooth as possible.<br>&gt; <br>&gt;&gt; 2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br>&gt; <br>&gt; We don&#39;t have such a mechanism, and as I said the goal of the package manager is to build your project, not distribute it as installable packages. I can imagine adding mechanisms to *help you create* an easily installable product, but I think the actual installation of that product should be left to other tools.<br>&gt; <br>&gt;&gt; 3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br>&gt; <br>&gt; Not currently. What exactly are you envisioning here?<br>&gt; <br>&gt;&gt; 4.  Is it a design goal to distribute Foundation via the package manager?<br>&gt; <br>&gt; I&#39;m not sure what you mean. Foundation itself is a special case, it is something we consider part of the Swift corelibs and will ship with the Swift compiler.<br>&gt; <br>&gt; We *would* like to be able to build the Foundation project with the package manager, but there are a lot of things that need to get sorted out before that can happen.<br>&gt; <br>&gt; HTH,<br>&gt; - Daniel<br>&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151212/448094b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>C dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December 13, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 3:46 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt; <br>&gt; Okay, this is good information.  The output of the package manager is a .a (or .so, .dylib, Mach-O executable, etc.) and it is your job to install that to a path on your system, or not.  This seems like a good model.  I might suggest updating the README in some way that explains this.<br></p><p>Good point, we don&#39;t really have any docs on the output. I don&#39;t have time to tackle this currently, but if patches here would be welcome. I believe Max also has some plans to make the build products more obvious (not hidden in the .build dir), the current system hasn&#39;t really been &quot;designed&quot; yet.<br></p><p>&gt; This is actually vaguely analogous to Rust&#39;s cargo, so I would suggest looking there for design concepts, as they are quite a bit further ahead of us on this problem.<br></p><p>Yup. I can&#39;t say I&#39;ve had the time to seriously study cargo and the state of its ecosystem, but I am aware of it. I&#39;d appreciate pointers if there are specific things you are thinking about.<br></p><p>&gt;&gt; If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt; <br>&gt; I&#39;m (sadly) intimately familiar.  It is not really all that easy, primarily because of binary hell, as anyone who has googled how to install pycairo can attest.  I really want to do better on this problem than Python does.<br></p><p>I think it depends on the project. For web stacks it can be awesome to pull down a dependency tree w/ C extensions for PostgreSQL, Redis, etc. and a lot of stuff &quot;just works&quot;. For more complicated C projects I agree it isn&#39;t a slam dunk.<br></p><p>&gt; Here&#39;s a concrete question: how would we advise a hypothetical swiftcairo project to package themselves in the package manager?  Should they:<br></p><p>Well, we don&#39;t really support any of these features yet so our current advisement would be &quot;we need to design this feature&quot;. :)<br></p><p>&gt; 1.  Call out to a shell script that does `brew install cairo` on OSX, `apt-get install cairo` on Debian, etc.<br></p><p>Currently, this is the only supported thing. But I want to do better than this...<br></p><p>&gt; 2.  Print some error telling them to come back when they&#39;ve installed cairo somewhere on their system.  Good luck, kid<br>&gt; 3.  Write a shell script that downloads and builds cairo from source including all its dependencies<br>&gt; 4.  Create a tree in the swift package manager like<br>&gt; <br>&gt; swiftcairo &lt;-- cairo &lt;-------pixman<br>&gt;                      &lt;-------freetype<br>&gt;                      &lt;-------fontconfig<br>&gt;                      &lt;-------libpng<br>&gt;                      &lt;-------glib<br>&gt;   Where each of these &quot;packages&quot; are mostly a shell script that runs a lot of `curl -O` `tar xf` `configure` `make` etc.<br>&gt; 5.  Do we try and second-guess what libpng&#39;s autotools want to do?  (Bad, bad, idea.  Build the way libpng decided to build, don&#39;t try to guess based on the arrangement of .c files in a folder)<br>&gt; 6.  Other ideas?<br>&gt; <br>&gt; A vision for the pathological case like Cairo will illuminate the simpler cases.  IMO it would be nice if &quot;depends: swiftcairo&quot; would &#39;just work&#39;, but that may be out of scope.<br></p><p>My proposal is:<br></p><p>1. We include some native support for C/C++ libraries. This should be &quot;well designed&quot;, but ideally would scale up to supporting very support complex projects (like `swiftc`). I care about this part deeply because there is a lot of awesome stuff I want to do in llbuild + clang, and that depends on being able to get the project onto those tools. We will by necessity need to start with a small limited scope and feature creep our way forward.<br></p><p>2. We provide an adaption mechanism, to allow projects that can&#39;t yet be built by #1 to still integrate directly into the ecosystem. This can take two forms:<br></p><p>2.a. For projects which *could* conform to #1, but the only problem is the upstream project doesn&#39;t want to change (or hasn&#39;t yet), then we could support an adaption mechanism which just took in the upstream project and overlayed the appropriate Package.swift definitions that we need to use to build it. This means that swiftpm + llbuild would have a full understanding of the build process, which is the ideal scenario for the ensuring a good user experience.<br></p><p>2.b. For projects which are just &quot;too complicated&quot; to do #2.a, we would allow a form of your #3 (a shell script which downloads and builds). The way I envision this working is that:<br>- I&#39;d like to avoid the script actually downloading anything, I think we should still try and use our model for pulling the sources. This may mean someone maintains a tagged version of an adaptor package that includes the source of the upstream project + the adaptor pieces.<br>- We would require a very strict interface between that script and the rest of the package manager. Essentially, we would provide the script with its inputs, and we would expect it to produce, as an output, the exact kind of build layout that we ourselves would have done for project in case #2.a. In practice, those scripts would usually look something like &quot; configure &amp;&amp; make &amp;&amp; ... move the built products around a bunch to conform to the expected layout ...&quot;. We would run the script in appropriate dependency order, then ingest / audit all of the outputs, and from then on it would integrate just like #2.a.<br></p><p>We need to be very careful about doing #2.b in a way that doesn&#39;t restrict our ability to evolve...<br></p><p>One thing I would like to call out is that I don&#39;t feel like we need to directly support the total amount of complexity that exists in the world w.r.t. C family projects. I want use to help make the world more sane by coming up with sensible conventions and models for C family projects, and then apply pressure in other places to reduce unnecessary complexity or to converge on semi-standard solutions. I outlined a bit more of my philosophy here in:<br>  https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151130/000027.html<br></p><p>&gt; <br>&gt;&gt;  (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt; <br>&gt; NaOH &lt;https://code.sealedabstract.com/drewcrawford/NaOH&gt; is a good test case.  It&#39;s a framework that statically links libsodium.  My current (terrible) workflow is:<br>&gt; <br>&gt; 1.  Download libsodium-xx.tar.gz &lt;https://github.com/jedisct1/libsodium/releases&gt; from GitHub<br>&gt; 2.  ./configure &amp;&amp; make<br>&gt; 3.  Move binaries + .h around to where Xcode can find them<br>&gt; 4.  Check into source control<br>&gt; 5.  Build<br>&gt; <br>&gt; Would love to automate this and get it building with the package manager.  There&#39;s actually been an issue open &lt;https://code.sealedabstract.com/drewcrawford/NaOH/issues/1&gt; since pretty much day 1 to get this working.  That is the problem that motivated me to post.  <br></p><p>Cool, thanks for the pointer I will check it out.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 11:02 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would say that our main goals are two fold:<br>&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt;&gt; <br>&gt;&gt; As a good example of #1, it would be awesome if in the future that even a project like the Swift compiler itself -- with its complicated dependency tree and build process -- could be configured and built with the package manager.<br>&gt;&gt; <br>&gt;&gt; The goals here are mostly oriented around how do we give the best possible developer experience for constructing source code. I strongly believe that the &quot;container&quot; / &quot;sandbox&quot; model is the right way to go in order to build tools which give reproducible results, allow for easy sharing and deployment, and encourage modular development. If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt;&gt; <br>&gt;&gt; Goal #2 of trying to stay out of the system package manager business (installing built software) is more out of trying to maintain a clear focus and emphasis than anything else. We already have a ton of work to do on the package manager even within that scope, so it just makes sense for now to leave this problem to existing projects better suited to the task.<br>&gt;&gt; <br>&gt;&gt; FWIW, I am working on a proposal for our initial support for *building* C family sources as part of Swift packages. Depending on exactly how complicated your dependencies are (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 5:04 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I noticed the README for the package manager seems to take a strong view of source distribution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt;&gt;&gt;&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is the vision for distributing this software with the package manager?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>&gt;&gt;&gt;   1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br>&gt;&gt; <br>&gt;&gt; Yes, it would barf. We are open to improving the reliability of the &quot;system modules&quot; mechanism to be more robust. We do need to support interoperating with installed libraries, and it would be great to make this as smooth as possible.<br>&gt;&gt; <br>&gt;&gt;&gt; 2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br>&gt;&gt; <br>&gt;&gt; We don&#39;t have such a mechanism, and as I said the goal of the package manager is to build your project, not distribute it as installable packages. I can imagine adding mechanisms to *help you create* an easily installable product, but I think the actual installation of that product should be left to other tools.<br>&gt;&gt; <br>&gt;&gt;&gt; 3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br>&gt;&gt; <br>&gt;&gt; Not currently. What exactly are you envisioning here?<br>&gt;&gt; <br>&gt;&gt;&gt; 4.  Is it a design goal to distribute Foundation via the package manager?<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure what you mean. Foundation itself is a special case, it is something we consider part of the Swift corelibs and will ship with the Swift compiler.<br>&gt;&gt; <br>&gt;&gt; We *would* like to be able to build the Foundation project with the package manager, but there are a lot of things that need to get sorted out before that can happen.<br>&gt;&gt; <br>&gt;&gt; HTH,<br>&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151213/7d46be62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>C dependencies</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; Yup. I can&#39;t say I&#39;ve had the time to seriously study cargo and the state of its ecosystem, but I am aware of it. I&#39;d appreciate pointers if there are specific things you are thinking about.<br></p><p>Well, the bullet list of learning from cargo:<br></p><p>Enforce a consistent file structure on sourcecode (which we do)<br>Consider using [swift] as a scripting language for external builds rather than bash<br>swift as manifest seems more powerful than is strictly necessary, but I do see some advantages too<br>Let the user choose static link, dynamic link, debug, release, --with-openssl, --target=iOS, etc. at the CLI<br>Have a synonym for &quot;make check&quot;<br>Have a .lock file that records the dependency revs actually used<br>Do something sane when the dependency repository is a git URL to an autotools project<br></p><p>I would +1 most of your proposal (prefer llbuild, scripting escape hatch, tagged sources, etc.) but I forsee a potential problem on this point:<br></p><p>&gt; One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. <br></p><p><br>While this is true, this seems like an https://xkcd.com/927/ &lt;https://xkcd.com/927/&gt; kind of statement.  I think this project has the potential for moral authority (or &quot;force for change&quot; as you put it), but the exact magnitude of the moral authority is unknown and I estimate it lower than perhaps you do.<br></p><p>I think swift-pm derives its moral authority from two facts:<br></p><p>That it&#39;s an official, swift.org &lt;http://swift.org/&gt; project, like Rust&#39;s cargo, go get, etc.<br>That people want a build system for Linux now and so they have to rethink their packaging anyway<br></p><p>However these two facts are only relevant for **swift** projects.  That is to say, libpng already builds on Linux and is not actively shopping for a new build system.  Nor do they care about packaging with the Approved Method™ from swift.org &lt;http://swift.org/&gt;, a language they do not even use.  And when push comes to shove, swift projects need libpng more badly than they need the Approved Packaging Method™.<br></p><p>tl;dr it is actually the C dependencies here which have the moral authority.  Any conflict between what swift-pm wants and what libpng wants will be resolved in favor of libpng.  You cannot tell swift developers to go apply pressure to libpng to switch build systems; we lack standing.<br></p><p>&gt; Well, we don&#39;t really support any of these features yet so our current advisement would be &quot;we need to design this feature&quot;. :)<br></p><p>Well yes, but in the context of the above, I&#39;m suggesting that the C dependency story and courting libpng etc (if that is in fact important) is more important than nearly any other problem.  I can live for a few months without unit tests, configuration options, build environment isolation, versioning, etc. I can PR those as I need them, it is mostly obvious what is the right patch to write, from the README alone.<br></p><p>I can&#39;t build without libsodium.  I can&#39;t build without libpng.  So forget about months, I can&#39;t get ten minutes into being a user even on one platform without making a decision on how to build C dependencies.  And it is much less obvious what the right thing to PR here is.  <br></p><p>I think it is potentially something like your 2b, but it seems presently underspecified (&quot;We need to be very careful about doing #2.b in a way that doesn&#39;t restrict our ability to evolve&quot;) and I&#39;m uncertain if there&#39;s anything concrete that can be done to get it into an implementable state.<br></p><p>&gt; On Dec 13, 2015, at 1:55 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 12, 2015, at 3:46 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt;&gt; <br>&gt;&gt; Okay, this is good information.  The output of the package manager is a .a (or .so, .dylib, Mach-O executable, etc.) and it is your job to install that to a path on your system, or not.  This seems like a good model.  I might suggest updating the README in some way that explains this.<br>&gt; <br>&gt; Good point, we don&#39;t really have any docs on the output. I don&#39;t have time to tackle this currently, but if patches here would be welcome. I believe Max also has some plans to make the build products more obvious (not hidden in the .build dir), the current system hasn&#39;t really been &quot;designed&quot; yet.<br>&gt; <br>&gt;&gt; This is actually vaguely analogous to Rust&#39;s cargo, so I would suggest looking there for design concepts, as they are quite a bit further ahead of us on this problem.<br>&gt; <br>&gt; Yup. I can&#39;t say I&#39;ve had the time to seriously study cargo and the state of its ecosystem, but I am aware of it. I&#39;d appreciate pointers if there are specific things you are thinking about.<br>&gt; <br>&gt;&gt;&gt; If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt;&gt; <br>&gt;&gt; I&#39;m (sadly) intimately familiar.  It is not really all that easy, primarily because of binary hell, as anyone who has googled how to install pycairo can attest.  I really want to do better on this problem than Python does.<br>&gt; <br>&gt; I think it depends on the project. For web stacks it can be awesome to pull down a dependency tree w/ C extensions for PostgreSQL, Redis, etc. and a lot of stuff &quot;just works&quot;. For more complicated C projects I agree it isn&#39;t a slam dunk.<br>&gt; <br>&gt;&gt; Here&#39;s a concrete question: how would we advise a hypothetical swiftcairo project to package themselves in the package manager?  Should they:<br>&gt; <br>&gt; Well, we don&#39;t really support any of these features yet so our current advisement would be &quot;we need to design this feature&quot;. :)<br>&gt; <br>&gt;&gt; 1.  Call out to a shell script that does `brew install cairo` on OSX, `apt-get install cairo` on Debian, etc.<br>&gt; <br>&gt; Currently, this is the only supported thing. But I want to do better than this...<br>&gt; <br>&gt;&gt; 2.  Print some error telling them to come back when they&#39;ve installed cairo somewhere on their system.  Good luck, kid<br>&gt;&gt; 3.  Write a shell script that downloads and builds cairo from source including all its dependencies<br>&gt;&gt; 4.  Create a tree in the swift package manager like<br>&gt;&gt; <br>&gt;&gt; swiftcairo &lt;-- cairo &lt;-------pixman<br>&gt;&gt;                      &lt;-------freetype<br>&gt;&gt;                      &lt;-------fontconfig<br>&gt;&gt;                      &lt;-------libpng<br>&gt;&gt;                      &lt;-------glib<br>&gt;&gt;   Where each of these &quot;packages&quot; are mostly a shell script that runs a lot of `curl -O` `tar xf` `configure` `make` etc.<br>&gt;&gt; 5.  Do we try and second-guess what libpng&#39;s autotools want to do?  (Bad, bad, idea.  Build the way libpng decided to build, don&#39;t try to guess based on the arrangement of .c files in a folder)<br>&gt;&gt; 6.  Other ideas?<br>&gt;&gt; <br>&gt;&gt; A vision for the pathological case like Cairo will illuminate the simpler cases.  IMO it would be nice if &quot;depends: swiftcairo&quot; would &#39;just work&#39;, but that may be out of scope.<br>&gt; <br>&gt; My proposal is:<br>&gt; <br>&gt; 1. We include some native support for C/C++ libraries. This should be &quot;well designed&quot;, but ideally would scale up to supporting very support complex projects (like `swiftc`). I care about this part deeply because there is a lot of awesome stuff I want to do in llbuild + clang, and that depends on being able to get the project onto those tools. We will by necessity need to start with a small limited scope and feature creep our way forward.<br>&gt; <br>&gt; 2. We provide an adaption mechanism, to allow projects that can&#39;t yet be built by #1 to still integrate directly into the ecosystem. This can take two forms:<br>&gt; <br>&gt; 2.a. For projects which *could* conform to #1, but the only problem is the upstream project doesn&#39;t want to change (or hasn&#39;t yet), then we could support an adaption mechanism which just took in the upstream project and overlayed the appropriate Package.swift definitions that we need to use to build it. This means that swiftpm + llbuild would have a full understanding of the build process, which is the ideal scenario for the ensuring a good user experience.<br>&gt; <br>&gt; 2.b. For projects which are just &quot;too complicated&quot; to do #2.a, we would allow a form of your #3 (a shell script which downloads and builds). The way I envision this working is that:<br>&gt; - I&#39;d like to avoid the script actually downloading anything, I think we should still try and use our model for pulling the sources. This may mean someone maintains a tagged version of an adaptor package that includes the source of the upstream project + the adaptor pieces.<br>&gt; - We would require a very strict interface between that script and the rest of the package manager. Essentially, we would provide the script with its inputs, and we would expect it to produce, as an output, the exact kind of build layout that we ourselves would have done for project in case #2.a. In practice, those scripts would usually look something like &quot; configure &amp;&amp; make &amp;&amp; ... move the built products around a bunch to conform to the expected layout ...&quot;. We would run the script in appropriate dependency order, then ingest / audit all of the outputs, and from then on it would integrate just like #2.a.<br>&gt; <br>&gt; We need to be very careful about doing #2.b in a way that doesn&#39;t restrict our ability to evolve...<br>&gt; <br>&gt; One thing I would like to call out is that I don&#39;t feel like we need to directly support the total amount of complexity that exists in the world w.r.t. C family projects. I want use to help make the world more sane by coming up with sensible conventions and models for C family projects, and then apply pressure in other places to reduce unnecessary complexity or to converge on semi-standard solutions. I outlined a bit more of my philosophy here in:<br>&gt;   https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151130/000027.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151130/000027.html&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt;&gt; <br>&gt;&gt; NaOH &lt;https://code.sealedabstract.com/drewcrawford/NaOH&gt; is a good test case.  It&#39;s a framework that statically links libsodium.  My current (terrible) workflow is:<br>&gt;&gt; <br>&gt;&gt; 1.  Download libsodium-xx.tar.gz &lt;https://github.com/jedisct1/libsodium/releases&gt; from GitHub<br>&gt;&gt; 2.  ./configure &amp;&amp; make<br>&gt;&gt; 3.  Move binaries + .h around to where Xcode can find them<br>&gt;&gt; 4.  Check into source control<br>&gt;&gt; 5.  Build<br>&gt;&gt; <br>&gt;&gt; Would love to automate this and get it building with the package manager.  There&#39;s actually been an issue open &lt;https://code.sealedabstract.com/drewcrawford/NaOH/issues/1&gt; since pretty much day 1 to get this working.  That is the problem that motivated me to post.  <br>&gt; <br>&gt; Cool, thanks for the pointer I will check it out.<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 11:02 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would say that our main goals are two fold:<br>&gt;&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a good example of #1, it would be awesome if in the future that even a project like the Swift compiler itself -- with its complicated dependency tree and build process -- could be configured and built with the package manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goals here are mostly oriented around how do we give the best possible developer experience for constructing source code. I strongly believe that the &quot;container&quot; / &quot;sandbox&quot; model is the right way to go in order to build tools which give reproducible results, allow for easy sharing and deployment, and encourage modular development. If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Goal #2 of trying to stay out of the system package manager business (installing built software) is more out of trying to maintain a clear focus and emphasis than anything else. We already have a ton of work to do on the package manager even within that scope, so it just makes sense for now to leave this problem to existing projects better suited to the task.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I am working on a proposal for our initial support for *building* C family sources as part of Swift packages. Depending on exactly how complicated your dependencies are (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 12, 2015, at 5:04 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I noticed the README for the package manager seems to take a strong view of source distribution:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt;&gt;&gt;&gt;&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is the vision for distributing this software with the package manager?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>&gt;&gt;&gt;&gt;   1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, it would barf. We are open to improving the reliability of the &quot;system modules&quot; mechanism to be more robust. We do need to support interoperating with installed libraries, and it would be great to make this as smooth as possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t have such a mechanism, and as I said the goal of the package manager is to build your project, not distribute it as installable packages. I can imagine adding mechanisms to *help you create* an easily installable product, but I think the actual installation of that product should be left to other tools.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not currently. What exactly are you envisioning here?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4.  Is it a design goal to distribute Foundation via the package manager?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure what you mean. Foundation itself is a special case, it is something we consider part of the Swift corelibs and will ship with the Swift compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We *would* like to be able to build the Foundation project with the package manager, but there are a lot of things that need to get sorted out before that can happen.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HTH,<br>&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151213/3ff51648/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>C dependencies</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 3:05 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt;&gt; Yup. I can&#39;t say I&#39;ve had the time to seriously study cargo and the state of its ecosystem, but I am aware of it. I&#39;d appreciate pointers if there are specific things you are thinking about.<br>&gt; <br>&gt; Well, the bullet list of learning from cargo:<br>&gt; <br>&gt; Enforce a consistent file structure on sourcecode (which we do)<br>&gt; Consider using [swift] as a scripting language for external builds rather than bash<br>&gt; swift as manifest seems more powerful than is strictly necessary, but I do see some advantages too<br></p><p>I can see how this might be useful, but don&#39;t really see what it buys you if that just turns around and calls something as open ended as configure. Can you say more about why this is a good thing?<br></p><p>&gt; Let the user choose static link, dynamic link, debug, release, --with-openssl, --target=iOS, etc. at the CLI<br></p><p>Yup, Max and I have talked about this, I assume things like this will come eventually. I agree cargo&#39;s system here looks pretty well done, although I would also like to know more about how it is working in practice.<br></p><p>&gt; Have a synonym for &quot;make check&quot;<br></p><p>Part of current testing proposal.<br></p><p>&gt; Have a .lock file that records the dependency revs actually used<br></p><p>Yup, this is part of the plan.<br></p><p>&gt; Do something sane when the dependency repository is a git URL to an auto tools project<br></p><p>I&#39;m less interested in trying to do something automatic here. If someone comes up with something that &quot;just works&quot; in a huge % of cases once the rest of things are designed I would gladly take it. If it doesn&#39;t &quot;just work&quot; most of the time, I would much rather force someone to write the adaptor package if it means that all consumers get a more robust development experience, that seems like a better tradeoff.<br></p><p>&gt; I would +1 most of your proposal (prefer llbuild, scripting escape hatch, tagged sources, etc.) but I forsee a potential problem on this point:<br>&gt; <br>&gt;&gt; One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. <br>&gt; <br>&gt; <br>&gt; While this is true, this seems like an https://xkcd.com/927/ &lt;https://xkcd.com/927/&gt; kind of statement.  I think this project has the potential for moral authority (or &quot;force for change&quot; as you put it), but the exact magnitude of the moral authority is unknown and I estimate it lower than perhaps you do.<br>&gt; <br>&gt; I think swift-pm derives its moral authority from two facts:<br>&gt; <br>&gt; That it&#39;s an official, swift.org &lt;http://swift.org/&gt; project, like Rust&#39;s cargo, go get, etc.<br>&gt; That people want a build system for Linux now and so they have to rethink their packaging anyway<br>&gt; <br>&gt; However these two facts are only relevant for **swift** projects.  That is to say, libpng already builds on Linux and is not actively shopping for a new build system.  Nor do they care about packaging with the Approved Method™ from swift.org &lt;http://swift.org/&gt;, a language they do not even use.  And when push comes to shove, swift projects need libpng more badly than they need the Approved Packaging Method™.<br>&gt; <br>&gt; tl;dr it is actually the C dependencies here which have the moral authority.  Any conflict between what swift-pm wants and what libpng wants will be resolved in favor of libpng.  You cannot tell swift developers to go apply pressure to libpng to switch build systems; we lack standing.<br></p><p>I am generally a believer in &quot;if you build it *better*, they will come&quot;. My goals here are not to encourage change by being a moral authority, but by simply providing a better solution to real problems than already exists, even for projects that don&#39;t care about Swift.<br></p><p>I&#39;ve been a C/C++ developer a lot longer than I have been a Swift developer, and I think it is a real active pain point in those communities that there is no easy way to glue packages together. So what I am really shooting for here is a system that is so good, its worth it for a project like libpng to support just so that it is easier for their C clients to use.<br></p><p>&gt; <br>&gt;&gt; Well, we don&#39;t really support any of these features yet so our current advisement would be &quot;we need to design this feature&quot;. :)<br>&gt; <br>&gt; Well yes, but in the context of the above, I&#39;m suggesting that the C dependency story and courting libpng etc (if that is in fact important) is more important than nearly any other problem.  I can live for a few months without unit tests, configuration options, build environment isolation, versioning, etc. I can PR those as I need them, it is mostly obvious what is the right patch to write, from the README alone.<br>&gt; <br>&gt; I can&#39;t build without libsodium.  I can&#39;t build without libpng.  So forget about months, I can&#39;t get ten minutes into being a user even on one platform without making a decision on how to build C dependencies.  And it is much less obvious what the right thing to PR here is.<br></p><p>Well, for now the answer is that you have to install your C dependencies with a system package manager and then use the modules maps feature. We know there are issues even with that approach (like the portability of the module maps), and that seems like one area to tackle with individual PRs and more focused design discussions. If there are specific issues blocking this approach for &quot;just getting it working&quot; lets discuss that separately.<br></p><p>I agree this is important and will be actively working on this area, starting with a proposal for building C family sources which are part of the package. That should go some way to supporting more integration with C based stuff, and will also hopefully start to clarify what 2.b would look like.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; I think it is potentially something like your 2b, but it seems presently underspecified (&quot;We need to be very careful about doing #2.b in a way that doesn&#39;t restrict our ability to evolve&quot;) and I&#39;m uncertain if there&#39;s anything concrete that can be done to get it into an implementable state.<br>&gt; <br>&gt;&gt; On Dec 13, 2015, at 1:55 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 3:46 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt;&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, this is good information.  The output of the package manager is a .a (or .so, .dylib, Mach-O executable, etc.) and it is your job to install that to a path on your system, or not.  This seems like a good model.  I might suggest updating the README in some way that explains this.<br>&gt;&gt; <br>&gt;&gt; Good point, we don&#39;t really have any docs on the output. I don&#39;t have time to tackle this currently, but if patches here would be welcome. I believe Max also has some plans to make the build products more obvious (not hidden in the .build dir), the current system hasn&#39;t really been &quot;designed&quot; yet.<br>&gt;&gt; <br>&gt;&gt;&gt; This is actually vaguely analogous to Rust&#39;s cargo, so I would suggest looking there for design concepts, as they are quite a bit further ahead of us on this problem.<br>&gt;&gt; <br>&gt;&gt; Yup. I can&#39;t say I&#39;ve had the time to seriously study cargo and the state of its ecosystem, but I am aware of it. I&#39;d appreciate pointers if there are specific things you are thinking about.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m (sadly) intimately familiar.  It is not really all that easy, primarily because of binary hell, as anyone who has googled how to install pycairo can attest.  I really want to do better on this problem than Python does.<br>&gt;&gt; <br>&gt;&gt; I think it depends on the project. For web stacks it can be awesome to pull down a dependency tree w/ C extensions for PostgreSQL, Redis, etc. and a lot of stuff &quot;just works&quot;. For more complicated C projects I agree it isn&#39;t a slam dunk.<br>&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a concrete question: how would we advise a hypothetical swiftcairo project to package themselves in the package manager?  Should they:<br>&gt;&gt; <br>&gt;&gt; Well, we don&#39;t really support any of these features yet so our current advisement would be &quot;we need to design this feature&quot;. :)<br>&gt;&gt; <br>&gt;&gt;&gt; 1.  Call out to a shell script that does `brew install cairo` on OSX, `apt-get install cairo` on Debian, etc.<br>&gt;&gt; <br>&gt;&gt; Currently, this is the only supported thing. But I want to do better than this...<br>&gt;&gt; <br>&gt;&gt;&gt; 2.  Print some error telling them to come back when they&#39;ve installed cairo somewhere on their system.  Good luck, kid<br>&gt;&gt;&gt; 3.  Write a shell script that downloads and builds cairo from source including all its dependencies<br>&gt;&gt;&gt; 4.  Create a tree in the swift package manager like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swiftcairo &lt;-- cairo &lt;-------pixman<br>&gt;&gt;&gt;                      &lt;-------freetype<br>&gt;&gt;&gt;                      &lt;-------fontconfig<br>&gt;&gt;&gt;                      &lt;-------libpng<br>&gt;&gt;&gt;                      &lt;-------glib<br>&gt;&gt;&gt;   Where each of these &quot;packages&quot; are mostly a shell script that runs a lot of `curl -O` `tar xf` `configure` `make` etc.<br>&gt;&gt;&gt; 5.  Do we try and second-guess what libpng&#39;s autotools want to do?  (Bad, bad, idea.  Build the way libpng decided to build, don&#39;t try to guess based on the arrangement of .c files in a folder)<br>&gt;&gt;&gt; 6.  Other ideas?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A vision for the pathological case like Cairo will illuminate the simpler cases.  IMO it would be nice if &quot;depends: swiftcairo&quot; would &#39;just work&#39;, but that may be out of scope.<br>&gt;&gt; <br>&gt;&gt; My proposal is:<br>&gt;&gt; <br>&gt;&gt; 1. We include some native support for C/C++ libraries. This should be &quot;well designed&quot;, but ideally would scale up to supporting very support complex projects (like `swiftc`). I care about this part deeply because there is a lot of awesome stuff I want to do in llbuild + clang, and that depends on being able to get the project onto those tools. We will by necessity need to start with a small limited scope and feature creep our way forward.<br>&gt;&gt; <br>&gt;&gt; 2. We provide an adaption mechanism, to allow projects that can&#39;t yet be built by #1 to still integrate directly into the ecosystem. This can take two forms:<br>&gt;&gt; <br>&gt;&gt; 2.a. For projects which *could* conform to #1, but the only problem is the upstream project doesn&#39;t want to change (or hasn&#39;t yet), then we could support an adaption mechanism which just took in the upstream project and overlayed the appropriate Package.swift definitions that we need to use to build it. This means that swiftpm + llbuild would have a full understanding of the build process, which is the ideal scenario for the ensuring a good user experience.<br>&gt;&gt; <br>&gt;&gt; 2.b. For projects which are just &quot;too complicated&quot; to do #2.a, we would allow a form of your #3 (a shell script which downloads and builds). The way I envision this working is that:<br>&gt;&gt; - I&#39;d like to avoid the script actually downloading anything, I think we should still try and use our model for pulling the sources. This may mean someone maintains a tagged version of an adaptor package that includes the source of the upstream project + the adaptor pieces.<br>&gt;&gt; - We would require a very strict interface between that script and the rest of the package manager. Essentially, we would provide the script with its inputs, and we would expect it to produce, as an output, the exact kind of build layout that we ourselves would have done for project in case #2.a. In practice, those scripts would usually look something like &quot; configure &amp;&amp; make &amp;&amp; ... move the built products around a bunch to conform to the expected layout ...&quot;. We would run the script in appropriate dependency order, then ingest / audit all of the outputs, and from then on it would integrate just like #2.a.<br>&gt;&gt; <br>&gt;&gt; We need to be very careful about doing #2.b in a way that doesn&#39;t restrict our ability to evolve...<br>&gt;&gt; <br>&gt;&gt; One thing I would like to call out is that I don&#39;t feel like we need to directly support the total amount of complexity that exists in the world w.r.t. C family projects. I want use to help make the world more sane by coming up with sensible conventions and models for C family projects, and then apply pressure in other places to reduce unnecessary complexity or to converge on semi-standard solutions. I outlined a bit more of my philosophy here in:<br>&gt;&gt;   https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151130/000027.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20151130/000027.html&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NaOH &lt;https://code.sealedabstract.com/drewcrawford/NaOH&gt; is a good test case.  It&#39;s a framework that statically links libsodium.  My current (terrible) workflow is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1.  Download libsodium-xx.tar.gz &lt;https://github.com/jedisct1/libsodium/releases&gt; from GitHub<br>&gt;&gt;&gt; 2.  ./configure &amp;&amp; make<br>&gt;&gt;&gt; 3.  Move binaries + .h around to where Xcode can find them<br>&gt;&gt;&gt; 4.  Check into source control<br>&gt;&gt;&gt; 5.  Build<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would love to automate this and get it building with the package manager.  There&#39;s actually been an issue open &lt;https://code.sealedabstract.com/drewcrawford/NaOH/issues/1&gt; since pretty much day 1 to get this working.  That is the problem that motivated me to post.  <br>&gt;&gt; <br>&gt;&gt; Cool, thanks for the pointer I will check it out.<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 12, 2015, at 11:02 AM, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would say that our main goals are two fold:<br>&gt;&gt;&gt;&gt; 1. Support a great development experience for building projects from source, where we build everything into the sandbox for that project. We would like to eventually support being able to build more complex dependencies (like external C projects) as part of a package build.<br>&gt;&gt;&gt;&gt; 2. Leave deployment and installation of packages to system package managers (i.e., someone else).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a good example of #1, it would be awesome if in the future that even a project like the Swift compiler itself -- with its complicated dependency tree and build process -- could be configured and built with the package manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goals here are mostly oriented around how do we give the best possible developer experience for constructing source code. I strongly believe that the &quot;container&quot; / &quot;sandbox&quot; model is the right way to go in order to build tools which give reproducible results, allow for easy sharing and deployment, and encourage modular development. If you look at how easy and portable it is to install projects with complex dependencies in ecosystems like Python + virtualenv, that is the kind of environment we want for Swift and eventually for the C family dependencies.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Goal #2 of trying to stay out of the system package manager business (installing built software) is more out of trying to maintain a clear focus and emphasis than anything else. We already have a ton of work to do on the package manager even within that scope, so it just makes sense for now to leave this problem to existing projects better suited to the task.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I am working on a proposal for our initial support for *building* C family sources as part of Swift packages. Depending on exactly how complicated your dependencies are (and if you give me pointers to the full tree I would be interested in checking them out as test cases), this feature may be enough that you could in theory get your Swift package to also build the necessary C libraries (with some adaption work). Stay tuned...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 12, 2015, at 5:04 AM, Drew Crawford via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I noticed the README for the package manager seems to take a strong view of source distribution:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Packages are distributed and consumed as source code, rather than pre-compiled binaries.<br>&gt;&gt;&gt;&gt;&gt;&gt; Although it requires additional computational resources, this approach guarantees that developers can adopt new features on platforms they support, without being reliant on vendors to supply updated dependencies. This also has the advantage of allowing tools to do things like automated testing and API analysis of package dependencies.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I maintain a lot of Swift software with C dependencies.  For example, I develop Swift frameworks that ship with libsodium statically linked.  AFAIK the new Foundation will have various C dynamic and static dependencies.  Etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What is the vision for distributing this software with the package manager?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1.  Will it barf if the user does not have the C dependencies already installed on their machine?<br>&gt;&gt;&gt;&gt;&gt;   1a.  What about iOS, where there is no concept of this?  Can I not build iOS libraries using the package manager?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, it would barf. We are open to improving the reliability of the &quot;system modules&quot; mechanism to be more robust. We do need to support interoperating with installed libraries, and it would be great to make this as smooth as possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2.  Are all binary packages forbidden?  Is there any mechanism like homebrew&#39;s bottles for distributing software that is arcane to compile?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We don&#39;t have such a mechanism, and as I said the goal of the package manager is to build your project, not distribute it as installable packages. I can imagine adding mechanisms to *help you create* an easily installable product, but I think the actual installation of that product should be left to other tools.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3.  Can I write a script that tries to resolve various C dependencies my project needs to link with?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not currently. What exactly are you envisioning here?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4.  Is it a design goal to distribute Foundation via the package manager?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure what you mean. Foundation itself is a special case, it is something we consider part of the Swift corelibs and will ship with the Swift compiler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We *would* like to be able to build the Foundation project with the package manager, but there are a lot of things that need to get sorted out before that can happen.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; HTH,<br>&gt;&gt;&gt;&gt; - Daniel<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151213/94a1986d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>C dependencies</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; I can see how this might be useful, but don&#39;t really see what it buys you if that just turns around and calls something as open ended as configure. Can you say more about why this is a good thing?<br></p><p>I think the premise is that structured formats are useful for a lot of problems. One example, the README has some interesting ideas about automatically checking license compatibility.  This presumes the license of a package can be statically inferred.  If the package metadata are defined in a Turing-complete language then that gets hard.  If it is YAML or something the problem is much easier.<br></p><p>The idea of someone defining their license as a function evaluation seems rather silly, but if it is legal then someone will do it. I also forsee security problems with this approach.  Somebody who wants to write a swift-packages.org &lt;http://swift-packages.org/&gt; search engine is about to find their life very painful.<br></p><p>Calling out to a real program seems more appropriate for a &quot;so, you actually want to build this software&quot; scenario rather than questions of basic metadata like the examples that appear in this documentation &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/Package.swift.md&gt;.<br></p><p>&gt; I am generally a believer in &quot;if you build it *better*, they will come&quot;. My goals here are not to encourage change by being a moral authority, but by simply providing a better solution to real problems than already exists, even for projects that don&#39;t care about Swift.<br></p><p>This argument concerns me.  What evidence would you cite that this actually works?<br></p><p>My frame of reference is e.g., Carthage (which IMO is better than CocoaPods), Ninja / CMake (which IMO are better than autotools).  It is my observation that the better build systems are dwarfed by the popular ones.<br></p><p>Further, I have some experience lobbying random projects to move to an obviously better buildsystem.  Historically it&#39;s always bit of a bikeshed, and generally a complete waste of time.  Is your experience here different?<br></p><p>I don&#39;t like it; I wish I lived in a world where the best build tool wins.  But the evidence suggests I might not live in that world, so I find arguments of the form &quot;we will win because we have the best tool&quot; concerning.<br></p><p>&gt; If there are specific issues blocking this approach for &quot;just getting it working&quot; lets discuss that separately.<br></p><p>I&#39;m going to open separate discussions as I run into problems.  But the preview is: I need to run a prebuild script of some kind in order to even get started.  I may just end up PRing something, since the discussion here seems to be wandering away from that part of the problem.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/e6f909ff/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
