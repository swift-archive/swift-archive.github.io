<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 11:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 for the idea of making the naming consistent<br>-1 for the actual chosen names<br></p><p>Even after reading the reasoning behind the choice of those words, it took me a time to scratch my head around it. It’s definitely not immediately obvious that Convertible is bi-directional.<br></p><p>I would have preferred something much more obvious (even if less grammatically correct):<br></p><p>-InputProtocol<br>-OutputProtocol<br>-InputOutputProtocol or BidirectionalProtocol<br></p><p>Or:<br></p><p>-Inputable<br>-Outputable (got that from Haskell)<br>-InputOutputable or -Bidirectionalable<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes for the idea of making them consistent, no for the names.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Haskell uses Outputable.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal several times.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>May 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 10, 2016, at 5:56 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt;    * What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 for the idea of making the naming consistent<br>&gt; -1 for the actual chosen names<br>&gt; <br>&gt; Even after reading the reasoning behind the choice of those words, it took me a time to scratch my head around it. It’s definitely not immediately obvious that Convertible is bi-directional.<br>&gt; <br>&gt; I would have preferred something much more obvious (even if less grammatically correct):<br>&gt; <br>&gt; -InputProtocol<br>&gt; -OutputProtocol<br>&gt; -InputOutputProtocol or BidirectionalProtocol<br>&gt; <br>&gt; Or:<br>&gt; <br>&gt; -Inputable<br>&gt; -Outputable (got that from Haskell)<br>&gt; -InputOutputable or -Bidirectionalable<br></p><p>Thanks for your feedback.<br></p><p>To be honest, I&#39;m not a fan of the names you suggest.  Erica had a similar variation using To, From, and ToAndFrom prefixes that I find preferable to your suggestions if we were to go in this direction.  That said, I think the names in our proposal feel more Swifty.<br></p><p>&gt; <br>&gt;&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes for the idea of making them consistent, no for the names.<br>&gt; <br>&gt;&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; Haskell uses Outputable.<br>&gt; <br>&gt;&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Read the proposal several times.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 11, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 11 May 2016, at 01:02, Matthew Johnson &lt;musical.matthew at mac.com&gt; wrote:<br>&gt; <br>&gt; Thanks for your feedback.<br>&gt; <br>&gt; To be honest, I&#39;m not a fan of the names you suggest.  Erica had a similar variation using To, From, and ToAndFrom prefixes that I find preferable to your suggestions if we were to go in this direction.  That said, I think the names in our proposal feel more Swifty.<br></p><p>I don’t think that my suggestions should be taken literally, more as an example that I would prefer a much more straight forward naming scheme, to improve discoverability, even if it is at the expense of more “swift” names.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/0902a88c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br></p><p>Here are comments from someone who preferred to stay anonymous.  These are not my own:<br></p><p><br></p><p><br>* What is your evaluation of the proposal?<br></p><p>I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br></p><p>1) I agree with the proposal that Representable seems more suited to meaning “a representation can be created from this type”. This is in line with existing Cocoa APIs that use “dictionaryRepresentation” to generate a dictionary that represents the object (for e.g. serialization to JSON). See, for example, NSUbiquitousKeyValueStore, NSUserDefaults, and SCNTechnique. Out of those, only the last one can also be initialized from a dictionary, so the term “representation” as used in existing Cocoa frameworks seems better suited for implying only a one-way conversion (and also feels natural to me).<br></p><p>2) I’m not convinced on Creatable. I’ve been using Convertible for protocols that imply that the type can be initialized from another type (e.g. the DictionaryConvertible protocol would contain init(dictionary:), and thus SCNTechnique would conform to it). This also seems in line with the bulk of the “Convertible” protocols in the standard library today. The word “creatable&quot; strikes me as strange, because the term “create” isn’t used anywhere else in regards to initialization that I know of.<br></p><p>3) I’m not positive that we need a third protocol that implies bidirectionality. I’m not opposed to it, but if raw values conformed to both RawConvertible and RawRepresentable to indicate both their initialization and generated representation qualities, I’d be fine with that. And then maybe there’s just a typealias for RawValueProtocol that combines those for convenience.<br></p><p><br>* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes, in that I think it would be good to establish a clear convention here and stick to it. Whether the “Creatable” term is sufficiently clear to warrant a renaming of all the “Convertible” protocols, I’m not as sure about. I think at least CustomStringRepresentable and CustomDebugStringRepresentable would be worth doing since they imply a different direction from all the other “Convertible&quot; protocols.<br></p><p><br>* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, insofar as Swift generally seems to value predictability and consistency, and this would improve upon that.<br></p><p><br>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The most relevant library here I think is the Cocoa libraries, as mentioned above, which are already using the term “representation” to mean a one-way conversion to another type.<br></p><p><br>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve been thinking about this for a while with regards to dictionary serialization, because it’s so common for data models, but I haven’t necessarily thought through all the implications for e.g. raw values.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 6:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; <br>&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br></p><p><br>We&#39;d be happy to bikeshed again.<br></p><p>I think fundamentally our take on this is:<br></p><p>* We want there to be a standard that expresses the three conversion/initialization styles.<br>* We feel the system is currently broken. And we want to have a coherent and settled vision in place for 3, even imperfect.<br>* We&#39;re flexible about the naming but it should be (1) Swifty and (2) well grounded in meaning.<br></p><p>Let me turn the floor over to Matthew here.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>How about:<br></p><p>Consuming (from)<br>Producing (to)<br></p><p><br>IntegerLiteralConsuming<br>StringLiteralConsuming<br></p><p>CustomStringProducing<br>CustomDebugStringProducing<br></p><p><br>As for something that does both, all I could find was ‘bidirectional’, ‘two-way’, ‘mutual’, ‘duplex’. I tried searching in biology (https://en.wikipedia.org/wiki/Organic_reaction), but couldn’t find anything. I like the idea of just conforming to both protocols, and some sort of protocol typealias. Or staying with Representable.<br></p><p><br>&gt; On 11 May 2016, at 12:33 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 10, 2016, at 6:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt; <br>&gt;&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt; <br>&gt; <br>&gt; We&#39;d be happy to bikeshed again.<br>&gt; <br>&gt; I think fundamentally our take on this is:<br>&gt; <br>&gt; * We want there to be a standard that expresses the three conversion/initialization styles.<br>&gt; * We feel the system is currently broken. And we want to have a coherent and settled vision in place for 3, even imperfect.<br>&gt; * We&#39;re flexible about the naming but it should be (1) Swifty and (2) well grounded in meaning.<br>&gt; <br>&gt; Let me turn the floor over to Matthew here.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>I like those a lot. Crystal clear.<br></p><p>&gt; On 11 May 2016, at 05:14, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; Consuming (from)<br>&gt; Producing (to)<br>&gt; <br>&gt; <br>&gt; IntegerLiteralConsuming<br>&gt; StringLiteralConsuming<br>&gt; <br>&gt; CustomStringProducing<br>&gt; CustomDebugStringProducing<br>&gt; <br>&gt; <br>&gt; As for something that does both, all I could find was ‘bidirectional’, ‘two-way’, ‘mutual’, ‘duplex’. I tried searching in biology (https://en.wikipedia.org/wiki/Organic_reaction), but couldn’t find anything. I like the idea of just conforming to both protocols, and some sort of protocol typealias. Or staying with Representable.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 12:33 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 6:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We&#39;d be happy to bikeshed again.<br>&gt;&gt; <br>&gt;&gt; I think fundamentally our take on this is:<br>&gt;&gt; <br>&gt;&gt; * We want there to be a standard that expresses the three conversion/initialization styles.<br>&gt;&gt; * We feel the system is currently broken. And we want to have a coherent and settled vision in place for 3, even imperfect.<br>&gt;&gt; * We&#39;re flexible about the naming but it should be (1) Swifty and (2) well grounded in meaning.<br>&gt;&gt; <br>&gt;&gt; Let me turn the floor over to Matthew here.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>On Tue, May 10, 2016 at 9:33 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 10, 2016, at 6:51 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hello Swift community,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for<br>&gt; Conversions&quot; begins now and runs through May 16. The proposal is available<br>&gt; here:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; &gt;<br>&gt; &gt; Here are comments from someone who preferred to stay anonymous.  These<br>&gt; are not my own:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; * What is your evaluation of the proposal?<br>&gt; &gt;<br>&gt; &gt; I rather agree with the comments mentioned in the proposal from the<br>&gt; Standard Library design team, in that I agree with the basic intention of<br>&gt; the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt;<br>&gt;<br>&gt; We&#39;d be happy to bikeshed again.<br>&gt;<br>&gt; I think fundamentally our take on this is:<br>&gt;<br>&gt; * We want there to be a standard that expresses the three<br>&gt; conversion/initialization styles.<br>&gt; * We feel the system is currently broken. And we want to have a coherent<br>&gt; and settled vision in place for 3, even imperfect.<br>&gt; * We&#39;re flexible about the naming but it should be (1) Swifty and (2) well<br>&gt; grounded in meaning.<br>&gt;<br>&gt; Let me turn the floor over to Matthew here.<br>&gt;<br></p><p>Like David Hart and the anonymous reviewer, I agree that the problem is<br>worth solving but the proposed names leave something to be desired. I&#39;d<br>like to offer a minimalist suggestion:<br></p><p>Initializable -- for what&#39;s currently &quot;LiteralConvertible&quot; (and also<br>StringInterpolationConvertible)<br>Convertible -- for &quot;StringConvertible&quot; protocols<br>Representable -- keep as it is currently<br></p><p>I agree with others that &quot;Creatable&quot; is a strange term because it&#39;s not<br>used anywhere else. Looking at the auto-generated docs for the<br>&quot;LiteralConvertible&quot; protocols, it says that conforming types &quot;can be<br>initialized with&quot; whatever thing is said to be convertible. I think that<br>offers a pretty clear alternative word--namely, &quot;initializable.&quot;<br></p><p>I can live with &quot;convertible&quot; being one-way. Not all &quot;convertible&quot; things<br>are like convertible cars. When you convert from one faith to another, for<br>example, some level of finality is intended.<br></p><p>I can also live with the current usage of the term &quot;representable.&quot; In the<br>context of things like &quot;representable values&quot; in floating point types,<br>representability suggests exactness and thus round-trippability.<br></p><p>(And to use the example in the proposal, a lawyer who represents you well<br>[*] is one that communicates your position to the court. You &quot;input&quot; your<br>position, your lawyer goes to court, and then they &quot;output&quot; your position<br>in legalese to the court. If there&#39;s degradation in the quality of the<br>&quot;output,&quot; then you&#39;ve been inadequately represented.)<br></p><p>[*And, it bears clarifying that your lawyer is considered to represent<br>*you* and not merely *your interests*. If you&#39;re the plaintiff in a case<br>and your lawyers says, &quot;My client&#39;s entitled to a million dollars!&quot;, the<br>court can restate that as &quot;Plaintiff argues that she&#39;s entitled to a<br>million dollars.&quot;]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/558cc7dc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 9:33 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 6:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt; <br>&gt;&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt; <br>&gt; <br>&gt; We&#39;d be happy to bikeshed again.<br>&gt; <br>&gt; I think fundamentally our take on this is:<br>&gt; <br>&gt; * We want there to be a standard that expresses the three conversion/initialization styles.<br>&gt; * We feel the system is currently broken. And we want to have a coherent and settled vision in place for 3, even imperfect.<br>&gt; * We&#39;re flexible about the naming but it should be (1) Swifty and (2) well grounded in meaning.<br>&gt; <br>&gt; Let me turn the floor over to Matthew here.<br></p><p>I agree with Erica here.  <br></p><p>There was a significant round of bike shedding that went into this proposal a few months ago, but there is no harm in continuing that exercise now that a broader audience is engaged.  As many reviewers have agreed, the important thing is to settle on *something*.<br></p><p>Several reviewers have mentioned Creatable as not feeling Swifty.  FWIW, the history behind the name is that we wanted something that will work regardless of the mechanism.  It should be a sensible name whether the requirement is an initializer or a factory method.<br></p><p>I&#39;m hoping we can reach a convention that most of us are happy with by the end of the review period.  <br></p><p>&gt; <br>&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 11, 2016, at 7:29 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We&#39;d be happy to bikeshed again.<br>&gt;&gt; <br>&gt;&gt; I think fundamentally our take on this is:<br>&gt;&gt; <br>&gt;&gt; * We want there to be a standard that expresses the three conversion/initialization styles.<br>&gt;&gt; * We feel the system is currently broken. And we want to have a coherent and settled vision in place for 3, even imperfect.<br>&gt;&gt; * We&#39;re flexible about the naming but it should be (1) Swifty and (2) well grounded in meaning.<br>&gt;&gt; <br>&gt;&gt; Let me turn the floor over to Matthew here.<br>&gt; <br>&gt; I agree with Erica here.  <br>&gt; <br>&gt; There was a significant round of bike shedding that went into this proposal a few months ago, but there is no harm in continuing that exercise now that a broader audience is engaged.  As many reviewers have agreed, the important thing is to settle on *something*.<br>&gt; <br>&gt; Several reviewers have mentioned Creatable as not feeling Swifty.  FWIW, the history behind the name is that we wanted something that will work regardless of the mechanism.  It should be a sensible name whether the requirement is an initializer or a factory method.<br>&gt; <br>&gt; I&#39;m hoping we can reach a convention that most of us are happy with by the end of the review period.  <br></p><p>If anyone wants to look back at the original discussion, you can find it here:<br></p><p>http://thread.gmane.org/gmane.comp.lang.swift.evolution/10883 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/10883&gt;<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/6397759b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>While the community feedback on our SE-0041 proposal &quot;Updating Protocol Naming Conventions for Conversions&quot; (https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md) has been positive about the need to establish conventions, feedback has been mixed to negative with regard to the specific conventions suggested in the proposal.<br></p><p>With that in mind, Erica and I have been working on refactoring those recommendations. We put together the following update and invite the community to bikeshed further with us. We hope this offers the Swift core team the flexibility to accept our proposal &quot;with revision&quot; if an alternative garners more support. With luck, we&#39;ll reach a naming consensus during the review period.<br></p><p>UPDATED APPROACH<br></p><p>Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br></p><p>1. `Initializable`<br></p><p>`Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br></p><p>For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br></p><p>This phrase replaces the `Creatable` form from our original proposal.<br></p><p>2. `Representable`<br></p><p>`Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br></p><p>This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing. <br></p><p>FUTURE DIRECTIONS<br></p><p>We did not include a third category for bidirectional conversion in this update. We recognize that style of contract is rare in Swift. Lossless conversion does not appear in the standard library outside of `RawRepresentable`, which we agreed was better covered by `Representable`. If such a convention is needed or adopted, we reserve the `Isomorphic` designation for future use.<br></p><p>Sent from my iPad<br></p><p>&gt; On May 10, 2016, at 7:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; <br>&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; * What is your evaluation of the proposal?<br>&gt; <br>&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt; <br>&gt; 1) I agree with the proposal that Representable seems more suited to meaning “a representation can be created from this type”. This is in line with existing Cocoa APIs that use “dictionaryRepresentation” to generate a dictionary that represents the object (for e.g. serialization to JSON). See, for example, NSUbiquitousKeyValueStore, NSUserDefaults, and SCNTechnique. Out of those, only the last one can also be initialized from a dictionary, so the term “representation” as used in existing Cocoa frameworks seems better suited for implying only a one-way conversion (and also feels natural to me).<br>&gt; <br>&gt; 2) I’m not convinced on Creatable. I’ve been using Convertible for protocols that imply that the type can be initialized from another type (e.g. the DictionaryConvertible protocol would contain init(dictionary:), and thus SCNTechnique would conform to it). This also seems in line with the bulk of the “Convertible” protocols in the standard library today. The word “creatable&quot; strikes me as strange, because the term “create” isn’t used anywhere else in regards to initialization that I know of.<br>&gt; <br>&gt; 3) I’m not positive that we need a third protocol that implies bidirectionality. I’m not opposed to it, but if raw values conformed to both RawConvertible and RawRepresentable to indicate both their initialization and generated representation qualities, I’d be fine with that. And then maybe there’s just a typealias for RawValueProtocol that combines those for convenience.<br>&gt; <br>&gt; <br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes, in that I think it would be good to establish a clear convention here and stick to it. Whether the “Creatable” term is sufficiently clear to warrant a renaming of all the “Convertible” protocols, I’m not as sure about. I think at least CustomStringRepresentable and CustomDebugStringRepresentable would be worth doing since they imply a different direction from all the other “Convertible&quot; protocols.<br>&gt; <br>&gt; <br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes, insofar as Swift generally seems to value predictability and consistency, and this would improve upon that.<br>&gt; <br>&gt; <br>&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; The most relevant library here I think is the Cocoa libraries, as mentioned above, which are already using the term “representation” to mean a one-way conversion to another type.<br>&gt; <br>&gt; <br>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I’ve been thinking about this for a while with regards to dictionary serialization, because it’s so common for data models, but I haven’t necessarily thought through all the implications for e.g. raw values.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/2150ca8b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Taking the suggested changes into account, here&#39;s my review.<br></p><p>1) +1, I think this is a reasonable way for naming this family of protocols.<br></p><p>2) The problem isn&#39;t huge, but I think it&#39;s worth fixing. So far, the naming of stdlib protocols has been somewhat inconsistent in this regard.<br></p><p>3) I&#39;ve used other languages &amp; stdlibs with similar naming schemes, although none of them used the words &quot;initializable&quot; and &quot;representable&quot;. Common alternatives have been word compositions involving expressions such as &quot;convertible&quot;, &quot;from&quot;, &quot;to&quot;, &quot;bi(jective)&quot;, &quot;can build&quot;. However, I think &quot;init&quot; is so central in Swift that the use of &quot;Initializable&quot; is well justified. &quot;Representable&quot; is slightly less so but self-explanatory IMO, and more so than &quot;convertible&quot; which could be understood either or both ways.<br></p><p>4) Quick reading.<br></p><p>— Pyry<br></p><p>&gt; On 13 May 2016, Matthew Johnson wrote:<br>&gt; <br>&gt; While the community feedback on our SE-0041 proposal &quot;Updating Protocol Naming Conventions for Conversions&quot; (https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;) has been positive about the need to establish conventions, feedback has been mixed to negative with regard to the specific conventions suggested in the proposal.<br>&gt; <br>&gt; With that in mind, Erica and I have been working on refactoring those recommendations. We put together the following update and invite the community to bikeshed further with us. We hope this offers the Swift core team the flexibility to accept our proposal &quot;with revision&quot; if an alternative garners more support. With luck, we&#39;ll reach a naming consensus during the review period.<br>&gt; <br>&gt; UPDATED APPROACH<br>&gt; <br>&gt; Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br>&gt; <br>&gt; 1. `Initializable`<br>&gt; <br>&gt; `Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br>&gt; <br>&gt; For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br>&gt; <br>&gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt; <br>&gt; 2. `Representable`<br>&gt; <br>&gt; `Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br>&gt; <br>&gt; This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing. <br>&gt; <br>&gt; FUTURE DIRECTIONS<br>&gt; <br>&gt; We did not include a third category for bidirectional conversion in this update. We recognize that style of contract is rare in Swift. Lossless conversion does not appear in the standard library outside of `RawRepresentable`, which we agreed was better covered by `Representable`. If such a convention is needed or adopted, we reserve the `Isomorphic` designation for future use.<br>&gt; <br>&gt; Sent from my iPad<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/b88c8136/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>I appreciate your rework on this - I still don’t understand one thing and disagree with a second:<br></p><p>(1) I don’t understand what the word “Custom” adds to CustomStringRepresentable and CustomDebugStringRepresentable and would drop that prefix (even if it remains Convertible).<br></p><p>(2) The use case for these two still stands out from every other protocol on the list. The intent is (was) better captured by “Describable”. i.e. these are things for which there is a description. I think it is more descriptive to name them Describable and DebugDescribable.<br></p><p>Best,<br></p><p>Daniel<br>&gt; On May 13, 2016, at 12:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While the community feedback on our SE-0041 proposal &quot;Updating Protocol Naming Conventions for Conversions&quot; (https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;) has been positive about the need to establish conventions, feedback has been mixed to negative with regard to the specific conventions suggested in the proposal.<br>&gt; <br>&gt; With that in mind, Erica and I have been working on refactoring those recommendations. We put together the following update and invite the community to bikeshed further with us. We hope this offers the Swift core team the flexibility to accept our proposal &quot;with revision&quot; if an alternative garners more support. With luck, we&#39;ll reach a naming consensus during the review period.<br>&gt; <br>&gt; UPDATED APPROACH<br>&gt; <br>&gt; Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br>&gt; <br>&gt; 1. `Initializable`<br>&gt; <br>&gt; `Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br>&gt; <br>&gt; For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br>&gt; <br>&gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt; <br>&gt; 2. `Representable`<br>&gt; <br>&gt; `Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br>&gt; <br>&gt; This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing. <br>&gt; <br>&gt; FUTURE DIRECTIONS<br>&gt; <br>&gt; We did not include a third category for bidirectional conversion in this update. We recognize that style of contract is rare in Swift. Lossless conversion does not appear in the standard library outside of `RawRepresentable`, which we agreed was better covered by `Representable`. If such a convention is needed or adopted, we reserve the `Isomorphic` designation for future use.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 10, 2016, at 7:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;<br>&gt;&gt; <br>&gt;&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt;&gt; <br>&gt;&gt; 1) I agree with the proposal that Representable seems more suited to meaning “a representation can be created from this type”. This is in line with existing Cocoa APIs that use “dictionaryRepresentation” to generate a dictionary that represents the object (for e.g. serialization to JSON). See, for example, NSUbiquitousKeyValueStore, NSUserDefaults, and SCNTechnique. Out of those, only the last one can also be initialized from a dictionary, so the term “representation” as used in existing Cocoa frameworks seems better suited for implying only a one-way conversion (and also feels natural to me).<br>&gt;&gt; <br>&gt;&gt; 2) I’m not convinced on Creatable. I’ve been using Convertible for protocols that imply that the type can be initialized from another type (e.g. the DictionaryConvertible protocol would contain init(dictionary:), and thus SCNTechnique would conform to it). This also seems in line with the bulk of the “Convertible” protocols in the standard library today. The word “creatable&quot; strikes me as strange, because the term “create” isn’t used anywhere else in regards to initialization that I know of.<br>&gt;&gt; <br>&gt;&gt; 3) I’m not positive that we need a third protocol that implies bidirectionality. I’m not opposed to it, but if raw values conformed to both RawConvertible and RawRepresentable to indicate both their initialization and generated representation qualities, I’d be fine with that. And then maybe there’s just a typealias for RawValueProtocol that combines those for convenience.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, in that I think it would be good to establish a clear convention here and stick to it. Whether the “Creatable” term is sufficiently clear to warrant a renaming of all the “Convertible” protocols, I’m not as sure about. I think at least CustomStringRepresentable and CustomDebugStringRepresentable would be worth doing since they imply a different direction from all the other “Convertible&quot; protocols.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, insofar as Swift generally seems to value predictability and consistency, and this would improve upon that.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The most relevant library here I think is the Cocoa libraries, as mentioned above, which are already using the term “representation” to mean a one-way conversion to another type.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I’ve been thinking about this for a while with regards to dictionary serialization, because it’s so common for data models, but I haven’t necessarily thought through all the implications for e.g. raw values.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/155fd222/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 14, 2016, at 8:45 AM, Daniel Steinberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I appreciate your rework on this - I still don’t understand one thing and disagree with a second:<br>&gt; <br>&gt; (1) I don’t understand what the word “Custom” adds to CustomStringRepresentable and CustomDebugStringRepresentable and would drop that prefix (even if it remains Convertible).<br></p><p>We did not introduce &quot;Custom&quot;. That is sourced from the Swift core team. Reevaluating that name would have to fall under the umbrella of a separate proposal. Our focus is keyword conventions.<br></p><p>&gt; (2) The use case for these two still stands out from every other protocol on the list. The intent is (was) better captured by “Describable”. i.e. these are things for which there is a description. I think it is more descriptive to name them Describable and DebugDescribable.<br></p><p>It is a representation suitable for printing or debug printing. We included them because they are a part of the existing art in the standard library.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May 15, 2016 at 04:00:00am</p></header><div class="content"><p>On Sat, May 14, 2016 at 7:45 AM, Daniel Steinberg via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I appreciate your rework on this - I still don’t understand one thing and<br>&gt; disagree with a second:<br>&gt;<br>&gt; (1) I don’t understand what the word “Custom” adds to<br>&gt; CustomStringRepresentable and CustomDebugStringRepresentable and would drop<br>&gt; that prefix (even if it remains Convertible).<br></p><p>In Swift, every value has a string and a debugging string<br>representation, synthesized by the runtime.  These protocols allow<br>customizing the default behavior.  We don&#39;t want users to write any<br>APIs against these protocols, because it is the wrong thing to do.<br></p><p>In Swift 1, when the protocols were named Printable and<br>DebugPrintable, many users wrote APIs like this:<br></p><p>func printAll(_ values: [Printable]) {<br>  for x in values { print(x) }<br>}<br></p><p>&#39;Printable&#39; is a wrong constraint.  Everything is printable, and<br>user-defined types that are happy with the default string<br>representation don&#39;t customize it; structural types (function types,<br>tuples) can not adopt a protocol at all.  Users can&#39;t pass instances<br>of such types to this overconstrained API.  The right API to design<br>is:<br></p><p>func printAll(_ values: [Any]) {<br>  for x in values { print(x) }<br>}<br></p><p>Motivation behind renaming Printable to CustomStringRepresentable was<br>to discourage writing APIs against these protocols.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>I like this much better but would recommend the word “Custom” be dropped from StringRepresentable and DebugS<br>&gt; On May 13, 2016, at 12:31 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While the community feedback on our SE-0041 proposal &quot;Updating Protocol Naming Conventions for Conversions&quot; (https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;) has been positive about the need to establish conventions, feedback has been mixed to negative with regard to the specific conventions suggested in the proposal.<br>&gt; <br>&gt; With that in mind, Erica and I have been working on refactoring those recommendations. We put together the following update and invite the community to bikeshed further with us. We hope this offers the Swift core team the flexibility to accept our proposal &quot;with revision&quot; if an alternative garners more support. With luck, we&#39;ll reach a naming consensus during the review period.<br>&gt; <br>&gt; UPDATED APPROACH<br>&gt; <br>&gt; Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br>&gt; <br>&gt; 1. `Initializable`<br>&gt; <br>&gt; `Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br>&gt; <br>&gt; For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br>&gt; <br>&gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt; <br>&gt; 2. `Representable`<br>&gt; <br>&gt; `Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br>&gt; <br>&gt; This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing. <br>&gt; <br>&gt; FUTURE DIRECTIONS<br>&gt; <br>&gt; We did not include a third category for bidirectional conversion in this update. We recognize that style of contract is rare in Swift. Lossless conversion does not appear in the standard library outside of `RawRepresentable`, which we agreed was better covered by `Representable`. If such a convention is needed or adopted, we reserve the `Isomorphic` designation for future use.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 10, 2016, at 7:51 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:48 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;<br>&gt;&gt; <br>&gt;&gt; Here are comments from someone who preferred to stay anonymous.  These are not my own:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I rather agree with the comments mentioned in the proposal from the Standard Library design team, in that I agree with the basic intention of the proposal, but I’m not convinced about the proposed answer. Specifically:<br>&gt;&gt; <br>&gt;&gt; 1) I agree with the proposal that Representable seems more suited to meaning “a representation can be created from this type”. This is in line with existing Cocoa APIs that use “dictionaryRepresentation” to generate a dictionary that represents the object (for e.g. serialization to JSON). See, for example, NSUbiquitousKeyValueStore, NSUserDefaults, and SCNTechnique. Out of those, only the last one can also be initialized from a dictionary, so the term “representation” as used in existing Cocoa frameworks seems better suited for implying only a one-way conversion (and also feels natural to me).<br>&gt;&gt; <br>&gt;&gt; 2) I’m not convinced on Creatable. I’ve been using Convertible for protocols that imply that the type can be initialized from another type (e.g. the DictionaryConvertible protocol would contain init(dictionary:), and thus SCNTechnique would conform to it). This also seems in line with the bulk of the “Convertible” protocols in the standard library today. The word “creatable&quot; strikes me as strange, because the term “create” isn’t used anywhere else in regards to initialization that I know of.<br>&gt;&gt; <br>&gt;&gt; 3) I’m not positive that we need a third protocol that implies bidirectionality. I’m not opposed to it, but if raw values conformed to both RawConvertible and RawRepresentable to indicate both their initialization and generated representation qualities, I’d be fine with that. And then maybe there’s just a typealias for RawValueProtocol that combines those for convenience.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, in that I think it would be good to establish a clear convention here and stick to it. Whether the “Creatable” term is sufficiently clear to warrant a renaming of all the “Convertible” protocols, I’m not as sure about. I think at least CustomStringRepresentable and CustomDebugStringRepresentable would be worth doing since they imply a different direction from all the other “Convertible&quot; protocols.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Yes, insofar as Swift generally seems to value predictability and consistency, and this would improve upon that.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt;&gt; The most relevant library here I think is the Cocoa libraries, as mentioned above, which are already using the term “representation” to mean a one-way conversion to another type.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; I’ve been thinking about this for a while with regards to dictionary serialization, because it’s so common for data models, but I haven’t necessarily thought through all the implications for e.g. raw values.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160514/d69a54c6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 17, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; UPDATED APPROACH<br>&gt; <br>&gt; Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br>&gt; <br>&gt; 1. `Initializable`<br>&gt; <br>&gt; `Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br>&gt; <br>&gt; For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br>&gt; <br>&gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt; <br>&gt; 2. `Representable`<br>&gt; <br>&gt; `Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br>&gt; <br>&gt; This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing. <br></p><p>If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On May 17, 2016, at 11:32 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; UPDATED APPROACH<br>&gt;&gt; <br>&gt;&gt; Our updated approach focuses on the two most important conventions: one for initialization and one for representation.<br>&gt;&gt; <br>&gt;&gt; 1. `Initializable`<br>&gt;&gt; <br>&gt;&gt; `Initializable` designates protocols that convert *from* a type or from an associated type mentioned in the protocol name, such as the current `&lt;Type&gt;LiteralConvertible` protocols.  This convention would include member requirements for initializers, factory methods, and any other way an instance can be imported to establish a new instance of the conforming type.<br>&gt;&gt; <br>&gt;&gt; For example, conforming to `ArrayLiteralInitializable` would allow a set to be created with `Set(arrayLiteral: &lt;some array&gt;)` and `var set: Set&lt;T&gt; = []`.<br>&gt;&gt; <br>&gt;&gt; This phrase replaces the `Creatable` form from our original proposal.<br>&gt;&gt; <br>&gt;&gt; 2. `Representable`<br>&gt;&gt; <br>&gt;&gt; `Representable` designates protocols whose primary purpose is to project *to* a type or associated type mentioned in the protocol name.  Items in the standard library that would be subsumed into this naming include `CustomStringConvertible`, `CustomDebugStringConvertible`, and `RawRepresentable`, which we imagine would become `CustomStringRepresentable`, `CustomDebugStringRepresentable`, and (as current) `RawRepresentable`.<br>&gt;&gt; <br>&gt;&gt; This second category groups together the `Convertible` and `Representable` categories from our original proposal and is predicated on the feedback from the design team review. The `Representable` designation does not promise bidirectional conversion although some `Representable` protocols may include requirements to allow attempted initialization *from* the type of the representation. Doing so falls outside the naming contract we are proposing.<br>&gt; <br>&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br></p><p>Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br>&gt; <br>&gt; Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br></p><p>I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br></p><p>Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 18 May 2016, Brent Royal-Gordon wrote:<br>&gt; <br>&gt; I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br>&gt; <br>&gt; Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br></p><p>Isn&#39;t it odd that we use four different terms for both kinds of String conversions that we have?<br></p><p>    A1: extension Foo : CustomStringConvertible // proposed: CustomStringRepresentable<br>    A2: foo.description<br>    A3: String(foo) // or `String(printing: foo)` if SE-0089 gets accepted<br>    A4: print(foo)<br></p><p>    B1: extension Foo : CustomDebugStringConvertible // proposed: CustomDebugStringRepresentable<br>    B2: foo.debugDescription<br>    B3: String(reflecting: foo)<br>    B4: debugPrint(foo)<br></p><p>I don&#39;t have great suggestions but wouldn&#39;t it be better to move the naming of cases 1 &amp; 2 towards the words used in cases 3 &amp; 4?<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/6da456ef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br>&gt;&gt; <br>&gt;&gt; Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br>&gt; <br>&gt; I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br>&gt; <br>&gt; Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br></p><p>Thanks for elaborating.  I can see that perspective.  It does also have the advantage of being the smallest change from current state.<br></p><p>I certainly wouldn’t oppose this.  The most important thing IMO is that we agree on *something*.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 1:58 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 1:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br>&gt;&gt; <br>&gt;&gt; Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br>&gt; <br>&gt; Thanks for elaborating.  I can see that perspective.  It does also have the advantage of being the smallest change from current state.<br>&gt; <br>&gt; I certainly wouldn’t oppose this.  The most important thing IMO is that we agree on *something*.<br></p><p><br>The whole discussion started because ArrayLiteralConvertible meant &quot;can be initialized from Array literal&quot;, and not &quot;can be converted to array literal&quot;, which is what nearly everyone this was presented to in an informal study thought it meant.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:01 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 18, 2016, at 1:58 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 1:52 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br>&gt;&gt; <br>&gt;&gt; Thanks for elaborating.  I can see that perspective.  It does also have the advantage of being the smallest change from current state.<br>&gt;&gt; <br>&gt;&gt; I certainly wouldn’t oppose this.  The most important thing IMO is that we agree on *something*.<br>&gt; <br>&gt; <br>&gt; The whole discussion started because ArrayLiteralConvertible meant &quot;can be initialized from Array literal&quot;, and not &quot;can be converted to array literal&quot;, which is what nearly everyone this was presented to in an informal study thought it meant.<br>&gt; <br></p><p>That was not the genesis of this proposal in my mind.  I was frustrated with the different semantics for Convertible between CustomStringConvertible and *LiteralConvertible.  <br></p><p>However, I do agree that there is some potential for ambiguity inherent in the term Convertible which is probably how the current conflicting uses arose in the first place.<br></p><p>Whatever we decide to do, I hope we can at least remove the current conflict and have consistent meanings in the standard library!<br></p><p>&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt; The whole discussion started because ArrayLiteralConvertible meant &quot;can be initialized from Array literal&quot;, and not &quot;can be converted to array literal&quot;, which is what nearly everyone this was presented to in an informal study thought it meant.<br>&gt;&gt; <br>&gt; <br>&gt; That was not the genesis of this proposal in my mind.  I was frustrated with the different semantics for Convertible between CustomStringConvertible and *LiteralConvertible.  <br></p><p>That&#39;s where *I* jumped on board. Sorry, I should have made it clearer.<br></p><p>&gt; However, I do agree that there is some potential for ambiguity inherent in the term Convertible which is probably how the current conflicting uses arose in the first place.<br>&gt; <br>&gt; Whatever we decide to do, I hope we can at least remove the current conflict and have consistent meanings in the standard library!<br></p><p>No matter how the core team rules, I hope there&#39;s an improvement over the status quo.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/0dfc7e11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 18, 2016, at 3:17 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The whole discussion started because ArrayLiteralConvertible meant &quot;can be initialized from Array literal&quot;, and not &quot;can be converted to array literal&quot;, which is what nearly everyone this was presented to in an informal study thought it meant.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; That was not the genesis of this proposal in my mind.  I was frustrated with the different semantics for Convertible between CustomStringConvertible and *LiteralConvertible.  <br>&gt; <br>&gt; That&#39;s where *I* jumped on board. Sorry, I should have made it clearer.<br></p><p>Sure.  :-)  I didn’t actually know this until today!<br></p><p>&gt; <br>&gt;&gt; However, I do agree that there is some potential for ambiguity inherent in the term Convertible which is probably how the current conflicting uses arose in the first place.<br>&gt;&gt; <br>&gt;&gt; Whatever we decide to do, I hope we can at least remove the current conflict and have consistent meanings in the standard library!<br>&gt; <br>&gt; No matter how the core team rules, I hope there&#39;s an improvement over the status quo.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/d1d7ce39/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Am 18.05.2016 um 20:52 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt;&gt; If we&#39;re doing this, I wonder if category 1 shouldn&#39;t just be `Convertible`. This would preserve our `LiteralConvertible` protocols with the same names (which, consistency issues aside, seem perfectly cromulent), while shifting the `StringConvertible` protocols over to the `Representable` category.<br>&gt;&gt; <br>&gt;&gt; Do you really think &#39;Convertible&#39; is more clear than &#39;Initializable&#39;?<br>&gt; <br>&gt; I don&#39;t think `Convertible` is clearer than `Initializable`, but I think it rolls off the tongue better, is easier to spell, is more compatible with non-initializer implementations, and in general wins on a lot of squishy, subjective, hard-to-define axes.<br></p><p>Well put!<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; Subjectively, I&#39;ve noticed that a lot of people *don&#39;t* think of things like `Double(myFloat)` as being initializers; they think of them as conversions. To those people, `Convertible` is probably the right name.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/423beb7cfb5894f7b53623d6e515b01d?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Jed Lewison</string> &lt;jed.lewison at icloud.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>I agree that CustomStringConvertible and CustomDebugStringConvertible are confusing, but in general, ‘Convertible’ and ‘Representable’ as currently used actually make sense to me.<br></p><p>Convert means to transform, so it feels natural to me to think of something that is a FooLiteralConvertible as being something that be converted from a FooLiteral.<br></p><p>To represent means to stand in for, so it feels natural to say that if a can represent b and b can represent a, then it’s representable.<br></p><p>The rub comes with CustomStringConvertible and CustomDebugStringConvertible, which while it makes sense linguistically, creates confusion in Swift because it converts in the opposite direction of all the other convertible protocols.<br></p><p>I’m not sure what the rationale was for moving away from Printable and DebugPrintable; maybe it was that everything should be printable? If so, then perhaps CustomPrintable and CustomDebugPrintable would do the job?<br></p><p>&gt; On May 10, 2016, at 11:48 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>May 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md&gt;<br></p><p>&gt; 	* What is your evaluation of the proposal?<br>-1.<br></p><p>I’m not 100% sure on the names (can we paint the bike shed plaid?) but more importantly, I’m not sure the groupings are adequate<br></p><p>RawRepresentable seems to represent a sub-type declaring a super type coercion system.<br></p><p>The various literal-based initializers are not necessarily coercion operators - some operations (e.g. initializing a Set from a literal with repeating elements) are lossy. These initializers also are not given a mechanism to recover from failure (possibly because the literals mean that failure represents a precondition failure in the written code?). That would imply that these literal-based initializers are special - a non-literal needs failure-reporting semantics.<br></p><p>CustomStringRepresentable is not meant for any sort of type conversion. It returns a user presentation of the object as text (while the Debug variant is meant to return a developer presentation)<br></p><p>So I don’t feel these represent In, Out, and InOut but instead three different classifications of conversions.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Now is a great time for naming consistency<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Future direction there may be another change if coercion is defined as a language feature (such as implicit numeric coercion)<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I thought of Ruby and the difference between to_s and to_str.  The idea of a representation as a type vs coercion to a type is a hard one to learn.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A quick reading.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/0035db7d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>+1 for the classification of the protocols to be renamed<br></p><p>I completely agree that you can divide the protocols being examined into those categories and I appreciate the effort put in to doing so.<br></p><p>-1 for the names chosen<br></p><p>======<br></p><p>The new Representable is being applied to - <br></p><p>CustomStringConvertible and CustomDebugStringConvertible. <br></p><p>I wouldn’t be upset with calling these StringRepresentable and DebugStringRepresentable but I would argue that these are very specific protocols whose purpose is to create strings that can be used while debugging and while printing.  We are not converting. We could argue that we&#39;re representing, but I would say we are using these protocols to describe an object. I would suggest naming them<br></p><p>Describable and DebugDescribable<br></p><p>The downside is that this isn’t extensible to other protocols that are creating instances but that isn’t really what’s being done here. These two are specific use cases.<br></p><p><br>=====<br></p><p>The current RawRepresentable does, in my opinion, completely describe what it represents. Calling it Convertible is not, in my opinion, appropriate.<br></p><p>The authors argue that it’s a preferred name because Convertible operates in both directions, but that isn’t the case with RawRepresentable. I can always ask a RawRepresentable instance for its rawValue but I will not always be able to successfully create a RawRepresentable instance from an arbitrary rawValue even if it is of the appropriate type. In fact, I think that their definition of Representable supports keeping RawRepresentable named as it is.<br></p><p>RawRepresentable says to me that an instance can be represented by a rawValue of a specified type. We are not guaranteed that we can create an instance from this type.<br></p><p><br>======<br></p><p>Given the above two comments, there is no longer any confusion with the remaining types that are currently labeled Convertible that are in the proposed Creatable category. I don’t know that Convertible is the right word - Creatable might be better - but there doesn’t seem to be enough of a reason to change the existing name. I wouldn’t be upset with keeping these as Convertible or changing them to Creatable.<br></p><p>======<br></p><p>I’ve been thinking about these a lot. Last fall Greg Heo gave a great presentation about how to group the standard library protocols according to their names. The two that stick out for me are CustomStringConvertible and CustomDebugStringConvertible. One reason they stick out is the prefix “Custom”. The other is that we aren’t converting something - we are describing or representing.<br></p><p>Daniel<br></p><p><br></p><p>&gt; On May 10, 2016, at 2:48 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for Conversions&quot; begins now and runs through May 16. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, May 10, 2016 at 11:48 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for<br>&gt; Conversions&quot; begins now and runs through May 16. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1 with the newly proposed Initializable/Representable names. Initializable<br>just fits perfectly with the fact that Swift has things called initializers<br>and is a vast improvement over Creatable. Representable to denote the other<br>direction makes sense compared to existing Cocoa APIs that use<br>*Representation in their name.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes. Many developers use stdlib as guidance when designing their own APIs<br>and having the standard library be internally consistent sets a good<br>example. These recommendations should also be hoisted into the API naming<br>guidelines documentation so that people can easily cite it, as opposed to<br>just saying &quot;note the pattern that exists&quot; (this is helpful when writing<br>team-specific style guides and for enforcing conventions in code reviews).<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes, it makes the language more consistent.<br></p><p><br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>None that handle conversions in this way using protocols.<br></p><p><br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>I read the proposal, the message with the updated names afterwards, and<br>loosely followed the e-mail threads.<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/288316fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review] SE-0041: Updating Protocol Naming Conventions for Conversions</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 18, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;ve been thinking about the &quot;conversion to some other type from this<br>protocol&quot; case for a while since it often seems to go against the guidance<br>to add a property for this conversion. `Convertible` is always an awkward<br>Protocol to write, in my opinion.<br></p><p>Is there a chance that we simplify the the `Convertible` case by adding<br>this syntax to protocols<br></p><p>``` swift<br></p><p>protocol CustomStringConvertible {<br>    String.init(customStringFrom:)<br>}<br></p><p>```<br></p><p>or something similar? I admit that it *is* unwieldy to declare that String<br>has an initializer in a protocol *but* we almost always end up writing an<br>initializer which accepts our protocol and calls the &#39;constructor property&#39;<br>we&#39;ve required in the protocol. This removes that indirection (also<br>removing the strange two-ways-in-our-API-to-convert-this-to-that) and,<br>maybe, avoids some overloading.<br></p><p>On Mon, May 16, 2016 at 10:33 AM, Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, May 10, 2016 at 11:48 AM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of &quot;SE-0041: Updating Protocol Naming Conventions for<br>&gt;&gt; Conversions&quot; begins now and runs through May 16. The proposal is available<br>&gt;&gt; here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0041-conversion-protocol-conventions.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt;<br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;<br>&gt; +1 with the newly proposed Initializable/Representable names.<br>&gt; Initializable just fits perfectly with the fact that Swift has things<br>&gt; called initializers and is a vast improvement over Creatable. Representable<br>&gt; to denote the other direction makes sense compared to existing Cocoa APIs<br>&gt; that use *Representation in their name.<br>&gt;<br>&gt;<br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;<br>&gt;<br>&gt; Yes. Many developers use stdlib as guidance when designing their own APIs<br>&gt; and having the standard library be internally consistent sets a good<br>&gt; example. These recommendations should also be hoisted into the API naming<br>&gt; guidelines documentation so that people can easily cite it, as opposed to<br>&gt; just saying &quot;note the pattern that exists&quot; (this is helpful when writing<br>&gt; team-specific style guides and for enforcing conventions in code reviews).<br>&gt;<br>&gt;<br>&gt;&gt;         * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;<br>&gt;<br>&gt; Yes, it makes the language more consistent.<br>&gt;<br>&gt;<br>&gt;&gt;         * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;<br>&gt; None that handle conversions in this way using protocols.<br>&gt;<br>&gt;<br>&gt;&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;<br>&gt; I read the proposal, the message with the updated names afterwards, and<br>&gt; loosely followed the e-mail threads.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/d18b5db0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
