<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m moving the discussion from &quot;Proposal proposal: @pure keyword&quot; here and jumping in this time.<br></p><p>On Sat, Jan 9, 2016 at 11:01 PM, Michel Fortin via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt; 1. Pure means that the function always return the same value given the same arguments, and has no side effects (it purely computes a result from its inputs), making it possible for the compiler, or a cache, to reuse the result from a previous call. This is the simplest definition, and it provide strong guaranties. Let&#39;s call that &quot;strongly pure&quot;.<br>&gt; <br>&gt; 2. Pure just mean that the function has no access to global variables. It can only mutate &quot;outside&quot; things through inout parameters or pointers (including class references) passed to it by the caller. So in the general case you can&#39;t reuse the results. But you can use this function to mutate the state inside a strongly pure one. A strongly pure function in this case is one with no inout or pointer in the signature.<br></p><p>There are two independently useful proporties, which I choose to call @pure and @noglobals. (Those names haven&#39;t been bikeshedded). However, I don&#39;t think @pure needs to be as strong as was suggested. A pure function can mutate its copy of any values that it takes and return those to the caller. It cannot access shared state--that is, state the may be reachable via other values. Put simply, it can&#39;t access heap objects unless we can guarantee those objects are uniquely referenced or immutable.<br></p><p>These properties can and should be inferred by the compiler. However, I feel that at least @noglobals should be the default, if not @pure, so that published APIs permit future optimization. If they aren&#39;t accepted as default, then we should aggressively add annotations to stdlib entry points. The compiler can then infer purity in higher level user code.<br></p><p>Note that I&#39;m looking at this mainly from an optimizer-hint perspective, and haven&#39;t seriously considered supporting computed lets.<br></p><p>On 9 Jan 2016, at 8:04 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; Is a method impure if it uses self? I suppose it could be. I guess self is<br>&gt; an inout parameter. I presume an inout parameter is a known expected.<br>&gt; side-effect.<br></p><p>I think normal inout parameters, including self are still @pure (closure captures are not pure). inout arguments do not have pointer-like semantics and are guaranteed not to alias for the purpose of side-effect visibility. The inout arguments simply need to be treated as results. Naturally, a @pure call cannot be eliminated if the inout argument is used after the call. Similarly, two mutating pure method calls on the same struct are not redundant. These facts are obvious to the optimizer, so I don&#39;t see the issue.<br></p><p>The value of the inout argument can mutate locally within a @pure function. If that argument is a struct, then those struct members can mutate.<br></p><p>The argument values, whether inout or not, can be copied without losing purity. Incrementing reference counts should not be considered a side effect from the perspective of function purity. It&#39;s true that we have an isUniquelyReferenced() API, but there is a requirement on the user of this API to ensure identical program behavior regardless of the return value (it is purely an optimization for CoW implementations).<br></p><p>On Sat, Jan 9, 2016 at 11:01 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; All that&#39;s good in theory, but there is a major detail that needs addressing. Memory allocation breaks the guaranties of a &quot;strongly pure&quot; function. For instance, if you return a newly allocated object, or a struct with a pointer to an object, the object is going to be a different one every time. That object is mutable memory, and returning a different chunk of mutable memory is quite different in semantics from returning the same one. If you want strong purity guaranties when returning objects (and thus be able to optimize by reusing the result from a previous call), there needs to be a way to return objects that have a language-enforced guaranty of immutability... same for structs that can have a pointer to an object or other memory. Without immutability guaranties, `@pure` has almost no optimization value.<br></p><p>I think broader support for immutability requires a separate proposal. I will say that we would like to optimize around calls that allocate objects but are otherwise @pure (they can&#39;t be marked @pure because they are not idempotent). We can probably get a lot of mileage out of marking them @noglobals. If we need to do better, we could introduce a @pure_with_alloc sort of attribute later.<br></p><p>On Sat, Jan 9, 2016 at 9:29 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; I&#39;m concerned that with this definition we won&#39;t be able to mark many APIs<br>&gt; as pure, even though they actually are pure.  The issue is that this<br>&gt; definition disallows local mutation.  Consider CollectionType.sort() -- the<br>&gt; way it is implemented is that it first copies the collection into an array,<br>&gt; and then sorts that array in-place.  sortInPlace() isn&#39;t pure, but because<br>&gt; the mutation happens on local state, the whole operation is pure.<br></p><p>Array&lt;T&gt;.sortInPlace() should definitely be considered @pure. Of course, that won&#39;t be inferred from the rules above because it&#39;s implementation uses UnsafeMutableBufferPointer, but we will annotate it as such. Chris L. already mentioned that we need this escape hatch.<br></p><p>There is a more general problem with CoW data types. Simply reading an array element is superficially impure because it accesses array storage. We would work around this using the same &quot;force pure&quot; mechanism because we know the storage is uniquely referenced or immutable.<br></p><p>This leads me to a much bigger issue though. Consuming a generic value is not necessarilly @pure because of deinit(). In fact it isn&#39;t even @noglobals. So this single argument nop function, which doesn&#39;t even have an inout, is impure and may access globals:<br></p><p>  func foo&lt;T&gt;(t: T) {}<br></p><p>To fix this we need to:<br></p><p>- Assert that freeing a non-ObjC Swift object has no side effects other than it&#39;s deinit().<br></p><p>- Introduce a type modifier that prevents any subclasses or protocol conformance from introducing an impure deinit().<br></p><p>Then we could write generic code that guarantees purity:<br></p><p>  func @pure foo&lt;T : PureType&gt;(t: T) {}<br></p><p>We still have a problem because our core library routines need to work on all types and we aren&#39;t going to accept an explosion of purity in the API. It&#39;s particularly problematic if we want @pure or @noglobal to be default.<br></p><p>This seems like it will require polymorphic effects/attributes that can be derived from the generic type parameters. Generally, we want to be able to say that foo&lt;T&gt;(t: T) is pure whenever T is a &quot;pure type&quot; as I explained above. This idea could be extended to support declaring a function purity conditionally depending on the purity (or @noglobals property) of any closure arguments.<br></p><p>So, to conclude, I&#39;m strongly in favor of defining @pure and @noglobals semantics, getting the defaults right, and annotating APIs from the outset. However, I don&#39;t have a compelling design proposal short of introducing a significant language feature. Suggested alternatives or proposals for the necessary language support are welcome.<br></p><p>AndyT<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Very interesting points Andy, I think I agree with pretty much everything<br>you&#39;ve said.<br></p><p>Good point on `func foo&lt;T&gt;(t: T) {}` being impure without a type<br>constraint, deinit seems to have some interesting consequences.<br></p><p>I&#39;ve been throwing around the idea of having this notation:<br></p><p>func myFunc&lt;T,U&gt;(value: T, apply: T -&gt; U) @pure(apply) -&gt; U<br></p><p>to indicate that myFunc is pure if &#39;apply&#39; is also pure. Similar to<br>@rethrows.<br></p><p>If it also requires that A has a pure deinit, or further requirements, then<br>perhaps you could use &quot;@pure(value,apply)&quot;. In your case you would annotate<br>it like this:<br></p><p>func foo&lt;T&gt;(t: T) @pure(t) {}<br></p><p><br>Then the compiler can make foo pure only if T&#39;s `deinit` is marked @pure.<br>The issue there is, as you say, if T can be subclassed then those need<br>@pure deinit. This could be solved if the annotation is always inherited,<br>likewise for overrides.<br></p><p><br>On Thu, Jan 14, 2016 at 3:27 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br></p><p>&gt; I&#39;m moving the discussion from &quot;Proposal proposal: @pure keyword&quot; here and<br>&gt; jumping in this time.<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 11:01 PM, Michel Fortin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; 1. Pure means that the function always return the same value given the<br>&gt; same arguments, and has no side effects (it purely computes a result from<br>&gt; its inputs), making it possible for the compiler, or a cache, to reuse the<br>&gt; result from a previous call. This is the simplest definition, and it<br>&gt; provide strong guaranties. Let&#39;s call that &quot;strongly pure&quot;.<br>&gt; &gt;<br>&gt; &gt; 2. Pure just mean that the function has no access to global variables.<br>&gt; It can only mutate &quot;outside&quot; things through inout parameters or pointers<br>&gt; (including class references) passed to it by the caller. So in the general<br>&gt; case you can&#39;t reuse the results. But you can use this function to mutate<br>&gt; the state inside a strongly pure one. A strongly pure function in this case<br>&gt; is one with no inout or pointer in the signature.<br>&gt;<br>&gt; There are two independently useful proporties, which I choose to call<br>&gt; @pure and @noglobals. (Those names haven&#39;t been bikeshedded). However, I<br>&gt; don&#39;t think @pure needs to be as strong as was suggested. A pure function<br>&gt; can mutate its copy of any values that it takes and return those to the<br>&gt; caller. It cannot access shared state--that is, state the may be reachable<br>&gt; via other values. Put simply, it can&#39;t access heap objects unless we can<br>&gt; guarantee those objects are uniquely referenced or immutable.<br>&gt;<br>&gt; These properties can and should be inferred by the compiler. However, I<br>&gt; feel that at least @noglobals should be the default, if not @pure, so that<br>&gt; published APIs permit future optimization. If they aren&#39;t accepted as<br>&gt; default, then we should aggressively add annotations to stdlib entry<br>&gt; points. The compiler can then infer purity in higher level user code.<br>&gt;<br>&gt; Note that I&#39;m looking at this mainly from an optimizer-hint perspective,<br>&gt; and haven&#39;t seriously considered supporting computed lets.<br>&gt;<br>&gt; On 9 Jan 2016, at 8:04 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; &gt; Is a method impure if it uses self? I suppose it could be. I guess self<br>&gt; is<br>&gt; &gt; an inout parameter. I presume an inout parameter is a known expected.<br>&gt; &gt; side-effect.<br>&gt;<br>&gt; I think normal inout parameters, including self are still @pure (closure<br>&gt; captures are not pure). inout arguments do not have pointer-like semantics<br>&gt; and are guaranteed not to alias for the purpose of side-effect visibility.<br>&gt; The inout arguments simply need to be treated as results. Naturally, a<br>&gt; @pure call cannot be eliminated if the inout argument is used after the<br>&gt; call. Similarly, two mutating pure method calls on the same struct are not<br>&gt; redundant. These facts are obvious to the optimizer, so I don&#39;t see the<br>&gt; issue.<br>&gt;<br>&gt; The value of the inout argument can mutate locally within a @pure<br>&gt; function. If that argument is a struct, then those struct members can<br>&gt; mutate.<br>&gt;<br>&gt; The argument values, whether inout or not, can be copied without losing<br>&gt; purity. Incrementing reference counts should not be considered a side<br>&gt; effect from the perspective of function purity. It&#39;s true that we have an<br>&gt; isUniquelyReferenced() API, but there is a requirement on the user of this<br>&gt; API to ensure identical program behavior regardless of the return value (it<br>&gt; is purely an optimization for CoW implementations).<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 11:01 PM, Michel Fortin via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; All that&#39;s good in theory, but there is a major detail that needs<br>&gt; addressing. Memory allocation breaks the guaranties of a &quot;strongly pure&quot;<br>&gt; function. For instance, if you return a newly allocated object, or a struct<br>&gt; with a pointer to an object, the object is going to be a different one<br>&gt; every time. That object is mutable memory, and returning a different chunk<br>&gt; of mutable memory is quite different in semantics from returning the same<br>&gt; one. If you want strong purity guaranties when returning objects (and thus<br>&gt; be able to optimize by reusing the result from a previous call), there<br>&gt; needs to be a way to return objects that have a language-enforced guaranty<br>&gt; of immutability... same for structs that can have a pointer to an object or<br>&gt; other memory. Without immutability guaranties, `@pure` has almost no<br>&gt; optimization value.<br>&gt;<br>&gt; I think broader support for immutability requires a separate proposal. I<br>&gt; will say that we would like to optimize around calls that allocate objects<br>&gt; but are otherwise @pure (they can&#39;t be marked @pure because they are not<br>&gt; idempotent). We can probably get a lot of mileage out of marking them<br>&gt; @noglobals. If we need to do better, we could introduce a @pure_with_alloc<br>&gt; sort of attribute later.<br>&gt;<br>&gt; On Sat, Jan 9, 2016 at 9:29 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; I&#39;m concerned that with this definition we won&#39;t be able to mark many<br>&gt; APIs<br>&gt; &gt; as pure, even though they actually are pure.  The issue is that this<br>&gt; &gt; definition disallows local mutation.  Consider CollectionType.sort() --<br>&gt; the<br>&gt; &gt; way it is implemented is that it first copies the collection into an<br>&gt; array,<br>&gt; &gt; and then sorts that array in-place.  sortInPlace() isn&#39;t pure, but<br>&gt; because<br>&gt; &gt; the mutation happens on local state, the whole operation is pure.<br>&gt;<br>&gt; Array&lt;T&gt;.sortInPlace() should definitely be considered @pure. Of course,<br>&gt; that won&#39;t be inferred from the rules above because it&#39;s implementation<br>&gt; uses UnsafeMutableBufferPointer, but we will annotate it as such. Chris L.<br>&gt; already mentioned that we need this escape hatch.<br>&gt;<br>&gt; There is a more general problem with CoW data types. Simply reading an<br>&gt; array element is superficially impure because it accesses array storage. We<br>&gt; would work around this using the same &quot;force pure&quot; mechanism because we<br>&gt; know the storage is uniquely referenced or immutable.<br>&gt;<br>&gt; This leads me to a much bigger issue though. Consuming a generic value is<br>&gt; not necessarilly @pure because of deinit(). In fact it isn&#39;t even<br>&gt; @noglobals. So this single argument nop function, which doesn&#39;t even have<br>&gt; an inout, is impure and may access globals:<br>&gt;<br>&gt;   func foo&lt;T&gt;(t: T) {}<br>&gt;<br>&gt; To fix this we need to:<br>&gt;<br>&gt; - Assert that freeing a non-ObjC Swift object has no side effects other<br>&gt; than it&#39;s deinit().<br>&gt;<br>&gt; - Introduce a type modifier that prevents any subclasses or protocol<br>&gt; conformance from introducing an impure deinit().<br>&gt;<br>&gt; Then we could write generic code that guarantees purity:<br>&gt;<br>&gt;   func @pure foo&lt;T : PureType&gt;(t: T) {}<br>&gt;<br>&gt; We still have a problem because our core library routines need to work on<br>&gt; all types and we aren&#39;t going to accept an explosion of purity in the API.<br>&gt; It&#39;s particularly problematic if we want @pure or @noglobal to be default.<br>&gt;<br>&gt; This seems like it will require polymorphic effects/attributes that can be<br>&gt; derived from the generic type parameters. Generally, we want to be able to<br>&gt; say that foo&lt;T&gt;(t: T) is pure whenever T is a &quot;pure type&quot; as I explained<br>&gt; above. This idea could be extended to support declaring a function purity<br>&gt; conditionally depending on the purity (or @noglobals property) of any<br>&gt; closure arguments.<br>&gt;<br>&gt; So, to conclude, I&#39;m strongly in favor of defining @pure and @noglobals<br>&gt; semantics, getting the defaults right, and annotating APIs from the outset.<br>&gt; However, I don&#39;t have a compelling design proposal short of introducing a<br>&gt; significant language feature. Suggested alternatives or proposals for the<br>&gt; necessary language support are welcome.<br>&gt;<br>&gt; AndyT<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/6e2ddc25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>January 14, 2016 at 07:00:00am</p></header><div class="content"><p>Le 14 janv. 2016 à 3:25, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br></p><p>&gt; Very interesting points Andy, I think I agree with pretty much everything you&#39;ve said. <br>&gt; <br>&gt; Good point on `func foo&lt;T&gt;(t: T) {}` being impure without a type constraint, deinit seems to have some interesting consequences.<br>&gt; <br>&gt; I&#39;ve been throwing around the idea of having this notation:<br>&gt; func myFunc&lt;T,U&gt;(value: T, apply: T -&gt; U) @pure(apply) -&gt; U<br>&gt; to indicate that myFunc is pure if &#39;apply&#39; is also pure. Similar to @rethrows.<br>&gt; <br>&gt; If it also requires that A has a pure deinit, or further requirements, then perhaps you could use &quot;@pure(value,apply)&quot;. In your case you would annotate it like this:<br>&gt; func foo&lt;T&gt;(t: T) @pure(t) {}<br>&gt; <br>&gt; Then the compiler can make foo pure only if T&#39;s `deinit` is marked @pure. The issue there is, as you say, if T can be subclassed then those need @pure deinit. This could be solved if the annotation is always inherited, likewise for overrides.<br></p><p>In D, for template functions, the pure attribute is deduced from the function&#39;s body. It&#39;d be nice to have deduced purity so you don&#39;t have to figure out those conditional purity requirements for every function. <br></p><p>Deduced purity should probably not extend automatically to other resilience domains though, because it provides a guaranty that might not apply to future versions of that function. So you still need a way to annotate.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 4:22 AM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; In D, for template functions, the pure attribute is deduced from the function&#39;s body. It&#39;d be nice to have deduced purity so you don&#39;t have to figure out those conditional purity requirements for every function. <br>&gt; <br>&gt; Deduced purity should probably not extend automatically to other resilience domains though, because it provides a guaranty that might not apply to future versions of that function. So you still need a way to annotate.<br></p><p>That’s right. This proposal is really about <br>- introducing API support so we can optimize across resilience<br>- allowing annotation of low level routines, like sortInPlace, that the compiler can’t figure out<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/3be1a1c7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 4:22 AM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 14 janv. 2016 à 3:25, Andrew Bennett &lt;cacoyi at gmail.com&gt; a écrit :<br>&gt; <br>&gt;&gt; Very interesting points Andy, I think I agree with pretty much everything you&#39;ve said. <br>&gt;&gt; <br>&gt;&gt; Good point on `func foo&lt;T&gt;(t: T) {}` being impure without a type constraint, deinit seems to have some interesting consequences.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been throwing around the idea of having this notation:<br>&gt;&gt; func myFunc&lt;T,U&gt;(value: T, apply: T -&gt; U) @pure(apply) -&gt; U<br>&gt;&gt; to indicate that myFunc is pure if &#39;apply&#39; is also pure. Similar to @rethrows.<br>&gt;&gt; <br>&gt;&gt; If it also requires that A has a pure deinit, or further requirements, then perhaps you could use &quot;@pure(value,apply)&quot;. In your case you would annotate it like this:<br>&gt;&gt; func foo&lt;T&gt;(t: T) @pure(t) {}<br>&gt;&gt; <br>&gt;&gt; Then the compiler can make foo pure only if T&#39;s `deinit` is marked @pure. The issue there is, as you say, if T can be subclassed then those need @pure deinit. This could be solved if the annotation is always inherited, likewise for overrides.<br>&gt; <br>&gt; In D, for template functions, the pure attribute is deduced from the function&#39;s body. It&#39;d be nice to have deduced purity so you don&#39;t have to figure out those conditional purity requirements for every function. <br>&gt; <br>&gt; Deduced purity should probably not extend automatically to other resilience domains though, because it provides a guaranty that might not apply to future versions of that function. So you still need a way to annotate.<br></p><p>Deducing purity from function bodies is compile-time expensive and brittle, and impossible across resilience boundaries. It wouldn&#39;t work well with our non-instantiation-based generics model.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Pure functions, as a concept, get +3245 from because, among other reasons, I *think* it’d help with auto-parallelization, which is of course the greatest computational problem of our time (besides a lack of native CPU support for arbitrary precision math). If not, then merely +1… I simply do not believe it wouldn’t eventually be useful for something (manual parallelization comes to mind), and the sooner we get language support for deep concepts like this, the less code will have to be recompiled if it breaks something (and somehow gets accepted anyway).<br></p><p>At the moment, the only other strong opinion I have on the matter is that only going with “auto-detect” is a bad idea, because then there’s no clear way to tell why you can’t pass your “I-thought-it-was-pure-but-it-really-isn’t” function to something that requires a function that actually is pure. I don’t mind the compiler auto-detecting purity (or anything, really) in addition to manual annotations, if it can, but I’ll always want a way to override it.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 14, 2016, at 04:22, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In D, for template functions, the pure attribute is deduced from the function&#39;s body. It&#39;d be nice to have deduced purity so you don&#39;t have to figure out those conditional purity requirements for every function. <br>&gt; <br>&gt; Deduced purity should probably not extend automatically to other resilience domains though, because it provides a guaranty that might not apply to future versions of that function. So you still need a way to annotate.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/0983bd38/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 14, 2016, at 12:25 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Good point on `func foo&lt;T&gt;(t: T) {}` being impure without a type constraint, deinit seems to have some interesting consequences.<br>&gt; <br>&gt; I&#39;ve been throwing around the idea of having this notation:<br>&gt; func myFunc&lt;T,U&gt;(value: T, apply: T -&gt; U) @pure(apply) -&gt; U<br>&gt; to indicate that myFunc is pure if &#39;apply&#39; is also pure. Similar to @rethrows.<br>&gt; <br>&gt; If it also requires that A has a pure deinit, or further requirements, then perhaps you could use &quot;@pure(value,apply)&quot;. In your case you would annotate it like this:<br>&gt; func foo&lt;T&gt;(t: T) @pure(t) {}<br>&gt; <br>&gt; Then the compiler can make foo pure only if T&#39;s `deinit` is marked @pure. The issue there is, as you say, if T can be subclassed then those need @pure deinit. This could be solved if the annotation is always inherited, likewise for overrides.<br></p><p>That works for me as long as we can also annotate types to indicate that subclasses and conformances can’t introduce an impure deinit (or introduce class members with impure deinit).<br></p><p>Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/e9e6f166/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
