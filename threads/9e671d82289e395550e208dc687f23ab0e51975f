<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9e453dc290485e158dcd01698e8c60ae?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Alexey Demedetskiy</string> &lt;demedeckie at gmail.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>I understand what you are talking about. <br>But point is not to limit available behaviors, but to give some hints to compiler and protect programmer from errors.<br></p><p>From my point of view, there is no need to specify order in super class. <br>But this can be helpful in child classes. I mean, that programmer will define the semantic of overriding, and not the semantic of inheritance.<br> <br>&gt; I disagree with the introduction of a method to specify if super must be call first or last. Defining that super must be call is fine, but I don’t see why the operation order should be enforced.<br>&gt; <br>&gt; If the super class declares a method overridable but require that some code must be perform first, it can simply execute that code before calling the overridable method instead of putting it in the super class definition then force the subclass to call super first.<br>&gt; <br>&gt; Moreover, I’m not fond of declaring that requirement in the overriding classes. That is the superclass that should define if a super implementation is required, not the children classes.<br>&gt; <br>&gt; <br>&gt; &gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt; &gt; <br>&gt; &gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt; &gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; -1 for enforcing the super call place.<br>&gt; &gt; &gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt;Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;Hi<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;I would like to suggest you to extend your proposal.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;In my practice, overriding super functions can have several semantics.<br>&gt; &gt; &gt; &gt;1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; &gt; &gt; &gt;2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; &gt; &gt; &gt;3) Before super - opposite to 2.<br>&gt; &gt; &gt; &gt;4) Override - no rules about order, but super call must be done.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;So code can look like:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;override(after) func viewDidLoad() {<br>&gt; &gt; &gt; &gt;// super.viewDidLoad()&lt;— no need to call super at first line.<br>&gt; &gt; &gt; &gt;// child code<br>&gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;override(before) func tearDown() {<br>&gt; &gt; &gt; &gt;// clean code<br>&gt; &gt; &gt; &gt;// super… inserted by compiler<br>&gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;override(instead) func loadView() {<br>&gt; &gt; &gt; &gt;// super.loadView()&lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;override func refillHealthBar() {<br>&gt; &gt; &gt; &gt;// absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;I am not sure about exposing this in a public interface and limit child override options.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;But in general - what is your thoughts about this approach to problem that you mention?<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt;&gt;Hi!<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt; &gt; &gt;&gt;The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;class View {<br>&gt; &gt; &gt; &gt;&gt;func viewDidLoad() {<br>&gt; &gt; &gt; &gt;&gt;// does something<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt; &gt; &gt; &gt;&gt;override func viewDidLoad() {<br>&gt; &gt; &gt; &gt;&gt;super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt; &gt; &gt;&gt;// do something other<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;// Example for extending a function<br>&gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt; &gt; &gt; &gt;&gt;extend func viewDidLoad() {<br>&gt; &gt; &gt; &gt;&gt;super.viewDidLoad()<br>&gt; &gt; &gt; &gt;&gt;// do something<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;extend func viewDidAppear() {<br>&gt; &gt; &gt; &gt;&gt;// do something<br>&gt; &gt; &gt; &gt;&gt;} //&lt;— the compiler should throw an error here.<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;// Example for replacing a function<br>&gt; &gt; &gt; &gt;&gt;class Geometry {<br>&gt; &gt; &gt; &gt;&gt;func volume() -&gt;Double {<br>&gt; &gt; &gt; &gt;&gt;return 0;<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;class Cube: Geometry {<br>&gt; &gt; &gt; &gt;&gt;var length: Double = 0.0<br>&gt; &gt; &gt; &gt;&gt;replace func volume() -&gt;Double {<br>&gt; &gt; &gt; &gt;&gt;let v = length * length * length<br>&gt; &gt; &gt; &gt;&gt;return v<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;Cheers,<br>&gt; &gt; &gt; &gt;&gt;Florian<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt;_______________________________________________<br>&gt; &gt; &gt; &gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>A lot of the time Cocoa documentation says that you must override a method,<br>or must not, and if you do, whether to to it in the beginning, the end, or<br>at some point. This proposal would make it enforceable by the compiler.<br>With the right defaults, this could function exactly as what we have today<br>but give additional ways for the compiler to enforce and automate the<br>implementor&#39;s intent instead of relying on the documentation.<br>On Tue, Feb 16, 2016 at 10:00 AM Alexey Demedetskiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I understand what you are talking about.<br>&gt; But point is not to limit available behaviors, but to give some hints to<br>&gt; compiler and protect programmer from errors.<br>&gt;<br>&gt; From my point of view, there is no need to specify order in super class.<br>&gt; But this can be helpful in child classes. I mean, that programmer will<br>&gt; define the semantic of overriding, and not the semantic of inheritance.<br>&gt;<br>&gt; &gt; I disagree with the introduction of a method to specify if super must be<br>&gt; call first or last. Defining that super must be call is fine, but I don’t<br>&gt; see why the operation order should be enforced.<br>&gt; &gt;<br>&gt; &gt; If the super class declares a method overridable but require that some<br>&gt; code must be perform first, it can simply execute that code before calling<br>&gt; the overridable method instead of putting it in the super class definition<br>&gt; then force the subclass to call super first.<br>&gt; &gt;<br>&gt; &gt; Moreover, I’m not fond of declaring that requirement in the overriding<br>&gt; classes. That is the superclass that should define if a super<br>&gt; implementation is required, not the children classes.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; &gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; For example: should standard library types prefer the &#39;override&#39; form<br>&gt; which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt; &gt; &gt; Perhaps &#39;override(before)&#39; should be an indication that, if the<br>&gt; overriding method doesn&#39;t explicitly declare the super call, then it should<br>&gt; be called implicitly at the start of the function?<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; -1 for enforcing the super call place.<br>&gt; &gt; &gt; &gt; While we usually call super at the beginning of viewDidLoad for<br>&gt; instance, there is absolutely no need to enforce it and it may result in<br>&gt; problem when some work have to be done before the super method is executed.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; I have some use cases that rely on performing setup before calling<br>&gt; the super.viewDidLoad().<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution&lt;<br>&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;Hi<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;I would like to suggest you to extend your proposal.<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;In my practice, overriding super functions can have several<br>&gt; semantics.<br>&gt; &gt; &gt; &gt; &gt;1) Replace - simple case for abstract classes which implementation<br>&gt; do nothing, or throw an exceptions.<br>&gt; &gt; &gt; &gt; &gt;2) After super - things like viewDidLoad and viewWillAppear, setUp<br>&gt; etc. All cases where super expect to be called before child code.<br>&gt; &gt; &gt; &gt; &gt;3) Before super - opposite to 2.<br>&gt; &gt; &gt; &gt; &gt;4) Override - no rules about order, but super call must be done.<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;So code can look like:<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;override(after) func viewDidLoad() {<br>&gt; &gt; &gt; &gt; &gt;// super.viewDidLoad()&lt;— no need to call super at first line.<br>&gt; &gt; &gt; &gt; &gt;// child code<br>&gt; &gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;override(before) func tearDown() {<br>&gt; &gt; &gt; &gt; &gt;// clean code<br>&gt; &gt; &gt; &gt; &gt;// super… inserted by compiler<br>&gt; &gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;override(instead) func loadView() {<br>&gt; &gt; &gt; &gt; &gt;// super.loadView()&lt;— marked as an error with appropriate fix-up to<br>&gt; remove instead modifier<br>&gt; &gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;override func refillHealthBar() {<br>&gt; &gt; &gt; &gt; &gt;// absent call to super will cause an error with fix-up to add<br>&gt; (instead) modifier<br>&gt; &gt; &gt; &gt; &gt;}<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;I am not sure about exposing this in a public interface and limit<br>&gt; child override options.<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;But in general - what is your thoughts about this approach to<br>&gt; problem that you mention?<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;Hi!<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;I would like to suggest to replace the override keyword for<br>&gt; functions by something like extend and replace or to add an annotation like<br>&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt; &gt; &gt; &gt;&gt;The reason for this is, that it might happen, that one forgets to<br>&gt; call the super’s implementation in an overridden function or if one reads<br>&gt; the code it might not be obvious why the super’s implementation is not<br>&gt; called:<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;class View {<br>&gt; &gt; &gt; &gt; &gt;&gt;func viewDidLoad() {<br>&gt; &gt; &gt; &gt; &gt;&gt;// does something<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt; &gt; &gt; &gt; &gt;&gt;override func viewDidLoad() {<br>&gt; &gt; &gt; &gt; &gt;&gt;super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt; &gt; &gt; &gt;&gt;// do something other<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;The compiler will accept if one overrides a superclass’s function<br>&gt; but does not call the superclass’s implementation which is often ok. The<br>&gt; developer should clearly state that he doesn’t want to call the<br>&gt; superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;// Example for extending a function<br>&gt; &gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt; &gt; &gt; &gt; &gt;&gt;extend func viewDidLoad() {<br>&gt; &gt; &gt; &gt; &gt;&gt;super.viewDidLoad()<br>&gt; &gt; &gt; &gt; &gt;&gt;// do something<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;extend func viewDidAppear() {<br>&gt; &gt; &gt; &gt; &gt;&gt;// do something<br>&gt; &gt; &gt; &gt; &gt;&gt;} //&lt;— the compiler should throw an error here.<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;// Example for replacing a function<br>&gt; &gt; &gt; &gt; &gt;&gt;class Geometry {<br>&gt; &gt; &gt; &gt; &gt;&gt;func volume() -&gt;Double {<br>&gt; &gt; &gt; &gt; &gt;&gt;return 0;<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;class Cube: Geometry {<br>&gt; &gt; &gt; &gt; &gt;&gt;var length: Double = 0.0<br>&gt; &gt; &gt; &gt; &gt;&gt;replace func volume() -&gt;Double {<br>&gt; &gt; &gt; &gt; &gt;&gt;let v = length * length * length<br>&gt; &gt; &gt; &gt; &gt;&gt;return v<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;Cheers,<br>&gt; &gt; &gt; &gt; &gt;&gt;Florian<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt; &gt; &gt; &gt; &gt;_______________________________________________<br>&gt; &gt; &gt; &gt; &gt;swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/1fe5f184/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes, that is the kind of things that do get a big +1 from me ;).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 16 Feb 2016, at 16:20, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of the time Cocoa documentation says that you must override a method, or must not, and if you do, whether to to it in the beginning, the end, or at some point. This proposal would make it enforceable by the compiler. With the right defaults, this could function exactly as what we have today but give additional ways for the compiler to enforce and automate the implementor&#39;s intent instead of relying on the documentation.<br>&gt; On Tue, Feb 16, 2016 at 10:00 AM Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I understand what you are talking about.<br>&gt;&gt; But point is not to limit available behaviors, but to give some hints to compiler and protect programmer from errors.<br>&gt;&gt; <br>&gt;&gt; From my point of view, there is no need to specify order in super class.<br>&gt;&gt; But this can be helpful in child classes. I mean, that programmer will define the semantic of overriding, and not the semantic of inheritance.<br>&gt;&gt; <br>&gt;&gt; &gt; I disagree with the introduction of a method to specify if super must be call first or last. Defining that super must be call is fine, but I don’t see why the operation order should be enforced.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If the super class declares a method overridable but require that some code must be perform first, it can simply execute that code before calling the overridable method instead of putting it in the super class definition then force the subclass to call super first.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Moreover, I’m not fond of declaring that requirement in the overriding classes. That is the superclass that should define if a super implementation is required, not the children classes.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt;&gt; &gt; &gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt;&gt; &gt; &gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; -1 for enforcing the super call place.<br>&gt;&gt; &gt; &gt; &gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;a écrit :<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;Hi<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;I would like to suggest you to extend your proposal.<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;In my practice, overriding super functions can have several semantics.<br>&gt;&gt; &gt; &gt; &gt; &gt;1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt;&gt; &gt; &gt; &gt; &gt;2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt;&gt; &gt; &gt; &gt; &gt;3) Before super - opposite to 2.<br>&gt;&gt; &gt; &gt; &gt; &gt;4) Override - no rules about order, but super call must be done.<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;So code can look like:<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;override(after) func viewDidLoad() {<br>&gt;&gt; &gt; &gt; &gt; &gt;// super.viewDidLoad()&lt;— no need to call super at first line.<br>&gt;&gt; &gt; &gt; &gt; &gt;// child code<br>&gt;&gt; &gt; &gt; &gt; &gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;override(before) func tearDown() {<br>&gt;&gt; &gt; &gt; &gt; &gt;// clean code<br>&gt;&gt; &gt; &gt; &gt; &gt;// super… inserted by compiler<br>&gt;&gt; &gt; &gt; &gt; &gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;override(instead) func loadView() {<br>&gt;&gt; &gt; &gt; &gt; &gt;// super.loadView()&lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt;&gt; &gt; &gt; &gt; &gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;override func refillHealthBar() {<br>&gt;&gt; &gt; &gt; &gt; &gt;// absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt;&gt; &gt; &gt; &gt; &gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;I am not sure about exposing this in a public interface and limit child override options.<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;But in general - what is your thoughts about this approach to problem that you mention?<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;Hi!<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;class View {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;func viewDidLoad() {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// does something<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;override func viewDidLoad() {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;super.viewDidLoad() //&lt;— this might be forgotten<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// do something other<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// Example for extending a function<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;class Button: View {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;extend func viewDidLoad() {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;super.viewDidLoad()<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// do something<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;extend func viewDidAppear() {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// do something<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;} //&lt;— the compiler should throw an error here.<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;// Example for replacing a function<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;class Geometry {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;func volume() -&gt;Double {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;return 0;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;class Cube: Geometry {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;var length: Double = 0.0<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;replace func volume() -&gt;Double {<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;let v = length * length * length<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;return v<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;}<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;Cheers,<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;Florian<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;&gt;<br>&gt;&gt; &gt; &gt; &gt; &gt;_______________________________________________<br>&gt;&gt; &gt; &gt; &gt; &gt;swift-evolution mailing list<br>&gt;&gt; &gt; &gt; &gt; &gt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt; &gt; &gt; &gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &gt;<br>&gt;&gt; &gt; &gt; _______________________________________________<br>&gt;&gt; &gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/494e05cc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>February 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 16 Feb 2016, at 17:20, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of the time Cocoa documentation says that you must override a method, or must not, and if you do, whether to to it in the beginning, the end, or at some point.<br></p><p>I’m sorry, I don’t believe this. How can the implementor of the superclass possibly know whether the arbitrary code that the implementor of a subclass can write should go before, after or around the call to the super implementation? It’s nonsense.<br></p><p>Furthermore, I don’t believe that the implementor of the super class can foresee all the possible cases of subclass implementation so it would be foolish to try to even enforce a call to super at any point.<br></p><p>Then there are the implementation problems. The attribute would restrict the subclass implementor to calling the super implementation in the implementation of the subclass function. They couldn’t call out to a private method to call the super implementation. They couldn’t put it inside a loop or control structure unless the compiler can definitely prove that the code path is executed.<br></p><p>How do you deal with multi-level hierarchies? Do you enforce adding the attribute to the method in the intermediate class? <br></p><p>I think the whole idea of the compiler enforcing calls to super for non initialisers is misconceived. There will be enough edge cases and implementation issues to have subclass implementors cursing it. We should just accept the fact that we can’t legislate every bug out of existence and live things as they are.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 17, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 17 Feb 2016, at 08:06, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m sorry, I don’t believe this. How can the implementor of the superclass possibly know whether the arbitrary code that the implementor of a subclass can write should go before, after or around the call to the super implementation? It’s nonsense.<br></p><p>The before and after clauses probably wouldn’t be the most commonly used except in cases where the developer is very sure that they are needed. I think they’d be used more by abstract classes than regular ones, where a partial implementation needs to be completed in a particular way, required and optional would be the most commonly used I think.<br></p><p>&gt; They couldn’t call out to a private method to call the super implementation.<br></p><p>What do you hope to gain by doing so? If the parent method requires that it is called then it has to called in all paths the sub-class implementation can take. You can still outsource work to a private method, you can even still make a decision based on what the private method’s results are, so long as you call the super method in every case.<br></p><p>&gt; They couldn’t put it inside a loop or control structure unless the compiler can definitely prove that the code path is executed.<br></p><p>Why would you want to potentially call the super-method zero or many times when your child method is only called once? I’d also say that this is exactly what required should prevent, as there should be no uncertainty over it being called, since the parent method specifically forbids it.<br></p><p>It shouldn’t prevent the use of a conditional, so long as all paths call the super method, i.e:<br></p><p>	if someCondition {<br>		…<br>		super.doSomething()<br>	} else {<br>		super.doSomething()<br>		…<br>	}<br></p><p>Would be fine (both branches call the super method) but a conditional where super is only called in some branches, and nowhere else, is exactly what required is for. You actually raise an interesting question of whether it should be possible to call the super method more than once, that might be a possibility for another requirement, as in most cases it won’t make sense to call it more than once; for example, if you’re extending an add() method then potentially calling super.add() more than once seems like it could lead to unexpected results, and could be an error. For example:<br></p><p>	if someCondition {<br>		…<br>		super.doSomething()<br>	}<br></p><p>	…<br>	super.doSomething()<br></p><p>Could be a bug where the developer has forgotten to remove the conditional super call; if the parent class knows its method shouldn’t be called more than once per child call then it could prevent this.<br></p><p>&gt; How do you deal with multi-level hierarchies? Do you enforce adding the attribute to the method in the intermediate class? <br></p><p>It’s up to the developer of the sub-class. As proposed all methods would be final by default, including those overriding a method in a super class, so they would need their own requirements set in order for them to be overridable in the first place.<br></p><p>For example:<br></p><p>	class MyClass {<br>		@super(require)<br>		func someMethod() { … }<br></p><p>		@super(require)<br>		func someOtherMethod() { … }<br>	}<br></p><p>	class MySubClass : MyClass {<br>		@super(require)<br>		override func someMethod() { … } // Can be extended further<br></p><p>		override func someOtherMethod() { … } // Cannot be extended further<br>	}<br></p><p>&gt; There will be enough edge cases and implementation issues to have subclass implementors cursing it.<br></p><p>Only if the developer of the parent class is over zealous in their choice of restrictions, but you could say the same thing about a bunch of features, like developers who mark almost everything private; like I say, the before and after requirements shouldn’t be very common, while the rest are pretty straightforward. In most cases you’ll either be extending a class that was designed for that purpose, in which case the requirements should be set correctly, or you will be extending a class in your own code base, so can request a change to the requirements (or change them yourself).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/d1e7c8d8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
