<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 22, 2016, at 1:23 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri May 20 2016, Matthew Johnson<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 20, 2016, at 7:40 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The Any-class requirement could replace the current `AnyObject`<br>&gt;&gt;&gt;&gt;&gt; protocol with a typealias like this: `typealias AnyObject =<br>&gt;&gt;&gt;&gt;&gt; Any&lt;class&gt;`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement<br>&gt;&gt;&gt;&gt;&gt; one day. How would one name a typealias for these, where `AnyClass`<br>&gt;&gt;&gt;&gt;&gt; means `AnyObject.Type`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to<br>&gt;&gt;&gt;&gt;&gt; `AnyClass`. If one would need the old `AnyClass` behavior it will<br>&gt;&gt;&gt;&gt;&gt; become `AnyClass.Type`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No<br>&gt;&gt;&gt;&gt; typealias, just directly using `Any&lt;&gt;`. We would also deprecate<br>&gt;&gt;&gt;&gt; `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do<br>&gt;&gt;&gt;&gt; this by providing `AnyObject` and `AnyClass` typealiases in Swift 3,<br>&gt;&gt;&gt;&gt; but marking them as deprecated.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more<br>&gt;&gt;&gt;&gt; quickly gets them to see how it&#39;s connected to a protocol<br>&gt;&gt;&gt;&gt; declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;`<br>&gt;&gt;&gt;&gt; has other capabilities from that list, like the ability to handle<br>&gt;&gt;&gt;&gt; multiple protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt;&gt;&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt;&gt;&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even in the long term, I don&#39;t see any good reason to support<br>&gt;&gt;&gt;&gt; `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction*<br>&gt;&gt;&gt;&gt; between a struct and an enum; you can always implement something<br>&gt;&gt;&gt;&gt; enum-y using a struct with a mode field, or something struct-y using<br>&gt;&gt;&gt;&gt; an enum with associated values. `Bool`, for instance, was once an<br>&gt;&gt;&gt;&gt; enum and was changed to a struct for implementation reasons; this<br>&gt;&gt;&gt;&gt; change made no difference to how it was used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, there *is* a semantic distinction between struct/enum and<br>&gt;&gt;&gt;&gt; class—one is a value type, the other is a reference type. To support<br>&gt;&gt;&gt;&gt; that distinction, it might make sense to support an `Any&lt;value&gt;` or<br>&gt;&gt;&gt;&gt; `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;`<br>&gt;&gt;&gt;&gt; syntax, though, not a typealias.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can implement reference types with value semantics and value types<br>&gt;&gt;&gt; with reference semantics.  Until the compiler can verify value<br>&gt;&gt;&gt; semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The<br>&gt;&gt;&gt; semantic distinction is what is important.  There has been discussion<br>&gt;&gt;&gt; about strengthening the “value type == value semantics” and “reference<br>&gt;&gt;&gt; type == reference semantics” relations but that hasn’t yet moved<br>&gt;&gt;&gt; beyond talk.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type<br>&gt;&gt;&gt;&gt; conformances and I&#39;m not convinced. It is always possible to<br>&gt;&gt;&gt;&gt; nominally &quot;conform&quot; to a protocol in a way that actually undermines<br>&gt;&gt;&gt;&gt; its guarantees; for example, you could implement<br>&gt;&gt;&gt;&gt; `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler<br>&gt;&gt;&gt;&gt; cannot reject all invalid conformances; it can only reject ones<br>&gt;&gt;&gt;&gt; which it can trivially show are invalid, because for instance they<br>&gt;&gt;&gt;&gt; do not even attempt to provide a required method. Similarly, the<br>&gt;&gt;&gt;&gt; compiler may not be able to prove you are providing value semantics,<br>&gt;&gt;&gt;&gt; but it *can* reject conformances of reference types to a protocol<br>&gt;&gt;&gt;&gt; requiring value semantics, since those cannot possibly be valid<br>&gt;&gt;&gt;&gt; conformances.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Immutable reference types actually *can* provide valid value semantics<br>&gt;&gt;&gt; (at least as long as as they can provide their own implementation of<br>&gt;&gt;&gt; `==` which I believe Dave A is arguing against).<br>&gt;&gt; <br>&gt;&gt; I am not making a strong argument against that, though it might be<br>&gt;&gt; reasonable.  I am mostly arguing in favor of a default definition of ==<br>&gt;&gt; for all reference types that is equivalent to ===.<br>&gt;<br>&gt; Sorry I misunderstood.  To make sure I understand clearly: you’re not<br>&gt; arguing against reference types with value semantics, just that we<br>&gt; should allow reference semantics to be assumed unless custom equality<br>&gt; is implemented.  Is that correct?<br></p><p>I don&#39;t view an immutable class with custom equality as problematic in<br>principle, but if dropping that capability would allow us to simplify<br>the programming model, I would do so in a heartbeat.  I haven&#39;t had the<br>chance to consider all the implications yet, but—at least until someone<br>can demonstrate that we really custom == for classes—we should be open<br>to the idea as we consider the value semantics story.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; I haven&#39;t had the<br>&gt; chance to consider all the implications yet, but—at least until someone<br>&gt; can demonstrate that we really custom == for classes—we should be open<br>&gt; to the idea as we consider the value semantics story.<br></p><p>I&#39;ve been lurking and skimming the discussion around this so far, but I&#39;ll speak up at this point. I really do think making `==` always be an identity check for class types is not a realistic option.<br></p><p>What you&#39;re proposing is essentially what Objective-C does. When Swift was introduced, the ability to use operators like `==` to mean *logical* equality instead of *referential* equality was touted as a major advantage. And it *is* a major advantage for readability—`text1 == text2` (where text1 and text2 are, say, NSMutableString or NSAttributedString) is much nicer than `text1.isEqual(text2)`. We would be giving up a significant feature of the language for a vision of purity that most programmers don&#39;t (think they) care about.<br></p><p>Now, one thing you *could* do is allow overloading of `==` and instead take `===` for this purpose. `===` is already an identity check on reference types and unavailable on value types; for value types, it could be defined as always equivalent to `==`. This would leave `==` open to user definition on class types, while exposing your value equality operation as `===`.<br></p><p>Either way, though, if `Hashable` is always identity-based on class types, that will cause bridging issues. NSDictionary and Dictionary (or NSSet and Set) will no longer agree on which objects are distinct and which are not. Converting from the Swift type to the Foundation type and back again may lose elements. If we broaden `===` to all instances, `Hashable` will probably still need to be tied to `==`, not `===`.<br></p><p>It&#39;s unfortunate that those darned users are always getting in the way of our elegant designs. :^)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:51 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 1:23 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri May 20 2016, Matthew Johnson<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 20, 2016, at 7:40 PM, Brent Royal-Gordon via<br>&gt;&gt;&gt;&gt;&gt; swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The Any-class requirement could replace the current `AnyObject`<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol with a typealias like this: `typealias AnyObject =<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;class&gt;`<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement<br>&gt;&gt;&gt;&gt;&gt;&gt; one day. How would one name a typealias for these, where `AnyClass`<br>&gt;&gt;&gt;&gt;&gt;&gt; means `AnyObject.Type`?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to<br>&gt;&gt;&gt;&gt;&gt;&gt; `AnyClass`. If one would need the old `AnyClass` behavior it will<br>&gt;&gt;&gt;&gt;&gt;&gt; become `AnyClass.Type`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No<br>&gt;&gt;&gt;&gt;&gt; typealias, just directly using `Any&lt;&gt;`. We would also deprecate<br>&gt;&gt;&gt;&gt;&gt; `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do<br>&gt;&gt;&gt;&gt;&gt; this by providing `AnyObject` and `AnyClass` typealiases in Swift 3,<br>&gt;&gt;&gt;&gt;&gt; but marking them as deprecated.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more<br>&gt;&gt;&gt;&gt;&gt; quickly gets them to see how it&#39;s connected to a protocol<br>&gt;&gt;&gt;&gt;&gt; declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;`<br>&gt;&gt;&gt;&gt;&gt; has other capabilities from that list, like the ability to handle<br>&gt;&gt;&gt;&gt;&gt; multiple protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt;&gt;&gt;&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt;&gt;&gt;&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even in the long term, I don&#39;t see any good reason to support<br>&gt;&gt;&gt;&gt;&gt; `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction*<br>&gt;&gt;&gt;&gt;&gt; between a struct and an enum; you can always implement something<br>&gt;&gt;&gt;&gt;&gt; enum-y using a struct with a mode field, or something struct-y using<br>&gt;&gt;&gt;&gt;&gt; an enum with associated values. `Bool`, for instance, was once an<br>&gt;&gt;&gt;&gt;&gt; enum and was changed to a struct for implementation reasons; this<br>&gt;&gt;&gt;&gt;&gt; change made no difference to how it was used.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now, there *is* a semantic distinction between struct/enum and<br>&gt;&gt;&gt;&gt;&gt; class—one is a value type, the other is a reference type. To support<br>&gt;&gt;&gt;&gt;&gt; that distinction, it might make sense to support an `Any&lt;value&gt;` or<br>&gt;&gt;&gt;&gt;&gt; `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;`<br>&gt;&gt;&gt;&gt;&gt; syntax, though, not a typealias.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can implement reference types with value semantics and value types<br>&gt;&gt;&gt;&gt; with reference semantics.  Until the compiler can verify value<br>&gt;&gt;&gt;&gt; semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The<br>&gt;&gt;&gt;&gt; semantic distinction is what is important.  There has been discussion<br>&gt;&gt;&gt;&gt; about strengthening the “value type == value semantics” and “reference<br>&gt;&gt;&gt;&gt; type == reference semantics” relations but that hasn’t yet moved<br>&gt;&gt;&gt;&gt; beyond talk.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type<br>&gt;&gt;&gt;&gt;&gt; conformances and I&#39;m not convinced. It is always possible to<br>&gt;&gt;&gt;&gt;&gt; nominally &quot;conform&quot; to a protocol in a way that actually undermines<br>&gt;&gt;&gt;&gt;&gt; its guarantees; for example, you could implement<br>&gt;&gt;&gt;&gt;&gt; `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler<br>&gt;&gt;&gt;&gt;&gt; cannot reject all invalid conformances; it can only reject ones<br>&gt;&gt;&gt;&gt;&gt; which it can trivially show are invalid, because for instance they<br>&gt;&gt;&gt;&gt;&gt; do not even attempt to provide a required method. Similarly, the<br>&gt;&gt;&gt;&gt;&gt; compiler may not be able to prove you are providing value semantics,<br>&gt;&gt;&gt;&gt;&gt; but it *can* reject conformances of reference types to a protocol<br>&gt;&gt;&gt;&gt;&gt; requiring value semantics, since those cannot possibly be valid<br>&gt;&gt;&gt;&gt;&gt; conformances.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Immutable reference types actually *can* provide valid value semantics<br>&gt;&gt;&gt;&gt; (at least as long as as they can provide their own implementation of<br>&gt;&gt;&gt;&gt; `==` which I believe Dave A is arguing against).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not making a strong argument against that, though it might be<br>&gt;&gt;&gt; reasonable.  I am mostly arguing in favor of a default definition of ==<br>&gt;&gt;&gt; for all reference types that is equivalent to ===.<br>&gt;&gt; <br>&gt;&gt; Sorry I misunderstood.  To make sure I understand clearly: you’re not<br>&gt;&gt; arguing against reference types with value semantics, just that we<br>&gt;&gt; should allow reference semantics to be assumed unless custom equality<br>&gt;&gt; is implemented.  Is that correct?<br>&gt; <br>&gt; I don&#39;t view an immutable class with custom equality as problematic in<br>&gt; principle, but if dropping that capability would allow us to simplify<br>&gt; the programming model, I would do so in a heartbeat.  I haven&#39;t had the<br>&gt; chance to consider all the implications yet, but—at least until someone<br>&gt; can demonstrate that we really custom == for classes—we should be open<br>&gt; to the idea as we consider the value semantics story.<br></p><p>I agree that we should be open to this idea.  <br></p><p>As we discussed previously, I would like to see some additional features around value types that would reduce or eliminate the reasons people might want to write immutable / value semantic classes introduced before we make a change like this.  But if it turns out to be the right long term decision and we can’t wait that long we should go ahead with it anyway.<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/85768d52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  9, 2016 at 12:00:00pm</p></header><div class="content"><p>I added a draft proposal here: https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md<br></p><p>Rename AnyObject and remove current AnyClass<br></p><p>Proposal: SE-NNNN<br>Author(s): Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>From the beginning AnyObject protocol and AnyClass type-alias felt wrong and confusing. This proposal aims to sort out the confusion and provide a consistency for future version of Swift.<br></p><p>Swift-evolution thread: [Pitch] Rename AnyObject to AnyClass and drop current AnyClass<br></p><p>Motivation<br></p><p>In Swift 3 the standard library will correspond to a particular guideline. This means that the Type suffix will be removed almost everywhere. This provides good readability and makes usage of .Type more clearer and consistent. Furthermore this change is a first step towards consistency for generalized existentials.<br></p><p>Short example:<br></p><p>-func construct(type: AnyClass) -&gt; AnyObject?<br>+func construct(type: AnyClass.Type) -&gt; AnyClass? {<br>    if let objectType = type as? NSObject.Type {<br>        return objectType.init()<br>    } else {<br>        return nil<br>    }<br>}<br>Proposed solution<br></p><p>Remove current AnyClass type-alias from the standard library and rename current AnyObject protocol to AnyClass. Then migrate existing code from AnyClass to AnyClass.Type and from AnyObject to AnyClass.<br></p><p>// Remove completely<br>-public typealias AnyClass = AnyObject.Type<br></p><p>// Rename to AnyClass<br>- at objc public protocol AnyObject {}<br>+ at objc public protocol AnyClass {}<br>Impact on existing code<br></p><p>This change will break existing code, and will require a migrator to translate Swift 2 code into Swift 3 code.<br></p><p>Alternatives considered &amp; Future consistency<br></p><p>Use generalized existentials with any-class requirement Any&lt;class&gt; instead, which won’t make it into Swift 3 in time:<br>AnyClass equals Any&lt;class&gt; or typealias AnyClass = Any&lt;class&gt;<br>AnyClass.Type equals Any&lt;class&gt;.Type<br>Add AnyValue type-alias with generalized existentials and value keyword:<br>AnyValue equals Any&lt;value&gt; or typealias AnyValue = Any&lt;value&gt;<br>AnyValue.Type equals Any&lt;value&gt;.Type<br>Or instead AnyValue add AnyStruct and AnyEnum type-aliases:<br>AnyStruct equals Any&lt;struct&gt; or typealias AnyStruct = Any&lt;struct&gt;<br>AnyEnum equals Any&lt;enum&gt; or typealias AnyEnum = Any&lt;enum&gt;<br>AnyStruct.Type equals Any&lt;struct&gt;.Type<br>AnyEnum.Type equals Any&lt;enum&gt;.Type<br>Example:<br></p><p>// Accept any type that conforms to `SomeProtocol`<br>func doSomething(with interface: SomeProtocol) { ... }<br></p><p>// Accept any class that conforms to `SomeProtocol`<br>// We use shorthand syntax for existentials here (SE-0095)<br>func doSomething(with interfaceReference: AnyClass &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceReference: Any&lt;class&gt; &amp; SomeProtocol) { ... }<br></p><p>// Accept any value that conforms to `SomeProtocol`<br>// Missing counterpart to `AnyClass`<br>func doSomething(with interfaceValue: AnyValue &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;value&gt; &amp; SomeProtocol) { ... }<br></p><p>// Or more specific value types:<br>func doSomething(with interfaceValue: AnyStruct &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;struct&gt; &amp; SomeProtocol) { ... }<br></p><p>func doSomething(with interfaceValue: AnyEnum &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;enum&gt; &amp; SomeProtocol) { ... }<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/d7cc0e49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>I find this more confusing, not less. AnyClass suggests that will be any class, but it’s not, it’s any class instance. So I think it’s less accurate.<br></p><p>For arguments that AnyStruct and AnyEnum will come, I don’t agree with those either. AnyValue would make more sense to me. The fact that a value’s type is a struct or enum is irrelevant, just as AnyObject makes no promise about the superclass. I don’t believe there would be much or anything you could do knowing if something was a struct or enum anyway — both support properties and methods, mutations, yet cases can only be used with a concrete enum type. So AFAIK, there would no um value in having both AnyStruct and AnyEnum.<br></p><p>So I am happy staying with AnyObject, as it describes what the actual instance is. And if AnyValue comes, they would pair nicely together.<br></p><p>Patrick<br></p><p><br>&gt; On 9 Jun 2016, at 8:08 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I added a draft proposal here: https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md&gt;<br>&gt; Rename AnyObject and remove current AnyClass<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/nnnn-rename-anyobject-remove-anyclass.md&gt;<br>&gt; Author(s): Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt; Status: Awaiting review &lt;x-msg://100/#rationale&gt;<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; From the beginning AnyObject protocol and AnyClass type-alias felt wrong and confusing. This proposal aims to sort out the confusion and provide a consistency for future version of Swift.<br>&gt; <br>&gt; Swift-evolution thread: [Pitch] Rename AnyObject to AnyClass and drop current AnyClass &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018283.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; In Swift 3 the standard library will correspond to a particular guideline &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;. This means that the Type suffix will be removed almost everywhere. This provides good readability and makes usage of .Type more clearer and consistent. Furthermore this change is a first step towards consistency for generalized existentials &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;.<br>&gt; <br>&gt; Short example:<br>&gt; <br>&gt; -func construct(type: AnyClass) -&gt; AnyObject?<br>&gt; +func construct(type: AnyClass.Type) -&gt; AnyClass? {<br>&gt;     if let objectType = type as? NSObject.Type {<br>&gt;         return objectType.init()<br>&gt;     } else {<br>&gt;         return nil<br>&gt;     }<br>&gt; }<br>&gt; Proposed solution<br>&gt; <br>&gt; Remove current AnyClass type-alias from the standard library and rename current AnyObject protocol to AnyClass. Then migrate existing code from AnyClass to AnyClass.Type and from AnyObject to AnyClass.<br>&gt; <br>&gt; // Remove completely<br>&gt; -public typealias AnyClass = AnyObject.Type<br>&gt; <br>&gt; // Rename to AnyClass<br>&gt; - at objc public protocol AnyObject {}<br>&gt; + at objc public protocol AnyClass {}<br>&gt; Impact on existing code<br>&gt; <br>&gt; This change will break existing code, and will require a migrator to translate Swift 2 code into Swift 3 code.<br>&gt; <br>&gt; Alternatives considered &amp; Future consistency<br>&gt; <br>&gt; Use generalized existentials with any-class requirement Any&lt;class&gt; instead, which won’t make it into Swift 3 in time:<br>&gt; AnyClass equals Any&lt;class&gt; or typealias AnyClass = Any&lt;class&gt;<br>&gt; AnyClass.Type equals Any&lt;class&gt;.Type<br>&gt; Add AnyValue type-alias with generalized existentials and value keyword:<br>&gt; AnyValue equals Any&lt;value&gt; or typealias AnyValue = Any&lt;value&gt;<br>&gt; AnyValue.Type equals Any&lt;value&gt;.Type<br>&gt; Or instead AnyValue add AnyStruct and AnyEnum type-aliases:<br>&gt; AnyStruct equals Any&lt;struct&gt; or typealias AnyStruct = Any&lt;struct&gt;<br>&gt; AnyEnum equals Any&lt;enum&gt; or typealias AnyEnum = Any&lt;enum&gt;<br>&gt; AnyStruct.Type equals Any&lt;struct&gt;.Type<br>&gt; AnyEnum.Type equals Any&lt;enum&gt;.Type<br>&gt; Example:<br>&gt; <br>&gt; // Accept any type that conforms to `SomeProtocol`<br>&gt; func doSomething(with interface: SomeProtocol) { ... }<br>&gt; <br>&gt; // Accept any class that conforms to `SomeProtocol`<br>&gt; // We use shorthand syntax for existentials here (SE-0095)<br>&gt; func doSomething(with interfaceReference: AnyClass &amp; SomeProtocol) { ... }<br>&gt; func doSomething(with interfaceReference: Any&lt;class&gt; &amp; SomeProtocol) { ... }<br>&gt; <br>&gt; // Accept any value that conforms to `SomeProtocol`<br>&gt; // Missing counterpart to `AnyClass`<br>&gt; func doSomething(with interfaceValue: AnyValue &amp; SomeProtocol) { ... }<br>&gt; func doSomething(with interfaceValue: Any&lt;value&gt; &amp; SomeProtocol) { ... }<br>&gt; <br>&gt; // Or more specific value types:<br>&gt; func doSomething(with interfaceValue: AnyStruct &amp; SomeProtocol) { ... }<br>&gt; func doSomething(with interfaceValue: Any&lt;struct&gt; &amp; SomeProtocol) { ... }<br>&gt; <br>&gt; func doSomething(with interfaceValue: AnyEnum &amp; SomeProtocol) { ... }<br>&gt; func doSomething(with interfaceValue: Any&lt;enum&gt; &amp; SomeProtocol) { ... }<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/33b84c70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>So what is the counterpart to AnyClass aka. AnyObject.Type for AnyValue? There is no and I don’t see any good name for it.<br></p><p>More confusion with generalized existentials:<br></p><p>Any&lt;class&gt; vs. AnyClass aka AnyObject.Type<br>Any&lt;class&gt; makes it crystal clear that you’re using an instance of a class not an instance of .Type. It should be consistent.<br></p><p>I’m not proposing for AnyStruct or AnyEnum here, it would be enough to get AnyValue in Swift, but I did considered both in my proposal.<br></p><p>Lets say we also would have something like One&lt;A, B&gt; which picks A or B and we have generalized struct and enum. That said we could create AnyValue like this typealias AnyValue = One&lt;struct, enum&gt;. Again this is not the main part of the proposal.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 9. Juni 2016 um 13:09:28, Patrick Smith (pgwsmith at gmail.com) schrieb:<br></p><p>I find this more confusing, not less. AnyClass suggests that will be any class, but it’s not, it’s any class instance. So I think it’s less accurate.<br></p><p>For arguments that AnyStruct and AnyEnum will come, I don’t agree with those either. AnyValue would make more sense to me. The fact that a value’s type is a struct or enum is irrelevant, just as AnyObject makes no promise about the superclass. I don’t believe there would be much or anything you could do knowing if something was a struct or enum anyway — both support properties and methods, mutations, yet cases can only be used with a concrete enum type. So AFAIK, there would no um value in having both AnyStruct and AnyEnum.<br></p><p>So I am happy staying with AnyObject, as it describes what the actual instance is. And if AnyValue comes, they would pair nicely together.<br></p><p>Patrick<br></p><p><br>On 9 Jun 2016, at 8:08 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>I added a draft proposal here: https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md<br></p><p>Rename AnyObject and remove current AnyClass<br></p><p>Proposal: SE-NNNN<br>Author(s): Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>From the beginning AnyObject protocol and AnyClass type-alias felt wrong and confusing. This proposal aims to sort out the confusion and provide a consistency for future version of Swift.<br></p><p>Swift-evolution thread: [Pitch] Rename AnyObject to AnyClass and drop current AnyClass<br></p><p>Motivation<br></p><p>In Swift 3 the standard library will correspond to a particular guideline. This means that the Type suffix will be removed almost everywhere. This provides good readability and makes usage of .Type more clearer and consistent. Furthermore this change is a first step towards consistency for generalized existentials.<br></p><p>Short example:<br></p><p>-func construct(type: AnyClass) -&gt; AnyObject?<br>+func construct(type: AnyClass.Type) -&gt; AnyClass? {<br>    if let objectType = type as? NSObject.Type {<br>        return objectType.init()<br>    } else {<br>        return nil<br>    }<br>}<br>Proposed solution<br></p><p>Remove current AnyClass type-alias from the standard library and rename current AnyObject protocol to AnyClass. Then migrate existing code from AnyClass to AnyClass.Type and from AnyObject to AnyClass.<br></p><p>// Remove completely<br>-public typealias AnyClass = AnyObject.Type<br></p><p>// Rename to AnyClass<br>- at objc public protocol AnyObject {}<br>+ at objc public protocol AnyClass {}<br>Impact on existing code<br></p><p>This change will break existing code, and will require a migrator to translate Swift 2 code into Swift 3 code.<br></p><p>Alternatives considered &amp; Future consistency<br></p><p>Use generalized existentials with any-class requirement Any&lt;class&gt; instead, which won’t make it into Swift 3 in time:<br>AnyClass equals Any&lt;class&gt; or typealias AnyClass = Any&lt;class&gt;<br>AnyClass.Type equals Any&lt;class&gt;.Type<br>Add AnyValue type-alias with generalized existentials and value keyword:  <br>AnyValue equals Any&lt;value&gt; or typealias AnyValue = Any&lt;value&gt;<br>AnyValue.Type equals Any&lt;value&gt;.Type<br>Or instead AnyValue add AnyStruct and AnyEnum type-aliases:<br>AnyStruct equals Any&lt;struct&gt; or typealias AnyStruct = Any&lt;struct&gt;<br>AnyEnum equals Any&lt;enum&gt; or typealias AnyEnum = Any&lt;enum&gt;<br>AnyStruct.Type equals Any&lt;struct&gt;.Type<br>AnyEnum.Type equals Any&lt;enum&gt;.Type<br>Example:<br></p><p>// Accept any type that conforms to `SomeProtocol`<br>func doSomething(with interface: SomeProtocol) { ... }<br></p><p>// Accept any class that conforms to `SomeProtocol`<br>// We use shorthand syntax for existentials here (SE-0095)<br>func doSomething(with interfaceReference: AnyClass &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceReference: Any&lt;class&gt; &amp; SomeProtocol) { ... }<br></p><p>// Accept any value that conforms to `SomeProtocol`<br>// Missing counterpart to `AnyClass`<br>func doSomething(with interfaceValue: AnyValue &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;value&gt; &amp; SomeProtocol) { ... }<br></p><p>// Or more specific value types:<br>func doSomething(with interfaceValue: AnyStruct &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;struct&gt; &amp; SomeProtocol) { ... }<br></p><p>func doSomething(with interfaceValue: AnyEnum &amp; SomeProtocol) { ... }<br>func doSomething(with interfaceValue: Any&lt;enum&gt; &amp; SomeProtocol) { ... }<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/62df60a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 9 Jun 2016, at 9:23 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So what is the counterpart to AnyClass aka. AnyObject.Type for AnyValue? There is no and I don’t see any good name for it.<br>&gt; <br>You could just use AnyValue.Type?<br>&gt; More confusion with generalized existentials:<br>&gt; <br>&gt; Any&lt;class&gt; vs. AnyClass aka AnyObject.Type<br>&gt; Any&lt;class&gt; makes it crystal clear that you’re using an instance of a class not an instance of .Type. It should be consistent.<br>&gt; <br>Any&lt;…&gt; would be used for any of a certain type. So Any&lt;class&gt; to me says ‘any of class’, not ‘any class’. Whereas AnyClass says to me literally ‘any class’.<br>&gt; I’m not proposing for AnyStruct or AnyEnum here, it would be enough to get AnyValue in Swift, but I did considered both in my proposal. <br>&gt; <br>&gt; Lets say we also would have something like One&lt;A, B&gt; which picks A or B and we have generalized struct and enum. That said we could create AnyValue like this typealias AnyValue = One&lt;struct, enum&gt;. Again this is not the main part of the proposal.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 9. Juni 2016 um 13:09:28, Patrick Smith (pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I find this more confusing, not less. AnyClass suggests that will be any class, but it’s not, it’s any class instance. So I think it’s less accurate.<br>&gt;&gt; <br>&gt;&gt; For arguments that AnyStruct and AnyEnum will come, I don’t agree with those either. AnyValue would make more sense to me. The fact that a value’s type is a struct or enum is irrelevant, just as AnyObject makes no promise about the superclass. I don’t believe there would be much or anything you could do knowing if something was a struct or enum anyway — both support properties and methods, mutations, yet cases can only be used with a concrete enum type. So AFAIK, there would no um value in having both AnyStruct and AnyEnum.<br>&gt;&gt; <br>&gt;&gt; So I am happy staying with AnyObject, as it describes what the actual instance is. And if AnyValue comes, they would pair nicely together.<br>&gt;&gt; <br>&gt;&gt; Patrick<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 9 Jun 2016, at 8:08 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I added a draft proposal here: https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/rename_anyobject_remove_anyclass/proposals/nnnn-rename-anyobject-remove-anyclass.md&gt;<br>&gt;&gt;&gt; Rename AnyObject and remove current AnyClass<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/nnnn-rename-anyobject-remove-anyclass.md&gt;<br>&gt;&gt;&gt; Author(s): Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;<br>&gt;&gt;&gt; Status: Awaiting review &lt;x-msg://100/#rationale&gt;<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the beginning AnyObject protocol and AnyClass type-alias felt wrong and confusing. This proposal aims to sort out the confusion and provide a consistency for future version of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [Pitch] Rename AnyObject to AnyClass and drop current AnyClass &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018283.html&gt;<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift 3 the standard library will correspond to a particular guideline &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md&gt;. This means that the Type suffix will be removed almost everywhere. This provides good readability and makes usage of .Type more clearer and consistent. Furthermore this change is a first step towards consistency for generalized existentials &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Short example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -func construct(type: AnyClass) -&gt; AnyObject?<br>&gt;&gt;&gt; +func construct(type: AnyClass.Type) -&gt; AnyClass? {<br>&gt;&gt;&gt;     if let objectType = type as? NSObject.Type {<br>&gt;&gt;&gt;         return objectType.init()<br>&gt;&gt;&gt;     } else {<br>&gt;&gt;&gt;         return nil<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Remove current AnyClass type-alias from the standard library and rename current AnyObject protocol to AnyClass. Then migrate existing code from AnyClass to AnyClass.Type and from AnyObject to AnyClass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Remove completely<br>&gt;&gt;&gt; -public typealias AnyClass = AnyObject.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Rename to AnyClass<br>&gt;&gt;&gt; - at objc public protocol AnyObject {}<br>&gt;&gt;&gt; + at objc public protocol AnyClass {}<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change will break existing code, and will require a migrator to translate Swift 2 code into Swift 3 code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered &amp; Future consistency<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Use generalized existentials with any-class requirement Any&lt;class&gt; instead, which won’t make it into Swift 3 in time:<br>&gt;&gt;&gt; AnyClass equals Any&lt;class&gt; or typealias AnyClass = Any&lt;class&gt;<br>&gt;&gt;&gt; AnyClass.Type equals Any&lt;class&gt;.Type<br>&gt;&gt;&gt; Add AnyValue type-alias with generalized existentials and value keyword:<br>&gt;&gt;&gt; AnyValue equals Any&lt;value&gt; or typealias AnyValue = Any&lt;value&gt;<br>&gt;&gt;&gt; AnyValue.Type equals Any&lt;value&gt;.Type<br>&gt;&gt;&gt; Or instead AnyValue add AnyStruct and AnyEnum type-aliases:<br>&gt;&gt;&gt; AnyStruct equals Any&lt;struct&gt; or typealias AnyStruct = Any&lt;struct&gt;<br>&gt;&gt;&gt; AnyEnum equals Any&lt;enum&gt; or typealias AnyEnum = Any&lt;enum&gt;<br>&gt;&gt;&gt; AnyStruct.Type equals Any&lt;struct&gt;.Type<br>&gt;&gt;&gt; AnyEnum.Type equals Any&lt;enum&gt;.Type<br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Accept any type that conforms to `SomeProtocol`<br>&gt;&gt;&gt; func doSomething(with interface: SomeProtocol) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Accept any class that conforms to `SomeProtocol`<br>&gt;&gt;&gt; // We use shorthand syntax for existentials here (SE-0095)<br>&gt;&gt;&gt; func doSomething(with interfaceReference: AnyClass &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; func doSomething(with interfaceReference: Any&lt;class&gt; &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Accept any value that conforms to `SomeProtocol`<br>&gt;&gt;&gt; // Missing counterpart to `AnyClass`<br>&gt;&gt;&gt; func doSomething(with interfaceValue: AnyValue &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; func doSomething(with interfaceValue: Any&lt;value&gt; &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Or more specific value types:<br>&gt;&gt;&gt; func doSomething(with interfaceValue: AnyStruct &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; func doSomething(with interfaceValue: Any&lt;struct&gt; &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(with interfaceValue: AnyEnum &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; func doSomething(with interfaceValue: Any&lt;enum&gt; &amp; SomeProtocol) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/00a81359/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>On 9 Jun 2016, at 9:23 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>So what is the counterpart to AnyClass aka. AnyObject.Type for AnyValue? There is no and I don’t see any good name for it.<br></p><p>You could just use AnyValue.Type?<br>So basically you’re for consistency for `AnyValue` but not for current `AnyObject`.<br></p><p>It’s clear that `AnyValue` can represent more than one value type, where `AnyObject` can only represent one reference type (class). IMO for consistency it should be named as `AnyClass`.<br></p><p>More confusion with generalized existentials:<br></p><p>Any&lt;class&gt; vs. AnyClass aka AnyObject.Type<br>Any&lt;class&gt; makes it crystal clear that you’re using an instance of a class not an instance of .Type. It should be consistent.<br></p><p>Any&lt;…&gt; would be used for any of a certain type. So Any&lt;class&gt; to me says ‘any of class’, not ‘any class’. Whereas AnyClass says to me literally ‘any class’.<br>`Any&lt;class&gt;` and `AnyClass` should be the same otherwise it will lead to confusion!<br></p><p>If someone is new to the language and reads `AnyObject.Type` its not clear that a `.Type` instance of a class is meant, because its not clear what `Object` might be. <br></p><p>If then you also have existentials with any-class requirements and `AnyClass` typealias which is `AnyObject.Type` it would definitely lead to confusion between:<br></p><p>func foo(value: AnyClass &amp; SomeProtocol) // this would be illegal with current implementation<br></p><p>vs.<br></p><p>func foo(value: Any&lt;class&gt; &amp; SomeProtocol)<br></p><p>If one would want to use a `.Type` instance then should always type out `.Type` suffix after your type name: `AnyClass.Type` == any `.Type` instance of any class<br></p><p>I&#39;m strongly against keeping `AnyClass` as an alias for `AnyObject.Type`, I’d consider to keep only `AnyObject` but if `Any&lt;&gt;` existentials were to come we’d get this mismatch:<br></p><p>typealias AnyObject = Any&lt;class&gt;<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/3600d2cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June  9, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 9 Jun 2016, at 9:55 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 9 Jun 2016, at 9:23 PM &lt;http://airmail.calendar/2016-06-09%2021:23:00%20MESZ&gt;, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So what is the counterpart to AnyClass aka. AnyObject.Type for AnyValue? There is no and I don’t see any good name for it.<br>&gt;&gt; <br>&gt;&gt; You could just use AnyValue.Type?<br>&gt; <br>&gt; So basically you’re for consistency for `AnyValue` but not for current `AnyObject`.<br>&gt; <br>&gt; It’s clear that `AnyValue` can represent more than one value type, where `AnyObject` can only represent one reference type (class). IMO for consistency it should be named as `AnyClass`.<br>&gt; <br>There could be one day more than one reference type, and AnyObject could also work with that.<br></p><p>&gt;&gt; More confusion with generalized existentials:<br>&gt;&gt; <br>&gt;&gt; Any&lt;class&gt; vs. AnyClass aka AnyObject.Type<br>&gt;&gt; Any&lt;class&gt; makes it crystal clear that you’re using an instance of a class not an instance of .Type. It should be consistent.<br>&gt;&gt; <br>&gt;&gt; Any&lt;…&gt; would be used for any of a certain type. So Any&lt;class&gt; to me says ‘any of class’, not ‘any class’. Whereas AnyClass says to me literally ‘any class’.<br>&gt; <br>&gt; `Any&lt;class&gt;` and `AnyClass` should be the same otherwise it will lead to confusion!<br>&gt; <br>If Any&lt;class&gt; was introduced, then I’d advocate for it being an outright replacement and just removing AnyObject.<br>&gt; If someone is new to the language and reads `AnyObject.Type` its not clear that a `.Type` instance of a class is meant, because its not clear what `Object` might be. <br>&gt; <br>&gt; If then you also have existentials with any-class requirements and `AnyClass` typealias which is `AnyObject.Type` it would definitely lead to confusion between:<br>&gt; <br>&gt; func foo(value: AnyClass &amp; SomeProtocol) // this would be illegal with current implementation<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt; func foo(value: Any&lt;class&gt; &amp; SomeProtocol)<br>&gt; <br>&gt; If one would want to use a `.Type` instance then should always type out `.Type` suffix after your type name: `AnyClass.Type` == any `.Type` instance of any class<br>&gt; <br>&gt; I&#39;m strongly against keeping `AnyClass` as an alias for `AnyObject.Type`, I’d consider to keep only `AnyObject` but if `Any&lt;&gt;` existentials were to come we’d get this mismatch:<br>&gt; <br>&gt; typealias AnyObject = Any&lt;class&gt;<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/18814c7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June  9, 2016 at 02:00:00pm</p></header><div class="content"><p>There could be one day more than one reference type, and AnyObject could also work with that.<br>Classes are not the only reference types. Closures are reference types which we CANNOT extend with protocols.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/d38e6097/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
