<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Thoughts on property behavior out-of-band members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 12:00:00am</p></header><div class="content"><p>This was originally going to be part of my recent email on the SE-0030 review thread, but it got very long and convoluted, so I decided to split it off.<br></p><p>***<br></p><p>If we&#39;re going to use an `@runcible` syntax for properties, we should think about what will happen to behavior members.<br></p><p>The basic syntax itself is simple enough; `foo at runcible` and `foo. at runcible` are both reasonable options. (I slightly favor the dotless version because it doesn&#39;t make it look like you could capture `foo` in a variable and access `@runcible` from it, but that&#39;s a minor issue.)<br></p><p>More interesting is controlling the behavior members&#39; visibility. The square bracket syntax had the advantage that you could put access control keywords alongside the declarations, like `[public resettable]`; with the `@` syntax that&#39;s now lost. We could echo `private(set)`, but the naive version of that is ridiculously wordy:<br></p><p>	public public(@resettable) @resettable var counter = 0<br></p><p>Maybe we could drop the second `@resettable`—it&#39;s implied by the one in the access control list:<br></p><p>	public public(@resettable) var counter = 0<br></p><p>And maybe we could drop the first `public`—it&#39;s implied, since the behavior can&#39;t be more visible than the property it&#39;s on—to get:<br></p><p>	public(@resettable) var counter = 0<br></p><p>However, there are downsides to both of those. If we decide to support accessor vars with the `@json(key=)` syntax I described in the SE-0030 review thread, you start seeing things like `public(@json(key=&quot;fooBarBaz&quot;))`, which kind of mixes unrelated things together.<br></p><p>And as for omitting the first `public`, well, I&#39;m not entirely sure about the &quot;can&#39;t be more visible&quot; thing either. Sometimes you actually *don&#39;t* want to expose a property, but you *do* want to expose a behavior method. For instance:<br></p><p>	public class NetworkDatabase {<br>		private public(@resettable) var recordCache: NSCache<br>		// You can&#39;t access the cache, but you can throw it out.<br>	}<br></p><p>If that&#39;s the case, I&#39;m not sure it&#39;s a good idea to have `public(@resettable)` imply the property is public, too.<br></p><p>***<br></p><p>Actually, I&#39;m beginning to think that the `foo. at runcible` thing isn&#39;t a good idea at all.<br></p><p>One thing I&#39;ve been thinking about lately is the ways we normally do behavior method-like things in Cocoa. For example, if you have a resettable property, you&#39;ll probably have something like this:<br></p><p>	@property (assign) NSUInteger foo;<br>	- (void)resetFoo;<br></p><p>It&#39;s pretty obvious, though, that we&#39;re not going to be able to Swiftify that—the clang importer isn&#39;t going to translate that into `@resettable var foo: Int`, or any other special syntax like that. It&#39;s just not going to be a realistic thing to detect and adjust during bridging.<br></p><p>And even if it could, that only exposes another problem: behaviors tie you *very* tightly to a particular implementation. If your property is `@resettable` and you decide you need to reset in a different way, you have no way to make that change without breaking all of your call sites. In particular, that means a public behavior in a resilient library can never be removed or even substituted for another behavior with a compatible interface.<br></p><p>So I&#39;m thinking that we should try to sidestep the problem entirely and instead expose behavior members alongside the property they belong to, Cocoa-style.<br></p><p>Within the behavior, all of the members behave exactly as you would expect. But members with a visibility specifier are exposed on the instance using the behavior with the same visibility (capped by the property&#39;s access control), only with an uppercased version of the property&#39;s name appended to the member&#39;s name. Members with no visibility modifier, on the other hand, are not exposed outside the behavior.<br></p><p>For example, let&#39;s define, apply, and use `@resettable`:<br></p><p>	public var behavior resettable&lt;Value&gt;: Value {<br>		var value: Value = initialValue				// no access control, so invisible<br>		<br>		get { return value }<br>		set { value = newValue }<br>		<br>		public mutating func reset() {				// visible at up to `public` scope<br>			value = initialValue<br>		}<br>	}<br>	<br>	struct Foo {<br>		@resettable var bar: Int<br>		// has a resetBar() method, which is internal because `bar` is internal.<br>	}<br>	<br>	var myFoo = Foo()<br>	myFoo.resetBar()<br></p><p>With this in place, all behaviors are pure implementation details; you can remove them and manually implement the members they provided and nobody would be the wiser. You probably wouldn&#39;t even see behaviors in the generated headers.<br></p><p>(By the way, while I&#39;m here, I&#39;ll note that it might be a good idea to bridge Objective-C null_resettable as Swift @resettable in both directions. That would mean the setter would have to accept `nil` in Objective-C only; I&#39;m not sure if it&#39;s worth inventing a general mechanism for that.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Thoughts on property behavior out-of-band members</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; If we&#39;re going to use an `@runcible` syntax for properties, we should think about what will happen to behavior members.<br>&gt; <br>&gt; The basic syntax itself is simple enough; `foo at runcible` and `foo. at runcible` are both reasonable options. (I slightly favor the dotless version because it doesn&#39;t make it look like you could capture `foo` in a variable and access `@runcible` from it, but that&#39;s a minor issue.)<br></p><p>A quick thought I had while reading this is what if the access syntax looked like this:<br></p><p>@resetable(foo).reset()<br>@runcible(spoon).finish = Material.silver<br></p><p>I think that would read pretty well - as if you’re accessing something that “wraps” the target var (which, basically, you are).<br></p><p>l8r<br>Sean<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>Thoughts on property behavior out-of-band members</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>February 19, 2016 at 09:00:00am</p></header><div class="content"><p>This is an interesting direction, Brent. I really like the resilience benefits.<br></p><p>If we went this way, I wonder how we would deal with name spacing when we add behavior composition. That is, if two behaviors define members with the same name, how would we disambiguate between the members at the usage site? Concretely:<br></p><p>var behavior plistBacked&lt;Value&gt;: Value {<br>  func reset() { … }<br>  …<br>}<br></p><p>var behavior resettable&lt;Value&gt;: Value {<br>  func reset() { … }<br>  …<br>}<br></p><p>class Foo {<br>  @plistBacked @resettable var problemChild: String<br>}<br></p><p>let foo = Foo()<br>foo.ResetProblemChild // Which reset() is invoked?<br></p><p>Disambiguating at point of use would require exposing the behaviors in the interface, negating the benefits. It seems like the disambiguation could be done at the declaration site somehow, at which point I realize that we essentially have the diamond inheritance problem. Under this generated-methods approach, adopting multiple behaviors on a single property is essentially multiple inheritance.<br></p><p>Am I missing something?<br></p><p>Cheers,<br></p><p>Curt<br></p><p><br>&gt; On Feb 19, 2016, at 12:45 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was originally going to be part of my recent email on the SE-0030 review thread, but it got very long and convoluted, so I decided to split it off.<br>&gt; <br>&gt; ***<br>&gt; <br>&gt; If we&#39;re going to use an `@runcible` syntax for properties, we should think about what will happen to behavior members.<br>&gt; <br>&gt; The basic syntax itself is simple enough; `foo at runcible` and `foo. at runcible` are both reasonable options. (I slightly favor the dotless version because it doesn&#39;t make it look like you could capture `foo` in a variable and access `@runcible` from it, but that&#39;s a minor issue.)<br>&gt; <br>&gt; More interesting is controlling the behavior members&#39; visibility. The square bracket syntax had the advantage that you could put access control keywords alongside the declarations, like `[public resettable]`; with the `@` syntax that&#39;s now lost. We could echo `private(set)`, but the naive version of that is ridiculously wordy:<br>&gt; <br>&gt;    public public(@resettable) @resettable var counter = 0<br>&gt; <br>&gt; Maybe we could drop the second `@resettable`—it&#39;s implied by the one in the access control list:<br>&gt; <br>&gt;    public public(@resettable) var counter = 0<br>&gt; <br>&gt; And maybe we could drop the first `public`—it&#39;s implied, since the behavior can&#39;t be more visible than the property it&#39;s on—to get:<br>&gt; <br>&gt;    public(@resettable) var counter = 0<br>&gt; <br>&gt; However, there are downsides to both of those. If we decide to support accessor vars with the `@json(key=)` syntax I described in the SE-0030 review thread, you start seeing things like `public(@json(key=&quot;fooBarBaz&quot;))`, which kind of mixes unrelated things together.<br>&gt; <br>&gt; And as for omitting the first `public`, well, I&#39;m not entirely sure about the &quot;can&#39;t be more visible&quot; thing either. Sometimes you actually *don&#39;t* want to expose a property, but you *do* want to expose a behavior method. For instance:<br>&gt; <br>&gt;    public class NetworkDatabase {<br>&gt;        private public(@resettable) var recordCache: NSCache<br>&gt;        // You can&#39;t access the cache, but you can throw it out.<br>&gt;    }<br>&gt; <br>&gt; If that&#39;s the case, I&#39;m not sure it&#39;s a good idea to have `public(@resettable)` imply the property is public, too.<br>&gt; <br>&gt; ***<br>&gt; <br>&gt; Actually, I&#39;m beginning to think that the `foo. at runcible` thing isn&#39;t a good idea at all.<br>&gt; <br>&gt; One thing I&#39;ve been thinking about lately is the ways we normally do behavior method-like things in Cocoa. For example, if you have a resettable property, you&#39;ll probably have something like this:<br>&gt; <br>&gt;    @property (assign) NSUInteger foo;<br>&gt;    - (void)resetFoo;<br>&gt; <br>&gt; It&#39;s pretty obvious, though, that we&#39;re not going to be able to Swiftify that—the clang importer isn&#39;t going to translate that into `@resettable var foo: Int`, or any other special syntax like that. It&#39;s just not going to be a realistic thing to detect and adjust during bridging.<br>&gt; <br>&gt; And even if it could, that only exposes another problem: behaviors tie you *very* tightly to a particular implementation. If your property is `@resettable` and you decide you need to reset in a different way, you have no way to make that change without breaking all of your call sites. In particular, that means a public behavior in a resilient library can never be removed or even substituted for another behavior with a compatible interface.<br>&gt; <br>&gt; So I&#39;m thinking that we should try to sidestep the problem entirely and instead expose behavior members alongside the property they belong to, Cocoa-style.<br>&gt; <br>&gt; Within the behavior, all of the members behave exactly as you would expect. But members with a visibility specifier are exposed on the instance using the behavior with the same visibility (capped by the property&#39;s access control), only with an uppercased version of the property&#39;s name appended to the member&#39;s name. Members with no visibility modifier, on the other hand, are not exposed outside the behavior.<br>&gt; <br>&gt; For example, let&#39;s define, apply, and use `@resettable`:<br>&gt; <br>&gt;    public var behavior resettable&lt;Value&gt;: Value {<br>&gt;        var value: Value = initialValue                // no access control, so invisible<br>&gt;        <br>&gt;        get { return value }<br>&gt;        set { value = newValue }<br>&gt;        <br>&gt;        public mutating func reset() {                // visible at up to `public` scope<br>&gt;            value = initialValue<br>&gt;        }<br>&gt;    }<br>&gt;    <br>&gt;    struct Foo {<br>&gt;        @resettable var bar: Int<br>&gt;        // has a resetBar() method, which is internal because `bar` is internal.<br>&gt;    }<br>&gt;    <br>&gt;    var myFoo = Foo()<br>&gt;    myFoo.resetBar()<br>&gt; <br>&gt; With this in place, all behaviors are pure implementation details; you can remove them and manually implement the members they provided and nobody would be the wiser. You probably wouldn&#39;t even see behaviors in the generated headers.<br>&gt; <br>&gt; (By the way, while I&#39;m here, I&#39;ll note that it might be a good idea to bridge Objective-C null_resettable as Swift @resettable in both directions. That would mean the setter would have to accept `nil` in Objective-C only; I&#39;m not sure if it&#39;s worth inventing a general mechanism for that.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Thoughts on property behavior out-of-band members</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 19, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; If we went this way, I wonder how we would deal with name spacing when we add behavior composition. That is, if two behaviors define members with the same name, how would we disambiguate between the members at the usage site? <br></p><p>It&#39;s a fair question. One possibility is make the `foo. at runcible` format available, but only in private scope with no way to widen it. The type applying the property would then be able to define a `resetFoo()` method which called whichever version it wanted to expose.<br></p><p>(In theory, you could do this for *all* members exposed on a behavior, and require the applying type to define cover members for whatever it wanted to expose. I don&#39;t like that idea, though; I think that would add a burdensome amount of boilerplate.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
