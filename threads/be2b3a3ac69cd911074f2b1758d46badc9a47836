<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi there!<br></p><p>From time to time, I find myself using safe subscripting, e.g.:<br></p><p>let array = [1, 2, 3]<br></p><p>array[safe: 0] // 1<br>array[safe: 1] // 2<br>array[safe: 2] // 3<br>array[safe: 3] // nil<br></p><p>… with the following implementation:<br></p><p>subscript (safe index: Int) -&gt; Element? {<br>    return self.indices ~= index ? self[index] : nil<br>}<br></p><p>I was wondering … wouldn’t it be handy to have this in the standard library?<br></p><p>Best regards,<br>Rudolf Adamkovic<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/be2b7836/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 16, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve also thought of this. But the concept of safe indexing can also be extended to CollectionType (or to the more abstract Indexable protocol) where it&#39;s index is Comparable.<br></p><p>For mutable Collections/MutableIndexable there could be two versions of a safe subscript set:<br></p><p>array[safe: 5] = 7 // does nothing if index out of bounds<br></p><p>array[clamp: 5] = 7<br>// if array is empty: does nothing<br>// if 5 &gt;= array.endIndex : sets last element<br>// if index &lt; 0 : sets first index<br></p><p>So definitely worth considering.<br></p><p><br>- Maximilian<br></p><p>&gt; Am 16.01.2016 um 21:44 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; From time to time, I find myself using safe subscripting, e.g.:<br>&gt; <br>&gt; let array = [1, 2, 3]<br>&gt; <br>&gt; array[safe: 0] // 1<br>&gt; array[safe: 1] // 2<br>&gt; array[safe: 2] // 3<br>&gt; array[safe: 3] // nil<br>&gt; <br>&gt; … with the following implementation:<br>&gt; <br>&gt; subscript (safe index: Int) -&gt; Element? {<br>&gt;     return self.indices ~= index ? self[index] : nil<br>&gt; }<br>&gt; <br>&gt; I was wondering … wouldn’t it be handy to have this in the standard library?<br>&gt; <br>&gt; Best regards,<br>&gt; Rudolf Adamkovic<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/a5e2b204/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 16, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m definitely +1 on the getter. I have reservations on the setter. As described, this code:<br>subscript(safe index: Index) -&gt; Element? {<br>    return self.indices ~= index ? self[index] : nil<br>}<br>subscript(clamp index: Index) -&gt; Element? {<br>    get { return self.indices ~= index ? self[index] : nil } // again, because subscripts can’t be setter-only<br>    set {<br>        if self.indices ~= index {<br>            self[index] = newValue!<br>        } else {<br>            self.append(newValue!)<br>        }<br>    }<br>}<br></p><p>Would lead to some counter-intuitive results.<br>var foo = [0, 1, 2]<br>print(foo[safe: 2]) // Optional(2)… Yep<br>foo[clamp: 6] = 6<br>print(foo[safe: 6]) // nil… Wait, what? I just set that to 6! Why is it nil now?<br></p><p><br>Instead of just appending the new value, we could extend the array to the required capacity:<br>subscript(safe index: Index) -&gt; Element? {<br>    get { return self.indices ~= index ? self[index] : nil }<br>    set {<br>        if self.indices ~= index {<br>            self[index] = newValue!<br>        } else {<br>            while !(self.indices ~= index) {<br>                self.append(newValue!)<br>            }<br>        }<br>    }<br>}<br></p><p>The results could still be unexpected:<br>var foo = [0, 1, 2]<br>print(foo) 		// [0, 1, 2]… Yep<br>foo[safe: 9] = 9<br>print(foo[safe: 9]) 	// Optional(9)… Yep<br>print(foo) 		// [0, 1, 2, 9, 9, 9, 9, 9, 9]… Wow, that’s bigger than I thought<br></p><p>but at least you’d be able to read from the index to which you just wrote.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 16, 2016, at 14:08, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve also thought of this. But the concept of safe indexing can also be extended to CollectionType (or to the more abstract Indexable protocol) where it&#39;s index is Comparable.<br>&gt; <br>&gt; For mutable Collections/MutableIndexable there could be two versions of a safe subscript set:<br>&gt; <br>&gt; array[safe: 5] = 7 // does nothing if index out of bounds<br>&gt; <br>&gt; array[clamp: 5] = 7<br>&gt; // if array is empty: does nothing<br>&gt; // if 5 &gt;= array.endIndex : sets last element<br>&gt; // if index &lt; 0 : sets first index<br>&gt; <br>&gt; So definitely worth considering.<br>&gt; <br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 16.01.2016 um 21:44 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Hi there!<br>&gt;&gt; <br>&gt;&gt; From time to time, I find myself using safe subscripting, e.g.:<br>&gt;&gt; <br>&gt;&gt; let array = [1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; array[safe: 0] // 1<br>&gt;&gt; array[safe: 1] // 2<br>&gt;&gt; array[safe: 2] // 3<br>&gt;&gt; array[safe: 3] // nil<br>&gt;&gt; <br>&gt;&gt; … with the following implementation:<br>&gt;&gt; <br>&gt;&gt; subscript (safe index: Int) -&gt; Element? {<br>&gt;&gt;     return self.indices ~= index ? self[index] : nil<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I was wondering … wouldn’t it be handy to have this in the standard library?<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Rudolf Adamkovic<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/3e45a1be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 17, 2016 at 02:00:00am</p></header><div class="content"><p>It is true that the setter could cause some confusion in the first place but I think of these particular setters as optional chaining:<br></p><p>person.residence?.address = &quot;1 Infinite Loop&quot;<br></p><p>Where the `address` is not set when `residence` is nil. So it&#39;s like the array is nil/not defined if you access it out of bounds.<br></p><p><br>In addition subscripts imply O(1) access/set so the expanding array setter should be implemented as method.<br></p><p>- Maximilian<br></p><p>&gt; Am 17.01.2016 um 02:29 schrieb davesweeris at mac.com:<br>&gt; <br>&gt; I’m definitely +1 on the getter. I have reservations on the setter. As described, this code:<br>&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;     return self.indices ~= index ? self[index] : nil<br>&gt; }<br>&gt; subscript(clamp index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil } // again, because subscripts can’t be setter-only<br>&gt;     set {<br>&gt;         if self.indices ~= index {<br>&gt;             self[index] = newValue!<br>&gt;         } else {<br>&gt;             self.append(newValue!)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Would lead to some counter-intuitive results.<br>&gt; var foo = [0, 1, 2]<br>&gt; print(foo[safe: 2]) // Optional(2)… Yep<br>&gt; foo[clamp: 6] = 6<br>&gt; print(foo[safe: 6]) // nil… Wait, what? I just set that to 6! Why is it nil now?<br>&gt; <br>&gt; <br>&gt; Instead of just appending the new value, we could extend the array to the required capacity:<br>&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;     set {<br>&gt;         if self.indices ~= index {<br>&gt;             self[index] = newValue!<br>&gt;         } else {<br>&gt;             while !(self.indices ~= index) {<br>&gt;                 self.append(newValue!)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The results could still be unexpected:<br>&gt; var foo = [0, 1, 2]<br>&gt; print(foo) 		// [0, 1, 2]… Yep<br>&gt; foo[safe: 9] = 9<br>&gt; print(foo[safe: 9]) 	// Optional(9)… Yep<br>&gt; print(foo) 		// [0, 1, 2, 9, 9, 9, 9, 9, 9]… Wow, that’s bigger than I thought<br>&gt; <br>&gt; but at least you’d be able to read from the index to which you just wrote.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 16, 2016, at 14:08, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve also thought of this. But the concept of safe indexing can also be extended to CollectionType (or to the more abstract Indexable protocol) where it&#39;s index is Comparable.<br>&gt;&gt; <br>&gt;&gt; For mutable Collections/MutableIndexable there could be two versions of a safe subscript set:<br>&gt;&gt; <br>&gt;&gt; array[safe: 5] = 7 // does nothing if index out of bounds<br>&gt;&gt; <br>&gt;&gt; array[clamp: 5] = 7<br>&gt;&gt; // if array is empty: does nothing<br>&gt;&gt; // if 5 &gt;= array.endIndex : sets last element<br>&gt;&gt; // if index &lt; 0 : sets first index<br>&gt;&gt; <br>&gt;&gt; So definitely worth considering.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 16.01.2016 um 21:44 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi there!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From time to time, I find myself using safe subscripting, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array = [1, 2, 3]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array[safe: 0] // 1<br>&gt;&gt;&gt; array[safe: 1] // 2<br>&gt;&gt;&gt; array[safe: 2] // 3<br>&gt;&gt;&gt; array[safe: 3] // nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … with the following implementation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; subscript (safe index: Int) -&gt; Element? {<br>&gt;&gt;&gt;     return self.indices ~= index ? self[index] : nil<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering … wouldn’t it be handy to have this in the standard library?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best regards,<br>&gt;&gt;&gt; Rudolf Adamkovic<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/7593cad3/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 17, 2016 at 10:00:00am</p></header><div class="content"><p>I think this maybe a good idea for someone.<br></p><p>However, you add another burden by dealing with the optional. So the<br>choices facing the programmers are choose from bound checking to optional<br>dealing.<br></p><p>zhaoxin<br></p><p>On Sun, Jan 17, 2016 at 9:55 AM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is true that the setter could cause some confusion in the first place<br>&gt; but I think of these particular setters as optional chaining:<br>&gt;<br>&gt; person.residence?.address = &quot;1 Infinite Loop&quot;<br>&gt;<br>&gt; Where the `address` is not set when `residence` is nil. So it&#39;s like the<br>&gt; array is nil/not defined if you access it out of bounds.<br>&gt;<br>&gt;<br>&gt; In addition subscripts imply O(1) access/set so the expanding array setter<br>&gt; should be implemented as method.<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 17.01.2016 um 02:29 schrieb davesweeris at mac.com:<br>&gt;<br>&gt; I’m definitely +1 on the getter. I have reservations on the setter. As<br>&gt; described, this code:<br>&gt;<br>&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;     return self.indices ~= index ? self[index] : nil<br>&gt; }<br>&gt;<br>&gt; subscript(clamp index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil } // again,<br>&gt; because subscripts can’t be setter-only<br>&gt;     set {<br>&gt;         if self.indices ~= index {<br>&gt;             self[index] = newValue!<br>&gt;         } else {<br>&gt;             self.append(newValue!)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Would lead to some counter-intuitive results.<br>&gt;<br>&gt; var foo = [0, 1, 2]<br>&gt; print(foo[safe: 2]) // Optional(2)… Yep<br>&gt; foo[clamp: 6] = 6<br>&gt; print(foo[safe: 6]) // nil… Wait, what? I just set that to 6! Why is it<br>&gt; nil now?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Instead of just appending the new value, we could extend the array to the<br>&gt; required capacity:<br>&gt;<br>&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;     set {<br>&gt;         if self.indices ~= index {<br>&gt;             self[index] = newValue!<br>&gt;         } else {<br>&gt;             while !(self.indices ~= index) {<br>&gt;                 self.append(newValue!)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The results could still be unexpected:<br>&gt;<br>&gt; var foo = [0, 1, 2]<br>&gt; print(foo)  // [0, 1, 2]… Yep<br>&gt; foo[safe: 9] = 9<br>&gt; print(foo[safe: 9])  // Optional(9)… Yep<br>&gt;<br>&gt; print(foo)  // [0, 1, 2, 9, 9, 9, 9, 9, 9]… Wow, that’s bigger than I<br>&gt; thought<br>&gt;<br>&gt;<br>&gt; but at least you’d be able to read from the index to which you just wrote.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jan 16, 2016, at 14:08, Maximilian Hünenberger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve also thought of this. But the concept of safe indexing can also be<br>&gt; extended to CollectionType (or to the more abstract Indexable protocol)<br>&gt; where it&#39;s index is Comparable.<br>&gt;<br>&gt; For mutable Collections/MutableIndexable there could be two versions of a<br>&gt; safe subscript set:<br>&gt;<br>&gt; array[safe: 5] = 7 // does nothing if index out of bounds<br>&gt;<br>&gt; array[clamp: 5] = 7<br>&gt; // if array is empty: does nothing<br>&gt; // if 5 &gt;= array.endIndex : sets last element<br>&gt; // if index &lt; 0 : sets first index<br>&gt;<br>&gt; So definitely worth considering.<br>&gt;<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 16.01.2016 um 21:44 schrieb Rudolf Adamkovič via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Hi there!<br>&gt;<br>&gt; From time to time, I find myself using safe subscripting, e.g.:<br>&gt;<br>&gt; let array = [1, 2, 3]<br>&gt;<br>&gt; array[safe: 0] // 1<br>&gt; array[safe: 1] // 2<br>&gt; array[safe: 2] // 3<br>&gt; array[safe: 3] // nil<br>&gt;<br>&gt;<br>&gt; … with the following implementation:<br>&gt;<br>&gt; subscript (safe index: Int) -&gt; Element? {<br>&gt;     return self.indices ~= index ? self[index] : nil<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I was wondering … wouldn’t it be handy to have this in the standard<br>&gt; library?<br>&gt;<br>&gt; Best regards,<br>&gt; Rudolf Adamkovic<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/df822ccf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 16, 2016 at 07:00:00pm</p></header><div class="content"><p>So, this?<br>subscript(safe index: Index) -&gt; Element? {<br>    get { return self.indices ~= index ? self[index] : nil }<br>    set {<br>        if self.indices ~= index {<br>            self[index] = newValue!<br>        }<br>    }<br>}<br></p><p>The problem with that is again semantics. You’re (sorta) saying “here, let me safely store this for you”, and then it doesn’t get stored because “safe” applies to the indexing as opposed to the assignment. What about “failable”?<br>subscript(failable index: Index) -&gt; Element? {<br>    get { return self.indices ~= index ? self[index] : nil }<br>    set {<br>        if self.indices ~= index &amp;&amp; newValue != nil {<br>            self[index] = newValue!<br>        }<br>    }<br>}<br></p><p>var foo = [1] // normal<br>var bar = foo[failable: 2] //nil, but it’s clearly failable, so no surprise <br>foo[failable: 2] = 3 //nothing happens, but again it’s clearly failable, so we know the assignment might not’ve stuck<br></p><p><br></p><p>&gt; On Jan 16, 2016, at 17:55, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; It is true that the setter could cause some confusion in the first place but I think of these particular setters as optional chaining:<br>&gt; <br>&gt; person.residence?.address = &quot;1 Infinite Loop&quot;<br>&gt; <br>&gt; Where the `address` is not set when `residence` is nil. So it’s like the array is nil/not defined if you access it out of bounds.<br></p><p>I really like that! I think the optional chaining syntax would make the semantics crystal clear<br>// note the ? after subscript<br>subscript?(index: Index) -&gt; Element? {…}<br></p><p>var foo = [1] // normal<br>var bar = foo?[2] // returns an Int?, just like with [Int]?<br>foo?[2] = 3 // performs assignment if possible, just like with [Int]?<br></p><p>I don’t know what it would take to get the “?” to apply to `[]` instead of `foo`. I have no (well, little) doubt that it’s possible, but I don’t know how hard it’d be or if it’d break anything. Off the top of my head, even though the results are just like if foo were `[Int]?`, the compiled code would not be the same. If we’re only talking about “safely” (or whatever the adverb is) indexing normal arrays, it’s not an issue because there’s nothing for the “?” to unwrap, so the programmer must be referring to the “safe” variant. With [Int]? though, are we unwrapping it? I guess we’d have to since `Optional&lt;T&gt;` isn’t subscriptable, so… Maybe this?<br>var optionalfoo:[Int]? = [1]<br>var bar = optionalfoo??[2] // “??”, so the optional is unwrapped *and* we use the “safe&quot; subscript. bar = nil<br>var crashBar = optionalfoo?[2] // “?”, so the optional is unwrapped, but we use the normal subscript and crash<br></p><p>I’m not at all certain what the implications of this would be for the rest of the language, though. Hmm…<br></p><p><br>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160116/89919565/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 16, 2016 at 07:00:00pm</p></header><div class="content"><p>Actually, I just thought of another setter problem: everything talked about so far allows you to assign a &#39;Element?&#39;, which can ignored in the setter (and is in some of the code snippets I posted), but assigning &#39;nil&#39; really should be a compile-time error.<br></p><p>Should this be split into two proposals (one for getter and one for setter), or is that premature?<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 17, 2016 at 11:00:00am</p></header><div class="content"><p>Dave, that’s a great point. The word “safe” doesn’t really work for setters, you’re totally right.<br></p><p>What about this:<br></p><p>let array = [0, 1, 2]<br></p><p>array[ifExists: 0] // same as array[0]<br>array[ifExists: 3] // doesn’t exist, evaluates to nil<br></p><p>var array = [0, 1, 2]<br></p><p>array[ifExists: 0] = 42 // same as array[0] = 42<br>array[ifExists: 3] = 42 // doesn’t exist, does nothing<br></p><p>Reads a bit better than “failable&quot; to me.<br></p><p>Ideas?<br></p><p>R+<br></p><p>&gt; On 17 Jan 2016, at 04:06, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So, this?<br>&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;     set {<br>&gt;         if self.indices ~= index {<br>&gt;             self[index] = newValue!<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The problem with that is again semantics. You’re (sorta) saying “here, let me safely store this for you”, and then it doesn’t get stored because “safe” applies to the indexing as opposed to the assignment. What about “failable”?<br>&gt; subscript(failable index: Index) -&gt; Element? {<br>&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;     set {<br>&gt;         if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;             self[index] = newValue!<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; var foo = [1] // normal<br>&gt; var bar = foo[failable: 2] //nil, but it’s clearly failable, so no surprise <br>&gt; foo[failable: 2] = 3 //nothing happens, but again it’s clearly failable, so we know the assignment might not’ve stuck<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 16, 2016, at 17:55, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is true that the setter could cause some confusion in the first place but I think of these particular setters as optional chaining:<br>&gt;&gt; <br>&gt;&gt; person.residence?.address = &quot;1 Infinite Loop&quot;<br>&gt;&gt; <br>&gt;&gt; Where the `address` is not set when `residence` is nil. So it’s like the array is nil/not defined if you access it out of bounds.<br>&gt; <br>&gt; I really like that! I think the optional chaining syntax would make the semantics crystal clear<br>&gt; // note the ? after subscript<br>&gt; subscript?(index: Index) -&gt; Element? {…}<br>&gt; <br>&gt; var foo = [1] // normal<br>&gt; var bar = foo?[2] // returns an Int?, just like with [Int]?<br>&gt; foo?[2] = 3 // performs assignment if possible, just like with [Int]?<br>&gt; <br>&gt; I don’t know what it would take to get the “?” to apply to `[]` instead of `foo`. I have no (well, little) doubt that it’s possible, but I don’t know how hard it’d be or if it’d break anything. Off the top of my head, even though the results are just like if foo were `[Int]?`, the compiled code would not be the same. If we’re only talking about “safely” (or whatever the adverb is) indexing normal arrays, it’s not an issue because there’s nothing for the “?” to unwrap, so the programmer must be referring to the “safe” variant. With [Int]? though, are we unwrapping it? I guess we’d have to since `Optional&lt;T&gt;` isn’t subscriptable, so… Maybe this?<br>&gt; var optionalfoo:[Int]? = [1]<br>&gt; var bar = optionalfoo??[2] // “??”, so the optional is unwrapped *and* we use the “safe&quot; subscript. bar = nil<br>&gt; var crashBar = optionalfoo?[2] // “?”, so the optional is unwrapped, but we use the normal subscript and crash<br>&gt; <br>&gt; I’m not at all certain what the implications of this would be for the rest of the language, though. Hmm…<br>&gt; <br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/35fde05b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 19, 2016 at 06:00:00am</p></header><div class="content"><p>Good points! <br>I like ifExists: even more than failable:<br></p><p>-Thorsten <br></p><p>&gt; Am 17.01.2016 um 11:26 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Dave, that’s a great point. The word “safe” doesn’t really work for setters, you’re totally right.<br>&gt; <br>&gt; What about this:<br>&gt; <br>&gt; let array = [0, 1, 2]<br>&gt; <br>&gt; array[ifExists: 0] // same as array[0]<br>&gt; array[ifExists: 3] // doesn’t exist, evaluates to nil<br>&gt; <br>&gt; var array = [0, 1, 2]<br>&gt; <br>&gt; array[ifExists: 0] = 42 // same as array[0] = 42<br>&gt; array[ifExists: 3] = 42 // doesn’t exist, does nothing<br>&gt; <br>&gt; Reads a bit better than “failable&quot; to me.<br>&gt; <br>&gt; Ideas?<br>&gt; <br>&gt; R+<br>&gt; <br>&gt;&gt; On 17 Jan 2016, at 04:06, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So, this?<br>&gt;&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;&gt;     set {<br>&gt;&gt;         if self.indices ~= index {<br>&gt;&gt;             self[index] = newValue!<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The problem with that is again semantics. You’re (sorta) saying “here, let me safely store this for you”, and then it doesn’t get stored because “safe” applies to the indexing as opposed to the assignment. What about “failable”?<br>&gt;&gt; subscript(failable index: Index) -&gt; Element? {<br>&gt;&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;&gt;     set {<br>&gt;&gt;         if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;             self[index] = newValue!<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var foo = [1] // normal<br>&gt;&gt; var bar = foo[failable: 2] //nil, but it’s clearly failable, so no surprise <br>&gt;&gt; foo[failable: 2] = 3 //nothing happens, but again it’s clearly failable, so we know the assignment might not’ve stuck<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 16, 2016, at 17:55, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is true that the setter could cause some confusion in the first place but I think of these particular setters as optional chaining:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; person.residence?.address = &quot;1 Infinite Loop&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Where the `address` is not set when `residence` is nil. So it’s like the array is nil/not defined if you access it out of bounds.<br>&gt;&gt; <br>&gt;&gt; I really like that! I think the optional chaining syntax would make the semantics crystal clear<br>&gt;&gt; // note the ? after subscript<br>&gt;&gt; subscript?(index: Index) -&gt; Element? {…}<br>&gt;&gt; <br>&gt;&gt; var foo = [1] // normal<br>&gt;&gt; var bar = foo?[2] // returns an Int?, just like with [Int]?<br>&gt;&gt; foo?[2] = 3 // performs assignment if possible, just like with [Int]?<br>&gt;&gt; <br>&gt;&gt; I don’t know what it would take to get the “?” to apply to `[]` instead of `foo`. I have no (well, little) doubt that it’s possible, but I don’t know how hard it’d be or if it’d break anything. Off the top of my head, even though the results are just like if foo were `[Int]?`, the compiled code would not be the same. If we’re only talking about “safely” (or whatever the adverb is) indexing normal arrays, it’s not an issue because there’s nothing for the “?” to unwrap, so the programmer must be referring to the “safe” variant. With [Int]? though, are we unwrapping it? I guess we’d have to since `Optional&lt;T&gt;` isn’t subscriptable, so… Maybe this?<br>&gt;&gt; var optionalfoo:[Int]? = [1]<br>&gt;&gt; var bar = optionalfoo??[2] // “??”, so the optional is unwrapped *and* we use the “safe&quot; subscript. bar = nil<br>&gt;&gt; var crashBar = optionalfoo?[2] // “?”, so the optional is unwrapped, but we use the normal subscript and crash<br>&gt;&gt; <br>&gt;&gt; I’m not at all certain what the implications of this would be for the rest of the language, though. Hmm…<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/8fc5f35e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>January 31, 2016 at 11:00:00pm</p></header><div class="content"><p>All right, I put together a proposal:<br></p><p>https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md<br></p><p>… and opened a PR:<br></p><p>https://github.com/apple/swift-evolution/pull/133<br></p><p>Let’s see how this goes.<br></p><p>R+<br></p><p>&gt; On 19 Jan 2016, at 06:53, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Good points! <br>&gt; I like ifExists: even more than failable:<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 17.01.2016 um 11:26 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Dave, that’s a great point. The word “safe” doesn’t really work for setters, you’re totally right.<br>&gt;&gt; <br>&gt;&gt; What about this:<br>&gt;&gt; <br>&gt;&gt; let array = [0, 1, 2]<br>&gt;&gt; <br>&gt;&gt; array[ifExists: 0] // same as array[0]<br>&gt;&gt; array[ifExists: 3] // doesn’t exist, evaluates to nil<br>&gt;&gt; <br>&gt;&gt; var array = [0, 1, 2]<br>&gt;&gt; <br>&gt;&gt; array[ifExists: 0] = 42 // same as array[0] = 42<br>&gt;&gt; array[ifExists: 3] = 42 // doesn’t exist, does nothing<br>&gt;&gt; <br>&gt;&gt; Reads a bit better than “failable&quot; to me.<br>&gt;&gt; <br>&gt;&gt; Ideas?<br>&gt;&gt; <br>&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt;&gt; On 17 Jan 2016, at 04:06, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, this?<br>&gt;&gt;&gt; subscript(safe index: Index) -&gt; Element? {<br>&gt;&gt;&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         if self.indices ~= index {<br>&gt;&gt;&gt;             self[index] = newValue!<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with that is again semantics. You’re (sorta) saying “here, let me safely store this for you”, and then it doesn’t get stored because “safe” applies to the indexing as opposed to the assignment. What about “failable”?<br>&gt;&gt;&gt; subscript(failable index: Index) -&gt; Element? {<br>&gt;&gt;&gt;     get { return self.indices ~= index ? self[index] : nil }<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;&gt;             self[index] = newValue!<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo = [1] // normal<br>&gt;&gt;&gt; var bar = foo[failable: 2] //nil, but it’s clearly failable, so no surprise <br>&gt;&gt;&gt; foo[failable: 2] = 3 //nothing happens, but again it’s clearly failable, so we know the assignment might not’ve stuck<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 16, 2016, at 17:55, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is true that the setter could cause some confusion in the first place but I think of these particular setters as optional chaining:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; person.residence?.address = &quot;1 Infinite Loop&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Where the `address` is not set when `residence` is nil. So it’s like the array is nil/not defined if you access it out of bounds.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like that! I think the optional chaining syntax would make the semantics crystal clear<br>&gt;&gt;&gt; // note the ? after subscript<br>&gt;&gt;&gt; subscript?(index: Index) -&gt; Element? {…}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo = [1] // normal<br>&gt;&gt;&gt; var bar = foo?[2] // returns an Int?, just like with [Int]?<br>&gt;&gt;&gt; foo?[2] = 3 // performs assignment if possible, just like with [Int]?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know what it would take to get the “?” to apply to `[]` instead of `foo`. I have no (well, little) doubt that it’s possible, but I don’t know how hard it’d be or if it’d break anything. Off the top of my head, even though the results are just like if foo were `[Int]?`, the compiled code would not be the same. If we’re only talking about “safely” (or whatever the adverb is) indexing normal arrays, it’s not an issue because there’s nothing for the “?” to unwrap, so the programmer must be referring to the “safe” variant. With [Int]? though, are we unwrapping it? I guess we’d have to since `Optional&lt;T&gt;` isn’t subscriptable, so… Maybe this?<br>&gt;&gt;&gt; var optionalfoo:[Int]? = [1]<br>&gt;&gt;&gt; var bar = optionalfoo??[2] // “??”, so the optional is unwrapped *and* we use the “safe&quot; subscript. bar = nil<br>&gt;&gt;&gt; var crashBar = optionalfoo?[2] // “?”, so the optional is unwrapped, but we use the normal subscript and crash<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not at all certain what the implications of this would be for the rest of the language, though. Hmm…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/9afe7f11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>The setter of the subscript should be:<br></p><p>set {<br>    if self.indices ~= index &amp;&amp; newValue != nil {<br>        self[index] = newValue!<br>    }<br>}<br></p><p>Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br></p><p>It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br></p><p>The setter is weird because you can use an optional element:<br></p><p>var arr = [1]<br>// is valid but doesn&#39;t set the first element<br>arr[ifExists: 0] = nil<br></p><p>var arr2: [Int?] = [1]<br>arr2[ifExists: 0] = nil // changes nothing<br>arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br></p><p>I don&#39;t know whether a setter should be added at all.<br></p><p>- Maximilian<br></p><p>&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; All right, I put together a proposal:<br>&gt; <br>&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md<br>&gt; <br>&gt; … and opened a PR:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/133<br>&gt; <br>&gt; Let’s see how this goes.<br>&gt; <br>&gt; R+<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/41a68543/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 31, 2016 at 03:00:00pm</p></header><div class="content"><p>My recollection from the discussion thread is that we didn&#39;t really reach a firm consensus on the setter semantics, mostly because Swift doesn&#39;t support setter-only subscripts, and we couldn&#39;t come up with one argument label that both read well as both a setter &amp; a getter, *and* clearly meant that the assignment itself could fail.<br></p><p>Don&#39;t misunderstand me... I&#39;m definitely +1 on this, I&#39;m just not a fan of &quot;ifExists&quot; (no, I don&#39;t have any better ideas)<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 31, 2016, at 15:07, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The setter of the subscript should be:<br>&gt; <br>&gt; set {<br>&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;         self[index] = newValue!<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt; <br>&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt; <br>&gt; The setter is weird because you can use an optional element:<br>&gt; <br>&gt; var arr = [1]<br>&gt; // is valid but doesn&#39;t set the first element<br>&gt; arr[ifExists: 0] = nil<br>&gt; <br>&gt; var arr2: [Int?] = [1]<br>&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt; <br>&gt; I don&#39;t know whether a setter should be added at all.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; All right, I put together a proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md<br>&gt;&gt; <br>&gt;&gt; … and opened a PR:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/133<br>&gt;&gt; <br>&gt;&gt; Let’s see how this goes.<br>&gt;&gt; <br>&gt;&gt; R+<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/26def0ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 31, 2016 at 04:00:00pm</p></header><div class="content"><p>Here&#39;s real working code you can tinker with in Swift 2.1:<br></p><p>extension Indexable {<br></p><p>    public subscript(ifExists index: Index) -&gt; _Element? {<br></p><p>        get {<br></p><p>            if startIndex.distanceTo(index) &lt; startIndex.distanceTo(endIndex)<br>{<br></p><p>                return self[index]<br></p><p>            }<br></p><p>            return nil<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>You can make the setter work and factor out some of the ugly if you wanted.<br>I didn&#39;t want to. I have no desire to see this in the language. I just<br>wanted to point out that developers who want it can have it today.<br></p><p>-david  https://github.com/AE9RB/SwiftGL<br></p><p>On Sun, Jan 31, 2016 at 3:21 PM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My recollection from the discussion thread is that we didn&#39;t really reach<br>&gt; a firm consensus on the setter semantics, mostly because Swift doesn&#39;t<br>&gt; support setter-only subscripts, and we couldn&#39;t come up with one argument<br>&gt; label that both read well as both a setter &amp; a getter, *and* clearly meant<br>&gt; that the assignment itself could fail.<br>&gt;<br>&gt; Don&#39;t misunderstand me... I&#39;m definitely +1 on this, I&#39;m just not a fan of<br>&gt; &quot;ifExists&quot; (no, I don&#39;t have any better ideas)<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jan 31, 2016, at 15:07, Maximilian Hünenberger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The setter of the subscript should be:<br>&gt;<br>&gt;<br>&gt; set {<br>&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;         self[index] = newValue!<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;<br>&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and<br>&gt; &quot;MutableCollectionType&quot;.<br>&gt;<br>&gt; The setter is weird because you can use an optional element:<br>&gt;<br>&gt; var arr = [1]<br>&gt; // is valid but doesn&#39;t set the first element<br>&gt; arr[ifExists: 0] = nil<br>&gt;<br>&gt; var arr2: [Int?] = [1]<br>&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;<br>&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt;<br>&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; All right, I put together a proposal:<br>&gt;<br>&gt;<br>&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md<br>&gt;<br>&gt; … and opened a PR:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/pull/133<br>&gt;<br>&gt; Let’s see how this goes.<br>&gt;<br>&gt; R+<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/e177f83e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Maximilian,<br></p><p>ah, I see. This is a show stopper then!<br></p><p>From what I imagine, this should not type-check:<br></p><p>var array = [1]<br>array[ifExists: 0] = nil<br></p><p>… and this should set array[0] to nil:<br></p><p>var array: [Int?] = [1]<br>array[ifExists: 0] = nil<br></p><p>Is it not possible to implement such setter in Swift?<br></p><p>R+<br></p><p>&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; The setter of the subscript should be:<br>&gt; <br>&gt; set {<br>&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;         self[index] = newValue!<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt; <br>&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt; <br>&gt; The setter is weird because you can use an optional element:<br>&gt; <br>&gt; var arr = [1]<br>&gt; // is valid but doesn&#39;t set the first element<br>&gt; arr[ifExists: 0] = nil<br>&gt; <br>&gt; var arr2: [Int?] = [1]<br>&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt; <br>&gt; I don&#39;t know whether a setter should be added at all.<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; All right, I put together a proposal:<br>&gt;&gt; <br>&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md &lt;https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md&gt;<br>&gt;&gt; <br>&gt;&gt; … and opened a PR:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/pull/133 &lt;https://github.com/apple/swift-evolution/pull/133&gt;<br>&gt;&gt; <br>&gt;&gt; Let’s see how this goes.<br>&gt;&gt; <br>&gt;&gt; R+<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/66960cac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Really, it should allow the nil to go through for any type that conforms to NilLiteralConvertible, not just Optionals. This code compiles on its own, but fails when you try to use it with an optional type:<br>extension Array {<br>    subscript(failableLookup idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>    }<br>}<br>extension Array where Element: NilLiteralConvertible {<br>    subscript(failableLookup idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set {<br>            if (startIndex ..&lt; endIndex) ~= idx {<br>                switch newValue {<br>                case .None:         self[idx] = nil<br>                case .Some(let nv): self[idx] = nv<br>                }<br>            }<br>        }<br>    }<br>}<br>var optarr: [Int?] = [1,2,3]<br>print(optarr)<br>optarr[failableLookup: 2] = nil // Ambiguous use of &#39;subscript(failableLookup:)&#39;<br></p><p>I don’t understand why the compiler thinks it’s ambiguous, though. Int? is NilLiteralConvertible, so the compiler should send it to the more specialized subscript. At least I thought that was how it was supposed to work. It might be a compiler bug, though, because it’s quite confused… It claims its two choices are:<br>EquationTests.swift:29:9: Found this candidate<br>EquationTests.swift:29:9: Found this candidate<br></p><p>and that’s the same line that tripped the error in the first place: optarr[failableLookup: 2] = nil<br></p><p>Astute readers will notice two things: First, the two candidates are identical, so there’s actually only one candidate. Second, optarr[failableLookup: 2] = nil does not define a subscript function, ambiguous or otherwise.<br></p><p>Anyway, that’s as far as I got with it.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 00:53, Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Maximilian,<br>&gt; <br>&gt; ah, I see. This is a show stopper then!<br>&gt; <br>&gt; From what I imagine, this should not type-check:<br>&gt; <br>&gt; var array = [1]<br>&gt; array[ifExists: 0] = nil<br>&gt; <br>&gt; … and this should set array[0] to nil:<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil<br>&gt; <br>&gt; Is it not possible to implement such setter in Swift?<br>&gt; <br>&gt; R+<br>&gt; <br>&gt;&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The setter of the subscript should be:<br>&gt;&gt; <br>&gt;&gt; set {<br>&gt;&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;         self[index] = newValue!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;&gt; <br>&gt;&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt;&gt; <br>&gt;&gt; The setter is weird because you can use an optional element:<br>&gt;&gt; <br>&gt;&gt; var arr = [1]<br>&gt;&gt; // is valid but doesn&#39;t set the first element<br>&gt;&gt; arr[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; var arr2: [Int?] = [1]<br>&gt;&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt;&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; All right, I put together a proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md &lt;https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … and opened a PR:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/133 &lt;https://github.com/apple/swift-evolution/pull/133&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s see how this goes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; R+<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/38a842bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 09:00:00pm</p></header><div class="content"><p>I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br></p><p>&gt; extension Array {<br>&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;     }<br>&gt; }<br></p><p><br>        // array[index1] is only set if both indexes are valid<br>        array[ifExists: index1] = array[ifExists: index2] <br></p><p><br>if array is of type [Int?] and the special setter for optional Elements would have been added:<br></p><p>array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br></p><p><br>- Maximilian<br></p><p>&gt; Am 01.02.2016 um 22:34 schrieb davesweeris at mac.com:<br>&gt; <br>&gt; Really, it should allow the nil to go through for any type that conforms to NilLiteralConvertible, not just Optionals. This code compiles on its own, but fails when you try to use it with an optional type:<br>&gt; extension Array {<br>&gt;     subscript(failableLookup idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;     }<br>&gt; }<br>&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;     subscript(failableLookup idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set {<br>&gt;             if (startIndex ..&lt; endIndex) ~= idx {<br>&gt;                 switch newValue {<br>&gt;                 case .None:         self[idx] = nil<br>&gt;                 case .Some(let nv): self[idx] = nv<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; var optarr: [Int?] = [1,2,3]<br>&gt; print(optarr)<br>&gt; optarr[failableLookup: 2] = nil // Ambiguous use of &#39;subscript(failableLookup:)&#39;<br>&gt; <br>&gt; I don’t understand why the compiler thinks it’s ambiguous, though. Int? is NilLiteralConvertible, so the compiler should send it to the more specialized subscript. At least I thought that was how it was supposed to work. It might be a compiler bug, though, because it’s quite confused… It claims its two choices are:<br>&gt; EquationTests.swift:29:9: Found this candidate<br>&gt; EquationTests.swift:29:9: Found this candidate<br>&gt; <br>&gt; and that’s the same line that tripped the error in the first place: optarr[failableLookup: 2] = nil<br>&gt; <br>&gt; Astute readers will notice two things: First, the two candidates are identical, so there’s actually only one candidate. Second, optarr[failableLookup: 2] = nil does not define a subscript function, ambiguous or otherwise.<br>&gt; <br>&gt; Anyway, that’s as far as I got with it.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 00:53, Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Maximilian,<br>&gt;&gt; <br>&gt;&gt; ah, I see. This is a show stopper then!<br>&gt;&gt; <br>&gt;&gt; From what I imagine, this should not type-check:<br>&gt;&gt; <br>&gt;&gt; var array = [1]<br>&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; … and this should set array[0] to nil:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; Is it not possible to implement such setter in Swift?<br>&gt;&gt; <br>&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt;&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The setter of the subscript should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; set {<br>&gt;&gt;&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;&gt;         self[index] = newValue!<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The setter is weird because you can use an optional element:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var arr = [1]<br>&gt;&gt;&gt; // is valid but doesn&#39;t set the first element<br>&gt;&gt;&gt; arr[ifExists: 0] = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var arr2: [Int?] = [1]<br>&gt;&gt;&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt;&gt;&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All right, I put together a proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md &lt;https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; … and opened a PR:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/133 &lt;https://github.com/apple/swift-evolution/pull/133&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s see how this goes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/94e6729a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 04.02.2016 um 21:24 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt;         // array[index1] is only set if both indexes are valid<br>&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt; <br>&gt; <br>&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt; <br>&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br></p><p>Why is that unfortunate? Isn&#39;t it exactly what you specified in your assignment?<br></p><p>-Thorsten <br></p><p><br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 01.02.2016 um 22:34 schrieb davesweeris at mac.com:<br>&gt;&gt; <br>&gt;&gt; Really, it should allow the nil to go through for any type that conforms to NilLiteralConvertible, not just Optionals. This code compiles on its own, but fails when you try to use it with an optional type:<br>&gt;&gt; extension Array {<br>&gt;&gt;     subscript(failableLookup idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;&gt;     subscript(failableLookup idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set {<br>&gt;&gt;             if (startIndex ..&lt; endIndex) ~= idx {<br>&gt;&gt;                 switch newValue {<br>&gt;&gt;                 case .None:         self[idx] = nil<br>&gt;&gt;                 case .Some(let nv): self[idx] = nv<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; var optarr: [Int?] = [1,2,3]<br>&gt;&gt; print(optarr)<br>&gt;&gt; optarr[failableLookup: 2] = nil // Ambiguous use of &#39;subscript(failableLookup:)&#39;<br>&gt;&gt; <br>&gt;&gt; I don’t understand why the compiler thinks it’s ambiguous, though. Int? is NilLiteralConvertible, so the compiler should send it to the more specialized subscript. At least I thought that was how it was supposed to work. It might be a compiler bug, though, because it’s quite confused… It claims its two choices are:<br>&gt;&gt; EquationTests.swift:29:9: Found this candidate<br>&gt;&gt; EquationTests.swift:29:9: Found this candidate<br>&gt;&gt; <br>&gt;&gt; and that’s the same line that tripped the error in the first place: optarr[failableLookup: 2] = nil<br>&gt;&gt; <br>&gt;&gt; Astute readers will notice two things: First, the two candidates are identical, so there’s actually only one candidate. Second, optarr[failableLookup: 2] = nil does not define a subscript function, ambiguous or otherwise.<br>&gt;&gt; <br>&gt;&gt; Anyway, that’s as far as I got with it.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 00:53, Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Maximilian,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ah, I see. This is a show stopper then!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From what I imagine, this should not type-check:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … and this should set array[0] to nil:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it not possible to implement such setter in Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; R+<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The setter of the subscript should be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; set {<br>&gt;&gt;&gt;&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;&gt;&gt;         self[index] = newValue!<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The setter is weird because you can use an optional element:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var arr = [1]<br>&gt;&gt;&gt;&gt; // is valid but doesn&#39;t set the first element<br>&gt;&gt;&gt;&gt; arr[ifExists: 0] = nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var arr2: [Int?] = [1]<br>&gt;&gt;&gt;&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt;&gt;&gt;&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; All right, I put together a proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; … and opened a PR:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/133<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s see how this goes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; R+<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/782aa1e1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt;         // array[index1] is only set if both indexes are valid<br>&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt; <br>&gt; <br>&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt; <br>&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br></p><p>Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/d48a8e7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 05.02.2016 um 10:20 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt; <br>&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt; <br>&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt; <br>&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br></p><p>You are right, of course!<br></p><p>Actually the code as written above already works exactly like that (I just tried on IBM&#39;s Swift sandbox): if the second index is out of bounds, the value won&#39;t get changed, otherwise it will be changed and the new value will be nil if the array did contain nil at the position of the second index.<br></p><p>-Thorsten <br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/c79fea1d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  6, 2016 at 12:00:00am</p></header><div class="content"><p>You are totally right. The return type is &quot;Int??&quot;.<br></p><p>My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br></p><p>        var array: [Int?] = [1]<br>        array[ifExists: 0] = nil<br></p><p>To set the element at index 0 to nil instead of doing nothing.<br>The next example would also set index 0 to nil even though the getter failed:<br></p><p>         array[ifExists: 0] = array[ifExists: 1]<br></p><p><br>- Maximilian<br></p><p>&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt; <br>&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt; <br>&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt; <br>&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/5abaeecd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February  6, 2016 at 11:00:00am</p></header><div class="content"><p>Has it been considered to just do this:<br></p><p>extension CollectionType {<br>    func at(index: Index) -&gt; Generator.Element? {<br>        return self.indices ~= index ? self[index] : nil<br>    }<br>    func update(value: Generator.Element, atIndex: Index) -&gt; Generator.Element?<br>{<br>        guard self.indices ~= index else { return nil }<br>        let oldValue = self[index]<br>        self[index] = value<br>        return oldValue<br>    }<br>}<br></p><p>Compare:<br>     let x = array[safe: index]<br>     let y = array.at(index)<br></p><p>It&#39;s more concise (for the getter), doesn&#39;t have to introduce new syntax,<br>works in current swift, and it doesn&#39;t have ambiguity about nil in a<br>subscript setter.<br></p><p>There&#39;s precedent for the update function in Dictionary:<br>    public mutating func updateValue(value: Value, forKey key: Key) -&gt;<br>Value?<br></p><p>It would be a shame (and surprising/unsafe) to have to do this:<br></p><p>    array[safe: index] = .Some(nil) // stores nil<br>    array[safe: index] = nil        // deletes a value<br></p><p><br>On Sat, Feb 6, 2016 at 10:58 AM, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;<br>&gt; My point was that if we allowed something like this (as suggested by Dave<br>&gt; Sweeris I think):<br>&gt;<br>&gt;         var array: [Int?] = [1]<br>&gt;         array[ifExists: 0] = nil<br>&gt;<br>&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt; The next example would also set index 0 to nil even though the getter<br>&gt; failed:<br>&gt;<br>&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt;<br>&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I just realized that the normal setter for failable lookups is very nice<br>&gt; in case of assigning/swapping:<br>&gt;<br>&gt; extension Array {<br>&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil {<br>&gt; self[idx] = newValue! } }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt;         // array[index1] is only set if both indexes are valid<br>&gt;         array[ifExists: index1] = array[ifExists: index2]<br>&gt;<br>&gt;<br>&gt; if array is of type [Int?] and the special setter for optional Elements<br>&gt; would have been added:<br>&gt;<br>&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil *or* index2<br>&gt; is not valid which is unfortunate.<br>&gt;<br>&gt;<br>&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test<br>&gt; for as a plain Int? but iirc you can still distinguish a return type of nil<br>&gt; from an optional that happens to contain nil, which should allow you to<br>&gt; tell the difference between a nil value and an invalid index, I just can’t<br>&gt; recall how at the moment (as I design around cases like these like my life<br>&gt; depends on it ;)<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/8fc805f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  6, 2016 at 02:00:00am</p></header><div class="content"><p>Inline:<br></p><p>&gt; Am 06.02.2016 um 01:20 schrieb Andrew Bennett &lt;cacoyi at gmail.com&gt;:<br>&gt; <br>&gt; Has it been considered to just do this:<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     func at(index: Index) -&gt; Generator.Element? {<br>&gt;         return self.indices ~= index ? self[index] : nil<br>&gt;     }<br>&gt;     func update(value: Generator.Element, atIndex: Index) -&gt; Generator.Element? {<br>&gt;         guard self.indices ~= index else { return nil }<br>&gt;         let oldValue = self[index]<br>&gt;         self[index] = value<br>&gt;         return oldValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Compare:<br>&gt;      let x = array[safe: index]<br>&gt;      let y = array.at(index)<br>&gt; <br>&gt; It&#39;s more concise (for the getter), doesn&#39;t have to introduce new syntax, works in current swift, and it doesn&#39;t have ambiguity about nil in a subscript setter.<br>&gt; <br></p><p>Although it is shorter I think an additional safe index access is a small tweak of the normal index access. Therefore it should be a subscript.<br>Furthermore both method names don&#39;t indicate that they could fail.<br>Also consider this example:<br></p><p>        array[ifExists: 0] = array[ifExists: 1]<br></p><p>        // vs<br></p><p>        array.at(1).map{ array.update($0, atIndex: 0) }<br></p><p>        if let newElement = array.at(1) {<br>            array.update(newValue, atIndex: 0)<br>        }<br></p><p>&gt; There&#39;s precedent for the update function in Dictionary:<br>&gt;     public mutating func updateValue(value: Value, forKey key: Key) -&gt; Value?<br>&gt; <br>&gt; It would be a shame (and surprising/unsafe) to have to do this:<br>&gt; <br>&gt;     array[safe: index] = .Some(nil) // stores nil<br></p><p>You only have to use this if &quot;array&quot; is of type &quot;[Int?]&quot; but how often do you use such a type?<br></p><p>&gt;     array[safe: index] = nil        // deletes a value<br>&gt; <br></p><p>This doesn&#39;t delete a value. It does nothing.<br></p><p>- Maximilian<br></p><p>&gt; <br>&gt;&gt; On Sat, Feb 6, 2016 at 10:58 AM, Maximilian Hünenberger &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt; <br>&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt; <br>&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt; <br>&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/368c70b5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  5, 2016 at 04:00:00pm</p></header><div class="content"><p>There&#39;s a pretty big difference between &quot;nil&quot; and &quot;Some(nil)&quot; (and &quot;Some(Some(1))&quot;). This was covered pretty early on in the Apple Swift blog &lt;https://developer.apple.com/swift/blog/?id=12&gt;  While double optionals can be confusing for humans, the compiler ought to pretty much always do something sensible.<br></p><p>…though I did say &quot;ought to&quot;; the compiler has done some less-than-sensible things in overload resolution before…<br></p><p>Jordan<br></p><p><br>&gt; On Feb 5, 2016, at 15:58, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt; <br>&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt; <br>&gt;         var array: [Int?] = [1]<br>&gt;         array[ifExists: 0] = nil<br>&gt; <br>&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt; <br>&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt; <br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt; <br>&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/42cc548d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt; <br>&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt; <br>&gt;         var array: [Int?] = [1]<br>&gt;         array[ifExists: 0] = nil<br>&gt; <br>&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt; <br>&gt;          array[ifExists: 0] = array[ifExists: 1]<br></p><p>No, it doesn&#39;t. Just try it out.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt; <br>&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/6eb8c3b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Probably I wasn&#39;t clear about that. Sorry.<br></p><p>My concern was about adding (code from Dave Sweeris):<br></p><p>extension Array where Element: NilLiteralConvertible {<br>    subscript(ifExists idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>    }<br>}<br></p><p><br>Since it would allow this:<br></p><p>var array: [Int?] = [1]<br>array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>print(array) // &quot;[nil]&quot;<br>array = [1]<br>array[ifExists: 0] = array[ifExists: 1]<br>print(array) // &quot;[nil]&quot;<br></p><p>Whereas the normal behavior:<br></p><p>var array: [Int?] = [1]<br>array[ifExists: 0] = nil // does nothing<br>print(array) // &quot;[1]&quot;<br>array[ifExists: 0] = array[ifExists: 1] // does nothing<br>print(array) // &quot;[1]&quot;<br></p><p><br>Hope this clarifies my point<br>- Maximilian<br></p><p>&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt; <br>&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt; <br>&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt; <br>&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt; <br>&gt; No, it doesn&#39;t. Just try it out.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/913cb8fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Ah ok, I was using the other version which distinguishes between nil and Optional(nil):<br></p><p>extension Array {<br>    subscript(ifExists idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>    }<br>}<br></p><p>Where you can assign Optional(nil) to set a value to nil which is admittedly not very intuitive...<br></p><p>var array: [Int?] = [1]<br>array[ifExists: 0] = Optional(nil)<br>print(array) // &quot;[nil]&quot;<br>array = [1]<br>array[ifExists: 0] = array[ifExists: 1]<br>print(array) // &quot;[Optional(1)]&quot;<br></p><p>A solution would probably be to introduce another enum mimicking Optional but built for the array subscript which allows to distinguish both cases.<br></p><p>-Thorsten <br></p><p>&gt; Am 06.02.2016 um 21:52 schrieb Maximilian Hünenberger &lt;m.huenenberger at me.com&gt;:<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; array = [1]<br>&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt; print(array) // &quot;[nil]&quot;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/5cbf62e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  6, 2016 at 03:00:00pm</p></header><div class="content"><p>In principle, I’m not opposed to that. In practice, though… unless you’re also proposing we give it “magic” syntax like what Optionals currently have, we’d have to manually wrap/unwrap the values:<br>bar[ifExists: 3] = Result.result(4)<br>print(bar[ifExists: 4].result)<br></p><p>Which would strictly speaking work, but IMHO is more annoying than just manually checking collection.indices.contains(idx) before attempting the subscript.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 6, 2016, at 13:21, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ah ok, I was using the other version which distinguishes between nil and Optional(nil):<br>&gt; <br>&gt; extension Array {<br>&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Where you can assign Optional(nil) to set a value to nil which is admittedly not very intuitive...<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = Optional(nil)<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; array = [1]<br>&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt; <br>&gt; A solution would probably be to introduce another enum mimicking Optional but built for the array subscript which allows to distinguish both cases.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 06.02.2016 um 21:52 schrieb Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt;:<br>&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; array = [1]<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/c8fd3414/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Ah, ok, I think I understand your objection now. Let me try to summarize…<br></p><p>If we extend on MutableCollectionType like this:<br>subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>    get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>    set { if let nv = newValue where self.indices.contains(idx) { self[idx] = nv } }<br>}<br>then, when CollectionType.Generator.Element is NilLiteralConvertible, we have the following problem:<br>var array: [Int?] = [1]<br>array[ifExists: 0] = nil // *PROBLEM*: The most straight-forward way of safely setting something to nil silently fails because the compiler treats this as an Int?? instead of an Int?<br>print(array) // &quot;[Optional(1)]&quot;<br>array[ifExists: 0] = array[ifExists: 1] // *No problem*<br>print(array) // &quot;[Optional(1)]&quot;<br>array[ifExists: 0] = nil as Int? // *No problem*<br>print(array) // &quot;[nil]&quot;<br></p><p>But if we fix it to allow an unannotated nil to go through:<br>subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>    get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>    set {<br>        if self.indices.contains(idx) {<br>            if let nv = newValue {<br>                self[idx] = nv<br>            } else {<br>                if let nilType = self[idx] as? NilLiteralConvertible {<br>                    self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>                }<br>            }<br>        }<br>    }<br>}<br>then we have a different problem:<br>var array: [Int?] = [1, 2, 3]<br>array[ifExists: 0] = nil // *No problem*: The code no longer cares that this is an Int?? instead of an Int?<br>print(array) // &quot;[nil, Optional(2), Optional(3)]&quot;<br>array[ifExists: 1] = array[ifExists: 3] // *PROBLEM*: This shouldn’t do anything, but it succeeds because the code no longer cares that it’s an Int?? instead of an Int?<br>print(array) // &quot;[nil, nil, Optional(3)]&quot;<br>array[ifExists: 2] = nil as Int? // *No problem*<br>print(array) // &quot;[nil, nil, nil]&quot;<br></p><p>Assuming we’re all on the same page now… Yeah, as much as I’d love to keep the array[ifExists: 0] = nil behavior from the “fixed” version, I agree that the 2nd problem is clearly worse than the 1st, especially since being explicit about your nils (array[ifExists: 0] = nil as Int?) allows the assignment to go through.<br></p><p>So I’m in favor of the 1st one, which doesn’t allow unannotated nil assignments to succeed.<br></p><p>The only alternative I can think of is changing the language to allow subscripts to throw errors:<br>enum IndexError : ErrorType { case outOfRange }<br>subscript(throwing idx: Self.Index) throws -&gt; Self.Generator.Element {<br>    get {<br>        guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>        return self[idx]<br>    }<br>    set {<br>        guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>        self[idx] = newValue<br>    }<br>}<br></p><p>Although… They aren’t mutually exclusive… It’s obviously not hard to imagine scenarios in which you don’t really care that you&#39;re out of bounds and just want to avoid crashing (otherwise we wouldn’t have been having this conversation in the first place) but nor is it hard to imagine scenarios in which you might want explicit confirmation that there wasn’t an error, rather than having to check for nil or compare before &amp; after versions of the array. In those cases the throwing version would be appropriate. Plus, if your subscript function doesn’t only pass-through to an underlying collection, it might be handy to be able to throw, say, an OutOfMemory error if your subscript function loads or generates some large data structure. Or perhaps you’re writing a file manager, and you’re trying to get files by “subscripting” directories… The file may exist, but you might not have read permission.<br></p><p>Should we propose both?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 6, 2016, at 12:52, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Probably I wasn&#39;t clear about that. Sorry.<br>&gt; <br>&gt; My concern was about adding (code from Dave Sweeris):<br>&gt; <br>&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Since it would allow this:<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; array = [1]<br>&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; <br>&gt; Whereas the normal behavior:<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil // does nothing<br>&gt; print(array) // &quot;[1]&quot;<br>&gt; array[ifExists: 0] = array[ifExists: 1] // does nothing<br>&gt; print(array) // &quot;[1]&quot;<br>&gt; <br>&gt; <br>&gt; Hope this clarifies my point<br>&gt; - Maximilian<br>&gt; <br>&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt; <br>&gt;&gt; No, it doesn&#39;t. Just try it out.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/41fecb6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  6, 2016 at 05:00:00pm</p></header><div class="content"><p>If implemented via extension, you could special case Self.Generator.Element:NilLiteralConvertable. Would that help? You could say in that case that an Optional.None newValue is actually Optional&lt;Element&gt;.Some(Element(nilLiteral:())).<br></p><p>-DW<br></p><p>&gt; On Feb 6, 2016, at 4:19 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ah, ok, I think I understand your objection now. Let me try to summarize…<br>&gt; <br>&gt; If we extend on MutableCollectionType like this:<br>&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;     set { if let nv = newValue where self.indices.contains(idx) { self[idx] = nv } }<br>&gt; }<br>&gt; then, when CollectionType.Generator.Element is NilLiteralConvertible, we have the following problem:<br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil // *PROBLEM*: The most straight-forward way of safely setting something to nil silently fails because the compiler treats this as an Int?? instead of an Int?<br>&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt; array[ifExists: 0] = array[ifExists: 1] // *No problem*<br>&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt; array[ifExists: 0] = nil as Int? // *No problem*<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; <br>&gt; But if we fix it to allow an unannotated nil to go through:<br>&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;     set {<br>&gt;         if self.indices.contains(idx) {<br>&gt;             if let nv = newValue {<br>&gt;                 self[idx] = nv<br>&gt;             } else {<br>&gt;                 if let nilType = self[idx] as? NilLiteralConvertible {<br>&gt;                     self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; then we have a different problem:<br>&gt; var array: [Int?] = [1, 2, 3]<br>&gt; array[ifExists: 0] = nil // *No problem*: The code no longer cares that this is an Int?? instead of an Int?<br>&gt; print(array) // &quot;[nil, Optional(2), Optional(3)]&quot;<br>&gt; array[ifExists: 1] = array[ifExists: 3] // *PROBLEM*: This shouldn’t do anything, but it succeeds because the code no longer cares that it’s an Int?? instead of an Int?<br>&gt; print(array) // &quot;[nil, nil, Optional(3)]&quot;<br>&gt; array[ifExists: 2] = nil as Int? // *No problem*<br>&gt; print(array) // &quot;[nil, nil, nil]&quot;<br>&gt; <br>&gt; Assuming we’re all on the same page now… Yeah, as much as I’d love to keep the array[ifExists: 0] = nil behavior from the “fixed” version, I agree that the 2nd problem is clearly worse than the 1st, especially since being explicit about your nils (array[ifExists: 0] = nil as Int?) allows the assignment to go through.<br>&gt; <br>&gt; So I’m in favor of the 1st one, which doesn’t allow unannotated nil assignments to succeed.<br>&gt; <br>&gt; The only alternative I can think of is changing the language to allow subscripts to throw errors:<br>&gt; enum IndexError : ErrorType { case outOfRange }<br>&gt; subscript(throwing idx: Self.Index) throws -&gt; Self.Generator.Element {<br>&gt;     get {<br>&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;         return self[idx]<br>&gt;     }<br>&gt;     set {<br>&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;         self[idx] = newValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Although… They aren’t mutually exclusive… It’s obviously not hard to imagine scenarios in which you don’t really care that you&#39;re out of bounds and just want to avoid crashing (otherwise we wouldn’t have been having this conversation in the first place) but nor is it hard to imagine scenarios in which you might want explicit confirmation that there wasn’t an error, rather than having to check for nil or compare before &amp; after versions of the array. In those cases the throwing version would be appropriate. Plus, if your subscript function doesn’t only pass-through to an underlying collection, it might be handy to be able to throw, say, an OutOfMemory error if your subscript function loads or generates some large data structure. Or perhaps you’re writing a file manager, and you’re trying to get files by “subscripting” directories… The file may exist, but you might not have read permission.<br>&gt; <br>&gt; Should we propose both?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 6, 2016, at 12:52, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Probably I wasn&#39;t clear about that. Sorry.<br>&gt;&gt; <br>&gt;&gt; My concern was about adding (code from Dave Sweeris):<br>&gt;&gt; <br>&gt;&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Since it would allow this:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; array = [1]<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; <br>&gt;&gt; Whereas the normal behavior:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // does nothing<br>&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // does nothing<br>&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hope this clarifies my point<br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt;&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it doesn&#39;t. Just try it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/9cb3a8bc/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4139 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/9cb3a8bc/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  6, 2016 at 07:00:00pm</p></header><div class="content"><p>I tried that already, and the complier complained that something was ambiguous. But when I did it again just now to get the actual error message, it worked! I tried switching back to extending Array instead of CollectionType, and the ambiguities reappeared: <br>bar[ifExists: 3] = nil // Ambiguous use of ’subscript(ifExists:)’<br></p><p>Now, I would like to know why it’s ambiguous in one case and not the other, but it’s kind of a moot point since even when it’s working, it still allows this counter-intuitive assignment to go through:<br>var bar: [Int?] = [1]<br>bar[ifExists: 0] = bar[ifExists: 6]<br>print(bar) // prints [nil], should print [Optional(1)]<br></p><p>The problem is that an unannotated nil: bar[ifExists: 3] = nil always resolves to Optional&lt;Element&gt;.None, but in the case where Element is itself NilLiteralConvertible, say when Element == Int?, we need the nil to resolve to Optional&lt;Optional&lt;Int&gt;&gt;.Some(Optional&lt;Int&gt;.None).  It’s not hard to explicitly tell the compiler to make it the “correct” kind of nil:  bar[ifExists: 3] = nil as Int?, but I was hoping to avoid the extra syntax, since nobody writes foo = nil unless they’re actually trying to set foo to be nil. Unfortunately, that means the setter has to accept Optional&lt;T:NilLiteralConvertible&gt;.None as a T, which makes it impossible, in the setter anyway, to tell the difference between:<br>var bar: [Int?] = [1, 2]<br>bar[ifExists: 0] = nil //the bar[ifExists: 0] setter promotes the Optional&lt;Optional&lt;Int&gt;&gt;.None to an Optional&lt;Int&gt;.None, and then assigns it to bar[0]<br>and<br>bar[ifExists: 1] = bar[ifExists: 6] // the bar[ifExists: 6] getter returns a Optional&lt;Optional&lt;Int&gt;&gt;.None, which the bar[ifExists: 1] setter then “promotes” to an Optional&lt;Int&gt;.None, and then assigns it to bar[1]<br></p><p>And this leads to the results of a lookup silently failing and then propagating through the assignment.<br></p><p>I think stuff like this is at least part of why the optional system is getting reworked.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 6, 2016, at 16:02, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; If implemented via extension, you could special case Self.Generator.Element:NilLiteralConvertable. Would that help? You could say in that case that an Optional.None newValue is actually Optional&lt;Element&gt;.Some(Element(nilLiteral:())).<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Feb 6, 2016, at 4:19 PM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ah, ok, I think I understand your objection now. Let me try to summarize…<br>&gt;&gt; <br>&gt;&gt; If we extend on MutableCollectionType like this:<br>&gt;&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;&gt;     set { if let nv = newValue where self.indices.contains(idx) { self[idx] = nv } }<br>&gt;&gt; }<br>&gt;&gt; then, when CollectionType.Generator.Element is NilLiteralConvertible, we have the following problem:<br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // *PROBLEM*: The most straight-forward way of safely setting something to nil silently fails because the compiler treats this as an Int?? instead of an Int?<br>&gt;&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // *No problem*<br>&gt;&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt;&gt; array[ifExists: 0] = nil as Int? // *No problem*<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; <br>&gt;&gt; But if we fix it to allow an unannotated nil to go through:<br>&gt;&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;&gt;     set {<br>&gt;&gt;         if self.indices.contains(idx) {<br>&gt;&gt;             if let nv = newValue {<br>&gt;&gt;                 self[idx] = nv<br>&gt;&gt;             } else {<br>&gt;&gt;                 if let nilType = self[idx] as? NilLiteralConvertible {<br>&gt;&gt;                     self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>&gt;&gt;                 }<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; then we have a different problem:<br>&gt;&gt; var array: [Int?] = [1, 2, 3]<br>&gt;&gt; array[ifExists: 0] = nil // *No problem*: The code no longer cares that this is an Int?? instead of an Int?<br>&gt;&gt; print(array) // &quot;[nil, Optional(2), Optional(3)]&quot;<br>&gt;&gt; array[ifExists: 1] = array[ifExists: 3] // *PROBLEM*: This shouldn’t do anything, but it succeeds because the code no longer cares that it’s an Int?? instead of an Int?<br>&gt;&gt; print(array) // &quot;[nil, nil, Optional(3)]&quot;<br>&gt;&gt; array[ifExists: 2] = nil as Int? // *No problem*<br>&gt;&gt; print(array) // &quot;[nil, nil, nil]&quot;<br>&gt;&gt; <br>&gt;&gt; Assuming we’re all on the same page now… Yeah, as much as I’d love to keep the array[ifExists: 0] = nil behavior from the “fixed” version, I agree that the 2nd problem is clearly worse than the 1st, especially since being explicit about your nils (array[ifExists: 0] = nil as Int?) allows the assignment to go through.<br>&gt;&gt; <br>&gt;&gt; So I’m in favor of the 1st one, which doesn’t allow unannotated nil assignments to succeed.<br>&gt;&gt; <br>&gt;&gt; The only alternative I can think of is changing the language to allow subscripts to throw errors:<br>&gt;&gt; enum IndexError : ErrorType { case outOfRange }<br>&gt;&gt; subscript(throwing idx: Self.Index) throws -&gt; Self.Generator.Element {<br>&gt;&gt;     get {<br>&gt;&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;&gt;         return self[idx]<br>&gt;&gt;     }<br>&gt;&gt;     set {<br>&gt;&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;&gt;         self[idx] = newValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Although… They aren’t mutually exclusive… It’s obviously not hard to imagine scenarios in which you don’t really care that you&#39;re out of bounds and just want to avoid crashing (otherwise we wouldn’t have been having this conversation in the first place) but nor is it hard to imagine scenarios in which you might want explicit confirmation that there wasn’t an error, rather than having to check for nil or compare before &amp; after versions of the array. In those cases the throwing version would be appropriate. Plus, if your subscript function doesn’t only pass-through to an underlying collection, it might be handy to be able to throw, say, an OutOfMemory error if your subscript function loads or generates some large data structure. Or perhaps you’re writing a file manager, and you’re trying to get files by “subscripting” directories… The file may exist, but you might not have read permission.<br>&gt;&gt; <br>&gt;&gt; Should we propose both?<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 6, 2016, at 12:52, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Probably I wasn&#39;t clear about that. Sorry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My concern was about adding (code from Dave Sweeris):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since it would allow this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt;&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt;&gt; array = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whereas the normal behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = nil // does nothing<br>&gt;&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // does nothing<br>&gt;&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hope this clarifies my point<br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt;&gt;&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, it doesn&#39;t. Just try it out.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/f9abe307/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Trying to think outside the box here.<br></p><p>From limited testing I have done, the compiler does force both setter and getter to use the exact same optional wrapping, which may have driven part of the design so far. But with subscript which can fail, it could make sense to have the getter wrap Element in an optional, and have the setter use Element directly. Seems to make sense when comparing to pop()/push() operations; the first return wrapped Element, the second assigned no-wrapped Element.<br> <br>This would of course prevent doing<br></p><p>array[ifExists: 0] = array[ifExists: 1]<br></p><p>but this could solved by adding a new assignment operator<br></p><p>array[ifExists: 0] ?= array[ifExists: 1]<br></p><p>Which (try to) assign unwrapped rhs to lhs iff rhs is not nil. This could be useful in other scenario and has been thankfully not stolen by SE024 Optional Value Setter. Unfortunately, this could bring a request for the triple question-mark assignment: assign unwrapped rhs to lhs iff both rhs and lhs are not nil, but I’m diverting here.<br></p><p>A quick test with:<br>infix operator ?= { associativity left precedence 140 assignment}<br>func ?=&lt;T&gt;(left: T, right: T?) -&gt; T {<br>    return right ?? left<br>}<br></p><p>And a [ifExistSet:] and [ifExistGet:] variant look promising; but I let others dig deeper, as I do not have a use case for the setter. On the other hand, I might have some interest in the getter, which bring me to should we investigate the syntax:<br></p><p>array[?1]<br></p><p>(Recap: both array?[1] and array[1]? with any number of ? already have a meaning)<br>I’m suggesting a brief syntax due to a possible use case I stumble upon.<br></p><p>var str:String = &quot;some user provided data with possibly some trailing garbage&quot;<br>let tokens = str.componentsSeparatedByString(&quot; &quot;)<br>switch (tokens[?0], tokens[?1], tokens[?2], tokens[?3]) // Expect 0 to 3 components<br>{<br>    case (let a?, nil, nil, nil): /* Some stuff when only one token */<br>}<br></p><p>Dany<br></p><p>&gt; Le 6 févr. 2016 à 22:48, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I tried that already, and the complier complained that something was ambiguous. But when I did it again just now to get the actual error message, it worked! I tried switching back to extending Array instead of CollectionType, and the ambiguities reappeared: <br>&gt; bar[ifExists: 3] = nil // Ambiguous use of ’subscript(ifExists:)’<br>&gt; <br>&gt; Now, I would like to know why it’s ambiguous in one case and not the other, but it’s kind of a moot point since even when it’s working, it still allows this counter-intuitive assignment to go through:<br>&gt; var bar: [Int?] = [1]<br>&gt; bar[ifExists: 0] = bar[ifExists: 6]<br>&gt; print(bar) // prints [nil], should print [Optional(1)]<br>&gt; <br>&gt; The problem is that an unannotated nil: bar[ifExists: 3] = nil always resolves to Optional&lt;Element&gt;.None, but in the case where Element is itself NilLiteralConvertible, say when Element == Int?, we need the nil to resolve to Optional&lt;Optional&lt;Int&gt;&gt;.Some(Optional&lt;Int&gt;.None).  It’s not hard to explicitly tell the compiler to make it the “correct” kind of nil:  bar[ifExists: 3] = nil as Int?, but I was hoping to avoid the extra syntax, since nobody writes foo = nil unless they’re actually trying to set foo to be nil. Unfortunately, that means the setter has to accept Optional&lt;T:NilLiteralConvertible&gt;.None as a T, which makes it impossible, in the setter anyway, to tell the difference between:<br>&gt; var bar: [Int?] = [1, 2]<br>&gt; bar[ifExists: 0] = nil //the bar[ifExists: 0] setter promotes the Optional&lt;Optional&lt;Int&gt;&gt;.None to an Optional&lt;Int&gt;.None, and then assigns it to bar[0]<br>&gt; and<br>&gt; bar[ifExists: 1] = bar[ifExists: 6] // the bar[ifExists: 6] getter returns a Optional&lt;Optional&lt;Int&gt;&gt;.None, which the bar[ifExists: 1] setter then “promotes” to an Optional&lt;Int&gt;.None, and then assigns it to bar[1]<br>&gt; <br>&gt; And this leads to the results of a lookup silently failing and then propagating through the assignment.<br>&gt; <br>&gt; I think stuff like this is at least part of why the optional system is getting reworked.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 6, 2016, at 16:02, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If implemented via extension, you could special case Self.Generator.Element:NilLiteralConvertable. Would that help? You could say in that case that an Optional.None newValue is actually Optional&lt;Element&gt;.Some(Element(nilLiteral:())).<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 6, 2016, at 4:19 PM, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, ok, I think I understand your objection now. Let me try to summarize…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we extend on MutableCollectionType like this:<br>&gt;&gt;&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;&gt;&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;&gt;&gt;     set { if let nv = newValue where self.indices.contains(idx) { self[idx] = nv } }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; then, when CollectionType.Generator.Element is NilLiteralConvertible, we have the following problem:<br>&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt; array[ifExists: 0] = nil // *PROBLEM*: The most straight-forward way of safely setting something to nil silently fails because the compiler treats this as an Int?? instead of an Int?<br>&gt;&gt;&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt;&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // *No problem*<br>&gt;&gt;&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt;&gt;&gt; array[ifExists: 0] = nil as Int? // *No problem*<br>&gt;&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if we fix it to allow an unannotated nil to go through:<br>&gt;&gt;&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;&gt;&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         if self.indices.contains(idx) {<br>&gt;&gt;&gt;             if let nv = newValue {<br>&gt;&gt;&gt;                 self[idx] = nv<br>&gt;&gt;&gt;             } else {<br>&gt;&gt;&gt;                 if let nilType = self[idx] as? NilLiteralConvertible {<br>&gt;&gt;&gt;                     self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; then we have a different problem:<br>&gt;&gt;&gt; var array: [Int?] = [1, 2, 3]<br>&gt;&gt;&gt; array[ifExists: 0] = nil // *No problem*: The code no longer cares that this is an Int?? instead of an Int?<br>&gt;&gt;&gt; print(array) // &quot;[nil, Optional(2), Optional(3)]&quot;<br>&gt;&gt;&gt; array[ifExists: 1] = array[ifExists: 3] // *PROBLEM*: This shouldn’t do anything, but it succeeds because the code no longer cares that it’s an Int?? instead of an Int?<br>&gt;&gt;&gt; print(array) // &quot;[nil, nil, Optional(3)]&quot;<br>&gt;&gt;&gt; array[ifExists: 2] = nil as Int? // *No problem*<br>&gt;&gt;&gt; print(array) // &quot;[nil, nil, nil]&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming we’re all on the same page now… Yeah, as much as I’d love to keep the array[ifExists: 0] = nil behavior from the “fixed” version, I agree that the 2nd problem is clearly worse than the 1st, especially since being explicit about your nils (array[ifExists: 0] = nil as Int?) allows the assignment to go through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I’m in favor of the 1st one, which doesn’t allow unannotated nil assignments to succeed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only alternative I can think of is changing the language to allow subscripts to throw errors:<br>&gt;&gt;&gt; enum IndexError : ErrorType { case outOfRange }<br>&gt;&gt;&gt; subscript(throwing idx: Self.Index) throws -&gt; Self.Generator.Element {<br>&gt;&gt;&gt;     get {<br>&gt;&gt;&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;&gt;&gt;         return self[idx]<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     set {<br>&gt;&gt;&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;&gt;&gt;         self[idx] = newValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although… They aren’t mutually exclusive… It’s obviously not hard to imagine scenarios in which you don’t really care that you&#39;re out of bounds and just want to avoid crashing (otherwise we wouldn’t have been having this conversation in the first place) but nor is it hard to imagine scenarios in which you might want explicit confirmation that there wasn’t an error, rather than having to check for nil or compare before &amp; after versions of the array. In those cases the throwing version would be appropriate. Plus, if your subscript function doesn’t only pass-through to an underlying collection, it might be handy to be able to throw, say, an OutOfMemory error if your subscript function loads or generates some large data structure. Or perhaps you’re writing a file manager, and you’re trying to get files by “subscripting” directories… The file may exist, but you might not have read permission.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should we propose both?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 6, 2016, at 12:52, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Probably I wasn&#39;t clear about that. Sorry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My concern was about adding (code from Dave Sweeris):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since it would allow this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt;&gt;&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt;&gt;&gt; array = [1]<br>&gt;&gt;&gt;&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whereas the normal behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt; array[ifExists: 0] = nil // does nothing<br>&gt;&gt;&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt;&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // does nothing<br>&gt;&gt;&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hope this clarifies my point<br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt;&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt;&gt;&gt;&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, it doesn&#39;t. Just try it out.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/e85fe6d9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  7, 2016 at 11:00:00pm</p></header><div class="content"><p>Nice summary!<br></p><p>The first &quot;problem&quot; can be solved even easier!!! Due to a feature of Swift I just encountered:<br></p><p>	var num1: Int? = nil<br>	num1? = 1<br>	print(num1) // still nil<br>	<br>	num1 = 2<br>	print(num1) // Optional(2)<br>	num1? = 3<br>	print(num1) // Optional(3)<br>	num1? = nil // not allowed<br></p><p>If you put a &quot;?&quot; after the optional variable it only changes the variable if the variable is not nil. Assignments to &quot;nil&quot; are prohibited if &quot;?&quot; is used. So it is like a nil check and assignments happen only at the unwrapped type level (&quot;Int&quot; not &quot;Int?&quot;):<br></p><p>For &quot;double Optionals&quot;:<br></p><p>	var num2: Int?? = nil<br>	num2? = 4<br>	print(num2) // still Optional(nil)<br>	<br>	num2 = .Some(nil)<br>	num2? = 5   // assigns; only one &quot;unwrap&quot;<br>	print(num2) // Optional(Optional(5))<br>	<br>	num2 = .Some(nil)<br>	num2?? = 6  // &quot;double unwrap&quot;<br>	print(num2) // still Optional(nil)<br></p><p>In our case we can &quot;solve&quot; the first problem the following way:<br></p><p>	var numbers: [Int] = [1, 2, 3]<br>	numbers[ifExists: 0]? = nil // not allowed<br>	<br>	var array: [Int?] = [1]<br>	array[ifExists: 0]? = nil // assignment is guaranteed to succeed if index exists<br>	print(array) // [nil]<br></p><p><br>Having subscripts which throw are good for catching &quot;missing&quot; indices. Although they require you to write &quot;try&quot; everywhere you use it and checking if the assignment comes through can also be done by unwrapping and optional assignment nil checks:<br></p><p>	if let value = array[ifExists: 0] {}<br>	// vs<br>	do { let value = try array[ifExists: 0] } catch {}<br>	<br>	if (array[ifExists: 0]? = 4) != nil {}<br>	// vs<br>	do { try array[ifExists: 0] = 4 } catch {}<br>	<br>	if let value = array[ifExists: 1] where (array[ifExists: 0]? = value) != nil {}<br>	// vs<br>	do { try array[ifExists: 0] = try array[ifExists: 1] } catch {}<br></p><p>Although I’m generally +1 for adding throwing subscripts but using them in this case doesn’t seem to be that useful.<br></p><p>- Maximilian<br></p><p>&gt; Am 07.02.2016 um 00:19 schrieb davesweeris at mac.com:<br>&gt; <br>&gt; Ah, ok, I think I understand your objection now. Let me try to summarize…<br>&gt; <br>&gt; If we extend on MutableCollectionType like this:<br>&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;     set { if let nv = newValue where self.indices.contains(idx) { self[idx] = nv } }<br>&gt; }<br>&gt; then, when CollectionType.Generator.Element is NilLiteralConvertible, we have the following problem:<br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil // *PROBLEM*: The most straight-forward way of safely setting something to nil silently fails because the compiler treats this as an Int?? instead of an Int?<br>&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt; array[ifExists: 0] = array[ifExists: 1] // *No problem*<br>&gt; print(array) // &quot;[Optional(1)]&quot;<br>&gt; array[ifExists: 0] = nil as Int? // *No problem*<br>&gt; print(array) // &quot;[nil]&quot;<br>&gt; <br>&gt; But if we fix it to allow an unannotated nil to go through:<br>&gt; subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>&gt;     get { return self.indices.contains(idx) ? self[idx] : nil as Self.Generator.Element? }<br>&gt;     set {<br>&gt;         if self.indices.contains(idx) {<br>&gt;             if let nv = newValue {<br>&gt;                 self[idx] = nv<br>&gt;             } else {<br>&gt;                 if let nilType = self[idx] as? NilLiteralConvertible {<br>&gt;                     self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; then we have a different problem:<br>&gt; var array: [Int?] = [1, 2, 3]<br>&gt; array[ifExists: 0] = nil // *No problem*: The code no longer cares that this is an Int?? instead of an Int?<br>&gt; print(array) // &quot;[nil, Optional(2), Optional(3)]&quot;<br>&gt; array[ifExists: 1] = array[ifExists: 3] // *PROBLEM*: This shouldn’t do anything, but it succeeds because the code no longer cares that it’s an Int?? instead of an Int?<br>&gt; print(array) // &quot;[nil, nil, Optional(3)]&quot;<br>&gt; array[ifExists: 2] = nil as Int? // *No problem*<br>&gt; print(array) // &quot;[nil, nil, nil]&quot;<br>&gt; <br>&gt; Assuming we’re all on the same page now… Yeah, as much as I’d love to keep the array[ifExists: 0] = nil behavior from the “fixed” version, I agree that the 2nd problem is clearly worse than the 1st, especially since being explicit about your nils (array[ifExists: 0] = nil as Int?) allows the assignment to go through.<br>&gt; <br>&gt; So I’m in favor of the 1st one, which doesn’t allow unannotated nil assignments to succeed.<br>&gt; <br>&gt; The only alternative I can think of is changing the language to allow subscripts to throw errors:<br>&gt; enum IndexError : ErrorType { case outOfRange }<br>&gt; subscript(throwing idx: Self.Index) throws -&gt; Self.Generator.Element {<br>&gt;     get {<br>&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;         return self[idx]<br>&gt;     }<br>&gt;     set {<br>&gt;         guard self.indices.contains(idx) else { throw IndexError.outOfRange }<br>&gt;         self[idx] = newValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Although… They aren’t mutually exclusive… It’s obviously not hard to imagine scenarios in which you don’t really care that you&#39;re out of bounds and just want to avoid crashing (otherwise we wouldn’t have been having this conversation in the first place) but nor is it hard to imagine scenarios in which you might want explicit confirmation that there wasn’t an error, rather than having to check for nil or compare before &amp; after versions of the array. In those cases the throwing version would be appropriate. Plus, if your subscript function doesn’t only pass-through to an underlying collection, it might be handy to be able to throw, say, an OutOfMemory error if your subscript function loads or generates some large data structure. Or perhaps you’re writing a file manager, and you’re trying to get files by “subscripting” directories… The file may exist, but you might not have read permission.<br>&gt; <br>&gt; Should we propose both?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 6, 2016, at 12:52, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Probably I wasn&#39;t clear about that. Sorry.<br>&gt;&gt; <br>&gt;&gt; My concern was about adding (code from Dave Sweeris):<br>&gt;&gt; <br>&gt;&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Since it would allow this:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // sets array[0] to nil if index is valid<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; array = [1]<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt; print(array) // &quot;[nil]&quot;<br>&gt;&gt; <br>&gt;&gt; Whereas the normal behavior:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil // does nothing<br>&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt; array[ifExists: 0] = array[ifExists: 1] // does nothing<br>&gt;&gt; print(array) // &quot;[1]&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Hope this clarifies my point<br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 06.02.2016 um 21:31 schrieb Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 06.02.2016 um 00:58 schrieb Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You are totally right. The return type is &quot;Int??&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My point was that if we allowed something like this (as suggested by Dave Sweeris I think):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         var array: [Int?] = [1]<br>&gt;&gt;&gt;&gt;         array[ifExists: 0] = nil<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To set the element at index 0 to nil instead of doing nothing.<br>&gt;&gt;&gt;&gt; The next example would also set index 0 to nil even though the getter failed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;          array[ifExists: 0] = array[ifExists: 1]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, it doesn&#39;t. Just try it out.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 05.02.2016 um 10:20 schrieb Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 4 Feb 2016, at 20:24, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I just realized that the normal setter for failable lookups is very nice in case of assigning/swapping:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Array {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     subscript(ifExists idx: Index) -&gt; Element? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;         // array[index1] is only set if both indexes are valid<br>&gt;&gt;&gt;&gt;&gt;&gt;         array[ifExists: index1] = array[ifExists: index2] <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; if array is of type [Int?] and the special setter for optional Elements would have been added:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; array[index1] would be set to &quot;nil&quot; if array[index2] is nil or index2 is not valid which is unfortunate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wouldn’t the return type be Int?? in this case? It’s not as pretty to test for as a plain Int? but iirc you can still distinguish a return type of nil from an optional that happens to contain nil, which should allow you to tell the difference between a nil value and an invalid index, I just can’t recall how at the moment (as I design around cases like these like my life depends on it ;)<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/e8b4c601/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>Ok, if the subscript label on the second one isn’t the same as the first one, it works. I’m still not sure why what I wrote earlier today was ambiguous, but this seems to work:<br>extension Array {<br>    subscript(failableLookup idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>    }<br>}<br>extension Array where Element: NilLiteralConvertible {<br>    subscript(nilConvertible idx: Index) -&gt; Element? {<br>        get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>        set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>    }<br>}<br></p><p>Seems kinda “hacky”, though, to need the 2nd set argument labels.<br></p><p>Anyway, I hope this helps.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 00:53, Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Maximilian,<br>&gt; <br>&gt; ah, I see. This is a show stopper then!<br>&gt; <br>&gt; From what I imagine, this should not type-check:<br>&gt; <br>&gt; var array = [1]<br>&gt; array[ifExists: 0] = nil<br>&gt; <br>&gt; … and this should set array[0] to nil:<br>&gt; <br>&gt; var array: [Int?] = [1]<br>&gt; array[ifExists: 0] = nil<br>&gt; <br>&gt; Is it not possible to implement such setter in Swift?<br>&gt; <br>&gt; R+<br>&gt; <br>&gt;&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The setter of the subscript should be:<br>&gt;&gt; <br>&gt;&gt; set {<br>&gt;&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;         self[index] = newValue!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;&gt; <br>&gt;&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt;&gt; <br>&gt;&gt; The setter is weird because you can use an optional element:<br>&gt;&gt; <br>&gt;&gt; var arr = [1]<br>&gt;&gt; // is valid but doesn&#39;t set the first element<br>&gt;&gt; arr[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; var arr2: [Int?] = [1]<br>&gt;&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt;&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; All right, I put together a proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md &lt;https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; … and opened a PR:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/133 &lt;https://github.com/apple/swift-evolution/pull/133&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s see how this goes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; R+<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/6353e6a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Optional safe subscripting for arrays</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  5, 2016 at 10:00:00pm</p></header><div class="content"><p>I went back to look at this some more today, and figured it out how to do it (at least in an Xcode 7.3 beta (7D111g) playground) with only one set of argument labels:<br>extension MutableCollectionType {<br>    subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>        get {return self.indices.contains(idx) ? self[idx] : nil}<br>        set {<br>            if self.indices.contains(idx) {<br>                if let nv = newValue {<br>                    self[idx] = nv<br>                } else if let nilType = self[idx] as? NilLiteralConvertible {<br>                    self[idx] = (nilType.dynamicType.init(nilLiteral: ()) as! Self.Generator.Element)<br>                }<br>            }<br>        }<br>    }<br>}<br>extension CollectionType {<br>    subscript(ifExists idx: Self.Index) -&gt; Self.Generator.Element? {<br>        return self.indices.contains(idx) ? self[idx] : nil<br>    }<br>}<br></p><p>And then to test it:<br>struct Foo : NilLiteralConvertible, CustomStringConvertible, IntegerLiteralConvertible {<br>    var value: Int<br>    init(nilLiteral: ()) {value = Int()}<br>    init(integerLiteral value: IntegerLiteralType) { self.value = value }<br>    var description: String { return &quot;\(value)&quot; }<br>}<br>var foo: [Int] = [0,1,2,3]<br>foo[ifExists: 3] = nil // This *should* be a compiler error, but it isn&#39;t because Swift doesn&#39;t support getters returning T? and setters takeing T (perhaps there ought to be a proposal about this). In the meantime, this doesn&#39;t do anything because you can&#39;t assign a nil to an Int.<br>print(foo) // prints [0, 1, 2, 3]<br>foo[ifExists: 3] = 4<br>print(foo) // prints [0, 1, 2, 4]<br></p><p>var bar: [Int?] = [0,1,2,3]<br>bar[ifExists: 3] = nil as Int?? // Again, this *should* be a compiler error… but isn’t (for the same reason as before)<br>print(bar) // prints [Optional(0), Optional(1), Optional(2), nil]<br>bar[ifExists: 2] = nil // Here, the compiler (eroneously, IMHO) treats this as Optional&lt;Optional&lt;Int&gt;&gt;.None, rather than as Optional&lt;Optional&lt;Int&gt;&gt;.Some(Optional&lt;Int&gt;.None), thus leading to all the trickeries needed to get the nil assignment to go through<br>print(bar) // prints [Optional(0), Optional(1), nil, nil]<br>bar[ifExists: 1] = nil as Int?  // Wouldn’t ever be an error, since Element == Int?<br>print(bar) // prints [Optional(0), nil, nil, nil]<br></p><p>var bof: [Foo] = [0,1,2,3]<br>bof[ifExists: 3] = nil // Sets bof[3] to nil, which results in bof[3] = Foo(nilLiteral: ())<br>print(bof) // prints [0, 1, 2, 0]<br></p><p>(FWIW, I think “failableIndex” or “failableLookup” is a little clearer than “ifExists”, but it’s not keeping me up at night or anything.)<br></p><p>Anyway, does this address everyone’s concerns, at least within what the language allows?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 15:10, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, if the subscript label on the second one isn’t the same as the first one, it works. I’m still not sure why what I wrote earlier today was ambiguous, but this seems to work:<br>&gt; extension Array {<br>&gt;     subscript(failableLookup idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx &amp;&amp; newValue != nil { self[idx] = newValue! } }<br>&gt;     }<br>&gt; }<br>&gt; extension Array where Element: NilLiteralConvertible {<br>&gt;     subscript(nilConvertible idx: Index) -&gt; Element? {<br>&gt;         get { return (startIndex ..&lt; endIndex) ~= idx ? self[idx] : nil }<br>&gt;         set { if (startIndex ..&lt; endIndex) ~= idx { self[idx] = newValue ?? Element(nilLiteral: ())} }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Seems kinda “hacky”, though, to need the 2nd set argument labels.<br>&gt; <br>&gt; Anyway, I hope this helps.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 00:53, Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Maximilian,<br>&gt;&gt; <br>&gt;&gt; ah, I see. This is a show stopper then!<br>&gt;&gt; <br>&gt;&gt; From what I imagine, this should not type-check:<br>&gt;&gt; <br>&gt;&gt; var array = [1]<br>&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; … and this should set array[0] to nil:<br>&gt;&gt; <br>&gt;&gt; var array: [Int?] = [1]<br>&gt;&gt; array[ifExists: 0] = nil<br>&gt;&gt; <br>&gt;&gt; Is it not possible to implement such setter in Swift?<br>&gt;&gt; <br>&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt;&gt; On 1 Feb 2016, at 00:07, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The setter of the subscript should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; set {<br>&gt;&gt;&gt;     if self.indices ~= index &amp;&amp; newValue != nil {<br>&gt;&gt;&gt;         self[index] = newValue!<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since &quot;newValue&quot; is of type &quot;Element?&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems that this subscript could also be added to &quot;CollectionType&quot; and &quot;MutableCollectionType&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The setter is weird because you can use an optional element:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var arr = [1]<br>&gt;&gt;&gt; // is valid but doesn&#39;t set the first element<br>&gt;&gt;&gt; arr[ifExists: 0] = nil<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var arr2: [Int?] = [1]<br>&gt;&gt;&gt; arr2[ifExists: 0] = nil // changes nothing<br>&gt;&gt;&gt; arr2[ifExists: 0] = .Some(nil) // sets first element to nil : arr2 == [nil]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t know whether a setter should be added at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 31.01.2016 um 23:38 schrieb Rudolf Adamkovič via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All right, I put together a proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md &lt;https://github.com/salutis/swift-evolution/blob/master/proposals/XXXX-runtime-safe-array-subscripting.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; … and opened a PR:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/133 &lt;https://github.com/apple/swift-evolution/pull/133&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s see how this goes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; R+<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/6ec49b9c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
