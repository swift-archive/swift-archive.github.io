<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>January 27, 2016 at 09:00:00pm</p></header><div class="content"><p>To better support interfacing with lower level systems, like graphics<br>libraries for example, it would be helpful to support the concept of<br>contiguous variables. The most common use case for this would be to create<br>a Matrix struct that can be passed as data into something like Metal. This<br>can be accomplished now, using something like the following:<br></p><p>Current Option 1:<br></p><p>struct Matrix2x2 {<br>    var m00: Float<br>    var m01: Float<br>    var m10: Float<br>    var m11: Float<br>}<br></p><p>OR<br>Current Option 2:<br></p><p>struct Matrix2x2 {<br>    var m: (Float, Float, Float, Float)<br>}<br></p><p>OR<br>Current Option 3:<br></p><p>struct Matrix2x2 {<br>    var m: [Float]<br>}<br></p><p>Options 1 &amp; 2 allow for the compiler to enforce the fixed number of<br>elements and also for the data to be easily passed into graphics libraries<br>as their memory layout is somewhat predictable using sizeof, strideof, and<br>alignof. The downside is that you lose the ability to easily subscript or<br>iterate the elements.<br></p><p>Option 3 does allow subscripting and iteration, but does not at compile<br>time enforce a fixed number of elements and is not as easily passed into a<br>library that expects to receive the raw data of the matrix.<br></p><p><br>Contiguous Variables:<br></p><p>struct Matrix2x2 {<br>    var m: Float:2*2<br>}<br></p><p>The variable `m` represents a series of 4 contiguous Float values. The<br>specific number of values must be a compile time constant. The only needed<br>functionality includes `count`, `subscript`, and iteration. To make things<br>easier to implement and to help avoid confusion and more complex<br>documentation, multiple dimensions are not allowed. To define multiple<br>dimensions you must provide your own ordering by wrapping this type in<br>another type and providing a custom subscript implementation. For example:<br></p><p>struct RowMajorMatrix2x2 {<br>    var m: Float:2*2<br></p><p>    static let rows = 2<br>    static let columns = 2<br></p><p>    subscript(row: Int, column: Int) -&gt; Float {<br>        return m[column * Matrix2x2.rows + row]<br>    }<br>}<br></p><p>sizeof(Matrix2x2) is 16<br>strideof(Matrix2x2) is 16<br></p><p>m.count is essentially a compile time constant and is not stored with the<br>rest of the data but is available and can also be used to do runtime bounds<br>checking.<br></p><p>struct Vector3 {<br>    var v: Float:3<br>}<br></p><p>sizeof(Vector3) is 12<br>strideof(Vector3) is 12<br></p><p>C code should also now be able to expose data types that contain fixed<br>sized arrays within them.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/68cd3767/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>You could make either option 1 or 2 conform to SequenceType and provide<br>them in the library for common types like small vectors and small matrices.<br>That would probably cover a lot of use cases.<br></p><p>In the longer term there is a thread on Swift evolution for computable<br>types which would address this issue.<br></p><p>On Thursday, 28 January 2016, Justin Kolb via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To better support interfacing with lower level systems, like graphics<br>&gt; libraries for example, it would be helpful to support the concept of<br>&gt; contiguous variables. The most common use case for this would be to create<br>&gt; a Matrix struct that can be passed as data into something like Metal. This<br>&gt; can be accomplished now, using something like the following:<br>&gt;<br>&gt; Current Option 1:<br>&gt;<br>&gt; struct Matrix2x2 {<br>&gt;     var m00: Float<br>&gt;     var m01: Float<br>&gt;     var m10: Float<br>&gt;     var m11: Float<br>&gt; }<br>&gt;<br>&gt; OR<br>&gt; Current Option 2:<br>&gt;<br>&gt; struct Matrix2x2 {<br>&gt;     var m: (Float, Float, Float, Float)<br>&gt; }<br>&gt;<br>&gt; OR<br>&gt; Current Option 3:<br>&gt;<br>&gt; struct Matrix2x2 {<br>&gt;     var m: [Float]<br>&gt; }<br>&gt;<br>&gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of<br>&gt; elements and also for the data to be easily passed into graphics libraries<br>&gt; as their memory layout is somewhat predictable using sizeof, strideof, and<br>&gt; alignof. The downside is that you lose the ability to easily subscript or<br>&gt; iterate the elements.<br>&gt;<br>&gt; Option 3 does allow subscripting and iteration, but does not at compile<br>&gt; time enforce a fixed number of elements and is not as easily passed into a<br>&gt; library that expects to receive the raw data of the matrix.<br>&gt;<br>&gt;<br>&gt; Contiguous Variables:<br>&gt;<br>&gt; struct Matrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt; }<br>&gt;<br>&gt; The variable `m` represents a series of 4 contiguous Float values. The<br>&gt; specific number of values must be a compile time constant. The only needed<br>&gt; functionality includes `count`, `subscript`, and iteration. To make things<br>&gt; easier to implement and to help avoid confusion and more complex<br>&gt; documentation, multiple dimensions are not allowed. To define multiple<br>&gt; dimensions you must provide your own ordering by wrapping this type in<br>&gt; another type and providing a custom subscript implementation. For example:<br>&gt;<br>&gt; struct RowMajorMatrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt;<br>&gt;     static let rows = 2<br>&gt;     static let columns = 2<br>&gt;<br>&gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;         return m[column * Matrix2x2.rows + row]<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; sizeof(Matrix2x2) is 16<br>&gt; strideof(Matrix2x2) is 16<br>&gt;<br>&gt; m.count is essentially a compile time constant and is not stored with the<br>&gt; rest of the data but is available and can also be used to do runtime bounds<br>&gt; checking.<br>&gt;<br>&gt; struct Vector3 {<br>&gt;     var v: Float:3<br>&gt; }<br>&gt;<br>&gt; sizeof(Vector3) is 12<br>&gt; strideof(Vector3) is 12<br>&gt;<br>&gt; C code should also now be able to expose data types that contain fixed<br>&gt; sized arrays within them.<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/758f76b9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt; <br>&gt; Current Option 1:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m00: Float<br>&gt;     var m01: Float<br>&gt;     var m10: Float<br>&gt;     var m11: Float<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 2:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: (Float, Float, Float, Float)<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 3:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: [Float]<br>&gt; }<br>&gt; <br>&gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt; <br>&gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br></p><p>+1 for fixed size arrays, like option 3, but instead of using Array&lt;T&gt; shorthand, using an explicit FixedArray&lt;T&gt; type.<br></p><p>Andy<br></p><p>&gt; Contiguous Variables:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt; }<br>&gt; <br>&gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt; <br>&gt; struct RowMajorMatrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt; <br>&gt;     static let rows = 2<br>&gt;     static let columns = 2<br>&gt; <br>&gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;         return m[column * Matrix2x2.rows + row]<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; sizeof(Matrix2x2) is 16<br>&gt; strideof(Matrix2x2) is 16<br>&gt; <br>&gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt; <br>&gt; struct Vector3 {<br>&gt;     var v: Float:3<br>&gt; }<br>&gt; <br>&gt; sizeof(Vector3) is 12<br>&gt; strideof(Vector3) is 12<br>&gt; <br>&gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br></p><p>- We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>- We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br></p><p>That would make the experience of working with imported C types a lot better.<br></p><p>-Joe<br></p><p>&gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt; <br>&gt; Current Option 1:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m00: Float<br>&gt;     var m01: Float<br>&gt;     var m10: Float<br>&gt;     var m11: Float<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 2:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: (Float, Float, Float, Float)<br>&gt; }<br>&gt; <br>&gt; OR<br>&gt; Current Option 3:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: [Float]<br>&gt; }<br>&gt; <br>&gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt; <br>&gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt; <br>&gt; <br>&gt; Contiguous Variables:<br>&gt; <br>&gt; struct Matrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt; }<br>&gt; <br>&gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt; <br>&gt; struct RowMajorMatrix2x2 {<br>&gt;     var m: Float:2*2<br>&gt; <br>&gt;     static let rows = 2<br>&gt;     static let columns = 2<br>&gt; <br>&gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;         return m[column * Matrix2x2.rows + row]<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; sizeof(Matrix2x2) is 16<br>&gt; strideof(Matrix2x2) is 16<br>&gt; <br>&gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt; <br>&gt; struct Vector3 {<br>&gt;     var v: Float:3<br>&gt; }<br>&gt; <br>&gt; sizeof(Vector3) is 12<br>&gt; strideof(Vector3) is 12<br>&gt; <br>&gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 4:20 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt; <br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br></p><p>+1 to these features.<br></p><p>&gt; <br>&gt; That would make the experience of working with imported C types a lot better.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt;&gt; <br>&gt;&gt; Current Option 1:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m00: Float<br>&gt;&gt;    var m01: Float<br>&gt;&gt;    var m10: Float<br>&gt;&gt;    var m11: Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; OR<br>&gt;&gt; Current Option 2:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: (Float, Float, Float, Float)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; OR<br>&gt;&gt; Current Option 3:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: [Float]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt;&gt; <br>&gt;&gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Contiguous Variables:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: Float:2*2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt;&gt; <br>&gt;&gt; struct RowMajorMatrix2x2 {<br>&gt;&gt;    var m: Float:2*2<br>&gt;&gt; <br>&gt;&gt;    static let rows = 2<br>&gt;&gt;    static let columns = 2<br>&gt;&gt; <br>&gt;&gt;    subscript(row: Int, column: Int) -&gt; Float {<br>&gt;&gt;        return m[column * Matrix2x2.rows + row]<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sizeof(Matrix2x2) is 16<br>&gt;&gt; strideof(Matrix2x2) is 16<br>&gt;&gt; <br>&gt;&gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt;&gt; <br>&gt;&gt; struct Vector3 {<br>&gt;&gt;    var v: Float:3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sizeof(Vector3) is 12<br>&gt;&gt; strideof(Vector3) is 12<br>&gt;&gt; <br>&gt;&gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 <br></p><p>-- E<br></p><p>&gt; On Jan 28, 2016, at 3:20 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt; <br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt; <br>&gt; That would make the experience of working with imported C types a lot better.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt;&gt; <br>&gt;&gt; Current Option 1:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m00: Float<br>&gt;&gt;    var m01: Float<br>&gt;&gt;    var m10: Float<br>&gt;&gt;    var m11: Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; OR<br>&gt;&gt; Current Option 2:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: (Float, Float, Float, Float)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; OR<br>&gt;&gt; Current Option 3:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: [Float]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt;&gt; <br>&gt;&gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Contiguous Variables:<br>&gt;&gt; <br>&gt;&gt; struct Matrix2x2 {<br>&gt;&gt;    var m: Float:2*2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt;&gt; <br>&gt;&gt; struct RowMajorMatrix2x2 {<br>&gt;&gt;    var m: Float:2*2<br>&gt;&gt; <br>&gt;&gt;    static let rows = 2<br>&gt;&gt;    static let columns = 2<br>&gt;&gt; <br>&gt;&gt;    subscript(row: Int, column: Int) -&gt; Float {<br>&gt;&gt;        return m[column * Matrix2x2.rows + row]<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sizeof(Matrix2x2) is 16<br>&gt;&gt; strideof(Matrix2x2) is 16<br>&gt;&gt; <br>&gt;&gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt;&gt; <br>&gt;&gt; struct Vector3 {<br>&gt;&gt;    var v: Float:3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sizeof(Vector3) is 12<br>&gt;&gt; strideof(Vector3) is 12<br>&gt;&gt; <br>&gt;&gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>I like this idea, but the syntax seems dangerously close to a call site for<br> &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it<br>is allowed).<br></p><p>Maybe we could take advantage of something which would be very invalid<br>under the current grammar, namely (n T) rather than (n * T):<br></p><p>    let values: (4 Int) = (1, 2, 3, 4)<br></p><p>Jacob<br></p><p>On Thu, Jan 28, 2016 at 2:20 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Rather than introduce a new kind of declaration, I think we could add a<br>&gt; few small features to tuples:<br>&gt;<br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n<br>&gt; elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the<br>&gt; common supertype of its elements.<br>&gt;<br>&gt; That would make the experience of working with imported C types a lot<br>&gt; better.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To better support interfacing with lower level systems, like graphics<br>&gt; libraries for example, it would be helpful to support the concept of<br>&gt; contiguous variables. The most common use case for this would be to create<br>&gt; a Matrix struct that can be passed as data into something like Metal. This<br>&gt; can be accomplished now, using something like the following:<br>&gt; &gt;<br>&gt; &gt; Current Option 1:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m00: Float<br>&gt; &gt;     var m01: Float<br>&gt; &gt;     var m10: Float<br>&gt; &gt;     var m11: Float<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 2:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 3:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: [Float]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of<br>&gt; elements and also for the data to be easily passed into graphics libraries<br>&gt; as their memory layout is somewhat predictable using sizeof, strideof, and<br>&gt; alignof. The downside is that you lose the ability to easily subscript or<br>&gt; iterate the elements.<br>&gt; &gt;<br>&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile<br>&gt; time enforce a fixed number of elements and is not as easily passed into a<br>&gt; library that expects to receive the raw data of the matrix.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Contiguous Variables:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The<br>&gt; specific number of values must be a compile time constant. The only needed<br>&gt; functionality includes `count`, `subscript`, and iteration. To make things<br>&gt; easier to implement and to help avoid confusion and more complex<br>&gt; documentation, multiple dimensions are not allowed. To define multiple<br>&gt; dimensions you must provide your own ordering by wrapping this type in<br>&gt; another type and providing a custom subscript implementation. For example:<br>&gt; &gt;<br>&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt;<br>&gt; &gt;     static let rows = 2<br>&gt; &gt;     static let columns = 2<br>&gt; &gt;<br>&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt; &gt; strideof(Matrix2x2) is 16<br>&gt; &gt;<br>&gt; &gt; m.count is essentially a compile time constant and is not stored with<br>&gt; the rest of the data but is available and can also be used to do runtime<br>&gt; bounds checking.<br>&gt; &gt;<br>&gt; &gt; struct Vector3 {<br>&gt; &gt;     var v: Float:3<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Vector3) is 12<br>&gt; &gt; strideof(Vector3) is 12<br>&gt; &gt;<br>&gt; &gt; C code should also now be able to expose data types that contain fixed<br>&gt; sized arrays within them.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/b1fb692a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt; <br>&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt; <br>&gt;     let values: (4 Int) = (1, 2, 3, 4)<br></p><p>Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 2:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt; <br>&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt; <br>&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br></p><p>Bare juxtaposition might be problematic if we ever do introduce type-level integer expressions, though.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>What is a &quot;type-level integer expression&quot;? The only thing I can think of is<br>allowing numeric parameters to generics, like &quot;Tuple&lt;4, Int&gt;&quot;, but I don&#39;t<br>think that&#39;s what you&#39;re talking about.<br></p><p>Jacob<br></p><p>On Thu, Jan 28, 2016 at 2:38 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 28, 2016, at 2:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like this idea, but the syntax seems dangerously close to a call site<br>&gt; for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised,<br>&gt; but it is allowed).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Maybe we could take advantage of something which would be very invalid<br>&gt; under the current grammar, namely (n T) rather than (n * T):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;<br>&gt; Bare juxtaposition might be problematic if we ever do introduce type-level<br>&gt; integer expressions, though.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ff299f64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 2:40 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; What is a &quot;type-level integer expression&quot;? The only thing I can think of is allowing numeric parameters to generics, like &quot;Tuple&lt;4, Int&gt;&quot;, but I don&#39;t think that&#39;s what you&#39;re talking about.<br></p><p>That&#39;s what I mean, yeah. If we allow integers as type parameters, you&#39;d conceivably want to use integer literals and expressions in this position too.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 28, 2016 at 2:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Jan 28, 2016, at 2:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt; <br>&gt; Bare juxtaposition might be problematic if we ever do introduce type-level integer expressions, though.<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/30bef0e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 28, 2016 at 05:00:00pm</p></header><div class="content"><p>I think that a (4 * Int) syntax or equivalent for uniform tuples and making them subscriptable would be very helpful when dealing with C APIs that export structures with arrays in them.<br></p><p>Félix<br></p><p>&gt; Le 28 janv. 2016 à 17:46:40, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 2:40 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What is a &quot;type-level integer expression&quot;? The only thing I can think of is allowing numeric parameters to generics, like &quot;Tuple&lt;4, Int&gt;&quot;, but I don&#39;t think that&#39;s what you&#39;re talking about.<br>&gt; <br>&gt; That&#39;s what I mean, yeah. If we allow integers as type parameters, you&#39;d conceivably want to use integer literals and expressions in this position too.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Thu, Jan 28, 2016 at 2:38 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 28, 2016, at 2:37 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; Bare juxtaposition might be problematic if we ever do introduce type-level integer expressions, though.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ba74b6e1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt; <br>&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt; <br>&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt; <br>&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br></p><p>How about:<br></p><p>	let values:Int[4] = (1,2,3,4)<br></p><p>While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br></p><p>	let values:(Int[4]) = (1,2,3,4)<br></p><p>Could work too? Just some alternatives anyway, as I like the idea.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/33ef7ac1/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2475 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/33ef7ac1/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>I don&#39;t like how similar-but-not-quite-the-same it is as the array declaration syntax. That would make it Int[4] for a fixed-size array and [Int] for an array of dynamic size.<br></p><p>I like that (4 x Int) is inside parentheses, which is code for &quot;tuple&quot; right now.<br></p><p>Related question: can you initialize a uniform tuple/contiguous variable with an array literal?<br></p><p>Félix<br></p><p>&gt; Le 28 janv. 2016 à 19:04:50, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt; <br>&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt; <br>&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt; <br>&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/8bb884ae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt; <br>&gt; How about:<br>&gt; <br>&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt; <br>&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt; <br>&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt; <br>&gt; Could work too? Just some alternatives anyway, as I like the idea.<br></p><p>This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br></p><p>-Joe<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/0f8de523/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I find <br></p><p>let values: (4 x Int) = (1, 2, 3, 4)<br></p><p>to be adequately cromulent. I believe this approach to be:<br></p><p>* Readable, even to someone unfamiliar with the syntax<br>* The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>* The type is preserved in-place<br>* It&#39;s compact, elegant, simple<br></p><p>-- E<br></p><p><br>&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt; <br>&gt;&gt; How about:<br>&gt;&gt; <br>&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt; <br>&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt; <br>&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt; <br>&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt; <br>&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/404cddd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 28, 2016 at 10:00:00pm</p></header><div class="content"><p>That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an<br>operator looks very odd to me, and it doesn&#39;t fit with the rest of the<br>language.<br></p><p>On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I find<br>&gt;<br>&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;<br>&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;<br>&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt; * The parens before the assignment suggest something to do with tuples,<br>&gt; and the numbers match the arity after the assignment<br>&gt; * The type is preserved in-place<br>&gt; * It&#39;s compact, elegant, simple<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I like this idea, but the syntax seems dangerously close to a call site<br>&gt; for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised,<br>&gt; but it is allowed).<br>&gt;<br>&gt; Maybe we could take advantage of something which would be very invalid<br>&gt; under the current grammar, namely (n T) rather than (n * T):<br>&gt;<br>&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;<br>&gt;<br>&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;<br>&gt;<br>&gt; How about:<br>&gt;<br>&gt; let values:Int[4] = (1,2,3,4)<br>&gt;<br>&gt; While it looks a bit like a subscript, it doesn’t make sense in a type<br>&gt; declaration at present, so could be a good way to define restrictions of<br>&gt; this type (we could even extend it to collections later). If the similarity<br>&gt; is too close then:<br>&gt;<br>&gt; let values:(Int[4]) = (1,2,3,4)<br>&gt;<br>&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;<br>&gt;<br>&gt; This kind of syntax doesn&#39;t compose well with other type productions. If<br>&gt; you parse Int[N][M] naively as (Int[N])[M], then you end up with an array<br>&gt; of M (array of N (Int)), which ends up subscripting in the opposite order,<br>&gt; array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple<br>&gt; array indices in a type declaration, so int [n][m] is really (int [m]) [n],<br>&gt; but this doesn&#39;t work well for Swift, which has other postfix type<br>&gt; productions—how would Int[N]?[M] parse? Choosing a prefix notation for<br>&gt; fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/f030fcc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br></p><p>I somewhat wish they would have been added in originally as it seems like it will be trickier to find a good form that isn’t already taken. I think it would probably be problematic for the parser to make use of `*` or `x`. Maybe after moving the count to the front of the declaration `:` would end up being different enough from other uses of `:` to make this work:<br></p><p>let values: (4:Int)<br></p><p><br>&gt; On Jan 28, 2016, at 9:04 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an operator looks very odd to me, and it doesn&#39;t fit with the rest of the language.<br>&gt; <br>&gt; On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I find <br>&gt; <br>&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt; <br>&gt; to be adequately cromulent. I believe this approach to be:<br>&gt; <br>&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt; * The type is preserved in-place<br>&gt; * It&#39;s compact, elegant, simple<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt; <br>&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/6346cfe0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Currently, arrays contained in C structures are exported as tuples to Swift. If tuples need magic to align like C arrays, that magic already exists. Operators can&#39;t appear inside a type, so I don&#39;t think that it would be a problem to reuse * there either.<br></p><p>Aesthetically speaking, I think that (N x Type) looks better than (N * Type), but I don&#39;t like that (0xBeef) is either a tuple of 0 Beef objects or a hex number, which would be a problem if Swift must allow integers a type parameters.<br></p><p>Félix<br></p><p>&gt; Le 28 janv. 2016 à 22:12:29, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br>&gt; <br>&gt; I somewhat wish they would have been added in originally as it seems like it will be trickier to find a good form that isn’t already taken. I think it would probably be problematic for the parser to make use of `*` or `x`. Maybe after moving the count to the front of the declaration `:` would end up being different enough from other uses of `:` to make this work:<br>&gt; <br>&gt; let values: (4:Int)<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:04 PM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an operator looks very odd to me, and it doesn&#39;t fit with the rest of the language.<br>&gt;&gt; <br>&gt;&gt; On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I find <br>&gt;&gt; <br>&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt; <br>&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt; * The type is preserved in-place<br>&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/199c051a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>What about (n of Type)?<br></p><p>Sent from my iPhone, please excuse brevity and errors<br></p><p>&gt; On Jan 28, 2016, at 7:32 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, arrays contained in C structures are exported as tuples to Swift. If tuples need magic to align like C arrays, that magic already exists. Operators can&#39;t appear inside a type, so I don&#39;t think that it would be a problem to reuse * there either.<br>&gt; <br>&gt; Aesthetically speaking, I think that (N x Type) looks better than (N * Type), but I don&#39;t like that (0xBeef) is either a tuple of 0 Beef objects or a hex number, which would be a problem if Swift must allow integers a type parameters.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 28 janv. 2016 à 22:12:29, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br>&gt;&gt; <br>&gt;&gt; I somewhat wish they would have been added in originally as it seems like it will be trickier to find a good form that isn’t already taken. I think it would probably be problematic for the parser to make use of `*` or `x`. Maybe after moving the count to the front of the declaration `:` would end up being different enough from other uses of `:` to make this work:<br>&gt;&gt; <br>&gt;&gt; let values: (4:Int)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:04 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an operator looks very odd to me, and it doesn&#39;t fit with the rest of the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I find <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a249f582/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a300fb6ff17dc07df9be5e863e0c98a?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Nate Birkholz</string> &lt;nbirkholz at gmail.com&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>What about &quot;(n of Type)&quot;?<br></p><p>Sent from my iPhone, please excuse brevity and errors<br></p><p>&gt; On Jan 28, 2016, at 7:32 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, arrays contained in C structures are exported as tuples to Swift. If tuples need magic to align like C arrays, that magic already exists. Operators can&#39;t appear inside a type, so I don&#39;t think that it would be a problem to reuse * there either.<br>&gt; <br>&gt; Aesthetically speaking, I think that (N x Type) looks better than (N * Type), but I don&#39;t like that (0xBeef) is either a tuple of 0 Beef objects or a hex number, which would be a problem if Swift must allow integers a type parameters.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 28 janv. 2016 à 22:12:29, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br>&gt;&gt; <br>&gt;&gt; I somewhat wish they would have been added in originally as it seems like it will be trickier to find a good form that isn’t already taken. I think it would probably be problematic for the parser to make use of `*` or `x`. Maybe after moving the count to the front of the declaration `:` would end up being different enough from other uses of `:` to make this work:<br>&gt;&gt; <br>&gt;&gt; let values: (4:Int)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:04 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an operator looks very odd to me, and it doesn&#39;t fit with the rest of the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I find <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/db4f4ce6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 for the proposal, and +1 for Nate&#39;s syntax.<br>&gt; On Jan 28, 2016, at 19:36, Nate Birkholz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What about &quot;(n of Type)&quot;?<br>&gt; <br>&gt; Sent from my iPhone, please excuse brevity and errors<br></p><p>That is currently true, but it might not always be the case. In principle it&#39;s possible to write a compile-time function (I think &quot;macro&quot; is the word I&#39;m looking for) that operates solely on types, rather than values, and could be evaluated at compile time. Why adopt a syntax that&#39;s likely to conflict with a commonly requested feature?<br>&gt;&gt; On Jan 28, 2016, at 7:32 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [...] Operators can&#39;t appear inside a type, so I don&#39;t think that it would be a problem to reuse * there either.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/571000a8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>That is good to hear as it should be easier to implement this feature then. I didn’t realize yet that C structs with arrays were imported like that, it helps me with the decision to settle with option 2 for now in the code I was planning to write.<br></p><p>I would expect that `0` would not be allowed for type declarations.<br></p><p><br>&gt; On Jan 28, 2016, at 9:32 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Currently, arrays contained in C structures are exported as tuples to Swift. If tuples need magic to align like C arrays, that magic already exists. Operators can&#39;t appear inside a type, so I don&#39;t think that it would be a problem to reuse * there either.<br>&gt; <br>&gt; Aesthetically speaking, I think that (N x Type) looks better than (N * Type), but I don&#39;t like that (0xBeef) is either a tuple of 0 Beef objects or a hex number, which would be a problem if Swift must allow integers a type parameters.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 28 janv. 2016 à 22:12:29, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br>&gt;&gt; <br>&gt;&gt; I somewhat wish they would have been added in originally as it seems like it will be trickier to find a good form that isn’t already taken. I think it would probably be problematic for the parser to make use of `*` or `x`. Maybe after moving the count to the front of the declaration `:` would end up being different enough from other uses of `:` to make this work:<br>&gt;&gt; <br>&gt;&gt; let values: (4:Int)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:04 PM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That looks great except that I would prefer (4 * Int). Having &quot;x&quot; as an operator looks very odd to me, and it doesn&#39;t fit with the rest of the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I find <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a8598a5d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 7:12 PM, Justin Kolb &lt;justin.kolb at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’m not sure I like the fact that they would be associated with tuples. As far as I’m aware tuples don’t have a public or well documented memory layout and most likely it would be better to keep them that way. To be compatible with C a fixed size array would have to have similar memory layout requirements. Also I assume there was a reason not to allow subscripting of tuples originally and adding it to something similar might confuse things. If any of these things are non-issues then I’m fine with them looking like tuples. I do think they will need to be able to be initialized with array like initializers in some form.<br></p><p>I don&#39;t think this is an issue. Practically speaking, there isn&#39;t anything we could do layout-wise for a homogeneous tuple in memory that would be better than a contiguous array.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I find <br>&gt; <br>&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt; <br>&gt; to be adequately cromulent. I believe this approach to be:<br>&gt; <br>&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt; * The type is preserved in-place<br>&gt; * It&#39;s compact, elegant, simple<br></p><p>+1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt; <br>&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/4c0a6c5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 7:57 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find <br>&gt;&gt; <br>&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt; <br>&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt; * The type is preserved in-place<br>&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt; <br>&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br></p><p>One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br></p><p>a) have no element labels.<br>b) all have the same element type.<br></p><p>This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/e852cacb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 8:00 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 28, 2016, at 7:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt; <br>&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt; <br>&gt; One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br>&gt; <br>&gt; a) have no element labels.<br>&gt; b) all have the same element type.<br>&gt; <br>&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br></p><p>I&#39;m not sure this prevents anything, since labeled tuples implicitly convert to unlabeled tuples, and tuples support structural subtyping, so (Derived, Derived) is-a (Base, Base) is-an (Any, Any). Both of those type rules might be worth reconsidering on their own, of course, but otherwise you could still backdoor your way into subscripting a heterogeneous and/or labeled tuple via those conversions.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/e151e8e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jan 28, 2016, at 9:25 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt;&gt; <br>&gt;&gt; One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br>&gt;&gt; <br>&gt;&gt; a) have no element labels.<br>&gt;&gt; b) all have the same element type.<br>&gt;&gt; <br>&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt; <br>&gt; I&#39;m not sure this prevents anything, since labeled tuples implicitly convert to unlabeled tuples, and tuples support structural subtyping, so (Derived, Derived) is-a (Base, Base) is-an (Any, Any). Both of those type rules might be worth reconsidering on their own, of course, but otherwise you could still backdoor your way into subscripting a heterogeneous and/or labeled tuple via those conversions.<br></p><p>Right, I’d much rather see:<br>	let v = (someHeterogenousTuple as (4 x Any))[i]<br>Rather than:<br>	let v = someHeterogenousTuple[i]<br></p><p>given that the subscripting syntax is intended to be an efficient “array index” operation.  I’m uncomfortable with an expensive representation-transforming operation that potentially involves heap allocation (when the tuple element is a struct larger than the Any existential rep) happening accidentally.<br></p><p>That said, perhaps there is a middle ground: we can use the same rules we use for array literals since array literals also don’t merge to Any as their common type.  I see no concerns with using the common type for a heterogenous tuple of classes that have a common base class, for example, because that won’t be a representation change.<br></p><p>That said, I don’t think this will be a very important use case, so I’d be happy with subsetting that out of the base proposal, and adding it when there is a specific motivation for it.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/74d24f0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 9:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 28, 2016, at 9:25 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) have no element labels.<br>&gt;&gt;&gt; b) all have the same element type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure this prevents anything, since labeled tuples implicitly convert to unlabeled tuples, and tuples support structural subtyping, so (Derived, Derived) is-a (Base, Base) is-an (Any, Any). Both of those type rules might be worth reconsidering on their own, of course, but otherwise you could still backdoor your way into subscripting a heterogeneous and/or labeled tuple via those conversions.<br>&gt; <br>&gt; Right, I’d much rather see:<br>&gt; 	let v = (someHeterogenousTuple as (4 x Any))[i]<br>&gt; Rather than:<br>&gt; 	let v = someHeterogenousTuple[i]<br>&gt; <br>&gt; given that the subscripting syntax is intended to be an efficient “array index” operation.  I’m uncomfortable with an expensive representation-transforming operation that potentially involves heap allocation (when the tuple element is a struct larger than the Any existential rep) happening accidentally.<br>&gt; <br>&gt; That said, perhaps there is a middle ground: we can use the same rules we use for array literals since array literals also don’t merge to Any as their common type.  I see no concerns with using the common type for a heterogenous tuple of classes that have a common base class, for example, because that won’t be a representation change.<br>&gt; <br>&gt; That said, I don’t think this will be a very important use case, so I’d be happy with subsetting that out of the base proposal, and adding it when there is a specific motivation for it.<br></p><p>Sure. What do you think about special-casing subscripting by integer literal? We could potentially supersede the &#39;x.0&#39; syntax with &#39;x[0]&#39;, giving an integer literal subscript the added power to produce the Nth value as the Nth concrete type of the tuple.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d576e910/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>On Jan 29, 2016, at 11:20 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; given that the subscripting syntax is intended to be an efficient “array index” operation.  I’m uncomfortable with an expensive representation-transforming operation that potentially involves heap allocation (when the tuple element is a struct larger than the Any existential rep) happening accidentally.<br>&gt;&gt; <br>&gt;&gt; That said, perhaps there is a middle ground: we can use the same rules we use for array literals since array literals also don’t merge to Any as their common type.  I see no concerns with using the common type for a heterogenous tuple of classes that have a common base class, for example, because that won’t be a representation change.<br>&gt;&gt; <br>&gt;&gt; That said, I don’t think this will be a very important use case, so I’d be happy with subsetting that out of the base proposal, and adding it when there is a specific motivation for it.<br>&gt; <br>&gt; Sure. What do you think about special-casing subscripting by integer literal? We could potentially supersede the &#39;x.0&#39; syntax with &#39;x[0]&#39;, giving an integer literal subscript the added power to produce the Nth value as the Nth concrete type of the tuple.<br></p><p>Personally, I wouldn’t be thrilled with that directly.  This would make tuple accesses more “array like” than “struct like”.  For heterogenous tuples, they are unquestionably more struct like.<br></p><p>I feel like adding the subscript only in the case of homogenous tuples nicely splits the different here, and it seems like it would fit better into the generics model (though I’m much less sure about that).<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 20:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 28, 2016, at 7:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt; <br>&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt; <br>&gt; One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br>&gt; <br>&gt; a) have no element labels.<br>&gt; b) all have the same element type.<br>&gt; <br>&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br></p><p>+1 from me, for &quot;principle of least surprise&quot; and &quot;principle of not making the type checker do extra work&quot;.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/651623a9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 20:00, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 7:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt; <br>&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt; <br>&gt; One other tweak worth considering: instead of subscript being defined on a tuple as returning a common type, a more modest proposal would be that subscript is defined on tuples that:<br>&gt; <br>&gt; a) have no element labels.<br>&gt; b) all have the same element type.<br>&gt; <br>&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt; <br>&gt; -Chris<br></p><p><br>(Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br></p><p>Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>let grohl = (0, “foo”, “fighters”, 0.0)<br></p><p>Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br>// compiler expands this to (grohl.0.hashValue, grohl.1.hashValue, grohl.2.hashValue, grohl.3.hashValue)<br>let thatsJustCrazyTalk = grohl.map {$0.hashValue} // no error because Int, String, and Double all have a hashValue property…<br></p><p>It seems to me that figuring out what’s legal for $0 wouldn’t be that hard… I mean, at the risk of publicizing my ignorance regarding the compiler’s internal workings, in my head, at least, the compiler maintains a set of valid functions/properties for each type, and $0’s set would literally just be the intersection of the sets associated with the types in the tuple.<br></p><p>Is it way more complicated than that? (One of these days I’m going to figure out how LLVM works so that I won’t have ask questions like that.)<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a7b7f1d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  9, 2016 at 12:00:00pm</p></header><div class="content"><p>On Feb 9, 2016, at 11:33 AM, davesweeris at mac.com wrote:<br>&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; <br>&gt; (Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br>&gt; <br>&gt; Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>&gt; let grohl = (0, “foo”, “fighters”, 0.0)<br>&gt; <br>&gt; Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br></p><p>Swift has no such intersection type.  The closes analogs we have are Any (or if you allow boxing, NSObject/NSValue).<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/39be6928/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 12:57, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Feb 9, 2016, at 11:33 AM, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; (Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br>&gt;&gt; <br>&gt;&gt; Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>&gt;&gt; let grohl = (0, “foo”, “fighters”, 0.0)<br>&gt;&gt; <br>&gt;&gt; Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br>&gt; <br>&gt; Swift has no such intersection type.  The closes analogs we have are Any (or if you allow boxing, NSObject/NSValue).<br></p><p>I know. My round-about point was that, if my assumption about how that part of the compiler works is correct, it wouldn’t be hard to add the functionality. At least from the point of view of how to check if the code is correct. Admittedly, I was only thinking in terms of how one would go about extending map() to tuples. I haven’t considered the implications of allowing the “intersection” to be assigned to a variable or returned from a function, or what the syntax could/should be for interacting with such a type outside of the closure passed to map().<br></p><p>If it isn’t out of scope or just a non-starter, I’d like to explore the idea here (or in a different thread). Seems like it could make tuples in general, and specifically generic tuples, a lot more powerful.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/6e88b50f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 13:52, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 12:57, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Feb 9, 2016, at 11:33 AM, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>&gt;&gt;&gt; let grohl = (0, “foo”, “fighters”, 0.0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br>&gt;&gt; <br>&gt;&gt; Swift has no such intersection type.  The closes analogs we have are Any (or if you allow boxing, NSObject/NSValue).<br>&gt; <br>&gt; I know. My round-about point was that, if my assumption about how that part of the compiler works is correct, it wouldn’t be hard to add the functionality. At least from the point of view of how to check if the code is correct. Admittedly, I was only thinking in terms of how one would go about extending map() to tuples. I haven’t considered the implications of allowing the “intersection” to be assigned to a variable or returned from a function, or what the syntax could/should be for interacting with such a type outside of the closure passed to map().<br>&gt; <br>&gt; If it isn’t out of scope or just a non-starter, I’d like to explore the idea here (or in a different thread). Seems like it could make tuples in general, and specifically generic tuples, a lot more powerful.<br></p><p>Types aren&#39;t just bags of operations, which means that taking the intersection of arbitrary types isn&#39;t meaningful. Similarly, generics aren&#39;t templates to be instantiated, meaning that there has to be a run-time representation of a &quot;value of intersection type&quot;.<br></p><p>The constructs that carries the right meaning in Swift are protocols, and in theory you could intersect the protocols of the various types. In practice, though, the current model doesn&#39;t have a good way to actually do this, since not all protocols can be used as types of values, and finding the protocol-intersection of N types is a needless amount of extra work for the compiler anyway.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/0c999a59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Feb 9, 2016, at 14:42, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 9, 2016, at 13:52, Dave via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 12:57, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Feb 9, 2016, at 11:33 AM, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>&gt;&gt;&gt;&gt; let grohl = (0, “foo”, “fighters”, 0.0)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift has no such intersection type.  The closes analogs we have are Any (or if you allow boxing, NSObject/NSValue).<br>&gt;&gt; <br>&gt;&gt; I know. My round-about point was that, if my assumption about how that part of the compiler works is correct, it wouldn’t be hard to add the functionality. At least from the point of view of how to check if the code is correct. Admittedly, I was only thinking in terms of how one would go about extending map() to tuples. I haven’t considered the implications of allowing the “intersection” to be assigned to a variable or returned from a function, or what the syntax could/should be for interacting with such a type outside of the closure passed to map().<br>&gt;&gt; <br>&gt;&gt; If it isn’t out of scope or just a non-starter, I’d like to explore the idea here (or in a different thread). Seems like it could make tuples in general, and specifically generic tuples, a lot more powerful.<br>&gt; <br>&gt; Types aren&#39;t just bags of operations, which means that taking the intersection of arbitrary types isn&#39;t meaningful. Similarly, generics aren&#39;t templates to be instantiated, meaning that there has to be a run-time representation of a &quot;value of intersection type&quot;.<br>&gt; <br>&gt; The constructs that carries the right meaning in Swift are protocols, and in theory you could intersect the protocols of the various types. In practice, though, the current model doesn&#39;t have a good way to actually do this, since not all protocols can be used as types of values, and finding the protocol-intersection of N types is a needless amount of extra work for the compiler anyway.<br>&gt; <br>&gt; Jordan<br>Ah, it’s a non-starter then… Or at the very least *much* more difficult than I’d thought. Thank you :-)<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/3b2c1c46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 10:00:00am</p></header><div class="content"><p>Ceylon has intersection and union types and uses the union type for tuples which is a better fit than the intersection type IMO.<br></p><p>How tuples work in Ceylon and how they are used to represent function parameter lists is explained in more detail here: http://ceylon-lang.org/blog/2013/01/21/abstracting-over-functions/<br></p><p>It&#39;s definitely worth a read as Ceylon makes tremendous use of union and intersection types IMO.<br></p><p>-Thorsten <br></p><p>&gt; Am 09.02.2016 um 23:47 schrieb Dave via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Feb 9, 2016, at 14:42, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 9, 2016, at 13:52, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 9, 2016, at 12:57, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Feb 9, 2016, at 11:33 AM, davesweeris at mac.com wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; This would solve the fixed size array use-case, be much easier to implement, and not have surprising performance issues promoting things to Any.  It is also consistent with the fact that we don’t infer the type of [Int(), Float()] to [Any].<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Sorry to go so far back… I started replying to this on probably the 29th and somehow forgot about it.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Out of curiosity, why would the subscript of non-homogeneous tuple have to return an &quot;Any”? If we declare this:<br>&gt;&gt;&gt;&gt;&gt; let grohl = (0, “foo”, “fighters”, 0.0)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why couldn’t subscript (and $0 in map, for that matter) return a type that’s the “intersection” of Int, String, and Double?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift has no such intersection type.  The closes analogs we have are Any (or if you allow boxing, NSObject/NSValue).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know. My round-about point was that, if my assumption about how that part of the compiler works is correct, it wouldn’t be hard to add the functionality. At least from the point of view of how to check if the code is correct. Admittedly, I was only thinking in terms of how one would go about extending map() to tuples. I haven’t considered the implications of allowing the “intersection” to be assigned to a variable or returned from a function, or what the syntax could/should be for interacting with such a type outside of the closure passed to map().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If it isn’t out of scope or just a non-starter, I’d like to explore the idea here (or in a different thread). Seems like it could make tuples in general, and specifically generic tuples, a lot more powerful.<br>&gt;&gt; <br>&gt;&gt; Types aren&#39;t just bags of operations, which means that taking the intersection of arbitrary types isn&#39;t meaningful. Similarly, generics aren&#39;t templates to be instantiated, meaning that there has to be a run-time representation of a &quot;value of intersection type&quot;.<br>&gt;&gt; <br>&gt;&gt; The constructs that carries the right meaning in Swift are protocols, and in theory you could intersect the protocols of the various types. In practice, though, the current model doesn&#39;t have a good way to actually do this, since not all protocols can be used as types of values, and finding the protocol-intersection of N types is a needless amount of extra work for the compiler anyway.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; Ah, it’s a non-starter then… Or at the very least *much* more difficult than I’d thought. Thank you :-)<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/1ce1d424/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>January 28, 2016 at 10:00:00pm</p></header><div class="content"><p>I will make an attempt at a first draft given what I’ve read in this thread. I’m a little fuzzy on how to proceed as the process document makes mention of using the template and getting refinements on the mailing list before making a PR with the proposal. I have been having trouble finding examples of that in prior threads. Should I post the initial markdown to the thread?<br></p><p>&gt; On Jan 28, 2016, at 9:57 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find <br>&gt;&gt; <br>&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt; <br>&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt; <br>&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt; * The type is preserved in-place<br>&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt; <br>&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/56f1e12c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p># Fixed Sized Arrays<br></p><p>* Proposal: TBD<br>* Author(s): [Swift Developer](https://github.com/swiftdev)<br>* Status: **Awaiting review**<br>* Review manager: TBD<br></p><p>## Introduction<br></p><p>To provide better support for C static arrays and to help implement low level memory concious data structures, it would be helpful to add a new syntax to define fixed sized arrays of a single type in Swift.<br></p><p>Swift-evolution thread: [Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007984.html)<br></p><p>## Motivation<br></p><p>While Swift does allow for arrays and tuples with repeating instances of the same type, both do not map well to low level structures like C static arrays. It would be beneficial to provide a type with a closer mapping the the semantics and capabilities of C static arrays to help with interfacing with low level libraries and hardware (like GPU rendering data). While this can be accomplished in Swift currently it is awkward. Also most languages have some form of fixed size array and it&#39;s lacking in Swift has become more and more noticeable.<br></p><p>## Proposed solution<br></p><p>It should be possible to take the current existing mapping from C static arrays to tuples and modify it slightly to help round out the feature. Changes to tuples would include a new syntax for defining fixed size arrays (shown below), adding subscripting to tuples, and providing a way to initialize this new form of tuple. To prevent confusion between standard tuples and fixed array tuples, only tuples that have no element labels and that have all the same element type would be allowed to be subscripted.<br></p><p>The syntax to declare a fixed size array would be as follows:<br></p><p>    var values: (4 x Int)<br>	<br>The declaration would be surrounded by parenthesis similar to an existing tuple type, but the size of the array would be given first followed by the type of the elements of the array. The declaration given here would specify four consecutive Int values similar to the tuple `(Int, Int, Int, Int)`.<br></p><p>Initializing the individual elements of a fixed array would be similar to initialzing an existing tuple:<br></p><p>    let values: (4 x Int) = (1, 2, 3, 4)<br></p><p>Initializing all the elements to a single value would be done similar to calling an initializer on a type:<br></p><p>    let values: (4 x Int)(repeatedValue: 0) // Is this possible?<br></p><p>Instead of accessing individual elements of a tuple using index numbers such as `value.0` and `value.1` fixed size arrays will be indexed similar to normal arrays using normal subscript syntax `values[0]`.<br></p><p>## Detailed design<br></p><p>TBD<br></p><p>## Impact on existing code<br></p><p>As this would be a change in how static arrays from C are imported into Swift, any existing code using that feature would break due to the change in how to access the elements of the array. Applications making use of static C arrays would need to be recompiled and migrated to use newer syntax. If the decision is make to allow for both forms of indexing then no code would break due to this change and authors could migrate their code as needed to the new syntax.<br></p><p>## Alternatives considered<br></p><p>Using tuples as they are implement now does provide access to C static arrays and to write data structures with memory layouts similar to C static arrays, but it is not a very elegant solution. If fixed arrays can be added to the language easily then it would be well worth it to improve Swift with the same functionality that is normally found in most system level languages.<br></p><p><br>&gt; On Jan 28, 2016, at 10:23 PM, Justin Kolb &lt;justin.kolb at gmail.com&gt; wrote:<br>&gt; <br>&gt; I will make an attempt at a first draft given what I’ve read in this thread. I’m a little fuzzy on how to proceed as the process document makes mention of using the template and getting refinements on the mailing list before making a PR with the proposal. I have been having trouble finding examples of that in prior threads. Should I post the initial markdown to the thread?<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt; <br>&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/bcf45397/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>I think that (4 x Int) needs to be syntax sugar for (Int, Int, Int, Int). Not having them the same would introduce awkward cases into the language.<br></p><p>Because of that, I also think that forcing people to use the subscript would have some awkward consequences. What if I have a func&lt;T, U&gt; that uses a (T, U) tuple and both T and U happen to be the same type?<br></p><p>So I think that tuples whose elements all have the same type should get a subscript but shouldn&#39;t lose direct field access. This would also avoid breaking existing code, and place the bounds check at compile-time instead of runtime. (The compiler will tell you if you try to access foo.4 on a (4 x Int) tuple, but it likely won&#39;t if you try to access foo[4]).<br></p><p>Félix<br></p><p>&gt; Le 29 janv. 2016 à 00:18:43, Justin Kolb &lt;justin.kolb at gmail.com&gt; a écrit :<br>&gt; <br>&gt; # Fixed Sized Arrays<br>&gt; <br>&gt; * Proposal: TBD<br>&gt; * Author(s): [Swift Developer](https://github.com/swiftdev &lt;https://github.com/swiftdev&gt;)<br>&gt; * Status: **Awaiting review**<br>&gt; * Review manager: TBD<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; To provide better support for C static arrays and to help implement low level memory concious data structures, it would be helpful to add a new syntax to define fixed sized arrays of a single type in Swift.<br>&gt; <br>&gt; Swift-evolution thread: [Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007984.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007984.html&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; While Swift does allow for arrays and tuples with repeating instances of the same type, both do not map well to low level structures like C static arrays. It would be beneficial to provide a type with a closer mapping the the semantics and capabilities of C static arrays to help with interfacing with low level libraries and hardware (like GPU rendering data). While this can be accomplished in Swift currently it is awkward. Also most languages have some form of fixed size array and it&#39;s lacking in Swift has become more and more noticeable.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; It should be possible to take the current existing mapping from C static arrays to tuples and modify it slightly to help round out the feature. Changes to tuples would include a new syntax for defining fixed size arrays (shown below), adding subscripting to tuples, and providing a way to initialize this new form of tuple. To prevent confusion between standard tuples and fixed array tuples, only tuples that have no element labels and that have all the same element type would be allowed to be subscripted.<br>&gt; <br>&gt; The syntax to declare a fixed size array would be as follows:<br>&gt; <br>&gt;     var values: (4 x Int)<br>&gt; 	<br>&gt; The declaration would be surrounded by parenthesis similar to an existing tuple type, but the size of the array would be given first followed by the type of the elements of the array. The declaration given here would specify four consecutive Int values similar to the tuple `(Int, Int, Int, Int)`.<br>&gt; <br>&gt; Initializing the individual elements of a fixed array would be similar to initialzing an existing tuple:<br>&gt; <br>&gt;     let values: (4 x Int) = (1, 2, 3, 4)<br>&gt; <br>&gt; Initializing all the elements to a single value would be done similar to calling an initializer on a type:<br>&gt; <br>&gt;     let values: (4 x Int)(repeatedValue: 0) // Is this possible?<br>&gt; <br>&gt; Instead of accessing individual elements of a tuple using index numbers such as `value.0` and `value.1` fixed size arrays will be indexed similar to normal arrays using normal subscript syntax `values[0]`.<br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; TBD<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; As this would be a change in how static arrays from C are imported into Swift, any existing code using that feature would break due to the change in how to access the elements of the array. Applications making use of static C arrays would need to be recompiled and migrated to use newer syntax. If the decision is make to allow for both forms of indexing then no code would break due to this change and authors could migrate their code as needed to the new syntax.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Using tuples as they are implement now does provide access to C static arrays and to write data structures with memory layouts similar to C static arrays, but it is not a very elegant solution. If fixed arrays can be added to the language easily then it would be well worth it to improve Swift with the same functionality that is normally found in most system level languages.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 10:23 PM, Justin Kolb &lt;justin.kolb at gmail.com &lt;mailto:justin.kolb at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I will make an attempt at a first draft given what I’ve read in this thread. I’m a little fuzzy on how to proceed as the process document makes mention of using the template and getting refinements on the mailing list before making a PR with the proposal. I have been having trouble finding examples of that in prior threads. Should I post the initial markdown to the thread?<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:57 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let values: (4 x Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to be adequately cromulent. I believe this approach to be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Readable, even to someone unfamiliar with the syntax<br>&gt;&gt;&gt;&gt; * The parens before the assignment suggest something to do with tuples, and the numbers match the arity after the assignment<br>&gt;&gt;&gt;&gt; * The type is preserved in-place<br>&gt;&gt;&gt;&gt; * It&#39;s compact, elegant, simple<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1.  I like this syntax too, and with Joe’s other proposed extensions, it would all fit together nicely.  Anyone interested in writing up a proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 5:56 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How about:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/fdc514a6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 9:41 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I think that (4 x Int) needs to be syntax sugar for (Int, Int, Int, Int). Not having them the same would introduce awkward cases into the language.<br></p><p>Agreed.  This means that:<br></p><p>   let values: (4 x Int)(repeatedValue: 0) // Is this possible?<br></p><p>will not be possible.<br></p><p><br>&gt; Because of that, I also think that forcing people to use the subscript would have some awkward consequences. What if I have a func&lt;T, U&gt; that uses a (T, U) tuple and both T and U happen to be the same type?<br></p><p>I don’t understand this concern.<br></p><p><br>&gt; So I think that tuples whose elements all have the same type should get a subscript but shouldn&#39;t lose direct field access. <br></p><p>Agreed.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Le 29 janv. 2016 à 00:50:52, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:41 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think that (4 x Int) needs to be syntax sugar for (Int, Int, Int, Int). Not having them the same would introduce awkward cases into the language.<br>&gt; <br>&gt; Agreed.  This means that:<br>&gt; <br>&gt;   let values: (4 x Int)(repeatedValue: 0) // Is this possible?<br>&gt; <br>&gt; will not be possible.<br></p><p>Why will it be possible to add a subscript but not an initializer?<br></p><p>&gt;&gt; Because of that, I also think that forcing people to use the subscript would have some awkward consequences. What if I have a func&lt;T, U&gt; that uses a (T, U) tuple and both T and U happen to be the same type?<br>&gt; <br>&gt; I don’t understand this concern.<br></p><p>If direct element access is disallowed on homogeneous tuples, to me, it would look like a bug that you can use direct element access on a (T, U) tuple from a generic function with &lt;T, U&gt; parameters, but not anywhere else. But regardless, we seem to agree that homogeneous tuples shouldn&#39;t lose direct member access.<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jan 29, 2016, at 10:00 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 29 janv. 2016 à 00:50:52, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:41 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that (4 x Int) needs to be syntax sugar for (Int, Int, Int, Int). Not having them the same would introduce awkward cases into the language.<br>&gt;&gt; <br>&gt;&gt; Agreed.  This means that:<br>&gt;&gt; <br>&gt;&gt;  let values: (4 x Int)(repeatedValue: 0) // Is this possible?<br>&gt;&gt; <br>&gt;&gt; will not be possible.<br>&gt; <br>&gt; Why will it be possible to add a subscript but not an initializer?<br>&gt; <br>&gt;&gt;&gt; Because of that, I also think that forcing people to use the subscript would have some awkward consequences. What if I have a func&lt;T, U&gt; that uses a (T, U) tuple and both T and U happen to be the same type?<br>&gt;&gt; <br>&gt;&gt; I don’t understand this concern.<br>&gt; <br>&gt; If direct element access is disallowed on homogeneous tuples, to me, it would look like a bug that you can use direct element access on a (T, U) tuple from a generic function with &lt;T, U&gt; parameters, but not anywhere else. But regardless, we seem to agree that homogeneous tuples shouldn&#39;t lose direct member access.<br>&gt; <br>&gt; Félix<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br></p><p>You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br></p><p>struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br></p><p>Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br></p><p>Austin<br></p><p>&gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt; <br>&gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt; <br>&gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>Is having fixed arrays with large numbers of elements (256, 1024, etc.)<br>going to cause issues with protocol conformance of tuples? I believe that<br>since the type system doesn&#39;t currently have type-level integers, tuple<br>protocol conformance is done via a hard-coded limit.<br></p><p>On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might<br>&gt; &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;<br>&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make<br>&gt; 256-member C array tuples less awful to work with.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic<br>&gt; parameters in the future is this what tuple shorthand syntax would still<br>&gt; look like (not rhetorical, actually asking)? It would be nice to<br>&gt; future-proof whatever design we come up with, to a reasonable extent.<br>&gt; &gt;<br>&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt; &gt;<br>&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/52830e60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>Tuples currently can’t conform to protocols, can they?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 29, 2016, at 11:14, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br>&gt; <br>&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt; <br>&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt; &gt;<br>&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt; &gt;<br>&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/60dbdca1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br></p><p>Tuples still don&#39;t really conform to protocols, we just provide overloads for the &lt;&gt;== operators for small tuples now. Proper language support for tuple protocol conformance ought to account for arbitrary variadic-ness.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt; <br>&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt; &gt;<br>&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt; &gt;<br>&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/1dd86b35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>So what if you have a struct containing a 100 element fixed-sized<br>array/tuple? To have that struct conform to Equatable, etc., would you have<br>to explicitly equate the elements?:<br></p><p>self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br></p><p>Given that large element fixed-sized arrays are common in C, this seems<br>like a huge burden.<br></p><p>On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;<br>&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.)<br>&gt; going to cause issues with protocol conformance of tuples? I believe that<br>&gt; since the type system doesn&#39;t currently have type-level integers, tuple<br>&gt; protocol conformance is done via a hard-coded limit.<br>&gt;<br>&gt;<br>&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads<br>&gt; for the &lt;&gt;== operators for small tuples now. Proper language support for<br>&gt; tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might<br>&gt;&gt; &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;<br>&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make<br>&gt;&gt; 256-member C array tuples less awful to work with.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic<br>&gt;&gt; parameters in the future is this what tuple shorthand syntax would still<br>&gt;&gt; look like (not rhetorical, actually asking)? It would be nice to<br>&gt;&gt; future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f64780ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either, so I don&#39;t think that it will bother a lot of people who need C interop. It is, however, unfortunate for people who want to use it as a first-class Swift construct.<br></p><p>Regarding the generalized `N x expr` syntax: if we allow it to appear in more places, should we be worried about the fact that x is also a common identifier?<br></p><p>Also regarding the `N x expr` syntax: how many times should it evaluate `expr`? Once, or N times?<br></p><p>There seems to be a consensus around allowing subscripts on uniform tuples, regardless of how you actually declare them. However, that part decidedly needs more discussion, so like Joe said earlier, maybe we should spin it off.<br></p><p>Félix<br></p><p>&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; So what if you have a struct containing a 100 element fixed-sized array/tuple? To have that struct conform to Equatable, etc., would you have to explicitly equate the elements?:<br>&gt; <br>&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt; <br>&gt; Given that large element fixed-sized arrays are common in C, this seems like a huge burden.<br>&gt; <br>&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br>&gt; <br>&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads for the &lt;&gt;== operators for small tuples now. Proper language support for tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt; <br>&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f828dfff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>While true for general arrays in C, you can use memcmp() to compare arrays<br>of primitive types, and that case is the main one for arrays with large<br>numbers of elements (char[], int[], etc.).<br></p><p>On Fri, Jan 29, 2016 at 3:46 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either,<br>&gt; so I don&#39;t think that it will bother a lot of people who need C interop. It<br>&gt; is, however, unfortunate for people who want to use it as a first-class<br>&gt; Swift construct.<br>&gt;<br>&gt; Regarding the generalized `N x expr` syntax: if we allow it to appear in<br>&gt; more places, should we be worried about the fact that x is also a common<br>&gt; identifier?<br>&gt;<br>&gt; Also regarding the `N x expr` syntax: how many times should it evaluate<br>&gt; `expr`? Once, or N times?<br>&gt;<br>&gt; There seems to be a consensus around allowing subscripts on uniform<br>&gt; tuples, regardless of how you actually declare them. However, that part<br>&gt; decidedly needs more discussion, so like Joe said earlier, maybe we should<br>&gt; spin it off.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; So what if you have a struct containing a 100 element fixed-sized<br>&gt; array/tuple? To have that struct conform to Equatable, etc., would you have<br>&gt; to explicitly equate the elements?:<br>&gt;<br>&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;<br>&gt; Given that large element fixed-sized arrays are common in C, this seems<br>&gt; like a huge burden.<br>&gt;<br>&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.)<br>&gt;&gt; going to cause issues with protocol conformance of tuples? I believe that<br>&gt;&gt; since the type system doesn&#39;t currently have type-level integers, tuple<br>&gt;&gt; protocol conformance is done via a hard-coded limit.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads<br>&gt;&gt; for the &lt;&gt;== operators for small tuples now. Proper language support for<br>&gt;&gt; tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might<br>&gt;&gt;&gt; &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make<br>&gt;&gt;&gt; 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic<br>&gt;&gt;&gt; parameters in the future is this what tuple shorthand syntax would still<br>&gt;&gt;&gt; look like (not rhetorical, actually asking)? It would be nice to<br>&gt;&gt;&gt; future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/d3eb1aff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:41 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While true for general arrays in C, you can use memcmp() to compare arrays of primitive types, and that case is the main one for arrays with large numbers of elements (char[], int[], etc.).<br></p><p>That’s not true in general in C, because some types have undefined padding - Float80 and Vec3f come to mind.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; On Fri, Jan 29, 2016 at 3:46 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either, so I don&#39;t think that it will bother a lot of people who need C interop. It is, however, unfortunate for people who want to use it as a first-class Swift construct.<br>&gt; <br>&gt; Regarding the generalized `N x expr` syntax: if we allow it to appear in more places, should we be worried about the fact that x is also a common identifier?<br>&gt; <br>&gt; Also regarding the `N x expr` syntax: how many times should it evaluate `expr`? Once, or N times?<br>&gt; <br>&gt; There seems to be a consensus around allowing subscripts on uniform tuples, regardless of how you actually declare them. However, that part decidedly needs more discussion, so like Joe said earlier, maybe we should spin it off.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; So what if you have a struct containing a 100 element fixed-sized array/tuple? To have that struct conform to Equatable, etc., would you have to explicitly equate the elements?:<br>&gt;&gt; <br>&gt;&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;&gt; <br>&gt;&gt; Given that large element fixed-sized arrays are common in C, this seems like a huge burden.<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br>&gt;&gt; <br>&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads for the &lt;&gt;== operators for small tuples now. Proper language support for tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/3e96262d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Correct. That&#39;s why I mentioned primitive types. I believe Float80 and<br>Vec3f are both structures.<br></p><p>On Fri, Jan 29, 2016 at 4:45 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 29, 2016, at 1:41 PM, Trent Nadeau via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; While true for general arrays in C, you can use memcmp() to compare arrays<br>&gt; of primitive types, and that case is the main one for arrays with large<br>&gt; numbers of elements (char[], int[], etc.).<br>&gt;<br>&gt;<br>&gt; That’s not true in general in C, because some types have undefined padding<br>&gt; - Float80 and Vec3f come to mind.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; On Fri, Jan 29, 2016 at 3:46 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either,<br>&gt;&gt; so I don&#39;t think that it will bother a lot of people who need C interop. It<br>&gt;&gt; is, however, unfortunate for people who want to use it as a first-class<br>&gt;&gt; Swift construct.<br>&gt;&gt;<br>&gt;&gt; Regarding the generalized `N x expr` syntax: if we allow it to appear in<br>&gt;&gt; more places, should we be worried about the fact that x is also a common<br>&gt;&gt; identifier?<br>&gt;&gt;<br>&gt;&gt; Also regarding the `N x expr` syntax: how many times should it evaluate<br>&gt;&gt; `expr`? Once, or N times?<br>&gt;&gt;<br>&gt;&gt; There seems to be a consensus around allowing subscripts on uniform<br>&gt;&gt; tuples, regardless of how you actually declare them. However, that part<br>&gt;&gt; decidedly needs more discussion, so like Joe said earlier, maybe we should<br>&gt;&gt; spin it off.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; So what if you have a struct containing a 100 element fixed-sized<br>&gt;&gt; array/tuple? To have that struct conform to Equatable, etc., would you have<br>&gt;&gt; to explicitly equate the elements?:<br>&gt;&gt;<br>&gt;&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;&gt;<br>&gt;&gt; Given that large element fixed-sized arrays are common in C, this seems<br>&gt;&gt; like a huge burden.<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.)<br>&gt;&gt;&gt; going to cause issues with protocol conformance of tuples? I believe that<br>&gt;&gt;&gt; since the type system doesn&#39;t currently have type-level integers, tuple<br>&gt;&gt;&gt; protocol conformance is done via a hard-coded limit.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide<br>&gt;&gt;&gt; overloads for the &lt;&gt;== operators for small tuples now. Proper language<br>&gt;&gt;&gt; support for tuple protocol conformance ought to account for arbitrary<br>&gt;&gt;&gt; variadic-ness.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might<br>&gt;&gt;&gt;&gt; &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make<br>&gt;&gt;&gt;&gt; 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic<br>&gt;&gt;&gt;&gt; parameters in the future is this what tuple shorthand syntax would still<br>&gt;&gt;&gt;&gt; look like (not rhetorical, actually asking)? It would be nice to<br>&gt;&gt;&gt;&gt; future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/e8c7956c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:47 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; Correct. That&#39;s why I mentioned primitive types. I believe Float80 and Vec3f are both structures.<br></p><p>They are structs in swift, but both primitives in C.  The former is “long double” and the later is:<br>http://clang.llvm.org/docs/LanguageExtensions.html#vectors-and-extended-vectors<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; On Fri, Jan 29, 2016 at 4:45 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 1:41 PM, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; While true for general arrays in C, you can use memcmp() to compare arrays of primitive types, and that case is the main one for arrays with large numbers of elements (char[], int[], etc.).<br>&gt; <br>&gt; That’s not true in general in C, because some types have undefined padding - Float80 and Vec3f come to mind.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 29, 2016 at 3:46 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either, so I don&#39;t think that it will bother a lot of people who need C interop. It is, however, unfortunate for people who want to use it as a first-class Swift construct.<br>&gt;&gt; <br>&gt;&gt; Regarding the generalized `N x expr` syntax: if we allow it to appear in more places, should we be worried about the fact that x is also a common identifier?<br>&gt;&gt; <br>&gt;&gt; Also regarding the `N x expr` syntax: how many times should it evaluate `expr`? Once, or N times?<br>&gt;&gt; <br>&gt;&gt; There seems to be a consensus around allowing subscripts on uniform tuples, regardless of how you actually declare them. However, that part decidedly needs more discussion, so like Joe said earlier, maybe we should spin it off.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what if you have a struct containing a 100 element fixed-sized array/tuple? To have that struct conform to Equatable, etc., would you have to explicitly equate the elements?:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that large element fixed-sized arrays are common in C, this seems like a huge burden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads for the &lt;&gt;== operators for small tuples now. Proper language support for tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/e200b9c2/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 30, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for the proposal. I think as well as subscript count would be useful.<br></p><p>-1 for N x Type syntax, I wouldn&#39;t like x to be tied up. Perhaps Type.N to<br>mimic the access tuple.0, tuple.1, etc.<br></p><p>On Saturday, 30 January 2016, Trent Nadeau via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; While true for general arrays in C, you can use memcmp() to compare arrays<br>&gt; of primitive types, and that case is the main one for arrays with large<br>&gt; numbers of elements (char[], int[], etc.).<br>&gt;<br>&gt; On Fri, Jan 29, 2016 at 3:46 PM, Félix Cloutier &lt;felixcca at yahoo.ca<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;felixcca at yahoo.ca&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Regarding ==: to be fair, C doesn&#39;t allow this kind of comparison either,<br>&gt;&gt; so I don&#39;t think that it will bother a lot of people who need C interop. It<br>&gt;&gt; is, however, unfortunate for people who want to use it as a first-class<br>&gt;&gt; Swift construct.<br>&gt;&gt;<br>&gt;&gt; Regarding the generalized `N x expr` syntax: if we allow it to appear in<br>&gt;&gt; more places, should we be worried about the fact that x is also a common<br>&gt;&gt; identifier?<br>&gt;&gt;<br>&gt;&gt; Also regarding the `N x expr` syntax: how many times should it evaluate<br>&gt;&gt; `expr`? Once, or N times?<br>&gt;&gt;<br>&gt;&gt; There seems to be a consensus around allowing subscripts on uniform<br>&gt;&gt; tuples, regardless of how you actually declare them. However, that part<br>&gt;&gt; decidedly needs more discussion, so like Joe said earlier, maybe we should<br>&gt;&gt; spin it off.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; So what if you have a struct containing a 100 element fixed-sized<br>&gt;&gt; array/tuple? To have that struct conform to Equatable, etc., would you have<br>&gt;&gt; to explicitly equate the elements?:<br>&gt;&gt;<br>&gt;&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;&gt;<br>&gt;&gt; Given that large element fixed-sized arrays are common in C, this seems<br>&gt;&gt; like a huge burden.<br>&gt;&gt;<br>&gt;&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jgroff at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;tanadeau at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.)<br>&gt;&gt;&gt; going to cause issues with protocol conformance of tuples? I believe that<br>&gt;&gt;&gt; since the type system doesn&#39;t currently have type-level integers, tuple<br>&gt;&gt;&gt; protocol conformance is done via a hard-coded limit.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide<br>&gt;&gt;&gt; overloads for the &lt;&gt;== operators for small tuples now. Proper language<br>&gt;&gt;&gt; support for tuple protocol conformance ought to account for arbitrary<br>&gt;&gt;&gt; variadic-ness.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might<br>&gt;&gt;&gt;&gt; &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make<br>&gt;&gt;&gt;&gt; 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;jgroff at apple.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic<br>&gt;&gt;&gt;&gt; parameters in the future is this what tuple shorthand syntax would still<br>&gt;&gt;&gt;&gt; look like (not rhetorical, actually asking)? It would be nice to<br>&gt;&gt;&gt;&gt; future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/b25fea82/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>January 30, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 12:46 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There seems to be a consensus around allowing subscripts on uniform tuples, regardless of how you actually declare them. However, that part decidedly needs more discussion, so like Joe said earlier, maybe we should spin it off.<br></p><p>+1 to separating the addition of tuple subscripts and the new declaration syntax into two separate proposals.<br></p><p>—CK<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 29 janv. 2016 à 14:24:17, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; So what if you have a struct containing a 100 element fixed-sized array/tuple? To have that struct conform to Equatable, etc., would you have to explicitly equate the elements?:<br>&gt;&gt; <br>&gt;&gt; self.data.0 == other.data.0 &amp;&amp; self.data.1 == other.data.1 &amp;&amp; ...<br>&gt;&gt; <br>&gt;&gt; Given that large element fixed-sized arrays are common in C, this seems like a huge burden.<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 29, 2016 at 2:17 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 11:14 AM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is having fixed arrays with large numbers of elements (256, 1024, etc.) going to cause issues with protocol conformance of tuples? I believe that since the type system doesn&#39;t currently have type-level integers, tuple protocol conformance is done via a hard-coded limit.<br>&gt;&gt; <br>&gt;&gt; Tuples still don&#39;t really conform to protocols, we just provide overloads for the &lt;&gt;== operators for small tuples now. Proper language support for tuple protocol conformance ought to account for arbitrary variadic-ness.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jan 29, 2016 at 1:30 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; That makes sense, thanks. I&#39;m wondering if the N x T syntax might &#39;naturally fall out&#39; of such a system for any other use cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daydreaming aside, I think this is a great proposal and it&#39;ll make 256-member C array tuples less awful to work with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 29, 2016, at 10:29 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jan 29, 2016, at 10:22 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I like the (Count x Type) design, but if Swift got integer generic parameters in the future is this what tuple shorthand syntax would still look like (not rhetorical, actually asking)? It would be nice to future-proof whatever design we come up with, to a reasonable extent.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; You&#39;d still need something to define FixedArray&lt;N&gt; in terms of:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct FixedArray&lt;T,N: Int&gt; { var values: (N x T) }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/82d0e327/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34ed1c635ed60d43e26456cd47f07028?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Justin Kolb</string> &lt;justin.kolb at gmail.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>It seems that while similar to tuples, fixed sized arrays are definitely not a tuple.<br></p><p>1.) There would be a need for two forms of tuple indexing, most likely leading to confusion and complexity.<br>2.) When a new user wants a fixed size array they aren’t looking for special casing of a tuple, they are going to look in the arrays documentation and not find what they are looking for.<br>3.) Tuples are generally compile time checked, arrays are usually not.<br>4.) The count of a tuple isn’t a very useful operation, but on an array it is essential.<br>5.) The memory layout of a tuple should prefer to be ambiguous (even if it is essentially the same as a fixed array) while a fixed array has a very specific and relied upon memory layout in order to make it useful in low level scenarios.<br></p><p>While researching this I came across the syntax that Rust uses for its fixed size arrays which in Swift would be:<br></p><p>var a: [Int; n] // Where n is a compile time constant<br></p><p>While this is very similar to the existing array syntax I think it is different and straight forward enough that people expecting a dynamic array would use [Int] and a fixed array to be [Int; n], and would allow them to be discussed with each other in the documentation without having to explain why a fixed array would be so vastly different as it would be in the instance it was considered a special case tuple.<br></p><p>I think we have fallen into a trap where it seems like it would be easy to modify tuples to act liked fixed arrays since they somewhat do already. Applying the principle of least surprise I think this is a mistake, when someone wants an array, they want an array. Despite any extra difficulty (that’s not obviously insurmountable) I think it would be beneficial to keep arrays and tuples separate and distinct from each other.<br></p><p>There is still the potential point of confusion that [Int; n] is a low level construct (most likely not allowing user defined methods) while [Int] is syntax sugar for Array&lt;Int&gt;, but I think overall it is still a better trade off and less surprising. It also seems like grammar problems might be lessened when dealing with [] instead of () which is used in more cases.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  2, 2016 at 11:00:00pm</p></header><div class="content"><p>Why does n have to be a compile-time constant? Seems like any integer value &gt;= 0 would be ok.<br></p><p>- Dave Sweeris<br></p><p>Sent from my iPhone<br>&gt; On Feb 2, 2016, at 20:10, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that while similar to tuples, fixed sized arrays are definitely not a tuple.<br>&gt; <br>&gt; 1.) There would be a need for two forms of tuple indexing, most likely leading to confusion and complexity.<br>&gt; 2.) When a new user wants a fixed size array they aren’t looking for special casing of a tuple, they are going to look in the arrays documentation and not find what they are looking for.<br>&gt; 3.) Tuples are generally compile time checked, arrays are usually not.<br>&gt; 4.) The count of a tuple isn’t a very useful operation, but on an array it is essential.<br>&gt; 5.) The memory layout of a tuple should prefer to be ambiguous (even if it is essentially the same as a fixed array) while a fixed array has a very specific and relied upon memory layout in order to make it useful in low level scenarios.<br>&gt; <br>&gt; While researching this I came across the syntax that Rust uses for its fixed size arrays which in Swift would be:<br>&gt; <br>&gt; var a: [Int; n] // Where n is a compile time constant<br>&gt; <br>&gt; While this is very similar to the existing array syntax I think it is different and straight forward enough that people expecting a dynamic array would use [Int] and a fixed array to be [Int; n], and would allow them to be discussed with each other in the documentation without having to explain why a fixed array would be so vastly different as it would be in the instance it was considered a special case tuple.<br>&gt; <br>&gt; I think we have fallen into a trap where it seems like it would be easy to modify tuples to act liked fixed arrays since they somewhat do already. Applying the principle of least surprise I think this is a mistake, when someone wants an array, they want an array. Despite any extra difficulty (that’s not obviously insurmountable) I think it would be beneficial to keep arrays and tuples separate and distinct from each other.<br>&gt; <br>&gt; There is still the potential point of confusion that [Int; n] is a low level construct (most likely not allowing user defined methods) while [Int] is syntax sugar for Array&lt;Int&gt;, but I think overall it is still a better trade off and less surprising. It also seems like grammar problems might be lessened when dealing with [] instead of () which is used in more cases.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Why does n have to be a compile-time constant? Seems like any integer value &gt;= 0 would be ok.<br>If n is a variable whose value is determined at runtime, the compiler can&#39;t enforce type safety. It is no problem to declare structures of fixed size in Swift, so there is no need for a special syntax unless it has benefits (like improved safety).<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>&gt; On 3 Feb 2016, at 05:10, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems that while similar to tuples, fixed sized arrays are definitely not a tuple.<br></p><p>I sort of disagree, but in my mind (and coming from a C++ background) (compile-time) fixed-size arrays could be regarded as a specific subset of tuples, namely the ones where all elements have the same type.<br>If we had the capability to have the subscript-operator / indexing return different types depending on the argument (which then would have to be known at compile-time), this would fall in place pretty nicely.<br></p><p>That said, the ability to index the type with value only known at run-time (and something like a .data() contiguous buffer view) would be a refinement only available on the fixed-size array variant.<br></p><p>Either way, I’m not sure whether it’s better to model this as separate types (e.g. std::tuple vs std::array) or not, but I am convinced that the way tuple is used now for mapping fixed-size arrays from C-headers should be improved, especially with some functionality of tuples (e.g. comparison, ordering IIRC?) being restricted to low arities.<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  3, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; I sort of disagree, but in my mind (and coming from a C++ background) (compile-time) fixed-size arrays could be regarded as a specific subset of tuples, namely the ones where all elements have the same type.<br>&gt; If we had the capability to have the subscript-operator / indexing return different types depending on the argument (which then would have to be known at compile-time), this would fall in place pretty nicely.<br></p><p>A proposal along these lines appears to already be in the works. However, tuple arrays still aren&#39;t quite first-class types—you can&#39;t even loop over them. Nor does that address other cases like ring buffers with a generic size.<br></p><p>Tuple arrays are a great way to get some extra mileage out of an existing feature, but they&#39;re not a 100% solution.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 9:41 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I think that (4 x Int) needs to be syntax sugar for (Int, Int, Int, Int). Not having them the same would introduce awkward cases into the language.<br></p><p>Yes, they should be different spellings of the same type.<br>&gt; <br>&gt; Because of that, I also think that forcing people to use the subscript would have some awkward consequences. What if I have a func&lt;T, U&gt; that uses a (T, U) tuple and both T and U happen to be the same type?<br></p><p>Statically we have to assume that&#39;s a heterogenous tuple. Indexing would either produce Any or be disallowed, depending on the design.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 28 janv. 2016 à 19:56, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 4:04 PM, Haravikk &lt;e-mail at haravikk.me &lt;mailto:e-mail at haravikk.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Jan 2016, at 22:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 28, 2016, at 2:36 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this idea, but the syntax seems dangerously close to a call site for  &quot;func *(lhs: Int, rhs: Any.Type)&quot;  (which is obviously ill-advised, but it is allowed).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe we could take advantage of something which would be very invalid under the current grammar, namely (n T) rather than (n * T):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    let values: (4 Int) = (1, 2, 3, 4)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, or we could lift (4 x Int) from LLVM IR&#39;s syntax.<br>&gt;&gt; <br>&gt;&gt; How about:<br>&gt;&gt; <br>&gt;&gt; 	let values:Int[4] = (1,2,3,4)<br>&gt;&gt; <br>&gt;&gt; While it looks a bit like a subscript, it doesn’t make sense in a type declaration at present, so could be a good way to define restrictions of this type (we could even extend it to collections later). If the similarity is too close then:<br>&gt;&gt; <br>&gt;&gt; 	let values:(Int[4]) = (1,2,3,4)<br>&gt;&gt; <br>&gt;&gt; Could work too? Just some alternatives anyway, as I like the idea.<br>&gt; <br>&gt; This kind of syntax doesn&#39;t compose well with other type productions. If you parse Int[N][M] naively as (Int[N])[M], then you end up with an array of M (array of N (Int)), which ends up subscripting in the opposite order, array[0..&lt;M][0..&lt;N]. C works around this by flipping the order of multiple array indices in a type declaration, so int [n][m] is really (int [m]) [n], but this doesn&#39;t work well for Swift, which has other postfix type productions—how would Int[N]?[M] parse? Choosing a prefix notation for fixed-sized array bounds is better IMO to avoid these pitfalls.<br></p><p>Hmm… Two dimensions tuples...<br>let matrix: (2 (4 Int)) = ( (1,2,3,4), (5,6,7,8) )<br>print(matrix.0.0, matrix.1.3) // display 1 and 8<br>// Output based on let matrix = ((1,2,3,4), (5,6,7,8))<br></p><p>The type is easier to read with LLVM IR syntax mentioned by Joe<br>let matrix: (2 x (4 x Int)) = ( (1,2,3,4), (5,6,7,8) )<br></p><p>A one dimensional tuple is supposed to be contiguous, but does the same behaviour apply to tuples of tuples?<br></p><p>Dany<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/5f75b1d4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>Damn, I&#39;m way to slow writing proposals…<br></p><p>I have one big problem with using tuples as basis for fixed-size vectors:<br>They cannot have methods, and I want a matrix-type to have some of those.<br></p><p>Have a look at<br>https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters<br>if you want to see what I&#39;d prefer instead — hopefully, I can spare an hour or two today to finish the text.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 01:00:00am</p></header><div class="content"><p>Same here, but can’t we wrap them?<br>struct Vector&lt;(4 x T) where T: MathType&gt; {}<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 29, 2016, at 01:01, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Damn, I&#39;m way to slow writing proposals…<br>&gt; <br>&gt; I have one big problem with using tuples as basis for fixed-size vectors:<br>&gt; They cannot have methods, and I want a matrix-type to have some of those.<br>&gt; <br>&gt; Have a look at<br>&gt; https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters<br>&gt; if you want to see what I&#39;d prefer instead — hopefully, I can spare an hour or two today to finish the text.<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Same here, but can’t we wrap them?<br>&gt; struct Vector&lt;(4 x T) where T: MathType&gt; {}<br>Might be possible, but I guess it will be much work:<br>You can&#39;t declare something like<br></p><p>class A&lt;Array&lt;T&gt; where T is SequenceType&gt;<br></p><p>now.<br></p><p>Also, I have an aversion of mixing the concept of array and tuple — and am I the only one who get creeps because of that &quot;x&quot; in the declaration? I hope this is just a placeholder — either for a sigil yet to be found (maybe something like &quot;:&quot;, &quot;@&quot;), or for the whole syntax.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/af1e205b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4030f7e8f6b6d3c09d10ec12691773c1?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>John Randolph</string> &lt;jcr at mac.com&gt;<p>February  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 2:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; am I the only one who get creeps because of that &quot;x&quot; in the declaration? I<br></p><p>I really don’t like the x as an operator either, because I use x for so many other things in my code. <br></p><p>My typical use case for contiguous variables would be images, e.g:<br></p><p>struct RGBAPixel {<br>	var red: Int8<br>	var green:Int8<br>	var blue:Int8<br>	var alpha:Int8<br>}<br></p><p>let myImage : RGBAPixel[512 * 515] = someCFunctionThatReturnsABitmap() as! RGBAPixel[]<br></p><p>I recently needed to do this kind of thing in a Swift tool that converted images into CIColorCubes, and it was nightmarish.   I almost reverted to C to get it done.<br></p><p>On a related note, I’d really love to have a way to declare multi-dimensional arrays and be able to name the axes.   <br></p><p>-jcr<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df65d69ec35e73390ddd0e6a2c335737?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>James Hillhouse IV</string> &lt;jimhillhouse at me.com&gt;<p>February  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On a related note, I’d really love to have a way to declare multi-dimensional arrays and be able to name the axes. <br></p><p>I would like to strongly second John Randolph’s request for a multi-dimensional arrays, otherwise known as matrices. There is currently GLKMatrix3 and GLKMatrix4, which hold CGFloats. But it would be more useful to for matrix members to be Float, Double, Int, String, etc..<br></p><p>var aMatrix: Matrix&lt;Int&gt; = Matrix(row: 6, columns: 20)<br></p><p>I would also like to request quaternions and tensors in Swift. Currently quaternions can be had via GLKQuaternion, but it holds only CGFloat variables. There are times I would like to instead use Double. <br></p><p>Tensors are not currently in Swift.<br></p><p>Thanks,<br></p><p>Jim Hillhouse<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; var aMatrix: Matrix&lt;Int&gt; = Matrix(row: 6, columns: 20)<br>That can be done already — but it is not possible for the compiler to enforce correct handling (matching dimensions for operations on matrix/vectors).<br>Adding this would be nice, but I was told it is out of scope for Swift 3.<br>(the proposal-draft I made is here: https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters)<br></p><p>Tino<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 8:42 AM, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 2:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; am I the only one who get creeps because of that &quot;x&quot; in the declaration? I<br>&gt; <br>&gt; I really don’t like the x as an operator either, because I use x for so many other things in my code. <br></p><p>I agree that it wouldn’t be acceptable to take x as a keyword.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  1, 2016 at 05:00:00pm</p></header><div class="content"><p>Have people on this thread been suggesting the letter ‘x’ literally for the operator, or was that meant as a shortcut/standin for the unicode cross operator: ×<br></p><p>?<br></p><p>Or maybe they are so similar that neither would be a good keyword…<br></p><p>Matt<br></p><p><br>&gt; On Feb 1, 2016, at 12:43, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 8:42 AM, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 29, 2016, at 2:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; am I the only one who get creeps because of that &quot;x&quot; in the declaration? I<br>&gt;&gt; <br>&gt;&gt; I really don’t like the x as an operator either, because I use x for so many other things in my code. <br>&gt; <br>&gt; I agree that it wouldn’t be acceptable to take x as a keyword.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  1, 2016 at 08:00:00pm</p></header><div class="content"><p>I can’t speak for everyone else, but I’ve been using it as a stand-in for “whatever”. I think × and x are different enough (at least in Xcode’s default Menlo and, my current favorite, Fira Mono), but I don’t think × is anywhere of the normal keyboard layout. I know it wouldn’t be hard for Apple to have a custom keyboard layout with a bunch of math symbols on the alt layer, but I don’t know how to handle it for other editors.<br></p><p>It’s too bad, really… Not for × in particular, but abstract / math code in general would be a lot more readable if people had easy access the various operators and set notation symbols.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 1, 2016, at 17:31, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Have people on this thread been suggesting the letter ‘x’ literally for the operator, or was that meant as a shortcut/standin for the unicode cross operator: ×<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; Or maybe they are so similar that neither would be a good keyword…<br>&gt; <br>&gt; Matt<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 1, 2016, at 12:43, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 8:42 AM, John Randolph via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 29, 2016, at 2:40 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; am I the only one who get creeps because of that &quot;x&quot; in the declaration? I<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really don’t like the x as an operator either, because I use x for so many other things in my code.<br>&gt;&gt; <br>&gt;&gt; I agree that it wouldn’t be acceptable to take x as a keyword.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/d5ab2350/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 1:01 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Damn, I&#39;m way to slow writing proposals…<br>&gt; <br>&gt; I have one big problem with using tuples as basis for fixed-size vectors:<br>&gt; They cannot have methods, and I want a matrix-type to have some of those.<br></p><p>If we go with this design, the canonical way to do that is as a struct wrapping a tuple, something like:<br></p><p>struct Matrix4x4 {<br>  private var elements : (4 x (4 x Float))<br></p><p>  public func …<br>}<br></p><p>This seems like a nice way to handle it, keeping the balance of not adding a completely new fundamental type to the language to solve such a narrow case.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Have a look at<br>&gt; https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters<br>&gt; if you want to see what I&#39;d prefer instead — hopefully, I can spare an hour or two today to finish the text.<br>&gt; <br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt; <br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt; <br>&gt; That would make the experience of working with imported C types a lot better.<br></p><p>I&#39;ve thought about these two enhancements several times during the last few weeks, exactly as you describe them. +1.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 29, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>On 29 January 2016 at 09:20, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Rather than introduce a new kind of declaration, I think we could add a<br>&gt; few small features to tuples:<br>&gt;<br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n<br>&gt; elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the<br>&gt; common supertype of its elements.<br>&gt;<br>&gt; That would make the experience of working with imported C types a lot<br>&gt; better.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To better support interfacing with lower level systems, like graphics<br>&gt; libraries for example, it would be helpful to support the concept of<br>&gt; contiguous variables. The most common use case for this would be to create<br>&gt; a Matrix struct that can be passed as data into something like Metal. This<br>&gt; can be accomplished now, using something like the following:<br>&gt; &gt;<br>&gt; &gt; Current Option 1:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m00: Float<br>&gt; &gt;     var m01: Float<br>&gt; &gt;     var m10: Float<br>&gt; &gt;     var m11: Float<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 2:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 3:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: [Float]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of<br>&gt; elements and also for the data to be easily passed into graphics libraries<br>&gt; as their memory layout is somewhat predictable using sizeof, strideof, and<br>&gt; alignof. The downside is that you lose the ability to easily subscript or<br>&gt; iterate the elements.<br>&gt; &gt;<br>&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile<br>&gt; time enforce a fixed number of elements and is not as easily passed into a<br>&gt; library that expects to receive the raw data of the matrix.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Contiguous Variables:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The<br>&gt; specific number of values must be a compile time constant. The only needed<br>&gt; functionality includes `count`, `subscript`, and iteration. To make things<br>&gt; easier to implement and to help avoid confusion and more complex<br>&gt; documentation, multiple dimensions are not allowed. To define multiple<br>&gt; dimensions you must provide your own ordering by wrapping this type in<br>&gt; another type and providing a custom subscript implementation. For example:<br>&gt; &gt;<br>&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt;<br>&gt; &gt;     static let rows = 2<br>&gt; &gt;     static let columns = 2<br>&gt; &gt;<br>&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt; &gt; strideof(Matrix2x2) is 16<br>&gt; &gt;<br>&gt; &gt; m.count is essentially a compile time constant and is not stored with<br>&gt; the rest of the data but is available and can also be used to do runtime<br>&gt; bounds checking.<br>&gt; &gt;<br>&gt; &gt; struct Vector3 {<br>&gt; &gt;     var v: Float:3<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Vector3) is 12<br>&gt; &gt; strideof(Vector3) is 12<br>&gt; &gt;<br>&gt; &gt; C code should also now be able to expose data types that contain fixed<br>&gt; sized arrays within them.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/c5bc366a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 28, 2016 at 11:00:00pm</p></header><div class="content"><p>It dawns on me that the proposal will most likely need to introduce a syntax to initialize the tuple as well, since we can&#39;t just memset it.<br></p><p>Félix<br></p><p>&gt; Le 28 janv. 2016 à 23:33:59, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; On 29 January 2016 at 09:20, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt; <br>&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt; <br>&gt; That would make the experience of working with imported C types a lot better.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt; &gt;<br>&gt; &gt; Current Option 1:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m00: Float<br>&gt; &gt;     var m01: Float<br>&gt; &gt;     var m10: Float<br>&gt; &gt;     var m11: Float<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 2:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; OR<br>&gt; &gt; Current Option 3:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: [Float]<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt; &gt;<br>&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Contiguous Variables:<br>&gt; &gt;<br>&gt; &gt; struct Matrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt; &gt;<br>&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt; &gt;     var m: Float:2*2<br>&gt; &gt;<br>&gt; &gt;     static let rows = 2<br>&gt; &gt;     static let columns = 2<br>&gt; &gt;<br>&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt; &gt; strideof(Matrix2x2) is 16<br>&gt; &gt;<br>&gt; &gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt; &gt;<br>&gt; &gt; struct Vector3 {<br>&gt; &gt;     var v: Float:3<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; sizeof(Vector3) is 12<br>&gt; &gt; strideof(Vector3) is 12<br>&gt; &gt;<br>&gt; &gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/5d29440a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 8:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; It dawns on me that the proposal will most likely need to introduce a syntax to initialize the tuple as well, since we can&#39;t just memset it.<br></p><p>Well, you can initialize it as (0,0,0,0,...), though that doesn&#39;t scale well. This seems like a separable issue, though. At least for C types, a zeroing initializer is provided by the Clang importer.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 28 janv. 2016 à 23:33:59, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt; On 29 January 2016 at 09:20, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt;&gt; <br>&gt;&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt;&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt;&gt; <br>&gt;&gt; That would make the experience of working with imported C types a lot better.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Current Option 1:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt; &gt;     var m00: Float<br>&gt;&gt; &gt;     var m01: Float<br>&gt;&gt; &gt;     var m10: Float<br>&gt;&gt; &gt;     var m11: Float<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; OR<br>&gt;&gt; &gt; Current Option 2:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; OR<br>&gt;&gt; &gt; Current Option 3:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt; &gt;     var m: [Float]<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Contiguous Variables:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     static let rows = 2<br>&gt;&gt; &gt;     static let columns = 2<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt;&gt; &gt; strideof(Matrix2x2) is 16<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct Vector3 {<br>&gt;&gt; &gt;     var v: Float:3<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; sizeof(Vector3) is 12<br>&gt;&gt; &gt; strideof(Vector3) is 12<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/a6e08398/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 29, 2016 at 12:00:00am</p></header><div class="content"><p>To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br></p><p>Félix<br></p><p>&gt; Le 29 janv. 2016 à 00:13:13, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 8:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It dawns on me that the proposal will most likely need to introduce a syntax to initialize the tuple as well, since we can&#39;t just memset it.<br>&gt; <br>&gt; Well, you can initialize it as (0,0,0,0,...), though that doesn&#39;t scale well. This seems like a separable issue, though. At least for C types, a zeroing initializer is provided by the Clang importer.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 28 janv. 2016 à 23:33:59, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 29 January 2016 at 09:20, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt;&gt;&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would make the experience of working with imported C types a lot better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Current Option 1:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m00: Float<br>&gt;&gt;&gt; &gt;     var m01: Float<br>&gt;&gt;&gt; &gt;     var m10: Float<br>&gt;&gt;&gt; &gt;     var m11: Float<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; OR<br>&gt;&gt;&gt; &gt; Current Option 2:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; OR<br>&gt;&gt;&gt; &gt; Current Option 3:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: [Float]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Contiguous Variables:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     static let rows = 2<br>&gt;&gt;&gt; &gt;     static let columns = 2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;&gt;&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt;&gt;&gt; &gt;     }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt;&gt;&gt; &gt; strideof(Matrix2x2) is 16<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Vector3 {<br>&gt;&gt;&gt; &gt;     var v: Float:3<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; sizeof(Vector3) is 12<br>&gt;&gt;&gt; &gt; strideof(Vector3) is 12<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/baba4946/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br></p><p>Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>The advantage in going with a &quot;only allow a single member of type T that initializes across the entire tuple&quot; is that it enforces safety and simplicity.<br></p><p>-- E<br></p><p>&gt; On Jan 29, 2016, at 11:43 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br>&gt; <br>&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>The fact that this could be used in expressions is making the N x T syntax<br>grow on me.<br></p><p>(N x T) := (T, T, ...)<br>(N x &lt;expr&gt;) := (&lt;expr&gt;, &lt;expr&gt;, ...)<br></p><p>It has a nice symmetry.<br></p><p>On Fri, Jan 29, 2016 at 1:43 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To me, it&#39;s closely related to the declaration issue. By introducing a<br>&gt; (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS<br>&gt; problem intact. If we want to spin it off into a separate proposal, I think<br>&gt; that the most logical split is to have a proposal for subscripts on uniform<br>&gt; tuples, and a a proposal for the shorthand syntax and a way to initialize<br>&gt; values of these types.<br>&gt;<br>&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as<br>&gt; well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0,<br>&gt; 0, 2). With integer literals it&#39;s hard to tell which side is which,<br>&gt; though...<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/f51e8845/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 11:11 AM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; The fact that this could be used in expressions is making the N x T syntax grow on me.<br>&gt; <br>&gt; (N x T) := (T, T, ...)<br>&gt; (N x &lt;expr&gt;) := (&lt;expr&gt;, &lt;expr&gt;, ...)<br></p><p>Yeah, and I could definitely see &#39;[a, b, c, 253 x 0]&#39; being useful to initialize dynamic arrays too.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>Speaking of spitballing, these can be nested/composed, right?<br>let x = (3 x (0, 2 x “”), 2 x NSFileManager())<br></p><p>So, I think that this would be correct:<br>let x0 = x.0 // is ((Int, (String, String)), (Int, (String, String)), (Int, (String, String)))<br>let x1 = x.1 // is (NSFileManager, NSFileManager)<br>let xIdx0 = x.0[0] // is (Int, (String, String))<br></p><p>Can we implicitly “unzip” the implicit &quot;arrays”, as well?<br>let x00 = x.0.0 // is (Int, Int, Int)… equivalent to let x00 = x.0.map { $0.0 }<br>let x01 = x.0.1 // is ((String, String), (String, String), (String, String))… equivalent to let x01 = x.0.map { $0.1 }<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 29, 2016, at 10:43, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br>&gt; <br>&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/0d758ea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>January 30, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 29 janv. 2016 à 14:13, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Speaking of spitballing, these can be nested/composed, right?<br>&gt; let x = (3 x (0, 2 x “”), 2 x NSFileManager())<br></p><p>Looks like there’s a missing set of parenthesis. I would expect:<br></p><p>let x = ((3 x (0, 2 x “”)), (2 x NSFileManager()))<br></p><p>To gives these result<br></p><p>&gt; So, I think that this would be correct:<br>&gt; let x0 = x.0 // is ((Int, (String, String)), (Int, (String, String)), (Int, (String, String)))<br>&gt; let x1 = x.1 // is (NSFileManager, NSFileManager)<br>&gt; let xIdx0 = x.0[0] // is (Int, (String, String))<br>&gt; <br>&gt; Can we implicitly “unzip” the implicit &quot;arrays”, as well?<br>&gt; let x00 = x.0.0 // is (Int, Int, Int)… equivalent to let x00 = x.0.map { $0.0 }<br>&gt; let x01 = x.0.1 // is ((String, String), (String, String), (String, String))… equivalent to let x01 = x.0.map { $0.1 }<br></p><p>As for the original<br>let x = (3 x (0, 2 x “”), 2 x NSFileManager())<br></p><p>The results would be:<br>let x0 = x.0 // is (Int, (String, String)<br>let x3 = x.3 // is NSFileManager<br>let xIdx0 = x.0[0] // is Int<br></p><p>Dany<br></p><p>&gt;&gt; On Jan 29, 2016, at 10:43, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br>&gt;&gt; <br>&gt;&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/7a12e292/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 10:43, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br>&gt; <br>&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br></p><p>I&#39;m not quite happy with this. Consider this case:<br></p><p>// In some library...<br>typealias FixedSizeBuffer = (256 x CChar)<br></p><p>// In my code...<br>var buffer: FixedSizeBuffer = /*???*/<br>generateCryptographicNoise(&amp;buffer)<br></p><p>I shouldn&#39;t really have to know that &#39;buffer&#39; has 256 elements.<br></p><p>Throwing out some possibilities:<br></p><p>var buffer: FixedSizeBuffer = (0...)<br>var buffer: FixedSizeBuffer = (* x 0)<br>var buffer: FixedSizeBuffer = (repeat 0)<br></p><p>…none of which I&#39;m particularly happy with. (The first one is inconsistent with the not-actually-proposed syntax for forwarding variadics.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/4a3173f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 29, 2016 at 01:00:00pm</p></header><div class="content"><p>On Jan 29, 2016, at 11:23 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jan 29, 2016, at 10:43, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 9:24 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, it&#39;s closely related to the declaration issue. By introducing a (N x Type) syntax, we&#39;re solving the LHS problem but leaving the RHS problem intact. If we want to spin it off into a separate proposal, I think that the most logical split is to have a proposal for subscripts on uniform tuples, and a a proposal for the shorthand syntax and a way to initialize values of these types.<br>&gt;&gt; <br>&gt;&gt; Just spitballing…we could bring the N x &lt;expr&gt; syntax to expressions as well, so that (5 x 0) is (0,0,0,0,0), and maybe (1, 3 x 0, 2) is (1, 0, 0, 0, 2). With integer literals it&#39;s hard to tell which side is which, though...<br>&gt; <br>&gt; Throwing out some possibilities:<br>&gt; <br>&gt; var buffer: FixedSizeBuffer = (0...)<br>&gt; var buffer: FixedSizeBuffer = (* x 0)<br>&gt; var buffer: FixedSizeBuffer = (repeat 0)<br></p><p>How about:  <br>  FixedSizeBuffer(0)<br></p><p>We introduce initializer expression syntax for tuples that takes an element, and define it to be a splat in the case of a homogenous tuple, or an error if not.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/6b90716b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 29, 2016 at 08:00:00am</p></header><div class="content"><p>Is this at all possible?<br></p><p>let values: (N x T) = V<br></p><p>where V.dynamicType is constrained to T and only one  repeating value can be used with this shorthand? I&#39;d imagine the single value would be 0 or maybe in rare circumstances 0xFF. My other common circumstance, passing a 4-tuple of floats, would be easy to write-up using the previous approach:<br></p><p>let values: (N x T) = (V0, ..., VN-1)<br></p><p>I imagine a single-value assignment would apply to the n-dimensional case as well:<br></p><p>let values: (M x (N x T)) = V<br></p><p>-- E<br></p><p><br>&gt; On Jan 28, 2016, at 10:13 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 8:43 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It dawns on me that the proposal will most likely need to introduce a syntax to initialize the tuple as well, since we can&#39;t just memset it.<br>&gt; <br>&gt; Well, you can initialize it as (0,0,0,0,...), though that doesn&#39;t scale well. This seems like a separable issue, though. At least for C types, a zeroing initializer is provided by the Clang importer.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 28 janv. 2016 à 23:33:59, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 29 January 2016 at 09:20, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Rather than introduce a new kind of declaration, I think we could add a few small features to tuples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We could say the type (n * T) is equivalent to a homogeneous tuple of n elements, and<br>&gt;&gt;&gt; - We could allow tuples to be subscriptable, producing a value of the common supertype of its elements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would make the experience of working with imported C types a lot better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 27, 2016, at 7:50 PM, Justin Kolb via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; To better support interfacing with lower level systems, like graphics libraries for example, it would be helpful to support the concept of contiguous variables. The most common use case for this would be to create a Matrix struct that can be passed as data into something like Metal. This can be accomplished now, using something like the following:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Current Option 1:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m00: Float<br>&gt;&gt;&gt; &gt;     var m01: Float<br>&gt;&gt;&gt; &gt;     var m10: Float<br>&gt;&gt;&gt; &gt;     var m11: Float<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; OR<br>&gt;&gt;&gt; &gt; Current Option 2:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: (Float, Float, Float, Float)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; OR<br>&gt;&gt;&gt; &gt; Current Option 3:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: [Float]<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Options 1 &amp; 2 allow for the compiler to enforce the fixed number of elements and also for the data to be easily passed into graphics libraries as their memory layout is somewhat predictable using sizeof, strideof, and alignof. The downside is that you lose the ability to easily subscript or iterate the elements.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Option 3 does allow subscripting and iteration, but does not at compile time enforce a fixed number of elements and is not as easily passed into a library that expects to receive the raw data of the matrix.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Contiguous Variables:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Matrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The variable `m` represents a series of 4 contiguous Float values. The specific number of values must be a compile time constant. The only needed functionality includes `count`, `subscript`, and iteration. To make things easier to implement and to help avoid confusion and more complex documentation, multiple dimensions are not allowed. To define multiple dimensions you must provide your own ordering by wrapping this type in another type and providing a custom subscript implementation. For example:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct RowMajorMatrix2x2 {<br>&gt;&gt;&gt; &gt;     var m: Float:2*2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     static let rows = 2<br>&gt;&gt;&gt; &gt;     static let columns = 2<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     subscript(row: Int, column: Int) -&gt; Float {<br>&gt;&gt;&gt; &gt;         return m[column * Matrix2x2.rows + row]<br>&gt;&gt;&gt; &gt;     }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; sizeof(Matrix2x2) is 16<br>&gt;&gt;&gt; &gt; strideof(Matrix2x2) is 16<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; m.count is essentially a compile time constant and is not stored with the rest of the data but is available and can also be used to do runtime bounds checking.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct Vector3 {<br>&gt;&gt;&gt; &gt;     var v: Float:3<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; sizeof(Vector3) is 12<br>&gt;&gt;&gt; &gt; strideof(Vector3) is 12<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; C code should also now be able to expose data types that contain fixed sized arrays within them.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/becc694f/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
