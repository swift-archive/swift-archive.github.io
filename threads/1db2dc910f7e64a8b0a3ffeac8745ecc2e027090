<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>August 11, 2016 at 10:00:00am</p></header><div class="content"><p>It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void <br></p><p><br>Detail explain:<br></p><p><br>var fn0: A-&gt;Void = {print($0)} <br>var fn1: (A|B)-&gt;Void = {print(v0)} <br>let a = A()<br>let b = B()<br></p><p><br>So:<br></p><p><br>fn0( a ) // this is OK <br>fn1( a ) // this is also OK<br></p><p><br>fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>Thus fn0 = fn1 is OK.<br></p><p><br>But:<br></p><p><br>fn1( b ) // this is OK<br>fn0( b ) // this is not OK<br></p><p><br>So fn0 is not subtype of fn1<br></p><p><br>At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com&gt; wrote:<br></p><p>Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br></p><p><br>`var fn0: A-&gt;Void= {print(v0)} <br>var fn1: (A|B)-&gt;Void= {print(v0)} <br></p><p><br> fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationshipvar <br></p><p><br>fn2: (A|B|C)-&gt;Void= {print($0)} <br></p><p><br> fn0 = fn2 // OK <br> fn1 = fn2 // OK`<br></p><p>On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>Hi all,<br></p><p><br>I want to make a discussion about union type for swift 4.<br>See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br></p><p><br></p><p>Add union type grammar, represents the type which is one of other types.<br></p><p>var stringOrURL: String| URL =&quot;https://www.apple.com&quot;<br></p><p>Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br></p><p>funcinput(value: A | B | C) {<br>    print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of boxswitch value {<br>    caselet value as A:<br>        // value is type Aprint(value.propertyInA)<br>    caselet value as B:<br>        // value is type Bprint(value.propertyInB)<br>    caselet value as C:<br>        // value is type Cprint(value.propertyInC)<br>    }<br>    // there is no default case other than A, B or C. we already declared that.<br>}<br></p><p>Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br></p><p><br></p><p>Impact on existing code<br>This is a new feature, developer who need declare common type will alter to this new grammar.<br>Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/1db27090/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 11, 2016 at 03:00:00am</p></header><div class="content"><p>I don&#39;t know if the core team feels differently now with respect to Swift<br>4, but union types are listed as a &quot;commonly rejected change&quot;:<br></p><p>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br></p><p>Is there anything in your proposal that goes beyond previous discussions on<br>the topic?<br>On Wed, Aug 10, 2016 at 21:59 Cao, Jiannan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void<br>&gt;<br>&gt; Detail explain:<br>&gt;<br>&gt; var fn0: A-&gt;Void = {print($0)}<br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt; let a = A()<br>&gt; let b = B()<br>&gt;<br>&gt; So:<br>&gt;<br>&gt; fn0( a ) // this is OK<br>&gt; fn1( a ) // this is also OK<br>&gt;<br>&gt; fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>&gt; Thus fn0 = fn1 is OK.<br>&gt;<br>&gt; But:<br>&gt;<br>&gt; fn1( b ) // this is OK<br>&gt; fn0( b ) // this is not OK<br>&gt;<br>&gt; So fn0 is not subtype of fn1<br>&gt;<br>&gt; At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com&gt; wrote:<br>&gt;<br>&gt; Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements.<br>&gt;<br>&gt; `var fn0: A-&gt;Void = {print(v0)}<br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)}<br>&gt;<br>&gt;  fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing<br>&gt; relationship var<br>&gt;<br>&gt; fn2: (A|B|C)-&gt;Void = {print($0)}<br>&gt;<br>&gt;  fn0 = fn2 // OK<br>&gt;  fn1 = fn2 // OK`<br>&gt;<br>&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi all,<br>&gt;<br>&gt; I want to make a discussion about union type for swift 4.<br>&gt; See<br>&gt; https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md<br>&gt;<br>&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;<br>&gt; var stringOrURL: String | URL = &quot;https://www.apple.com&quot;<br>&gt;<br>&gt; Now, if we using the new union type feature, we can declare type<br>&gt; conveniently, No other type declaration, and compiler will automatically<br>&gt; calculate the common interface.<br>&gt;<br>&gt; func input(value: A | B | C) {<br>&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;     switch value {<br>&gt;     case let value as A:<br>&gt;         // value is type A<br>&gt;         print(value.propertyInA)<br>&gt;     case let value as B:<br>&gt;         // value is type B<br>&gt;         print(value.propertyInB)<br>&gt;     case let value as C:<br>&gt;         // value is type C<br>&gt;         print(value.propertyInC)<br>&gt;     }<br>&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt; }<br>&gt;<br>&gt; Note: A, B, C can be either class or protocol, or any other types. This<br>&gt; leaves developer more freedom.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt;    - This is a new feature, developer who need declare common type will<br>&gt;    alter to this new grammar.<br>&gt;    - Enum based version optional or IUO will be replaced by Union-based<br>&gt;    ones. Any optional type will automatically replaced by union type<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/61e32d46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>August 11, 2016 at 11:00:00am</p></header><div class="content"><p>https://lists.swift.org/pipermail/swift-evolution-announce/2016-June/000182.html &lt;https://lists.swift.org/pipermail/swift-evolution-announce/2016-June/000182.html&gt;<br>you can go for detail. it is for Swift 3.<br></p><p>and swift-evolution should be open mind. Since it ask us to make proposals.<br></p><p>&gt; 在 2016年8月11日，11:15，Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; 写道：<br>&gt; <br>&gt; I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt; <br>&gt; Is there anything in your proposal that goes beyond previous discussions on the topic?<br>&gt; On Wed, Aug 10, 2016 at 21:59 Cao, Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void <br>&gt; <br>&gt; Detail explain:<br>&gt; <br>&gt; var fn0: A-&gt;Void = {print($0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; <br>&gt; So:<br>&gt; <br>&gt; fn0( a ) // this is OK <br>&gt; fn1( a ) // this is also OK<br>&gt; <br>&gt; fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>&gt; Thus fn0 = fn1 is OK.<br>&gt; <br>&gt; But:<br>&gt; <br>&gt; fn1( b ) // this is OK<br>&gt; fn0( b ) // this is not OK<br>&gt; <br>&gt; So fn0 is not subtype of fn1<br>&gt; <br>&gt; At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt; Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br>&gt; <br>&gt; `var fn0: A-&gt;Void = {print(v0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; <br>&gt;  fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationship var <br>&gt; <br>&gt; fn2: (A|B|C)-&gt;Void = {print($0)} <br>&gt; <br>&gt;  fn0 = fn2 // OK <br>&gt;  fn1 = fn2 // OK`<br>&gt; <br>&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt;&gt; <br>&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt; <br>&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt; <br>&gt;&gt; func input(value: A | B | C) {<br>&gt;&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;     switch value {<br>&gt;&gt;     case let value as A:<br>&gt;&gt;         // value is type A<br>&gt;&gt;         print(value.propertyInA)<br>&gt;&gt;     case let value as B:<br>&gt;&gt;         // value is type B<br>&gt;&gt;         print(value.propertyInB)<br>&gt;&gt;     case let value as C:<br>&gt;&gt;         // value is type C<br>&gt;&gt;         print(value.propertyInC)<br>&gt;&gt;     }<br>&gt;&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt; }<br>&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/c1c155cf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>August 11, 2016 at 11:00:00am</p></header><div class="content"><p>Union type is powerful. It can make up optional, let it leaves terrible generic wrap.<br></p><p>And the most important part, It can replace enum Optional&lt;T&gt; to represent optional types.<br>    let string: String?<br>is same to<br></p><p>    let string: String | None<br>instead of<br></p><p>    let string: Optional&lt;String&gt;<br>IUO, Implicity Unwrapped Optional, can also use union to represent<br>    let string: String!<br>will be the same as the union grammar:<br></p><p>    let iuo: *String | None<br></p><p>&gt; 在 2016年8月11日，11:15，Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; 写道：<br>&gt; <br>&gt; I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt; <br>&gt; Is there anything in your proposal that goes beyond previous discussions on the topic?<br>&gt; On Wed, Aug 10, 2016 at 21:59 Cao, Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void <br>&gt; <br>&gt; Detail explain:<br>&gt; <br>&gt; var fn0: A-&gt;Void = {print($0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; <br>&gt; So:<br>&gt; <br>&gt; fn0( a ) // this is OK <br>&gt; fn1( a ) // this is also OK<br>&gt; <br>&gt; fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>&gt; Thus fn0 = fn1 is OK.<br>&gt; <br>&gt; But:<br>&gt; <br>&gt; fn1( b ) // this is OK<br>&gt; fn0( b ) // this is not OK<br>&gt; <br>&gt; So fn0 is not subtype of fn1<br>&gt; <br>&gt; At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt; Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br>&gt; <br>&gt; `var fn0: A-&gt;Void = {print(v0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; <br>&gt;  fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationship var <br>&gt; <br>&gt; fn2: (A|B|C)-&gt;Void = {print($0)} <br>&gt; <br>&gt;  fn0 = fn2 // OK <br>&gt;  fn1 = fn2 // OK`<br>&gt; <br>&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt;&gt; <br>&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt; <br>&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt; <br>&gt;&gt; func input(value: A | B | C) {<br>&gt;&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;     switch value {<br>&gt;&gt;     case let value as A:<br>&gt;&gt;         // value is type A<br>&gt;&gt;         print(value.propertyInA)<br>&gt;&gt;     case let value as B:<br>&gt;&gt;         // value is type B<br>&gt;&gt;         print(value.propertyInB)<br>&gt;&gt;     case let value as C:<br>&gt;&gt;         // value is type C<br>&gt;&gt;         print(value.propertyInC)<br>&gt;&gt;     }<br>&gt;&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt; }<br>&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/582030c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 11, 2016 at 07:00:00am</p></header><div class="content"><p>Seeing from the sample codes, this is just a syntax for anonymous enums, which were discussed here a few months ago. I personally don&#39;t see that much advantage in it given it is more restrictive than an enum (you can&#39;t have two cases with the same payload type) and it leads to people retyping these anonymous enums rather than declaring a type - which in general leads to a less readable language - when do I pass in type A, when type B, when type C? Enum has those cases named.<br></p><p>Would this be valid?<br></p><p>let x: A | B = y<br>func input(value: A | B | C) {}<br></p><p>input(value: x)<br></p><p>I.e. supplying a union of fewer types into a union of superset of the types?<br></p><p>&gt; On Aug 11, 2016, at 5:55 AM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Union type is powerful. It can make up optional, let it leaves terrible generic wrap.<br>&gt; <br>&gt; And the most important part, It can replace enum Optional&lt;T&gt; to represent optional types.<br>&gt;     let string: String?<br>&gt; is same to<br>&gt; <br>&gt;     let string: String | None<br>&gt; instead of<br>&gt; <br>&gt;     let string: Optional&lt;String&gt;<br>&gt; IUO, Implicity Unwrapped Optional, can also use union to represent<br>&gt;     let string: String!<br>&gt; will be the same as the union grammar:<br>&gt; <br>&gt;     let iuo: *String | None<br>&gt; <br>&gt;&gt; 在 2016年8月11日，11:15，Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt;&gt; <br>&gt;&gt; Is there anything in your proposal that goes beyond previous discussions on the topic?<br>&gt;&gt; On Wed, Aug 10, 2016 at 21:59 Cao, Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void <br>&gt;&gt; <br>&gt;&gt; Detail explain:<br>&gt;&gt; <br>&gt;&gt; var fn0: A-&gt;Void = {print($0)} <br>&gt;&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt;&gt; let a = A()<br>&gt;&gt; let b = B()<br>&gt;&gt; <br>&gt;&gt; So:<br>&gt;&gt; <br>&gt;&gt; fn0( a ) // this is OK <br>&gt;&gt; fn1( a ) // this is also OK<br>&gt;&gt; <br>&gt;&gt; fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>&gt;&gt; Thus fn0 = fn1 is OK.<br>&gt;&gt; <br>&gt;&gt; But:<br>&gt;&gt; <br>&gt;&gt; fn1( b ) // this is OK<br>&gt;&gt; fn0( b ) // this is not OK<br>&gt;&gt; <br>&gt;&gt; So fn0 is not subtype of fn1<br>&gt;&gt; <br>&gt;&gt; At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt;&gt; Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br>&gt;&gt; <br>&gt;&gt; `var fn0: A-&gt;Void = {print(v0)} <br>&gt;&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt;&gt; <br>&gt;&gt;  fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationship var <br>&gt;&gt; <br>&gt;&gt; fn2: (A|B|C)-&gt;Void = {print($0)} <br>&gt;&gt; <br>&gt;&gt;  fn0 = fn2 // OK <br>&gt;&gt;  fn1 = fn2 // OK`<br>&gt;&gt; <br>&gt;&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func input(value: A | B | C) {<br>&gt;&gt;&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;&gt;     switch value {<br>&gt;&gt;&gt;     case let value as A:<br>&gt;&gt;&gt;         // value is type A<br>&gt;&gt;&gt;         print(value.propertyInA)<br>&gt;&gt;&gt;     case let value as B:<br>&gt;&gt;&gt;         // value is type B<br>&gt;&gt;&gt;         print(value.propertyInB)<br>&gt;&gt;&gt;     case let value as C:<br>&gt;&gt;&gt;         // value is type C<br>&gt;&gt;&gt;         print(value.propertyInC)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt;&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/b1e3ef4a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 10, 2016, at 8:15 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br></p><p>There is no change in opinion here.  This topic is also out of scope for Swift 4 stage 1 in any case.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/a304441d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d569462ac92d4619342b1c5ff305043?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>frogcjn at 163.com</string> &lt;frogcjn at 163.com&gt;<p>August 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Swift evolution seems not an evolution. <br></p><p><br>I&#39;ll leave this mail list since this is not a good proposal environment. <br>Typescript and other language community is more open to new idea. Swift-evolution is just a weird community. <br></p><p><br>You just accept what you like and what you want. Is this called swift-evolution or proposal?<br></p><p><br>Proposal is for a long time standard, not just for next version of your shame release.<br></p><p><br>在 2016-08-11 13:18:54，&quot;Chris Lattner&quot; &lt;clattner at apple.com&gt; 写道：<br></p><p><br>On Aug 10, 2016, at 8:15 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br></p><p>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br></p><p><br></p><p>There is no change in opinion here.  This topic is also out of scope for Swift 4 stage 1 in any case.<br></p><p><br>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/dd3dc70e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 18, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 11 Aug 2016, at 07:18, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 10, 2016, at 8:15 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know if the core team feels differently now with respect to Swift 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt; <br>&gt; There is no change in opinion here.  This topic is also out of scope for Swift 4 stage 1 in any case.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>While I appreciate if you don’t want to reply, given the way the tone of this discussion seems to have turned:<br></p><p>The section on this topic in the “commonly-proposed” section could use some elaborating. On the face of it, it seems like a handy feature, and I’m sure many would like to know (now and in the future) why the core-team feels this way. Only then can they properly judge when circumstances may have changed, and if/when to raise the issue again.<br></p><p>Thanks<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/6c120254/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>August 17, 2016 at 07:00:00pm</p></header><div class="content"><p>These are a couple comments from Chris Lattner that come to mind<br></p><p>&quot;FWIW, this has been discussed before on swift-evolution.  Adding them<br>isn’t out of the question, but it is a lot more complicated than it looks<br>for the type checker.&quot;<br></p><p>&quot;Here is my concern:  Swift enums should be good enough that we don’t need<br>an Either type.  If defining your own custom enum is hard or bad, then we<br>should fix that.<br></p><p>There are a number of concepts floating around that would make enums better<br>in various ways.  One specific one would be to synthesize optional<br>accessors that line up with enum cases.&quot;<br>-  in &quot;Either in the Swift Standard Library&quot;<br></p><p><br>On Wed, Aug 17, 2016 at 7:06 PM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 11 Aug 2016, at 07:18, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Aug 10, 2016, at 8:15 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t know if the core team feels differently now with respect to Swift<br>&gt; 4, but union types are listed as a &quot;commonly rejected change&quot;:<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;<br>&gt;<br>&gt; There is no change in opinion here.  This topic is also out of scope for<br>&gt; Swift 4 stage 1 in any case.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; While I appreciate if you don’t want to reply, given the way the tone of<br>&gt; this discussion seems to have turned:<br>&gt;<br>&gt; The section on this topic in the “commonly-proposed” section could use<br>&gt; some elaborating. On the face of it, it seems like a handy feature, and I’m<br>&gt; sure many would like to know (now and in the future) why the core-team<br>&gt; feels this way. Only then can they properly judge when circumstances may<br>&gt; have changed, and if/when to raise the issue again.<br>&gt;<br>&gt; Thanks<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/c429ab4d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 19, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Cao,<br></p><p>Considering &quot;&amp;&quot; for types is already decided, symmetry would be enough motivation for me to add &quot;|&quot; as well.<br></p><p>Maybe I would even support replacing enums with associated values in favor of union types (my impression is that enums aren&#39;t as useful as I thought when I started using them).<br></p><p>But right now, this doesn&#39;t seem to be a time for discussing huge changes, but for actually implementing smaller ones ;-)<br>I&#39;m a little bit concerned that Swift might already be preferring compatibility over elegance, but the defensive attitude that you perceived might as well be explained with release-stress…<br></p><p>Of course, rejection is still frustrating — but please consider that most proposals aren&#39;t accompanied by an implementation, so every wish that&#39;s accepted adds something to the pile of work to be done by the core team.<br>Imho it would be nice if Swift evolution would be more &quot;decentralized&quot;, moving away from proposals like &quot;I want to have feature X&quot; towards &quot;I want to develop feature X, is there a chance this could be integrated?&quot;, but coordination is already hard enough, so this might be unfeasible.<br></p><p>- Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 19, 2016 at 11:00:00am</p></header><div class="content"><p>On Fri, Aug 19, 2016 at 11:07 AM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Cao,<br>&gt;<br>&gt; Considering &quot;&amp;&quot; for types is already decided, symmetry would be enough<br>&gt; motivation for me to add &quot;|&quot; as well.<br>&gt;<br></p><p>Tino, this line of reasoning was explicitly addressed by the core team when<br>they approved &quot;&amp;&quot;. In fact, it was their &quot;princip[al] concern&quot; about &quot;&amp;&quot;:<br></p><p>&quot;The principle concern with this is that having an “&amp;&quot; operator for generic<br>constraints leads the question of whether the language should introduce an<br>&quot;|&quot; operator to represent disjunctions in type constraints (something that<br>the type system cannot and should not support). This is a topic that the<br>C++ committee grappled with in its discussions of C++ concepts. That said,<br>the core team feels that “&amp;” directly expresses the relationship that we<br>want, that “|” can be addressed in the “commonly rejected proposals&quot; list,<br>and that other proposals for an infix operator (like +) skirt this issue<br>but are strictly worse at communicating intent in code.&quot;<br></p><p><br>&gt; Maybe I would even support replacing enums with associated values in favor<br>&gt; of union types (my impression is that enums aren&#39;t as useful as I thought<br>&gt; when I started using them).<br>&gt;<br>&gt; But right now, this doesn&#39;t seem to be a time for discussing huge changes,<br>&gt; but for actually implementing smaller ones ;-)<br>&gt; I&#39;m a little bit concerned that Swift might already be preferring<br>&gt; compatibility over elegance, but the defensive attitude that you perceived<br>&gt; might as well be explained with release-stress…<br>&gt;<br>&gt; Of course, rejection is still frustrating — but please consider that most<br>&gt; proposals aren&#39;t accompanied by an implementation, so every wish that&#39;s<br>&gt; accepted adds something to the pile of work to be done by the core team.<br>&gt; Imho it would be nice if Swift evolution would be more &quot;decentralized&quot;,<br>&gt; moving away from proposals like &quot;I want to have feature X&quot; towards &quot;I want<br>&gt; to develop feature X, is there a chance this could be integrated?&quot;, but<br>&gt; coordination is already hard enough, so this might be unfeasible.<br>&gt;<br>&gt; - Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/9230085c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-Proposal-Discussion] Union Type - Swift 4</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>September 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Am 11.08.2016 um 04:58 schrieb Cao, Jiannan via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; It is no a mistake. since fn1: (A|B)-&gt;Void is subtype of fn0: A-&gt;Void <br></p><p>That is correct as (A|B) is a supertype of A and it occurs in a contravariant position (argument position) of the funcion type, so (A|B) -&gt; Void is a subtype of A -&gt; Void.<br></p><p>The current version of the proposal (https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design) seems to have been changed, though, as it has it the other way round (i.e. fn1 = fn0).<br></p><p>-Thorsten<br></p><p>&gt; <br>&gt; Detail explain:<br>&gt; <br>&gt; var fn0: A-&gt;Void = {print($0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; let a = A()<br>&gt; let b = B()<br>&gt; <br>&gt; So:<br>&gt; <br>&gt; fn0( a ) // this is OK <br>&gt; fn1( a ) // this is also OK<br>&gt; <br>&gt; fn1 is subtype of fn0, because fn1 can do anything fn0 do.<br>&gt; Thus fn0 = fn1 is OK.<br>&gt; <br>&gt; But:<br>&gt; <br>&gt; fn1( b ) // this is OK<br>&gt; fn0( b ) // this is not OK<br>&gt; <br>&gt; So fn0 is not subtype of fn1<br>&gt; <br>&gt; At 2016-08-11 10:41:02, &quot;Step C&quot; &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt; Shouldn&#39;t it be &quot;fn1 = fn0&quot;? Same for the fn2 statements. <br>&gt; <br>&gt; `var fn0: A-&gt;Void = {print(v0)} <br>&gt; var fn1: (A|B)-&gt;Void = {print(v0)} <br>&gt; <br>&gt;  fn0 = fn1 // OK, because Original Type and Union Type has a sub-typing relationship var <br>&gt; <br>&gt; fn2: (A|B|C)-&gt;Void = {print($0)} <br>&gt; <br>&gt;  fn0 = fn2 // OK <br>&gt;  fn1 = fn2 // OK`<br>&gt; <br>&gt; On Aug 10, 2016, at 9:28 PM, Cao Jiannan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I want to make a discussion about union type for swift 4.<br>&gt;&gt; See https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md&gt;<br>&gt;&gt; <br>&gt;&gt; Add union type grammar, represents the type which is one of other types.<br>&gt;&gt; <br>&gt;&gt; var stringOrURL: String | URL = &quot;https://www.apple.com &lt;https://www.apple.com/&gt;&quot;<br>&gt;&gt; Now, if we using the new union type feature, we can declare type conveniently, No other type declaration, and compiler will automatically calculate the common interface.<br>&gt;&gt; <br>&gt;&gt; func input(value: A | B | C) {<br>&gt;&gt;     print(value.commonProperty) // type checker will calculate the common interface, developer just use it out of box<br>&gt;&gt;     switch value {<br>&gt;&gt;     case let value as A:<br>&gt;&gt;         // value is type A<br>&gt;&gt;         print(value.propertyInA)<br>&gt;&gt;     case let value as B:<br>&gt;&gt;         // value is type B<br>&gt;&gt;         print(value.propertyInB)<br>&gt;&gt;     case let value as C:<br>&gt;&gt;         // value is type C<br>&gt;&gt;         print(value.propertyInC)<br>&gt;&gt;     }<br>&gt;&gt;     // there is no default case other than A, B or C. we already declared that.<br>&gt;&gt; }<br>&gt;&gt; Note: A, B, C can be either class or protocol, or any other types. This leaves developer more freedom.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a new feature, developer who need declare common type will alter to this new grammar.<br>&gt;&gt; Enum based version optional or IUO will be replaced by Union-based ones. Any optional type will automatically replaced by union type<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/frogcjn/swift-evolution/blob/master/proposals/xxxx-union-type.md#detailed-design&gt;_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  <br>&gt; <br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160911/d144b8bd/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
