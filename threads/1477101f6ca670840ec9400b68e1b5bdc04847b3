<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Possible compiler bug? Unable to extend a type whose name clashes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  8, 2016 at 05:00:00pm</p></header><div class="content"><p>I recently ran into a situation where I needed to import a symbol with the same name from two different modules, and noticed that the usual Swift technique of disambiguating using the package name doesn&#39;t work when used with extensions.<br></p><p>In my case, I have a package &#39;LegacyStore&#39; and a package &#39;AppleTart&#39;, both of which contain a type named &#39;User&#39;.<br></p><p>In the case of LegacyStore, User is an Objective-C class, and in the case of AppleTart, User is a Swift struct.<br></p><p>Normally, I&#39;d be able to refer to one as &#39;LegacyStore.User&#39; and the other as &#39;AppleTart.User&#39;, but when using this notation for an extension:<br></p><p>    extension AppleTart.User<br>    {<br>        public var legacyUser: LegacyStore.User {<br>            // implementation<br>        }<br>    }<br></p><p>...I get a compiler error on the extension declaration line:<br></p><p>    error: &#39;User&#39; is not a member type of &#39;AppleTart&#39;<br></p><p>Note that the &#39;LegacyStore.User&#39; notation used in the var declaration never triggers a compiler error, so I&#39;m assuming the notation just isn&#39;t supported yet in the context of declaring an extension.<br></p><p>Fortunately, there&#39;s a (somewhat cumbersome) work-around, which is to create two separate files, one for each module. Within each file import just that one module, and create a typealias for each clashing name using package-qualified name of the type.<br></p><p>For example, here&#39;s the relevant part of my AppleTartTypeDisambiguation.swift file:<br></p><p>    import AppleTart<br></p><p>    public typealias AppleTartUser = User<br></p><p>And here&#39;s my LegacyStoreTypeDisambiguation.swift file:<br></p><p>    import LegacyStore<br></p><p>    public typealias LegacyUser = User<br></p><p>I can then use the typealiases to extend either type. For example, here&#39;s how I successfully extended AppleTart.User:<br></p><p>    extension AppleTartUser<br>    {<br>        public var legacyUser: LegacyStore.User {<br>            // implementation<br>        }<br>    }<br></p><p>Should the inability to extend a type using the qualified type name be considered a compiler bug? I&#39;m assuming yes. If so, I&#39;ll file a ticket.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Possible compiler bug? Unable to extend a type whose name clashes</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi, Evan. Just a suspicion: do you also have a type named AppleTart? In that case you&#39;d be hitting SR-898 &lt;https://bugs.swift.org/browse/SR-898&gt;, rather than a specific issue with extensions.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 8, 2016, at 14:26, Evan Maloney via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I recently ran into a situation where I needed to import a symbol with the same name from two different modules, and noticed that the usual Swift technique of disambiguating using the package name doesn&#39;t work when used with extensions.<br>&gt; <br>&gt; In my case, I have a package &#39;LegacyStore&#39; and a package &#39;AppleTart&#39;, both of which contain a type named &#39;User&#39;.<br>&gt; <br>&gt; In the case of LegacyStore, User is an Objective-C class, and in the case of AppleTart, User is a Swift struct.<br>&gt; <br>&gt; Normally, I&#39;d be able to refer to one as &#39;LegacyStore.User&#39; and the other as &#39;AppleTart.User&#39;, but when using this notation for an extension:<br>&gt; <br>&gt;    extension AppleTart.User<br>&gt;    {<br>&gt;        public var legacyUser: LegacyStore.User {<br>&gt;            // implementation<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; ...I get a compiler error on the extension declaration line:<br>&gt; <br>&gt;    error: &#39;User&#39; is not a member type of &#39;AppleTart&#39;<br>&gt; <br>&gt; Note that the &#39;LegacyStore.User&#39; notation used in the var declaration never triggers a compiler error, so I&#39;m assuming the notation just isn&#39;t supported yet in the context of declaring an extension.<br>&gt; <br>&gt; Fortunately, there&#39;s a (somewhat cumbersome) work-around, which is to create two separate files, one for each module. Within each file import just that one module, and create a typealias for each clashing name using package-qualified name of the type.<br>&gt; <br>&gt; For example, here&#39;s the relevant part of my AppleTartTypeDisambiguation.swift file:<br>&gt; <br>&gt;    import AppleTart<br>&gt; <br>&gt;    public typealias AppleTartUser = User<br>&gt; <br>&gt; And here&#39;s my LegacyStoreTypeDisambiguation.swift file:<br>&gt; <br>&gt;    import LegacyStore<br>&gt; <br>&gt;    public typealias LegacyUser = User<br>&gt; <br>&gt; I can then use the typealiases to extend either type. For example, here&#39;s how I successfully extended AppleTart.User:<br>&gt; <br>&gt;    extension AppleTartUser<br>&gt;    {<br>&gt;        public var legacyUser: LegacyStore.User {<br>&gt;            // implementation<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Should the inability to extend a type using the qualified type name be considered a compiler bug? I&#39;m assuming yes. If so, I&#39;ll file a ticket.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160308/1ac15bb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Possible compiler bug? Unable to extend a type whose name clashes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>March  9, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks a lot, Jordan; your suspicion is correct! That appears to be the issue I&#39;m having--although unlike what&#39;s captured in the JIRA ticket, in my case there are no generics involved.<br></p><p>Would you mind if I updated this ticket with the additional info related to the scenario I hit?<br></p><p><br></p><p>&gt; On Mar 8, 2016, at 5:41 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi, Evan. Just a suspicion: do you also have a type named AppleTart? In that case you&#39;d be hitting SR-898 &lt;https://bugs.swift.org/browse/SR-898&gt;, rather than a specific issue with extensions.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 14:26, Evan Maloney via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I recently ran into a situation where I needed to import a symbol with the same name from two different modules, and noticed that the usual Swift technique of disambiguating using the package name doesn&#39;t work when used with extensions.<br>&gt;&gt; <br>&gt;&gt; In my case, I have a package &#39;LegacyStore&#39; and a package &#39;AppleTart&#39;, both of which contain a type named &#39;User&#39;.<br>&gt;&gt; <br>&gt;&gt; In the case of LegacyStore, User is an Objective-C class, and in the case of AppleTart, User is a Swift struct.<br>&gt;&gt; <br>&gt;&gt; Normally, I&#39;d be able to refer to one as &#39;LegacyStore.User&#39; and the other as &#39;AppleTart.User&#39;, but when using this notation for an extension:<br>&gt;&gt; <br>&gt;&gt;    extension AppleTart.User<br>&gt;&gt;    {<br>&gt;&gt;        public var legacyUser: LegacyStore.User {<br>&gt;&gt;            // implementation<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; ...I get a compiler error on the extension declaration line:<br>&gt;&gt; <br>&gt;&gt;    error: &#39;User&#39; is not a member type of &#39;AppleTart&#39;<br>&gt;&gt; <br>&gt;&gt; Note that the &#39;LegacyStore.User&#39; notation used in the var declaration never triggers a compiler error, so I&#39;m assuming the notation just isn&#39;t supported yet in the context of declaring an extension.<br>&gt;&gt; <br>&gt;&gt; Fortunately, there&#39;s a (somewhat cumbersome) work-around, which is to create two separate files, one for each module. Within each file import just that one module, and create a typealias for each clashing name using package-qualified name of the type.<br>&gt;&gt; <br>&gt;&gt; For example, here&#39;s the relevant part of my AppleTartTypeDisambiguation.swift file:<br>&gt;&gt; <br>&gt;&gt;    import AppleTart<br>&gt;&gt; <br>&gt;&gt;    public typealias AppleTartUser = User<br>&gt;&gt; <br>&gt;&gt; And here&#39;s my LegacyStoreTypeDisambiguation.swift file:<br>&gt;&gt; <br>&gt;&gt;    import LegacyStore<br>&gt;&gt; <br>&gt;&gt;    public typealias LegacyUser = User<br>&gt;&gt; <br>&gt;&gt; I can then use the typealiases to extend either type. For example, here&#39;s how I successfully extended AppleTart.User:<br>&gt;&gt; <br>&gt;&gt;    extension AppleTartUser<br>&gt;&gt;    {<br>&gt;&gt;        public var legacyUser: LegacyStore.User {<br>&gt;&gt;            // implementation<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Should the inability to extend a type using the qualified type name be considered a compiler bug? I&#39;m assuming yes. If so, I&#39;ll file a ticket.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160309/97e2175e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Possible compiler bug? Unable to extend a type whose name clashes</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March  9, 2016 at 09:00:00am</p></header><div class="content"><p>Sure, go ahead. (The associated Radar also deals with a non-generic type; sorry I didn&#39;t include that in the SR.)<br></p><p>Jordan<br></p><p><br>&gt; On Mar 9, 2016, at 8:23 , Evan Maloney &lt;emaloney at gilt.com&gt; wrote:<br>&gt; <br>&gt; Thanks a lot, Jordan; your suspicion is correct! That appears to be the issue I&#39;m having--although unlike what&#39;s captured in the JIRA ticket, in my case there are no generics involved.<br>&gt; <br>&gt; Would you mind if I updated this ticket with the additional info related to the scenario I hit?<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 8, 2016, at 5:41 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi, Evan. Just a suspicion: do you also have a type named AppleTart? In that case you&#39;d be hitting SR-898 &lt;https://bugs.swift.org/browse/SR-898&gt;, rather than a specific issue with extensions.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 8, 2016, at 14:26, Evan Maloney via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I recently ran into a situation where I needed to import a symbol with the same name from two different modules, and noticed that the usual Swift technique of disambiguating using the package name doesn&#39;t work when used with extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my case, I have a package &#39;LegacyStore&#39; and a package &#39;AppleTart&#39;, both of which contain a type named &#39;User&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case of LegacyStore, User is an Objective-C class, and in the case of AppleTart, User is a Swift struct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Normally, I&#39;d be able to refer to one as &#39;LegacyStore.User&#39; and the other as &#39;AppleTart.User&#39;, but when using this notation for an extension:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension AppleTart.User<br>&gt;&gt;&gt;    {<br>&gt;&gt;&gt;        public var legacyUser: LegacyStore.User {<br>&gt;&gt;&gt;            // implementation<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...I get a compiler error on the extension declaration line:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    error: &#39;User&#39; is not a member type of &#39;AppleTart&#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the &#39;LegacyStore.User&#39; notation used in the var declaration never triggers a compiler error, so I&#39;m assuming the notation just isn&#39;t supported yet in the context of declaring an extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fortunately, there&#39;s a (somewhat cumbersome) work-around, which is to create two separate files, one for each module. Within each file import just that one module, and create a typealias for each clashing name using package-qualified name of the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, here&#39;s the relevant part of my AppleTartTypeDisambiguation.swift file:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    import AppleTart<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public typealias AppleTartUser = User<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And here&#39;s my LegacyStoreTypeDisambiguation.swift file:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    import LegacyStore<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    public typealias LegacyUser = User<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can then use the typealiases to extend either type. For example, here&#39;s how I successfully extended AppleTart.User:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension AppleTartUser<br>&gt;&gt;&gt;    {<br>&gt;&gt;&gt;        public var legacyUser: LegacyStore.User {<br>&gt;&gt;&gt;            // implementation<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should the inability to extend a type using the qualified type name be considered a compiler bug? I&#39;m assuming yes. If so, I&#39;ll file a ticket.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160309/ff8576f1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
