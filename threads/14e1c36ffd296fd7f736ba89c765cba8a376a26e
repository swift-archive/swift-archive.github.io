<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>on Sat Apr 23 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Currently, Comparable looks like this:<br>&gt;<br>&gt; 	public protocol Comparable : Equatable {<br>&gt; 	  /// A [strict total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt; 	  /// over instances of `Self`.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	}<br>&gt;<br>&gt; Simple and straightforward, but not actually accurate. In a strict<br>&gt; total order, all elements are ordered, but that&#39;s not true of the<br>&gt; current Comparable. For instance, floating-point NaNs are not ordered.<br>&gt;<br>&gt; The FloatingPoint proposal (SE-0067,<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;)<br>&gt; suggests that Comparable&#39;s requirements should be weakened so that<br>&gt; only &quot;normal&quot; members of types need to be ordered, while &quot;exceptional&quot;<br>&gt; members like NaNs are permitted to violate the rules. In practice,<br>&gt; though, this ends up making algorithms give bizarre and incorrect<br>&gt; results:<br>&gt;<br>&gt; 	Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.1 clang-703.0.29). Type :help for assistance. <br>&gt; 	  1&gt; let numbers = Array(0.0.stride(to: 1.0, by: 0.2)) + [.NaN] + Array(1.0.stride(to: 0.0, by: -0.25)) <br>&gt; 	numbers: [Double] = 10 values {<br>&gt; 	  [0] = 0<br>&gt; 	  [1] = 0.20000000000000001<br>&gt; 	  [2] = 0.40000000000000002<br>&gt; 	  [3] = 0.60000000000000009<br>&gt; 	  [4] = 0.80000000000000004<br>&gt; 	  [5] = NaN<br>&gt; 	  [6] = 1<br>&gt; 	  [7] = 0.75<br>&gt; 	  [8] = 0.5<br>&gt; 	  [9] = 0.25<br>&gt; 	}<br>&gt; 	  2&gt; numbers.sort()<br>&gt; 	$R1: [Double] = 10 values {<br>&gt; 	  [0] = 0<br>&gt; 	  [1] = 0.20000000000000001<br>&gt; 	  [2] = 0.40000000000000002<br>&gt; 	  [3] = 0.60000000000000009<br>&gt; 	  [4] = 0.80000000000000004<br>&gt; 	  [5] = NaN<br>&gt; 	  [6] = 0.25<br>&gt; 	  [7] = 0.5<br>&gt; 	  [8] = 0.75<br>&gt; 	  [9] = 1<br>&gt; 	}<br>&gt;<br>&gt; (Note that the behavior is actually much stranger than simply having the NaN act as a partition of the listâ€”try sorting `Array(0.0.stride(to: 1.0, by: 0.1)) + [.NaN] + Array(0.0.stride(to: 1.0, by: 0.1))` to see what I mean. I&#39;m sure there are sensible implementation reasons why `sort()` behaves this way, but they aren&#39;t really relevant to this discussion.)<br>&gt;<br>&gt; To address this, FloatingPoint introduces an ad-hoc mechanism: there is a `totalOrder` method in the protocol which actually *does* sort NaNs in a useful way. But because this is ad-hoc, it can&#39;t be extended to other, non-floating-point types. And since it&#39;s not part of Comparable, the plain `sort()` (well, `sorted()` in Swift 3) method on Sequences of Comparable elements doesn&#39;t use it. That&#39;s not great; the type system shouldn&#39;t lead us astray like this.<br>&gt;<br>&gt; I think we should go in the other direction. Rather than weakening Comparable&#39;s promises, I think we should instead strengthen and clarify them.<br>&gt;<br>&gt; In short, I propose we:<br>&gt;<br>&gt; * Introduce a new `&lt;=&gt;` operator which implements a strict total<br>&gt; ordering on the Comparable type. Rather than returning a `Bool`, it<br>&gt; returns a new `Order` type which is similar to<br>&gt; `NSComparisonResult`. This provides a semantic hint that non-ordering<br>&gt; is not an option for `&lt;=&gt;`.<br></p><p>That has been my plan for some time.<br></p><p>&gt; * Introduce a new `&lt;&gt;` operator which captures the concept of two<br>&gt; values being unordered relative to one another. For example, `1.0 &lt;&gt;<br>&gt; .nan` would be `true`.<br></p><p>Cute.  I&#39;m not sure we need this operator, though.  Is this a test you<br>actually want in real code often enough to make it worth having?<br></p><p>&gt; * Define the friendly comparison operators like `&lt;` and `==` as being<br>&gt; a partial order covering all values which are not `&lt;&gt;`.  <br></p><p>Natch&#39;.<br></p><p>&gt; * Include default implementations such that you only need to define<br>&gt; `&lt;=&gt;`; `&lt;&gt;` is always `false` by default, and the other operators call<br>&gt; through to `&lt;=&gt;` and `&lt;&gt;` to determine the correct values to return.<br></p><p>I think you can do the default implementations of `&lt;`, `&gt;`, `&lt;=`, `&gt;=`,<br>`==` and `!=` using just `&lt;=&gt;`.  Why involve `&lt;&gt;`?<br></p><p>&gt; * Redefine functions like `sorted(_:)` and `max(_:)` to take a total<br>&gt; ordering function returning an `Order`, not a partial ordering<br>&gt; function returning a `Bool`. <br></p><p>They don&#39;t accept partial ordering functions today.<br></p><p>&gt; In other words, you would pass `&lt;=&gt;` instead of `&lt;`.<br></p><p>One problem I haven&#39;t come to a conclusion about is the total- vs<br>strict-weak- ordering question.  For me, this area is where most of the<br>uncertainty about pursuing something like this lies, and once we get it<br>sorted out I&#39;d be very happy to move ahead.  I&#39;m sure it&#39;s doable but I<br>just haven&#39;t had the time to devote.  In short:<br></p><p>Almost all types can reasonably implement a total order, but almost any<br>algorithm that can be implemented with just a binary comparison<br>predicate (sort, binary search, partition, et al) only needs a strict<br>weak ordering to produce sensible results, because as far as the<br>ordering is concerned, unordered values appear to be equivalent.<br></p><p>In fact it seems to me that the distinction between a total ordering and<br>a strict-weak ordering is *only* observable in the presence of an<br>equality comparison.  When an algorithm takes a single comparison<br>function (whether it has binary or trinary results) and doesn&#39;t<br>additionally require Equatable conformance, there is no reason<br>whatsoever to require a total ordering, and you can easily argue that it<br>is meaningless to do so.<br></p><p>[If you&#39;re reading along and wondering what all these kinds of orderings are<br>about, I once figured that out and wrote a blog post about it:<br>http://web.archive.org/web/20120422220137/http://cpp-next.com/archive/2010/02/order-i-say/]<br></p><p>&gt; Here&#39;s what the new `Comparable` might look like:<br>&gt;<br>&gt; 	public enum Order {<br>&gt; 	  case firstEarlier<br>&gt; 	  case bothEqual<br>&gt; 	  case firstLater<br>&gt; 	}<br>&gt;<br>&gt; 	/// Instances of conforming types can be compared using relational operators.<br>&gt; 	/// <br>&gt; 	/// Comparable includes both a total order, which sorts all possible values, <br>&gt; 	/// and a partial order, which compares only &quot;normal&quot; or &quot;common&quot; values.<br>&gt; 	/// The partial order may consider some elements &quot;unordered&quot; and return `false` <br>&gt; 	/// for all operations.<br>&gt; 	/// <br>&gt; 	/// The `&lt;=&gt;` operator implements the total order; the others implement the <br>&gt; 	/// partial order. You may define only the total order, and `Comparable` will <br>&gt; 	/// provide default implementations which use it. You may also define both the <br>&gt; 	/// `&lt;=&gt;` operator and the `&lt;&gt;` &quot;unordered&quot; operator, and Comparable will <br>&gt; 	/// provide default implementations for the rest of the partial order which them. <br>&gt; 	/// You may also choose to implement the `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==`, and <br>&gt; 	/// `!=` operators to completely customize the implementation.<br>&gt; 	public protocol Comparable : Equatable {<br>&gt; 	  /// A [total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt; 	  /// over instances of `Self`. In a total order, no element is permitted to be <br>&gt; 	  /// unordered relative to any other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Order<br>&gt;<br>&gt; 	  /// Returns `true` if, to partial order operators like `&lt;` and `==`, `lhs` is <br>&gt; 	  /// unordered relative to `rhs`.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  /// Returns `true` if `lhs` is less than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  /// Returns `true` if `lhs` is greater than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  /// Returns `true` if `lhs` is less than or equal to `rhs`. Should be consistent with `&lt;=&gt;` <br>&gt; 	  /// except when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt; 	  /// Returns `true` if `lhs` is greater than or equal to `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	}<br>&gt;<br>&gt; Some APIs on Order which might be useful:<br>&gt;<br>&gt; 	public extension Order {<br>&gt; 	  /// Returns the equivalent order for the two arguments reversed.<br>&gt; 	  func reversed() -&gt; Order {â€¦}<br>&gt; 	  /// Returns `x` and `y` reordered according to `self`, with the earlier one first.<br>&gt; 	  func reorder&lt;T&gt;(_ x: T, _ y: T) -&gt; (T, T) {â€¦}<br>&gt; 	  /// Returns `x` and `y` reordered with the earlier one first.<br>&gt; 	  static func reorder&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; (T, T) {â€¦}<br>&gt; 	}<br>&gt;<br>&gt; Alternate designs:<br>&gt;<br>&gt; * The `&lt;&gt;` operator is arguably not very obvious, or too confusable<br>&gt; with some languages&#39; use of that operator for &quot;not equals&quot;. It could<br>&gt; instead be a different operator, an instance method, or a class<br>&gt; method.<br>&gt;<br>&gt; * It might make sense to instead use `&lt;&gt;` to say &quot;is comparable&quot; and<br>&gt; `!&lt;&gt;` to say &quot;is incomparable&quot;.<br>&gt;<br>&gt; * It may also be better to define Comparable such that certain<br>&gt; *values* are incomparable with any value, rather than certain *pairs*<br>&gt; of values being incomparable. If so, we would want an `isIncomparable`<br>&gt; property instead of a method or function. That works for<br>&gt; `FloatingPoint`, but it might not suit other types. (For instance,<br>&gt; with the `&lt;&gt;` operator in place, `String.Index` could be made<br>&gt; incomparable with indices from other strings, but all `String.Index`es<br>&gt; would still have a total order. That design wouldn&#39;t be possible with<br>&gt; an `isIncomparable` property.)<br>&gt;<br>&gt; * The `&lt;=&gt;` operator is common from other languages, but it might<br>&gt; still be too jargony. One interesting design for this would be to<br>&gt; expose the total order as a method on `Comparable` which is used as an<br>&gt; implementation hook for an `Order.init(_:_:)` initializer.<br>&gt;<br>&gt; * The cases of Order are highly bikesheddable. I like these names more<br>&gt; than `ascending` and `descending` because I have an easier time<br>&gt; understanding what they mean, but others might disagree.<br>&gt;<br>&gt; * I&#39;m also toying with the idea that the partial order, which includes<br>&gt; `==`, may have a looser definition of equality than the total order;<br>&gt; this would mean that, for instance, `String`&#39;s total order could fall<br>&gt; back to `UnicodeScalar.value` comparison to distinguish between<br>&gt; strings which have equal graphemes. I&#39;m not sure how useful that would<br>&gt; be in practice, though.<br>&gt;<br>&gt;<br>&gt; Any thoughts?<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
