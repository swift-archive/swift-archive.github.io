<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  8, 2016 at 11:00:00pm</p></header><div class="content"><p>(No joking)<br>Points:<br></p><p>1. When nil was added to the language, we could not infer enumeration type:<br>if x != Optional.none { ... }<br></p><p>Now it looks like this:<br>if x != .none { ... }<br></p><p>If at this point we had a proposal to add nil as a replacement for .none,<br>would we accept it?<br></p><p>2. nil is very generic, it only approximately allows to express the<br>intentions.<br>In case of Optional, .none is clearer. In case of JSON processing, .null is<br>clearer. In case of a semantically nullable struct, NilLiteralConvertible<br>usually goes to default constructor.<br></p><p>3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br></p><p>4. There should be a single consistent terminology: no value in Swift<br>equals none.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/f34a1492/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I think you know I am very +1 on this :)<br></p><p>Brandon<br></p><p>&gt; On Jun 8, 2016, at 4:41 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (No joking)<br>&gt; Points:<br>&gt; <br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt; <br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt; <br>&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; <br>&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; <br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; <br>&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>It&#39;s been pointed out before that Optional being an enum type is treated<br>like an implementation detail. Currently, it is possible to teach the<br>concept of Optional without introducing enum types or generics. How would<br>you do so after elimination of nil?<br></p><p><br>On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; (No joking)<br>&gt; Points:<br>&gt;<br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt;<br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt;<br>&gt; If at this point we had a proposal to add nil as a replacement for .none,<br>&gt; would we accept it?<br>&gt;<br>&gt; 2. nil is very generic, it only approximately allows to express the<br>&gt; intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null<br>&gt; is clearer. In case of a semantically nullable struct,<br>&gt; NilLiteralConvertible usually goes to default constructor.<br>&gt;<br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;<br>&gt; 4. There should be a single consistent terminology: no value in Swift<br>&gt; equals none.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/050eaa2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>.none or a more appropriate keyword like “none” (imo)<br></p><p>Brandon<br></p><p>&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt; <br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; (No joking)<br>&gt; Points:<br>&gt; <br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt; <br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt; <br>&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; <br>&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; <br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; <br>&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/2e62506a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt; <br>&gt; Brandon<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; (No joking)<br>&gt;&gt; Points:<br>&gt;&gt; <br>&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt; <br>&gt;&gt; Now it looks like this:<br>&gt;&gt; if x != .none { ... }<br>&gt;&gt; <br>&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt; <br>&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt; <br>&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt; <br>&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt; <br>&gt;&gt; - Anton<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br></p><p>I understand how nil works in the context of other languages. But looking at Optional:<br>public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br></p><p>    /// The absence of a value.<br>    ///<br>    /// In code, the absence of a value is typically written using the `nil`<br>    /// literal rather than the explicit `.none` enumeration case.<br>    case none<br></p><p>    /// The presence of a value, stored as `Wrapped`.<br>    case some(Wrapped)<br>}<br></p><p><br>These are not pointers and they sure look like one when you assign nil to an optional<br></p><p>B<br></p><p>Why would nil be chosen to represent the none case in the absence of other languages?<br></p><p><br>&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt; <br>&gt;&gt; Brandon<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt; Points:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/bb4bbcb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br></p><p>If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt; <br>&gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt; <br>&gt;     /// The absence of a value.<br>&gt;     ///<br>&gt;     /// In code, the absence of a value is typically written using the `nil`<br>&gt;     /// literal rather than the explicit `.none` enumeration case.<br>&gt;     case none<br>&gt; <br>&gt;     /// The presence of a value, stored as `Wrapped`.<br>&gt;     case some(Wrapped)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt; <br>&gt; B<br>&gt; <br>&gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt;&gt; Points:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>I think we also need to consider newbies coming from other languages. “nil”<br>being a holdover makes it easier to understand what it means, having a<br>“.none”/“none” duality makes it both seem inconsistent as well as dredge up<br>language implementation details-now you have to explain that Optionals are<br>actually enums internally. Using nil doesn’t lead to this kind of scenario,<br>and they already (mostly) know what it means from other languages.<br></p><p>On Wed, Jun 8, 2016 at 2:13 PM Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If there’s both “.none” and “none”, then I think that’d be more confusing<br>&gt; *because of* the naming consistency, IMO. I’d look at that as a newbie and<br>&gt; wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt;<br>&gt; If enum cases could be referred to without the leading “.” then perhaps I<br>&gt; could get behind this because “none” wouldn’t even need to be a keyword at<br>&gt; all in that case, but there are probably difficult ambiguities down that<br>&gt; road.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; 1. People will find .none ugly which is why I think it could be replaced<br>&gt; by a none keyword. It is awkward<br>&gt; &gt; 2. none is more descriptive than nil in this case. The case is named<br>&gt; none (consistency!) and nil is a holdover from other languages<br>&gt; &gt;<br>&gt; &gt; I understand how nil works in the context of other languages. But<br>&gt; looking at Optional:<br>&gt; &gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt; &gt;<br>&gt; &gt;     /// The absence of a value.<br>&gt; &gt;     ///<br>&gt; &gt;     /// In code, the absence of a value is typically written using the<br>&gt; `nil`<br>&gt; &gt;     /// literal rather than the explicit `.none` enumeration case.<br>&gt; &gt;     case none<br>&gt; &gt;<br>&gt; &gt;     /// The presence of a value, stored as `Wrapped`.<br>&gt; &gt;     case some(Wrapped)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; These are not pointers and they sure look like one when you assign nil<br>&gt; to an optional<br>&gt; &gt;<br>&gt; &gt; B<br>&gt; &gt;<br>&gt; &gt; Why would nil be chosen to represent the none case in the absence of<br>&gt; other languages?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you add a new keyword called “none” without the period, but keep<br>&gt; allowing “.none” to work because Optional is really an enum… then I don’t<br>&gt; really see what has been gained here at all - you’re basically back to<br>&gt; nil/.none =&gt; 2 ways to say the same thing!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; l8r<br>&gt; &gt;&gt; Sean<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Brandon<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is<br>&gt; treated like an implementation detail. Currently, it is possible to teach<br>&gt; the concept of Optional without introducing enum types or generics. How<br>&gt; would you do so after elimination of nil?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; (No joking)<br>&gt; &gt;&gt;&gt;&gt; Points:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration<br>&gt; type:<br>&gt; &gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Now it looks like this:<br>&gt; &gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for<br>&gt; .none, would we accept it?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the<br>&gt; intentions.<br>&gt; &gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing,<br>&gt; .null is clearer. In case of a semantically nullable struct,<br>&gt; NilLiteralConvertible usually goes to default constructor.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift<br>&gt; equals none.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; - Anton<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/5ed677ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Yes it is the same keyword, but is it the same behavior from other languages?<br></p><p>Brandon<br></p><p>&gt; On Jun 8, 2016, at 5:20 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think we also need to consider newbies coming from other languages. “nil” being a holdover makes it easier to understand what it means, having a “.none”/“none” duality makes it both seem inconsistent as well as dredge up language implementation details-now you have to explain that Optionals are actually enums internally. Using nil doesn’t lead to this kind of scenario, and they already (mostly) know what it means from other languages.<br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 2:13 PM Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt; <br>&gt; If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt; &gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt; &gt;<br>&gt; &gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt; &gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt; &gt;<br>&gt; &gt;     /// The absence of a value.<br>&gt; &gt;     ///<br>&gt; &gt;     /// In code, the absence of a value is typically written using the `nil`<br>&gt; &gt;     /// literal rather than the explicit `.none` enumeration case.<br>&gt; &gt;     case none<br>&gt; &gt;<br>&gt; &gt;     /// The presence of a value, stored as `Wrapped`.<br>&gt; &gt;     case some(Wrapped)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt; &gt;<br>&gt; &gt; B<br>&gt; &gt;<br>&gt; &gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; l8r<br>&gt; &gt;&gt; Sean<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Brandon<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; (No joking)<br>&gt; &gt;&gt;&gt;&gt; Points:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; &gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Now it looks like this:<br>&gt; &gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; &gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; - Anton<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/35608996/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>When isn’t it?<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Jun 8, 2016, at 4:22 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; Yes it is the same keyword, but is it the same behavior from other languages?<br>&gt; <br>&gt; Brandon<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 5:20 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think we also need to consider newbies coming from other languages. “nil” being a holdover makes it easier to understand what it means, having a “.none”/“none” duality makes it both seem inconsistent as well as dredge up language implementation details-now you have to explain that Optionals are actually enums internally. Using nil doesn’t lead to this kind of scenario, and they already (mostly) know what it means from other languages.<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 2:13 PM Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt;&gt; <br>&gt;&gt; If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt;&gt; &gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt;&gt; &gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     /// The absence of a value.<br>&gt;&gt; &gt;     ///<br>&gt;&gt; &gt;     /// In code, the absence of a value is typically written using the `nil`<br>&gt;&gt; &gt;     /// literal rather than the explicit `.none` enumeration case.<br>&gt;&gt; &gt;     case none<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     /// The presence of a value, stored as `Wrapped`.<br>&gt;&gt; &gt;     case some(Wrapped)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; B<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; l8r<br>&gt;&gt; &gt;&gt; Sean<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Brandon<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt; (No joking)<br>&gt;&gt; &gt;&gt;&gt;&gt; Points:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt; &gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt; &gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt; &gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; - Anton<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; -- <br>&gt;&gt; -Saagar Jha<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Here I have a contrived example (I am bad at trying to explain my point -_-):<br></p><p>When I see nil, I think of reference types. I.e. Objective-C:<br></p><p>NSMutableString *mutableString = [[NSMutableString alloc] initWithString:@&quot;123&quot;];<br>__weak NSMutableString *reference = mutableString;<br>    <br>reference = mutableString;<br>    <br>[reference appendString:@&quot;456&quot;];<br>mutableString = nil;<br></p><p>//memory is now deallocated because strong references are eliminated<br>// BUT reference is now nil! This is expected with reference types<br></p><p>In Objective-C we have to use nil to manage when objects are deallocated. We also have to use __weak to avoid retain cycles etc...<br></p><p>This behavior is consistent with other languages with reference semantics.<br></p><p>However, in Swift, optionals are value types as we all know (though they can wrap reference types):<br></p><p>var number1: Int? = nil<br>var number2: Int? = number1<br></p><p>number1 == number2<br></p><p>number1 = 3<br>number2 == number1 // FALSE. This behavior is obviously different from Objective-C and we expect that knowing that it’s a value type<br></p><p><br>On first look, it looks like reference semantics because you see nil and remember it from other languages. OR you learn this behavior in Swift and expect it to work the same in other languages. Either way the behavior isn’t exactly consistent between all languages. Even nil in Objective-C is different than most languages because you are allowed to send messages to it.<br></p><p>As far as I know, setting:<br>number1 = nil<br></p><p>does not deallocate number1. It is still an optional with enough space to wrap an Int that happens to just be set to .none currently.<br></p><p>It looks like you are deallocating something if that is the behavior you expect from other languages upon seeing nil.<br></p><p>nil can have similar behaviors in both languages, but they can also have very dissimilar behaviors too.<br></p><p>My main point comes down to: nil makes it look like a pointer and thus makes you see it as a reference type at first glance until you completely retrain yourself. This is not how nil works with values in Swift and I think some might find that surprising down the road when:<br>A) They learn Swift first and move to another language and see a different behavior than they are use to<br>B) They come from another language and associate seeing nil with the type being a reference and being surprised<br></p><p>or C…you just have to remember the differences.<br></p><p>I probably made my point even worse but I can only try!<br>Brandon<br></p><p><br></p><p>&gt; On Jun 8, 2016, at 5:37 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; When isn’t it?<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:22 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes it is the same keyword, but is it the same behavior from other languages?<br>&gt;&gt; <br>&gt;&gt; Brandon<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 5:20 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we also need to consider newbies coming from other languages. “nil” being a holdover makes it easier to understand what it means, having a “.none”/“none” duality makes it both seem inconsistent as well as dredge up language implementation details-now you have to explain that Optionals are actually enums internally. Using nil doesn’t lead to this kind of scenario, and they already (mostly) know what it means from other languages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 8, 2016 at 2:13 PM Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt;&gt;&gt;&gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt;&gt;&gt;&gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    /// The absence of a value.<br>&gt;&gt;&gt;&gt;    ///<br>&gt;&gt;&gt;&gt;    /// In code, the absence of a value is typically written using the `nil`<br>&gt;&gt;&gt;&gt;    /// literal rather than the explicit `.none` enumeration case.<br>&gt;&gt;&gt;&gt;    case none<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    /// The presence of a value, stored as `Wrapped`.<br>&gt;&gt;&gt;&gt;    case some(Wrapped)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; B<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Points:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/551b7e2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a7a6eec529bcd543e8936a8390129716?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Emanuel Andrada</string> &lt;emanuel at aijunasys.com.ar&gt;<p>June 10, 2016 at 11:00:00am</p></header><div class="content"><p>The same example won’t work in objective-c<br>number1 and number2 are two different variables that holds different values. When you are assigning number2 = number1 you’re copying the value. And when you are comparing number1 == number2 you are comparing values, that are the same because one is a copy of the another. With objects, it’s the same, as references are values too. Try this:<br></p><p>&gt; var number1: AnyObject? = NSObject()<br>&gt; var number2: AnyObject? = number1<br>&gt; <br>&gt; number1 === number2 // == does not work here because AnyObject is not Equatable<br>&gt; <br>&gt; number1 = NSObject()<br>&gt; number2 === number1 // FALSE.<br></p><p><br>You can do the same in objective-c with the same result.<br></p><p><br>&gt; El 8 jun 2016, a las 19:57, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt; <br>&gt; Here I have a contrived example (I am bad at trying to explain my point -_-):<br>&gt; <br>&gt; When I see nil, I think of reference types. I.e. Objective-C:<br>&gt; <br>&gt; NSMutableString *mutableString = [[NSMutableString alloc] initWithString:@&quot;123&quot;];<br>&gt; __weak NSMutableString *reference = mutableString;<br>&gt; <br>&gt; reference = mutableString;<br>&gt; <br>&gt; [reference appendString:@&quot;456&quot;];<br>&gt; mutableString = nil;<br>&gt; <br>&gt; //memory is now deallocated because strong references are eliminated<br>&gt; // BUT reference is now nil! This is expected with reference types<br>&gt; <br>&gt; In Objective-C we have to use nil to manage when objects are deallocated. We also have to use __weak to avoid retain cycles etc...<br>&gt; <br>&gt; This behavior is consistent with other languages with reference semantics.<br>&gt; <br>&gt; However, in Swift, optionals are value types as we all know (though they can wrap reference types):<br>&gt; <br>&gt; var number1: Int? = nil<br>&gt; var number2: Int? = number1<br>&gt; <br>&gt; number1 == number2<br>&gt; <br>&gt; number1 = 3<br>&gt; number2 == number1 // FALSE. This behavior is obviously different from Objective-C and we expect that knowing that it’s a value type<br>&gt; <br>&gt; <br>&gt; On first look, it looks like reference semantics because you see nil and remember it from other languages. OR you learn this behavior in Swift and expect it to work the same in other languages. Either way the behavior isn’t exactly consistent between all languages. Even nil in Objective-C is different than most languages because you are allowed to send messages to it.<br>&gt; <br>&gt; As far as I know, setting:<br>&gt; number1 = nil<br>&gt; <br>&gt; does not deallocate number1. It is still an optional with enough space to wrap an Int that happens to just be set to .none currently.<br>&gt; <br>&gt; It looks like you are deallocating something if that is the behavior you expect from other languages upon seeing nil.<br>&gt; <br>&gt; nil can have similar behaviors in both languages, but they can also have very dissimilar behaviors too.<br>&gt; <br>&gt; My main point comes down to: nil makes it look like a pointer and thus makes you see it as a reference type at first glance until you completely retrain yourself. This is not how nil works with values in Swift and I think some might find that surprising down the road when:<br>&gt; A) They learn Swift first and move to another language and see a different behavior than they are use to<br>&gt; B) They come from another language and associate seeing nil with the type being a reference and being surprised<br>&gt; <br>&gt; or C…you just have to remember the differences.<br>&gt; <br>&gt; I probably made my point even worse but I can only try!<br>&gt; Brandon<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 5:37 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When isn’t it?<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 4:22 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes it is the same keyword, but is it the same behavior from other languages?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 5:20 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we also need to consider newbies coming from other languages. “nil” being a holdover makes it easier to understand what it means, having a “.none”/“none” duality makes it both seem inconsistent as well as dredge up language implementation details-now you have to explain that Optionals are actually enums internally. Using nil doesn’t lead to this kind of scenario, and they already (mostly) know what it means from other languages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 2:13 PM Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt;&gt;&gt;&gt;&gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt;&gt;&gt;&gt;&gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    /// The absence of a value.<br>&gt;&gt;&gt;&gt;&gt;    ///<br>&gt;&gt;&gt;&gt;&gt;    /// In code, the absence of a value is typically written using the `nil`<br>&gt;&gt;&gt;&gt;&gt;    /// literal rather than the explicit `.none` enumeration case.<br>&gt;&gt;&gt;&gt;&gt;    case none<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    /// The presence of a value, stored as `Wrapped`.<br>&gt;&gt;&gt;&gt;&gt;    case some(Wrapped)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; B<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; l8r<br>&gt;&gt;&gt;&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Points:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/b24fb1bb/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 842 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/b24fb1bb/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>I was thinking about this too…but I’m not sure how feasible it would be.<br></p><p>However, I don’t find this any more confusing than having two ways to refer to it currently: nil and .none<br></p><p>none == sugar<br>.none == the underlying implementation of optional as Xiaodi put it (I am starting to see this view)<br></p><p>Brandon<br></p><p><br>&gt; On Jun 8, 2016, at 5:13 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; If there’s both “.none” and “none”, then I think that’d be more confusing *because of* the naming consistency, IMO. I’d look at that as a newbie and wonder why in the world this word sometimes has a dot and sometimes doesn’t.<br>&gt; <br>&gt; If enum cases could be referred to without the leading “.” then perhaps I could get behind this because “none” wouldn’t even need to be a keyword at all in that case, but there are probably difficult ambiguities down that road.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:04 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. People will find .none ugly which is why I think it could be replaced by a none keyword. It is awkward<br>&gt;&gt; 2. none is more descriptive than nil in this case. The case is named none (consistency!) and nil is a holdover from other languages<br>&gt;&gt; <br>&gt;&gt; I understand how nil works in the context of other languages. But looking at Optional:<br>&gt;&gt; public enum Optional&lt;Wrapped&gt; : NilLiteralConvertible {<br>&gt;&gt; <br>&gt;&gt;    /// The absence of a value.<br>&gt;&gt;    ///<br>&gt;&gt;    /// In code, the absence of a value is typically written using the `nil`<br>&gt;&gt;    /// literal rather than the explicit `.none` enumeration case.<br>&gt;&gt;    case none<br>&gt;&gt; <br>&gt;&gt;    /// The presence of a value, stored as `Wrapped`.<br>&gt;&gt;    case some(Wrapped)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; These are not pointers and they sure look like one when you assign nil to an optional<br>&gt;&gt; <br>&gt;&gt; B<br>&gt;&gt; <br>&gt;&gt; Why would nil be chosen to represent the none case in the absence of other languages?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 4:55 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you add a new keyword called “none” without the period, but keep allowing “.none” to work because Optional is really an enum… then I don’t really see what has been gained here at all - you’re basically back to nil/.none =&gt; 2 ways to say the same thing!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 3:52 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt;&gt;&gt; Points:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Jun 8, 2016 at 3:52 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;<br>&gt;<br>My point is that `.none` exposes the underlying enum. The premise here is<br>that the enum is an implementation detail. You&#39;ll notice that, currently,<br>significant sugar and magic is devoted to allowing you to work with<br>optionals without ever writing `.some` or `none`. For example, `if let x =<br>...` and friends allow you to avoid writing `if case .some(let x) = ...`,<br>while you can write `return x` instead of `return .some(x)`. This was,<br>IIUC, a deliberate choice to allow progressive disclosure of the language<br>to learners. Renaming `nil` to `none` is a different proposal from Anton is<br>proposing here.<br></p><p><br>&gt; Brandon<br>&gt;<br>&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s been pointed out before that Optional being an enum type is treated<br>&gt; like an implementation detail. Currently, it is possible to teach the<br>&gt; concept of Optional without introducing enum types or generics. How would<br>&gt; you do so after elimination of nil?<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; (No joking)<br>&gt;&gt; Points:<br>&gt;&gt;<br>&gt;&gt; 1. When nil was added to the language, we could not infer enumeration<br>&gt;&gt; type:<br>&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;<br>&gt;&gt; Now it looks like this:<br>&gt;&gt; if x != .none { ... }<br>&gt;&gt;<br>&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none,<br>&gt;&gt; would we accept it?<br>&gt;&gt;<br>&gt;&gt; 2. nil is very generic, it only approximately allows to express the<br>&gt;&gt; intentions.<br>&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null<br>&gt;&gt; is clearer. In case of a semantically nullable struct,<br>&gt;&gt; NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;<br>&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;<br>&gt;&gt; 4. There should be a single consistent terminology: no value in Swift<br>&gt;&gt; equals none.<br>&gt;&gt;<br>&gt;&gt; - Anton<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/dcb69736/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Is it really an implementation detail? It is very leaky if it is one because it is highly exposed to everyone.<br></p><p>Regardless of whether or not it is an implementation detail, nil does not adequately describe the “none” case it is trying to represent in my opinion<br></p><p>B<br></p><p><br>&gt; On Jun 8, 2016, at 4:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 3:52 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt; <br>&gt; <br>&gt; My point is that `.none` exposes the underlying enum. The premise here is that the enum is an implementation detail. You&#39;ll notice that, currently, significant sugar and magic is devoted to allowing you to work with optionals without ever writing `.some` or `none`. For example, `if let x = ...` and friends allow you to avoid writing `if case .some(let x) = ...`, while you can write `return x` instead of `return .some(x)`. This was, IIUC, a deliberate choice to allow progressive disclosure of the language to learners. Renaming `nil` to `none` is a different proposal from Anton is proposing here.<br>&gt;  <br>&gt; Brandon<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; (No joking)<br>&gt;&gt; Points:<br>&gt;&gt; <br>&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt; <br>&gt;&gt; Now it looks like this:<br>&gt;&gt; if x != .none { ... }<br>&gt;&gt; <br>&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt; <br>&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt; <br>&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt; <br>&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt; <br>&gt;&gt; - Anton<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/47b72362/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Jun 8, 2016 at 3:59 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br></p><p>&gt; Is it really an implementation detail? It is very leaky if it is one<br>&gt; because it is highly exposed to everyone.<br>&gt;<br>&gt; Regardless of whether or not it is an implementation detail, nil does not<br>&gt; adequately describe the “none” case it is trying to represent in my opinion<br>&gt;<br></p><p>So you&#39;re arguing for renaming as opposed to removal then.<br></p><p><br>&gt;<br>&gt;<br>&gt; B<br>&gt;<br>&gt;<br>&gt; On Jun 8, 2016, at 4:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 3:52 PM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt;<br>&gt;&gt;<br>&gt; My point is that `.none` exposes the underlying enum. The premise here is<br>&gt; that the enum is an implementation detail. You&#39;ll notice that, currently,<br>&gt; significant sugar and magic is devoted to allowing you to work with<br>&gt; optionals without ever writing `.some` or `none`. For example, `if let x =<br>&gt; ...` and friends allow you to avoid writing `if case .some(let x) = ...`,<br>&gt; while you can write `return x` instead of `return .some(x)`. This was,<br>&gt; IIUC, a deliberate choice to allow progressive disclosure of the language<br>&gt; to learners. Renaming `nil` to `none` is a different proposal from Anton is<br>&gt; proposing here.<br>&gt;<br>&gt;<br>&gt;&gt; Brandon<br>&gt;&gt;<br>&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated<br>&gt;&gt; like an implementation detail. Currently, it is possible to teach the<br>&gt;&gt; concept of Optional without introducing enum types or generics. How would<br>&gt;&gt; you do so after elimination of nil?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt; Points:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration<br>&gt;&gt;&gt; type:<br>&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for<br>&gt;&gt;&gt; .none, would we accept it?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the<br>&gt;&gt;&gt; intentions.<br>&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null<br>&gt;&gt;&gt; is clearer. In case of a semantically nullable struct,<br>&gt;&gt;&gt; NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift<br>&gt;&gt;&gt; equals none.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/83bf7aef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>In my other thread where this came up, my support is:<br>1. Removing NilLiteralConvertible conformance from Optional (apparently other people use this protocol?)<br>2. Introducing a new keyword that is sugar for .none<br></p><p>Would I like to remove nil and NilLiteralConvertible? Perhaps, but it seems that some people use them for other things and I would hate to take it away from them. <br></p><p>My concerns come down to this:<br>- It looks like a pointer<br>- People learning Swift as their first language will go to other languages and expect “nil” to be safe. Swift seems to be mostly alone here: nil is safe whereas in most languages it is not safe to dereference a nil pointer<br>- It is not consistent with the Optional enum naming<br>- It is not as descriptive or expressive<br></p><p><br>Brandon<br></p><p>&gt; On Jun 8, 2016, at 4:59 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is it really an implementation detail? It is very leaky if it is one because it is highly exposed to everyone.<br>&gt; <br>&gt; Regardless of whether or not it is an implementation detail, nil does not adequately describe the “none” case it is trying to represent in my opinion<br>&gt; <br>&gt; B<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 3:52 PM, Brandon Knope &lt;bknope at me.com &lt;mailto:bknope at me.com&gt;&gt; wrote:<br>&gt;&gt; .none or a more appropriate keyword like “none” (imo)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; My point is that `.none` exposes the underlying enum. The premise here is that the enum is an implementation detail. You&#39;ll notice that, currently, significant sugar and magic is devoted to allowing you to work with optionals without ever writing `.some` or `none`. For example, `if let x = ...` and friends allow you to avoid writing `if case .some(let x) = ...`, while you can write `return x` instead of `return .some(x)`. This was, IIUC, a deliberate choice to allow progressive disclosure of the language to learners. Renaming `nil` to `none` is a different proposal from Anton is proposing here.<br>&gt;&gt;  <br>&gt;&gt; Brandon<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 4:47 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s been pointed out before that Optional being an enum type is treated like an implementation detail. Currently, it is possible to teach the concept of Optional without introducing enum types or generics. How would you do so after elimination of nil?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 8, 2016 at 3:41 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; (No joking)<br>&gt;&gt;&gt; Points:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now it looks like this:<br>&gt;&gt;&gt; if x != .none { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/8f1495dd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>June 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 4:59 PM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is it really an implementation detail? It is very leaky if it is one because it is highly exposed to everyone.<br></p><p>It’s only as leaky as you want it to be. We have two shipping apps with large codebases using Swift, and we *never* refer to Optional enum directly or to its enum .some or .none cases anywhere in our code.<br></p><p>Personally, I’d much prefer to keep nil.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 1:41 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; (No joking)<br>&gt; Points:<br>&gt; <br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt; <br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt; <br>&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; <br>&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; <br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; <br>&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br></p><p>I know we&#39;re making a lot of source-compatibility breaks in Swift 3 and so these lines seem blurry, but I think the spelling of &quot;nil&quot; is quite solidly in the &quot;that ship has sailed&quot; category, along with &quot;struct&quot; and &quot;func&quot; and &quot;var&quot;.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>Isn’t the only thing keeping nil relevant is the NilLiteralConvertible protocol?<br></p><p>Brandon<br></p><p>&gt; On Jun 8, 2016, at 5:08 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 1:41 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; (No joking)<br>&gt;&gt; Points:<br>&gt;&gt; <br>&gt;&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt;&gt; if x != Optional.none { ... }<br>&gt;&gt; <br>&gt;&gt; Now it looks like this:<br>&gt;&gt; if x != .none { ... }<br>&gt;&gt; <br>&gt;&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt;&gt; <br>&gt;&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt;&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt;&gt; <br>&gt;&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt;&gt; <br>&gt;&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; <br>&gt; I know we&#39;re making a lot of source-compatibility breaks in Swift 3 and so these lines seem blurry, but I think the spelling of &quot;nil&quot; is quite solidly in the &quot;that ship has sailed&quot; category, along with &quot;struct&quot; and &quot;func&quot; and &quot;var&quot;.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/6d0c3544/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  9, 2016 at 12:00:00am</p></header><div class="content"><p>I don&#39;t see a reason to rename or remove the `nil` literal.<br></p><p>But I can come up with a concrete reason to deprecate NilLiteralConvertible: The language has made Optional a very specific thing with `if let` syntax, implicit wrapping, and optional chaining to name a few. But the second most common way (I guess) to create an Optional—by using the `nil` literal—isn&#39;t actually guaranteed to create an Optional.<br></p><p>    let condition: Bool<br>    let x = condition ? 1 : nil<br>    // error: result values in &#39;? :&#39; expression have mismatching types &#39;Int&#39; and &#39;_&#39;<br></p><p>An expression like the above doesn&#39;t compile because the compiler can&#39;t tell what type `nil` should initialise. (Currently, at least Optional&lt;Int&gt; and ImplicitlyUnwrappedOptional&lt;Int&gt; seem possible, but with NilLiteralConvertible, something like a conforming MyJSON could be as well!) This, I think, can be confusing to new users. And life would be simpler if `nil` always stood for `Optional.none`, which would then infer the associated Wrapped type respectfully.<br></p><p>So no, I don&#39;t support this idea but I think we should sunset NilLiteralConvertible.<br></p><p>— Pyry<br></p><p>PS. Besides, the above statement will compile with any of the following edits:<br></p><p>    let x = condition ? 1 : Optional.none<br>    let x = condition ? 1 : nil as Optional<br>    let x = condition ? 1 : Optional()<br>    let x = condition ? 1 as Optional : nil<br>    let x = condition ? 1 as Int? : nil<br>    let x = condition ? Optional(1) : nil<br>    let x: Int? = condition ? 1 : nil<br></p><p>&gt; On 08 Jun 2016, at 23:41, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (No joking)<br>&gt; Points:<br>&gt; <br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt; <br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt; <br>&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; <br>&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; <br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; <br>&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/32652cb4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Remove nil and NilLiteralConvertible</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  9, 2016 at 08:00:00am</p></header><div class="content"><p>My objection to this is that .none is a fairly common member in various enums (besides Optional) and it&#39;s a mess already:<br></p><p>enum EventDataRenderType {<br>	case none<br>	case tab<br>	case blockClosed<br>	case blockOpened<br>}<br></p><p>let data = self.data<br>if data.customization?.renderType == .none {<br>    /// Was it compared to Optional.none, or EventDataRenderType,<br>    /// since data.customization?.renderType == .tab is completely<br>    /// valid...<br>}<br></p><p>If `none` became a keyword as suggested by some, would it be allowed to have .none in other enums?<br></p><p><br>&gt; On Jun 8, 2016, at 10:41 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (No joking)<br>&gt; Points:<br>&gt; <br>&gt; 1. When nil was added to the language, we could not infer enumeration type:<br>&gt; if x != Optional.none { ... }<br>&gt; <br>&gt; Now it looks like this:<br>&gt; if x != .none { ... }<br>&gt; <br>&gt; If at this point we had a proposal to add nil as a replacement for .none, would we accept it?<br>&gt; <br>&gt; 2. nil is very generic, it only approximately allows to express the intentions.<br>&gt; In case of Optional, .none is clearer. In case of JSON processing, .null is clearer. In case of a semantically nullable struct, NilLiteralConvertible usually goes to default constructor.<br>&gt; <br>&gt; 3. Too many &quot;empty&quot; things: .none, nil; NSNull, Void, NoReturn types.<br>&gt; <br>&gt; 4. There should be a single consistent terminology: no value in Swift equals none.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
