<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.  <br></p><p>Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.  <br></p><p>import Darwin<br></p><p>public extension Float {<br>   static let min = -FLT_MAX<br>   static let max = FLT_MAX<br>}<br></p><p>public extension Double {<br>   static let min = -DBL_MAX<br>   static let max = DBL_MAX<br>}<br></p><p>Is there interest in adding this?  If so, what is the right way to proceed?<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>December  5, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi Matthew —<br></p><p>This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:<br></p><p>  /// Positive infinity.<br>  ///<br>  /// Compares greater than all finite numbers.<br>  static var infinity: Self { get }<br>  <br>  /// The greatest finite value.<br>  ///<br>  /// Compares greater than or equal to all finite numbers, but less than<br>  /// infinity.<br>  static var greatestFiniteMagnitude: Self { get }<br>  <br>  /// The least positive normal value.<br>  ///<br>  /// Compares less than or equal to all positive normal numbers.  There may<br>  /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>  /// they are represented with less precision than normal numbers.<br>  static var leastNormalMagnitude: Self { get }<br>  <br>  /// The least positive value.<br>  ///<br>  /// Compares less than or equal to all positive numbers, but greater than<br>  /// zero.  If the target supports subnormal values, this is smaller than<br>  /// `leastNormalMagnitude`; otherwise they are equal.<br>  static var leastMagnitude: Self { get }<br></p><p>– Steve<br></p><p>&gt; On Dec 5, 2015, at 11:10 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.  <br>&gt; <br>&gt; Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.  <br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; public extension Float {<br>&gt;   static let min = -FLT_MAX<br>&gt;   static let max = FLT_MAX<br>&gt; }<br>&gt; <br>&gt; public extension Double {<br>&gt;   static let min = -DBL_MAX<br>&gt;   static let max = DBL_MAX<br>&gt; }<br>&gt; <br>&gt; Is there interest in adding this?  If so, what is the right way to proceed?<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/c979acfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9c72f152ed52fbbdb5f174ad2e1e7b0a?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>John Calsbeek</string> &lt;john.calsbeek+lists at gmail.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>+1 on not calling them `max` and `min`.<br></p><p>I don’t have the history of the internal discussion, but I am not thrilled about that particular set of constants. Their names accurately describe the standard set of floating point constants (infinity, `FLT_MAX`, `FLT_MIN`, and smallest positive subnormal), but is that the best set of constants to expose?<br></p><p>How should I pick a starting value for a loop that takes the `min` or `max` of ints or floats in a sequence? With floats I should use `Float.greatestFiniteMagnitude` and `-Float.greatestFiniteMagnitude`, whereas with ints I should use `Int.max` and `Int.min`, because `-Int.max != Int.min`. Rather than parsing the three qualifiers in the name `greatestFiniteMagnitude` and reassure myself that negating it is the proper way to get the smallest finite value, I would rather type `Float.largestFinite` and `Float.smallestFinite` or something along those lines.<br></p><p>I have no problem with the name `leastNormalMagnitude`—if you want such a thing, you hopefully understand floats well enough for the name to not be confusing—but `leastMagnitude` is surprising to me. I think of subnormal numbers as being exceptional in the same way that infinities and NaNs are, so I wouldn’t expect to get a subnormal from a property called `leastMagnitude`. If there was a qualifier that explicitly meant “either normal or subnormal,” it would be the obvious choice here. I don’t know any, but I hope leaving off the qualifier entirely is not the best solution.<br></p><p>If I had to decide at this instant, I would probably pick `largestFinite`, `smallestFinite`, `leastNormalMagnitude`, and leave out `lastMagnitude` in favor of spelling it `Float(0).nextUp`.<br></p><p>&lt;/bikeshedding&gt;<br></p><p>Cheers,<br>John<br></p><p>&gt; On Dec 5, 2015, at 9:41 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew —<br>&gt; <br>&gt; This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:<br>&gt; <br>&gt;   /// Positive infinity.<br>&gt;   ///<br>&gt;   /// Compares greater than all finite numbers.<br>&gt;   static var infinity: Self { get }<br>&gt;   <br>&gt;   /// The greatest finite value.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;   <br>&gt;   /// The least positive normal value.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive normal numbers.  There may<br>&gt;   /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>&gt;   /// they are represented with less precision than normal numbers.<br>&gt;   static var leastNormalMagnitude: Self { get }<br>&gt;   <br>&gt;   /// The least positive value.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive numbers, but greater than<br>&gt;   /// zero.  If the target supports subnormal values, this is smaller than<br>&gt;   /// `leastNormalMagnitude`; otherwise they are equal.<br>&gt;   static var leastMagnitude: Self { get }<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 11:10 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.  <br>&gt;&gt; <br>&gt;&gt; Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.  <br>&gt;&gt; <br>&gt;&gt; import Darwin<br>&gt;&gt; <br>&gt;&gt; public extension Float {<br>&gt;&gt;   static let min = -FLT_MAX<br>&gt;&gt;   static let max = FLT_MAX<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension Double {<br>&gt;&gt;   static let min = -DBL_MAX<br>&gt;&gt;   static let max = DBL_MAX<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is there interest in adding this?  If so, what is the right way to proceed?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/15cc3459/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 02:00:00pm</p></header><div class="content"><p>Hi Steve,<br></p><p>Thanks for looking at my proposal and sharing the internal consensus.  I do like the more explicit names.<br></p><p>One of the reasons I proposed this was to follow up with a proposal for a RangeDiscoverable protocol that would be conformed to by all numeric types:<br></p><p>protocol RangeDiscoverable {<br>    static var min: Self { get }<br>    static var max: Self { get }<br>}<br></p><p>A better interface would looks like this (not sure why I didn’t think of this before):<br></p><p>public protocol RangeDiscoverable {<br>	static var representableRange: Range&lt;Self&gt; { get }<br>}<br></p><p>With conformances that look like this:<br></p><p>extension Int: RangeDiscoverable {<br>	static let representableRange: Range&lt;Int&gt; = Int.min…Int.max<br>}<br></p><p>extension Float: RangeDiscoverable {<br>	// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not<br>	static let representableRange: Range&lt;Float&gt; = -Float.infinity...Float.infinity<br>}<br></p><p>This would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.<br></p><p>My original implementation looked like this:<br></p><p>extension Float: BidirectionalIndexType {<br>    public func predecessor() -&gt; Float {<br>        return nextafterf(self, Float.min)<br>    }<br>    public func successor() -&gt; Float {<br>        return nextafterf(self, Float.max)<br>    }<br>}<br></p><p>With the nextUp and nextDown properties I see in test/Prototypes/FloatingPoint.swift this could change to:<br></p><p>extension Float: BidirectionalIndexType {<br>    public func predecessor() -&gt; Float {<br>        return nextDown<br>    }<br>    public func successor() -&gt; Float {<br>        return nextUp<br>    }<br>}<br></p><p>What is your thought on adding a protocol similar to RangeDiscoverable (conformed to by all numeric types) and the supporting BidirectionalIndexType conformance for floating point types?  Is this something that would be considered?<br></p><p><br></p><p><br>&gt; On Dec 5, 2015, at 11:41 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Matthew —<br>&gt; <br>&gt; This is something that we’ve discussed quite a bit internally, and are close to consensus on.  Many people feel that “max” and “min” are confusing or misleading, as they are not actually the largest / smallest values of the type, so the plan is to use much more explicit names (you can see an early sketch of this in test/Prototypes/FloatingPoint.swift, though there are a number of things that will be changed as well).  I’ve excerpted the relevant section here for convenience:<br>&gt; <br>&gt;   /// Positive infinity.<br>&gt;   ///<br>&gt;   /// Compares greater than all finite numbers.<br>&gt;   static var infinity: Self { get }<br>&gt;   <br>&gt;   /// The greatest finite value.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;   <br>&gt;   /// The least positive normal value.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive normal numbers.  There may<br>&gt;   /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>&gt;   /// they are represented with less precision than normal numbers.<br>&gt;   static var leastNormalMagnitude: Self { get }<br>&gt;   <br>&gt;   /// The least positive value.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive numbers, but greater than<br>&gt;   /// zero.  If the target supports subnormal values, this is smaller than<br>&gt;   /// `leastNormalMagnitude`; otherwise they are equal.<br>&gt;   static var leastMagnitude: Self { get }<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Dec 5, 2015, at 11:10 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the spirit of small commits and incremental change I have a very small proposal.  I am not sure if this belongs on the list or if small changes like this are ok as pull requests, but am starting here because it involves adding public API in the standard library.  <br>&gt;&gt; <br>&gt;&gt; Integer types have static min / max properties, but floating point types currently do not.  The Darwin implementation is very straightforward.  <br>&gt;&gt; <br>&gt;&gt; import Darwin<br>&gt;&gt; <br>&gt;&gt; public extension Float {<br>&gt;&gt;   static let min = -FLT_MAX<br>&gt;&gt;   static let max = FLT_MAX<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension Double {<br>&gt;&gt;   static let min = -DBL_MAX<br>&gt;&gt;   static let max = DBL_MAX<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is there interest in adding this?  If so, what is the right way to proceed?<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151205/d48ecfbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; extension Int: RangeDiscoverable {<br>&gt; 	static let representableRange: Range&lt;Int&gt; = Int.min…Int.max<br>&gt; }<br></p><p><br>There’s a problem with that:<br></p><p>	 24&gt; Int.min...Int.max<br>	fatal error: Range end index has no valid successor<br></p><p>The problem is that Int.min … Int.max is actually represented as Int.min ..&lt; Int.max.successor(), which is obviously not going to work.<br></p><p>&gt; This would require numeric types to conform to ForwardIndexType.  Integer types already conform to RandomAccessIndexType.  Floating point types do not currently conform to ForwardIndexType but could conform not just to ForwardIndexType, but also BidirectionalIndexType.<br></p><p>Floats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.<br></p><p>However, we can fix both of these issues by using ClosedInterval instead of Range. ClosedInterval requires only that the bounds be Comparable, and doesn’t try to add 1 to the end.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: floating point static min / max properties</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  5, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; There’s a problem with that:<br>&gt; <br>&gt; 	 24&gt; Int.min...Int.max<br>&gt; 	fatal error: Range end index has no valid successor<br>&gt; <br>&gt; The problem is that Int.min … Int.max is actually represented as Int.min ..&lt; Int.max.successor(), which is obviously not going to work.<br></p><p>That’s embarrassing.  I should have known better than to post code that should work without trying it out first!  Thanks for pointing that out.  It looks like ClosedInterval is indeed what I should have used.  <br></p><p>protocol ClosedIntervalType {<br>	static var closedInterval: ClosedInterval&lt;Self&gt; { get }<br>}<br></p><p>extension Int: ClosedIntervalType {<br>	static let closedInterval: ClosedInterval &lt;Int&gt; = Int.min…Int.max<br>}<br></p><p>extension Float: ClosedIntervalType {<br>	// not sure it would be better to use -Float. greatestFiniteMagnitude..Float. greatestFiniteMagnitude here or not<br>	static let closedInterval: ClosedInterval &lt;Float&gt; = -Float.infinity...Float.infinity<br>}<br></p><p><br>I think having something like this in the standard library would be quite useful.  All numeric types could conform as could <br></p><p>&gt; Floats don’t currently conform to the IndexType protocols because there’s no *natural* interval for them to use. nextUp/nextDown are rarely what you want in practice, while 1 breaks down at large sizes.<br></p><p>nextUp/nextDown may be rarely needed, they do seem to me to be a “natural” interval for floating point numbers.  Natural because successor and predecessor imply stepping through a discrete sequence of values one-by-one and any other interval would necessarily skip values.<br></p><p>I did run into a scenario where nextUp/nextDown were precisely what I needed which is what lead me to write a conformance of Float and Double to BidirectionalIndexType.  I didn’t actually need BidirectionalIndexType conformance - just the successor and predecessor (nextUp/nextDown) functions - it just seemed most natural to conform to the protocol that defined them functions that do precisely this.<br></p><p>I think it would be perfectly natural for floating point types to conform to BidirectionalIndexType but I admit it would probably not be used often.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
