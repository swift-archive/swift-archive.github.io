<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; <br>&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; <br>&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt; <br>&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt; <br>&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt; it.<br>&gt;<br>&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt; point. <br></p><p>I should point out that with the resyntaxing of existentials to<br>Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>conform to Collection becomes far less absurd than it was, so maybe this<br>is not so bad.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;  on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;  itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt; it.<br>&gt;&gt; <br>&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt; point. <br>&gt; <br>&gt; I should point out that with the resyntaxing of existentials to<br>&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt; is not so bad.<br></p><p>I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br></p><p>What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>The type family cannot conform to T because T is just one fixed member of it.<br>It conforms to itself, though, as I can write<br>let c1: Any&lt;Collection&gt; = …<br>let c2: Any&lt;Collection&gt; = c1<br></p><p>That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 7:50 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt; point. <br>&gt;&gt; <br>&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt; is not so bad.<br>&gt; <br>&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt; <br>&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt; It conforms to itself, though, as I can write<br>&gt; let c1: Any&lt;Collection&gt; = …<br>&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt; <br>&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br></p><p>I was exploring this path a bit… <br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p><br></p><p>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt; point. <br>&gt;&gt; <br>&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt; is not so bad.<br>&gt; <br>&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt; <br>&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt; It conforms to itself, though, as I can write<br>&gt; let c1: Any&lt;Collection&gt; = …<br>&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt; <br>&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br></p><p><br>Let me expand that a bit:<br></p><p>Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br></p><p>(1) misconception: protocols with associated types are somehow very different from generics<br></p><p>I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br></p><p>Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br></p><p>Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br></p><p>And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br></p><p>In essence protocols with associated types are like generics with wildcards.<br></p><p>Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>(a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>(b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have. <br></p><p><br>(2) misconception: POP is different from OOP<br></p><p>It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>But protocols are not really different from interfaces in Java. I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>(I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br></p><p><br>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 08:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br>&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt; is not so bad.<br>&gt;&gt; <br>&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt; <br>&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt; <br>&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt; <br>&gt; <br>&gt; Let me expand that a bit:<br>&gt; <br>&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt; <br>&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt; <br>&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br></p><p>btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p>&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt; <br>&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>Java supports co/contra variant params<br></p><p>&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br></p><p>This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br></p><p>&gt; In essence protocols with associated types are like generics with wildcards.<br></p><p>Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about iwith respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br></p><p>&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br></p><p>IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into A partial reification in the jvm. It seems the decision for now the decision is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br></p><p>&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br></p><p>I hope sypesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br></p><p>... x is String?<br>If let! x {}<br>That runs as<br>if let x = x {}<br></p><p>something equally short could be done here.<br></p><p>&gt; <br>&gt; (2) misconception: POP is different from OOP<br>&gt; <br>&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br></p><p>Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br></p><p>&gt; But protocols are not really different from interfaces in Java.<br></p><p>There is one big difference: default methods, but it seems swift will add that soon. I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br></p><p>&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br></p><p>-1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br></p><p>&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br></p><p>I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Let me expand that a bit:<br>&gt;&gt; <br>&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt; <br>&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt; <br>&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt; <br>&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p>As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>Why? Just give the top type a name, e.g. `Any` and you are done. Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br></p><p><br>&gt; <br>&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt; <br>&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt; Java supports co/contra variant params<br></p><p>Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br></p><p>Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br></p><p><br>&gt; <br>&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt; <br>&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br></p><p>You mean Java 10?<br></p><p><br>&gt; <br>&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt; <br>&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about iwith respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt; <br>&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt; <br>&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into A partial reification in the jvm. It seems the decision for now the decision is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt; <br>&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt; <br>&gt; I hope sypesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt; <br>&gt; ... x is String?<br>&gt; If let! x {}<br>&gt; That runs as<br>&gt; if let x = x {}<br>&gt; <br>&gt; something equally short could be done here.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt; <br>&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt; <br>&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt; <br>&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt; <br>&gt; There is one big difference: default methods, but it seems swift will add that soon.<br></p><p>Swift already has default extension methods, doesn’t it?<br></p><p><br>&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt; <br>&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br></p><p>I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br></p><p>&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br></p><p>Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br></p><p>-THorsten<br></p><p><br>&gt; <br>&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt; <br>&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 11:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt;&gt; <br>&gt;&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt;&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br>&gt; <br>&gt; As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>&gt; Why? Just give the top type a name, e.g. `Any` and you are done.<br>Yes.. I just don&#39;t like magic. I think that all types should be expressable with a syntax and that you can then decide to alias one parsing case with a specific name. Not the other way around.<br></p><p>&gt; Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br>The _[] case is just a degenerate case of the syntax, showing that it is expressible inside, as opposoed to have to define a contextual keyword (read the SourceKit code). And then it is aliasable. Part of the problems in swift today to me is that some things are no doable in swift, so the compiler must contain that semantic. This here is just one example, but there are others. These are notions that the standard library has to defer to the compiler. Some of them have been tabled for 4.0 it seems. My point here was that it is not fate, and choosing the syntax carefully for existentials (whichever it is, i don&#39;t really care inthe end) would prevent having to add a magic keyword for to top type to the compiler and to SourceKit again (they are trying to remove them).<br></p><p>As for the current Any&lt;...&gt; proposal for generalizing existentials it is IMHO cluncky and magic. There is nothing stopping us mechanically from entering Any&lt;UITableView, UIButton&gt;. To me that is the holemark of bad design. In what I tested you just can&#39;t do it and the reason is clear. Of course when I say you can&#39;t I do not mean that your keyboard will zap u if you try. But the way to verify correctness is different... and in a world where xcode would be a good ide, then code completion would even show you why and actually truly assist (because the grammar i tested makes really makes it possible). I know that xcode is only as good as SourceKit lets it be.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt; Java supports co/contra variant params<br>&gt; <br>&gt; Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br>&gt; <br>&gt; Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt; <br>&gt;&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br>&gt; <br>&gt; You mean Java 10?<br></p><p>Yes. After 10. Than is their only date hint.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt;&gt; <br>&gt;&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about with respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt;&gt; <br>&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt;&gt; <br>&gt;&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into a partial reification in the jvm. It seems the decision for now is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt;&gt; <br>&gt;&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt;&gt; <br>&gt;&gt; I hope typesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt;&gt; <br>&gt;&gt; ... x is String?<br>&gt;&gt; If let! x {}<br>&gt;&gt; That runs as<br>&gt;&gt; if let x = x {}<br>&gt;&gt; <br>&gt;&gt; something equally short could be done here.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt;&gt; <br>&gt;&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt;&gt; <br>&gt;&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt;&gt; <br>&gt;&gt; There is one big difference: default methods, but it seems swift will add that soon.<br>&gt; <br>&gt; Swift already has default extension methods, doesn’t it?<br></p><p>Yes, and no. It has differently dispatched code that can be found to fill in the gap of the conformance req, yes. But Joe Grof (?) said that there are no reasons why these could not be added. Having true defaults could be one way to deal with optional comformance...<br></p><p>protocol MyProto {<br>func mustImplement()<br>default canImplement() { } <br>}<br></p><p>Related data there:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br></p><p>&gt; <br>&gt; <br>&gt;&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt;&gt; <br>&gt;&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>&gt; <br>&gt; I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br>&gt; <br>&gt;&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br>&gt; <br>&gt; Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br></p><p>I think I care more about existentials, but only because of the kind of java i wrote for a living. I just looked at a bunch of opensource swift libs (particularly for server side swift)... some of it is a real engineering disaster: 20+ folders, each with 2 source files... or 3 folders &quot;extensions&quot; &quot;utils&quot; &quot;classes&quot;. Swift is currently not equiped for people to write big things with... I wish the team would address it sooner than later (look at their own c++ code to see the difference). IMHO import conflicts are more often the symptom of bad code than a real issue.<br></p><p>Cheers<br>&gt; <br>&gt; -THorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt;&gt; <br>&gt;&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 11.06.2016 um 12:38 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 11:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt;&gt;&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br>&gt;&gt; <br>&gt;&gt; As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>&gt;&gt; Why? Just give the top type a name, e.g. `Any` and you are done.<br>&gt; Yes.. I just don&#39;t like magic. I think that all types should be expressable with a syntax and that you can then decide to alias one parsing case with a specific name. Not the other way around.<br></p><p>Well, I think that would be backwards, because we have a nominal type system. That means that the syntax for a type is just its name. <br>`&amp;` is a type operator which creates a new type from its operands.<br>`where` clauses add constraints to types.<br>But it all starts with a type&#39;s name.<br></p><p>The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br></p><p>protocol Foo { … }<br></p><p>means<br></p><p>protocol Foo : Any { … }<br></p><p>That’s less magic than creating a special syntax just to express the top type.<br></p><p><br>&gt; <br>&gt;&gt; Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br>&gt; The _[] case is just a degenerate case of the syntax, showing that it is expressible inside, as opposoed to have to define a contextual keyword (read the SourceKit code). And then it is aliasable. Part of the problems in swift today to me is that some things are no doable in swift, so the compiler must contain that semantic. This here is just one example, but there are others. These are notions that the standard library has to defer to the compiler. Some of them have been tabled for 4.0 it seems. My point here was that it is not fate, and choosing the syntax carefully for existentials (whichever it is, i don&#39;t really care inthe end) would prevent having to add a magic keyword for to top type to the compiler and to SourceKit again (they are trying to remove them).<br></p><p>`Any` would *not* be a keyword. It is just a type name like `Collection` or `Int`. Like I said, the only magic would be in adding `: Any` to type definitions without a conforming clause.<br></p><p>&gt; <br>&gt; As for the current Any&lt;...&gt; proposal for generalizing existentials it is IMHO cluncky and magic. There is nothing stopping us mechanically from entering Any&lt;UITableView, UIButton&gt;. To me that is the holemark of bad design. In what I tested you just can&#39;t do it and the reason is clear. Of course when I<br></p><p>`Any&lt;UITableView, UIButton&gt;` is just an intersection type and would be written UITableView &amp; UIButton. And, yes, that would be ok, because it would be just the empty set, i.e. the bottom type (which has no members). There is no magic involved, it is just the normal result of an intersection: each type is a set containing all instances of this type (instances conforming to it). Intersecting two sets might result in an empty set. The type denoting the empty set is the bottom type which is the subtype of all types and might be called `Nothing` or `Never` or `Bottom`.<br>Ceylon makes very nice use of type intersections and type unions and the beautiful thing is that these type operations really just work like you would expect if you think of types as sets (which is the standard definition for a type AFAIK). No surprises and no magic there!<br></p><p>So it is *not* a sign of bad design, quite to the contrary! What did you test it with? Probably not Ceylon, because otherwise you would have seen that it just works.<br></p><p><br>&gt; say you can&#39;t I do not mean that your keyboard will zap u if you try. But the way to verify correctness is different... and in a world where xcode would be a good ide, then code completion would even show you why and actually truly assist (because the grammar i tested makes really makes it possible). I know that xcode is only as good as SourceKit lets it be.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt;&gt; Java supports co/contra variant params<br>&gt;&gt; <br>&gt;&gt; Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br>&gt;&gt; <br>&gt;&gt; Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br>&gt;&gt; <br>&gt;&gt; You mean Java 10?<br>&gt; <br>&gt; Yes. After 10. Than is their only date hint.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about with respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt;&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into a partial reification in the jvm. It seems the decision for now is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope typesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ... x is String?<br>&gt;&gt;&gt; If let! x {}<br>&gt;&gt;&gt; That runs as<br>&gt;&gt;&gt; if let x = x {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; something equally short could be done here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is one big difference: default methods, but it seems swift will add that soon.<br>&gt;&gt; <br>&gt;&gt; Swift already has default extension methods, doesn’t it?<br>&gt; <br>&gt; Yes, and no. It has differently dispatched code that can be found to fill in the gap of the conformance req, yes. But Joe Grof (?) said that there are no reasons why these could not be added. Having true defaults could be one way to deal with optional comformance…<br></p><p>The dispatch issue only arises for extensions introducing a method that is not declared in a protocol. That is something you *cannot* do in Java. Java’s default methods are implementations for methods declared in interfaces. Swift’s extension methods providing defaults for methods declared in a protocol are dynamically dispatched and should work like Java’s default methods.<br>(One caveat exists with subclasses where the superclasses didn’t implement the method because I then am not allowed to `override` the default method but that is a bug IMO).<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt; protocol MyProto {<br>&gt; func mustImplement()<br>&gt; default canImplement() { } <br>&gt; }<br>&gt; <br>&gt; Related data there:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>&gt;&gt; <br>&gt;&gt; I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br>&gt;&gt; <br>&gt;&gt;&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br>&gt;&gt; <br>&gt;&gt; Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br>&gt; <br>&gt; I think I care more about existentials, but only because of the kind of java i wrote for a living. I just looked at a bunch of opensource swift libs (particularly for server side swift)... some of it is a real engineering disaster: 20+ folders, each with 2 source files... or 3 folders &quot;extensions&quot; &quot;utils&quot; &quot;classes&quot;. Swift is currently not equiped for people to write big things with... I wish the team would address it sooner than later (look at their own c++ code to see the difference). IMHO import conflicts are more often the symptom of bad code than a real issue.<br></p><p>Alas, most languages suffer from poor module systems. A good module system should not only allow resolving conflicts between modules and making it possible to structure code well, but solve the issue around versioned modules so that is is possibly to safely use different versions of the same module in the same application.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; Cheers<br>&gt;&gt; <br>&gt;&gt; -THorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt;&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 11, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt; <br>&gt; protocol Foo { … }<br>&gt; <br>&gt; means<br>&gt; <br>&gt; protocol Foo : Any { … }<br></p><p>Any is also the supertype of all structural types, and structural types cannot conform to protocols.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 11.06.2016 um 14:23 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt;&gt; <br>&gt;&gt; protocol Foo { … }<br>&gt;&gt; <br>&gt;&gt; means<br>&gt;&gt; <br>&gt;&gt; protocol Foo : Any { … }<br>&gt; <br>&gt; Any is also the supertype of all structural types, and structural types cannot conform to protocols.<br></p><p>AFAIK Swift does not support structural types and I am not sure whether we should change that. In that case `Any` would become magic, yes.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 11, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 11, 2016, at 7:31 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 11.06.2016 um 14:23 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; means<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo : Any { … }<br>&gt;&gt; <br>&gt;&gt; Any is also the supertype of all structural types, and structural types cannot conform to protocols.<br>&gt; <br>&gt; AFAIK Swift does not support structural types and I am not sure whether we should change that. In that case `Any` would become magic, yes.<br></p><p>Functions and tuples are structural types, although it is probably possible to make tuples syntactic sugar for a Tuple type of we get the necessary variadic generics support.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 11, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; Functions and tuples are structural types, although it is probably possible to make tuples syntactic sugar for a Tuple type of we get the necessary variadic generics support.<br></p><p>The design the variadic generics thread seems to have preliminarily settled on is based on representing variadic generics as tuples, so I imagine we would hit some issues with circularity!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 11, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jun 11, 2016, at 7:48 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Functions and tuples are structural types, although it is probably possible to make tuples syntactic sugar for a Tuple type of we get the necessary variadic generics support.<br>&gt; <br>&gt; The design the variadic generics thread seems to have preliminarily settled on is based on representing variadic generics as tuples, so I imagine we would hit some issues with circularity!<br></p><p>I&#39;m not sure this topic is settled at all (felt a bit more like deferred I thought).  But this may well turn out to be the case.  There is some circularity either way of course - one will probably be defined in terms of the other.<br></p><p>The more important point is that Swift does have structural types and even if you could define Tuple with variadic generics you still have structural function types.  So it will always have at least one structural type.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Am 11.06.2016 um 14:48 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt;&gt; Functions and tuples are structural types, although it is probably possible to make tuples syntactic sugar for a Tuple type of we get the necessary variadic generics support.<br>&gt; <br>&gt; The design the variadic generics thread seems to have preliminarily settled on is based on representing variadic generics as tuples, so I imagine we would hit some issues with circularity!<br></p><p>Maybe we should look how Ceylon solves these issues then as they have variadic tuples, too.<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 11.06.2016 um 14:44 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 7:31 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 11.06.2016 um 14:23 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; means<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo : Any { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any is also the supertype of all structural types, and structural types cannot conform to protocols.<br>&gt;&gt; <br>&gt;&gt; AFAIK Swift does not support structural types and I am not sure whether we should change that. In that case `Any` would become magic, yes.<br>&gt; <br>&gt; Functions and tuples are structural types, although it is probably possible to make tuples syntactic sugar for a Tuple type of we get the necessary variadic generics support.<br></p><p>That&#39;s right, I forgot about them. Still I&#39;d prefer the magic of having on type being the top type to having some syntax which does not work for structural types either and derive a top type from it.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 2:31 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 11.06.2016 um 14:23 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; means<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo : Any { … }<br>&gt;&gt; <br>&gt;&gt; Any is also the supertype of all structural types, and structural types cannot conform to protocols.<br>&gt; <br>&gt; AFAIK Swift does not support structural types and I am not sure whether we should change that. In that case `Any` would become magic, yes.<br></p><p>Hmmm poor tuples... I thought they did a good job as swift&#39;s structural type.<br></p><p><br>&gt; <br>&gt; -Thorsten<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 11, 2016, at 2:05 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.06.2016 um 12:38 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 11, 2016, at 11:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt;&gt;&gt;&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>&gt;&gt;&gt; Why? Just give the top type a name, e.g. `Any` and you are done.<br>&gt;&gt; Yes.. I just don&#39;t like magic. I think that all types should be expressable with a syntax and that you can then decide to alias one parsing case with a specific name. Not the other way around.<br>&gt; <br>&gt; Well, I think that would be backwards, because we have a nominal type system. That means that the syntax for a type is just its name. <br></p><p>I realize we do not understand each other. <br>The words we use now to describe a behavior are just that, words. As is the concepts they describe are useless to the computer running the compiler.<br>So we need to map these concepts into a heuristic that a fast but dumb computer will be able to reason with. The code to do that will be either clean and organized, or it will look contrived and full of different paths that will be difficult to mesh together. Of all the possible ways in which swift can behave as a language, some will lead to the former, others to the latter code. I think this is not fate or something you find out after the decision was made and you struggle to carry it through. This is something that can partially be predicted. One of the tools for such prediction is to translate the concepts into a grammar that will show formalize the logic. The simpler the logic, the cleaner (not simple) the final code. <br></p><p>Saying that the syntax for a type is a name is of no use whatsoever for the compiler implementer. It is so universally true that it cannot help in any way whatsoever decide the shape of the swift grammar, much less the structure of the c++ code implementing it.<br></p><p>&gt; `&amp;` is a type operator which creates a new type from its operands.<br>&gt; `where` clauses add constraints to types.<br>&gt; But it all starts with a type&#39;s name.<br>&gt; <br>&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br></p><p>I call magic the core notions of swift that cannot be expressed in swift but have to parachutted in by the compiler. If you read Chris&#39; initial message you will see that he said as much, that adopting P&amp;Q as syntax was leaving a gap that the compiler would have to magically fill. <br></p><p><br>&gt; <br>&gt; protocol Foo { … }<br>&gt; <br>&gt; means<br>&gt; <br>&gt; protocol Foo : Any { … }<br>&gt; <br>&gt; That’s less magic than creating a special syntax just to express the top type.<br></p><p>I will try again... Would it be easier to understand it if instead of magic I said arbitrary?  You are creating a special case: you decide arbitrarily that the special series of characters &#39;A&#39; &#39;n&#39; &#39;y&#39; with this precise casing and without any spaces is going to be adorned with a special meaning when used in specific situations. This is not something you deduced. My approach is exactly the opposite:  _[] does not describe the top type because I have a special affinity with these characters, it describes the top type because it is the only possible logical conclusion from having followed a set of rules attached to a syntax that describes ALL existentials. And because it is not particularly savory, I typealias it to something else. But this is not in the compiler, it us in the standard linrary... inside swift, not outside.<br>Read Chris&#39; original announcement.. He describes P&amp;Q as it would be adopted today as being just a CORNER CASE of a single general principal... a single grammar that can work today to describe P&amp;Q as well as generalize existentials tomorrow. No special treatment, single parser, single rule. I don&#39;t like to write un-necessary IF statements in code.<br></p><p>&gt;&gt;&gt; Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br>&gt;&gt; The _[] case is just a degenerate case of the syntax, showing that it is expressible inside, as opposoed to have to define a contextual keyword (read the SourceKit code). And then it is aliasable. Part of the problems in swift today to me is that some things are no doable in swift, so the compiler must contain that semantic. This here is just one example, but there are others. These are notions that the standard library has to defer to the compiler. Some of them have been tabled for 4.0 it seems. My point here was that it is not fate, and choosing the syntax carefully for existentials (whichever it is, i don&#39;t really care inthe end) would prevent having to add a magic keyword for to top type to the compiler and to SourceKit again (they are trying to remove them).<br>&gt; <br>&gt; `Any` would *not* be a keyword. It is just a type name like `Collection` or `Int`. Like I said, the only magic would be in adding `: Any` to type definitions without a conforming clause.<br></p><p>I hope that by now you understand what magic I was talking about.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; As for the current Any&lt;...&gt; proposal for generalizing existentials it is IMHO cluncky and magic. There is nothing stopping us mechanically from entering Any&lt;UITableView, UIButton&gt;. To me that is the holemark of bad design. In what I tested you just can&#39;t do it and the reason is clear. Of course when I<br>&gt; <br>&gt; `Any&lt;UITableView, UIButton&gt;` is just an intersection type and would be written UITableView &amp; UIButton. And, yes, that would be ok, because it would be just the empty set, i.e. the bottom type (which has no members). There is no magic involved, it is just the normal result of an intersection: each type is a set containing all instances of this type (instances conforming to it)<br></p><p>You can&#39;t be serious? You are saying that to you the ide should not be telling us we are writting an absurdity? And this one was obvious, but it gets a lot worse with more complex types. <br></p><p>&gt; . Intersecting two sets might result in an empty set. The type denoting the empty set is the bottom type which is the subtype of all types and might be called `Nothing` or `Never` or `Bottom`.<br>&gt; Ceylon makes very nice use of type intersections and type unions and the beautiful thing is that these type operations really just work like you would expect if you think of types as sets (which is the standard definition for a type AFAIK). No surprises and no magic there!<br>&gt; <br>&gt; So it is *not* a sign of bad design, quite to the contrary! What did you test it with? Probably not Ceylon, because otherwise you would have seen that it just works.<br></p><p>Hey, who knows, ceylon may one day come to llvm... <br></p><p>&gt; <br>&gt; <br>&gt;&gt; say you can&#39;t I do not mean that your keyboard will zap u if you try. But the way to verify correctness is different... and in a world where xcode would be a good ide, then code completion would even show you why and actually truly assist (because the grammar i tested makes really makes it possible). I know that xcode is only as good as SourceKit lets it be.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt;&gt;&gt; Java supports co/contra variant params<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You mean Java 10?<br>&gt;&gt; <br>&gt;&gt; Yes. After 10. Than is their only date hint.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about with respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt;&gt;&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into a partial reification in the jvm. It seems the decision for now is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope typesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ... x is String?<br>&gt;&gt;&gt;&gt; If let! x {}<br>&gt;&gt;&gt;&gt; That runs as<br>&gt;&gt;&gt;&gt; if let x = x {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; something equally short could be done here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is one big difference: default methods, but it seems swift will add that soon.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift already has default extension methods, doesn’t it?<br>&gt;&gt; <br>&gt;&gt; Yes, and no. It has differently dispatched code that can be found to fill in the gap of the conformance req, yes. But Joe Grof (?) said that there are no reasons why these could not be added. Having true defaults could be one way to deal with optional comformance…<br>&gt; <br>&gt; The dispatch issue only arises for extensions introducing a method that is not declared in a protocol. That is something you *cannot* do in Java. Java’s default methods are implementations for methods declared in interfaces. Swift’s extension methods providing defaults for methods declared in a protocol are dynamically dispatched and should work like Java’s default methods.<br></p><p>I think we should agree to disagree.<br></p><p><br>&gt; (One caveat exists with subclasses where the superclasses didn’t implement the method because I then am not allowed to `override` the default method but that is a bug IMO).<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol MyProto {<br>&gt;&gt; func mustImplement()<br>&gt;&gt; default canImplement() { } <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Related data there:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br>&gt;&gt; <br>&gt;&gt; I think I care more about existentials, but only because of the kind of java i wrote for a living. I just looked at a bunch of opensource swift libs (particularly for server side swift)... some of it is a real engineering disaster: 20+ folders, each with 2 source files... or 3 folders &quot;extensions&quot; &quot;utils&quot; &quot;classes&quot;. Swift is currently not equiped for people to write big things with... I wish the team would address it sooner than later (look at their own c++ code to see the difference). IMHO import conflicts are more often the symptom of bad code than a real issue.<br>&gt; <br>&gt; Alas, most languages suffer from poor module systems. A good module system should not only allow resolving conflicts between modules and making it possible to structure code well, but solve the issue around versioned modules so that is is possibly to safely use different versions of the same module in the same application.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Cheers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -THorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt;&gt;&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 11.06.2016 um 15:08 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 11, 2016, at 2:05 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.06.2016 um 12:38 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 11, 2016, at 11:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt;&gt;&gt;&gt;&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>&gt;&gt;&gt;&gt; Why? Just give the top type a name, e.g. `Any` and you are done.<br>&gt;&gt;&gt; Yes.. I just don&#39;t like magic. I think that all types should be expressable with a syntax and that you can then decide to alias one parsing case with a specific name. Not the other way around.<br>&gt;&gt; <br>&gt;&gt; Well, I think that would be backwards, because we have a nominal type system. That means that the syntax for a type is just its name.<br>&gt; <br>&gt; I realize we do not understand each other. <br>&gt; The words we use now to describe a behavior are just that, words. As is the concepts they describe are useless to the computer running the compiler.<br>&gt; So we need to map these concepts into a heuristic that a fast but dumb computer will be able to reason with. The code to do that will be either clean and organized, or it will look contrived and full of different paths that will be difficult to mesh together. Of all the possible ways in which swift can behave as a language, some will lead to the former, others to the latter code. I think this is not fate or something you find out after the decision was made and you struggle to carry it through. This is something that can partially be predicted. One of the tools for such prediction is to translate the concepts into a grammar that will show formalize the logic. The simpler the logic, the cleaner (not simple) the final code. <br>&gt; <br>&gt; Saying that the syntax for a type is a name is of no use whatsoever for the compiler implementer. It is so universally true that it cannot help in any way whatsoever decide the shape of the swift grammar, much less the structure of the c++ code implementing it.<br>&gt; <br>&gt;&gt; `&amp;` is a type operator which creates a new type from its operands.<br>&gt;&gt; `where` clauses add constraints to types.<br>&gt;&gt; But it all starts with a type&#39;s name.<br>&gt;&gt; <br>&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt; <br>&gt; I call magic the core notions of swift that cannot be expressed in swift but have to parachutted in by the compiler. If you read Chris&#39; initial message you will see that he said as much, that adopting P&amp;Q as syntax was leaving a gap that the compiler would have to magically fill. <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol Foo { … }<br>&gt;&gt; <br>&gt;&gt; means<br>&gt;&gt; <br>&gt;&gt; protocol Foo : Any { … }<br>&gt;&gt; <br>&gt;&gt; That’s less magic than creating a special syntax just to express the top type.<br>&gt; <br>&gt; I will try again... Would it be easier to understand it if instead of magic I said arbitrary?  You are creating a special case: you decide arbitrarily that the special series of characters &#39;A&#39; &#39;n&#39; &#39;y&#39; with this precise casing and without any spaces is going to be adorned with a special meaning when used in specific situations. This is not something you deduced. My approach is exactly the opposite:  _[] does not describe the top type because I have a special affinity with these characters, it describes the top type because it is the only possible logical conclusion from having followed a set of rules attached to a syntax that describes ALL existentials. And because it is not particularly savory, I typealias it to something else. But this is not in the compiler, it us in the standard linrary... inside swift, not outside.<br></p><p>Ok, that&#39;s a good argument. But your proposal does not contain those rules.<br>Why should _[] describe the top type? You just say this in your proposal, but you do not define rules what _[] means.<br>_[A,B] describes the type intersection of A and B, i.e. it contains all members of A which are also members of B. _[] does not list any types, so one might conclude that it has no members and therefore must be the bottom type!<br>Or _[A,B] in reality means _[A,B,Any], i.e. A &amp; B &amp; Any which of course is equal to A &amp; B. Then _[] would just mean Any, but we would have had to introduce the top type explicitly again.<br></p><p>On the other hand if we declare a protocol Any and define protocol A {...} to mean protocol A: Any {...} there is not really something special in the compiler except for adding the conformance which seems very minor to me. Everything else is just standard behavior of the type system.<br></p><p><br>&gt; Read Chris&#39; original announcement.. He describes P&amp;Q as it would be adopted today as being just a CORNER CASE of a single general principal... a single grammar that can work today to describe P&amp;Q as well as generalize existentials tomorrow. No special treatment, single parser, single rule. I don&#39;t like to write un-necessary IF statements in code.<br></p><p>Sorry, I do not understand what you mean here: where would you have to write unnecessary if-statements?<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br>&gt;&gt;&gt; The _[] case is just a degenerate case of the syntax, showing that it is expressible inside, as opposoed to have to define a contextual keyword (read the SourceKit code). And then it is aliasable. Part of the problems in swift today to me is that some things are no doable in swift, so the compiler must contain that semantic. This here is just one example, but there are others. These are notions that the standard library has to defer to the compiler. Some of them have been tabled for 4.0 it seems. My point here was that it is not fate, and choosing the syntax carefully for existentials (whichever it is, i don&#39;t really care inthe end) would prevent having to add a magic keyword for to top type to the compiler and to SourceKit again (they are trying to remove them).<br>&gt;&gt; <br>&gt;&gt; `Any` would *not* be a keyword. It is just a type name like `Collection` or `Int`. Like I said, the only magic would be in adding `: Any` to type definitions without a conforming clause.<br>&gt; <br>&gt; I hope that by now you understand what magic I was talking about.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for the current Any&lt;...&gt; proposal for generalizing existentials it is IMHO cluncky and magic. There is nothing stopping us mechanically from entering Any&lt;UITableView, UIButton&gt;. To me that is the holemark of bad design. In what I tested you just can&#39;t do it and the reason is clear. Of course when I<br>&gt;&gt; <br>&gt;&gt; `Any&lt;UITableView, UIButton&gt;` is just an intersection type and would be written UITableView &amp; UIButton. And, yes, that would be ok, because it would be just the empty set, i.e. the bottom type (which has no members). There is no magic involved, it is just the normal result of an intersection: each type is a set containing all instances of this type (instances conforming to it)<br>&gt; <br>&gt; You can&#39;t be serious? You are saying that to you the ide should not be telling us we are writting an absurdity? And this one was obvious, but it gets a lot worse with more complex types.<br></p><p>Why is an empty intersection absurd? The beauty is that all type expressions sort out automatically by applying simple set rules. And it actually does make sense!<br></p><p>struct Set&lt;T&gt; {<br>    // answer any one element<br>    func any() -&gt; T?<br>}<br>func intersect&lt;T, U&gt;(a: Set&lt;T&gt;, b: Set&lt;U&gt;) -&gt; Set&lt;T &amp; U&gt; {...}<br></p><p>let x: Set&lt;UITableView&gt; = ...<br>let y: Set&lt;UIButton&gt; = ..<br>let z = intersect(x, y) // has type Set&lt;Bottom&gt;<br>z.any // has type Optional&lt;Bottom&gt; and therefore can only be nil<br></p><p>Therefore the type system statically knows that the intersection of those sets is always empty. No need to declare this as invalid. It just works correctly and gives the results you would expect without need for special casing and compiler magic (which we both would like to keep small).<br></p><p>-Thorsten <br></p><p><br>&gt;&gt; . Intersecting two sets might result in an empty set. The type denoting the empty set is the bottom type which is the subtype of all types and might be called `Nothing` or `Never` or `Bottom`.<br>&gt;&gt; Ceylon makes very nice use of type intersections and type unions and the beautiful thing is that these type operations really just work like you would expect if you think of types as sets (which is the standard definition for a type AFAIK). No surprises and no magic there!<br>&gt;&gt; <br>&gt;&gt; So it is *not* a sign of bad design, quite to the contrary! What did you test it with? Probably not Ceylon, because otherwise you would have seen that it just works.<br>&gt; <br>&gt; Hey, who knows, ceylon may one day come to llvm... <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; say you can&#39;t I do not mean that your keyboard will zap u if you try. But the way to verify correctness is different... and in a world where xcode would be a good ide, then code completion would even show you why and actually truly assist (because the grammar i tested makes really makes it possible). I know that xcode is only as good as SourceKit lets it be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt;&gt;&gt;&gt; Java supports co/contra variant params<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You mean Java 10?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. After 10. Than is their only date hint.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about with respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt;&gt;&gt;&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into a partial reification in the jvm. It seems the decision for now is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I hope typesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ... x is String?<br>&gt;&gt;&gt;&gt;&gt; If let! x {}<br>&gt;&gt;&gt;&gt;&gt; That runs as<br>&gt;&gt;&gt;&gt;&gt; if let x = x {}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; something equally short could be done here.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is one big difference: default methods, but it seems swift will add that soon.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift already has default extension methods, doesn’t it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, and no. It has differently dispatched code that can be found to fill in the gap of the conformance req, yes. But Joe Grof (?) said that there are no reasons why these could not be added. Having true defaults could be one way to deal with optional comformance…<br>&gt;&gt; <br>&gt;&gt; The dispatch issue only arises for extensions introducing a method that is not declared in a protocol. That is something you *cannot* do in Java. Java’s default methods are implementations for methods declared in interfaces. Swift’s extension methods providing defaults for methods declared in a protocol are dynamically dispatched and should work like Java’s default methods.<br>&gt; <br>&gt; I think we should agree to disagree.<br>&gt; <br>&gt; <br>&gt;&gt; (One caveat exists with subclasses where the superclasses didn’t implement the method because I then am not allowed to `override` the default method but that is a bug IMO).<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt; func mustImplement()<br>&gt;&gt;&gt; default canImplement() { } <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related data there:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I care more about existentials, but only because of the kind of java i wrote for a living. I just looked at a bunch of opensource swift libs (particularly for server side swift)... some of it is a real engineering disaster: 20+ folders, each with 2 source files... or 3 folders &quot;extensions&quot; &quot;utils&quot; &quot;classes&quot;. Swift is currently not equiped for people to write big things with... I wish the team would address it sooner than later (look at their own c++ code to see the difference). IMHO import conflicts are more often the symptom of bad code than a real issue.<br>&gt;&gt; <br>&gt;&gt; Alas, most languages suffer from poor module systems. A good module system should not only allow resolving conflicts between modules and making it possible to structure code well, but solve the issue around versioned modules so that is is possibly to safely use different versions of the same module in the same application.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -THorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 12, 2016 at 09:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br>&gt; On Jun 11, 2016, at 11:43 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 11.06.2016 um 15:08 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 11, 2016, at 2:05 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 11.06.2016 um 12:38 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 11, 2016, at 11:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 11.06.2016 um 08:00 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards<br>&gt;&gt;&gt;&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 10, 2016, at 9:35 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a generic parameter `T: Collection` denotes a specific (though unknown) member of that type family and `Any&lt;Collection&gt;` denotes the type family again, so there is really no point in writing Any&lt;Collection&gt; IMO. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols vs. classes has had me confused somewhat and I think there are still some misconceptions present on this list sometimes, so I’ll try to clear them up:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very different from generics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is the way the type parameters are bound: generics use explicit parameter lists whereas protocols use inheritance. That has some advantages (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is nothing more than adding the ability to protocols to bind the parameters to be used just like Java’s wildcards are adding the opposite feature to generics, namely not having to bind all parameters.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; btw, i tried to to see if Any&lt;&gt; could have a simpler alternative<br>&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you know I like using `&amp;` as type intersection operator. But you write &quot;The syntax leave a void when it comes to expressing the so called Top type:“<br>&gt;&gt;&gt;&gt;&gt; Why? Just give the top type a name, e.g. `Any` and you are done.<br>&gt;&gt;&gt;&gt; Yes.. I just don&#39;t like magic. I think that all types should be expressable with a syntax and that you can then decide to alias one parsing case with a specific name. Not the other way around.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I think that would be backwards, because we have a nominal type system. That means that the syntax for a type is just its name.<br>&gt;&gt; <br>&gt;&gt; I realize we do not understand each other. <br>&gt;&gt; The words we use now to describe a behavior are just that, words. As is the concepts they describe are useless to the computer running the compiler.<br>&gt;&gt; So we need to map these concepts into a heuristic that a fast but dumb computer will be able to reason with. The code to do that will be either clean and organized, or it will look contrived and full of different paths that will be difficult to mesh together. Of all the possible ways in which swift can behave as a language, some will lead to the former, others to the latter code. I think this is not fate or something you find out after the decision was made and you struggle to carry it through. This is something that can partially be predicted. One of the tools for such prediction is to translate the concepts into a grammar that will show formalize the logic. The simpler the logic, the cleaner (not simple) the final code. <br>&gt;&gt; <br>&gt;&gt; Saying that the syntax for a type is a name is of no use whatsoever for the compiler implementer. It is so universally true that it cannot help in any way whatsoever decide the shape of the swift grammar, much less the structure of the c++ code implementing it.<br>&gt;&gt; <br>&gt;&gt;&gt; `&amp;` is a type operator which creates a new type from its operands.<br>&gt;&gt;&gt; `where` clauses add constraints to types.<br>&gt;&gt;&gt; But it all starts with a type&#39;s name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only magic would be that all type definitions (`protocol` etc.) which do not give a supertype they conform to, will implicitly conform to `Any`, i.e.<br>&gt;&gt; <br>&gt;&gt; I call magic the core notions of swift that cannot be expressed in swift but have to parachutted in by the compiler. If you read Chris&#39; initial message you will see that he said as much, that adopting P&amp;Q as syntax was leaving a gap that the compiler would have to magically fill. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; means<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo : Any { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s less magic than creating a special syntax just to express the top type.<br>&gt;&gt; <br>&gt;&gt; I will try again... Would it be easier to understand it if instead of magic I said arbitrary?  You are creating a special case: you decide arbitrarily that the special series of characters &#39;A&#39; &#39;n&#39; &#39;y&#39; with this precise casing and without any spaces is going to be adorned with a special meaning when used in specific situations. This is not something you deduced. My approach is exactly the opposite:  _[] does not describe the top type because I have a special affinity with these characters, it describes the top type because it is the only possible logical conclusion from having followed a set of rules attached to a syntax that describes ALL existentials. And because it is not particularly savory, I typealias it to something else. But this is not in the compiler, it us in the standard linrary... inside swift, not outside.<br>&gt; <br>&gt; Ok, that&#39;s a good argument. But your proposal does not contain those rules.<br>&gt; Why should _[] describe the top type? You just say this in your proposal, but you do not define rules what _[] means.<br>&gt; _[A,B]<br></p><p>don&#39;t know where this comes from. This is incorrect and the parser would reject it.<br></p><p>&gt; describes the type intersection of A and B, i.e. it contains all members of A which are also members of B. _[] does not list any types, so one might conclude that it has no members and therefore must be the bottom type!<br>Are you saying that protocol&lt;&gt; is the bottom type of Swift then? Because if you disect the logic it follows to explain why it is a top type and apply the exact same reasoning to  _[] then you should reach the same conclusion {same effects produce the same conclusions}<br></p><p>&gt; Or _[A,B] in reality means _[A,B,Any],i.e. A &amp; B &amp; Any which of course is equal to A &amp; B. Then _[] would just mean Any, but we would have had to introduce the top type explicitly again.<br>From cause to effects. Any is an effect (a conclusion we reach) rather than a cause (something we posit before starting the discussion). Like I explained, Any is a stdlib provided convenient typealias for _[] as opposed to a parachuted concept born inside the compiler. Btw, it means a different stdlib could redefine it as All, without altering the compiler. Any is not core to swift&#39;s structure, but _[] is because it is borne out of the mechanical uniformity of the grammar.<br></p><p>&gt; On the other hand if we declare a protocol Any and define protocol A {...} to mean protocol A: Any {...} there is not really something special in the compiler except for adding the conformance which seems very minor to me. Everything else is just standard behavior of the type system.<br></p><p>You are back to adding some magic that I just demonstrated is not required if the grammar is simple (not that i could add it to my grammar to please you, but then it would not eliminate any of the other definitions, and would just complicate the parser and type checker to ensure that people use it correctly. Per Ockham&#39;s principle, the system i describe is a better alternative.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; Read Chris&#39; original announcement.. He describes P&amp;Q as it would be adopted today as being just a CORNER CASE of a single general principal... a single grammar that can work today to describe P&amp;Q as well as generalize existentials tomorrow. No special treatment, single parser, single rule. I don&#39;t like to write un-necessary IF statements in code.<br>&gt; <br>&gt; Sorry, I do not understand what you mean here: where would you have to write unnecessary if-statements?<br></p><p>Close your eyes and make a mental representation of what the code to implement the Any&lt;....&gt; proposal will necessarily look like... that is what I am referring to. That code cannot not be uggly. Because some of of things a parser typically should catch are not discernsble, and therefore have to be differed to the type checker. By comparison, look at the grammar I wrote and picture the code to implement it. The picture will look very different, and the parser can already eliminate a lot of things that never reach the type checker.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why should the top type have special *syntax*? It is just the type all other types conform to. No need to do something special here and therefore no need to invent an alternative syntax like `Any&lt;&gt;` or the alternative from your gist which is rather confusing IMO (and I don’t like the special case given to classes in the syntax).<br>&gt;&gt;&gt;&gt; The _[] case is just a degenerate case of the syntax, showing that it is expressible inside, as opposoed to have to define a contextual keyword (read the SourceKit code). And then it is aliasable. Part of the problems in swift today to me is that some things are no doable in swift, so the compiler must contain that semantic. This here is just one example, but there are others. These are notions that the standard library has to defer to the compiler. Some of them have been tabled for 4.0 it seems. My point here was that it is not fate, and choosing the syntax carefully for existentials (whichever it is, i don&#39;t really care inthe end) would prevent having to add a magic keyword for to top type to the compiler and to SourceKit again (they are trying to remove them).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `Any` would *not* be a keyword. It is just a type name like `Collection` or `Int`. Like I said, the only magic would be in adding `: Any` to type definitions without a conforming clause.<br>&gt;&gt; <br>&gt;&gt; I hope that by now you understand what magic I was talking about.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for the current Any&lt;...&gt; proposal for generalizing existentials it is IMHO cluncky and magic. There is nothing stopping us mechanically from entering Any&lt;UITableView, UIButton&gt;. To me that is the holemark of bad design. In what I tested you just can&#39;t do it and the reason is clear. Of course when I<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `Any&lt;UITableView, UIButton&gt;` is just an intersection type and would be written UITableView &amp; UIButton. And, yes, that would be ok, because it would be just the empty set, i.e. the bottom type (which has no members). There is no magic involved, it is just the normal result of an intersection: each type is a set containing all instances of this type (instances conforming to it)<br>&gt;&gt; <br>&gt;&gt; You can&#39;t be serious? You are saying that to you the ide should not be telling us we are writting an absurdity? And this one was obvious, but it gets a lot worse with more complex types.<br>&gt; <br></p><p>Take a screenshot next time you see a &quot;let x:Any&lt;UITableView, UIButton&gt;&quot; in an app and send it to me. The absurdity would be for the compiler to generate a binary, the app to start, and us to wonder why x the code depending on x would never execute. Seems obvious to you why now? <br></p><p>not debatting past here I can&#39;t see how it relates (it is interesting but you may want to look at the whole thing from a &#39;whats usefull&#39; perspective, rather than as &#39;whats combinatorially possible&#39;<br></p><p>&gt; Why is an empty intersection absurd? The beauty is that all type expressions sort out automatically by applying simple set rules. And it actually does make sense!<br>&gt; <br>&gt; struct Set&lt;T&gt; {<br>&gt;    // answer any one element<br>&gt;    func any() -&gt; T?<br>&gt; }<br>&gt; func intersect&lt;T, U&gt;(a: Set&lt;T&gt;, b: Set&lt;U&gt;) -&gt; Set&lt;T &amp; U&gt; {...}<br>&gt; <br>&gt; let x: Set&lt;UITableView&gt; = ...<br>&gt; let y: Set&lt;UIButton&gt; = ..<br>&gt; let z = intersect(x, y) // has type Set&lt;Bottom&gt;<br>&gt; z.any // has type Optional&lt;Bottom&gt; and therefore can only be nil<br>&gt; <br>&gt; Therefore the type system statically knows that the intersection of those sets is always empty. No need to declare this as invalid. It just works correctly and gives the results you would expect without need for special casing and compiler magic (which we both would like to keep small).<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt;&gt; . Intersecting two sets might result in an empty set. The type denoting the empty set is the bottom type which is the subtype of all types and might be called `Nothing` or `Never` or `Bottom`.<br>&gt;&gt;&gt; Ceylon makes very nice use of type intersections and type unions and the beautiful thing is that these type operations really just work like you would expect if you think of types as sets (which is the standard definition for a type AFAIK). No surprises and no magic there!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So it is *not* a sign of bad design, quite to the contrary! What did you test it with? Probably not Ceylon, because otherwise you would have seen that it just works.<br>&gt;&gt; <br>&gt;&gt; Hey, who knows, ceylon may one day come to llvm... <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; say you can&#39;t I do not mean that your keyboard will zap u if you try. But the way to verify correctness is different... and in a world where xcode would be a good ide, then code completion would even show you why and actually truly assist (because the grammar i tested makes really makes it possible). I know that xcode is only as good as SourceKit lets it be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that Swift’s Collection had no additional associated types; otherwise I would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt;&gt;&gt;&gt;&gt; Java supports co/contra variant params<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Java has no declaration-site variance like Ceylon or Scala have (see e.g. http://ceylon-lang.org/blog/2014/07/14/wildcards#why_i_distrust_wildcards_and_why_we_need_them_anyway).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Java’s wildcards are a way to express use-site variance. The proposed `Any&lt;&gt;` does just the same. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This picture is accurate today, but there are going to be more serious differences after 10 no date is currently geven for when it will come)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You mean Java 10?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. After 10. Than is their only date hint.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with wildcards.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, java has kept everything within its generics system rather than split parts out. Something people may not immediately think about with respect to the 2 generic systems is that when u call a func&lt;T&gt;capture(T t){}  in java with a wildcard you are doing a compile time capture only (to avoid the dreaded unsafe casts), whereas it is really nice to do the same in swift and subsequently be able to access T.Type and see that it is not Any. The closest u ever get to that type at runtime in java is via generics introspection, but u still can&#39;t do everything ( like no new T() ). But today the bridging between existential types and generics is definitely a work in progress.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be used as types is useful and (b) whether sacrificing type safety would somehow be necessary for that, I think we can safely answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a) yes, it *is* useful to be able to use existentials like Any&lt;Collection&gt; as types, because wildcards are quite often needed and very useful in Java (they haven’t been added without a reason)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO they made java 8 (referring to streams). And even though the syntax for co/contra variance is pretty heavy, it is the foundation for all modern java code. The any-fication of the generics is going to open new doors as some of it will translate into a partial reification in the jvm. It seems the decision for now is to not use the extra info in java to retain binary compatibility with all the erased code out there, this is something scala might use in areas where it won&#39;t mind loosing java compatibility.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (b) no, sacrificing type safety does not make sense, as the experience with Java’s wildcards shows that this is not needed. Especially if something like path dependent types is used like proposed and some notation to open an existential’s type is added, which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I hope typesafe opening inside the &quot; if let &quot; syntax gets added. I know that chris is against sugaring, but I played if an implementation of<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ... x is String?<br>&gt;&gt;&gt;&gt;&gt;&gt; If let! x {}<br>&gt;&gt;&gt;&gt;&gt;&gt; That runs as<br>&gt;&gt;&gt;&gt;&gt;&gt; if let x = x {}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; something equally short could be done here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has always done. They just use associated types instead of explicit type parameters for generics (see above). The more important distinction of Swift is emphasizing value types and making mutation safely available by enforcing copy semantics for value types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Values are coming to the jvm, which will narrow this gap (like their view identity for value vs ref and the whole deep ==) . I also really like the cow approach of the swift runtime.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But protocols are not really different from interfaces in Java.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is one big difference: default methods, but it seems swift will add that soon.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift already has default extension methods, doesn’t it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, and no. It has differently dispatched code that can be found to fill in the gap of the conformance req, yes. But Joe Grof (?) said that there are no reasons why these could not be added. Having true defaults could be one way to deal with optional comformance…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The dispatch issue only arises for extensions introducing a method that is not declared in a protocol. That is something you *cannot* do in Java. Java’s default methods are implementations for methods declared in interfaces. Swift’s extension methods providing defaults for methods declared in a protocol are dynamically dispatched and should work like Java’s default methods.<br>&gt;&gt; <br>&gt;&gt; I think we should agree to disagree.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (One caveat exists with subclasses where the superclasses didn’t implement the method because I then am not allowed to `override` the default method but that is a bug IMO).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol MyProto {<br>&gt;&gt;&gt;&gt; func mustImplement()<br>&gt;&gt;&gt;&gt; default canImplement() { } <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Related data there:<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I also really like how extensions and conformance mix together in swift to bake retro-modelling in and the adapter pattern (spent enough years deep diving inside eclipse to appreciate it).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would have preferred a unified model using just classes with real multiple inheritance like Eiffel has and value types just being a part of that similar to Eiffel’s `expanded` classes. But that ship has probably sailed a long time ago :-/<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like extensions very much (having used Smalltalk for a long time). I like enums for the pattern matching and structs as value types. But having to split protocols off instead of using abstract classes makes things more complicated IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -1  i am old school c/c++...  i really like protocol, struct, class, extensions, enums. It is a really nice mix that gives objc people room to grow, but I do miss how they are an integral part of generics (i protocols as a replacement and look forward to when they interact better) and namespaces+scoped-imports (c#)... Looking forward to where things go next<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, namespacing/submodules/conflict resolution (when doing imports but also when conforming to multiple protocols which has just the same problems) are still missing. But I’m optimistic :-) Let’s complete generics first, then tackle existentials/type intersections.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I care more about existentials, but only because of the kind of java i wrote for a living. I just looked at a bunch of opensource swift libs (particularly for server side swift)... some of it is a real engineering disaster: 20+ folders, each with 2 source files... or 3 folders &quot;extensions&quot; &quot;utils&quot; &quot;classes&quot;. Swift is currently not equiped for people to write big things with... I wish the team would address it sooner than later (look at their own c++ code to see the difference). IMHO import conflicts are more often the symptom of bad code than a real issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alas, most languages suffer from poor module systems. A good module system should not only allow resolving conflicts between modules and making it possible to structure code well, but solve the issue around versioned modules so that is is possibly to safely use different versions of the same module in the same application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -THorsten<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So be it. But at least there should be no reasons for POP vs OOP wars ;-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (I’d like to add that I liked Dave’s talks at last WWDC very much, it’s just that I don’t think that POP is something new or different.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I used to thin that way. But today I think that although in broad brush strokes the similarities and bigger than the differences, there is room for making a bigger difference in the how.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/2be10b1b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 12, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br></p><p>&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt; point. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt; is not so bad.<br>&gt;&gt; <br>&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt; <br>&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt; <br>&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;<br>&gt; Let me expand that a bit:<br>&gt;<br>&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt; clear them up:<br></p><p>There are several objectively incorrect statements here, and several<br>others with which I disagree.  I was hoping someone else would write<br>this for me, but since the post has such a tone of authority I feel I<br>must respond.<br></p><p>&gt; (1) misconception: protocols with associated types are somehow very<br>&gt; different from generics<br>&gt;<br>&gt; I don’t think they are and I will explain why. The only difference is<br>&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt; These ways are dual in a notation sense: generic types have to have<br>&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt; nothing more than adding the ability to protocols to bind the<br>&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt; opposite feature to generics, namely not having to bind all<br>&gt; parameters.<br></p><p>Protocols and generics fulfill completely different roles in Swift, and<br>so, **especially in a language design context like the one we&#39;re in<br>here**, must be thought of differently.  The former are an abstraction<br>mechanism for APIs, and the latter a mechanism for generalizing<br>implementations.  The only place you could argue that they intersect is<br>in generic non-final classes, because a class fills the dual role of<br>abstraction and implementation mechanism (and some might say that&#39;s a<br>weakness).  But even accounting for generic classes, protocols with<br>associated types are very different from generics.  Two utterly<br>different types (an enum and a struct, for example) can conform to any<br>given protocol P, but generic types always share a common basis<br>implementation.  There is no way to produce distinct instances of a<br>generic type with all its type parameters bound, but for any protocol P<br>I can make infinitely many instances of P with P.AssociatedType == Int.<br></p><p>Back to the my original point: while protocols and generic types have<br>some similarities, the idea that they are fundamentally the same thing<br>(I know you didn&#39;t say *exactly* that, but I think it will be read that<br>way) would be wrong and a very unproductive way to approach language<br>evolution.<br></p><p>&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br></p><p>I don&#39;t see how you can use an example that requires *assuming away*<br>assoociated types to justify an argument that protocols *with associated<br>types* are the same as generics.<br></p><p>&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as<br>&gt; `Collection&lt;? extends Number&gt;` in Java.<br>&gt;<br>&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;<br>&gt; In essence protocols with associated types are like generics with<br>&gt; wildcards.<br></p><p>It is true that generics with wildcards in Java *are* (not just “like”)<br>existential types but I don&#39;t agree with the statement above.  Because<br>Java tries to create an “everything is a class” world, generic classes<br>with bound type parameters end up playing the role of existential type.<br>But protocols in Swift are not, fundamentally, just existential types,<br>and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>context is a huge leap forward in making that distinction clear... when<br>that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>*won&#39;t* be types at all, existential or otherwise.<br></p><p>&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt; used as types is useful <br></p><p>That&#39;s the only use existentials have.  They *are* types.  Of course<br>they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br></p><p>&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt; needed. <br></p><p>I would call this “interesting information,” but hardly conclusive.<br>Java&#39;s generics are almost exactly the same thing as Objective-C<br>lightweight generics, which are less capable and less expressive in<br>many ways than Swift&#39;s generics.  <br></p><p>&gt; Especially if something like path dependent types is used like<br>&gt; proposed and some notation to open an existential’s type is added,<br>&gt; which is both something that Java does not have.<br>&gt;<br>&gt; (2) misconception: POP is different from OOP<br>&gt;<br>&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt; always done. They just use associated types instead of explicit type<br>&gt; parameters for generics (see above). <br></p><p>They are not the same thing at all (see above ;-&gt;).  To add to the list<br>above, protocols can express fundamental relationships—like Self<br>requirements—that OOP simply can&#39;t handle.  There&#39;s a reason Java can&#39;t<br>express Comparable without losing static type-safety.  Finally, in a<br>language with first-class value types, taking a protocol-oriented<br>approach to abstraction leads to *fundamentally* different designs from<br>what you get using OOP.<br></p><p>&gt; The more important distinction of Swift is emphasizing value types and<br>&gt; making mutation safely available by enforcing copy semantics for value<br>&gt; types.  <br></p><p>We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>something I&#39;d like to change.  But regardless, value types would be a<br>*lot* less useful if they couldn&#39;t conform to protocols, and so they<br>would be a lot less used.  Heck, before we got protocol extensions in<br>Swift 2, there was basically *no way* to share implementation among<br>value types.  So you can&#39;t take protocols out of the picture without<br>making value types, and the argument for value semantics, far weaker.<br></p><p>&gt; But protocols are not really different from interfaces in Java. <br>&gt; I would have preferred a unified model using just classes with real<br>&gt; multiple inheritance like Eiffel has and value types just being a part<br>&gt; of that similar to Eiffel’s `expanded` classes. But that ship has<br>&gt; probably sailed a long time ago :-/ So be it. But at least there<br>&gt; should be no reasons for POP vs OOP wars ;-) (I’d like to add that I<br>&gt; liked Dave’s talks at last WWDC very much, it’s just that I don’t<br>&gt; think that POP is something new or different.)<br></p><p>Protocol-oriented programming is about the synergy of features and ideas<br>most of which not *individually* new, but that together create a new<br>world of possibilities.  I&#39;ve already discussed the synergy of protocols<br>and first-class value semantics.  There&#39;s also the fact that in<br>protocols we have one construct with which to express dynamic<br>polymorphism (existentials) and static polymorphism (generic<br>constraints), both of which have important roles to play but that I<br>maintain are very different indeed.  One result is that you can “start<br>with a protocol” as your abstraction mechanism and know that you&#39;re not<br>going to design yourself into a corner where it becomes impossibly<br>awkward to express what you need.  Finally—and I&#39;m certain this *is*<br>new—in protocol extensions we have a means to express both post-hoc<br>conformance and generic functions that is much more accessible to users<br>than in any previous language, to the point where generic programming<br>can become a natural part of everyday work.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>June 13, 2016 at 08:00:00am</p></header><div class="content"><p>Hello Dave,<br></p><p>Sent from my iPhone<br></p><p>&gt; On 13 Jun 2016, at 03:04, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt; <br>&gt;&gt; Let me expand that a bit:<br>&gt;&gt; <br>&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt; clear them up:<br>&gt; <br>&gt; There are several objectively incorrect statements here, and several<br>&gt; others with which I disagree.  I was hoping someone else would write<br>&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt; must respond.<br>&gt; <br>&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt; different from generics<br>&gt;&gt; <br>&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt; parameters.<br>&gt; <br>&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt; implementations.  The only place you could argue that they intersect is<br>&gt; in generic non-final classes, because a class fills the dual role of<br>&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt; associated types are very different from generics.  Two utterly<br>&gt; different types (an enum and a struct, for example) can conform to any<br>&gt; given protocol P, but generic types always share a common basis<br>&gt; implementation.  There is no way to produce distinct instances of a<br>&gt; generic type with all its type parameters bound, but for any protocol P<br>&gt; I can make infinitely many instances of P with P.AssociatedType == Int.<br>&gt; <br>&gt; Back to the my original point: while protocols and generic types have<br>&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt; way) would be wrong and a very unproductive way to approach language<br>&gt; evolution.<br>&gt; <br>&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt; <br>&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt; assoociated types to justify an argument that protocols *with associated<br>&gt; types* are the same as generics.<br>&gt; <br>&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as<br>&gt;&gt; `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt; <br>&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt; <br>&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt; wildcards.<br>&gt; <br>&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt; with bound type parameters end up playing the role of existential type.<br>&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt; context is a huge leap forward in making that distinction clear... when<br>&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt; <br>&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt; used as types is useful<br>&gt; <br>&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt; <br>&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt; needed.<br>&gt; <br>&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt; lightweight generics, which are less capable and less expressive in<br>&gt; many ways than Swift&#39;s generics.  <br>&gt; <br>&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt; which is both something that Java does not have.<br>&gt;&gt; <br>&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt; <br>&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt; parameters for generics (see above).<br>&gt; <br>&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt; above, protocols can express fundamental relationships—like Self<br>&gt; requirements—that OOP simply can&#39;t handle.  There&#39;s a reason Java can&#39;t<br>&gt; express Comparable without losing static type-safety.  Finally, in a<br>&gt; language with first-class value types, taking a protocol-oriented<br>&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt; what you get using OOP.<br>&gt; <br>&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt; types.  <br>&gt; <br>&gt; We don&#39;t, in fact, enforce copy semantics for value types.  <br></p><p>It was again clarified that Copy on Write was only automatically added for Strings and Arrays, and subclasses I suppose, but how else are structs passed around if not by copy? If they are passed around by reference and people are starting, being encouraged to do so, to massively make use of structs... will enforcing copy semantics (even with opt-in CoW behaviour) be a massive cause of performance regression in games and similar kinds of tight processing loops? <br></p><p>&gt; That&#39;s<br>&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt; value types.  <br></p><p>Ah so it is their (value types) fault our beautiful abstract API contracts meant to decouple behaviour from implementation now contain code and this implementation ;)?<br></p><p>The other day I was revisiting the rationale by Java engineers for default methods in Java interfaces, which I always used to compare Objective-C protocols to, and beside from the ease of adding code to a lot of pre-existing objects without forcing developers using a library to have to do much to adapt to a new update of said library... Well, I did not actually find much beyond convenience. <br>In Swift, they are already enabling structs to do something you could have only done with classes before (sharing implementation): in a way it is kind of forcing people to use composition over subclassing without as much effort as before.<br></p><p>Still, I appreciated how clear dispatching/overriding rules were designed (although they may be limiting for some use cases people here might conceive):<br>&gt; When you extend an interface that contains a default method, you can do the following:<br>&gt; * Not mention the default method at all, which lets your extended interface inherit the default method.<br>&gt; * Redeclare the default method, which makes it abstract.<br>&gt; * Redefine the default method, which overrides it.<br>https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html<br></p><p>I find that quite intuitive to adapt to. What I would like to ask you is this: don&#39;t you feel it is dangerous or at least unintuitive that casting generally does not allow to change how the object behaves (it does not interfere with the object&#39;s implementation of its API contract) while if you are using default methods in protocol extensions you are suddenly allowing casting to change the class implementation?<br></p><p>Are extensions and in particular default methods meant more for value types, implementation sharing too as you were saying, than classes?<br></p><p>&gt; So you can&#39;t take protocols out of the picture without<br>&gt; making value types, and the argument for value semantics, far weaker.<br>&gt; <br>&gt;&gt; But protocols are not really different from interfaces in Java. <br>&gt;&gt; I would have preferred a unified model using just classes with real<br>&gt;&gt; multiple inheritance like Eiffel has and value types just being a part<br>&gt;&gt; of that similar to Eiffel’s `expanded` classes. But that ship has<br>&gt;&gt; probably sailed a long time ago :-/ So be it. But at least there<br>&gt;&gt; should be no reasons for POP vs OOP wars ;-) (I’d like to add that I<br>&gt;&gt; liked Dave’s talks at last WWDC very much, it’s just that I don’t<br>&gt;&gt; think that POP is something new or different.)<br>&gt; <br>&gt; Protocol-oriented programming is about the synergy of features and ideas<br>&gt; most of which not *individually* new, but that together create a new<br>&gt; world of possibilities.  I&#39;ve already discussed the synergy of protocols<br>&gt; and first-class value semantics.  There&#39;s also the fact that in<br>&gt; protocols we have one construct with which to express dynamic<br>&gt; polymorphism (existentials) and static polymorphism (generic<br>&gt; constraints), both of which have important roles to play but that I<br>&gt; maintain are very different indeed.  One result is that you can “start<br>&gt; with a protocol” as your abstraction mechanism and know that you&#39;re not<br>&gt; going to design yourself into a corner where it becomes impossibly<br>&gt; awkward to express what you need.  Finally—and I&#39;m certain this *is*<br>&gt; new—in protocol extensions we have a means to express both post-hoc<br>&gt; conformance and generic functions that is much more accessible to users<br>&gt; than in any previous language, to the point where generic programming<br>&gt; can become a natural part of everyday work.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/60025814/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 13, 2016 at 10:00:00am</p></header><div class="content"><p>I had decided to watch from the sideline, but a couple things push me to say something<br></p><p><br>&gt; On Jun 13, 2016, at 4:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com &lt;http://tseitz42-at-icloud.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt; point. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt; <br>&gt;&gt; Let me expand that a bit:<br>&gt;&gt; <br>&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt; clear them up:<br>&gt; <br>&gt; There are several objectively incorrect statements here, and several<br>&gt; others with which I disagree.  I was hoping someone else would write<br>&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt; must respond.<br>&gt; <br>&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt; different from generics<br>&gt;&gt; <br>&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt; parameters.<br>&gt; <br>&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt; here**, must be thought of differently.  <br></p><p>The temptation is great to mention your own words from 2+ years ago regarding the choice of the name Protocol instead of Interface, and the ‘hope’ (your word) that the differentiation would wind-up being big enough to justify the new name. Wanting to view them in a different light is one thing, succeeding in establishing a gap wide enough that people with superficial or intimate knowledge of both would come to the unavoidable conclusion that they are fundamentally different, is an entirely different exercise.<br></p><p>At this point I think it is fair to say that the differences are notable but, perhaps out of lack of familiarity with the details, not quite strong enough to make all developers reach the conclusion you’d like them to reach.<br></p><p>&gt; The former are an abstraction<br>&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt; implementations. The only place you could argue that they intersect is<br>&gt; in generic non-final classes, because a class fills the dual role of<br>&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt; associated types are very different from generics.  Two utterly<br>&gt; different types (an enum and a struct, for example) can conform to any<br>&gt; given protocol P, but generic types always share a common basis<br>&gt; implementation.  There is no way to produce distinct instances of a<br>&gt; generic type with all its type parameters bound, but for any protocol P<br>&gt; I can make infinitely many instances of P with P.AssociatedType == Int.<br></p><p>somehow I think both your arguments contain some truth. You are pointing out the differentiating fact that a Protocol is abstracting across multiple concrete types, while he is showing that the mechanism in which associated types in a Protocol is reminiscent of the way a type T operates on a generic type. The two are not mutually exclusive.<br></p><p>In all cases, &quot;A is to B what 1 is to 2” has never meant that 1 and A are the same, it simply means that the relationship inside each pair operates in a similar fashion to the relationship within the other pair; which again is very different from saying that the relationships are the same. In this context, I think that there is a strong case for wanting to further bridge the gap, as was even pointed out by Doug in his Generics Manifesto. Not to mention that Java and a few others are there to demonstrate how far the similarities can be pushed. <br></p><p>&gt; Back to the my original point: while protocols and generic types have<br>&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt; way) would be wrong and a very unproductive way to approach language<br>&gt; evolution.<br></p><p>Yes, similarities are just that, and I am absolutely with you to claim that they are NOT THE SAME, and it is unfortunate that analogies get so often confused with alike-ness. Although it is undeniably helpful for people to learn new concepts via their alike-ness to other concepts, it can also create the wrong mental picture. Unfortunately I think that 10s of thousands of years of evolution are conspiring to make our brains likely to jump from analogous to alike quite readily, wiping out critical differences in the process.<br></p><p>&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt; <br>&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt; assoociated types to justify an argument that protocols *with associated<br>&gt; types* are the same as generics.<br></p><p>You might have to write a lot of educational material on the language to cast the “the relationship between protocols and their associated types is analogous to the relationship of a generic type and its parameters” in stone, and dispel the “protocols are the same as generics” views. I do hope this is a topic you will dwell-on in your presentation at WWDC this week, openly presenting the similarities to better point out the critical differences !!!! :) <br></p><p>&gt;&gt; Likewise `Any&lt;Collection where .Element: Number&gt;` is just the same as<br>&gt;&gt; `Collection&lt;? extends Number&gt;` in Java.<br>&gt;&gt; <br>&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt; <br>&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt; wildcards.<br>&gt; <br>&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt; Java tries to create an “everything is a class” world,generic classes<br>&gt; with bound type parameters end up playing the role of existential type.<br>&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br></p><p>for as much as I would prefer the  &quot;var p : ProtocolName” and its extension to “var t : UITableView[UITableViewDataSource &amp; UITableViewDelegate], I do understand wanting to surrender to Any&lt;UITableView &amp; UITableViewDelegate&gt; to carve the difference with the Generics in the hardest marble. But I do think that over time people will forget the meaning and just get into the habit of writing code that will just work.<br></p><p>&gt; context is a huge leap forward in making that distinction clear... when<br>&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt; <br>&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt; used as types is useful <br>&gt; <br>&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br></p><p>:) I sure hope not… <br></p><p>&gt; <br>&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt; needed. <br>&gt; <br>&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt; lightweight generics, which are less capable and less expressive in<br>&gt; many ways than Swift&#39;s generics.  <br></p><p>This is the part that had me jump in my seat… With all due respect, I find this a very reductionist view. As things stand, Java generics covers both classes and interfaces equally, which the swift generics+protocol&amp;assocType is far from doing. It has to be the case or this thread would not exist and Austin and myself would not have bothered to write long proposals to attempt to fill the gap. <br>Furthermore, Java &amp; JVM are currently undergoing an effort to any-fy the generics system that will result in a number of new doors opening: Collection&lt;any&gt; that includes int, reification of generic parameters inside the .class, … when coupled with the other ongoing effort to add value types, then the difference with swift would be in the direction of swift having some serious catchup to do. I do hope that the current status-quo between Generics and Protocols will not remain what it is and that some form of the extended existential proposals (ok… I can’t resists: https://gist.github.com/lmihalkovic/68c321ea7ffe27e553e37b794309b051) will have made it into swift by then. <br></p><p>I place existentials/dynamic polymorphism high on my TODO because looking at the evolution of Java in the last 3 years, the greatest leaps have come from this part of the language. But I do understand that when looking at where Apple developers come from with Objc, it may seem that that this form of abstraction may seem far away on their priority list. However IMHO designing swift to be a simple upgrade for objc might be missing the point that today, even Typescript has a very powerful way of abstracting over generic interfaces.<br></p><p>&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt; which is both something that Java does not have.<br>&gt;&gt; <br>&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt; <br>&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt; parameters for generics (see above). <br>&gt; <br>&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt; above, protocols can express fundamental relationships—like Self<br>&gt; requirements—that OOP simply can&#39;t handle.  There&#39;s a reason Java can&#39;t<br>&gt; express Comparable without losing static type-safety.  <br></p><p>self requirements on interfaces would be a very nice addition to java… <br></p><p>&gt; Finally, in a<br>&gt; language with first-class value types, taking a protocol-oriented<br>&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt; what you get using OOP.<br></p><p>Looking at the code people actually write, I’m afraid this may be a tough battle to win… <br></p><p>&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt; types.  <br>&gt; <br>&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt; making value types, and the argument for value semantics, far weaker.<br>&gt; <br>&gt;&gt; But protocols are not really different from interfaces in Java. <br>&gt;&gt; I would have preferred a unified model using just classes with real<br>&gt;&gt; multiple inheritance like Eiffel has and value types just being a part<br>&gt;&gt; of that similar to Eiffel’s `expanded` classes. But that ship has<br>&gt;&gt; probably sailed a long time ago :-/ So be it. But at least there<br>&gt;&gt; should be no reasons for POP vs OOP wars ;-) (I’d like to add that I<br>&gt;&gt; liked Dave’s talks at last WWDC very much, it’s just that I don’t<br>&gt;&gt; think that POP is something new or different.)<br>&gt; <br>&gt; Protocol-oriented programming is about the synergy of features and ideas<br>&gt; most of which not *individually* new, but that together create a new<br>&gt; world of possibilities.  I&#39;ve already discussed the synergy of protocols<br>&gt; and first-class value semantics.  There&#39;s also the fact that in<br>&gt; protocols we have one construct with which to express dynamic<br>&gt; polymorphism (existentials) and static polymorphism (generic<br>&gt; constraints), both of which have important roles to play but that I<br>&gt; maintain are very different indeed.  One result is that you can “start<br>&gt; with a protocol” as your abstraction mechanism and know that you&#39;re not<br>&gt; going to design yourself into a corner where it becomes impossibly<br>&gt; awkward to express what you need. Finally—and I&#39;m certain this *is*<br>&gt; new—in protocol extensions we have a means to express both post-hoc<br>&gt; conformance and generic functions that is much more accessible to users<br>&gt; than in any previous language, to the point where generic programming<br>&gt; can become a natural part of everyday work.<br></p><p>As a long term Erich Gama fan and Eclipse cave-diver, I do wholeheartedly agree that protocol extensions is an incredible feature!!! It would have done wonders for all the adapters I have had to write, to be able to do that in java directly. I hope you manage to make people see how powerful they are today, and make them even more powerful in the future. As you bring the topic, I had gathered some thoughts on methods dispatching in protocol extensions : https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018560.html<br></p><p>Looking forward to a presentation on POP/Extensions/Generics this week.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/113c3bfc/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt; <br>&gt;&gt; Let me expand that a bit:<br>&gt;&gt; <br>&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt; clear them up:<br>&gt; <br>&gt; There are several objectively incorrect statements here, and several<br>&gt; others with which I disagree.  I was hoping someone else would write<br>&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt; must respond.<br></p><p>You are right, the tone of my post was not appropriate, for which I want to apologize sincerely.<br></p><p>I still believe my statements to be valid, though, and will respond to your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to have an argument for the argument&#39;s sake. All I want is to contribute maybe a tiny bit to make Swift even better than it already is, by sharing ideas and thoughts not only from me but from the designs of other perhaps more obscure programming languages which I happen to have stumbled upon in the past (often with much delight). <br></p><p>&gt; <br>&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt; different from generics<br>&gt;&gt; <br>&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt; parameters.<br>&gt; <br>&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt; implementations.  <br></p><p>That&#39;s not what I was talking about. Of course, protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols. In addition I was talking about generics in general, not just about generics in Swift which restricts them to implementations and does not support wildcards.<br>Other languages like Java offer generics for interfaces as well and support wildcards (adding generic types parameters to protocols in Swift is currently discussed on the mailing list as well).<br>FWIW my arguments were not about whether we should have wildcards in Swift or not, but simply to relate one parametrization feature (associated types) to a more well known parametrization feature (generics with wildcards) in order to understand them better.<br></p><p>&gt; The only place you could argue that they intersect is<br>&gt; in generic non-final classes, because a class fills the dual role of<br>&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt; associated types are very different from generics.  Two utterly<br>&gt; different types (an enum and a struct, for example) can conform to any<br>&gt; given protocol P, but generic types always share a common basis<br>&gt; implementation.  <br></p><p>The latter is not the case for generic interfaces in Java, for example, so it is just an artificial restriction present in Swift.<br></p><p>&gt; There is no way to produce distinct instances of a<br>&gt; generic type with all its type parameters bound, <br></p><p>That is true in Swift (except for generic classes) due to the restriction just mentioned.<br></p><p>&gt; but for any protocol P<br>&gt; I can make infinitely many instances of P with P.AssociatedType == Int.<br></p><p><br>This likewise applies to generic interfaces and for generic types in general if taking inheritance into account - just like you do here for protocols.<br></p><p>&gt; Back to the my original point: while protocols and generic types have<br>&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt; way) would be wrong and a very unproductive way to approach language<br>&gt; evolution.<br></p><p>I said that protocols *with associated types* are much like generics *with wildcards* and tried to show why. <br></p><p>&gt; <br>&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt; <br>&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt; assoociated types to justify an argument that protocols *with associated<br>&gt; types* are the same as generics.<br></p><p>Note, that I said *additional* associated types, i.e. in addition to .Element, even giving an example how the Java interface had to be extended by a type parameter `Index` if this assumption was not applied (still simplifying because Generator would have been more correct which would have to be added as type parameter in addition to `Index`).<br></p><p>So, in essence the comparison is between the following (I&#39;m using Foo now instead of Collection to avoid the differences mentioned. Note that this has no impact on the argument at all):<br></p><p>protocol Foo {<br>    associatedtype T<br>    ...<br>}<br></p><p>interface Foo&lt;T&gt; {<br>    ...<br>}<br></p><p>My argument is that existentials of protocols with associated types are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift is just the same as `Foo&lt;?&gt;` in Java.<br>Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;? extends Number&gt;` in Java. For me that was an insight I wanted to share.<br></p><p>&gt;&gt; <br>&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt; <br>&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt; wildcards.<br>&gt; <br>&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt; with bound type parameters end up playing the role of existential type.<br>&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt; context is a huge leap forward in making that distinction clear... when<br>&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt; *won&#39;t* be types at all, existential or otherwise.<br></p><p>I fully agree that protocols are not types, their existentials are. But I haven&#39;t seen yet what we really *gain* from making that distinction explicit (except an ugly type syntax :-). <br>And like I already wrote in this or another thread we would have to apply the same logic to non-final classes, which are existentials, too.<br></p><p><br>&gt; <br>&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt; used as types is useful<br>&gt; <br>&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br></p><p>I&#39;m pretty sure that there was a discussion about whether being able to write something like Any&lt;Collection&gt; is useful. My wording was certainly imprecise, though, and didn&#39;t make sense as written. I should have said something like &quot;whether adding the ability to use existential types of protocols with unbound associated types is useful&quot;.<br></p><p>&gt; <br>&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt; needed.<br>&gt; <br>&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt; lightweight generics, which are less capable and less expressive in<br>&gt; many ways than Swift&#39;s generics.  <br></p><p>I agree that Java does not have something like `Self` or associated types (which are really useful for not having to bind all type parameters explicitly, especially when binding type parameters to other generics which makes for long type parameter lists in Java where I have to repeat everything over and over again), but do you mean something else here?<br>Especially in the context of sacrificing type safety?<br></p><p>&gt; <br>&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt; which is both something that Java does not have.<br>&gt;&gt; <br>&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt; <br>&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt; parameters for generics (see above).<br>&gt; <br>&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt; above, protocols can express fundamental relationships—like Self<br>&gt; requirements—that OOP simply can&#39;t handle.  <br></p><p>Eiffel has something like Self, it is called anchoring and allows binding the type of a variable to that of another one or self (which is called `Current` in Eiffel). And Eiffel does model everything with classes which may be abstract and allow for real multiple inheritance with abilities to resolve all conflicts including those concerning state (which is what other languages introduce interfaces for to avoid conflicts concerning state while still failing to solve *semantic* conflicts with the same diamond pattern).<br>No protocols or interfaces needed. Why do you say this is not OOP? The book which describes Eiffel is called &quot;Object-Oriented Software Construction&quot; (and is now about 20 years old).<br></p><p><br>&gt; There&#39;s a reason Java can&#39;t<br>&gt; express Comparable without losing static type-safety.  <br></p><p>You are certainly right that Java is not the best language out there especially when talking about type systems (I often enough rant about it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems quite typesafe to me. Or do you mean that one could write `class A implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point but doesn&#39;t compromise type safety, does it?<br>Ceylon has an elegant solution for that without using Self types: <br></p><p>interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br></p><p>Note the variance annotation (which Swift currently has not) and the `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This is a nice feature that I haven&#39;t seen often in programming languages (only Cecil comes to mind IIRC) and which is used for enumerations as well in Ceylon. In Swift I cannot do this but can use Self which solves this problem differently, albeit with some drawbacks compared to Ceylon&#39;s solution (having to redefine the compare method in all subtypes, which has lead to lengthy discussion threads about Self, StaticSelf, #Self etc.).<br></p><p>&gt; Finally, in a<br>&gt; language with first-class value types, taking a protocol-oriented<br>&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt; what you get using OOP.<br></p><p>Eiffel has expanded types which are value types with copy semantics quite like structs in Swift. These expanded types are pretty much integrated into Eiffel&#39;s class-only type system. Just define a class as `expanded` and you are done. Eiffel seems to have no need to introduce interfaces or protocols to the language to support value types.<br>You can even derive from expanded classes which is currently not possible in Swift but has already been discussed several times on this mailing list. <br>Polymorphic usage is only possible for non expanded super types, which means as far as I understood that a reference is used in that case. Variables with an expanded type do not use refences and therefore may not be used polymorphically in Eiffel.<br>This should be similar in Swift, at least as far as I did understand it. The question whether variables with a value type can be used polymorphically currently does not arise in Swift as structs cannot inherit from each other (yet?).<br></p><p>&gt; <br>&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt; types.  <br>&gt; <br>&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt; making value types, and the argument for value semantics, far weaker.<br></p><p>Why? Like I said, Eiffel *has* value types without needing protocols. They just have a unified mechanism built around classes.<br></p><p><br>&gt; <br>&gt;&gt; But protocols are not really different from interfaces in Java. <br>&gt;&gt; I would have preferred a unified model using just classes with real<br>&gt;&gt; multiple inheritance like Eiffel has and value types just being a part<br>&gt;&gt; of that similar to Eiffel’s `expanded` classes. But that ship has<br>&gt;&gt; probably sailed a long time ago :-/ So be it. But at least there<br>&gt;&gt; should be no reasons for POP vs OOP wars ;-) (I’d like to add that I<br>&gt;&gt; liked Dave’s talks at last WWDC very much, it’s just that I don’t<br>&gt;&gt; think that POP is something new or different.)<br>&gt; <br>&gt; Protocol-oriented programming is about the synergy of features and ideas<br>&gt; most of which not *individually* new, but that together create a new<br>&gt; world of possibilities.  I&#39;ve already discussed the synergy of protocols<br>&gt; and first-class value semantics.  <br></p><p>Again, I think that Eiffel demonstrates that protocols are not needed for first-class value semantics.<br></p><p><br>&gt; There&#39;s also the fact that in<br>&gt; protocols we have one construct with which to express dynamic<br>&gt; polymorphism (existentials) and static polymorphism (generic<br>&gt; constraints), both of which have important roles to play but that I<br>&gt; maintain are very different indeed.  <br></p><p>I don&#39;t argue with the fact that protocols can be used for both of these roles (existentials and constraints) and that these roles are something different. But I didn&#39;t say anything like that, at least not intentionally.<br></p><p><br>&gt; One result is that you can “start<br>&gt; with a protocol” as your abstraction mechanism and know that you&#39;re not<br>&gt; going to design yourself into a corner where it becomes impossibly<br>&gt; awkward to express what you need.  <br></p><p>Not sure what problems you are hinting at here specifically? Is it the single inheritance restriction most languages impose on classes? In that case I agree with you that that is a problem. I would not agree with interfaces being the only or even best solution, though, because I would prefer classes with real support for multiple inheritance like Eiffel shows is possible (especially as interfaces do not solve all problems with MI). <br></p><p><br>&gt; Finally—and I&#39;m certain this *is*<br>&gt; new—in protocol extensions we have a means to express both post-hoc<br>&gt; conformance and generic functions that is much more accessible to users<br>&gt; than in any previous language, to the point where generic programming<br>&gt; can become a natural part of everyday work.<br></p><p>Protocol extensions are a great feature that I was very very happy to see after having used extensions in Smalltalk for many years and missing them in Java. Especially being able to use post-hoc conformance is a really nice feature! <br></p><p>Please don&#39;t get me wrong, I think Swift is a fantastic language and I love it.<br>I&#39;m not arguing for removal of protocols in Swift or something like that. That ship has sailed. But I don&#39;t think that classes should be second class citizens in Swift, like several posts on this mailing list implied, e.g. in the discussion about abstract classes. <br></p><p>Best regards<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/1ef720a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br></p><p>This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br></p><p>Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br></p><p>Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br></p><p>1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br></p><p>2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br></p><p>Is there a deeper difference I’m missing?<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/2a47fca0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 10:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt; <br>&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt; <br>&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br></p><p>If Collection were a Java-like generic protocol you would have 5 generic parameters, all of which must be explicitly provided with arguments when forming an existential, although the arguments could be wildcards.  This is a bit unwieldy.  You would probably end up using a typealias in either case.<br></p><p>&gt; <br>&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt; <br>&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br></p><p>This is a pretty huge difference.  Multiple conformances are on the unlikely list for Swift and generic protocol syntax implies multiple conformances are possible (as is the case in at least some languages).<br></p><p>&gt; <br>&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br>&gt; <br>&gt; Is there a deeper difference I’m missing?<br></p><p>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/f6707f82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 10:50 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 16, 2016, at 10:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt;&gt; <br>&gt;&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt; <br>&gt; If Collection were a Java-like generic protocol you would have 5 generic parameters, all of which must be explicitly provided with arguments when forming an existential, although the arguments could be wildcards.  This is a bit unwieldy.<br></p><p>Yes. This was #2 on my list. A very, very nice syntactic difference — nonrepetition of redundant type information is so much of what makes Swift great. — but only a syntactic difference.<br></p><p><br>&gt;&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt;&gt; <br>&gt;&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt; <br>&gt; This is a pretty huge difference.  Multiple conformances are on the unlikely list for Swift and generic protocol syntax implies multiple conformances are possible (as is the case in at least some languages).<br></p><p>Right. Is that it? Are associated types really just generic protocols + single conformance constraint + type params inferred / implied?<br></p><p>P<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/fa728453/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 16, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 8:55 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right. Is that it? Are associated types really just generic protocols + single conformance constraint + type params inferred / implied?<br></p><p>A protocol and its associated types form a &quot;package&quot; or &quot;group&quot; of types that function together as one cohesive unit. For example, in the Swift world a collection is defined not only by its element type, but also by the type of its subsequence and its index. The protocol and associated types together define how the various types in the group relate to each other (via associated type nesting; for example Element belongs to Iterator belongs to Sequence), and to other types (via protocol conformance constraints).<br></p><p>A type doesn&#39;t need to be generic to adopt a protocol + associated types. For example, the various String views are bona fide Collections, but they&#39;re not generic in any way: all their associated types are fixed to concrete types as far as I can tell.<br></p><p>Another way to think of it is that generics allow *instances* to be abstracted over type, while protocols+associated types allow *conforming types* to be abstracted over type. For example, Either&lt;T, U&gt; can be instantiated for one instance as Either&lt;String, Int&gt;, and for another as Either&lt;NSView, Bool&gt;. (A simplified example version of the) protocol Collection can be instantiated for one type as being (Collection.Element = Int, Collection.Index = FooIndex), and another type as being (Collection.Element = String, Collection.Index = Int).<br></p><p>A generic type conforming to Collection would &quot;unify&quot; the two concepts. For example, SimpleArray&lt;T&gt; instantiates Collection as being (Collection.Element = T, Collection.Index = Int). Then, individual instances of SimpleArray&lt;T&gt; abstract over T by filling in T with Int (SimpleArray&lt;Int&gt;), String, etc.<br></p><p>Hope that helps,<br>Austin<br></p><p>&gt; <br>&gt; P<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 5:36 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt; <br>&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt; <br>&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt; <br>&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt; <br>&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt; <br>&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br></p><p>Wasn&#39;t there something recently from chris about removing inference?<br></p><p>&gt; <br>&gt; Is there a deeper difference I’m missing?<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/7f83bcf6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 16.06.2016 um 17:36 schrieb Paul Cantrell &lt;cantrell at pobox.com&gt;:<br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt; <br>&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt; <br>&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt; <br>&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt; <br>&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt; <br>&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br></p><p>That syntactic difference is *very* handy IMO for the following reason: with generics I have to repeat all types over and over again which gets ugly when I have levels of nesting where type parameters are constrained by other generics, which requires adding their parameters to the parameter list. Essentially the nested parameters have to be fully flattened because each type parameter has to be explicitly specified.<br></p><p>I’ll try to show that with a simplified example:<br></p><p>// with associated types<br></p><p>protocol Edge {<br>    associatedtype VertexType<br></p><p>    var source: VertexType { get }<br>    var target: VertexType { get }<br>}<br></p><p>protocol Graph {<br>    associatedtype EdgeType : Edge<br>    <br>    var vertices: [EdgeType.VertexType] { get }<br>    var edges: [EdgeType] { get }<br>    <br>    func outEdges(vertex: EdgeType.VertexType) -&gt; [EdgeType]<br>}<br></p><p>protocol GraphIterator {<br>    associatedtype GraphType : Graph<br>    <br>    var graph: GraphType { get }<br>    <br>    var startVertex: GraphType.VertexType { get }<br>    <br>    func enter(vertex: GraphType.VertexType)<br>    func propagate(along edge: GraphType.EdgeType)<br>    func finish(vertex: GraphType.VertexType)<br>}<br></p><p><br>// with generics<br></p><p>class Edge&lt;VertexType&gt; {<br>    var source: VertexType<br>    var target: VertexType<br>}<br></p><p>class Graph&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;&gt; {<br>    <br>    var vertices: [VertexType]<br>    var edges: [EdgeType]<br>    <br>    func outEdges(vertex: VertexType) -&gt; [EdgeType]<br>    <br>}<br></p><p>class GraphIterator&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;, GraphType: Graph&lt;VertexType, EdgeType&gt;&gt; {<br>    <br>    var graph: GraphType<br>    <br>    var startVertex: VertexType<br>    <br>    func enter(vertex: VertexType)<br>    func propagate(along edge: EdgeType)<br>    func finish(vertex: VertexType)<br>}<br></p><p>Note, how the parameter list for GraphIterator exploded, because I had to list each level of nested types down to the VertexType, whereas<br>in the associated types example the GraphIterator simply declares an associated type conforming to the topmost type of my nesting, the Graph.<br></p><p><br>&gt; <br>&gt; Is there a deeper difference I’m missing?<br></p><p>Maybe Dave can chime in here?<br></p><p><br>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/d4cfdc82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 17, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 9:46 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 16.06.2016 um 17:36 schrieb Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt;&gt; <br>&gt;&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt;&gt; <br>&gt;&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt;&gt; <br>&gt;&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt;&gt; <br>&gt;&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt;&gt; <br>&gt;&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br>&gt; <br>&gt; That syntactic difference is *very* handy IMO for the following reason: with generics I have to repeat all types over and over again which gets ugly when I have levels of nesting where type parameters are constrained by other generics, which requires adding their parameters to the parameter list. Essentially the nested parameters have to be fully flattened because each type parameter has to be explicitly specified.<br>&gt; <br>&gt; I’ll try to show that with a simplified example:<br>&gt; <br>&gt; // with associated types<br>&gt; <br>&gt; protocol Edge {<br>&gt;     associatedtype VertexType<br>&gt; <br>&gt;     var source: VertexType { get }<br>&gt;     var target: VertexType { get }<br>&gt; }<br>&gt; <br>&gt; protocol Graph {<br>&gt;     associatedtype EdgeType : Edge<br>&gt;     <br>&gt;     var vertices: [EdgeType.VertexType] { get }<br>&gt;     var edges: [EdgeType] { get }<br>&gt;     <br>&gt;     func outEdges(vertex: EdgeType.VertexType) -&gt; [EdgeType]<br>&gt; }<br>&gt; <br>&gt; protocol GraphIterator {<br>&gt;     associatedtype GraphType : Graph<br>&gt;     <br>&gt;     var graph: GraphType { get }<br>&gt;     <br>&gt;     var startVertex: GraphType.VertexType { get }<br>&gt;     <br>&gt;     func enter(vertex: GraphType.VertexType)<br>&gt;     func propagate(along edge: GraphType.EdgeType)<br>&gt;     func finish(vertex: GraphType.VertexType)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // with generics<br>&gt; <br>&gt; class Edge&lt;VertexType&gt; {<br>&gt;     var source: VertexType<br>&gt;     var target: VertexType<br>&gt; }<br>&gt; <br>&gt; class Graph&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;&gt; {<br>&gt;     <br>&gt;     var vertices: [VertexType]<br>&gt;     var edges: [EdgeType]<br>&gt;     <br>&gt;     func outEdges(vertex: VertexType) -&gt; [EdgeType]<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; class GraphIterator&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;, GraphType: Graph&lt;VertexType, EdgeType&gt;&gt; {<br>&gt;     <br>&gt;     var graph: GraphType<br>&gt;     <br>&gt;     var startVertex: VertexType<br>&gt;     <br>&gt;     func enter(vertex: VertexType)<br>&gt;     func propagate(along edge: EdgeType)<br>&gt;     func finish(vertex: VertexType)<br>&gt; }<br>&gt; <br>&gt; Note, how the parameter list for GraphIterator exploded, because I had to list each level of nested types down to the VertexType, whereas<br>&gt; in the associated types example the GraphIterator simply declares an associated type conforming to the topmost type of my nesting, the Graph.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Is there a deeper difference I’m missing?<br>&gt; <br>&gt; Maybe Dave can chime in here?<br></p><p>You can recover an associated type (say, X.Element) by just having the type “X”, but this is not true for a type parameter. That doesn’t matter when you have (or want to specify) that type… for example, your comment that Collection&lt;Foo&gt; and Any&lt;Collection where .Element == Foo&gt; would basically be the same thing.<br></p><p>However, with generalized/enhanced existentials you would be able to write<br></p><p>	var heterogeneousArrayOfCollections: [Collection]<br>	heterogeneousArrayOfCollections.append([1, 2 3])<br>	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br></p><p>You can’t do that with generic protocols, because there is no common element type:<br></p><p>	var heterogeneousArrayOfCollections: [Collection&lt;???&gt;]<br></p><p>One could perhaps try to rely on subtyping of collections for this specific case<br></p><p>	var heterogeneousArrayOfCollections: [Collection&lt;Any&gt;]<br>	heterogeneousArrayOfCollections.append([1, 2 3])<br>	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br></p><p>but that’s not something we have now and doesn’t really generalize well in Swift.<br></p><p>- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/4103ddd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 17.06.2016 um 16:11 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 9:46 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 16.06.2016 um 17:36 schrieb Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br>&gt;&gt; <br>&gt;&gt; That syntactic difference is *very* handy IMO for the following reason: with generics I have to repeat all types over and over again which gets ugly when I have levels of nesting where type parameters are constrained by other generics, which requires adding their parameters to the parameter list. Essentially the nested parameters have to be fully flattened because each type parameter has to be explicitly specified.<br>&gt;&gt; <br>&gt;&gt; I’ll try to show that with a simplified example:<br>&gt;&gt; <br>&gt;&gt; // with associated types<br>&gt;&gt; <br>&gt;&gt; protocol Edge {<br>&gt;&gt;     associatedtype VertexType<br>&gt;&gt; <br>&gt;&gt;     var source: VertexType { get }<br>&gt;&gt;     var target: VertexType { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol Graph {<br>&gt;&gt;     associatedtype EdgeType : Edge<br>&gt;&gt;     <br>&gt;&gt;     var vertices: [EdgeType.VertexType] { get }<br>&gt;&gt;     var edges: [EdgeType] { get }<br>&gt;&gt;     <br>&gt;&gt;     func outEdges(vertex: EdgeType.VertexType) -&gt; [EdgeType]<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol GraphIterator {<br>&gt;&gt;     associatedtype GraphType : Graph<br>&gt;&gt;     <br>&gt;&gt;     var graph: GraphType { get }<br>&gt;&gt;     <br>&gt;&gt;     var startVertex: GraphType.VertexType { get }<br>&gt;&gt;     <br>&gt;&gt;     func enter(vertex: GraphType.VertexType)<br>&gt;&gt;     func propagate(along edge: GraphType.EdgeType)<br>&gt;&gt;     func finish(vertex: GraphType.VertexType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // with generics<br>&gt;&gt; <br>&gt;&gt; class Edge&lt;VertexType&gt; {<br>&gt;&gt;     var source: VertexType<br>&gt;&gt;     var target: VertexType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Graph&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;&gt; {<br>&gt;&gt;     <br>&gt;&gt;     var vertices: [VertexType]<br>&gt;&gt;     var edges: [EdgeType]<br>&gt;&gt;     <br>&gt;&gt;     func outEdges(vertex: VertexType) -&gt; [EdgeType]<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class GraphIterator&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;, GraphType: Graph&lt;VertexType, EdgeType&gt;&gt; {<br>&gt;&gt;     <br>&gt;&gt;     var graph: GraphType<br>&gt;&gt;     <br>&gt;&gt;     var startVertex: VertexType<br>&gt;&gt;     <br>&gt;&gt;     func enter(vertex: VertexType)<br>&gt;&gt;     func propagate(along edge: EdgeType)<br>&gt;&gt;     func finish(vertex: VertexType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note, how the parameter list for GraphIterator exploded, because I had to list each level of nested types down to the VertexType, whereas<br>&gt;&gt; in the associated types example the GraphIterator simply declares an associated type conforming to the topmost type of my nesting, the Graph.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a deeper difference I’m missing?<br>&gt;&gt; <br>&gt;&gt; Maybe Dave can chime in here?<br>&gt; <br>&gt; You can recover an associated type (say, X.Element) by just having the type “X”, but this is not true for a type parameter. That doesn’t matter when you have (or want to specify) that type… for example, your comment that Collection&lt;Foo&gt; and Any&lt;Collection where .Element == Foo&gt; would basically be the same thing.<br>&gt; <br>&gt; However, with generalized/enhanced existentials you would be able to write<br>&gt; <br>&gt; 	var heterogeneousArrayOfCollections: [Collection]<br>&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt; <br>&gt; You can’t do that with generic protocols, because there is no common element type:<br>&gt; <br>&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;???&gt;]<br>&gt; <br>&gt; One could perhaps try to rely on subtyping of collections for this specific case<br>&gt; <br>&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;Any&gt;]<br>&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt; <br>&gt; but that’s not something we have now and doesn’t really generalize well in Swift.<br>&gt; <br>&gt; - Doug<br>&gt; <br>&gt; <br></p><p>Wildcards would work, too, e.g. in Java it looks like follows:<br>List&lt;Collection&lt;?&gt;&gt; heterogeneousListOfCollections = new ArrayList&lt;&gt;();<br></p><p>List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();<br>Collections.addAll(intList, 1, 2, 3);<br></p><p>List&lt;String&gt; stringList = new ArrayList&lt;&gt;();<br>Collections.addAll(stringList, &quot;Hello&quot;, &quot;Swift&quot;);<br></p><p>heterogeneousListOfCollections.add(intList);<br>heterogeneousListOfCollections.add(stringList);<br></p><p><br>With Austin’s proposal we could even recover the associated type of a concrete instance as a path dependent type, making this well typed, for example:<br></p><p>heterogeneousArrayOfCollections.map { xs in xs.min().map { minElement in xs.index(of: minElement) } }   // minElement has type xs.Iterator.Element<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160618/25a68e45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 18, 2016, at 2:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 17.06.2016 um 16:11 schrieb Douglas Gregor &lt;dgregor at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:46 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 16.06.2016 um 17:36 schrieb Paul Cantrell &lt;cantrell at pobox.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That syntactic difference is *very* handy IMO for the following reason: with generics I have to repeat all types over and over again which gets ugly when I have levels of nesting where type parameters are constrained by other generics, which requires adding their parameters to the parameter list. Essentially the nested parameters have to be fully flattened because each type parameter has to be explicitly specified.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll try to show that with a simplified example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // with associated types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Edge {<br>&gt;&gt;&gt;     associatedtype VertexType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var source: VertexType { get }<br>&gt;&gt;&gt;     var target: VertexType { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Graph {<br>&gt;&gt;&gt;     associatedtype EdgeType : Edge<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var vertices: [EdgeType.VertexType] { get }<br>&gt;&gt;&gt;     var edges: [EdgeType] { get }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func outEdges(vertex: EdgeType.VertexType) -&gt; [EdgeType]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol GraphIterator {<br>&gt;&gt;&gt;     associatedtype GraphType : Graph<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var graph: GraphType { get }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var startVertex: GraphType.VertexType { get }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func enter(vertex: GraphType.VertexType)<br>&gt;&gt;&gt;     func propagate(along edge: GraphType.EdgeType)<br>&gt;&gt;&gt;     func finish(vertex: GraphType.VertexType)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // with generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Edge&lt;VertexType&gt; {<br>&gt;&gt;&gt;     var source: VertexType<br>&gt;&gt;&gt;     var target: VertexType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Graph&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;&gt; {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var vertices: [VertexType]<br>&gt;&gt;&gt;     var edges: [EdgeType]<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func outEdges(vertex: VertexType) -&gt; [EdgeType]<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class GraphIterator&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;, GraphType: Graph&lt;VertexType, EdgeType&gt;&gt; {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var graph: GraphType<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var startVertex: VertexType<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func enter(vertex: VertexType)<br>&gt;&gt;&gt;     func propagate(along edge: EdgeType)<br>&gt;&gt;&gt;     func finish(vertex: VertexType)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note, how the parameter list for GraphIterator exploded, because I had to list each level of nested types down to the VertexType, whereas<br>&gt;&gt;&gt; in the associated types example the GraphIterator simply declares an associated type conforming to the topmost type of my nesting, the Graph.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a deeper difference I’m missing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe Dave can chime in here?<br>&gt;&gt; <br>&gt;&gt; You can recover an associated type (say, X.Element) by just having the type “X”, but this is not true for a type parameter. That doesn’t matter when you have (or want to specify) that type… for example, your comment that Collection&lt;Foo&gt; and Any&lt;Collection where .Element == Foo&gt; would basically be the same thing.<br>&gt;&gt; <br>&gt;&gt; However, with generalized/enhanced existentials you would be able to write<br>&gt;&gt; <br>&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection]<br>&gt;&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt;&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt;&gt; <br>&gt;&gt; You can’t do that with generic protocols, because there is no common element type:<br>&gt;&gt; <br>&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;???&gt;]<br>&gt;&gt; <br>&gt;&gt; One could perhaps try to rely on subtyping of collections for this specific case<br>&gt;&gt; <br>&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;Any&gt;]<br>&gt;&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt;&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt;&gt; <br>&gt;&gt; but that’s not something we have now and doesn’t really generalize well in Swift.<br>&gt;&gt; <br>&gt;&gt; - Doug<br>&gt; <br>&gt; Wildcards would work, too, e.g. in Java it looks like follows:<br>&gt; List&lt;Collection&lt;?&gt;&gt; heterogeneousListOfCollections = new ArrayList&lt;&gt;();<br>&gt; <br>&gt; List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();<br>&gt; Collections.addAll(intList, 1, 2, 3);<br>&gt; <br>&gt; List&lt;String&gt; stringList = new ArrayList&lt;&gt;();<br>&gt; Collections.addAll(stringList, &quot;Hello&quot;, &quot;Swift&quot;);<br>&gt; <br>&gt; heterogeneousListOfCollections.add(intList);<br>&gt; heterogeneousListOfCollections.add(stringList);<br></p><p>Having to add wildcards means yet another advanced generics feature. I suspect that we can make generalized existentials sufficiently accessible for all Swift programmers. Not so sure one could do that with generic protocols and wildcards (Java&#39;s experience with wildcards is not encouraging).<br></p><p>  - Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160618/7fd04e42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 19, 2016, at 8:35 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jun 18, 2016, at 2:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 17.06.2016 um 16:11 schrieb Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 16, 2016, at 9:46 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 16.06.2016 um 17:36 schrieb Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 16, 2016, at 8:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has been a point of confusion for me as well. I keep hearing that associated types are different from generic protocols, but this seems like a distinction without a difference.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Suppose Swift allowed generic protocols. How would a hypothetical Collection&lt;Foo&gt; be different in practice from the proposed existential Any&lt;Collection where .Element == Foo&gt;?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, in the realm of type theory and compiler internals they might represented differently, sure. But in practice, in terms of what code can actually do? I know of only two differences:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. A type can only conform to any given protocol with one set of type parameters. (Nothing can be both Collection&lt;Foo&gt; and Collection&lt;Bar&gt;.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. When a type conforms to Collection, it declares “associatedtype Foo” instead of “: Collection&lt;Foo&gt;”, and Foo can be inferred by the compiler in some circumstances. That’s handy, but it’s a syntactic difference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That syntactic difference is *very* handy IMO for the following reason: with generics I have to repeat all types over and over again which gets ugly when I have levels of nesting where type parameters are constrained by other generics, which requires adding their parameters to the parameter list. Essentially the nested parameters have to be fully flattened because each type parameter has to be explicitly specified.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ll try to show that with a simplified example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // with associated types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Edge {<br>&gt;&gt;&gt;&gt;     associatedtype VertexType<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var source: VertexType { get }<br>&gt;&gt;&gt;&gt;     var target: VertexType { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Graph {<br>&gt;&gt;&gt;&gt;     associatedtype EdgeType : Edge<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var vertices: [EdgeType.VertexType] { get }<br>&gt;&gt;&gt;&gt;     var edges: [EdgeType] { get }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func outEdges(vertex: EdgeType.VertexType) -&gt; [EdgeType]<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol GraphIterator {<br>&gt;&gt;&gt;&gt;     associatedtype GraphType : Graph<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var graph: GraphType { get }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var startVertex: GraphType.VertexType { get }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func enter(vertex: GraphType.VertexType)<br>&gt;&gt;&gt;&gt;     func propagate(along edge: GraphType.EdgeType)<br>&gt;&gt;&gt;&gt;     func finish(vertex: GraphType.VertexType)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // with generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Edge&lt;VertexType&gt; {<br>&gt;&gt;&gt;&gt;     var source: VertexType<br>&gt;&gt;&gt;&gt;     var target: VertexType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Graph&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;&gt; {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var vertices: [VertexType]<br>&gt;&gt;&gt;&gt;     var edges: [EdgeType]<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func outEdges(vertex: VertexType) -&gt; [EdgeType]<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class GraphIterator&lt;VertexType, EdgeType: Edge&lt;VertexType&gt;, GraphType: Graph&lt;VertexType, EdgeType&gt;&gt; {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var graph: GraphType<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var startVertex: VertexType<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func enter(vertex: VertexType)<br>&gt;&gt;&gt;&gt;     func propagate(along edge: EdgeType)<br>&gt;&gt;&gt;&gt;     func finish(vertex: VertexType)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note, how the parameter list for GraphIterator exploded, because I had to list each level of nested types down to the VertexType, whereas<br>&gt;&gt;&gt;&gt; in the associated types example the GraphIterator simply declares an associated type conforming to the topmost type of my nesting, the Graph.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is there a deeper difference I’m missing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Maybe Dave can chime in here?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can recover an associated type (say, X.Element) by just having the type “X”, but this is not true for a type parameter. That doesn’t matter when you have (or want to specify) that type… for example, your comment that Collection&lt;Foo&gt; and Any&lt;Collection where .Element == Foo&gt; would basically be the same thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, with generalized/enhanced existentials you would be able to write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection]<br>&gt;&gt;&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt;&gt;&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can’t do that with generic protocols, because there is no common element type:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;???&gt;]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could perhaps try to rely on subtyping of collections for this specific case<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	var heterogeneousArrayOfCollections: [Collection&lt;Any&gt;]<br>&gt;&gt;&gt; 	heterogeneousArrayOfCollections.append([1, 2 3])<br>&gt;&gt;&gt; 	heterogeneousArrayOfCollections.append([“Hello” : 1, “Swift” : 2])<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but that’s not something we have now and doesn’t really generalize well in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Wildcards would work, too, e.g. in Java it looks like follows:<br>&gt;&gt; List&lt;Collection&lt;?&gt;&gt; heterogeneousListOfCollections = new ArrayList&lt;&gt;();<br>&gt;&gt; <br>&gt;&gt; List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();<br>&gt;&gt; Collections.addAll(intList, 1, 2, 3);<br>&gt;&gt; <br>&gt;&gt; List&lt;String&gt; stringList = new ArrayList&lt;&gt;();<br>&gt;&gt; Collections.addAll(stringList, &quot;Hello&quot;, &quot;Swift&quot;);<br>&gt;&gt; <br>&gt;&gt; heterogeneousListOfCollections.add(intList);<br>&gt;&gt; heterogeneousListOfCollections.add(stringList);<br>&gt; <br>&gt; Having to add wildcards means yet another advanced generics feature. I suspect that we can make generalized existentials sufficiently accessible for all Swift programmers. Not so sure one could do that with generic protocols and wildcards (Java&#39;s experience with wildcards is not encouraging).<br></p><p>maybe : <br>var heterogeneousListOfCollections: [Collection[Any]] <br></p><p>(per https://gist.github.com/lmihalkovic/68c321ea7ffe27e553e37b794309b051)<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/fe9d2ac0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 3:29 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt; clear them up:<br>&gt;&gt; <br>&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt; must respond.<br>&gt; <br>&gt; You are right, the tone of my post was not appropriate, for which I want to apologize sincerely.<br>&gt; <br>&gt; I still believe my statements to be valid, though, and will respond to your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to have an argument for the argument&#39;s sake. All I want is to contribute maybe a tiny bit to make Swift even better than it already is, by sharing ideas and thoughts not only from me but from the designs of other perhaps more obscure programming languages which I happen to have stumbled upon in the past (often with much delight). <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt; parameters.<br>&gt;&gt; <br>&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt; implementations.  <br>&gt; <br>&gt; That&#39;s not what I was talking about. Of course, protocols are a mechanism for deriving types from each other whereas generics are a way to parameterize types. My point was that Swift&#39;s other way to parameterize types, namely by associated types, is very similar to generics with wildcards when looking a the existentials of such protocols. In addition I was talking about generics in general, not just about generics in Swift which restricts them to implementations and does not support wildcards.<br>&gt; Other languages like Java offer generics for interfaces as well and support wildcards (adding generic types parameters to protocols in Swift is currently discussed on the mailing list as well).<br>&gt; FWIW my arguments were not about whether we should have wildcards in Swift or not, but simply to relate one parametrization feature (associated types) to a more well known parametrization feature (generics with wildcards) in order to understand them better.<br>&gt; <br>&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt; implementation.  <br>&gt; <br>&gt; The latter is not the case for generic interfaces in Java, for example, so it is just an artificial restriction present in Swift.<br>&gt; <br>&gt;&gt; There is no way to produce distinct instances of a<br>&gt;&gt; generic type with all its type parameters bound, <br>&gt; <br>&gt; That is true in Swift (except for generic classes) due to the restriction just mentioned.<br>&gt; <br>&gt;&gt; but for any protocol P<br>&gt;&gt; I can make infinitely many instances of P with P.AssociatedType == Int.<br>&gt; <br>&gt; <br>&gt; This likewise applies to generic interfaces and for generic types in general if taking inheritance into account - just like you do here for protocols.<br>&gt; <br>&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt; evolution.<br>&gt; <br>&gt; I said that protocols *with associated types* are much like generics *with wildcards* and tried to show why. <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt; types* are the same as generics.<br>&gt; <br>&gt; Note, that I said *additional* associated types, i.e. in addition to .Element, even giving an example how the Java interface had to be extended by a type parameter `Index` if this assumption was not applied (still simplifying because Generator would have been more correct which would have to be added as type parameter in addition to `Index`).<br>&gt; <br>&gt; So, in essence the comparison is between the following (I&#39;m using Foo now instead of Collection to avoid the differences mentioned. Note that this has no impact on the argument at all):<br>&gt; <br>&gt; protocol Foo {<br>&gt;     associatedtype T<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; interface Foo&lt;T&gt; {<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; My argument is that existentials of protocols with associated types are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift is just the same as `Foo&lt;?&gt;` in Java.<br>&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;? extends Number&gt;` in Java. For me that was an insight I wanted to share.<br></p><p>The like-ness applies only to a subset of the java type system, and this is the area that will drastically change within the next 2 years.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt; wildcards.<br>&gt;&gt; <br>&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt; Java tries to create an “everything is a class” world,<br></p><p>Never did, never will...<br></p><p>&gt;&gt; generic classes<br>&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br></p><p>Hmmm starting to see the ugly Any&lt;&gt; burgeoning  all over swift soon... :(<br></p><p>&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt; <br>&gt; I fully agree that protocols are not types, their existentials are. But I haven&#39;t seen yet what we really *gain* from making that distinction explicit (except an ugly type syntax :-). <br>&gt; And like I already wrote in this or another thread we would have to apply the same logic to non-final classes, which are existentials, too.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt; used as types is useful<br>&gt;&gt; <br>&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt; <br>&gt; I&#39;m pretty sure that there was a discussion about whether being able to write something like Any&lt;Collection&gt; is useful. My wording was certainly imprecise, though, and didn&#39;t make sense as written. I should have said something like &quot;whether adding the ability to use existential types of protocols with unbound associated types is useful&quot;.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt; needed.<br>&gt;&gt; <br>&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt; <br>&gt; I agree that Java does not have something like `Self` or associated types (which are really useful for not having to bind all type parameters explicitly, especially when binding type parameters to other generics which makes for long type parameter lists in Java where I have to repeat everything over and over again), but do you mean something else here?<br>&gt; Especially in the context of sacrificing type safety?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt; <br>&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt; requirements—that OOP simply can&#39;t handle.  <br>&gt; <br>&gt; Eiffel has something like Self, it is called anchoring and allows binding the type of a variable to that of another one or self (which is called `Current` in Eiffel). And Eiffel does model everything with classes which may be abstract and allow for real multiple inheritance with abilities to resolve all conflicts including those concerning state (which is what other languages introduce interfaces for to avoid conflicts concerning state while still failing to solve *semantic* conflicts with the same diamond pattern).<br>&gt; No protocols or interfaces needed. Why do you say this is not OOP? The book which describes Eiffel is called &quot;Object-Oriented Software Construction&quot; (and is now about 20 years old).<br>&gt; <br>&gt; <br>&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt; express Comparable without losing static type-safety.  <br>&gt; <br>&gt; You are certainly right that Java is not the best language out there especially when talking about type systems (I often enough rant about it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems quite typesafe to me. Or do you mean that one could write `class A implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point but doesn&#39;t compromise type safety, does it?<br>&gt; Ceylon has an elegant solution for that without using Self types: <br>&gt; <br>&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt; <br>&gt; Note the variance annotation (which Swift currently has not) and the `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This is a nice feature that I haven&#39;t seen often in programming languages (only Cecil comes to mind IIRC) and which is used for enumerations as well in Ceylon. In Swift I cannot do this but can use Self which solves this problem differently, albeit with some drawbacks compared to Ceylon&#39;s solution (having to redefine the compare method in all subtypes, which has lead to lengthy discussion threads about Self, StaticSelf, #Self etc.).<br>&gt; <br>&gt;&gt; Finally, in a<br>&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt; what you get using OOP.<br>&gt; <br>&gt; Eiffel has expanded types which are value types with copy semantics quite like structs in Swift. These expanded types are pretty much integrated into Eiffel&#39;s class-only type system. Just define a class as `expanded` and you are done. Eiffel seems to have no need to introduce interfaces or protocols to the language to support value types.<br>&gt; You can even derive from expanded classes which is currently not possible in Swift but has already been discussed several times on this mailing list. <br>&gt; Polymorphic usage is only possible for non expanded super types, which means as far as I understood that a reference is used in that case. Variables with an expanded type do not use refences and therefore may not be used polymorphically in Eiffel.<br>&gt; This should be similar in Swift, at least as far as I did understand it. The question whether variables with a value type can be used polymorphically currently does not arise in Swift as structs cannot inherit from each other (yet?).<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt; types.  <br>&gt;&gt; <br>&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt; making value types, and the argument for value semantics, far weaker.<br></p><p>Value types are coming to the jvm without protocols.<br></p><p>&gt; Why? Like I said, Eiffel *has* value types without needing protocols. They just have a unified mechanism built around classes.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; But protocols are not really different from interfaces in Java. <br>&gt;&gt;&gt; I would have preferred a unified model using just classes with real<br>&gt;&gt;&gt; multiple inheritance like Eiffel has and value types just being a part<br>&gt;&gt;&gt; of that similar to Eiffel’s `expanded` classes. But that ship has<br>&gt;&gt;&gt; probably sailed a long time ago :-/ So be it. But at least there<br>&gt;&gt;&gt; should be no reasons for POP vs OOP wars ;-) (I’d like to add that I<br>&gt;&gt;&gt; liked Dave’s talks at last WWDC very much, it’s just that I don’t<br>&gt;&gt;&gt; think that POP is something new or different.)<br>&gt;&gt; <br>&gt;&gt; Protocol-oriented programming is about the synergy of features and ideas<br>&gt;&gt; most of which not *individually* new, but that together create a new<br>&gt;&gt; world of possibilities.  I&#39;ve already discussed the synergy of protocols<br>&gt;&gt; and first-class value semantics.  <br>&gt; <br>&gt; Again, I think that Eiffel demonstrates that protocols are not needed for first-class value semantics.<br></p><p>So does the clr today and soon the jvm.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; There&#39;s also the fact that in<br>&gt;&gt; protocols we have one construct with which to express dynamic<br>&gt;&gt; polymorphism (existentials) and static polymorphism (generic<br>&gt;&gt; constraints), both of which have important roles to play but that I<br>&gt;&gt; maintain are very different indeed.  <br>&gt; <br>&gt; I don&#39;t argue with the fact that protocols can be used for both of these roles (existentials and constraints) and that these roles are something different. But I didn&#39;t say anything like that, at least not intentionally.<br>&gt; <br>&gt; <br>&gt;&gt; One result is that you can “start<br>&gt;&gt; with a protocol” as your abstraction mechanism and know that you&#39;re not<br>&gt;&gt; going to design yourself into a corner where it becomes impossibly<br>&gt;&gt; awkward to express what you need.  <br>&gt; <br>&gt; Not sure what problems you are hinting at here specifically? Is it the single inheritance restriction most languages impose on classes? In that case I agree with you that that is a problem. I would not agree with interfaces being the only or even best solution, though, because I would prefer classes with real support for multiple inheritance like Eiffel shows is possible (especially as interfaces do not solve all problems with MI). <br>&gt; <br>&gt; <br>&gt;&gt; Finally—and I&#39;m certain this *is*<br>&gt;&gt; new—in protocol extensions we have a means to express both post-hoc<br>&gt;&gt; conformance and generic functions that is much more accessible to users<br>&gt;&gt; than in any previous language, to the point where generic programming<br>&gt;&gt; can become a natural part of everyday work.<br>&gt; <br>&gt; Protocol extensions are a great feature that I was very very happy to see after having used extensions in Smalltalk for many years and missing them in Java. Especially being able to use post-hoc conformance is a really nice feature! <br>&gt; <br>&gt; Please don&#39;t get me wrong, I think Swift is a fantastic language and I love it.<br>&gt; I&#39;m not arguing for removal of protocols in Swift or something like that. That ship has sailed. But I don&#39;t think that classes should be second class citizens in Swift, like several posts on this mailing list implied, e.g. in the discussion about abstract classes. <br>&gt; <br></p><p>I don&#39;t think the core team views them as second-class considering the restructuring that went in jn Foundation, i.e pairing Data with NSData ... val+ref is the arghment Dave was making a few weeks ago in the discussion around PureValue<br></p><p><br>&gt; Best regards<br>&gt; <br>&gt; -Thorsten <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/b6343e1a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 17, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br></p><p>&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt; clear them up:<br>&gt;&gt; <br>&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt; must respond.<br>&gt;<br>&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt; want to apologize sincerely.<br></p><p>My fundamental disagreement is with the content, not the tone.<br></p><p>&gt; I still believe my statements to be valid, though, and will respond to<br>&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt; other perhaps more obscure programming languages which I happen to<br>&gt; have stumbled upon in the past (often with much delight).<br></p><p>And I want you to know, even though I disagree with what you&#39;ve written,<br>that I very much appreciate the contribution you&#39;re making.<br></p><p>&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt; parameters.<br>&gt;&gt; <br>&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt; implementations.  <br>&gt;<br>&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt; mechanism for deriving types from each other whereas generics are a<br>&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt; parameterize types, namely by associated types, is very similar to<br>&gt; generics with wildcards when looking a the existentials of such<br>&gt; protocols. In addition I was talking about generics in general, not<br>&gt; just about generics in Swift which restricts them to implementations<br>&gt; and does not support wildcards.<br></p><p>I&#39;m aware of these other systems.  One of the problems with the way<br>you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>choice to sharply distinguish classes from protocols was not a conscious<br>one... but it was.  Yes, Swift could have been designed differently, so<br>that a single language construct, a kind of generic class, was stretched<br>so it could express almost everything.  Personally, I don&#39;t believe that<br>results in a better language.<br></p><p>&gt; Other languages like Java offer generics for interfaces as well and<br>&gt; support wildcards (adding generic types parameters to protocols in<br>&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt; not, but simply to relate one parametrization feature (associated<br>&gt; types) to a more well known parametrization feature (generics with<br>&gt; wildcards) in order to understand them better.<br>&gt;<br>&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt; implementation.  <br>&gt;<br>&gt; The latter is not the case for generic interfaces in Java, for<br>&gt; example, so it is just an artificial restriction present in Swift.<br></p><p>It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>“generic type” you just mean anything that encodes a static type<br>relationship, lots of things fall into that bucket.<br></p><p>&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt; all its type parameters bound,<br>&gt;<br>&gt; That is true in Swift (except for generic classes) due to the<br>&gt; restriction just mentioned.<br>&gt;<br>&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt; P.AssociatedType == Int.<br>&gt;<br>&gt; This likewise applies to generic interfaces and for generic types in<br>&gt; general if taking inheritance into account - just like you do here for<br>&gt; protocols.<br>&gt;<br>&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt; evolution.<br>&gt;<br>&gt; I said that protocols *with associated types* are much like generics<br>&gt; *with wildcards* and tried to show why.<br></p><p>If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>have no argument.<br></p><p>&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt; types* are the same as generics.<br>&gt;<br>&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt; .Element, even giving an example how the Java interface had to be<br>&gt; extended by a type parameter `Index` if this assumption was not<br>&gt; applied (still simplifying because Generator would have been more<br>&gt; correct which would have to be added as type parameter in addition to<br>&gt; `Index`).<br>&gt;<br>&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt; that this has no impact on the argument at all):<br>&gt;<br>&gt; protocol Foo {<br>&gt;     associatedtype T<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; interface Foo&lt;T&gt; {<br>&gt;     ...<br>&gt; }<br></p><p>Yes, those correspond.<br></p><p>&gt; My argument is that existentials of protocols with associated types<br>&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt; share.<br></p><p>It&#39;s a good one.<br></p><p>&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt; wildcards.<br>&gt;&gt; <br>&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;<br>&gt; I fully agree that protocols are not types, their existentials<br>&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt; distinction explicit (except an ugly type syntax :-).<br></p><p>For me, it helps distinguish static from dynamic polymorphism.<br></p><p>&gt; And like I already wrote in this or another thread we would have to<br>&gt; apply the same logic to non-final classes, which are existentials,<br>&gt; too.<br>&gt;&gt; <br>&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt; used as types is useful<br>&gt;&gt; <br>&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;<br>&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt; should have said something like &quot;whether adding the ability to use<br>&gt; existential types of protocols with unbound associated types is<br>&gt; useful&quot;.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt; needed.<br>&gt;&gt; <br>&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;<br>&gt; I agree that Java does not have something like `Self` or associated<br>&gt; types (which are really useful for not having to bind all type<br>&gt; parameters explicitly, especially when binding type parameters to<br>&gt; other generics which makes for long type parameter lists in Java where<br>&gt; I have to repeat everything over and over again), but do you mean<br>&gt; something else here?<br>&gt; Especially in the context of sacrificing type safety?<br></p><p>I do, but it will take some research for me to recover my memory of<br>where the holes are.  It has been years since I thought about Java<br>generics.  It&#39;s also possible that I&#39;m wrong ;-)<br></p><p>&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt; <br>&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;<br>&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt; binding the type of a variable to that of another one or self (which<br>&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt; with abilities to resolve all conflicts including those concerning<br>&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt; conflicts with the same diamond pattern).<br>&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt; Construction&quot; (and is now about 20 years old).<br></p><p>It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>OOP either.  If you survey object-oriented languages, what you find in<br>common is inheritance-based dynamic polymorphism and reference<br>semantics.  Those are the defining characteristics of OOP, and taking an<br>object-oriented approach to a given problem means reaching for those<br>features.<br></p><p>&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;<br>&gt; You are certainly right that Java is not the best language out there<br>&gt; especially when talking about type systems (I often enough rant about<br>&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt; but doesn&#39;t compromise type safety, does it?<br></p><p>Java has cleverly avoided compromising type safety here by failing to<br>express the constraint that comparable conformance means a type can be<br>compared to itself ;-)<br></p><p>&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;<br>&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;<br>&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt; subtypes, <br></p><p>That sounds interesting but is a bit vague.  A concise example of how<br>this plays out in Swift and in Ceylon would be instructive here.<br></p><p>&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt; #Self etc.).<br>&gt;<br>&gt;&gt; Finally, in a<br>&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt; what you get using OOP.<br>&gt;<br>&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt; as `expanded` and you are done. <br></p><p>Unless this part of the language has changed since 1996, or unless I&#39;ve<br>misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf, you can&#39;t<br>make an efficient array with value semantics in Eiffel.  That, IMO,<br>cannot be considered a language with first-class value types.<br></p><p>&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt; the language to support value types.  <br></p><p>No, of course not.  By saying that everything from abstract interfaces<br>to static constraints and even value types is to be expressed a kind of<br>possibly-generic class, you can eliminate distinctions in the language<br>that IMO help to clarify design intent.  This is a language design<br>choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>an S-expression.  That has certain upsides, but for me it fails the<br>expressivity test.<br></p><p>&gt; You can even derive from expanded classes which is currently not<br>&gt; possible in Swift but has already been discussed several times on this<br>&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt; super types, which means as far as I understood that a reference is<br>&gt; used in that case. Variables with an expanded type do not use refences<br>&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt; question whether variables with a value type can be used<br>&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt; inherit from each other (yet?).<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt; types.  <br>&gt;&gt; <br>&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;<br>&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt; protocols. They just have a unified mechanism built around classes.<br></p><p>Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>Generic Class ;-)<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 17, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 17, 2016, at 7:04 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com &lt;http://tseitz42-at-icloud.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt; must respond.<br>&gt;&gt; <br>&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt; want to apologize sincerely.<br>&gt; <br>&gt; My fundamental disagreement is with the content, not the tone.<br>&gt; <br>&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt; <br>&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt; that I very much appreciate the contribution you&#39;re making.<br>&gt; <br>&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt; implementations.  <br>&gt;&gt; <br>&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt; and does not support wildcards.<br>&gt; <br>&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt; one... but it was.  Yes, Swift could have been designed differently, so<br>&gt; that a single language construct, a kind of generic class, was stretched<br>&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt; results in a better language.<br>&gt; <br>&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt; <br>&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt; implementation.  <br>&gt;&gt; <br>&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt; <br>&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>&gt; “generic type” you just mean anything that encodes a static type<br>&gt; relationship, lots of things fall into that bucket.<br>&gt; <br>&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt; <br>&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt; restriction just mentioned.<br>&gt;&gt; <br>&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt; <br>&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt; protocols.<br>&gt;&gt; <br>&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt; evolution.<br>&gt;&gt; <br>&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt; *with wildcards* and tried to show why.<br>&gt; <br>&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt; have no argument.<br>&gt; <br>&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt; <br>&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt; `Index`).<br>&gt;&gt; <br>&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;    associatedtype T<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt; <br>&gt; Yes, those correspond.<br></p><p>would be difficult to say otherwise ;)  considering:<br></p><p>&quot;In Swift, I suggest that we use the term protocol for this feature, because I expect the end result to be similar enough to Objective-C protocols that our users will benefit, and (more importantly) different enough from Java/C# interfaces and C++ abstract base classes that those terms will be harmful. The term trait comes with the wrong connotation for C++ programmers, and none of our users know Scala.&quot;<br></p><p><br>&gt; <br>&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt; share.<br>&gt; <br>&gt; It&#39;s a good one.<br>&gt; <br>&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt; <br>&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt; <br>&gt; For me, it helps distinguish static from dynamic polymorphism.<br>&gt; <br>&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt; too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt; <br>&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt; useful&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt; <br>&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt; something else here?<br>&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt; <br>&gt; I do, but it will take some research for me to recover my memory of<br>&gt; where the holes are.  It has been years since I thought about Java<br>&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br>&gt; <br>&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt; <br>&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt; <br>&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt; object-oriented approach to a given problem means reaching for those<br>&gt; features.<br>&gt; <br>&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt; <br>&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt; <br>&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt; express the constraint that comparable conformance means a type can be<br>&gt; compared to itself ;-)<br></p><p>somehow considering how dynamic java is, it would have been short-sighted to express the constraint in the type itself rather than as it is, in generic methods where it can be guaranteed.<br>public static &lt;T extends Comparable &lt;http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html&gt;&lt;? super T&gt;&gt; void sort(List &lt;http://docs.oracle.com/javase/6/docs/api/java/util/List.html&gt;&lt;T&gt; list)<br></p><p><br></p><p>&gt; <br>&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt; <br>&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt; <br>&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt; subtypes, <br>&gt; <br>&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt; this plays out in Swift and in Ceylon would be instructive here.<br>&gt; <br>&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt; #Self etc.).<br>&gt;&gt; <br>&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt; <br>&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt; as `expanded` and you are done. <br>&gt; <br>&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf &lt;https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf&gt;, you can&#39;t<br>&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt; cannot be considered a language with first-class value types.<br></p><p>java/jvm is about to throw an interesting wrench into the status-quo. Between the different forms of non-ref based arrays that can be optimized down to the JVM (azul is ahead of everyone in that arena) and value types, a lot of preconceived notions will have to go away (which I fully expect they won’t anytime soon considering how we like to hold on to things).<br></p><p><br>&gt; <br>&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt; the language to support value types.  <br>&gt; <br>&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt; to static constraints and even value types is to be expressed a kind of<br>&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt; that IMO help to clarify design intent.  This is a language design<br>&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt; expressivity test.<br>&gt; <br>&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt; inherit from each other (yet?).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt; <br>&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt; <br>&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt; Generic Class ;-)<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/fb306e11/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry for the late reply — I had hoped to be able to think more deeply about various points, <br>but I’m going to delay that instead of delaying the reply even more :-)<br></p><p><br>&gt; Am 17.06.2016 um 19:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt; must respond.<br>&gt;&gt; <br>&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt; want to apologize sincerely.<br>&gt; <br>&gt; My fundamental disagreement is with the content, not the tone.<br>&gt; <br>&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt; <br>&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt; that I very much appreciate the contribution you&#39;re making.<br></p><p>Thanks! I’m very glad about that!<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt; implementations.  <br>&gt;&gt; <br>&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt; and does not support wildcards.<br>&gt; <br>&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt; one... but it was.  <br></p><p>I never had assumed that this had been decided lightly ;-)<br>And I have been favorably impressed by the rationales put forth so far by the Swift <br>team, so it would definitely be interesting to learn a bit more about the rationale<br>being put into that decision and the advantages and disadvantages discussed back then.<br>Is there something written down somewhere? <br></p><p><br>&gt; Yes, Swift could have been designed differently, so<br>&gt; that a single language construct, a kind of generic class, was stretched<br>&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt; results in a better language.<br></p><p>I still believe it would have advantages but I’ll concede that this discussion <br>will probably not help advancing Swift as this decision has been made.<br>Still, it might be of interest to keep in mind for further design considerations.<br></p><p><br>&gt; <br>&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt; <br>&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt; implementation.  <br>&gt;&gt; <br>&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt; <br>&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br></p><p>I meant artifical in the sense that a different design choice would have been possible.<br></p><p><br>&gt; “generic type” you just mean anything that encodes a static type<br>&gt; relationship, lots of things fall into that bucket.<br></p><p>Well, I think Java’s generics are not that advanced, so the bucket does not <br>have to be very big :-)<br></p><p><br>&gt; <br>&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt; <br>&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt; restriction just mentioned.<br>&gt;&gt; <br>&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt; <br>&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt; protocols.<br>&gt;&gt; <br>&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt; evolution.<br>&gt;&gt; <br>&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt; *with wildcards* and tried to show why.<br>&gt; <br>&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt; have no argument.<br></p><p>Ok.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt; <br>&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt; `Index`).<br>&gt;&gt; <br>&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;    associatedtype T<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt; <br>&gt; Yes, those correspond.<br>&gt; <br>&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt; share.<br>&gt; <br>&gt; It&#39;s a good one.<br></p><p>Thanks!<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt; <br>&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt; <br>&gt; For me, it helps distinguish static from dynamic polymorphism.<br></p><p>Hmm, I’ll have to think more about that.<br></p><p><br>&gt; <br>&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt; too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt; <br>&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt; useful&quot;.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt; <br>&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt; something else here?<br>&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt; <br>&gt; I do, but it will take some research for me to recover my memory of<br>&gt; where the holes are.  It has been years since I thought about Java<br>&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br></p><p>If you happen to remember, I’d be interested in hearing about the problems you meant.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt; <br>&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt; <br>&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt; object-oriented approach to a given problem means reaching for those<br>&gt; features.<br></p><p>Agreed, it is not part of most OOP *implementations* while being compatible with OOP.<br>There have been lots of papers and research languages about typing problems like <br>binary methods, null pointers etc., though, so taking the mainstream OO languages<br>as the yardstick for OOP is jumping a little bit too short IMO. <br></p><p><br>&gt; <br>&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt; <br>&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt; <br>&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt; express the constraint that comparable conformance means a type can be<br>&gt; compared to itself ;-)<br></p><p>Indeed :-)<br></p><p><br>&gt; <br>&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt; <br>&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt; <br>&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt; subtypes, <br>&gt; <br>&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt; this plays out in Swift and in Ceylon would be instructive here.<br></p><p>Sorry, the difficulty with Self I was thinking of only occurs when Self is in a covariant position<br>which is not the case in Comparable, of course. Let’s take a modified example instead with Self <br>in a covariant position:<br></p><p>Swift:<br></p><p>protocol Minimizable {<br>    func min(from other: Self) -&gt; Self<br>}<br></p><p>final class A : Minimizable { // has to be final<br> <br>    let x: Int<br>    <br>    init(x: Int) {<br>        self.x = x<br>    }<br>    <br>    func min(from other: A) -&gt; A {<br>        return x &lt; other.x ? self : other<br>    }<br>}<br></p><p>Ceylon:<br></p><p>interface Minimizable&lt;Other&gt; of Other given Other satisfies Minimizable&lt;Other&gt; {<br>    shared formal Other min(Other other);<br>}<br></p><p>class A() satisfies Minimizable&lt;A&gt; {<br></p><p>    Integer x = 0;<br></p><p>    shared actual default A min(A other) {<br>        if (x &lt; other.x) {<br>            return this;<br>        } else {<br>            return other;<br>        }<br>    }<br>}<br></p><p>In Ceylon class A does not have to be final and choosing the minimum of two values would be available for values from the whole subtree of types rooted in A (the `of` ensures that such a declaration cannot „cross“ into other subtrees) whereas `Self` enforces that there is no subtree below class A.<br></p><p>I have to admit that I am not well versed using `Self`, yet, so maybe I’m wrong here. In addition I am sure that `Self` allows designs<br>that are not possible with Ceylon’s `of`.<br></p><p>The usage of Ceylon’s `of` for enumeration types is as follows (example taken from http://ceylon-lang.org/documentation/tour/types/):<br></p><p>abstract class Node() of Leaf | Branch {}<br></p><p>class Leaf(shared Object element) <br>        extends Node() {}<br></p><p>class Branch(shared Node left, shared Node right) <br>        extends Node() {}<br>void printTree(Node node) {<br>    switch (node)<br>    case (is Leaf) {<br>        print(&quot;Found a leaf: ``node.element``!&quot;);<br>    }<br>    case (is Branch) {<br>        printTree(node.left);<br>        printTree(node.right);<br>    }<br>}<br></p><p><br></p><p>&gt; <br>&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt; #Self etc.).<br>&gt;&gt; <br>&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt; <br>&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt; as `expanded` and you are done. <br>&gt; <br>&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf, you can&#39;t<br>&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt; cannot be considered a language with first-class value types.<br></p><p>I haven’t had time yet to really evaluate that paper, but if you are right, then I agree<br>with you that Eiffel cannot be considered as having first-calss value types.<br></p><p>At least one of the deficiencies listed in the paper does not exist anymore AFAIU <br>(expanded types not having constructors), though, so maybe things actually do have <br>changed since then.<br></p><p><br>&gt; <br>&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt; the language to support value types.  <br>&gt; <br>&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt; to static constraints and even value types is to be expressed a kind of<br>&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt; that IMO help to clarify design intent.  This is a language design<br>&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt; expressivity test.<br></p><p>That’s certainly a valid point.<br></p><p>Furthermore I do understand (and fully support) that being interoperable with Objective-C is an <br>important restriction on Swift’s design space and I think it is absolutely awesome how<br>that has been achieved!<br></p><p><br>&gt; <br>&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt; inherit from each other (yet?).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt; <br>&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt; <br>&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt; Generic Class ;-)<br></p><p>Ah, ok, I took your statement of protocols being needed for strong value semantics<br>to be of general validity, not confined to Swift :-) <br>Within Swift that is certainly true!<br></p><p>-Thorsten<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/2f3bd705/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 25, 2016, at 6:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for the late reply — I had hoped to be able to think more deeply about various points, <br>&gt; but I’m going to delay that instead of delaying the reply even more :-)<br>&gt; <br>&gt; <br>&gt;&gt; Am 17.06.2016 um 19:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt;&gt; must respond.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt;&gt; want to apologize sincerely.<br>&gt;&gt; <br>&gt;&gt; My fundamental disagreement is with the content, not the tone.<br>&gt;&gt; <br>&gt;&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt;&gt; <br>&gt;&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt;&gt; that I very much appreciate the contribution you&#39;re making.<br>&gt; <br>&gt; Thanks! I’m very glad about that!<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt;&gt; implementations.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt;&gt; and does not support wildcards.<br>&gt;&gt; <br>&gt;&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt;&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt;&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt;&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt;&gt; one... but it was.  <br>&gt; <br>&gt; I never had assumed that this had been decided lightly ;-)<br>&gt; And I have been favorably impressed by the rationales put forth so far by the Swift <br>&gt; team, so it would definitely be interesting to learn a bit more about the rationale<br>&gt; being put into that decision and the advantages and disadvantages discussed back then.<br>&gt; Is there something written down somewhere? <br>&gt; <br></p><p>I think some applicable rational exist in type-system papers that came out of studying scala&#39;s. <br></p><p>&gt;&gt; Yes, Swift could have been designed differently, so<br>&gt;&gt; that a single language construct, a kind of generic class, was stretched<br>&gt;&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt;&gt; results in a better language.<br>&gt; <br>&gt; I still believe it would have advantages but I’ll concede that this discussion <br>&gt; will probably not help advancing Swift as this decision has been made.<br>&gt; Still, it might be of interest to keep in mind for further design considerations.<br></p><p>Somehow the world of languages is small, and tracing inspiriation across is playing permutations on a limited set. <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt;&gt; implementation.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt;&gt; <br>&gt;&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>&gt; <br>&gt; I meant artifical in the sense that a different design choice would have been possible.<br>&gt; <br>&gt; <br>&gt;&gt; “generic type” you just mean anything that encodes a static type<br>&gt;&gt; relationship, lots of things fall into that bucket.<br>&gt; <br>&gt; Well, I think Java’s generics are not that advanced, so the bucket does not <br>&gt; have to be very big :-)<br></p><p>I am curious to see what language you have in mind when you are making a comparison?<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt;&gt; restriction just mentioned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt;&gt; evolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt;&gt; *with wildcards* and tried to show why.<br>&gt;&gt; <br>&gt;&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt;&gt; have no argument.<br>&gt; <br>&gt; Ok.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt;&gt; `Index`).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;    associatedtype T<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;&gt;    ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Yes, those correspond.<br>&gt;&gt; <br>&gt;&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt;&gt; share.<br>&gt;&gt; <br>&gt;&gt; It&#39;s a good one.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt;&gt; <br>&gt;&gt; For me, it helps distinguish static from dynamic polymorphism.<br>&gt; <br>&gt; Hmm, I’ll have to think more about that.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt;&gt; too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt;&gt; useful&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt;&gt; something else here?<br>&gt;&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt;&gt; <br>&gt;&gt; I do, but it will take some research for me to recover my memory of<br>&gt;&gt; where the holes are.  It has been years since I thought about Java<br>&gt;&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br>&gt; <br>&gt; If you happen to remember, I’d be interested in hearing about the problems you meant.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt;&gt; <br>&gt;&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt;&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt;&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt;&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt;&gt; object-oriented approach to a given problem means reaching for those<br>&gt;&gt; features.<br>&gt; <br>&gt; Agreed, it is not part of most OOP *implementations* while being compatible with OOP.<br>&gt; There have been lots of papers and research languages about typing problems like <br>&gt; binary methods, null pointers etc., though, so taking the mainstream OO languages<br>&gt; as the yardstick for OOP is jumping a little bit too short IMO. <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt;&gt; <br>&gt;&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt;&gt; express the constraint that comparable conformance means a type can be<br>&gt;&gt; compared to itself ;-)<br>&gt; <br>&gt; Indeed :-)<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt;&gt; subtypes,<br>&gt;&gt; <br>&gt;&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt;&gt; this plays out in Swift and in Ceylon would be instructive here.<br>&gt; <br>&gt; Sorry, the difficulty with Self I was thinking of only occurs when Self is in a covariant position<br>&gt; which is not the case in Comparable, of course. Let’s take a modified example instead with Self <br>&gt; in a covariant position:<br>&gt; <br>&gt; Swift:<br>&gt; <br>&gt; protocol Minimizable {<br>&gt;     func min(from other: Self) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; final class A : Minimizable { // has to be final<br>&gt;  <br>&gt;     let x: Int<br>&gt;     <br>&gt;     init(x: Int) {<br>&gt;         self.x = x<br>&gt;     }<br>&gt;     <br>&gt;     func min(from other: A) -&gt; A {<br>&gt;         return x &lt; other.x ? self : other<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Ceylon:<br>&gt; <br>&gt; interface Minimizable&lt;Other&gt; of Other given Other satisfies Minimizable&lt;Other&gt; {<br>&gt;     shared formal Other min(Other other);<br>&gt; }<br>&gt; <br>&gt; class A() satisfies Minimizable&lt;A&gt; {<br>&gt; <br>&gt;     Integer x = 0;<br>&gt; <br>&gt;     shared actual default A min(A other) {<br>&gt;         if (x &lt; other.x) {<br>&gt;             return this;<br>&gt;         } else {<br>&gt;             return other;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; In Ceylon class A does not have to be final and choosing the minimum of two values would be available for values from the whole subtree of types rooted in A (the `of` ensures that such a declaration cannot „cross“ into other subtrees) whereas `Self` enforces that there is no subtree below class A.<br>&gt; <br>&gt; I have to admit that I am not well versed using `Self`, yet, so maybe I’m wrong here. In addition I am sure that `Self` allows designs<br>&gt; that are not possible with Ceylon’s `of`.<br>&gt; <br>&gt; The usage of Ceylon’s `of` for enumeration types is as follows (example taken from http://ceylon-lang.org/documentation/tour/types/):<br>&gt; <br>&gt; abstract class Node() of Leaf | Branch {}<br>&gt; <br>&gt; class Leaf(shared Object element) <br>&gt;         extends Node() {}<br>&gt; <br>&gt; class Branch(shared Node left, shared Node right) <br>&gt;         extends Node() {}<br>&gt; void printTree(Node node) {<br>&gt;     switch (node)<br>&gt;     case (is Leaf) {<br>&gt;         print(&quot;Found a leaf: ``node.element``!&quot;);<br>&gt;     }<br>&gt;     case (is Branch) {<br>&gt;         printTree(node.left);<br>&gt;         printTree(node.right);<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt;&gt; #Self etc.).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt;&gt; as `expanded` and you are done.<br>&gt;&gt; <br>&gt;&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt;&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf, you can&#39;t<br>&gt;&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt;&gt; cannot be considered a language with first-class value types.<br>&gt; <br>&gt; I haven’t had time yet to really evaluate that paper, but if you are right, then I agree<br>&gt; with you that Eiffel cannot be considered as having first-calss value types.<br>&gt; <br>&gt; At least one of the deficiencies listed in the paper does not exist anymore AFAIU <br>&gt; (expanded types not having constructors), though, so maybe things actually do have <br>&gt; changed since then.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt;&gt; the language to support value types.  <br>&gt;&gt; <br>&gt;&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt;&gt; to static constraints and even value types is to be expressed a kind of<br>&gt;&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt;&gt; that IMO help to clarify design intent.  This is a language design<br>&gt;&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt;&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt;&gt; expressivity test.<br>&gt; <br>&gt; That’s certainly a valid point.<br>&gt; <br>&gt; Furthermore I do understand (and fully support) that being interoperable with Objective-C is an <br>&gt; important restriction on Swift’s design space and I think it is absolutely awesome how<br>&gt; that has been achieved!<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt;&gt; inherit from each other (yet?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt;&gt; <br>&gt;&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt;&gt; Generic Class ;-)<br>&gt; <br>&gt; Ah, ok, I took your statement of protocols being needed for strong value semantics<br>&gt; to be of general validity, not confined to Swift :-) <br>&gt; Within Swift that is certainly true!<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/f7dd96da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 25.06.2016 um 19:09 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 25, 2016, at 6:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Sorry for the late reply — I had hoped to be able to think more deeply about various points, <br>&gt;&gt; but I’m going to delay that instead of delaying the reply even more :-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 17.06.2016 um 19:04 schrieb Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com &lt;http://tseitz42-at-icloud.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com &lt;http://tseitz42-at-icloud.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt;&gt;&gt; must respond.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt;&gt;&gt; want to apologize sincerely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My fundamental disagreement is with the content, not the tone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt;&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt;&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt;&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt;&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt;&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt;&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt;&gt;&gt; that I very much appreciate the contribution you&#39;re making.<br>&gt;&gt; <br>&gt;&gt; Thanks! I’m very glad about that!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt;&gt;&gt; implementations.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt;&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt;&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt;&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt;&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt;&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt;&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt;&gt;&gt; and does not support wildcards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt;&gt;&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt;&gt;&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt;&gt;&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt;&gt;&gt; one... but it was.  <br>&gt;&gt; <br>&gt;&gt; I never had assumed that this had been decided lightly ;-)<br>&gt;&gt; And I have been favorably impressed by the rationales put forth so far by the Swift <br>&gt;&gt; team, so it would definitely be interesting to learn a bit more about the rationale<br>&gt;&gt; being put into that decision and the advantages and disadvantages discussed back then.<br>&gt;&gt; Is there something written down somewhere? <br>&gt;&gt; <br>&gt; <br>&gt; I think some applicable rational exist in type-system papers that came out of studying scala&#39;s. <br>&gt; <br>&gt;&gt;&gt; Yes, Swift could have been designed differently, so<br>&gt;&gt;&gt; that a single language construct, a kind of generic class, was stretched<br>&gt;&gt;&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt;&gt;&gt; results in a better language.<br>&gt;&gt; <br>&gt;&gt; I still believe it would have advantages but I’ll concede that this discussion <br>&gt;&gt; will probably not help advancing Swift as this decision has been made.<br>&gt;&gt; Still, it might be of interest to keep in mind for further design considerations.<br>&gt; <br>&gt; Somehow the world of languages is small, and tracing inspiriation across is playing permutations on a limited set. <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt;&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt;&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt;&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt;&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt;&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt;&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt;&gt;&gt; implementation.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt;&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>&gt;&gt; <br>&gt;&gt; I meant artifical in the sense that a different design choice would have been possible.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; “generic type” you just mean anything that encodes a static type<br>&gt;&gt;&gt; relationship, lots of things fall into that bucket.<br>&gt;&gt; <br>&gt;&gt; Well, I think Java’s generics are not that advanced, so the bucket does not <br>&gt;&gt; have to be very big :-)<br>&gt; <br>&gt; I am curious to see what language you have in mind when you are making a comparison?<br></p><p>e.g. Ceylon and Scala with their definition-site variance declarations, Ceylon with defaults for type parameters, Scala with lower type bounds, Scala and Haskell with higher kinded types, Haskell with type classes, type families, kind polymorphism and lots more. Then there are things like types parameterized by values (like discussed on this list in the thread about expanding generics to support defining a type safe unit system).<br></p><p>The design space is much larger than the mainstream, especially something like Java, makes on believe… :-)<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt;&gt;&gt; restriction just mentioned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt;&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt;&gt;&gt; evolution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt;&gt;&gt; *with wildcards* and tried to show why.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt;&gt;&gt; have no argument.<br>&gt;&gt; <br>&gt;&gt; Ok.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt;&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt;&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt;&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt;&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt;&gt;&gt; `Index`).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt;&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt;&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;    associatedtype T<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, those correspond.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt;&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt;&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt;&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt;&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt;&gt;&gt; share.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s a good one.<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt;&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt;&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For me, it helps distinguish static from dynamic polymorphism.<br>&gt;&gt; <br>&gt;&gt; Hmm, I’ll have to think more about that.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt;&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt;&gt;&gt; too.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt;&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt;&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt;&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt;&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt;&gt;&gt; useful&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt;&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt;&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt;&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt;&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt;&gt;&gt; something else here?<br>&gt;&gt;&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do, but it will take some research for me to recover my memory of<br>&gt;&gt;&gt; where the holes are.  It has been years since I thought about Java<br>&gt;&gt;&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br>&gt;&gt; <br>&gt;&gt; If you happen to remember, I’d be interested in hearing about the problems you meant.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt;&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt;&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt;&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt;&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt;&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt;&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt;&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt;&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt;&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt;&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt;&gt;&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt;&gt;&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt;&gt;&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt;&gt;&gt; object-oriented approach to a given problem means reaching for those<br>&gt;&gt;&gt; features.<br>&gt;&gt; <br>&gt;&gt; Agreed, it is not part of most OOP *implementations* while being compatible with OOP.<br>&gt;&gt; There have been lots of papers and research languages about typing problems like <br>&gt;&gt; binary methods, null pointers etc., though, so taking the mainstream OO languages<br>&gt;&gt; as the yardstick for OOP is jumping a little bit too short IMO. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt;&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt;&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt;&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt;&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt;&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt;&gt;&gt; express the constraint that comparable conformance means a type can be<br>&gt;&gt;&gt; compared to itself ;-)<br>&gt;&gt; <br>&gt;&gt; Indeed :-)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt;&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt;&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt;&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt;&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt;&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt;&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt;&gt;&gt; subtypes, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt;&gt;&gt; this plays out in Swift and in Ceylon would be instructive here.<br>&gt;&gt; <br>&gt;&gt; Sorry, the difficulty with Self I was thinking of only occurs when Self is in a covariant position<br>&gt;&gt; which is not the case in Comparable, of course. Let’s take a modified example instead with Self <br>&gt;&gt; in a covariant position:<br>&gt;&gt; <br>&gt;&gt; Swift:<br>&gt;&gt; <br>&gt;&gt; protocol Minimizable {<br>&gt;&gt;     func min(from other: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; final class A : Minimizable { // has to be final<br>&gt;&gt;  <br>&gt;&gt;     let x: Int<br>&gt;&gt;     <br>&gt;&gt;     init(x: Int) {<br>&gt;&gt;         self.x = x<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func min(from other: A) -&gt; A {<br>&gt;&gt;         return x &lt; other.x ? self : other<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Ceylon:<br>&gt;&gt; <br>&gt;&gt; interface Minimizable&lt;Other&gt; of Other given Other satisfies Minimizable&lt;Other&gt; {<br>&gt;&gt;     shared formal Other min(Other other);<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class A() satisfies Minimizable&lt;A&gt; {<br>&gt;&gt; <br>&gt;&gt;     Integer x = 0;<br>&gt;&gt; <br>&gt;&gt;     shared actual default A min(A other) {<br>&gt;&gt;         if (x &lt; other.x) {<br>&gt;&gt;             return this;<br>&gt;&gt;         } else {<br>&gt;&gt;             return other;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In Ceylon class A does not have to be final and choosing the minimum of two values would be available for values from the whole subtree of types rooted in A (the `of` ensures that such a declaration cannot „cross“ into other subtrees) whereas `Self` enforces that there is no subtree below class A.<br>&gt;&gt; <br>&gt;&gt; I have to admit that I am not well versed using `Self`, yet, so maybe I’m wrong here. In addition I am sure that `Self` allows designs<br>&gt;&gt; that are not possible with Ceylon’s `of`.<br>&gt;&gt; <br>&gt;&gt; The usage of Ceylon’s `of` for enumeration types is as follows (example taken from http://ceylon-lang.org/documentation/tour/types/ &lt;http://ceylon-lang.org/documentation/tour/types/&gt;):<br>&gt;&gt; <br>&gt;&gt; abstract class Node() of Leaf | Branch {}<br>&gt;&gt; <br>&gt;&gt; class Leaf(shared Object element) <br>&gt;&gt;         extends Node() {}<br>&gt;&gt; <br>&gt;&gt; class Branch(shared Node left, shared Node right) <br>&gt;&gt;         extends Node() {}<br>&gt;&gt; void printTree(Node node) {<br>&gt;&gt;     switch (node)<br>&gt;&gt;     case (is Leaf) {<br>&gt;&gt;         print(&quot;Found a leaf: ``node.element``!&quot;);<br>&gt;&gt;     }<br>&gt;&gt;     case (is Branch) {<br>&gt;&gt;         printTree(node.left);<br>&gt;&gt;         printTree(node.right);<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt;&gt;&gt; #Self etc.).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt;&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt;&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt;&gt;&gt; as `expanded` and you are done. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt;&gt;&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf &lt;https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf&gt;, you can&#39;t<br>&gt;&gt;&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt;&gt;&gt; cannot be considered a language with first-class value types.<br>&gt;&gt; <br>&gt;&gt; I haven’t had time yet to really evaluate that paper, but if you are right, then I agree<br>&gt;&gt; with you that Eiffel cannot be considered as having first-calss value types.<br>&gt;&gt; <br>&gt;&gt; At least one of the deficiencies listed in the paper does not exist anymore AFAIU <br>&gt;&gt; (expanded types not having constructors), though, so maybe things actually do have <br>&gt;&gt; changed since then.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt;&gt;&gt; the language to support value types.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt;&gt;&gt; to static constraints and even value types is to be expressed a kind of<br>&gt;&gt;&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt;&gt;&gt; that IMO help to clarify design intent.  This is a language design<br>&gt;&gt;&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt;&gt;&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt;&gt;&gt; expressivity test.<br>&gt;&gt; <br>&gt;&gt; That’s certainly a valid point.<br>&gt;&gt; <br>&gt;&gt; Furthermore I do understand (and fully support) that being interoperable with Objective-C is an <br>&gt;&gt; important restriction on Swift’s design space and I think it is absolutely awesome how<br>&gt;&gt; that has been achieved!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt;&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt;&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt;&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt;&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt;&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt;&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt;&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt;&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt;&gt;&gt; inherit from each other (yet?).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt;&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt;&gt;&gt; Generic Class ;-)<br>&gt;&gt; <br>&gt;&gt; Ah, ok, I took your statement of protocols being needed for strong value semantics<br>&gt;&gt; to be of general validity, not confined to Swift :-) <br>&gt;&gt; Within Swift that is certainly true!<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/57e7f3fb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 25, 2016, at 8:48 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.06.2016 um 19:09 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 6:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry for the late reply — I had hoped to be able to think more deeply about various points, <br>&gt;&gt;&gt; but I’m going to delay that instead of delaying the reply even more :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 17.06.2016 um 19:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt;&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt;&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt;&gt;&gt;&gt; must respond.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt;&gt;&gt;&gt; want to apologize sincerely.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My fundamental disagreement is with the content, not the tone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt;&gt;&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt;&gt;&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt;&gt;&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt;&gt;&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt;&gt;&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt;&gt;&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt;&gt;&gt;&gt; that I very much appreciate the contribution you&#39;re making.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks! I’m very glad about that!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt;&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt;&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt;&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt;&gt;&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt;&gt;&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt;&gt;&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt;&gt;&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt;&gt;&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt;&gt;&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt;&gt;&gt;&gt; and does not support wildcards.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt;&gt;&gt;&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt;&gt;&gt;&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt;&gt;&gt;&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt;&gt;&gt;&gt; one... but it was.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I never had assumed that this had been decided lightly ;-)<br>&gt;&gt;&gt; And I have been favorably impressed by the rationales put forth so far by the Swift <br>&gt;&gt;&gt; team, so it would definitely be interesting to learn a bit more about the rationale<br>&gt;&gt;&gt; being put into that decision and the advantages and disadvantages discussed back then.<br>&gt;&gt;&gt; Is there something written down somewhere? <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think some applicable rational exist in type-system papers that came out of studying scala&#39;s. <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, Swift could have been designed differently, so<br>&gt;&gt;&gt;&gt; that a single language construct, a kind of generic class, was stretched<br>&gt;&gt;&gt;&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt;&gt;&gt;&gt; results in a better language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still believe it would have advantages but I’ll concede that this discussion <br>&gt;&gt;&gt; will probably not help advancing Swift as this decision has been made.<br>&gt;&gt;&gt; Still, it might be of interest to keep in mind for further design considerations.<br>&gt;&gt; <br>&gt;&gt; Somehow the world of languages is small, and tracing inspiriation across is playing permutations on a limited set. <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt;&gt;&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt;&gt;&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt;&gt;&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt;&gt;&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt;&gt;&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt;&gt;&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt;&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt;&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt;&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt;&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt;&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt;&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt;&gt;&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I meant artifical in the sense that a different design choice would have been possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “generic type” you just mean anything that encodes a static type<br>&gt;&gt;&gt;&gt; relationship, lots of things fall into that bucket.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, I think Java’s generics are not that advanced, so the bucket does not <br>&gt;&gt;&gt; have to be very big :-)<br>&gt;&gt; <br>&gt;&gt; I am curious to see what language you have in mind when you are making a comparison?<br>&gt; <br>&gt; e.g. Ceylon and Scala with their definition-site variance declarations, Ceylon with defaults for type parameters, Scala with lower type bounds, Scala and Haskell with higher kinded types, Haskell with type classes, type families, kind polymorphism and lots more. Then there are things like types parameterized by values (like discussed on this list in the thread about expanding generics to support defining a type safe unit system).<br>&gt; <br></p><p>this was just about which generics you were familiar with, and were comparing with Java&#39;s. Considering how you seemed to indicate how puny the latter is compared to others i was expecting a more light-bulb-moment answer. I would have added kotlin and c# especially considering how their their definition-site syntax is the same. But more so kotlin if i had to name a type system with generics really dwarfing java&#39;s. :-)<br></p><p>&gt; The design space is much larger than the mainstream, especially something like Java, makes on believe… :-)<br></p><p>... or ceylon ;-)<br></p><p>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt;&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt;&gt;&gt;&gt; restriction just mentioned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt;&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt;&gt;&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt;&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt;&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt;&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt;&gt;&gt;&gt; *with wildcards* and tried to show why.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt;&gt;&gt;&gt; have no argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt;&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt;&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt;&gt;&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt;&gt;&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt;&gt;&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt;&gt;&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt;&gt;&gt;&gt; `Index`).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt;&gt;&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt;&gt;&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;    associatedtype T<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, those correspond.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt;&gt;&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt;&gt;&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt;&gt;&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt;&gt;&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt;&gt;&gt;&gt; share.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s a good one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt;&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt;&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt;&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt;&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt;&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt;&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt;&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt;&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt;&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt;&gt;&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt;&gt;&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For me, it helps distinguish static from dynamic polymorphism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, I’ll have to think more about that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt;&gt;&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt;&gt;&gt;&gt; too.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt;&gt;&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt;&gt;&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt;&gt;&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt;&gt;&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt;&gt;&gt;&gt; useful&quot;.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt;&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt;&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt;&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt;&gt;&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt;&gt;&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt;&gt;&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt;&gt;&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt;&gt;&gt;&gt; something else here?<br>&gt;&gt;&gt;&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I do, but it will take some research for me to recover my memory of<br>&gt;&gt;&gt;&gt; where the holes are.  It has been years since I thought about Java<br>&gt;&gt;&gt;&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you happen to remember, I’d be interested in hearing about the problems you meant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt;&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt;&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt;&gt;&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt;&gt;&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt;&gt;&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt;&gt;&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt;&gt;&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt;&gt;&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt;&gt;&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt;&gt;&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt;&gt;&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt;&gt;&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt;&gt;&gt;&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt;&gt;&gt;&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt;&gt;&gt;&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt;&gt;&gt;&gt; object-oriented approach to a given problem means reaching for those<br>&gt;&gt;&gt;&gt; features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed, it is not part of most OOP *implementations* while being compatible with OOP.<br>&gt;&gt;&gt; There have been lots of papers and research languages about typing problems like <br>&gt;&gt;&gt; binary methods, null pointers etc., though, so taking the mainstream OO languages<br>&gt;&gt;&gt; as the yardstick for OOP is jumping a little bit too short IMO. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt;&gt;&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt;&gt;&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt;&gt;&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt;&gt;&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt;&gt;&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt;&gt;&gt;&gt; express the constraint that comparable conformance means a type can be<br>&gt;&gt;&gt;&gt; compared to itself ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt;&gt;&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt;&gt;&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt;&gt;&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt;&gt;&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt;&gt;&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt;&gt;&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt;&gt;&gt;&gt; subtypes, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt;&gt;&gt;&gt; this plays out in Swift and in Ceylon would be instructive here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, the difficulty with Self I was thinking of only occurs when Self is in a covariant position<br>&gt;&gt;&gt; which is not the case in Comparable, of course. Let’s take a modified example instead with Self <br>&gt;&gt;&gt; in a covariant position:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Minimizable {<br>&gt;&gt;&gt;     func min(from other: Self) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; final class A : Minimizable { // has to be final<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     let x: Int<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(x: Int) {<br>&gt;&gt;&gt;         self.x = x<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     func min(from other: A) -&gt; A {<br>&gt;&gt;&gt;         return x &lt; other.x ? self : other<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ceylon:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; interface Minimizable&lt;Other&gt; of Other given Other satisfies Minimizable&lt;Other&gt; {<br>&gt;&gt;&gt;     shared formal Other min(Other other);<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class A() satisfies Minimizable&lt;A&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Integer x = 0;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     shared actual default A min(A other) {<br>&gt;&gt;&gt;         if (x &lt; other.x) {<br>&gt;&gt;&gt;             return this;<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return other;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Ceylon class A does not have to be final and choosing the minimum of two values would be available for values from the whole subtree of types rooted in A (the `of` ensures that such a declaration cannot „cross“ into other subtrees) whereas `Self` enforces that there is no subtree below class A.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have to admit that I am not well versed using `Self`, yet, so maybe I’m wrong here. In addition I am sure that `Self` allows designs<br>&gt;&gt;&gt; that are not possible with Ceylon’s `of`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The usage of Ceylon’s `of` for enumeration types is as follows (example taken from http://ceylon-lang.org/documentation/tour/types/):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; abstract class Node() of Leaf | Branch {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Leaf(shared Object element) <br>&gt;&gt;&gt;         extends Node() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Branch(shared Node left, shared Node right) <br>&gt;&gt;&gt;         extends Node() {}<br>&gt;&gt;&gt; void printTree(Node node) {<br>&gt;&gt;&gt;     switch (node)<br>&gt;&gt;&gt;     case (is Leaf) {<br>&gt;&gt;&gt;         print(&quot;Found a leaf: ``node.element``!&quot;);<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     case (is Branch) {<br>&gt;&gt;&gt;         printTree(node.left);<br>&gt;&gt;&gt;         printTree(node.right);<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt;&gt;&gt;&gt; #Self etc.).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt;&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt;&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt;&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt;&gt;&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt;&gt;&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt;&gt;&gt;&gt; as `expanded` and you are done. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt;&gt;&gt;&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf, you can&#39;t<br>&gt;&gt;&gt;&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt;&gt;&gt;&gt; cannot be considered a language with first-class value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t had time yet to really evaluate that paper, but if you are right, then I agree<br>&gt;&gt;&gt; with you that Eiffel cannot be considered as having first-calss value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At least one of the deficiencies listed in the paper does not exist anymore AFAIU <br>&gt;&gt;&gt; (expanded types not having constructors), though, so maybe things actually do have <br>&gt;&gt;&gt; changed since then.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt;&gt;&gt;&gt; the language to support value types.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt;&gt;&gt;&gt; to static constraints and even value types is to be expressed a kind of<br>&gt;&gt;&gt;&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt;&gt;&gt;&gt; that IMO help to clarify design intent.  This is a language design<br>&gt;&gt;&gt;&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt;&gt;&gt;&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt;&gt;&gt;&gt; expressivity test.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s certainly a valid point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore I do understand (and fully support) that being interoperable with Objective-C is an <br>&gt;&gt;&gt; important restriction on Swift’s design space and I think it is absolutely awesome how<br>&gt;&gt;&gt; that has been achieved!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt;&gt;&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt;&gt;&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt;&gt;&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt;&gt;&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt;&gt;&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt;&gt;&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt;&gt;&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt;&gt;&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt;&gt;&gt;&gt; inherit from each other (yet?).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt;&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt;&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt;&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt;&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt;&gt;&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt;&gt;&gt;&gt; Generic Class ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, ok, I took your statement of protocols being needed for strong value semantics<br>&gt;&gt;&gt; to be of general validity, not confined to Swift :-) <br>&gt;&gt;&gt; Within Swift that is certainly true!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/93ca51b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>July  2, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 25.06.2016 um 22:03 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 8:48 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.06.2016 um 19:09 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 25, 2016, at 6:34 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry for the late reply — I had hoped to be able to think more deeply about various points, <br>&gt;&gt;&gt;&gt; but I’m going to delay that instead of delaying the reply even more :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 17.06.2016 um 19:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Jun 16 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 13.06.2016 um 04:04 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jun 10 2016, Thorsten Seitz &lt;tseitz42-AT-icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:50 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 09.06.2016 um 18:49 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I should point out that with the resyntaxing of existentials to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not so bad.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the problem is more that Any&lt;Collection&gt; does not conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a specific value for a type parameter T: Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I mean by this is that `Collection` denotes a type family, a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generic parameter `T: Collection` denotes a specific (though<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unknown) member of that type family and `Any&lt;Collection&gt;` denotes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the type family again, so there is really no point in writing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any&lt;Collection&gt; IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The type family cannot conform to T because T is just one fixed member of it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It conforms to itself, though, as I can write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c1: Any&lt;Collection&gt; = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let c2: Any&lt;Collection&gt; = c1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That’s why I think that we could just drop Any&lt;Collection&gt; and simply write Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me expand that a bit:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually all this talk about existentials vs. generics or protocols<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vs. classes has had me confused somewhat and I think there are still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; some misconceptions present on this list sometimes, so I’ll try to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; clear them up:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are several objectively incorrect statements here, and several<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; others with which I disagree.  I was hoping someone else would write<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this for me, but since the post has such a tone of authority I feel I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; must respond.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You are right, the tone of my post was not appropriate, for which I<br>&gt;&gt;&gt;&gt;&gt;&gt; want to apologize sincerely.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My fundamental disagreement is with the content, not the tone.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still believe my statements to be valid, though, and will respond to<br>&gt;&gt;&gt;&gt;&gt;&gt; your arguments inline. Please don&#39;t get me wrong, I&#39;m not trying to<br>&gt;&gt;&gt;&gt;&gt;&gt; have an argument for the argument&#39;s sake. All I want is to contribute<br>&gt;&gt;&gt;&gt;&gt;&gt; maybe a tiny bit to make Swift even better than it already is, by<br>&gt;&gt;&gt;&gt;&gt;&gt; sharing ideas and thoughts not only from me but from the designs of<br>&gt;&gt;&gt;&gt;&gt;&gt; other perhaps more obscure programming languages which I happen to<br>&gt;&gt;&gt;&gt;&gt;&gt; have stumbled upon in the past (often with much delight).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And I want you to know, even though I disagree with what you&#39;ve written,<br>&gt;&gt;&gt;&gt;&gt; that I very much appreciate the contribution you&#39;re making.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks! I’m very glad about that!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (1) misconception: protocols with associated types are somehow very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; different from generics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think they are and I will explain why. The only difference is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the way the type parameters are bound: generics use explicit parameter<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; lists whereas protocols use inheritance. That has some advantages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (think long parameter lists of generics) and some disadvantages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; These ways are dual in a notation sense: generic types have to have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; all parameters bound whereas protocols cannot bind any of them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The „existential“ notation `Any&lt;&gt;` being discussed on this list is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nothing more than adding the ability to protocols to bind the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters to be used just like Java’s wildcards are adding the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; opposite feature to generics, namely not having to bind all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Protocols and generics fulfill completely different roles in Swift, and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; so, **especially in a language design context like the one we&#39;re in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; here**, must be thought of differently.  The former are an abstraction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mechanism for APIs, and the latter a mechanism for generalizing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not what I was talking about. Of course, protocols are a<br>&gt;&gt;&gt;&gt;&gt;&gt; mechanism for deriving types from each other whereas generics are a<br>&gt;&gt;&gt;&gt;&gt;&gt; way to parameterize types. My point was that Swift&#39;s other way to<br>&gt;&gt;&gt;&gt;&gt;&gt; parameterize types, namely by associated types, is very similar to<br>&gt;&gt;&gt;&gt;&gt;&gt; generics with wildcards when looking a the existentials of such<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols. In addition I was talking about generics in general, not<br>&gt;&gt;&gt;&gt;&gt;&gt; just about generics in Swift which restricts them to implementations<br>&gt;&gt;&gt;&gt;&gt;&gt; and does not support wildcards.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m aware of these other systems.  One of the problems with the way<br>&gt;&gt;&gt;&gt;&gt; you&#39;re writing about this is that we&#39;re speaking in the context of Swift<br>&gt;&gt;&gt;&gt;&gt; and you&#39;re assuming a completely open design space, as though Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt; choice to sharply distinguish classes from protocols was not a conscious<br>&gt;&gt;&gt;&gt;&gt; one... but it was.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I never had assumed that this had been decided lightly ;-)<br>&gt;&gt;&gt;&gt; And I have been favorably impressed by the rationales put forth so far by the Swift <br>&gt;&gt;&gt;&gt; team, so it would definitely be interesting to learn a bit more about the rationale<br>&gt;&gt;&gt;&gt; being put into that decision and the advantages and disadvantages discussed back then.<br>&gt;&gt;&gt;&gt; Is there something written down somewhere? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think some applicable rational exist in type-system papers that came out of studying scala&#39;s. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, Swift could have been designed differently, so<br>&gt;&gt;&gt;&gt;&gt; that a single language construct, a kind of generic class, was stretched<br>&gt;&gt;&gt;&gt;&gt; so it could express almost everything.  Personally, I don&#39;t believe that<br>&gt;&gt;&gt;&gt;&gt; results in a better language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still believe it would have advantages but I’ll concede that this discussion <br>&gt;&gt;&gt;&gt; will probably not help advancing Swift as this decision has been made.<br>&gt;&gt;&gt;&gt; Still, it might be of interest to keep in mind for further design considerations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Somehow the world of languages is small, and tracing inspiriation across is playing permutations on a limited set. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Other languages like Java offer generics for interfaces as well and<br>&gt;&gt;&gt;&gt;&gt;&gt; support wildcards (adding generic types parameters to protocols in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift is currently discussed on the mailing list as well).  FWIW my<br>&gt;&gt;&gt;&gt;&gt;&gt; arguments were not about whether we should have wildcards in Swift or<br>&gt;&gt;&gt;&gt;&gt;&gt; not, but simply to relate one parametrization feature (associated<br>&gt;&gt;&gt;&gt;&gt;&gt; types) to a more well known parametrization feature (generics with<br>&gt;&gt;&gt;&gt;&gt;&gt; wildcards) in order to understand them better.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only place you could argue that they intersect is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in generic non-final classes, because a class fills the dual role of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; abstraction and implementation mechanism (and some might say that&#39;s a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; weakness).  But even accounting for generic classes, protocols with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; associated types are very different from generics.  Two utterly<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; different types (an enum and a struct, for example) can conform to any<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; given protocol P, but generic types always share a common basis<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The latter is not the case for generic interfaces in Java, for<br>&gt;&gt;&gt;&gt;&gt;&gt; example, so it is just an artificial restriction present in Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s not an artificial restriction, it&#39;s a design choice.  Sure, if by<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I meant artifical in the sense that a different design choice would have been possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “generic type” you just mean anything that encodes a static type<br>&gt;&gt;&gt;&gt;&gt; relationship, lots of things fall into that bucket.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, I think Java’s generics are not that advanced, so the bucket does not <br>&gt;&gt;&gt;&gt; have to be very big :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am curious to see what language you have in mind when you are making a comparison?<br>&gt;&gt; <br>&gt;&gt; e.g. Ceylon and Scala with their definition-site variance declarations, Ceylon with defaults for type parameters, Scala with lower type bounds, Scala and Haskell with higher kinded types, Haskell with type classes, type families, kind polymorphism and lots more. Then there are things like types parameterized by values (like discussed on this list in the thread about expanding generics to support defining a type safe unit system).<br>&gt; <br>&gt; this was just about which generics you were familiar with, and were comparing with Java&#39;s.<br></p><p>Of course. Wouldn&#39;t make much sense to talk about something I&#39;m not familiar with here :-)<br></p><p>&gt; Considering how you seemed to indicate how puny the latter is compared to others i was expecting a more light-bulb-moment answer.<br></p><p>Well, I think I did list quite some features that are far more advanced than Java&#39;s generics.<br></p><p>&gt; I would have added kotlin and c# especially considering how their their definition-site syntax is the same.<br></p><p>Listing more languages supporting the same feature would not have made the gap wider, it would only have shown that the feature seems to be quite common and useful (which is not bad, but my goal was collecting generic features Java does not support and not trying to show how much such features are suppored outside of Java).<br></p><p>&gt; But more so kotlin if i had to name a type system with generics really dwarfing java&#39;s. :-)<br></p><p>I&#39;m not that familiar with Kotlin (only looking at it once in a while, because they have nice ideas), so I looked up their generics. They do have type projections which is a very nice feature complementing declaratin-site covariance annotations pretty well!<br>Apart from these I couldn&#39;t find additional generics features, so &quot;dwarfing&quot; seems a little bit much. Did I miss something?<br></p><p>&gt; <br>&gt;&gt; The design space is much larger than the mainstream, especially something like Java, makes on believe… :-)<br>&gt; <br>&gt; ... or ceylon ;-)<br></p><p>Of course, as there are Haskell, Scala, Erlang, Kotlin, Rust, Mozart/Oz, Smalltalk, Newspeak, Eiffel (e.g. multiple inheritance, pre- and postconditions and class invariants), Dylan (e.g. multiple dispatch), Cecil (e.g. multiple dispatch, dynamic inheritance), OCaml, Clojure, F#, Beta (nesting), Loom (binary methods, MyType), Fortress and many more that I forgot or never knew :-)<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is no way to produce distinct instances of a generic type with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; all its type parameters bound,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That is true in Swift (except for generic classes) due to the<br>&gt;&gt;&gt;&gt;&gt;&gt; restriction just mentioned.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but for any protocol P I can make infinitely many instances of P with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; P.AssociatedType == Int.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This likewise applies to generic interfaces and for generic types in<br>&gt;&gt;&gt;&gt;&gt;&gt; general if taking inheritance into account - just like you do here for<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Back to the my original point: while protocols and generic types have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; some similarities, the idea that they are fundamentally the same thing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (I know you didn&#39;t say *exactly* that, but I think it will be read that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; way) would be wrong and a very unproductive way to approach language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I said that protocols *with associated types* are much like generics<br>&gt;&gt;&gt;&gt;&gt;&gt; *with wildcards* and tried to show why.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If all you&#39;re trying to do is say that there&#39;s an analogy there, then we<br>&gt;&gt;&gt;&gt;&gt; have no argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Essentially `Any&lt;Collection&gt;` in Swift is just the same as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Collection&lt;?&gt;` in Java (assuming for comparability’s sake that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift’s Collection had no additional associated types; otherwise I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would just have to introduce a Collection&lt;Element, Index&gt; in Java).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t see how you can use an example that requires *assuming away*<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; assoociated types to justify an argument that protocols *with associated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types* are the same as generics.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note, that I said *additional* associated types, i.e. in addition to<br>&gt;&gt;&gt;&gt;&gt;&gt; .Element, even giving an example how the Java interface had to be<br>&gt;&gt;&gt;&gt;&gt;&gt; extended by a type parameter `Index` if this assumption was not<br>&gt;&gt;&gt;&gt;&gt;&gt; applied (still simplifying because Generator would have been more<br>&gt;&gt;&gt;&gt;&gt;&gt; correct which would have to be added as type parameter in addition to<br>&gt;&gt;&gt;&gt;&gt;&gt; `Index`).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So, in essence the comparison is between the following (I&#39;m using Foo<br>&gt;&gt;&gt;&gt;&gt;&gt; now instead of Collection to avoid the differences mentioned. Note<br>&gt;&gt;&gt;&gt;&gt;&gt; that this has no impact on the argument at all):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;    associatedtype T<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; interface Foo&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;    ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, those correspond.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My argument is that existentials of protocols with associated types<br>&gt;&gt;&gt;&gt;&gt;&gt; are just like generic types with wildcards, i.e. `Any&lt;Foo&gt;` in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt; is just the same as `Foo&lt;?&gt;` in Java.<br>&gt;&gt;&gt;&gt;&gt;&gt; Likewise `Any&lt;Foo where .T: Number&gt;` is just the same as `Foo&lt;?<br>&gt;&gt;&gt;&gt;&gt;&gt; extends Number&gt;` in Java. For me that was an insight I wanted to<br>&gt;&gt;&gt;&gt;&gt;&gt; share.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s a good one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And just like Collection&lt;?&gt; does not conform to a type parameter `T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extends Collection&lt;?&gt;` because Collection&lt;?&gt; is the type `forall<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; E. Collection&lt;E&gt;` whereas `T extends Collection&lt;?&gt;` is the type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `T. Collection&lt;T&gt;` for a given T.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In essence protocols with associated types are like generics with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wildcards.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is true that generics with wildcards in Java *are* (not just “like”)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; existential types but I don&#39;t agree with the statement above.  Because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Java tries to create an “everything is a class” world, generic classes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with bound type parameters end up playing the role of existential type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But protocols in Swift are not, fundamentally, just existential types,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and the resyntaxing of ProtocolName to Any&lt;ProtocolName&gt; for use in type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; context is a huge leap forward in making that distinction clear... when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that&#39;s done (unless we leave Array&lt;ProtocolName&gt; around as a synonym for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Array&lt;Any&lt;ProtocolName&gt;&gt;—I really hope we won&#39;t!)  protocols indeed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *won&#39;t* be types at all, existential or otherwise.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I fully agree that protocols are not types, their existentials<br>&gt;&gt;&gt;&gt;&gt;&gt; are. But I haven&#39;t seen yet what we really *gain* from making that<br>&gt;&gt;&gt;&gt;&gt;&gt; distinction explicit (except an ugly type syntax :-).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For me, it helps distinguish static from dynamic polymorphism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmm, I’ll have to think more about that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And like I already wrote in this or another thread we would have to<br>&gt;&gt;&gt;&gt;&gt;&gt; apply the same logic to non-final classes, which are existentials,<br>&gt;&gt;&gt;&gt;&gt;&gt; too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Coming back to the questions whether (a) allowing existentials to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; used as types is useful<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s the only use existentials have.  They *are* types.  Of course<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re useful, and I don&#39;t think anyone was arguing otherwise.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m pretty sure that there was a discussion about whether being able<br>&gt;&gt;&gt;&gt;&gt;&gt; to write something like Any&lt;Collection&gt; is useful. My wording was<br>&gt;&gt;&gt;&gt;&gt;&gt; certainly imprecise, though, and didn&#39;t make sense as written. I<br>&gt;&gt;&gt;&gt;&gt;&gt; should have said something like &quot;whether adding the ability to use<br>&gt;&gt;&gt;&gt;&gt;&gt; existential types of protocols with unbound associated types is<br>&gt;&gt;&gt;&gt;&gt;&gt; useful&quot;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and (b) whether sacrificing type safety would somehow be necessary for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that, I think we can safely answer (a) yes, it *is* useful to be able<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use existentials like Any&lt;Collection&gt; as types, because wildcards<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are quite often needed and very useful in Java (they haven’t been<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; added without a reason) (b) no, sacrificing type safety does not make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense, as the experience with Java’s wildcards shows that this is not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; needed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would call this “interesting information,” but hardly conclusive.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Java&#39;s generics are almost exactly the same thing as Objective-C<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; lightweight generics, which are less capable and less expressive in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; many ways than Swift&#39;s generics.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree that Java does not have something like `Self` or associated<br>&gt;&gt;&gt;&gt;&gt;&gt; types (which are really useful for not having to bind all type<br>&gt;&gt;&gt;&gt;&gt;&gt; parameters explicitly, especially when binding type parameters to<br>&gt;&gt;&gt;&gt;&gt;&gt; other generics which makes for long type parameter lists in Java where<br>&gt;&gt;&gt;&gt;&gt;&gt; I have to repeat everything over and over again), but do you mean<br>&gt;&gt;&gt;&gt;&gt;&gt; something else here?<br>&gt;&gt;&gt;&gt;&gt;&gt; Especially in the context of sacrificing type safety?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I do, but it will take some research for me to recover my memory of<br>&gt;&gt;&gt;&gt;&gt; where the holes are.  It has been years since I thought about Java<br>&gt;&gt;&gt;&gt;&gt; generics.  It&#39;s also possible that I&#39;m wrong ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you happen to remember, I’d be interested in hearing about the problems you meant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Especially if something like path dependent types is used like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed and some notation to open an existential’s type is added,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which is both something that Java does not have.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (2) misconception: POP is different from OOP<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not. Protocols are just interfaces using subtyping like OOP has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; always done. They just use associated types instead of explicit type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parameters for generics (see above).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; They are not the same thing at all (see above ;-&gt;).  To add to the list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; above, protocols can express fundamental relationships—like Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements—that OOP simply can&#39;t handle.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Eiffel has something like Self, it is called anchoring and allows<br>&gt;&gt;&gt;&gt;&gt;&gt; binding the type of a variable to that of another one or self (which<br>&gt;&gt;&gt;&gt;&gt;&gt; is called `Current` in Eiffel). And Eiffel does model everything with<br>&gt;&gt;&gt;&gt;&gt;&gt; classes which may be abstract and allow for real multiple inheritance<br>&gt;&gt;&gt;&gt;&gt;&gt; with abilities to resolve all conflicts including those concerning<br>&gt;&gt;&gt;&gt;&gt;&gt; state (which is what other languages introduce interfaces for to avoid<br>&gt;&gt;&gt;&gt;&gt;&gt; conflicts concerning state while still failing to solve *semantic*<br>&gt;&gt;&gt;&gt;&gt;&gt; conflicts with the same diamond pattern).<br>&gt;&gt;&gt;&gt;&gt;&gt; No protocols or interfaces needed. Why do you say this is not OOP? The<br>&gt;&gt;&gt;&gt;&gt;&gt; book which describes Eiffel is called &quot;Object-Oriented Software<br>&gt;&gt;&gt;&gt;&gt;&gt; Construction&quot; (and is now about 20 years old).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s not *incompatible* with OOP, but it is not part of the essence of<br>&gt;&gt;&gt;&gt;&gt; OOP either.  If you survey object-oriented languages, what you find in<br>&gt;&gt;&gt;&gt;&gt; common is inheritance-based dynamic polymorphism and reference<br>&gt;&gt;&gt;&gt;&gt; semantics.  Those are the defining characteristics of OOP, and taking an<br>&gt;&gt;&gt;&gt;&gt; object-oriented approach to a given problem means reaching for those<br>&gt;&gt;&gt;&gt;&gt; features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Agreed, it is not part of most OOP *implementations* while being compatible with OOP.<br>&gt;&gt;&gt;&gt; There have been lots of papers and research languages about typing problems like <br>&gt;&gt;&gt;&gt; binary methods, null pointers etc., though, so taking the mainstream OO languages<br>&gt;&gt;&gt;&gt; as the yardstick for OOP is jumping a little bit too short IMO. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s a reason Java can&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; express Comparable without losing static type-safety.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You are certainly right that Java is not the best language out there<br>&gt;&gt;&gt;&gt;&gt;&gt; especially when talking about type systems (I often enough rant about<br>&gt;&gt;&gt;&gt;&gt;&gt; it :-) but I&#39;m not sure what you mean here. Java&#39;s Comparable&lt;T&gt; seems<br>&gt;&gt;&gt;&gt;&gt;&gt; quite typesafe to me. Or do you mean that one could write `class A<br>&gt;&gt;&gt;&gt;&gt;&gt; implements Comparable&lt;B&gt;` by mistake? That&#39;s certainly a weak point<br>&gt;&gt;&gt;&gt;&gt;&gt; but doesn&#39;t compromise type safety, does it?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Java has cleverly avoided compromising type safety here by failing to<br>&gt;&gt;&gt;&gt;&gt; express the constraint that comparable conformance means a type can be<br>&gt;&gt;&gt;&gt;&gt; compared to itself ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Indeed :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ceylon has an elegant solution for that without using Self types:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; interface Comparable&lt;in Other&gt; of Other given Other satisfies Comparable&lt;Other&gt; {...}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note the variance annotation (which Swift currently has not) and the<br>&gt;&gt;&gt;&gt;&gt;&gt; `of` which ensures that the only subtype of Comparable&lt;T&gt; is T. This<br>&gt;&gt;&gt;&gt;&gt;&gt; is a nice feature that I haven&#39;t seen often in programming languages<br>&gt;&gt;&gt;&gt;&gt;&gt; (only Cecil comes to mind IIRC) and which is used for enumerations as<br>&gt;&gt;&gt;&gt;&gt;&gt; well in Ceylon. In Swift I cannot do this but can use Self which<br>&gt;&gt;&gt;&gt;&gt;&gt; solves this problem differently, albeit with some drawbacks compared<br>&gt;&gt;&gt;&gt;&gt;&gt; to Ceylon&#39;s solution (having to redefine the compare method in all<br>&gt;&gt;&gt;&gt;&gt;&gt; subtypes, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That sounds interesting but is a bit vague.  A concise example of how<br>&gt;&gt;&gt;&gt;&gt; this plays out in Swift and in Ceylon would be instructive here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, the difficulty with Self I was thinking of only occurs when Self is in a covariant position<br>&gt;&gt;&gt;&gt; which is not the case in Comparable, of course. Let’s take a modified example instead with Self <br>&gt;&gt;&gt;&gt; in a covariant position:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Minimizable {<br>&gt;&gt;&gt;&gt;     func min(from other: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; final class A : Minimizable { // has to be final<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;     let x: Int<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init(x: Int) {<br>&gt;&gt;&gt;&gt;         self.x = x<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     func min(from other: A) -&gt; A {<br>&gt;&gt;&gt;&gt;         return x &lt; other.x ? self : other<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; interface Minimizable&lt;Other&gt; of Other given Other satisfies Minimizable&lt;Other&gt; {<br>&gt;&gt;&gt;&gt;     shared formal Other min(Other other);<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class A() satisfies Minimizable&lt;A&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Integer x = 0;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     shared actual default A min(A other) {<br>&gt;&gt;&gt;&gt;         if (x &lt; other.x) {<br>&gt;&gt;&gt;&gt;             return this;<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;             return other;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In Ceylon class A does not have to be final and choosing the minimum of two values would be available for values from the whole subtree of types rooted in A (the `of` ensures that such a declaration cannot „cross“ into other subtrees) whereas `Self` enforces that there is no subtree below class A.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have to admit that I am not well versed using `Self`, yet, so maybe I’m wrong here. In addition I am sure that `Self` allows designs<br>&gt;&gt;&gt;&gt; that are not possible with Ceylon’s `of`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The usage of Ceylon’s `of` for enumeration types is as follows (example taken from http://ceylon-lang.org/documentation/tour/types/):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; abstract class Node() of Leaf | Branch {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Leaf(shared Object element) <br>&gt;&gt;&gt;&gt;         extends Node() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Branch(shared Node left, shared Node right) <br>&gt;&gt;&gt;&gt;         extends Node() {}<br>&gt;&gt;&gt;&gt; void printTree(Node node) {<br>&gt;&gt;&gt;&gt;     switch (node)<br>&gt;&gt;&gt;&gt;     case (is Leaf) {<br>&gt;&gt;&gt;&gt;         print(&quot;Found a leaf: ``node.element``!&quot;);<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     case (is Branch) {<br>&gt;&gt;&gt;&gt;         printTree(node.left);<br>&gt;&gt;&gt;&gt;         printTree(node.right);<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; which has lead to lengthy discussion threads about Self, StaticSelf,<br>&gt;&gt;&gt;&gt;&gt;&gt; #Self etc.).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; language with first-class value types, taking a protocol-oriented<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; approach to abstraction leads to *fundamentally* different designs from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; what you get using OOP.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Eiffel has expanded types which are value types with copy semantics<br>&gt;&gt;&gt;&gt;&gt;&gt; quite like structs in Swift. These expanded types are pretty much<br>&gt;&gt;&gt;&gt;&gt;&gt; integrated into Eiffel&#39;s class-only type system. Just define a class<br>&gt;&gt;&gt;&gt;&gt;&gt; as `expanded` and you are done. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unless this part of the language has changed since 1996, or unless I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; misread https://www.cs.kent.ac.uk/pubs/1996/798/content.pdf, you can&#39;t<br>&gt;&gt;&gt;&gt;&gt; make an efficient array with value semantics in Eiffel.  That, IMO,<br>&gt;&gt;&gt;&gt;&gt; cannot be considered a language with first-class value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t had time yet to really evaluate that paper, but if you are right, then I agree<br>&gt;&gt;&gt;&gt; with you that Eiffel cannot be considered as having first-calss value types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At least one of the deficiencies listed in the paper does not exist anymore AFAIU <br>&gt;&gt;&gt;&gt; (expanded types not having constructors), though, so maybe things actually do have <br>&gt;&gt;&gt;&gt; changed since then.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Eiffel seems to have no need to introduce interfaces or protocols to<br>&gt;&gt;&gt;&gt;&gt;&gt; the language to support value types.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No, of course not.  By saying that everything from abstract interfaces<br>&gt;&gt;&gt;&gt;&gt; to static constraints and even value types is to be expressed a kind of<br>&gt;&gt;&gt;&gt;&gt; possibly-generic class, you can eliminate distinctions in the language<br>&gt;&gt;&gt;&gt;&gt; that IMO help to clarify design intent.  This is a language design<br>&gt;&gt;&gt;&gt;&gt; choice one could make, but not one I&#39;d want to.  In LISP, everything is<br>&gt;&gt;&gt;&gt;&gt; an S-expression.  That has certain upsides, but for me it fails the<br>&gt;&gt;&gt;&gt;&gt; expressivity test.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s certainly a valid point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Furthermore I do understand (and fully support) that being interoperable with Objective-C is an <br>&gt;&gt;&gt;&gt; important restriction on Swift’s design space and I think it is absolutely awesome how<br>&gt;&gt;&gt;&gt; that has been achieved!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can even derive from expanded classes which is currently not<br>&gt;&gt;&gt;&gt;&gt;&gt; possible in Swift but has already been discussed several times on this<br>&gt;&gt;&gt;&gt;&gt;&gt; mailing list.  Polymorphic usage is only possible for non expanded<br>&gt;&gt;&gt;&gt;&gt;&gt; super types, which means as far as I understood that a reference is<br>&gt;&gt;&gt;&gt;&gt;&gt; used in that case. Variables with an expanded type do not use refences<br>&gt;&gt;&gt;&gt;&gt;&gt; and therefore may not be used polymorphically in Eiffel.  This should<br>&gt;&gt;&gt;&gt;&gt;&gt; be similar in Swift, at least as far as I did understand it. The<br>&gt;&gt;&gt;&gt;&gt;&gt; question whether variables with a value type can be used<br>&gt;&gt;&gt;&gt;&gt;&gt; polymorphically currently does not arise in Swift as structs cannot<br>&gt;&gt;&gt;&gt;&gt;&gt; inherit from each other (yet?).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The more important distinction of Swift is emphasizing value types and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; making mutation safely available by enforcing copy semantics for value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t, in fact, enforce copy semantics for value types.  That&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something I&#39;d like to change.  But regardless, value types would be a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; *lot* less useful if they couldn&#39;t conform to protocols, and so they<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would be a lot less used.  Heck, before we got protocol extensions in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift 2, there was basically *no way* to share implementation among<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; value types.  So you can&#39;t take protocols out of the picture without<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; making value types, and the argument for value semantics, far weaker.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why? Like I said, Eiffel *has* value types without needing<br>&gt;&gt;&gt;&gt;&gt;&gt; protocols. They just have a unified mechanism built around classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because I&#39;m speaking about Swift, not some other world where Protocol ==<br>&gt;&gt;&gt;&gt;&gt; Generic Class ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, ok, I took your statement of protocols being needed for strong value semantics<br>&gt;&gt;&gt;&gt; to be of general validity, not confined to Swift :-) <br>&gt;&gt;&gt;&gt; Within Swift that is certainly true!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/4e5db2ab/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 6:49 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Jordan Rose &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz<br>&gt;&gt; <br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt;  on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt;  itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt; it.<br>&gt;&gt; <br>&gt;&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt;&gt; point. <br>&gt; <br>&gt; I should point out that with the resyntaxing of existentials to<br>&gt; Any&lt;Protocols...&gt;, the idea that Collection&#39;s existential doesn&#39;t<br>&gt; conform to Collection becomes far less absurd than it was, so maybe this<br>&gt; is not so bad.<br></p><p>the issue I have will all proposed Any&lt;…&gt; so far is that they are rather heavy, and in the case of a replacement for the obj-c   id&lt;UITableViewDataSource&gt; or worse MyTVC&lt;UITableViewDataSource&gt; (I know the example is absurd for it stands for a specific concrete type conforming), it involves a bit of magic. So played with a little toy syntax starting from the sugaring you are doing for literals:<br></p><p>Array&lt;X&gt;  —&gt; [X]<br>Dict&lt;X,Y&gt; —&gt; [X:Y]<br></p><p>stretching it to consider that existential are a degenerate form of literal notation, then the following would not look entirely out of place<br></p><p>https://gist.github.com/lmihalkovic/8aa66542f5cc4592e967bade260477ef<br></p><p>[last example unfinished - missing opening syntax]<br></p><p><br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
