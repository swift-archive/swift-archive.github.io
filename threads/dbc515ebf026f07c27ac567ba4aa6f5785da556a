<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 12:00:00pm</p></header><div class="content"><p>There are several functions in public API, such as dispatch_sync and<br>dispatch_apply, which do not allow their block parameters to escape the<br>function call.<br></p><p>However, they are not currently exposed to Swift as @noescape, meaning that<br>users are required to specify &quot;self.&quot; or &quot;[weak self]&quot; in their closures.<br></p><p>The instances I can think of:<br></p><p>- dispatch_sync<br>- dispatch_barrier_sync<br>- dispatch_apply<br>- dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)<br></p><p>I provided a preliminary implementation at<br>https://github.com/apple/swift-corelibs-libdispatch/pull/6, but it needs<br>refinement. Tony Parker mentioned commented that there might be similar<br>changes to make for the swift-corelibs-foundation project.<br></p><p>Thoughts?<br></p><p>Question: does __attribute__((noescape)) have the same meaning when applied<br>to C function pointers? Namely, does Swift understand @noescape as it<br>applies to @convention(c)?<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/dbc5556a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.<br>&gt; <br>&gt; However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify &quot;self.&quot; or &quot;[weak self]&quot; in their closures.<br>&gt; <br>&gt; The instances I can think of:<br>&gt; <br>&gt; - dispatch_sync<br>&gt; - dispatch_barrier_sync<br>&gt; - dispatch_apply<br>&gt; - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)<br></p><p>I also pointed out dispatch_once(), which even it doesnâ€™t make sense for swift where the globals already have the proper semantics, is still useful as the compiler can still implement various optimizations in how the block captures its variables (it is okay to use the things where they are on the stack as opposed to have to create a real state for the block).<br></p><p>&gt; I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 &lt;https://github.com/apple/swift-corelibs-libdispatch/pull/6&gt;, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt;  _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/b39520e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi Jacob,<br></p><p>Thanks for bringing the discussion on this topic here.<br></p><p>One topic I wanted to discuss was finding a comprehensive list of API that needs the attribute. The next step after that is figuring out how to get this attribute to be consistent across Darwin and Swift open source.<br></p><p>One option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.<br></p><p>- Tony<br></p><p>&gt; On Dec 5, 2015, at 12:53 PM, Jacob Bandes-Storch via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; There are several functions in public API, such as dispatch_sync and dispatch_apply, which do not allow their block parameters to escape the function call.<br>&gt; <br>&gt; However, they are not currently exposed to Swift as @noescape, meaning that users are required to specify &quot;self.&quot; or &quot;[weak self]&quot; in their closures.<br>&gt; <br>&gt; The instances I can think of:<br>&gt; <br>&gt; - dispatch_sync<br>&gt; - dispatch_barrier_sync<br>&gt; - dispatch_apply<br>&gt; - dispatch_block_perform (thanks to Pierre Habouzit for pointing this out)<br>&gt; <br>&gt; I provided a preliminary implementation at https://github.com/apple/swift-corelibs-libdispatch/pull/6 &lt;https://github.com/apple/swift-corelibs-libdispatch/pull/6&gt;, but it needs refinement. Tony Parker mentioned commented that there might be similar changes to make for the swift-corelibs-foundation project.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Question: does __attribute__((noescape)) have the same meaning when applied to C function pointers? Namely, does Swift understand @noescape as it applies to @convention(c)?<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt;  _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/3caa81b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; One option was to use the API notes feature of the compiler to annotate<br>&gt; these APIs as part of the import into Swift. Another is to get the C<br>&gt; headers changed (on Darwin too) to add the attribute. We may want to do one<br>&gt; approach in the short term and another in the long term.<br>&gt;<br></p><p>I&#39;ve been operating under the assumption that __attribute__((noescape))<br>will eventually be deeply understood by clang, and allow the same elision<br>of &quot;self&quot; in Objective-C that @noescape does in Swift. (I filed<br>&lt;rdar://19914650&gt; for this some time ago.)<br></p><p>Thus, I think it makes the most sense to change the C headers.<br></p><p>However, if swift-corelibs-libdispatch isn&#39;t going to affect the Swift<br>versions that ship with Xcode in the near future, then I guess amending the<br>API notes is a good idea, so the @noescape versions can get into<br>developers&#39; hands as soon as possible.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/8598f3cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[swift-evolution] Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 1:44 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One option was to use the API notes feature of the compiler to annotate these APIs as part of the import into Swift. Another is to get the C headers changed (on Darwin too) to add the attribute. We may want to do one approach in the short term and another in the long term.<br>&gt; <br>&gt; I&#39;ve been operating under the assumption that __attribute__((noescape)) will eventually be deeply understood by clang, and allow the same elision of &quot;self&quot; in Objective-C that @noescape does in Swift. (I filed &lt;rdar://19914650&gt; for this some time ago.)<br>&gt; <br>&gt; Thus, I think it makes the most sense to change the C headers.<br></p><p>I completely agree with that statement, and I think that this change should make it into Darwin and swift-corelibs-libdispatch both.<br></p><p>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/7b5665e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[swift-evolution] Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 01:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015 at 1:50 PM, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I completely agree with that statement, and I think that this change<br>&gt; should make it into Darwin and swift-corelibs-libdispatch both.<br>&gt;<br>&gt; -Pierre<br>&gt;<br></p><p>Pardon my ignorance, but what is intended to be the difference between the<br>two? Will they diverge?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/dec69ae6/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  5, 2015 at 02:00:00pm</p></header><div class="content"><p>On Sat, Dec 5, 2015 at 1:40 PM, Tony Parker &lt;anthony.parker at apple.com&gt;<br>wrote:<br></p><p>&gt; One topic I wanted to discuss was finding a comprehensive list of API that<br>&gt; needs the attribute.<br>&gt;<br></p><p>On this subject, here are some other APIs which could use the annotation.<br>Again, I think these should be annotated even in the C/Objective-C headers,<br>so they can benefit C/Objective-C callers as well.<br></p><p>- bsearch, heapsort, qsort, mergesort, psort, and their _b variants<br></p><p>&quot;passing test&quot; methods:<br>- -[{NSArray,NSOrderedSet} indexOfObjectPassingTest:]<br>- -[{NSArray,NSOrderedSet} indexesOfObjectsPassingTest:]<br>- -[{NSArray,NSOrderedSet} indexOfObjectsAtIndexes:passingTest:]<br>- -[{NSArray,NSOrderedSet} indexesOfObjectsAtIndexes:passingTest:]<br>- -[SCNNode childNodesPassingTest:]<br>- -[SCNSceneSource entriesPassingTest:]<br>- -[AVAudioUnitComponentManager componentsPassingTest:]<br>- -[NSIndexSet indexPassingTest:]<br>- -[NSIndexSet indexWithOptions:passingTest:]<br>- -[NSIndexSet indexesPassingTest:]<br>- -[NSIndexSet indexesWithOptions:passingTest:]<br>- -[NSIndexSet indexInRange:options:passingTest:]<br>- -[NSIndexSet indexesInRange:options:passingTest:]<br>- -[NSSet objectsPassingTest:]<br>- -[NSSet objectsWithOptions:passingTest:]<br>- -[NSDictionary keysOfEntriesPassingTest:]<br>- -[NSDictionary keysOfEntriesWithOptions:passingTest:]<br></p><p>&quot;using comparator&quot; methods:<br>- -[NSArray indexOfObject:inSortedRange:options:usingComparator:]<br>- -[NSArray sortedArrayUsingComparator:]<br>- -[NSArray sortedArrayWithOptions:usingComparator:]<br>- -[NSDictionary keysSortedByValueUsingComparator:]<br>- -[NSDictionary keysSortedByValueWithOptions:usingComparator:]<br>- -[NSMutableArray sortUsingComparator:]<br>- -[NSMutableArray sortWithOptions:usingComparator:]<br>- -[NSMutableOrderedSet sortWithOptions:usingComparator:]<br>- -[NSMutableOrderedSet sortRange:options:usingComparator:]<br></p><p> (and some of these have &quot;usingFunction&quot; variants)<br></p><p>&quot;enumerate using block&quot; methods:<br>- -[NSTableView enumerateAvailableRowViewsUsingBlock:]<br>- -[SKPhysicsWorld enumerateBodiesAtPoint:usingBlock:]<br>- -[SKPhysicsWorld enumerateBodiesInRect:usingBlock:]<br>- -[NSData enumerateByteRangesUsingBlock:]<br>- -[SCNNode enumerateChildNodesUsingBlock:]<br>- -[SCNNode enumerateChildNodesWithName:usingBlock:]<br>- -[NSIndexSet enumerateIndexesUsingBlock:]<br>- -[NSIndexSet enumerateIndexesWithOptions:usingBlock:]<br>- -[NSDictionary enumerateKeysAndObjectsUsingBlock:]<br>- -[NSDictionary enumerateKeysAndObjectsWithOptions:usingBlock:]<br>- -[NSString enumerateLinesUsingBlock:]<br>- -[NSString enumerateSubstringsInRange:options:usingBlock:]<br>- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsUsingBlock:]<br>- -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsWithOptions:usingBlock:]<br>- -[NSIndexSet enumerateRangesUsingBlock:]<br>- -[NSIndexSet enumerateRangesWithOptions:usingBlock:]<br>- -[NSIndexSet enumerateRangesInRange:options:usingBlock:]<br>- -[MPMediaEntity enumerateValuesForProperties:usingBlock:]<br>- -[NSMetadataQuery enumerateResultsUsingBlock:]<br>- -[NSMetadataQuery enumerateResultsWithOptions:usingBlock:]<br></p><p>misc:<br>- -[NSDocument performSynchronousFileAccessUsingBlock:]<br></p><p>Wow, that&#39;s more than I expected to find! This is obviously beyond the<br>scope of just libdispatch, and I think a lot of these should probably<br>change upstream, in their original frameworks, internally (not something<br>that community members can really contribute to).<br></p><p>Arguably, the &quot;enumerateXUsingBlock:&quot; pattern should be bridged to Swift as<br>something SequenceType-ish which can be `for-in`ed.<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151205/6f83b5e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 12:00:00am</p></header><div class="content"><p>Alright, I&#39;ve written up a proposal:<br>https://github.com/apple/swift-evolution/pull/40<br></p><p>Feedback welcome!<br></p><p>Jacob<br></p><p>On Sat, Dec 5, 2015 at 2:25 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Sat, Dec 5, 2015 at 1:40 PM, Tony Parker &lt;anthony.parker at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; One topic I wanted to discuss was finding a comprehensive list of API<br>&gt;&gt; that needs the attribute.<br>&gt;&gt;<br>&gt;<br>&gt; On this subject, here are some other APIs which could use the annotation.<br>&gt; Again, I think these should be annotated even in the C/Objective-C headers,<br>&gt; so they can benefit C/Objective-C callers as well.<br>&gt;<br>&gt; - bsearch, heapsort, qsort, mergesort, psort, and their _b variants<br>&gt;<br>&gt; &quot;passing test&quot; methods:<br>&gt; - -[{NSArray,NSOrderedSet} indexOfObjectPassingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexesOfObjectsPassingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexOfObjectsAtIndexes:passingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexesOfObjectsAtIndexes:passingTest:]<br>&gt; - -[SCNNode childNodesPassingTest:]<br>&gt; - -[SCNSceneSource entriesPassingTest:]<br>&gt; - -[AVAudioUnitComponentManager componentsPassingTest:]<br>&gt; - -[NSIndexSet indexPassingTest:]<br>&gt; - -[NSIndexSet indexWithOptions:passingTest:]<br>&gt; - -[NSIndexSet indexesPassingTest:]<br>&gt; - -[NSIndexSet indexesWithOptions:passingTest:]<br>&gt; - -[NSIndexSet indexInRange:options:passingTest:]<br>&gt; - -[NSIndexSet indexesInRange:options:passingTest:]<br>&gt; - -[NSSet objectsPassingTest:]<br>&gt; - -[NSSet objectsWithOptions:passingTest:]<br>&gt; - -[NSDictionary keysOfEntriesPassingTest:]<br>&gt; - -[NSDictionary keysOfEntriesWithOptions:passingTest:]<br>&gt;<br>&gt; &quot;using comparator&quot; methods:<br>&gt; - -[NSArray indexOfObject:inSortedRange:options:usingComparator:]<br>&gt; - -[NSArray sortedArrayUsingComparator:]<br>&gt; - -[NSArray sortedArrayWithOptions:usingComparator:]<br>&gt; - -[NSDictionary keysSortedByValueUsingComparator:]<br>&gt; - -[NSDictionary keysSortedByValueWithOptions:usingComparator:]<br>&gt; - -[NSMutableArray sortUsingComparator:]<br>&gt; - -[NSMutableArray sortWithOptions:usingComparator:]<br>&gt; - -[NSMutableOrderedSet sortWithOptions:usingComparator:]<br>&gt; - -[NSMutableOrderedSet sortRange:options:usingComparator:]<br>&gt;<br>&gt;  (and some of these have &quot;usingFunction&quot; variants)<br>&gt;<br>&gt; &quot;enumerate using block&quot; methods:<br>&gt; - -[NSTableView enumerateAvailableRowViewsUsingBlock:]<br>&gt; - -[SKPhysicsWorld enumerateBodiesAtPoint:usingBlock:]<br>&gt; - -[SKPhysicsWorld enumerateBodiesInRect:usingBlock:]<br>&gt; - -[NSData enumerateByteRangesUsingBlock:]<br>&gt; - -[SCNNode enumerateChildNodesUsingBlock:]<br>&gt; - -[SCNNode enumerateChildNodesWithName:usingBlock:]<br>&gt; - -[NSIndexSet enumerateIndexesUsingBlock:]<br>&gt; - -[NSIndexSet enumerateIndexesWithOptions:usingBlock:]<br>&gt; - -[NSDictionary enumerateKeysAndObjectsUsingBlock:]<br>&gt; - -[NSDictionary enumerateKeysAndObjectsWithOptions:usingBlock:]<br>&gt; - -[NSString enumerateLinesUsingBlock:]<br>&gt; - -[NSString enumerateSubstringsInRange:options:usingBlock:]<br>&gt; - -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsUsingBlock:]<br>&gt; - -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsWithOptions:usingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesUsingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesWithOptions:usingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesInRange:options:usingBlock:]<br>&gt; - -[MPMediaEntity enumerateValuesForProperties:usingBlock:]<br>&gt; - -[NSMetadataQuery enumerateResultsUsingBlock:]<br>&gt; - -[NSMetadataQuery enumerateResultsWithOptions:usingBlock:]<br>&gt;<br>&gt; misc:<br>&gt; - -[NSDocument performSynchronousFileAccessUsingBlock:]<br>&gt;<br>&gt; Wow, that&#39;s more than I expected to find! This is obviously beyond the<br>&gt; scope of just libdispatch, and I think a lot of these should probably<br>&gt; change upstream, in their original frameworks, internally (not something<br>&gt; that community members can really contribute to).<br>&gt;<br>&gt; Arguably, the &quot;enumerateXUsingBlock:&quot; pattern should be bridged to Swift<br>&gt; as something SequenceType-ish which can be `for-in`ed.<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151208/967f21c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>[swift-evolution] Proposal: add `noescape` attribute to public API (particularly libdispatch)</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>To re-iterate my comment on github; I think this is a great idea. <br></p><p>There are a couple of suggestions for scope limiting; since this will require changes in the c and objective-c layers to support this attribute it would be good to limit this for now to just the core libraries (dispatch, XCTest and Foundation). <br></p><p>Most likely future optimizations in c and objective c code can be applied in addition to the positive effect to swift code.<br></p><p>&gt; On Dec 8, 2015, at 12:02 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Alright, I&#39;ve written up a proposal: https://github.com/apple/swift-evolution/pull/40 &lt;https://github.com/apple/swift-evolution/pull/40&gt;<br>&gt; <br>&gt; Feedback welcome!<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Sat, Dec 5, 2015 at 2:25 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; On Sat, Dec 5, 2015 at 1:40 PM, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt; One topic I wanted to discuss was finding a comprehensive list of API that needs the attribute.<br>&gt; <br>&gt; On this subject, here are some other APIs which could use the annotation. Again, I think these should be annotated even in the C/Objective-C headers, so they can benefit C/Objective-C callers as well.<br>&gt; <br>&gt; - bsearch, heapsort, qsort, mergesort, psort, and their _b variants<br>&gt; <br>&gt; &quot;passing test&quot; methods:<br>&gt; - -[{NSArray,NSOrderedSet} indexOfObjectPassingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexesOfObjectsPassingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexOfObjectsAtIndexes:passingTest:]<br>&gt; - -[{NSArray,NSOrderedSet} indexesOfObjectsAtIndexes:passingTest:]<br>&gt; - -[SCNNode childNodesPassingTest:]<br>&gt; - -[SCNSceneSource entriesPassingTest:]<br>&gt; - -[AVAudioUnitComponentManager componentsPassingTest:]<br>&gt; - -[NSIndexSet indexPassingTest:]<br>&gt; - -[NSIndexSet indexWithOptions:passingTest:]<br>&gt; - -[NSIndexSet indexesPassingTest:]<br>&gt; - -[NSIndexSet indexesWithOptions:passingTest:]<br>&gt; - -[NSIndexSet indexInRange:options:passingTest:]<br>&gt; - -[NSIndexSet indexesInRange:options:passingTest:]<br>&gt; - -[NSSet objectsPassingTest:]<br>&gt; - -[NSSet objectsWithOptions:passingTest:]<br>&gt; - -[NSDictionary keysOfEntriesPassingTest:]<br>&gt; - -[NSDictionary keysOfEntriesWithOptions:passingTest:]<br>&gt; <br>&gt; &quot;using comparator&quot; methods:<br>&gt; - -[NSArray indexOfObject:inSortedRange:options:usingComparator:]<br>&gt; - -[NSArray sortedArrayUsingComparator:]<br>&gt; - -[NSArray sortedArrayWithOptions:usingComparator:]<br>&gt; - -[NSDictionary keysSortedByValueUsingComparator:]<br>&gt; - -[NSDictionary keysSortedByValueWithOptions:usingComparator:]<br>&gt; - -[NSMutableArray sortUsingComparator:]<br>&gt; - -[NSMutableArray sortWithOptions:usingComparator:]<br>&gt; - -[NSMutableOrderedSet sortWithOptions:usingComparator:]<br>&gt; - -[NSMutableOrderedSet sortRange:options:usingComparator:]<br>&gt; <br>&gt;  (and some of these have &quot;usingFunction&quot; variants)<br>&gt; <br>&gt; &quot;enumerate using block&quot; methods:<br>&gt; - -[NSTableView enumerateAvailableRowViewsUsingBlock:]<br>&gt; - -[SKPhysicsWorld enumerateBodiesAtPoint:usingBlock:]<br>&gt; - -[SKPhysicsWorld enumerateBodiesInRect:usingBlock:]<br>&gt; - -[NSData enumerateByteRangesUsingBlock:]<br>&gt; - -[SCNNode enumerateChildNodesUsingBlock:]<br>&gt; - -[SCNNode enumerateChildNodesWithName:usingBlock:]<br>&gt; - -[NSIndexSet enumerateIndexesUsingBlock:]<br>&gt; - -[NSIndexSet enumerateIndexesWithOptions:usingBlock:]<br>&gt; - -[NSDictionary enumerateKeysAndObjectsUsingBlock:]<br>&gt; - -[NSDictionary enumerateKeysAndObjectsWithOptions:usingBlock:]<br>&gt; - -[NSString enumerateLinesUsingBlock:]<br>&gt; - -[NSString enumerateSubstringsInRange:options:usingBlock:]<br>&gt; - -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsUsingBlock:]<br>&gt; - -[{NSArray,NSSet,NSOrderedSet} enumerateObjectsWithOptions:usingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesUsingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesWithOptions:usingBlock:]<br>&gt; - -[NSIndexSet enumerateRangesInRange:options:usingBlock:]<br>&gt; - -[MPMediaEntity enumerateValuesForProperties:usingBlock:]<br>&gt; - -[NSMetadataQuery enumerateResultsUsingBlock:]<br>&gt; - -[NSMetadataQuery enumerateResultsWithOptions:usingBlock:]<br>&gt; <br>&gt; misc:<br>&gt; - -[NSDocument performSynchronousFileAccessUsingBlock:]<br>&gt; <br>&gt; Wow, that&#39;s more than I expected to find! This is obviously beyond the scope of just libdispatch, and I think a lot of these should probably change upstream, in their original frameworks, internally (not something that community members can really contribute to).<br>&gt; <br>&gt; Arguably, the &quot;enumerateXUsingBlock:&quot; pattern should be bridged to Swift as something SequenceType-ish which can be `for-in`ed.<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151209/88f42434/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
