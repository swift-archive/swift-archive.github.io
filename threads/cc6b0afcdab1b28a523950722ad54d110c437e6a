<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ebd4f96d72358cfa22f7b3a92d547f4?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Team AOL</string> &lt;alexey.demedetskiy at teamaol.com&gt;<p>February 16, 2016 at 12:00:00am</p></header><div class="content"><p>Hi<br></p><p>I would like to suggest you to extend your proposal.<br></p><p>In my practice, overriding super functions can have several semantics.<br>1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>3) Before super - opposite to 2.<br>4) Override - no rules about order, but super call must be done. <br></p><p>So code can look like: <br></p><p>override(after) func viewDidLoad() {<br>    // super.viewDidLoad() &lt;— no need to call super at first line.<br>    // child code<br>}<br></p><p>override(before) func tearDown() {<br>    // clean code<br>    // super… inserted by compiler<br>}<br></p><p>override(instead) func loadView() {<br>    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>}<br></p><p>override func refillHealthBar() {<br>   // absent call to super will cause an error with fix-up to add (instead) modifier<br>}<br></p><p>I am not sure about exposing this in a public interface and limit child override options.<br></p><p>But in general - what is your thoughts about this approach to problem that you mention?<br></p><p><br>&gt; Hi!<br>&gt; <br>&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; <br>&gt; class View {<br>&gt; func viewDidLoad() {<br>&gt; // does something<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; class Button: View {<br>&gt; override func viewDidLoad() {<br>&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; // do something other<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; <br>&gt; // Example for extending a function<br>&gt; class Button: View {<br>&gt; extend func viewDidLoad() {<br>&gt; super.viewDidLoad()<br>&gt; // do something<br>&gt; }<br>&gt; <br>&gt; extend func viewDidAppear() {<br>&gt; // do something<br>&gt; } //&lt;— the compiler should throw an error here.<br>&gt; }<br>&gt; <br>&gt; // Example for replacing a function<br>&gt; class Geometry {<br>&gt; func volume() -&gt;Double {<br>&gt; return 0;<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; class Cube: Geometry {<br>&gt; var length: Double = 0.0<br>&gt; replace func volume() -&gt;Double {<br>&gt; let v = length * length * length<br>&gt; return v<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; Cheers,<br>&gt; Florian<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 15, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 for what you outlined Alexey. I think maintaining the use of override as<br>the keyword is the most understandable in the context and also is<br>terminology usually used in various object languages. I like adding the<br>optional qualifiers to allow (1) better diagnostics by the compiler, (2)<br>clearer code, and (3) the opportunity for compiler generating the need<br>coded (in a few of the situations).<br></p><p>Can something like this be used in the super classes interface definition<br>to clarify expectations of a subclass?<br></p><p>On Mon, Feb 15, 2016 at 2:07 PM Alexey Demedetskiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi<br>&gt;<br>&gt; I would like to suggest you to extend your proposal.<br>&gt;<br>&gt; In my practice, overriding super functions can have several semantics.<br>&gt; 1) Replace - simple case for abstract classes which implementation do<br>&gt; nothing, or throw an exceptions.<br>&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc.<br>&gt; All cases where super expect to be called before child code.<br>&gt; 3) Before super - opposite to 2.<br>&gt; 4) Override - no rules about order, but super call must be done.<br>&gt;<br>&gt; So code can look like:<br>&gt;<br>&gt; override(after) func viewDidLoad() {<br>&gt;     // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;     // child code<br>&gt; }<br>&gt;<br>&gt; override(before) func tearDown() {<br>&gt;     // clean code<br>&gt;     // super… inserted by compiler<br>&gt; }<br>&gt;<br>&gt; override(instead) func loadView() {<br>&gt;     // super.loadView() &lt;— marked as an error with appropriate fix-up to<br>&gt; remove instead modifier<br>&gt; }<br>&gt;<br>&gt; override func refillHealthBar() {<br>&gt;    // absent call to super will cause an error with fix-up to add<br>&gt; (instead) modifier<br>&gt; }<br>&gt;<br>&gt; I am not sure about exposing this in a public interface and limit child<br>&gt; override options.<br>&gt;<br>&gt; But in general - what is your thoughts about this approach to problem that<br>&gt; you mention?<br>&gt;<br>&gt;<br>&gt; &gt; Hi!<br>&gt; &gt;<br>&gt; &gt; I would like to suggest to replace the override keyword for functions by<br>&gt; something like extend and replace or to add an annotation like<br>&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt; The reason for this is, that it might happen, that one forgets to call<br>&gt; the super’s implementation in an overridden function or if one reads the<br>&gt; code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt;<br>&gt; &gt; class View {<br>&gt; &gt; func viewDidLoad() {<br>&gt; &gt; // does something<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Button: View {<br>&gt; &gt; override func viewDidLoad() {<br>&gt; &gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt; // do something other<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The compiler will accept if one overrides a superclass’s function but<br>&gt; does not call the superclass’s implementation which is often ok. The<br>&gt; developer should clearly state that he doesn’t want to call the<br>&gt; superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt;<br>&gt; &gt; // Example for extending a function<br>&gt; &gt; class Button: View {<br>&gt; &gt; extend func viewDidLoad() {<br>&gt; &gt; super.viewDidLoad()<br>&gt; &gt; // do something<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extend func viewDidAppear() {<br>&gt; &gt; // do something<br>&gt; &gt; } //&lt;— the compiler should throw an error here.<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Example for replacing a function<br>&gt; &gt; class Geometry {<br>&gt; &gt; func volume() -&gt;Double {<br>&gt; &gt; return 0;<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Cube: Geometry {<br>&gt; &gt; var length: Double = 0.0<br>&gt; &gt; replace func volume() -&gt;Double {<br>&gt; &gt; let v = length * length * length<br>&gt; &gt; return v<br>&gt; &gt; }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Cheers,<br>&gt; &gt; Florian<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/e1d7d9ee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>-1 for enforcing the super call place.<br>While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br></p><p>I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br></p><p>&gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi<br>&gt; <br>&gt; I would like to suggest you to extend your proposal.<br>&gt; <br>&gt; In my practice, overriding super functions can have several semantics.<br>&gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; 3) Before super - opposite to 2.<br>&gt; 4) Override - no rules about order, but super call must be done. <br>&gt; <br>&gt; So code can look like: <br>&gt; <br>&gt; override(after) func viewDidLoad() {<br>&gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;    // child code<br>&gt; }<br>&gt; <br>&gt; override(before) func tearDown() {<br>&gt;    // clean code<br>&gt;    // super… inserted by compiler<br>&gt; }<br>&gt; <br>&gt; override(instead) func loadView() {<br>&gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; }<br>&gt; <br>&gt; override func refillHealthBar() {<br>&gt;   // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; }<br>&gt; <br>&gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt; <br>&gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt; <br>&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; <br>&gt;&gt; class View {<br>&gt;&gt; func viewDidLoad() {<br>&gt;&gt; // does something<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Button: View {<br>&gt;&gt; override func viewDidLoad() {<br>&gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt;&gt; // do something other<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; <br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt; extend func viewDidLoad() {<br>&gt;&gt; super.viewDidLoad()<br>&gt;&gt; // do something<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extend func viewDidAppear() {<br>&gt;&gt; // do something<br>&gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt; func volume() -&gt;Double {<br>&gt;&gt; return 0;<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt; var length: Double = 0.0<br>&gt;&gt; replace func volume() -&gt;Double {<br>&gt;&gt; let v = length * length * length<br>&gt;&gt; return v<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br></p><p>For example: should standard library types prefer the &#39;override&#39; form which<br>enforces calling super but doesn&#39;t enforce when it is called?<br>Perhaps &#39;override(before)&#39; should be an indication that, if the overriding<br>method doesn&#39;t explicitly declare the super call, then it should be called<br>implicitly at the start of the function?<br></p><p>On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; -1 for enforcing the super call place.<br>&gt; While we usually call super at the beginning of viewDidLoad for instance,<br>&gt; there is absolutely no need to enforce it and it may result in problem when<br>&gt; some work have to be done before the super method is executed.<br>&gt;<br>&gt; I have some use cases that rely on performing setup before calling the<br>&gt; super.viewDidLoad().<br>&gt;<br>&gt; &gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; Hi<br>&gt; &gt;<br>&gt; &gt; I would like to suggest you to extend your proposal.<br>&gt; &gt;<br>&gt; &gt; In my practice, overriding super functions can have several semantics.<br>&gt; &gt; 1) Replace - simple case for abstract classes which implementation do<br>&gt; nothing, or throw an exceptions.<br>&gt; &gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc.<br>&gt; All cases where super expect to be called before child code.<br>&gt; &gt; 3) Before super - opposite to 2.<br>&gt; &gt; 4) Override - no rules about order, but super call must be done.<br>&gt; &gt;<br>&gt; &gt; So code can look like:<br>&gt; &gt;<br>&gt; &gt; override(after) func viewDidLoad() {<br>&gt; &gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt; &gt;    // child code<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(before) func tearDown() {<br>&gt; &gt;    // clean code<br>&gt; &gt;    // super… inserted by compiler<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(instead) func loadView() {<br>&gt; &gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to<br>&gt; remove instead modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override func refillHealthBar() {<br>&gt; &gt;   // absent call to super will cause an error with fix-up to add<br>&gt; (instead) modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I am not sure about exposing this in a public interface and limit child<br>&gt; override options.<br>&gt; &gt;<br>&gt; &gt; But in general - what is your thoughts about this approach to problem<br>&gt; that you mention?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Hi!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to suggest to replace the override keyword for functions<br>&gt; by something like extend and replace or to add an annotation like<br>&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt;&gt; The reason for this is, that it might happen, that one forgets to call<br>&gt; the super’s implementation in an overridden function or if one reads the<br>&gt; code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class View {<br>&gt; &gt;&gt; func viewDidLoad() {<br>&gt; &gt;&gt; // does something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; override func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt;&gt; // do something other<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The compiler will accept if one overrides a superclass’s function but<br>&gt; does not call the superclass’s implementation which is often ok. The<br>&gt; developer should clearly state that he doesn’t want to call the<br>&gt; superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for extending a function<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; extend func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad()<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extend func viewDidAppear() {<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for replacing a function<br>&gt; &gt;&gt; class Geometry {<br>&gt; &gt;&gt; func volume() -&gt;Double {<br>&gt; &gt;&gt; return 0;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Cube: Geometry {<br>&gt; &gt;&gt; var length: Double = 0.0<br>&gt; &gt;&gt; replace func volume() -&gt;Double {<br>&gt; &gt;&gt; let v = length * length * length<br>&gt; &gt;&gt; return v<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt; Florian<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/4d2d5295/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ebd4f96d72358cfa22f7b3a92d547f4?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Team AOL</string> &lt;alexey.demedetskiy at teamaol.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br></p><p>In this case you don’t need to write: override(after) func videDidLoad() { … }<br>Just override will be enough.<br></p><p>From my point of view there is no need to add some constraints to childs. There is some cases where this constraints can help, <br>but I think they will make the overall system very fragile and inflexible. <br></p><p>override(before), override(after), override(instead) and override affect only one specific function. You cannot constrain child call with it. <br></p><p>Also, simple fix-it should be provided:<br></p><p>1) If no modifiers present and call to super is first call in function --&gt; propose to remove it and add (after) modifier<br>2) If no modifiers present and call to super is last call in function --&gt; propose to remove it and add (before) modifier<br>3) If no modifiers present and no call to super in function --&gt; propose to add (instead) modifier<br>4) If any modifier is present and there is call to super in function body —&gt; propose to remove modifier.<br></p><p>In this case no existing code will be affected of malfunctioning.<br></p><p>&gt; On Feb 16, 2016, at 4:21 PM, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt; <br>&gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; -1 for enforcing the super call place.<br>&gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt; <br>&gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt; <br>&gt; &gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; Hi<br>&gt; &gt;<br>&gt; &gt; I would like to suggest you to extend your proposal.<br>&gt; &gt;<br>&gt; &gt; In my practice, overriding super functions can have several semantics.<br>&gt; &gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; &gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; &gt; 3) Before super - opposite to 2.<br>&gt; &gt; 4) Override - no rules about order, but super call must be done.<br>&gt; &gt;<br>&gt; &gt; So code can look like:<br>&gt; &gt;<br>&gt; &gt; override(after) func viewDidLoad() {<br>&gt; &gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt; &gt;    // child code<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(before) func tearDown() {<br>&gt; &gt;    // clean code<br>&gt; &gt;    // super… inserted by compiler<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(instead) func loadView() {<br>&gt; &gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override func refillHealthBar() {<br>&gt; &gt;   // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt; &gt;<br>&gt; &gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Hi!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class View {<br>&gt; &gt;&gt; func viewDidLoad() {<br>&gt; &gt;&gt; // does something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; override func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt;&gt; // do something other<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for extending a function<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; extend func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad()<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extend func viewDidAppear() {<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for replacing a function<br>&gt; &gt;&gt; class Geometry {<br>&gt; &gt;&gt; func volume() -&gt;Double {<br>&gt; &gt;&gt; return 0;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Cube: Geometry {<br>&gt; &gt;&gt; var length: Double = 0.0<br>&gt; &gt;&gt; replace func volume() -&gt;Double {<br>&gt; &gt;&gt; let v = length * length * length<br>&gt; &gt;&gt; return v<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt; Florian<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/3b00df2c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>I disagree with the introduction of a method to specify if super must be call first or last. Defining that super must be call is fine, but I don’t see why the operation order should be enforced.<br></p><p>If the super class declares a method overridable but require that some code must be perform first, it can simply execute that code before calling the overridable method instead of putting it in the super class definition then force the subclass to call super first.<br></p><p>Moreover, I’m not fond of declaring that requirement in the overriding classes. That is the superclass that should define if a super implementation is required, not the children classes.<br></p><p><br>&gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt; <br>&gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; -1 for enforcing the super call place.<br>&gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt; <br>&gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt; <br>&gt; &gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; Hi<br>&gt; &gt;<br>&gt; &gt; I would like to suggest you to extend your proposal.<br>&gt; &gt;<br>&gt; &gt; In my practice, overriding super functions can have several semantics.<br>&gt; &gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; &gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; &gt; 3) Before super - opposite to 2.<br>&gt; &gt; 4) Override - no rules about order, but super call must be done.<br>&gt; &gt;<br>&gt; &gt; So code can look like:<br>&gt; &gt;<br>&gt; &gt; override(after) func viewDidLoad() {<br>&gt; &gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt; &gt;    // child code<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(before) func tearDown() {<br>&gt; &gt;    // clean code<br>&gt; &gt;    // super… inserted by compiler<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override(instead) func loadView() {<br>&gt; &gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; override func refillHealthBar() {<br>&gt; &gt;   // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt; &gt;<br>&gt; &gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Hi!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; &gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class View {<br>&gt; &gt;&gt; func viewDidLoad() {<br>&gt; &gt;&gt; // does something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; override func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt; &gt;&gt; // do something other<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for extending a function<br>&gt; &gt;&gt; class Button: View {<br>&gt; &gt;&gt; extend func viewDidLoad() {<br>&gt; &gt;&gt; super.viewDidLoad()<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extend func viewDidAppear() {<br>&gt; &gt;&gt; // do something<br>&gt; &gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; // Example for replacing a function<br>&gt; &gt;&gt; class Geometry {<br>&gt; &gt;&gt; func volume() -&gt;Double {<br>&gt; &gt;&gt; return 0;<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Cube: Geometry {<br>&gt; &gt;&gt; var length: Double = 0.0<br>&gt; &gt;&gt; replace func volume() -&gt;Double {<br>&gt; &gt;&gt; let v = length * length * length<br>&gt; &gt;&gt; return v<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt; Florian<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/368ce13c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 16, 2016 at 08:00:00am</p></header><div class="content"><p>Agreed - attempting to enforce the ordering is too fiddly and complicated, IMO. If the superclass must ensure a specific order, then it should do so itself by first calling a final function that then calls the overridable function at the right time.<br></p><p>Personally I’d like to see the syntax using the “required” keyword that already exists for constructors - so something more like this:<br></p><p>class Base {<br>  required(super) foo() {<br>	// etc<br>  }<br>}<br></p><p>This would then require any subclasses to call super.foo() if they override foo, but the subclass would not need to do anything new - just use the existing override syntax (with the complier ensuring super is called if it is required).<br></p><p>Then I’d like to see something like this:<br></p><p>class Base {<br>  required foo()<br>}<br></p><p>Which implicitly turns “Base” into an abstract base class that cannot be instantiated on its own, but requires a subclass supply a body for the required missing functions.<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Feb 16, 2016, at 8:43 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I disagree with the introduction of a method to specify if super must be call first or last. Defining that super must be call is fine, but I don’t see why the operation order should be enforced.<br>&gt; <br>&gt; If the super class declares a method overridable but require that some code must be perform first, it can simply execute that code before calling the overridable method instead of putting it in the super class definition then force the subclass to call super first.<br>&gt; <br>&gt; Moreover, I’m not fond of declaring that requirement in the overriding classes. That is the superclass that should define if a super implementation is required, not the children classes.<br>&gt; <br>&gt; <br>&gt;&gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt;&gt; <br>&gt;&gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt;&gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for enforcing the super call place.<br>&gt;&gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt;&gt; <br>&gt;&gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt;&gt; <br>&gt;&gt; &gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I would like to suggest you to extend your proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In my practice, overriding super functions can have several semantics.<br>&gt;&gt; &gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt;&gt; &gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt;&gt; &gt; 3) Before super - opposite to 2.<br>&gt;&gt; &gt; 4) Override - no rules about order, but super call must be done.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So code can look like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; override(after) func viewDidLoad() {<br>&gt;&gt; &gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;&gt; &gt;    // child code<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; override(before) func tearDown() {<br>&gt;&gt; &gt;    // clean code<br>&gt;&gt; &gt;    // super… inserted by compiler<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; override(instead) func loadView() {<br>&gt;&gt; &gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; override func refillHealthBar() {<br>&gt;&gt; &gt;   // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Hi!<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; &gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class View {<br>&gt;&gt; &gt;&gt; func viewDidLoad() {<br>&gt;&gt; &gt;&gt; // does something<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class Button: View {<br>&gt;&gt; &gt;&gt; override func viewDidLoad() {<br>&gt;&gt; &gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt;&gt; &gt;&gt; // do something other<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; // Example for extending a function<br>&gt;&gt; &gt;&gt; class Button: View {<br>&gt;&gt; &gt;&gt; extend func viewDidLoad() {<br>&gt;&gt; &gt;&gt; super.viewDidLoad()<br>&gt;&gt; &gt;&gt; // do something<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; extend func viewDidAppear() {<br>&gt;&gt; &gt;&gt; // do something<br>&gt;&gt; &gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; // Example for replacing a function<br>&gt;&gt; &gt;&gt; class Geometry {<br>&gt;&gt; &gt;&gt; func volume() -&gt;Double {<br>&gt;&gt; &gt;&gt; return 0;<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class Cube: Geometry {<br>&gt;&gt; &gt;&gt; var length: Double = 0.0<br>&gt;&gt; &gt;&gt; replace func volume() -&gt;Double {<br>&gt;&gt; &gt;&gt; let v = length * length * length<br>&gt;&gt; &gt;&gt; return v<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Cheers,<br>&gt;&gt; &gt;&gt; Florian<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February 16, 2016 at 08:00:00am</p></header><div class="content"><p>It occurs to me that “required(super)” is probably unnecessary - just use “required” on any function where an override must call super and leave it off on any function that doesn’t need to call super on an override. For any function that is illegal to override, we already have “final” for that. Additionally, if “required” exists on a function with no body implemented, then that turns the entire class into an abstract base class and subclasses must supply the body and *not* call super (since the base class obviously has no implementation itself).<br></p><p>I’m probably missing something somewhere, but that seems like it’d cover the important cases - all without adding any new keywords or even any new variations on existing keywords.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Feb 16, 2016, at 8:51 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Agreed - attempting to enforce the ordering is too fiddly and complicated, IMO. If the superclass must ensure a specific order, then it should do so itself by first calling a final function that then calls the overridable function at the right time.<br>&gt; <br>&gt; Personally I’d like to see the syntax using the “required” keyword that already exists for constructors - so something more like this:<br>&gt; <br>&gt; class Base {<br>&gt;  required(super) foo() {<br>&gt; 	// etc<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; This would then require any subclasses to call super.foo() if they override foo, but the subclass would not need to do anything new - just use the existing override syntax (with the complier ensuring super is called if it is required).<br>&gt; <br>&gt; Then I’d like to see something like this:<br>&gt; <br>&gt; class Base {<br>&gt;  required foo()<br>&gt; }<br>&gt; <br>&gt; Which implicitly turns “Base” into an abstract base class that cannot be instantiated on its own, but requires a subclass supply a body for the required missing functions.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 16, 2016, at 8:43 AM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I disagree with the introduction of a method to specify if super must be call first or last. Defining that super must be call is fine, but I don’t see why the operation order should be enforced.<br>&gt;&gt; <br>&gt;&gt; If the super class declares a method overridable but require that some code must be perform first, it can simply execute that code before calling the overridable method instead of putting it in the super class definition then force the subclass to call super first.<br>&gt;&gt; <br>&gt;&gt; Moreover, I’m not fond of declaring that requirement in the overriding classes. That is the superclass that should define if a super implementation is required, not the children classes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 16 févr. 2016 à 15:21, Ross O&#39;Brien via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jean-Daniel: can you clarify which aspect you&#39;re disagreeing with?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example: should standard library types prefer the &#39;override&#39; form which enforces calling super but doesn&#39;t enforce when it is called?<br>&gt;&gt;&gt; Perhaps &#39;override(before)&#39; should be an indication that, if the overriding method doesn&#39;t explicitly declare the super call, then it should be called implicitly at the start of the function?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Feb 16, 2016 at 2:12 PM, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 for enforcing the super call place.<br>&gt;&gt;&gt; While we usually call super at the beginning of viewDidLoad for instance, there is absolutely no need to enforce it and it may result in problem when some work have to be done before the super method is executed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have some use cases that rely on performing setup before calling the super.viewDidLoad().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 15 févr. 2016 à 23:06, Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to suggest you to extend your proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my practice, overriding super functions can have several semantics.<br>&gt;&gt;&gt;&gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt;&gt;&gt;&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt;&gt;&gt;&gt; 3) Before super - opposite to 2.<br>&gt;&gt;&gt;&gt; 4) Override - no rules about order, but super call must be done.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So code can look like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override(after) func viewDidLoad() {<br>&gt;&gt;&gt;&gt;   // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;&gt;&gt;&gt;   // child code<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override(before) func tearDown() {<br>&gt;&gt;&gt;&gt;   // clean code<br>&gt;&gt;&gt;&gt;   // super… inserted by compiler<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override(instead) func loadView() {<br>&gt;&gt;&gt;&gt;   // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; override func refillHealthBar() {<br>&gt;&gt;&gt;&gt;  // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But in general - what is your thoughts about this approach to problem that you mention?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt;&gt;&gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class View {<br>&gt;&gt;&gt;&gt;&gt; func viewDidLoad() {<br>&gt;&gt;&gt;&gt;&gt; // does something<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Button: View {<br>&gt;&gt;&gt;&gt;&gt; override func viewDidLoad() {<br>&gt;&gt;&gt;&gt;&gt; super.viewDidLoad() //&lt;— this might be forgotten<br>&gt;&gt;&gt;&gt;&gt; // do something other<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Example for extending a function<br>&gt;&gt;&gt;&gt;&gt; class Button: View {<br>&gt;&gt;&gt;&gt;&gt; extend func viewDidLoad() {<br>&gt;&gt;&gt;&gt;&gt; super.viewDidLoad()<br>&gt;&gt;&gt;&gt;&gt; // do something<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extend func viewDidAppear() {<br>&gt;&gt;&gt;&gt;&gt; // do something<br>&gt;&gt;&gt;&gt;&gt; } //&lt;— the compiler should throw an error here.<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // Example for replacing a function<br>&gt;&gt;&gt;&gt;&gt; class Geometry {<br>&gt;&gt;&gt;&gt;&gt; func volume() -&gt;Double {<br>&gt;&gt;&gt;&gt;&gt; return 0;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Cube: Geometry {<br>&gt;&gt;&gt;&gt;&gt; var length: Double = 0.0<br>&gt;&gt;&gt;&gt;&gt; replace func volume() -&gt;Double {<br>&gt;&gt;&gt;&gt;&gt; let v = length * length * length<br>&gt;&gt;&gt;&gt;&gt; return v<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt;&gt; Florian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 06:00:00pm</p></header><div class="content"><p>Not that I disagree with having a superclass overly dictate what a subclass<br>can do... it can quickly become a double edges sword however it can be<br>powerful for complex class designs especially if they focus on extension<br>via subclassing.<br></p><p>It should be noted it isn&#39;t always possible to leverage the super class<br>calling a final method as a point of enforcement. If the interface is<br>public then any code could call an overridden function without the ability<br>for the super class to enforce desired requirements. (yeah you could likely<br>achieve this by having the overridables have non-public access)<br></p><p>Anyway some more thinking out loud...<br></p><p>sub-class:<br></p><p>override -&gt; implies that the subclass intends to override a function of its<br>super class chain, if no such function is found up the chain at compile<br>time then a compiler error can be omitted to help catch missed function<br>signature changes that affect a sub-class (or fat fingering of a function<br>name), if absent and an override is taking place the compiler could also<br>flag unexpected override (e.g. function signature collision).<br></p><p>override with no qualifier is assumed to imply the overriding code should<br>at some point call up to the supers implementation, if that isn&#39;t found the<br>compiler should provide a fixup to either add the (instead) qualifier to<br>make it clear you want to replace the supers implementation or force you to<br>add a call to super<br></p><p>override(before) &amp; override(after) could exist to help catch errors and/or<br>generate code as needed (super call not needed in the overriding)<br></p><p>override func foo() {...}<br>override(instead|before|after) func bar() {...}<br></p><p>super-class:<br></p><p>require -&gt; implies some requirement for those subclassing the function<br></p><p>require(override) -&gt; implies that a subclass must override and that the<br>class stating this requirement should be considered abstract<br></p><p>require(super) -&gt; states that any override must call supers implementation<br>at some point in its body, override(instead) wouldn&#39;t be allowed, if the<br>requirement is not specified the subclass is free to call or not call the<br>supers implementation<br></p><p>require(superBefore) -&gt; states that it is expected that a subclass calls<br>super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t<br>honor this requirement the compiler will help to enforce it however a<br>subclass could state it is explicitly ignoring that requirement by say<br>something like override(ignoreBefore), override(instead) wouldn&#39;t be<br>allowed, consider this an escape hatch for subclasses,<br></p><p>require(superAfter) -&gt; same as above but after the override body<br></p><p>Note something like require(override, superXxx) is valid allowing for a<br>base class to provide some amount of implementation while still being<br>considered an abstract class.<br></p><p>final func baz() {...}<br>require(override) func foo() {}<br>require(override, super|superBefore|superAfter) func bar() {...}<br></p><p>Note I have not convinced myself of the true need for something like this<br>but I see being a potential benefit for class authors.<br></p><p>-Shawn<br></p><p><br>On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Agreed - attempting to enforce the ordering is too fiddly and complicated,<br>&gt; IMO. If the superclass must ensure a specific order, then it should do so<br>&gt; itself by first calling a final function that then calls the overridable<br>&gt; function at the right time.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/89b7a7fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>My vote is for a simple `require(override)` or `require(super)` on the<br>super-class. The user should be free to choose where to call super if<br>needed where she/he wants.<br></p><p>Other thing that I think is related is to declare a func abstract<br>(something like `require(override)` but without body implementation).<br></p><p><br>-Van<br></p><p>On Tue, Feb 16, 2016 at 4:12 PM, Shawn Erickson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Not that I disagree with having a superclass overly dictate what a<br>&gt; subclass can do... it can quickly become a double edges sword however it<br>&gt; can be powerful for complex class designs especially if they focus on<br>&gt; extension via subclassing.<br>&gt;<br>&gt; It should be noted it isn&#39;t always possible to leverage the super class<br>&gt; calling a final method as a point of enforcement. If the interface is<br>&gt; public then any code could call an overridden function without the ability<br>&gt; for the super class to enforce desired requirements. (yeah you could likely<br>&gt; achieve this by having the overridables have non-public access)<br>&gt;<br>&gt; Anyway some more thinking out loud...<br>&gt;<br>&gt; sub-class:<br>&gt;<br>&gt; override -&gt; implies that the subclass intends to override a function of<br>&gt; its super class chain, if no such function is found up the chain at compile<br>&gt; time then a compiler error can be omitted to help catch missed function<br>&gt; signature changes that affect a sub-class (or fat fingering of a function<br>&gt; name), if absent and an override is taking place the compiler could also<br>&gt; flag unexpected override (e.g. function signature collision).<br>&gt;<br>&gt; override with no qualifier is assumed to imply the overriding code should<br>&gt; at some point call up to the supers implementation, if that isn&#39;t found the<br>&gt; compiler should provide a fixup to either add the (instead) qualifier to<br>&gt; make it clear you want to replace the supers implementation or force you to<br>&gt; add a call to super<br>&gt;<br>&gt; override(before) &amp; override(after) could exist to help catch errors and/or<br>&gt; generate code as needed (super call not needed in the overriding)<br>&gt;<br>&gt; override func foo() {...}<br>&gt; override(instead|before|after) func bar() {...}<br>&gt;<br>&gt; super-class:<br>&gt;<br>&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt;<br>&gt; require(override) -&gt; implies that a subclass must override and that the<br>&gt; class stating this requirement should be considered abstract<br>&gt;<br>&gt; require(super) -&gt; states that any override must call supers implementation<br>&gt; at some point in its body, override(instead) wouldn&#39;t be allowed, if the<br>&gt; requirement is not specified the subclass is free to call or not call the<br>&gt; supers implementation<br>&gt;<br>&gt; require(superBefore) -&gt; states that it is expected that a subclass calls<br>&gt; super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t<br>&gt; honor this requirement the compiler will help to enforce it however a<br>&gt; subclass could state it is explicitly ignoring that requirement by say<br>&gt; something like override(ignoreBefore), override(instead) wouldn&#39;t be<br>&gt; allowed, consider this an escape hatch for subclasses,<br>&gt;<br>&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt;<br>&gt; Note something like require(override, superXxx) is valid allowing for a<br>&gt; base class to provide some amount of implementation while still being<br>&gt; considered an abstract class.<br>&gt;<br>&gt; final func baz() {...}<br>&gt; require(override) func foo() {}<br>&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt;<br>&gt; Note I have not convinced myself of the true need for something like this<br>&gt; but I see being a potential benefit for class authors.<br>&gt;<br>&gt; -Shawn<br>&gt;<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Agreed - attempting to enforce the ordering is too fiddly and<br>&gt;&gt; complicated, IMO. If the superclass must ensure a specific order, then it<br>&gt;&gt; should do so itself by first calling a final function that then calls the<br>&gt;&gt; overridable function at the right time.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/5169f663/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>There are some cases where a predefined place to call super is very useful<br>and can be automated. One such example is dealloc in ObjC or deinit in<br>Swift. And the compiler already does this automatically. The proposal would<br>make this more generic. I expect that if it&#39;s implemented, the place to<br>call super will not be specified most of the time. But occasionally, it<br>might be very useful and reduce human error.<br>On Tue, Feb 16, 2016 at 2:24 PM Vanderlei Martinelli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My vote is for a simple `require(override)` or `require(super)` on the<br>&gt; super-class. The user should be free to choose where to call super if<br>&gt; needed where she/he wants.<br>&gt;<br>&gt; Other thing that I think is related is to declare a func abstract<br>&gt; (something like `require(override)` but without body implementation).<br>&gt;<br>&gt;<br>&gt; -Van<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 4:12 PM, Shawn Erickson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Not that I disagree with having a superclass overly dictate what a<br>&gt;&gt; subclass can do... it can quickly become a double edges sword however it<br>&gt;&gt; can be powerful for complex class designs especially if they focus on<br>&gt;&gt; extension via subclassing.<br>&gt;&gt;<br>&gt;&gt; It should be noted it isn&#39;t always possible to leverage the super class<br>&gt;&gt; calling a final method as a point of enforcement. If the interface is<br>&gt;&gt; public then any code could call an overridden function without the ability<br>&gt;&gt; for the super class to enforce desired requirements. (yeah you could likely<br>&gt;&gt; achieve this by having the overridables have non-public access)<br>&gt;&gt;<br>&gt;&gt; Anyway some more thinking out loud...<br>&gt;&gt;<br>&gt;&gt; sub-class:<br>&gt;&gt;<br>&gt;&gt; override -&gt; implies that the subclass intends to override a function of<br>&gt;&gt; its super class chain, if no such function is found up the chain at compile<br>&gt;&gt; time then a compiler error can be omitted to help catch missed function<br>&gt;&gt; signature changes that affect a sub-class (or fat fingering of a function<br>&gt;&gt; name), if absent and an override is taking place the compiler could also<br>&gt;&gt; flag unexpected override (e.g. function signature collision).<br>&gt;&gt;<br>&gt;&gt; override with no qualifier is assumed to imply the overriding code should<br>&gt;&gt; at some point call up to the supers implementation, if that isn&#39;t found the<br>&gt;&gt; compiler should provide a fixup to either add the (instead) qualifier to<br>&gt;&gt; make it clear you want to replace the supers implementation or force you to<br>&gt;&gt; add a call to super<br>&gt;&gt;<br>&gt;&gt; override(before) &amp; override(after) could exist to help catch errors<br>&gt;&gt; and/or generate code as needed (super call not needed in the overriding)<br>&gt;&gt;<br>&gt;&gt; override func foo() {...}<br>&gt;&gt; override(instead|before|after) func bar() {...}<br>&gt;&gt;<br>&gt;&gt; super-class:<br>&gt;&gt;<br>&gt;&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt;&gt;<br>&gt;&gt; require(override) -&gt; implies that a subclass must override and that the<br>&gt;&gt; class stating this requirement should be considered abstract<br>&gt;&gt;<br>&gt;&gt; require(super) -&gt; states that any override must call supers<br>&gt;&gt; implementation at some point in its body, override(instead) wouldn&#39;t be<br>&gt;&gt; allowed, if the requirement is not specified the subclass is free to call<br>&gt;&gt; or not call the supers implementation<br>&gt;&gt;<br>&gt;&gt; require(superBefore) -&gt; states that it is expected that a subclass calls<br>&gt;&gt; super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t<br>&gt;&gt; honor this requirement the compiler will help to enforce it however a<br>&gt;&gt; subclass could state it is explicitly ignoring that requirement by say<br>&gt;&gt; something like override(ignoreBefore), override(instead) wouldn&#39;t be<br>&gt;&gt; allowed, consider this an escape hatch for subclasses,<br>&gt;&gt;<br>&gt;&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt;&gt;<br>&gt;&gt; Note something like require(override, superXxx) is valid allowing for a<br>&gt;&gt; base class to provide some amount of implementation while still being<br>&gt;&gt; considered an abstract class.<br>&gt;&gt;<br>&gt;&gt; final func baz() {...}<br>&gt;&gt; require(override) func foo() {}<br>&gt;&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt;&gt;<br>&gt;&gt; Note I have not convinced myself of the true need for something like this<br>&gt;&gt; but I see being a potential benefit for class authors.<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Agreed - attempting to enforce the ordering is too fiddly and<br>&gt;&gt;&gt; complicated, IMO. If the superclass must ensure a specific order, then it<br>&gt;&gt;&gt; should do so itself by first calling a final function that then calls the<br>&gt;&gt;&gt; overridable function at the right time.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/d8d496c4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 07:00:00pm</p></header><div class="content"><p>The addition of before and after are just icing on the cake as they say (I<br>see benefit but am not sure about them being worth it). I agree the core<br>benefit would come from being able to state &quot;require override&quot; as a base<br>class with or without providing an implementation. The only hole I see in<br>that is how to help subclassers detected missed calls to super (subclass<br>override(instead) helps deal with that well enough). I could see require<br>(override) and require (override,super) as base class if the author<br>strongly feels a subclass needs to involve the supers implementation... of<br>course then you get back to the edge case of before and after.<br></p><p>So at it core I support...<br></p><p>For base classes require(override) with or without an implementation,<br>without implies abstract, with implies a subclass should likely call the<br>base implementation in its override<br></p><p>For subclasses override to detect override attempts or on omission flag<br>unexpected overrides, override(instead) to state it is ok that supers<br>implementation isn&#39;t called in the override (assumed to be desired unless<br>instead is stated).<br></p><p><br>On Tue, Feb 16, 2016 at 11:24 AM Vanderlei Martinelli &lt;<br>vmartinelli at alecrim.com&gt; wrote:<br></p><p>&gt; My vote is for a simple `require(override)` or `require(super)` on the<br>&gt; super-class. The user should be free to choose where to call super if<br>&gt; needed where she/he wants.<br>&gt;<br>&gt; Other thing that I think is related is to declare a func abstract<br>&gt; (something like `require(override)` but without body implementation).<br>&gt;<br>&gt;<br>&gt; -Van<br>&gt;<br>&gt; On Tue, Feb 16, 2016 at 4:12 PM, Shawn Erickson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Not that I disagree with having a superclass overly dictate what a<br>&gt;&gt; subclass can do... it can quickly become a double edges sword however it<br>&gt;&gt; can be powerful for complex class designs especially if they focus on<br>&gt;&gt; extension via subclassing.<br>&gt;&gt;<br>&gt;&gt; It should be noted it isn&#39;t always possible to leverage the super class<br>&gt;&gt; calling a final method as a point of enforcement. If the interface is<br>&gt;&gt; public then any code could call an overridden function without the ability<br>&gt;&gt; for the super class to enforce desired requirements. (yeah you could likely<br>&gt;&gt; achieve this by having the overridables have non-public access)<br>&gt;&gt;<br>&gt;&gt; Anyway some more thinking out loud...<br>&gt;&gt;<br>&gt;&gt; sub-class:<br>&gt;&gt;<br>&gt;&gt; override -&gt; implies that the subclass intends to override a function of<br>&gt;&gt; its super class chain, if no such function is found up the chain at compile<br>&gt;&gt; time then a compiler error can be omitted to help catch missed function<br>&gt;&gt; signature changes that affect a sub-class (or fat fingering of a function<br>&gt;&gt; name), if absent and an override is taking place the compiler could also<br>&gt;&gt; flag unexpected override (e.g. function signature collision).<br>&gt;&gt;<br>&gt;&gt; override with no qualifier is assumed to imply the overriding code should<br>&gt;&gt; at some point call up to the supers implementation, if that isn&#39;t found the<br>&gt;&gt; compiler should provide a fixup to either add the (instead) qualifier to<br>&gt;&gt; make it clear you want to replace the supers implementation or force you to<br>&gt;&gt; add a call to super<br>&gt;&gt;<br>&gt;&gt; override(before) &amp; override(after) could exist to help catch errors<br>&gt;&gt; and/or generate code as needed (super call not needed in the overriding)<br>&gt;&gt;<br>&gt;&gt; override func foo() {...}<br>&gt;&gt; override(instead|before|after) func bar() {...}<br>&gt;&gt;<br>&gt;&gt; super-class:<br>&gt;&gt;<br>&gt;&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt;&gt;<br>&gt;&gt; require(override) -&gt; implies that a subclass must override and that the<br>&gt;&gt; class stating this requirement should be considered abstract<br>&gt;&gt;<br>&gt;&gt; require(super) -&gt; states that any override must call supers<br>&gt;&gt; implementation at some point in its body, override(instead) wouldn&#39;t be<br>&gt;&gt; allowed, if the requirement is not specified the subclass is free to call<br>&gt;&gt; or not call the supers implementation<br>&gt;&gt;<br>&gt;&gt; require(superBefore) -&gt; states that it is expected that a subclass calls<br>&gt;&gt; super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t<br>&gt;&gt; honor this requirement the compiler will help to enforce it however a<br>&gt;&gt; subclass could state it is explicitly ignoring that requirement by say<br>&gt;&gt; something like override(ignoreBefore), override(instead) wouldn&#39;t be<br>&gt;&gt; allowed, consider this an escape hatch for subclasses,<br>&gt;&gt;<br>&gt;&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt;&gt;<br>&gt;&gt; Note something like require(override, superXxx) is valid allowing for a<br>&gt;&gt; base class to provide some amount of implementation while still being<br>&gt;&gt; considered an abstract class.<br>&gt;&gt;<br>&gt;&gt; final func baz() {...}<br>&gt;&gt; require(override) func foo() {}<br>&gt;&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt;&gt;<br>&gt;&gt; Note I have not convinced myself of the true need for something like this<br>&gt;&gt; but I see being a potential benefit for class authors.<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Agreed - attempting to enforce the ordering is too fiddly and<br>&gt;&gt;&gt; complicated, IMO. If the superclass must ensure a specific order, then it<br>&gt;&gt;&gt; should do so itself by first calling a final function that then calls the<br>&gt;&gt;&gt; overridable function at the right time.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/a38044b4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 16, 2016 at 08:00:00pm</p></header><div class="content"><p>I think it should be possible to enforce a convention. Sub classing does come with limitations in order to work well and if you are subclassing something you have no code access to you are relying only on documentation to give you hints on what to do. I think we should give the author the ability to make it explicit in this case.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 16 Feb 2016, at 19:24, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My vote is for a simple `require(override)` or `require(super)` on the super-class. The user should be free to choose where to call super if needed where she/he wants.<br>&gt; <br>&gt; Other thing that I think is related is to declare a func abstract (something like `require(override)` but without body implementation).<br>&gt; <br>&gt; <br>&gt; -Van<br>&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 4:12 PM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Not that I disagree with having a superclass overly dictate what a subclass can do... it can quickly become a double edges sword however it can be powerful for complex class designs especially if they focus on extension via subclassing.<br>&gt;&gt; <br>&gt;&gt; It should be noted it isn&#39;t always possible to leverage the super class calling a final method as a point of enforcement. If the interface is public then any code could call an overridden function without the ability for the super class to enforce desired requirements. (yeah you could likely achieve this by having the overridables have non-public access)<br>&gt;&gt; <br>&gt;&gt; Anyway some more thinking out loud...<br>&gt;&gt; <br>&gt;&gt; sub-class:<br>&gt;&gt; <br>&gt;&gt; override -&gt; implies that the subclass intends to override a function of its super class chain, if no such function is found up the chain at compile time then a compiler error can be omitted to help catch missed function signature changes that affect a sub-class (or fat fingering of a function name), if absent and an override is taking place the compiler could also flag unexpected override (e.g. function signature collision).<br>&gt;&gt; <br>&gt;&gt; override with no qualifier is assumed to imply the overriding code should at some point call up to the supers implementation, if that isn&#39;t found the compiler should provide a fixup to either add the (instead) qualifier to make it clear you want to replace the supers implementation or force you to add a call to super<br>&gt;&gt; <br>&gt;&gt; override(before) &amp; override(after) could exist to help catch errors and/or generate code as needed (super call not needed in the overriding)<br>&gt;&gt; <br>&gt;&gt; override func foo() {...}<br>&gt;&gt; override(instead|before|after) func bar() {...} <br>&gt;&gt; <br>&gt;&gt; super-class:<br>&gt;&gt; <br>&gt;&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt;&gt; <br>&gt;&gt; require(override) -&gt; implies that a subclass must override and that the class stating this requirement should be considered abstract<br>&gt;&gt; <br>&gt;&gt; require(super) -&gt; states that any override must call supers implementation at some point in its body, override(instead) wouldn&#39;t be allowed, if the requirement is not specified the subclass is free to call or not call the supers implementation<br>&gt;&gt; <br>&gt;&gt; require(superBefore) -&gt; states that it is expected that a subclass calls super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t honor this requirement the compiler will help to enforce it however a subclass could state it is explicitly ignoring that requirement by say something like override(ignoreBefore), override(instead) wouldn&#39;t be allowed, consider this an escape hatch for subclasses,<br>&gt;&gt; <br>&gt;&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt;&gt; <br>&gt;&gt; Note something like require(override, superXxx) is valid allowing for a base class to provide some amount of implementation while still being considered an abstract class.<br>&gt;&gt; <br>&gt;&gt; final func baz() {...}<br>&gt;&gt; require(override) func foo() {}<br>&gt;&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt;&gt; <br>&gt;&gt; Note I have not convinced myself of the true need for something like this but I see being a potential benefit for class authors.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Agreed - attempting to enforce the ordering is too fiddly and complicated, IMO. If the superclass must ensure a specific order, then it should do so itself by first calling a final function that then calls the overridable function at the right time.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/7608fd2b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/671aaf492518a334ad3b9243cf2b1328?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Florian Liefers</string> &lt;florian at liefers.com&gt;<p>February 16, 2016 at 09:00:00pm</p></header><div class="content"><p>For me this solution sounds exactly for what i was looking for. I don’t know if the superclass should be able to dictate when the supers implementation has to be called but it should be able to dictate, that supers implementation must be called. So currently this is my preferred solution:<br></p><p>For subcasses:<br>override func foo() {} // super must be called somewhere inside the body<br>override(before) func foo() {} // semantic hint, super must not be called inside the body, the compiler generates the code before the body<br>override(after) func foo() {} // semantic hint, super must not be called inside the body, the compiler generates the code after the body<br>override(instead) func foo() {} // replaces supers implementation, super must not be called inside the body<br></p><p>For superclasses:<br>func foo() {} // subclass can override and may or may not call supers implementation<br>require(override) func foo() // subclass must override and must not call supers implementation (which doesn’t exist)<br>require(override) func foo() {} // subclass must override and may or may not call supers implementation<br>require(override, super) // subclass must override and must call supers implementation<br></p><p>Cheers, Florian<br></p><p>&gt; Am 16.02.2016 um 19:12 schrieb Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Not that I disagree with having a superclass overly dictate what a subclass can do... it can quickly become a double edges sword however it can be powerful for complex class designs especially if they focus on extension via subclassing.<br>&gt; <br>&gt; It should be noted it isn&#39;t always possible to leverage the super class calling a final method as a point of enforcement. If the interface is public then any code could call an overridden function without the ability for the super class to enforce desired requirements. (yeah you could likely achieve this by having the overridables have non-public access)<br>&gt; <br>&gt; Anyway some more thinking out loud...<br>&gt; <br>&gt; sub-class:<br>&gt; <br>&gt; override -&gt; implies that the subclass intends to override a function of its super class chain, if no such function is found up the chain at compile time then a compiler error can be omitted to help catch missed function signature changes that affect a sub-class (or fat fingering of a function name), if absent and an override is taking place the compiler could also flag unexpected override (e.g. function signature collision).<br>&gt; <br>&gt; override with no qualifier is assumed to imply the overriding code should at some point call up to the supers implementation, if that isn&#39;t found the compiler should provide a fixup to either add the (instead) qualifier to make it clear you want to replace the supers implementation or force you to add a call to super<br>&gt; <br>&gt; override(before) &amp; override(after) could exist to help catch errors and/or generate code as needed (super call not needed in the overriding)<br>&gt; <br>&gt; override func foo() {...}<br>&gt; override(instead|before|after) func bar() {...} <br>&gt; <br>&gt; super-class:<br>&gt; <br>&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt; <br>&gt; require(override) -&gt; implies that a subclass must override and that the class stating this requirement should be considered abstract<br>&gt; <br>&gt; require(super) -&gt; states that any override must call supers implementation at some point in its body, override(instead) wouldn&#39;t be allowed, if the requirement is not specified the subclass is free to call or not call the supers implementation<br>&gt; <br>&gt; require(superBefore) -&gt; states that it is expected that a subclass calls super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t honor this requirement the compiler will help to enforce it however a subclass could state it is explicitly ignoring that requirement by say something like override(ignoreBefore), override(instead) wouldn&#39;t be allowed, consider this an escape hatch for subclasses,<br>&gt; <br>&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt; <br>&gt; Note something like require(override, superXxx) is valid allowing for a base class to provide some amount of implementation while still being considered an abstract class.<br>&gt; <br>&gt; final func baz() {...}<br>&gt; require(override) func foo() {}<br>&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt; <br>&gt; Note I have not convinced myself of the true need for something like this but I see being a potential benefit for class authors.<br>&gt; <br>&gt; -Shawn<br>&gt; <br>&gt; <br>&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Agreed - attempting to enforce the ordering is too fiddly and complicated, IMO. If the superclass must ensure a specific order, then it should do so itself by first calling a final function that then calls the overridable function at the right time.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/671aaf492518a334ad3b9243cf2b1328?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Florian Liefers</string> &lt;florian at liefers.com&gt;<p>February 16, 2016 at 09:00:00pm</p></header><div class="content"><p>One thing i forgot is<br>For superclasses:<br>require(super) func foo() {} // subclass may override but if it must call supers implementation.<br></p><p>Another thing i’m wondering is, how it would look like if a subclass overrides supers function and defines it’s own function to be required to be called from subclasses?<br></p><p>require(super) override(before) func foo() {}<br></p><p>Florian<br></p><p>&gt; Am 16.02.2016 um 21:39 schrieb Florian Liefers via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; For me this solution sounds exactly for what i was looking for. I don’t know if the superclass should be able to dictate when the supers implementation has to be called but it should be able to dictate, that supers implementation must be called. So currently this is my preferred solution:<br>&gt; <br>&gt; For subcasses:<br>&gt; override func foo() {} // super must be called somewhere inside the body<br>&gt; override(before) func foo() {} // semantic hint, super must not be called inside the body, the compiler generates the code before the body<br>&gt; override(after) func foo() {} // semantic hint, super must not be called inside the body, the compiler generates the code after the body<br>&gt; override(instead) func foo() {} // replaces supers implementation, super must not be called inside the body<br>&gt; <br>&gt; For superclasses:<br>&gt; func foo() {} // subclass can override and may or may not call supers implementation<br>&gt; require(override) func foo() // subclass must override and must not call supers implementation (which doesn’t exist)<br>&gt; require(override) func foo() {} // subclass must override and may or may not call supers implementation<br>&gt; require(override, super) // subclass must override and must call supers implementation<br>&gt; <br>&gt; Cheers, Florian<br>&gt; <br>&gt;&gt; Am 16.02.2016 um 19:12 schrieb Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Not that I disagree with having a superclass overly dictate what a subclass can do... it can quickly become a double edges sword however it can be powerful for complex class designs especially if they focus on extension via subclassing.<br>&gt;&gt; <br>&gt;&gt; It should be noted it isn&#39;t always possible to leverage the super class calling a final method as a point of enforcement. If the interface is public then any code could call an overridden function without the ability for the super class to enforce desired requirements. (yeah you could likely achieve this by having the overridables have non-public access)<br>&gt;&gt; <br>&gt;&gt; Anyway some more thinking out loud...<br>&gt;&gt; <br>&gt;&gt; sub-class:<br>&gt;&gt; <br>&gt;&gt; override -&gt; implies that the subclass intends to override a function of its super class chain, if no such function is found up the chain at compile time then a compiler error can be omitted to help catch missed function signature changes that affect a sub-class (or fat fingering of a function name), if absent and an override is taking place the compiler could also flag unexpected override (e.g. function signature collision).<br>&gt;&gt; <br>&gt;&gt; override with no qualifier is assumed to imply the overriding code should at some point call up to the supers implementation, if that isn&#39;t found the compiler should provide a fixup to either add the (instead) qualifier to make it clear you want to replace the supers implementation or force you to add a call to super<br>&gt;&gt; <br>&gt;&gt; override(before) &amp; override(after) could exist to help catch errors and/or generate code as needed (super call not needed in the overriding)<br>&gt;&gt; <br>&gt;&gt; override func foo() {...}<br>&gt;&gt; override(instead|before|after) func bar() {...} <br>&gt;&gt; <br>&gt;&gt; super-class:<br>&gt;&gt; <br>&gt;&gt; require -&gt; implies some requirement for those subclassing the function<br>&gt;&gt; <br>&gt;&gt; require(override) -&gt; implies that a subclass must override and that the class stating this requirement should be considered abstract<br>&gt;&gt; <br>&gt;&gt; require(super) -&gt; states that any override must call supers implementation at some point in its body, override(instead) wouldn&#39;t be allowed, if the requirement is not specified the subclass is free to call or not call the supers implementation<br>&gt;&gt; <br>&gt;&gt; require(superBefore) -&gt; states that it is expected that a subclass calls super before doing things in its override, if the subclass doesn&#39;t doesn&#39;t honor this requirement the compiler will help to enforce it however a subclass could state it is explicitly ignoring that requirement by say something like override(ignoreBefore), override(instead) wouldn&#39;t be allowed, consider this an escape hatch for subclasses,<br>&gt;&gt; <br>&gt;&gt; require(superAfter) -&gt; same as above but after the override body<br>&gt;&gt; <br>&gt;&gt; Note something like require(override, superXxx) is valid allowing for a base class to provide some amount of implementation while still being considered an abstract class.<br>&gt;&gt; <br>&gt;&gt; final func baz() {...}<br>&gt;&gt; require(override) func foo() {}<br>&gt;&gt; require(override, super|superBefore|superAfter) func bar() {...}<br>&gt;&gt; <br>&gt;&gt; Note I have not convinced myself of the true need for something like this but I see being a potential benefit for class authors.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 16, 2016 at 6:51 AM Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Agreed - attempting to enforce the ordering is too fiddly and complicated, IMO. If the superclass must ensure a specific order, then it should do so itself by first calling a final function that then calls the overridable function at the right time.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
