<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I was playing around with the idea of swift and Windows since there are<br>some interesting differences between COFF/PE and (ELF and MachO).<br></p><p>PE/COFF does not directly address symbols in external modules<br>(DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>(provided to external modules), or &quot;default&quot; (everything else).<br></p><p>Adjusting the IRGen to correctly annotate this part of the semantics should<br>get us part of the way to supporting swift on PE/COFF.<br></p><p>The thing to consider with this is that the DLL storage class is dependent<br>on how the module(s) are being built.  For example, something may change<br>from the exported storage to default if being built into a static library<br>rather than a shared object and is not meant to be re-exported.<br></p><p>Part of this information really needs to be threaded from the build system<br>so that we know whether a given SIL module is external or internal.<br></p><p>Given that this would potentially effect ABI stability, it seems like this<br>is a good time to tackle it so that we can push this into the resilience<br>work that is being done for swift 3.<br></p><p>I would appreciate any pointers and suggestions as to how to best go about<br>handling this.<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160406/f01d0356/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>Hey, Saleem. How do you expect this to differ from normal symbol visibility? It seems to me that in a shared library, any public symbol is either exported or imported, depending on whether it has a definition, and any non-public symbol is default. (Unlike C, we expect to have sensible rules here.) I guess there&#39;s the difference between &quot;a public symbol from elsewhere in this library&quot; and &quot;a public symbol from some other library&quot;. Is that it?<br></p><p>The difference between static and shared libraries seems unfortunate to have to expose to IRGen, but we may end up needing that anyway to handle Mach-O/ELF-style symbol visibility.<br></p><p>Jordan<br></p><p><br>&gt; On Apr 6, 2016, at 10:21, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I was playing around with the idea of swift and Windows since there are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; <br>&gt; PE/COFF does not directly address symbols in external modules (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks in Windows parlance).  Fortunately, LLVM has a nice way to model this: GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether something is &quot;imported&quot; (provided by an external module), &quot;exported&quot; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; <br>&gt; Adjusting the IRGen to correctly annotate this part of the semantics should get us part of the way to supporting swift on PE/COFF.<br>&gt; <br>&gt; The thing to consider with this is that the DLL storage class is dependent on how the module(s) are being built.  For example, something may change from the exported storage to default if being built into a static library rather than a shared object and is not meant to be re-exported.<br>&gt; <br>&gt; Part of this information really needs to be threaded from the build system so that we know whether a given SIL module is external or internal.<br>&gt; <br>&gt; Given that this would potentially effect ABI stability, it seems like this is a good time to tackle it so that we can push this into the resilience work that is being done for swift 3.<br>&gt; <br>&gt; I would appreciate any pointers and suggestions as to how to best go about handling this.<br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 11:18 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Hey, Saleem. How do you expect this to differ from normal symbol<br>&gt; visibility? It seems to me that in a shared library, any public symbol is<br>&gt; either exported or imported, depending on whether it has a definition, and<br>&gt; any non-public symbol is default. (Unlike C, we expect to have sensible<br>&gt; rules here.) I guess there&#39;s the difference between &quot;a public symbol from<br>&gt; elsewhere in this library&quot; and &quot;a public symbol from some other library&quot;.<br>&gt; Is that it?<br>&gt;<br></p><p>Well, there are four cases to consider:<br>- externally available: imported<br>- defined (and available for others): exported<br>- defined (statically): default -- won&#39;t even show up, so this is a no-op<br>- defined (non-statically defined for internal use): default<br></p><p>The thing is that there is no modeling for internal symbols which other<br>shared objects can use.  The closest thing you can do is anonymize the<br>symbol (so you don&#39;t have a name that you can call it by, but you have an<br>integral ID).<br></p><p>A public symbol from elsewhere in this library is treated as a local symbol<br>defined elsewhere in this library.  However, a public symbol from another<br>library is treated differently.  These get a local symbol which is<br>synthesized to perform the indirect addressing.  The symbol uses the form<br>__USER_LABEL_PREFIX__ ## _imp_ ## name.  This will contain the real address<br>or an indirect jump for the public symbol.<br></p><p>The difference between static and shared libraries seems unfortunate to<br>&gt; have to expose to IRGen, but we may end up needing that anyway to handle<br>&gt; Mach-O/ELF-style symbol visibility.<br>&gt;<br></p><p>Yes, it is unfortunate, but sounds like it could end up being beneficial.<br></p><p><br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; &gt; On Apr 6, 2016, at 10:21, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I was playing around with the idea of swift and Windows since there are<br>&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; &gt;<br>&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; &gt;<br>&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt; &gt;<br>&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt; change from the exported storage to default if being built into a static<br>&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt; &gt;<br>&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt; system so that we know whether a given SIL module is external or internal.<br>&gt; &gt;<br>&gt; &gt; Given that this would potentially effect ABI stability, it seems like<br>&gt; this is a good time to tackle it so that we can push this into the<br>&gt; resilience work that is being done for swift 3.<br>&gt; &gt;<br>&gt; &gt; I would appreciate any pointers and suggestions as to how to best go<br>&gt; about handling this.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Saleem Abdulrasool<br>&gt; &gt; compnerd (at) compnerd (dot) org<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160406/9221cafa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:31, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Apr 6, 2016 at 11:18 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; Hey, Saleem. How do you expect this to differ from normal symbol visibility? It seems to me that in a shared library, any public symbol is either exported or imported, depending on whether it has a definition, and any non-public symbol is default. (Unlike C, we expect to have sensible rules here.) I guess there&#39;s the difference between &quot;a public symbol from elsewhere in this library&quot; and &quot;a public symbol from some other library&quot;. Is that it?<br>&gt; <br>&gt; Well, there are four cases to consider:<br>&gt; - externally available: imported<br>&gt; - defined (and available for others): exported<br>&gt; - defined (statically): default -- won&#39;t even show up, so this is a no-op<br>&gt; - defined (non-statically defined for internal use): default<br>&gt; <br>&gt; The thing is that there is no modeling for internal symbols which other shared objects can use.  The closest thing you can do is anonymize the symbol (so you don&#39;t have a name that you can call it by, but you have an integral ID).<br></p><p>What is an &quot;internal symbol which other shared objects can use&quot;? That sounds like a self-contradiction.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160406/77a99c80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 11:34 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 6, 2016, at 11:31, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Wed, Apr 6, 2016 at 11:18 AM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hey, Saleem. How do you expect this to differ from normal symbol<br>&gt;&gt; visibility? It seems to me that in a shared library, any public symbol is<br>&gt;&gt; either exported or imported, depending on whether it has a definition, and<br>&gt;&gt; any non-public symbol is default. (Unlike C, we expect to have sensible<br>&gt;&gt; rules here.) I guess there&#39;s the difference between &quot;a public symbol from<br>&gt;&gt; elsewhere in this library&quot; and &quot;a public symbol from some other library&quot;.<br>&gt;&gt; Is that it?<br>&gt;&gt;<br>&gt;<br>&gt; Well, there are four cases to consider:<br>&gt; - externally available: imported<br>&gt; - defined (and available for others): exported<br>&gt; - defined (statically): default -- won&#39;t even show up, so this is a no-op<br>&gt; - defined (non-statically defined for internal use): default<br>&gt;<br>&gt; The thing is that there is no modeling for internal symbols which other<br>&gt; shared objects can use.  The closest thing you can do is anonymize the<br>&gt; symbol (so you don&#39;t have a name that you can call it by, but you have an<br>&gt; integral ID).<br>&gt;<br>&gt;<br>&gt; What is an &quot;internal symbol which other shared objects can use&quot;? That<br>&gt; sounds like a self-contradiction.<br>&gt;<br></p><p>This is used for things like providing private hooks across shared<br>objects.  These would usually be anonymized (nameless), but you get an<br>integral ID that gives you an index into a table of pointers to the<br>function or variable that you are interested in.<br></p><p><br>&gt; Jordan<br>&gt;<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160406/46633fe9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:18 AM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, Saleem. How do you expect this to differ from normal symbol visibility? It seems to me that in a shared library, any public symbol is either exported or imported, depending on whether it has a definition, and any non-public symbol is default. (Unlike C, we expect to have sensible rules here.) I guess there&#39;s the difference between &quot;a public symbol from elsewhere in this library&quot; and &quot;a public symbol from some other library&quot;. Is that it?<br></p><p>In concept, it&#39;s more-or-less the same as symbol visibility.  My understanding is that the PE/COFF model is simply a little less forgiving about getting it wrong.<br></p><p>As you say, this is something we want to be getting right anyway because it allows IRGen to use more efficient code patterns.<br></p><p>John.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 10:21 AM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I was playing around with the idea of swift and Windows since there are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; <br>&gt; PE/COFF does not directly address symbols in external modules (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks in Windows parlance).  Fortunately, LLVM has a nice way to model this: GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether something is &quot;imported&quot; (provided by an external module), &quot;exported&quot; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; <br>&gt; Adjusting the IRGen to correctly annotate this part of the semantics should get us part of the way to supporting swift on PE/COFF.<br>&gt; <br>&gt; The thing to consider with this is that the DLL storage class is dependent on how the module(s) are being built.  For example, something may change from the exported storage to default if being built into a static library rather than a shared object and is not meant to be re-exported.<br>&gt; <br>&gt; Part of this information really needs to be threaded from the build system so that we know whether a given SIL module is external or internal.<br>&gt; <br>&gt; Given that this would potentially effect ABI stability, it seems like this is a good time to tackle it so that we can push this into the resilience work that is being done for swift 3.<br>&gt; <br>&gt; I would appreciate any pointers and suggestions as to how to best go about handling this.<br></p><p>As Jordan noted, we probably want to thread this information through for ELF and Mach-O builds too, for a couple of reasons. One, if you&#39;re building a static library as opposed to a .so or .dylib, it&#39;s not desirable to reexport that static library&#39;s API by default through any executables or dynamic libraries that use it. We currently get this wrong; if the compiler knew it was building for a static library, it could give public symbols in the .a &#39;hidden&#39; visibility so that they do the right thing when linked into dylibs. Second, ELF&#39;s default visibility is problematic for Swift, since it allows default-visibility symbols to be interposed at load time by other dynamic libraries. This imposes a performance penalty on shared libraries accessing their own data, interferes with some of the load-time optimizations we do with metadata that assume we can hardcode relative references within a linkage unit, and is flat-out dangerous in the face of interprocedural optimization. For these reasons, we export symbols with &quot;protected&quot; visibility when we&#39;re emitting them as part of the current dylib, but import external public symbols with default visibility. Since we already need to track this distinction, it should be possible to approximate the right thing for Windows by using dllexport where we set protected visibility on ELF, or dllimport otherwise.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April  6, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 11:39 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 6, 2016, at 10:21 AM, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I was playing around with the idea of swift and Windows since there are<br>&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; &gt;<br>&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; &gt;<br>&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt; &gt;<br>&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt; change from the exported storage to default if being built into a static<br>&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt; &gt;<br>&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt; system so that we know whether a given SIL module is external or internal.<br>&gt; &gt;<br>&gt; &gt; Given that this would potentially effect ABI stability, it seems like<br>&gt; this is a good time to tackle it so that we can push this into the<br>&gt; resilience work that is being done for swift 3.<br>&gt; &gt;<br>&gt; &gt; I would appreciate any pointers and suggestions as to how to best go<br>&gt; about handling this.<br>&gt;<br>&gt; As Jordan noted, we probably want to thread this information through for<br>&gt; ELF and Mach-O builds too, for a couple of reasons. One, if you&#39;re building<br>&gt; a static library as opposed to a .so or .dylib, it&#39;s not desirable to<br>&gt; reexport that static library&#39;s API by default through any executables or<br>&gt; dynamic libraries that use it. We currently get this wrong; if the compiler<br>&gt; knew it was building for a static library, it could give public symbols in<br>&gt; the .a &#39;hidden&#39; visibility so that they do the right thing when linked into<br>&gt; dylibs. Second, ELF&#39;s default visibility is problematic for Swift, since it<br>&gt; allows default-visibility symbols to be interposed at load time by other<br>&gt; dynamic libraries. This imposes a performance penalty on shared libraries<br>&gt; accessing their own data, interferes with some of the load-time<br>&gt; optimizations we do with metadata that assume we can hardcode relative<br>&gt; references within a linkage unit, and is flat-out dangerous in the face of<br>&gt; interprocedural optimization. For these reasons, we export symbols with<br>&gt; &quot;protected&quot; visibility when we&#39;re emitting them as part of the current<br>&gt; dylib, but import external public symbols with default visibility. Since we<br>&gt; already need to track this distinction, it should be possible to<br>&gt; approximate the right thing for Windows by using dllexport where we set<br>&gt; protected visibility on ELF, or dllimport otherwise.<br></p><p><br>Yeah, I can absolutely see this information being useful in a non-COFF<br>environment.  I think that approaching it where we can implement it<br>generically enough to be shared across COFF, ELF, (and possibly MachO?  --<br>sorry, not as familiar with the object format as the other two), would be<br>the best thing to do.  But, I wanted to raise the issue on swift-dev so<br>that all the concerns can get ironed out before I take a stab at doing<br>something like this.  Not to mention, some pointers would probably be time<br>saving as well.<br></p><p><br>&gt; -Joe<br></p><p><br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160406/be90e1e7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April  7, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I was playing around with the idea of swift and Windows since there are<br>&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;<br>&gt; PE/COFF does not directly address symbols in external modules<br>&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;<br>&gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;<br>&gt; The thing to consider with this is that the DLL storage class is dependent<br>&gt; on how the module(s) are being built.  For example, something may change<br>&gt; from the exported storage to default if being built into a static library<br>&gt; rather than a shared object and is not meant to be re-exported.<br>&gt;<br>&gt; Part of this information really needs to be threaded from the build system<br>&gt; so that we know whether a given SIL module is external or internal.<br>&gt;<br></p><p>To the DLL Storage semantics support, Ive taken a quick first stab at it.<br>Ive pushed the changes to<br>https://github.com/compnerd/apple-swift/tree/dllstorage and created a Pull<br>Request at https://github.com/apple/swift/pull/2080 .<br></p><p>However, as I expected, this is going to cause problems for building some<br>of the core libraries.  In particular, there are mismatches between what<br>gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>statically compiled and then merged into swiftCore.  There is also the<br>concern of the the support modules (e.g. Platform).  If there are stubs<br>that are being used (e.g. via _silgen_name) then there are issues with<br>calculating the correct DLL storage for the associated global values.<br></p><p>It seems to me, at least initially, that we need a way to treat SwiftModule<br>as a container (a la llvm::Module) and indicate which of the TopLevelDecls<br>are meant to be a single &quot;module&quot; (DSO, DLL, whatever you want to call it)<br>so that we can properly track the DLL storage associated with them.  Am I<br>confusing something there?<br></p><p>Is there a preference on a means to handle this?<br></p><p><br>&gt; Given that this would potentially effect ABI stability, it seems like this<br>&gt; is a good time to tackle it so that we can push this into the resilience<br>&gt; work that is being done for swift 3.<br>&gt;<br>&gt; I would appreciate any pointers and suggestions as to how to best go about<br>&gt; handling this.<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160407/d4c5bc10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April 11, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>wrote:<br></p><p>&gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I was playing around with the idea of swift and Windows since there are<br>&gt;&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;&gt;<br>&gt;&gt; PE/COFF does not directly address symbols in external modules<br>&gt;&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt;&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt;&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt;&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt;&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;&gt;<br>&gt;&gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt;&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;&gt;<br>&gt;&gt; The thing to consider with this is that the DLL storage class is<br>&gt;&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt;&gt; change from the exported storage to default if being built into a static<br>&gt;&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt;&gt;<br>&gt;&gt; Part of this information really needs to be threaded from the build<br>&gt;&gt; system so that we know whether a given SIL module is external or internal.<br>&gt;&gt;<br>&gt;<br>&gt; To the DLL Storage semantics support, Ive taken a quick first stab at it.<br>&gt; Ive pushed the changes to<br>&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt;<br>&gt; However, as I expected, this is going to cause problems for building some<br>&gt; of the core libraries.  In particular, there are mismatches between what<br>&gt; gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt; calculating the correct DLL storage for the associated global values.<br>&gt;<br></p><p>Playing around with this, I was trying to special case the building of the<br>standard library (as the runtime will be statically linked into it, the<br>symbols that it is expecting to be externally available are actually<br>private linkage.  Not hacking up the compiler like this causes issues since<br>there are inverse dependencies (swiftCore gets dllimport interfaces from<br>swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>problem is that we do not have a way to represent that in swift.<br></p><p>The easiest answer that seems to come to mind is to actually introduce an<br>attribute to indicate that an interface is part of a specific module and<br>assume that everything else is locally defined.  This would also<br>potentially allow us to handle things like @inline(always) @transparent<br>interfaces which get imported to ensure that a static inline function is<br>given local visibility rather than a DLL Import storage.<br></p><p>Unfortunately, I believe that currently Im stuck as I do not have a good<br>way to determine what type of dll storage class a symbol should be given<br>(since currently, theres no way to determine if we will have a symbol<br>available locally or not when actually linking).<br></p><p><br>&gt; It seems to me, at least initially, that we need a way to treat<br>&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt; with them.  Am I confusing something there?<br>&gt;<br>&gt; Is there a preference on a means to handle this?<br>&gt;<br>&gt;<br>&gt;&gt; Given that this would potentially effect ABI stability, it seems like<br>&gt;&gt; this is a good time to tackle it so that we can push this into the<br>&gt;&gt; resilience work that is being done for swift 3.<br>&gt;&gt;<br>&gt;&gt; I would appreciate any pointers and suggestions as to how to best go<br>&gt;&gt; about handling this.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Saleem Abdulrasool<br>&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160411/7bb62f72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; I was playing around with the idea of swift and Windows since there are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; <br>&gt; PE/COFF does not directly address symbols in external modules (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks in Windows parlance).  Fortunately, LLVM has a nice way to model this: GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether something is &quot;imported&quot; (provided by an external module), &quot;exported&quot; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; <br>&gt; Adjusting the IRGen to correctly annotate this part of the semantics should get us part of the way to supporting swift on PE/COFF.<br>&gt; <br>&gt; The thing to consider with this is that the DLL storage class is dependent on how the module(s) are being built.  For example, something may change from the exported storage to default if being built into a static library rather than a shared object and is not meant to be re-exported.<br>&gt; <br>&gt; Part of this information really needs to be threaded from the build system so that we know whether a given SIL module is external or internal.<br>&gt; <br>&gt; To the DLL Storage semantics support, Ive taken a quick first stab at it.  Ive pushed the changes to https://github.com/compnerd/apple-swift/tree/dllstorage and created a Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt; <br>&gt; However, as I expected, this is going to cause problems for building some of the core libraries.  In particular, there are mismatches between what gets compiled and is desired.  The swiftStubs and swiftRuntime are statically compiled and then merged into swiftCore.  There is also the concern of the the support modules (e.g. Platform).  If there are stubs that are being used (e.g. via _silgen_name) then there are issues with calculating the correct DLL storage for the associated global values.<br>&gt; <br>&gt; Playing around with this, I was trying to special case the building of the standard library (as the runtime will be statically linked into it, the symbols that it is expecting to be externally available are actually private linkage.  Not hacking up the compiler like this causes issues since there are inverse dependencies (swiftCore gets dllimport interfaces from swiftRuntime, which has dependencies on swiftCore).  The crux of the problem is that we do not have a way to represent that in swift.<br>&gt; <br>&gt; The easiest answer that seems to come to mind is to actually introduce an attribute to indicate that an interface is part of a specific module and assume that everything else is locally defined.  This would also potentially allow us to handle things like @inline(always) @transparent interfaces which get imported to ensure that a static inline function is given local visibility rather than a DLL Import storage.<br>&gt; <br>&gt; Unfortunately, I believe that currently Im stuck as I do not have a good way to determine what type of dll storage class a symbol should be given (since currently, theres no way to determine if we will have a symbol available locally or not when actually linking).<br>&gt;  <br>&gt; It seems to me, at least initially, that we need a way to treat SwiftModule as a container (a la llvm::Module) and indicate which of the TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you want to call it) so that we can properly track the DLL storage associated with them.  Am I confusing something there?<br>&gt; <br>&gt; Is there a preference on a means to handle this?<br></p><p>The runtime is linked as part of the standard library, and its ABI interface should be exported from libswiftCore.dylib/so/dll like the standard library&#39;s. We should already mark up the ABI entry points with the SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not sufficient to expand these macros to __dllexport?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April 12, 2016 at 09:00:00am</p></header><div class="content"><p>On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;<br>&gt; compnerd at compnerd.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;<br>&gt; compnerd at compnerd.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I was playing around with the idea of swift and Windows since there are<br>&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; &gt;<br>&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; &gt;<br>&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt; &gt;<br>&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt; change from the exported storage to default if being built into a static<br>&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt; &gt;<br>&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt; system so that we know whether a given SIL module is external or internal.<br>&gt; &gt;<br>&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at<br>&gt; it.  Ive pushed the changes to<br>&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt; &gt;<br>&gt; &gt; However, as I expected, this is going to cause problems for building<br>&gt; some of the core libraries.  In particular, there are mismatches between<br>&gt; what gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt; calculating the correct DLL storage for the associated global values.<br>&gt; &gt;<br>&gt; &gt; Playing around with this, I was trying to special case the building of<br>&gt; the standard library (as the runtime will be statically linked into it, the<br>&gt; symbols that it is expecting to be externally available are actually<br>&gt; private linkage.  Not hacking up the compiler like this causes issues since<br>&gt; there are inverse dependencies (swiftCore gets dllimport interfaces from<br>&gt; swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>&gt; problem is that we do not have a way to represent that in swift.<br>&gt; &gt;<br>&gt; &gt; The easiest answer that seems to come to mind is to actually introduce<br>&gt; an attribute to indicate that an interface is part of a specific module and<br>&gt; assume that everything else is locally defined.  This would also<br>&gt; potentially allow us to handle things like @inline(always) @transparent<br>&gt; interfaces which get imported to ensure that a static inline function is<br>&gt; given local visibility rather than a DLL Import storage.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a good<br>&gt; way to determine what type of dll storage class a symbol should be given<br>&gt; (since currently, theres no way to determine if we will have a symbol<br>&gt; available locally or not when actually linking).<br>&gt; &gt;<br>&gt; &gt; It seems to me, at least initially, that we need a way to treat<br>&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt; with them.  Am I confusing something there?<br>&gt; &gt;<br>&gt; &gt; Is there a preference on a means to handle this?<br>&gt;<br>&gt; The runtime is linked as part of the standard library, and its ABI<br>&gt; interface should be exported from libswiftCore.dylib/so/dll like the<br>&gt; standard library&#39;s. We should already mark up the ABI entry points with the<br>&gt; SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not<br>&gt; sufficient to expand these macros to __dllexport?<br></p><p><br>The definitions can be marked as __declspec(dllexport) but the compiler<br>generated references need to be dllimport for the wrapped runtime functions<br>(easy for the most part -- see my changes).  There&#39;s also the concern of<br>stubs for the aliases (via silgen_name).  Those are defined externally with<br>no indication that they are locally available and thus should have default<br>rather than dllimport storage.  Similar things for standard library<br>metadata (type, witness tables, etc).<br></p><p>-Joe<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160412/53daadae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>April 26, 2016 at 08:00:00am</p></header><div class="content"><p>On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>wrote:<br></p><p>&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;<br>&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;<br>&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I was playing around with the idea of swift and Windows since there are<br>&gt;&gt; some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt;&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt;&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt;&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt;&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt;&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt;&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt;&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt;&gt; change from the exported storage to default if being built into a static<br>&gt;&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt;&gt; system so that we know whether a given SIL module is external or internal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at<br>&gt;&gt; it.  Ive pushed the changes to<br>&gt;&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt;&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; However, as I expected, this is going to cause problems for building<br>&gt;&gt; some of the core libraries.  In particular, there are mismatches between<br>&gt;&gt; what gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt;&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt;&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt;&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt;&gt; calculating the correct DLL storage for the associated global values.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Playing around with this, I was trying to special case the building of<br>&gt;&gt; the standard library (as the runtime will be statically linked into it, the<br>&gt;&gt; symbols that it is expecting to be externally available are actually<br>&gt;&gt; private linkage.  Not hacking up the compiler like this causes issues since<br>&gt;&gt; there are inverse dependencies (swiftCore gets dllimport interfaces from<br>&gt;&gt; swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>&gt;&gt; problem is that we do not have a way to represent that in swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The easiest answer that seems to come to mind is to actually introduce<br>&gt;&gt; an attribute to indicate that an interface is part of a specific module and<br>&gt;&gt; assume that everything else is locally defined.  This would also<br>&gt;&gt; potentially allow us to handle things like @inline(always) @transparent<br>&gt;&gt; interfaces which get imported to ensure that a static inline function is<br>&gt;&gt; given local visibility rather than a DLL Import storage.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a<br>&gt;&gt; good way to determine what type of dll storage class a symbol should be<br>&gt;&gt; given (since currently, theres no way to determine if we will have a symbol<br>&gt;&gt; available locally or not when actually linking).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It seems to me, at least initially, that we need a way to treat<br>&gt;&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt;&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt;&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt;&gt; with them.  Am I confusing something there?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is there a preference on a means to handle this?<br>&gt;&gt;<br>&gt;&gt; The runtime is linked as part of the standard library, and its ABI<br>&gt;&gt; interface should be exported from libswiftCore.dylib/so/dll like the<br>&gt;&gt; standard library&#39;s. We should already mark up the ABI entry points with the<br>&gt;&gt; SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not<br>&gt;&gt; sufficient to expand these macros to __dllexport?<br>&gt;<br>&gt;<br>&gt; The definitions can be marked as __declspec(dllexport) but the compiler<br>&gt; generated references need to be dllimport for the wrapped runtime functions<br>&gt; (easy for the most part -- see my changes).  There&#39;s also the concern of<br>&gt; stubs for the aliases (via silgen_name).  Those are defined externally with<br>&gt; no indication that they are locally available and thus should have default<br>&gt; rather than dllimport storage.  Similar things for standard library<br>&gt; metadata (type, witness tables, etc).<br>&gt;<br></p><p>A gentle reminder on this topic.  I would like to get something sorted out<br>so that we can try to get this resolved, preferably before the swift 3<br>release.<br></p><p><br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160426/a7177d65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 8:43 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org &lt;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;&gt;&gt; wrote:<br>&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;&gt;&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I was playing around with the idea of swift and Windows since there are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; &gt;<br>&gt; &gt; PE/COFF does not directly address symbols in external modules (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks in Windows parlance).  Fortunately, LLVM has a nice way to model this: GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether something is &quot;imported&quot; (provided by an external module), &quot;exported&quot; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; &gt;<br>&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics should get us part of the way to supporting swift on PE/COFF.<br>&gt; &gt;<br>&gt; &gt; The thing to consider with this is that the DLL storage class is dependent on how the module(s) are being built.  For example, something may change from the exported storage to default if being built into a static library rather than a shared object and is not meant to be re-exported.<br>&gt; &gt;<br>&gt; &gt; Part of this information really needs to be threaded from the build system so that we know whether a given SIL module is external or internal.<br>&gt; &gt;<br>&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at it.  Ive pushed the changes to https://github.com/compnerd/apple-swift/tree/dllstorage &lt;https://github.com/compnerd/apple-swift/tree/dllstorage&gt; and created a Pull Request at https://github.com/apple/swift/pull/2080 &lt;https://github.com/apple/swift/pull/2080&gt; .<br>&gt; &gt;<br>&gt; &gt; However, as I expected, this is going to cause problems for building some of the core libraries.  In particular, there are mismatches between what gets compiled and is desired.  The swiftStubs and swiftRuntime are statically compiled and then merged into swiftCore.  There is also the concern of the the support modules (e.g. Platform).  If there are stubs that are being used (e.g. via _silgen_name) then there are issues with calculating the correct DLL storage for the associated global values.<br>&gt; &gt;<br>&gt; &gt; Playing around with this, I was trying to special case the building of the standard library (as the runtime will be statically linked into it, the symbols that it is expecting to be externally available are actually private linkage.  Not hacking up the compiler like this causes issues since there are inverse dependencies (swiftCore gets dllimport interfaces from swiftRuntime, which has dependencies on swiftCore).  The crux of the problem is that we do not have a way to represent that in swift.<br>&gt; &gt;<br>&gt; &gt; The easiest answer that seems to come to mind is to actually introduce an attribute to indicate that an interface is part of a specific module and assume that everything else is locally defined.  This would also potentially allow us to handle things like @inline(always) @transparent interfaces which get imported to ensure that a static inline function is given local visibility rather than a DLL Import storage.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a good way to determine what type of dll storage class a symbol should be given (since currently, theres no way to determine if we will have a symbol available locally or not when actually linking).<br>&gt; &gt;<br>&gt; &gt; It seems to me, at least initially, that we need a way to treat SwiftModule as a container (a la llvm::Module) and indicate which of the TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you want to call it) so that we can properly track the DLL storage associated with them.  Am I confusing something there?<br>&gt; &gt;<br>&gt; &gt; Is there a preference on a means to handle this?<br>&gt; <br>&gt; The runtime is linked as part of the standard library, and its ABI interface should be exported from libswiftCore.dylib/so/dll like the standard library&#39;s. We should already mark up the ABI entry points with the SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not sufficient to expand these macros to __dllexport?<br>&gt; <br>&gt; The definitions can be marked as __declspec(dllexport) but the compiler generated references need to be dllimport for the wrapped runtime functions (easy for the most part -- see my changes).  There&#39;s also the concern of stubs for the aliases (via silgen_name).  Those are defined externally with no indication that they are locally available and thus should have default rather than dllimport storage.  Similar things for standard library metadata (type, witness tables, etc).<br>&gt; <br>&gt; A gentle reminder on this topic.  I would like to get something sorted out so that we can try to get this resolved, preferably before the swift 3 release.<br></p><p>I think it&#39;s reasonable to assume that @_silgen_name is not being used for objects that are external to the declaring module.  That is, the implementation model is that those declarations really are declaring a Swift function; it just happens that the actual body (if not provided) is provided magically.  That should work for all the standard library use cases.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160426/8b194680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05d93b58565bbc562ecb20fc9f8e6009?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Paul Menage</string> &lt;paul at paulmenage.org&gt;<p>October  7, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 8:49 AM, John McCall via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; I think it&#39;s reasonable to assume that @_silgen_name is not being used for<br>&gt; objects that are external to the declaring module.  That is, the<br>&gt; implementation model is that those declarations really are declaring a Swift<br>&gt; function; it just happens that the actual body (if not provided) is provided<br>&gt; magically.  That should work for all the standard library use cases.<br></p><p>So what&#39;s the cleanest way to make this work in practice? I<br>experimented with the following hack, which worked for building the<br>stdlib and the SDK overlay but which is full of layer violations:<br></p><p>- Add a symbol tracking hook in SILGenNameAttr, such that when the<br>hook is active, whenever we encounter a _silgen_name() declaration we<br>record it in a set.<br></p><p>- Enable this symbol tracking just for the duration of parsing the<br>main module. Thus we end up with a set of all _silgen_name attributes<br>on functions declared in the current module, but not _silgen_name<br>attributes on functions imported from other modules.<br></p><p>- At various points in lib/IRGen/GenDecl.cc<br>(updateLinkageForDefinition, LinkInfo::createFunction,<br>LinkInfo::createVariable) check whether the symbol being used is in<br>the list of _silgen_name attributes from the current module, and if so<br>ignore the dll-import tag on the symbol when setting up the<br>llvm::GlobalValue.<br></p><p>It would be nicer to walk across the main module after parsing it to<br>find SILGenNameAttr instances, but I don&#39;t have a good idea how to<br>start with that. Then we could perhaps add the list of attributes to<br>the llvm::Module as some kind of llvm::Metadata object?<br></p><p>Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Oct 7, 2016, at 4:08 PM, Paul Menage &lt;paul at paulmenage.org&gt; wrote:<br>&gt; On Tue, Apr 26, 2016 at 8:49 AM, John McCall via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s reasonable to assume that @_silgen_name is not being used for<br>&gt;&gt; objects that are external to the declaring module.  That is, the<br>&gt;&gt; implementation model is that those declarations really are declaring a Swift<br>&gt;&gt; function; it just happens that the actual body (if not provided) is provided<br>&gt;&gt; magically.  That should work for all the standard library use cases.<br>&gt; <br>&gt; So what&#39;s the cleanest way to make this work in practice? I<br>&gt; experimented with the following hack, which worked for building the<br>&gt; stdlib and the SDK overlay but which is full of layer violations:<br></p><p>Sorry, I could&#39;ve been more clear.  For ordinary declarations, we know exactly<br>which module defines any symbols associated with them because we know<br>which module the declaration is in and ordinary declarations are always definitions.<br>A @_silgen_name declaration isn&#39;t itself a definition, but it&#39;s actually still<br>reasonable to assume that it&#39;s defined by the current module, which means<br>that as far as knowing where the symbol is defined goes, it really *is* a definition.<br>So there&#39;s no difference.<br></p><p>The right solution is for SILFunctions (well, at least the ones with public linkage)<br>to always carry a reference to their defining module.  IRGen can then just key off<br>of that + its knowledge of the current module when emitting the llvm::GlobalValue<br>for the thing.<br></p><p>John.<br></p><p>&gt; <br>&gt; - Add a symbol tracking hook in SILGenNameAttr, such that when the<br>&gt; hook is active, whenever we encounter a _silgen_name() declaration we<br>&gt; record it in a set.<br>&gt; <br>&gt; - Enable this symbol tracking just for the duration of parsing the<br>&gt; main module. Thus we end up with a set of all _silgen_name attributes<br>&gt; on functions declared in the current module, but not _silgen_name<br>&gt; attributes on functions imported from other modules.<br>&gt; <br>&gt; - At various points in lib/IRGen/GenDecl.cc<br>&gt; (updateLinkageForDefinition, LinkInfo::createFunction,<br>&gt; LinkInfo::createVariable) check whether the symbol being used is in<br>&gt; the list of _silgen_name attributes from the current module, and if so<br>&gt; ignore the dll-import tag on the symbol when setting up the<br>&gt; llvm::GlobalValue.<br>&gt; <br>&gt; It would be nicer to walk across the main module after parsing it to<br>&gt; find SILGenNameAttr instances, but I don&#39;t have a good idea how to<br>&gt; start with that. Then we could perhaps add the list of attributes to<br>&gt; the llvm::Module as some kind of llvm::Metadata object?<br>&gt; <br>&gt; Paul<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>May  3, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 08:43, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;mailto:compnerd at compnerd.org&gt;&gt; wrote:<br>&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;swift-dev at swift.org &lt;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;&gt;&gt; wrote:<br>&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org &lt;&gt;&gt; wrote:<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I was playing around with the idea of swift and Windows since there are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt; &gt;<br>&gt; &gt; PE/COFF does not directly address symbols in external modules (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks in Windows parlance).  Fortunately, LLVM has a nice way to model this: GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether something is &quot;imported&quot; (provided by an external module), &quot;exported&quot; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt; &gt;<br>&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics should get us part of the way to supporting swift on PE/COFF.<br>&gt; &gt;<br>&gt; &gt; The thing to consider with this is that the DLL storage class is dependent on how the module(s) are being built.  For example, something may change from the exported storage to default if being built into a static library rather than a shared object and is not meant to be re-exported.<br>&gt; &gt;<br>&gt; &gt; Part of this information really needs to be threaded from the build system so that we know whether a given SIL module is external or internal.<br>&gt; &gt;<br>&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at it.  Ive pushed the changes to https://github.com/compnerd/apple-swift/tree/dllstorage &lt;https://github.com/compnerd/apple-swift/tree/dllstorage&gt; and created a Pull Request at https://github.com/apple/swift/pull/2080 &lt;https://github.com/apple/swift/pull/2080&gt; .<br>&gt; &gt;<br>&gt; &gt; However, as I expected, this is going to cause problems for building some of the core libraries.  In particular, there are mismatches between what gets compiled and is desired.  The swiftStubs and swiftRuntime are statically compiled and then merged into swiftCore.  There is also the concern of the the support modules (e.g. Platform).  If there are stubs that are being used (e.g. via _silgen_name) then there are issues with calculating the correct DLL storage for the associated global values.<br>&gt; &gt;<br>&gt; &gt; Playing around with this, I was trying to special case the building of the standard library (as the runtime will be statically linked into it, the symbols that it is expecting to be externally available are actually private linkage.  Not hacking up the compiler like this causes issues since there are inverse dependencies (swiftCore gets dllimport interfaces from swiftRuntime, which has dependencies on swiftCore).  The crux of the problem is that we do not have a way to represent that in swift.<br>&gt; &gt;<br>&gt; &gt; The easiest answer that seems to come to mind is to actually introduce an attribute to indicate that an interface is part of a specific module and assume that everything else is locally defined.  This would also potentially allow us to handle things like @inline(always) @transparent interfaces which get imported to ensure that a static inline function is given local visibility rather than a DLL Import storage.<br>&gt; &gt;<br>&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a good way to determine what type of dll storage class a symbol should be given (since currently, theres no way to determine if we will have a symbol available locally or not when actually linking).<br>&gt; &gt;<br>&gt; &gt; It seems to me, at least initially, that we need a way to treat SwiftModule as a container (a la llvm::Module) and indicate which of the TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you want to call it) so that we can properly track the DLL storage associated with them.  Am I confusing something there?<br>&gt; &gt;<br>&gt; &gt; Is there a preference on a means to handle this?<br>&gt; <br>&gt; The runtime is linked as part of the standard library, and its ABI interface should be exported from libswiftCore.dylib/so/dll like the standard library&#39;s. We should already mark up the ABI entry points with the SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not sufficient to expand these macros to __dllexport?<br>&gt; <br>&gt; The definitions can be marked as __declspec(dllexport) but the compiler generated references need to be dllimport for the wrapped runtime functions (easy for the most part -- see my changes).  There&#39;s also the concern of stubs for the aliases (via silgen_name).  Those are defined externally with no indication that they are locally available and thus should have default rather than dllimport storage.  Similar things for standard library metadata (type, witness tables, etc).<br>&gt; <br>&gt; A gentle reminder on this topic.  I would like to get something sorted out so that we can try to get this resolved, preferably before the swift 3 release.<br></p><p>Just to chime in here (as asked by Saleem, um, a month ago) I think this is the right way to go. We should handle the DLL-ish case (mark public things ‘dllexport’ and references outside the Swift module ‘dllimport’), and not worry about static linking (unnecessary dllimports).<br></p><p>(It seems __declspec(dllexport) is exactly the same as LLVM ‘public’ vs ‘hidden’—at least for Swift’s uses, even if that isn’t true generally.)<br></p><p>We can then come back later and design / add some kind of “I know this object file is going to be statically linked into the executable” mode, which will drop all the dllexports. We’d also want to encode this flag into the serialized “swiftmodule” files (a library’s public interface), so that we know not to use dllimport for anything we use from there.<br></p><p>Thanks for pushing on this!<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160503/0e800e1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May  6, 2016 at 08:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I made an experimental MSVC port. Of cause, dllimport/dllexport and the<br>driver for linking and many other part is not implemented. But dynamic<br>linking was possible with some trick.<br></p><p>I think it is useful for designing, my observation about the experimental<br>building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll and linking of<br>Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br></p><p>1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>  Hello.obj needed defined in libswift*.dll<br>    _swift_getExistentialTypeMetadata,<br>    _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>    _TMSS,<br>    _TZvOs7Process5_argcVs5Int32,<br>    swift_bufferAllocate, ....<br>  Some of above are dllexported by the macro, but _T* are not. Maybe, it<br>generated by swiftc.exe.<br>  I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts all<br>symbols and generates &#39;allsymbol.def&#39;.<br>  With that .def, I could build the all-symbol-dllexported libswiftCore.dll.<br>  (I&#39;m hoping we can build it without this trick.)<br></p><p>2) Imediate mode just worked with libswift*.dll.<br>  Using the libswiftCore.dll, I could just run &#39;swift -O Hello.swift&#39; and<br>it worked. I was happy.<br>  But I don&#39;t know how Immediate mode work. How could this work without any<br>consideration about dllimport or import library?<br>  Anyway, after building libswiftSwiftOnoneSupport.dll, I could run &#39;swift<br>Hello.swift&#39; without -O.<br></p><p>3) Building Hello.exe with some trick.<br>  I compiled the Hello.swift to Hello.ll, and simply replace the string<br>&quot;external global/constant&quot; to &quot;external dllimport global/contant&quot; in the<br>file, and pass it to &#39;clang&#39; for Hello.obj, and link with previously built<br>import library of swiftCore.<br>  It worked well. It will be happy swiftc could generate the dllimport.<br></p><p>4) In building libswiftSwiftOnoneSupport.dll, there is SOME MORE.<br>  To build libswiftSwiftOnoneSupport.dll, it needed to link with<br>libswiftCore.dll. I used the same method - &#39;injecting dllimport into *.ll&#39;.<br>  When linking swiftOnone, only _TWVBo was not resolved.<br>  To make it linkable, in the SwiftOnoneSupport.ll,<br>    @_TWVBo = external global i8*, align 8<br>  should be replaced to<br>    @__imp__TWVBo = external global i8*, align 8<br>  not<br>    @_TWVBo = external dllimport global i8*, align 8.<br></p><p>  I don&#39;t know well what _TWVBo is. I only guess this related to indirect<br>access the variable _TWVBo.<br>  But I think we should know what the root cause to this.<br></p><p>- Han Sangjin<br></p><p>2016-05-04 10:34 GMT+09:00 Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt;:<br></p><p>&gt;<br>&gt; On Apr 26, 2016, at 08:43, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I was playing around with the idea of swift and Windows since there<br>&gt;&gt;&gt; are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt;&gt;&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt;&gt;&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt;&gt;&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt;&gt;&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt;&gt;&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt;&gt;&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt;&gt;&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt;&gt;&gt; change from the exported storage to default if being built into a static<br>&gt;&gt;&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt;&gt;&gt; system so that we know whether a given SIL module is external or internal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at<br>&gt;&gt;&gt; it.  Ive pushed the changes to<br>&gt;&gt;&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt;&gt;&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; However, as I expected, this is going to cause problems for building<br>&gt;&gt;&gt; some of the core libraries.  In particular, there are mismatches between<br>&gt;&gt;&gt; what gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt;&gt;&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt;&gt;&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt;&gt;&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt;&gt;&gt; calculating the correct DLL storage for the associated global values.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Playing around with this, I was trying to special case the building of<br>&gt;&gt;&gt; the standard library (as the runtime will be statically linked into it, the<br>&gt;&gt;&gt; symbols that it is expecting to be externally available are actually<br>&gt;&gt;&gt; private linkage.  Not hacking up the compiler like this causes issues since<br>&gt;&gt;&gt; there are inverse dependencies (swiftCore gets dllimport interfaces from<br>&gt;&gt;&gt; swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>&gt;&gt;&gt; problem is that we do not have a way to represent that in swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The easiest answer that seems to come to mind is to actually introduce<br>&gt;&gt;&gt; an attribute to indicate that an interface is part of a specific module and<br>&gt;&gt;&gt; assume that everything else is locally defined.  This would also<br>&gt;&gt;&gt; potentially allow us to handle things like @inline(always) @transparent<br>&gt;&gt;&gt; interfaces which get imported to ensure that a static inline function is<br>&gt;&gt;&gt; given local visibility rather than a DLL Import storage.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a<br>&gt;&gt;&gt; good way to determine what type of dll storage class a symbol should be<br>&gt;&gt;&gt; given (since currently, theres no way to determine if we will have a symbol<br>&gt;&gt;&gt; available locally or not when actually linking).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It seems to me, at least initially, that we need a way to treat<br>&gt;&gt;&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt;&gt;&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt;&gt;&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt;&gt;&gt; with them.  Am I confusing something there?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is there a preference on a means to handle this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The runtime is linked as part of the standard library, and its ABI<br>&gt;&gt;&gt; interface should be exported from libswiftCore.dylib/so/dll like the<br>&gt;&gt;&gt; standard library&#39;s. We should already mark up the ABI entry points with the<br>&gt;&gt;&gt; SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not<br>&gt;&gt;&gt; sufficient to expand these macros to __dllexport?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The definitions can be marked as __declspec(dllexport) but the compiler<br>&gt;&gt; generated references need to be dllimport for the wrapped runtime functions<br>&gt;&gt; (easy for the most part -- see my changes).  There&#39;s also the concern of<br>&gt;&gt; stubs for the aliases (via silgen_name).  Those are defined externally with<br>&gt;&gt; no indication that they are locally available and thus should have default<br>&gt;&gt; rather than dllimport storage.  Similar things for standard library<br>&gt;&gt; metadata (type, witness tables, etc).<br>&gt;&gt;<br>&gt;<br>&gt; A gentle reminder on this topic.  I would like to get something sorted out<br>&gt; so that we can try to get this resolved, preferably before the swift 3<br>&gt; release.<br>&gt;<br>&gt;<br>&gt; Just to chime in here (as asked by Saleem, um, a month ago) I think this<br>&gt; is the right way to go. We should handle the DLL-ish case (mark public<br>&gt; things ‘dllexport’ and references outside the Swift module ‘dllimport’),<br>&gt; and not worry about static linking (unnecessary dllimports).<br>&gt;<br>&gt; (It seems __declspec(dllexport) is exactly the same as LLVM ‘public’ vs<br>&gt; ‘hidden’—at least for Swift’s uses, even if that isn’t true generally.)<br>&gt;<br>&gt; We can then come back later and design / add some kind of “I know this<br>&gt; object file is going to be statically linked into the executable” mode,<br>&gt; which will drop all the dllexports. We’d also want to encode this flag into<br>&gt; the serialized “swiftmodule” files (a library’s public interface), so that<br>&gt; we know not to use dllimport for anything we use from there.<br>&gt;<br>&gt; Thanks for pushing on this!<br>&gt; Jordan<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160506/1e5a3074/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the driver for linking and many other part is not implemented. But dynamic linking was possible with some trick.<br>&gt; <br>&gt; I think it is useful for designing, my observation about the experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; <br>&gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt;   Hello.obj needed defined in libswift*.dll<br>&gt;     _swift_getExistentialTypeMetadata,<br>&gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt;     _TMSS,<br>&gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt;     swift_bufferAllocate, .... <br>&gt;   Some of above are dllexported by the macro, but _T* are not. Maybe, it generated by swiftc.exe.<br>&gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt;   With that .def, I could build the all-symbol-dllexported libswiftCore.dll.<br>&gt;   (I&#39;m hoping we can build it without this trick.)<br></p><p>The _T symbols are emitted by the Swift compiler. You should modify swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage class when targeting Windows.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May  6, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org<br>&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the<br>&gt; driver for linking and many other part is not implemented. But dynamic<br>&gt; linking was possible with some trick.<br>&gt; &gt;<br>&gt; &gt; I think it is useful for designing, my observation about the<br>&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt;<br>&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt;     _TMSS,<br>&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe, it<br>&gt; generated by swiftc.exe.<br>&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts<br>&gt; all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt; libswiftCore.dll.<br>&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt;<br>&gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt; class when targeting Windows.<br></p><p><br>https://github.com/apple/swift/pull/2080 is a first cut attempt to do this.<br></p><p><br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160506/b5a7d048/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May  8, 2016 at 08:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br></p><p>I could compile easily Hello.swift with #2080 merged one.<br></p><p>  swiftc -c -o Hello.obj Hello.swift<br>  clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport<br>-Wl,&lt;some link options&gt;<br></p><p>Without #2080, I should use the *.ll-modifying-trick. It is perfect in this<br>example.<br></p><p>But, we need the way to disable dllimport. The immediate mode did not work.<br></p><p>  swift Hello.swift<br>  LLVM ERROR: Program used external function<br>&#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>not be resolved!<br></p><p>  swift -O Hello.swift<br>  LLVM ERROR: Program used external function<br>&#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br></p><p>It seems swift.exe call directly the function in the DLL without import<br>library.<br></p><p>The feature also needed when we link to static library.<br></p><p>I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to<br>approach this problem.<br></p><p><br>2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br></p><p>&gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the<br>&gt;&gt; driver for linking and many other part is not implemented. But dynamic<br>&gt;&gt; linking was possible with some trick.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think it is useful for designing, my observation about the<br>&gt;&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt;&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt;&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt;&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt;&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt;&gt; &gt;     _TMSS,<br>&gt;&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt;&gt; &gt;     swift_bufferAllocate, ....<br>&gt;&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe,<br>&gt;&gt; it generated by swiftc.exe.<br>&gt;&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts<br>&gt;&gt; all symbols and generates &#39;allsymbol.def&#39;.<br>&gt;&gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt;&gt; libswiftCore.dll.<br>&gt;&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt;&gt;<br>&gt;&gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt;&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt;&gt; class when targeting Windows.<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt; this.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160508/57b663a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May  8, 2016 at 11:00:00am</p></header><div class="content"><p>One more,<br></p><p>I couldn&#39;t build the libswiftCore.dll which can be used for Hello.swift. At<br>least one symbol _TMSS is not dllexported.<br>(But I could build the dll with dlltool.exe which make all symbols to be<br>dllexported)<br></p><p>To find out the reason, I built a Swift.ll instead of the Swift.obj for the<br>libswiftCore.dll. The Swift.ll are built from many<br>stdlib/public/core/*.swift and core/8/*.swift files, and about 50MB.<br></p><p>In that file, I could find many dllexport symbols, like<br>@_TZvOs7Process5_argcVs5Int32 = dllexport global %Vs5Int32 zeroinitializer,<br>align 4<br>and Hello.ll uses them,<br>@_TZvOs7Process5_argcVs5Int32 = external dllimport global %Vs5Int32, align 4<br></p><p>In the case of _TMSS, Hello.ll uses the same way,<br>@_TMSS = external dllimport global %swift.type, align 8<br>But, Swift.ll did not declared with dllexport.<br>@_TMSS = alias %swift.type, bitcast (i64* getelementptr inbounds (&lt;{ i8**,<br>i64, i64, %swift.type*, i64 }&gt;, &lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;*<br>@_TMfSS, i32 0, i32 1) to %swift.type*)<br></p><p>How we can make @_TMSS also has the dllexport?  Or any other solution ?<br></p><p><br>-Han Sangjin<br></p><p><br></p><p><br>2016-05-08 8:01 GMT+09:00 Sangjin Han &lt;tinysun.net at gmail.com&gt;:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt;<br>&gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt;<br>&gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt;   clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport<br>&gt; -Wl,&lt;some link options&gt;<br>&gt;<br>&gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in<br>&gt; this example.<br>&gt;<br>&gt; But, we need the way to disable dllimport. The immediate mode did not work.<br>&gt;<br>&gt;   swift Hello.swift<br>&gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>&gt; not be resolved!<br>&gt;<br>&gt;   swift -O Hello.swift<br>&gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt;<br>&gt; It seems swift.exe call directly the function in the DLL without import<br>&gt; library.<br>&gt;<br>&gt; The feature also needed when we link to static library.<br>&gt;<br>&gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to<br>&gt; approach this problem.<br>&gt;<br>&gt;<br>&gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt;<br>&gt;&gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and<br>&gt;&gt;&gt; the driver for linking and many other part is not implemented. But dynamic<br>&gt;&gt;&gt; linking was possible with some trick.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I think it is useful for designing, my observation about the<br>&gt;&gt;&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt;&gt;&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt;&gt;&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt;&gt;&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt;&gt;&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt;&gt;&gt; &gt;     _TMSS,<br>&gt;&gt;&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt;&gt;&gt; &gt;     swift_bufferAllocate, ....<br>&gt;&gt;&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe,<br>&gt;&gt;&gt; it generated by swiftc.exe.<br>&gt;&gt;&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It<br>&gt;&gt;&gt; extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt;&gt;&gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt;&gt;&gt; libswiftCore.dll.<br>&gt;&gt;&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt;&gt;&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt;&gt;&gt; class when targeting Windows.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt;&gt; this.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Saleem Abdulrasool<br>&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160508/3279a92f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May  9, 2016 at 07:00:00pm</p></header><div class="content"><p>On Sat, May 7, 2016 at 7:55 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br></p><p>&gt; One more,<br>&gt;<br>&gt; I couldn&#39;t build the libswiftCore.dll which can be used for Hello.swift.<br>&gt; At least one symbol _TMSS is not dllexported.<br>&gt; (But I could build the dll with dlltool.exe which make all symbols to be<br>&gt; dllexported)<br>&gt;<br>&gt; To find out the reason, I built a Swift.ll instead of the Swift.obj for<br>&gt; the libswiftCore.dll. The Swift.ll are built from many<br>&gt; stdlib/public/core/*.swift and core/8/*.swift files, and about 50MB.<br>&gt;<br>&gt; In that file, I could find many dllexport symbols, like<br>&gt; @_TZvOs7Process5_argcVs5Int32 = dllexport global %Vs5Int32<br>&gt; zeroinitializer, align 4<br>&gt; and Hello.ll uses them,<br>&gt; @_TZvOs7Process5_argcVs5Int32 = external dllimport global %Vs5Int32, align<br>&gt; 4<br>&gt;<br>&gt; In the case of _TMSS, Hello.ll uses the same way,<br>&gt; @_TMSS = external dllimport global %swift.type, align 8<br>&gt; But, Swift.ll did not declared with dllexport.<br>&gt; @_TMSS = alias %swift.type, bitcast (i64* getelementptr inbounds (&lt;{ i8**,<br>&gt; i64, i64, %swift.type*, i64 }&gt;, &lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;*<br>&gt; @_TMfSS, i32 0, i32 1) to %swift.type*)<br>&gt;<br>&gt; How we can make @_TMSS also has the dllexport?  Or any other solution ?<br>&gt;<br></p><p>Interesting.  Does changing the string type from struct to class help?  Ill<br>try to have a look at this.<br></p><p><br>&gt;<br>&gt; -Han Sangjin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; 2016-05-08 8:01 GMT+09:00 Sangjin Han &lt;tinysun.net at gmail.com&gt;:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt;&gt;<br>&gt;&gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt;&gt;<br>&gt;&gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt;&gt;   clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport<br>&gt;&gt; -Wl,&lt;some link options&gt;<br>&gt;&gt;<br>&gt;&gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in<br>&gt;&gt; this example.<br>&gt;&gt;<br>&gt;&gt; But, we need the way to disable dllimport. The immediate mode did not<br>&gt;&gt; work.<br>&gt;&gt;<br>&gt;&gt;   swift Hello.swift<br>&gt;&gt;   LLVM ERROR: Program used external function<br>&gt;&gt; &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>&gt;&gt; not be resolved!<br>&gt;&gt;<br>&gt;&gt;   swift -O Hello.swift<br>&gt;&gt;   LLVM ERROR: Program used external function<br>&gt;&gt; &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt;&gt;<br>&gt;&gt; It seems swift.exe call directly the function in the DLL without import<br>&gt;&gt; library.<br>&gt;&gt;<br>&gt;&gt; The feature also needed when we link to static library.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to<br>&gt;&gt; approach this problem.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and<br>&gt;&gt;&gt;&gt; the driver for linking and many other part is not implemented. But dynamic<br>&gt;&gt;&gt;&gt; linking was possible with some trick.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I think it is useful for designing, my observation about the<br>&gt;&gt;&gt;&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt;&gt;&gt;&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt;&gt;&gt;&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt;&gt;&gt;&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt;&gt;&gt;&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt;&gt;&gt;&gt; &gt;     _TMSS,<br>&gt;&gt;&gt;&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt;&gt;&gt;&gt; &gt;     swift_bufferAllocate, ....<br>&gt;&gt;&gt;&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe,<br>&gt;&gt;&gt;&gt; it generated by swiftc.exe.<br>&gt;&gt;&gt;&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It<br>&gt;&gt;&gt;&gt; extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt;&gt;&gt;&gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt;&gt;&gt;&gt; libswiftCore.dll.<br>&gt;&gt;&gt;&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt;&gt;&gt;&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt;&gt;&gt;&gt; class when targeting Windows.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt;&gt;&gt; this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Saleem Abdulrasool<br>&gt;&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160509/9bd1b201/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 9, 2016, at 7:19 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; On Sat, May 7, 2016 at 7:55 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; One more,<br>&gt; <br>&gt; I couldn&#39;t build the libswiftCore.dll which can be used for Hello.swift. At least one symbol _TMSS is not dllexported.<br>&gt; (But I could build the dll with dlltool.exe which make all symbols to be dllexported)<br>&gt; <br>&gt; To find out the reason, I built a Swift.ll instead of the Swift.obj for the libswiftCore.dll. The Swift.ll are built from many stdlib/public/core/*.swift and core/8/*.swift files, and about 50MB.<br>&gt; <br>&gt; In that file, I could find many dllexport symbols, like<br>&gt; @_TZvOs7Process5_argcVs5Int32 = dllexport global %Vs5Int32 zeroinitializer, align 4<br>&gt; and Hello.ll uses them,<br>&gt; @_TZvOs7Process5_argcVs5Int32 = external dllimport global %Vs5Int32, align 4<br>&gt; <br>&gt; In the case of _TMSS, Hello.ll uses the same way,<br>&gt; @_TMSS = external dllimport global %swift.type, align 8<br>&gt; But, Swift.ll did not declared with dllexport.<br>&gt; @_TMSS = alias %swift.type, bitcast (i64* getelementptr inbounds (&lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;, &lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;* @_TMfSS, i32 0, i32 1) to %swift.type*)<br>&gt; <br>&gt; How we can make @_TMSS also has the dllexport?  Or any other solution ?<br>&gt; <br>&gt; Interesting.  Does changing the string type from struct to class help?  Ill try to have a look at this.<br></p><p>Did you handle the path that creates these llvm::GlobalAlias objects for type metadata when adding the dllimport/export attributes?<br></p><p>-Joe<br></p><p>&gt;  <br>&gt; <br>&gt; -Han Sangjin<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; 2016-05-08 8:01 GMT+09:00 Sangjin Han &lt;tinysun.net at gmail.com&gt;:<br>&gt; Hi all,<br>&gt; <br>&gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; <br>&gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; <br>&gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt;   clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; <br>&gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in this example.<br>&gt; <br>&gt; But, we need the way to disable dllimport. The immediate mode did not work.<br>&gt; <br>&gt;   swift Hello.swift<br>&gt;   LLVM ERROR: Program used external function &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could not be resolved!<br>&gt; <br>&gt;   swift -O Hello.swift<br>&gt;   LLVM ERROR: Program used external function &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; <br>&gt; It seems swift.exe call directly the function in the DLL without import library.<br>&gt; <br>&gt; The feature also needed when we link to static library.<br>&gt; <br>&gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to approach this problem.<br>&gt; <br>&gt; <br>&gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the driver for linking and many other part is not implemented. But dynamic linking was possible with some trick.<br>&gt; &gt;<br>&gt; &gt; I think it is useful for designing, my observation about the experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt;<br>&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt;     _TMSS,<br>&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe, it generated by swiftc.exe.<br>&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt;   With that .def, I could build the all-symbol-dllexported libswiftCore.dll.<br>&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; <br>&gt; The _T symbols are emitted by the Swift compiler. You should modify swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage class when targeting Windows.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do this.<br>&gt;  <br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>On Monday, May 9, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 9, 2016, at 7:19 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Sat, May 7, 2016 at 7:55 PM, Sangjin Han &lt;tinysun.net at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; One more,<br>&gt; &gt;<br>&gt; &gt; I couldn&#39;t build the libswiftCore.dll which can be used for Hello.swift.<br>&gt; At least one symbol _TMSS is not dllexported.<br>&gt; &gt; (But I could build the dll with dlltool.exe which make all symbols to be<br>&gt; dllexported)<br>&gt; &gt;<br>&gt; &gt; To find out the reason, I built a Swift.ll instead of the Swift.obj for<br>&gt; the libswiftCore.dll. The Swift.ll are built from many<br>&gt; stdlib/public/core/*.swift and core/8/*.swift files, and about 50MB.<br>&gt; &gt;<br>&gt; &gt; In that file, I could find many dllexport symbols, like<br>&gt; &gt; @_TZvOs7Process5_argcVs5Int32 = dllexport global %Vs5Int32<br>&gt; zeroinitializer, align 4<br>&gt; &gt; and Hello.ll uses them,<br>&gt; &gt; @_TZvOs7Process5_argcVs5Int32 = external dllimport global %Vs5Int32,<br>&gt; align 4<br>&gt; &gt;<br>&gt; &gt; In the case of _TMSS, Hello.ll uses the same way,<br>&gt; &gt; @_TMSS = external dllimport global %swift.type, align 8<br>&gt; &gt; But, Swift.ll did not declared with dllexport.<br>&gt; &gt; @_TMSS = alias %swift.type, bitcast (i64* getelementptr inbounds (&lt;{<br>&gt; i8**, i64, i64, %swift.type*, i64 }&gt;, &lt;{ i8**, i64, i64, %swift.type*, i64<br>&gt; }&gt;* @_TMfSS, i32 0, i32 1) to %swift.type*)<br>&gt; &gt;<br>&gt; &gt; How we can make @_TMSS also has the dllexport?  Or any other solution ?<br>&gt; &gt;<br>&gt; &gt; Interesting.  Does changing the string type from struct to class help?<br>&gt; Ill try to have a look at this.<br>&gt;<br>&gt; Did you handle the path that creates these llvm::GlobalAlias objects for<br>&gt; type metadata when adding the dllimport/export attributes?<br></p><p><br>Ah, awesome, thanks for that hint.  That was indeed missing.  I suppose I<br>should audit a few more things.  I&#39;ll upload a new version shortly that<br>should take care of the dll storage on metadata.<br></p><p><br>&gt; -Joe<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -Han Sangjin<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; 2016-05-08 8:01 GMT+09:00 Sangjin Han &lt;tinysun.net at gmail.com<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; &gt;<br>&gt; &gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; &gt;<br>&gt; &gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt; &gt;   clang -o Hello.exe Hello.obj -llibswiftCore<br>&gt; -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; &gt;<br>&gt; &gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in<br>&gt; this example.<br>&gt; &gt;<br>&gt; &gt; But, we need the way to disable dllimport. The immediate mode did not<br>&gt; work.<br>&gt; &gt;<br>&gt; &gt;   swift Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>&gt; not be resolved!<br>&gt; &gt;<br>&gt; &gt;   swift -O Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; &gt;<br>&gt; &gt; It seems swift.exe call directly the function in the DLL without import<br>&gt; library.<br>&gt; &gt;<br>&gt; &gt; The feature also needed when we link to static library.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to<br>&gt; approach this problem.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org<br>&gt; &lt;javascript:;&gt;&gt;:<br>&gt; &gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt; swift-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and<br>&gt; the driver for linking and many other part is not implemented. But dynamic<br>&gt; linking was possible with some trick.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I think it is useful for designing, my observation about the<br>&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt; &gt;     _TMSS,<br>&gt; &gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe,<br>&gt; it generated by swiftc.exe.<br>&gt; &gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It<br>&gt; extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt; libswiftCore.dll.<br>&gt; &gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; &gt;<br>&gt; &gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt; class when targeting Windows.<br>&gt; &gt;<br>&gt; &gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt; this.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Saleem Abdulrasool<br>&gt; &gt; compnerd (at) compnerd (dot) org<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Saleem Abdulrasool<br>&gt; &gt; compnerd (at) compnerd (dot) org<br>&gt;<br>&gt;<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160510/a57f002f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 2:25 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; <br>&gt; On Monday, May 9, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On May 9, 2016, at 7:19 PM, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Sat, May 7, 2016 at 7:55 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; &gt; One more,<br>&gt; &gt;<br>&gt; &gt; I couldn&#39;t build the libswiftCore.dll which can be used for Hello.swift. At least one symbol _TMSS is not dllexported.<br>&gt; &gt; (But I could build the dll with dlltool.exe which make all symbols to be dllexported)<br>&gt; &gt;<br>&gt; &gt; To find out the reason, I built a Swift.ll instead of the Swift.obj for the libswiftCore.dll. The Swift.ll are built from many stdlib/public/core/*.swift and core/8/*.swift files, and about 50MB.<br>&gt; &gt;<br>&gt; &gt; In that file, I could find many dllexport symbols, like<br>&gt; &gt; @_TZvOs7Process5_argcVs5Int32 = dllexport global %Vs5Int32 zeroinitializer, align 4<br>&gt; &gt; and Hello.ll uses them,<br>&gt; &gt; @_TZvOs7Process5_argcVs5Int32 = external dllimport global %Vs5Int32, align 4<br>&gt; &gt;<br>&gt; &gt; In the case of _TMSS, Hello.ll uses the same way,<br>&gt; &gt; @_TMSS = external dllimport global %swift.type, align 8<br>&gt; &gt; But, Swift.ll did not declared with dllexport.<br>&gt; &gt; @_TMSS = alias %swift.type, bitcast (i64* getelementptr inbounds (&lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;, &lt;{ i8**, i64, i64, %swift.type*, i64 }&gt;* @_TMfSS, i32 0, i32 1) to %swift.type*)<br>&gt; &gt;<br>&gt; &gt; How we can make @_TMSS also has the dllexport?  Or any other solution ?<br>&gt; &gt;<br>&gt; &gt; Interesting.  Does changing the string type from struct to class help?  Ill try to have a look at this.<br>&gt; <br>&gt; Did you handle the path that creates these llvm::GlobalAlias objects for type metadata when adding the dllimport/export attributes?<br>&gt; <br>&gt; Ah, awesome, thanks for that hint.  That was indeed missing.  I suppose I should audit a few more things.  I&#39;ll upload a new version shortly that should take care of the dll storage on metadata.<br>&gt;  <br></p><p>It might help to centralize the logic. In IRGen, there&#39;s a function getIRLinkage that decomposes a semantic SIL visibility into an LLVM linkage and visibility pair:<br></p><p>https://github.com/apple/swift/blob/master/lib/IRGen/GenDecl.cpp#L1201<br></p><p>It could be modified to produce a three-element tuple that includes the DLL storage class too.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, May 10, 2016 at 2:29 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; It might help to centralize the logic. In IRGen, there&#39;s a function<br>&gt; getIRLinkage that decomposes a semantic SIL visibility into an LLVM linkage<br>&gt; and visibility pair:<br>&gt;<br>&gt; https://github.com/apple/swift/blob/master/lib/IRGen/GenDecl.cpp#L1201<br>&gt;<br>&gt; It could be modified to produce a three-element tuple that includes the<br>&gt; DLL storage class too.<br>&gt;<br></p><p>Hah.  You should have a look at the pull request :-).  Thats exactly what I<br>had done.  However, that function is not used globally and I just audited<br>the other calls for llvm::Function::Create and llvm::GlobalAlias::create.<br>I believe that it should be correct now.  Thanks for the original hint that<br>I had missed an instance of the GlobalAlias.  I also updated the test cases<br>that I had for this.  Additional input on what would be good test cases<br>would be good too.<br></p><p>https://github.com/apple/swift/pull/2080<br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160510/50d82bf7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 7, 2016, at 4:01 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; <br>&gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; <br>&gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt;   clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; <br>&gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in this example.<br>&gt; <br>&gt; But, we need the way to disable dllimport. The immediate mode did not work.<br></p><p>If it only affects immediate mode, this might be a problem with LLVM&#39;s MCJIT. I would recommend asking llvm-dev, cc-ing Lang Hames (lhames at apple.com), to see what the right thing to do to reference DLL exports from JIT code is.<br></p><p>-Joe<br></p><p>&gt;   swift Hello.swift<br>&gt;   LLVM ERROR: Program used external function &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could not be resolved!<br>&gt; <br>&gt;   swift -O Hello.swift<br>&gt;   LLVM ERROR: Program used external function &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; <br>&gt; It seems swift.exe call directly the function in the DLL without import library.<br>&gt; <br>&gt; The feature also needed when we link to static library.<br>&gt; <br>&gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to approach this problem.<br></p><p><br></p><p>&gt; <br>&gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the driver for linking and many other part is not implemented. But dynamic linking was possible with some trick.<br>&gt; &gt;<br>&gt; &gt; I think it is useful for designing, my observation about the experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt;<br>&gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt;     _TMSS,<br>&gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe, it generated by swiftc.exe.<br>&gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt;   With that .def, I could build the all-symbol-dllexported libswiftCore.dll.<br>&gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; <br>&gt; The _T symbols are emitted by the Swift compiler. You should modify swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage class when targeting Windows.<br>&gt; <br>&gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do this.<br>&gt;  <br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May 11, 2016 at 07:00:00am</p></header><div class="content"><p>Joe,<br></p><p>LLVM&#39;s MCJIT? Did you mean the REPL mode?<br></p><p>I&#39;m not ready to ask a question or understand the answer about them. Maybe<br>it takes some time for me to handle them.<br>Currently, I want to concentrate on the immediate mode, dynamic/static<br>linking on Windows (MSVC).<br></p><p>By the way, in Cygwin (although it uses similar ABI and the COFF format),<br>immediate mode and dynamic linking worked without the dll import/export<br>consideration, it was &#39;ld&#39;&#39;s magic. The immediate mode in Cygwin does not<br>work if dllimport is applied. (same to Windows(MSVC) )<br></p><p>I think we may consider for only MSVC, if the REPL in Cygwin works without<br>dllimport consideration.<br></p><p>-Han Sangjin<br></p><p>2016-05-10 2:06 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br></p><p>&gt;<br>&gt; &gt; On May 7, 2016, at 4:01 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; &gt;<br>&gt; &gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; &gt;<br>&gt; &gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt; &gt;   clang -o Hello.exe Hello.obj -llibswiftCore<br>&gt; -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; &gt;<br>&gt; &gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in<br>&gt; this example.<br>&gt; &gt;<br>&gt; &gt; But, we need the way to disable dllimport. The immediate mode did not<br>&gt; work.<br>&gt;<br>&gt; If it only affects immediate mode, this might be a problem with LLVM&#39;s<br>&gt; MCJIT. I would recommend asking llvm-dev, cc-ing Lang Hames (<br>&gt; lhames at apple.com), to see what the right thing to do to reference DLL<br>&gt; exports from JIT code is.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt;   swift Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>&gt; not be resolved!<br>&gt; &gt;<br>&gt; &gt;   swift -O Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; &gt;<br>&gt; &gt; It seems swift.exe call directly the function in the DLL without import<br>&gt; library.<br>&gt; &gt;<br>&gt; &gt; The feature also needed when we link to static library.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to<br>&gt; approach this problem.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt;<br>&gt; &gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt; &gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and<br>&gt; the driver for linking and many other part is not implemented. But dynamic<br>&gt; linking was possible with some trick.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I think it is useful for designing, my observation about the<br>&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt; &gt;     _TMSS,<br>&gt; &gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe,<br>&gt; it generated by swiftc.exe.<br>&gt; &gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It<br>&gt; extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt; libswiftCore.dll.<br>&gt; &gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; &gt;<br>&gt; &gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt; class when targeting Windows.<br>&gt; &gt;<br>&gt; &gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt; this.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Saleem Abdulrasool<br>&gt; &gt; compnerd (at) compnerd (dot) org<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160511/857d3af1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 3:11 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; <br>&gt; Joe,<br>&gt; <br>&gt; LLVM&#39;s MCJIT? Did you mean the REPL mode?<br></p><p>By immediate mode, do you mean &quot;swift foo.swift&quot;, where the script is immediately compiled and executed? That also uses MCJIT.<br></p><p>&gt; <br>&gt; I&#39;m not ready to ask a question or understand the answer about them. Maybe it takes some time for me to handle them.<br>&gt; Currently, I want to concentrate on the immediate mode, dynamic/static linking on Windows (MSVC).<br></p><p>I suspect that this is because of an LLVM bug in handling dllimport/export in JIT mode. Asking the LLVM list, you should at least be able to confirm this, and maybe get help from other LLVM users who&#39;ve run into similar issues.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; By the way, in Cygwin (although it uses similar ABI and the COFF format), immediate mode and dynamic linking worked without the dll import/export consideration, it was &#39;ld&#39;&#39;s magic. The immediate mode in Cygwin does not work if dllimport is applied. (same to Windows(MSVC) )<br>&gt; <br>&gt; I think we may consider for only MSVC, if the REPL in Cygwin works without dllimport consideration.<br>&gt; <br>&gt; -Han Sangjin<br>&gt; <br>&gt; 2016-05-10 2:06 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; <br>&gt; &gt; On May 7, 2016, at 4:01 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; &gt;<br>&gt; &gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; &gt;<br>&gt; &gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt; &gt;   clang -o Hello.exe Hello.obj -llibswiftCore -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; &gt;<br>&gt; &gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in this example.<br>&gt; &gt;<br>&gt; &gt; But, we need the way to disable dllimport. The immediate mode did not work.<br>&gt; <br>&gt; If it only affects immediate mode, this might be a problem with LLVM&#39;s MCJIT. I would recommend asking llvm-dev, cc-ing Lang Hames (lhames at apple.com), to see what the right thing to do to reference DLL exports from JIT code is.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt;   swift Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could not be resolved!<br>&gt; &gt;<br>&gt; &gt;   swift -O Hello.swift<br>&gt; &gt;   LLVM ERROR: Program used external function &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; &gt;<br>&gt; &gt; It seems swift.exe call directly the function in the DLL without import library.<br>&gt; &gt;<br>&gt; &gt; The feature also needed when we link to static library.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how to approach this problem.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt;<br>&gt; &gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt; &gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and the driver for linking and many other part is not implemented. But dynamic linking was possible with some trick.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I think it is useful for designing, my observation about the experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt; &gt;     _TMSS,<br>&gt; &gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt; &gt;   Some of above are dllexported by the macro, but _T* are not. Maybe, it generated by swiftc.exe.<br>&gt; &gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt; &gt;   With that .def, I could build the all-symbol-dllexported libswiftCore.dll.<br>&gt; &gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; &gt;<br>&gt; &gt; The _T symbols are emitted by the Swift compiler. You should modify swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage class when targeting Windows.<br>&gt; &gt;<br>&gt; &gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do this.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Saleem Abdulrasool<br>&gt; &gt; compnerd (at) compnerd (dot) org<br>&gt; &gt;<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May 11, 2016 at 07:00:00am</p></header><div class="content"><p>Yes, I ran &#39;swift Hello.swift&#39;. I didn&#39;t know there is MCJIT in that.<br>I&#39;ll ask and find the answer for it.<br></p><p>-Han Sangjin<br></p><p>2016-05-11 7:14 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br></p><p>&gt;<br>&gt; &gt; On May 10, 2016, at 3:11 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Joe,<br>&gt; &gt;<br>&gt; &gt; LLVM&#39;s MCJIT? Did you mean the REPL mode?<br>&gt;<br>&gt; By immediate mode, do you mean &quot;swift foo.swift&quot;, where the script is<br>&gt; immediately compiled and executed? That also uses MCJIT.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;m not ready to ask a question or understand the answer about them.<br>&gt; Maybe it takes some time for me to handle them.<br>&gt; &gt; Currently, I want to concentrate on the immediate mode, dynamic/static<br>&gt; linking on Windows (MSVC).<br>&gt;<br>&gt; I suspect that this is because of an LLVM bug in handling dllimport/export<br>&gt; in JIT mode. Asking the LLVM list, you should at least be able to confirm<br>&gt; this, and maybe get help from other LLVM users who&#39;ve run into similar<br>&gt; issues.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt;<br>&gt; &gt; By the way, in Cygwin (although it uses similar ABI and the COFF<br>&gt; format), immediate mode and dynamic linking worked without the dll<br>&gt; import/export consideration, it was &#39;ld&#39;&#39;s magic. The immediate mode in<br>&gt; Cygwin does not work if dllimport is applied. (same to Windows(MSVC) )<br>&gt; &gt;<br>&gt; &gt; I think we may consider for only MSVC, if the REPL in Cygwin works<br>&gt; without dllimport consideration.<br>&gt; &gt;<br>&gt; &gt; -Han Sangjin<br>&gt; &gt;<br>&gt; &gt; 2016-05-10 2:06 GMT+09:00 Joe Groff &lt;jgroff at apple.com&gt;:<br>&gt; &gt;<br>&gt; &gt; &gt; On May 7, 2016, at 4:01 PM, Sangjin Han &lt;tinysun.net at gmail.com&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Hi all,<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I merged Saleem&#39;s #2080 to my working branch, and did some experiment.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I could compile easily Hello.swift with #2080 merged one.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;   swiftc -c -o Hello.obj Hello.swift<br>&gt; &gt; &gt;   clang -o Hello.exe Hello.obj -llibswiftCore<br>&gt; -llibswiftSwiftOnoneSupport -Wl,&lt;some link options&gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Without #2080, I should use the *.ll-modifying-trick. It is perfect in<br>&gt; this example.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; But, we need the way to disable dllimport. The immediate mode did not<br>&gt; work.<br>&gt; &gt;<br>&gt; &gt; If it only affects immediate mode, this might be a problem with LLVM&#39;s<br>&gt; MCJIT. I would recommend asking llvm-dev, cc-ing Lang Hames (<br>&gt; lhames at apple.com), to see what the right thing to do to reference DLL<br>&gt; exports from JIT code is.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt;<br>&gt; &gt; &gt;   swift Hello.swift<br>&gt; &gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp_globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3&#39; which could<br>&gt; not be resolved!<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;   swift -O Hello.swift<br>&gt; &gt; &gt;   LLVM ERROR: Program used external function<br>&gt; &#39;__imp__swift_getExistentialTypeMetadata&#39; which could not be resolved!<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; It seems swift.exe call directly the function in the DLL without<br>&gt; import library.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The feature also needed when we link to static library.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I don&#39;t know about the SIL, IR, so it is thankful someone tell me how<br>&gt; to approach this problem.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; 2016-05-07 5:01 GMT+09:00 Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;:<br>&gt; &gt; &gt; On Thu, May 5, 2016 at 5:26 PM, Joe Groff via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; On May 5, 2016, at 4:18 PM, Sangjin Han via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Hi,<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; I made an experimental MSVC port. Of cause, dllimport/dllexport and<br>&gt; the driver for linking and many other part is not implemented. But dynamic<br>&gt; linking was possible with some trick.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; I think it is useful for designing, my observation about the<br>&gt; experimental building of libswiftCore.dll, libswiftSwiftOnoneSupport.dll<br>&gt; and linking of Hello.exe - its source has only &#39;print(&quot;Hello&quot;)&#39;.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; 1) SWIFT_RUNTIME_EXPORT was not enough for dllexport.<br>&gt; &gt; &gt; &gt;   Hello.obj needed defined in libswift*.dll<br>&gt; &gt; &gt; &gt;     _swift_getExistentialTypeMetadata,<br>&gt; &gt; &gt; &gt;     _TFs5printFTGSaP__9separatorSS10terminatorSS_T_,<br>&gt; &gt; &gt; &gt;     _TMSS,<br>&gt; &gt; &gt; &gt;     _TZvOs7Process5_argcVs5Int32,<br>&gt; &gt; &gt; &gt;     swift_bufferAllocate, ....<br>&gt; &gt; &gt; &gt;   Some of above are dllexported by the macro, but _T* are not.<br>&gt; Maybe, it generated by swiftc.exe.<br>&gt; &gt; &gt; &gt;   I used the utility &#39;dlltool.exe&#39; from Cygwin/MinGW world. It<br>&gt; extracts all symbols and generates &#39;allsymbol.def&#39;.<br>&gt; &gt; &gt; &gt;   With that .def, I could build the all-symbol-dllexported<br>&gt; libswiftCore.dll.<br>&gt; &gt; &gt; &gt;   (I&#39;m hoping we can build it without this trick.)<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The _T symbols are emitted by the Swift compiler. You should modify<br>&gt; swiftc&#39;s IRGen to generate public symbols with LLVM&#39;s &quot;dllexport&quot; storage<br>&gt; class when targeting Windows.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; https://github.com/apple/swift/pull/2080 is a first cut attempt to do<br>&gt; this.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; -Joe<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-dev mailing list<br>&gt; &gt; &gt; swift-dev at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; --<br>&gt; &gt; &gt; Saleem Abdulrasool<br>&gt; &gt; &gt; compnerd (at) compnerd (dot) org<br>&gt; &gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160511/262b86ba/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>On Tue, May 3, 2016 at 6:34 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 26, 2016, at 08:43, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;compnerd at compnerd.org<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I was playing around with the idea of swift and Windows since there<br>&gt;&gt;&gt; are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt;&gt;&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt;&gt;&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt;&gt;&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt;&gt;&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt;&gt;&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt;&gt;&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt;&gt;&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt;&gt;&gt; change from the exported storage to default if being built into a static<br>&gt;&gt;&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt;&gt;&gt; system so that we know whether a given SIL module is external or internal.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at<br>&gt;&gt;&gt; it.  Ive pushed the changes to<br>&gt;&gt;&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt;&gt;&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; However, as I expected, this is going to cause problems for building<br>&gt;&gt;&gt; some of the core libraries.  In particular, there are mismatches between<br>&gt;&gt;&gt; what gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt;&gt;&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt;&gt;&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt;&gt;&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt;&gt;&gt; calculating the correct DLL storage for the associated global values.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Playing around with this, I was trying to special case the building of<br>&gt;&gt;&gt; the standard library (as the runtime will be statically linked into it, the<br>&gt;&gt;&gt; symbols that it is expecting to be externally available are actually<br>&gt;&gt;&gt; private linkage.  Not hacking up the compiler like this causes issues since<br>&gt;&gt;&gt; there are inverse dependencies (swiftCore gets dllimport interfaces from<br>&gt;&gt;&gt; swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>&gt;&gt;&gt; problem is that we do not have a way to represent that in swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The easiest answer that seems to come to mind is to actually introduce<br>&gt;&gt;&gt; an attribute to indicate that an interface is part of a specific module and<br>&gt;&gt;&gt; assume that everything else is locally defined.  This would also<br>&gt;&gt;&gt; potentially allow us to handle things like @inline(always) @transparent<br>&gt;&gt;&gt; interfaces which get imported to ensure that a static inline function is<br>&gt;&gt;&gt; given local visibility rather than a DLL Import storage.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a<br>&gt;&gt;&gt; good way to determine what type of dll storage class a symbol should be<br>&gt;&gt;&gt; given (since currently, theres no way to determine if we will have a symbol<br>&gt;&gt;&gt; available locally or not when actually linking).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It seems to me, at least initially, that we need a way to treat<br>&gt;&gt;&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt;&gt;&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt;&gt;&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt;&gt;&gt; with them.  Am I confusing something there?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is there a preference on a means to handle this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The runtime is linked as part of the standard library, and its ABI<br>&gt;&gt;&gt; interface should be exported from libswiftCore.dylib/so/dll like the<br>&gt;&gt;&gt; standard library&#39;s. We should already mark up the ABI entry points with the<br>&gt;&gt;&gt; SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not<br>&gt;&gt;&gt; sufficient to expand these macros to __dllexport?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The definitions can be marked as __declspec(dllexport) but the compiler<br>&gt;&gt; generated references need to be dllimport for the wrapped runtime functions<br>&gt;&gt; (easy for the most part -- see my changes).  There&#39;s also the concern of<br>&gt;&gt; stubs for the aliases (via silgen_name).  Those are defined externally with<br>&gt;&gt; no indication that they are locally available and thus should have default<br>&gt;&gt; rather than dllimport storage.  Similar things for standard library<br>&gt;&gt; metadata (type, witness tables, etc).<br>&gt;&gt;<br>&gt;<br>&gt; A gentle reminder on this topic.  I would like to get something sorted out<br>&gt; so that we can try to get this resolved, preferably before the swift 3<br>&gt; release.<br>&gt;<br>&gt;<br>&gt; Just to chime in here (as asked by Saleem, um, a month ago) I think this<br>&gt; is the right way to go. We should handle the DLL-ish case (mark public<br>&gt; things ‘dllexport’ and references outside the Swift module ‘dllimport’),<br>&gt; and not worry about static linking (unnecessary dllimports).<br>&gt;<br>&gt; (It seems __declspec(dllexport) is exactly the same as LLVM ‘public’ vs<br>&gt; ‘hidden’—at least for Swift’s uses, even if that isn’t true generally.)<br>&gt;<br></p><p>Yeah, for the most part, they serve similar purposes.<br></p><p><br>&gt; We can then come back later and design / add some kind of “I know this<br>&gt; object file is going to be statically linked into the executable” mode,<br>&gt; which will drop all the dllexports. We’d also want to encode this flag into<br>&gt; the serialized “swiftmodule” files (a library’s public interface), so that<br>&gt; we know not to use dllimport for anything we use from there.<br>&gt;<br></p><p>Unfortunately, ATM, the runtime is compacted into the stdlib, which has the<br>small problem of making the stdlib have references to the runtime functions<br>as if it were being dynamically linked.  We *could* just assume that the<br>any time that the LLVM module name is &quot;Swift.*&quot; we are building the stdlib<br>and not mark the runtime functions for external (import) dll storage, but<br>this seems rather fragile.  The problem is that at IRGen time, we no longer<br>have access to  the SILModule (AFAIK), so we don&#39;t have a way to identify<br>if we are the stdlib or not.  Suggestions on how to handle that would be<br>appreciated.<br></p><p><br>&gt; Thanks for pushing on this!<br>&gt; Jordan<br>&gt;<br></p><p><br></p><p>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160511/ae809d64/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52752079730726d693332706c65540b8?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Sangjin Han</string> &lt;tinysun.net at gmail.com&gt;<p>May 12, 2016 at 02:00:00pm</p></header><div class="content"><p>I merged Saleem&#39;s recent #2080 in my repo, and tested the same.<br></p><p>Now I could build the libswiftCore.dll which can be used for Hello.swift.<br>No _TMSS errors were occurred.<br></p><p>&gt; Unfortunately, ATM, the runtime is compacted into the stdlib, which has<br>the small problem of making the stdlib have references to the runtime<br>functions as if it were being dynamically linked.<br></p><p>The linker complained with many warnings for this, but successfully linked<br>and can be ignored with option.<br></p><p>-Han Sangjin<br></p><p>2016-05-12 1:23 GMT+09:00 Saleem Abdulrasool via swift-dev &lt;<br>swift-dev at swift.org&gt;:<br></p><p>&gt; On Tue, May 3, 2016 at 6:34 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 26, 2016, at 08:43, Saleem Abdulrasool &lt;compnerd at compnerd.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 12, 2016 at 9:32 AM, Saleem Abdulrasool &lt;<br>&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Monday, April 11, 2016, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Apr 11, 2016, at 3:19 PM, Saleem Abdulrasool via swift-dev &lt;<br>&gt;&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; On Thu, Apr 7, 2016 at 2:12 PM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; On Wed, Apr 6, 2016 at 10:21 AM, Saleem Abdulrasool &lt;<br>&gt;&gt;&gt;&gt; compnerd at compnerd.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I was playing around with the idea of swift and Windows since there<br>&gt;&gt;&gt;&gt; are some interesting differences between COFF/PE and (ELF and MachO).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; PE/COFF does not directly address symbols in external modules<br>&gt;&gt;&gt;&gt; (DSOs/dylibs/DLLs).  Instead, there is an indirect addressing model (thunks<br>&gt;&gt;&gt;&gt; in Windows parlance).  Fortunately, LLVM has a nice way to model this:<br>&gt;&gt;&gt;&gt; GlobalValues have an associated &quot;DLLStorageClass&quot; which indicates whether<br>&gt;&gt;&gt;&gt; something is &quot;imported&quot; (provided by an external module), &quot;exported&quot;<br>&gt;&gt;&gt;&gt; (provided to external modules), or &quot;default&quot; (everything else).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Adjusting the IRGen to correctly annotate this part of the semantics<br>&gt;&gt;&gt;&gt; should get us part of the way to supporting swift on PE/COFF.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The thing to consider with this is that the DLL storage class is<br>&gt;&gt;&gt;&gt; dependent on how the module(s) are being built.  For example, something may<br>&gt;&gt;&gt;&gt; change from the exported storage to default if being built into a static<br>&gt;&gt;&gt;&gt; library rather than a shared object and is not meant to be re-exported.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Part of this information really needs to be threaded from the build<br>&gt;&gt;&gt;&gt; system so that we know whether a given SIL module is external or internal.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; To the DLL Storage semantics support, Ive taken a quick first stab at<br>&gt;&gt;&gt;&gt; it.  Ive pushed the changes to<br>&gt;&gt;&gt;&gt; https://github.com/compnerd/apple-swift/tree/dllstorage and created a<br>&gt;&gt;&gt;&gt; Pull Request at https://github.com/apple/swift/pull/2080 .<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; However, as I expected, this is going to cause problems for building<br>&gt;&gt;&gt;&gt; some of the core libraries.  In particular, there are mismatches between<br>&gt;&gt;&gt;&gt; what gets compiled and is desired.  The swiftStubs and swiftRuntime are<br>&gt;&gt;&gt;&gt; statically compiled and then merged into swiftCore.  There is also the<br>&gt;&gt;&gt;&gt; concern of the the support modules (e.g. Platform).  If there are stubs<br>&gt;&gt;&gt;&gt; that are being used (e.g. via _silgen_name) then there are issues with<br>&gt;&gt;&gt;&gt; calculating the correct DLL storage for the associated global values.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Playing around with this, I was trying to special case the building<br>&gt;&gt;&gt;&gt; of the standard library (as the runtime will be statically linked into it,<br>&gt;&gt;&gt;&gt; the symbols that it is expecting to be externally available are actually<br>&gt;&gt;&gt;&gt; private linkage.  Not hacking up the compiler like this causes issues since<br>&gt;&gt;&gt;&gt; there are inverse dependencies (swiftCore gets dllimport interfaces from<br>&gt;&gt;&gt;&gt; swiftRuntime, which has dependencies on swiftCore).  The crux of the<br>&gt;&gt;&gt;&gt; problem is that we do not have a way to represent that in swift.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The easiest answer that seems to come to mind is to actually<br>&gt;&gt;&gt;&gt; introduce an attribute to indicate that an interface is part of a specific<br>&gt;&gt;&gt;&gt; module and assume that everything else is locally defined.  This would also<br>&gt;&gt;&gt;&gt; potentially allow us to handle things like @inline(always) @transparent<br>&gt;&gt;&gt;&gt; interfaces which get imported to ensure that a static inline function is<br>&gt;&gt;&gt;&gt; given local visibility rather than a DLL Import storage.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Unfortunately, I believe that currently Im stuck as I do not have a<br>&gt;&gt;&gt;&gt; good way to determine what type of dll storage class a symbol should be<br>&gt;&gt;&gt;&gt; given (since currently, theres no way to determine if we will have a symbol<br>&gt;&gt;&gt;&gt; available locally or not when actually linking).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It seems to me, at least initially, that we need a way to treat<br>&gt;&gt;&gt;&gt; SwiftModule as a container (a la llvm::Module) and indicate which of the<br>&gt;&gt;&gt;&gt; TopLevelDecls are meant to be a single &quot;module&quot; (DSO, DLL, whatever you<br>&gt;&gt;&gt;&gt; want to call it) so that we can properly track the DLL storage associated<br>&gt;&gt;&gt;&gt; with them.  Am I confusing something there?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Is there a preference on a means to handle this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The runtime is linked as part of the standard library, and its ABI<br>&gt;&gt;&gt;&gt; interface should be exported from libswiftCore.dylib/so/dll like the<br>&gt;&gt;&gt;&gt; standard library&#39;s. We should already mark up the ABI entry points with the<br>&gt;&gt;&gt;&gt; SWIFT_RUNTIME_EXPORT and SWIFT_RUNTIME_STDLIB_INTERFACE macros. Is it not<br>&gt;&gt;&gt;&gt; sufficient to expand these macros to __dllexport?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The definitions can be marked as __declspec(dllexport) but the compiler<br>&gt;&gt;&gt; generated references need to be dllimport for the wrapped runtime functions<br>&gt;&gt;&gt; (easy for the most part -- see my changes).  There&#39;s also the concern of<br>&gt;&gt;&gt; stubs for the aliases (via silgen_name).  Those are defined externally with<br>&gt;&gt;&gt; no indication that they are locally available and thus should have default<br>&gt;&gt;&gt; rather than dllimport storage.  Similar things for standard library<br>&gt;&gt;&gt; metadata (type, witness tables, etc).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A gentle reminder on this topic.  I would like to get something sorted<br>&gt;&gt; out so that we can try to get this resolved, preferably before the swift 3<br>&gt;&gt; release.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Just to chime in here (as asked by Saleem, um, a month ago) I think this<br>&gt;&gt; is the right way to go. We should handle the DLL-ish case (mark public<br>&gt;&gt; things ‘dllexport’ and references outside the Swift module ‘dllimport’),<br>&gt;&gt; and not worry about static linking (unnecessary dllimports).<br>&gt;&gt;<br>&gt;&gt; (It seems __declspec(dllexport) is exactly the same as LLVM ‘public’ vs<br>&gt;&gt; ‘hidden’—at least for Swift’s uses, even if that isn’t true generally.)<br>&gt;&gt;<br>&gt;<br>&gt; Yeah, for the most part, they serve similar purposes.<br>&gt;<br>&gt;<br>&gt;&gt; We can then come back later and design / add some kind of “I know this<br>&gt;&gt; object file is going to be statically linked into the executable” mode,<br>&gt;&gt; which will drop all the dllexports. We’d also want to encode this flag into<br>&gt;&gt; the serialized “swiftmodule” files (a library’s public interface), so that<br>&gt;&gt; we know not to use dllimport for anything we use from there.<br>&gt;&gt;<br>&gt;<br>&gt; Unfortunately, ATM, the runtime is compacted into the stdlib, which has<br>&gt; the small problem of making the stdlib have references to the runtime<br>&gt; functions as if it were being dynamically linked.  We *could* just assume<br>&gt; that the any time that the LLVM module name is &quot;Swift.*&quot; we are building<br>&gt; the stdlib and not mark the runtime functions for external (import) dll<br>&gt; storage, but this seems rather fragile.  The problem is that at IRGen time,<br>&gt; we no longer have access to  the SILModule (AFAIK), so we don&#39;t have a way<br>&gt; to identify if we are the stdlib or not.  Suggestions on how to handle that<br>&gt; would be appreciated.<br>&gt;<br>&gt;<br>&gt;&gt; Thanks for pushing on this!<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160512/505604ed/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05d93b58565bbc562ecb20fc9f8e6009?s=50"></div><header><strong>swift (ABI) and Windows</strong> from <string>Paul Menage</string> &lt;paul at paulmenage.org&gt;<p>October  7, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, May 11, 2016 at 9:23 AM, Saleem Abdulrasool via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Unfortunately, ATM, the runtime is compacted into the stdlib, which has the<br>&gt; small problem of making the stdlib have references to the runtime functions<br>&gt; as if it were being dynamically linked.  We *could* just assume that the any<br>&gt; time that the LLVM module name is &quot;Swift.*&quot; we are building the stdlib and<br>&gt; not mark the runtime functions for external (import) dll storage, but this<br>&gt; seems rather fragile.  The problem is that at IRGen time, we no longer have<br>&gt; access to  the SILModule (AFAIK), so we don&#39;t have a way to identify if we<br>&gt; are the stdlib or not.  Suggestions on how to handle that would be<br>&gt; appreciated.<br></p><p>Experimenting with building for Windows-arm with MSVC, this approach<br>does work pretty well. But it seems hacky. Can we use<br>llvm::Module::addModuleFlag() to add a &quot;SwiftStdlib&quot; flag to the<br>module that the IRGenCode can check for?<br></p><p>Paul<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
