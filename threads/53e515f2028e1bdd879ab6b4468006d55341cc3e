<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Would it be possible to do the following:<br></p><p>â€¢ Have 1 group which are always used as identifiers.  This would probably be the identifiers from this proposal.<br></p><p>â€¢ Have a 2nd group which are always used as operators (quite a bit larger than the group proposed by this proposal).  At a minimum, the following ascii + set operators + math operators: <br>(Â± â‰  â‰¤ â‰¥ Â¿ Â¡ â„¢ Â¢ Â¶ â€¢ Â° Æ’ Â© âˆš âˆ† â—Š Â§ â‰ˆ  âˆ« Ã· Â¬ ).<br></p><p>â€¢ Everything else is in a 3rd group.  These can be used as identifiers unless they have been defined as an operator somewhere within the project, at which point they switch to being only usable as operators.  As long as the 2nd group is large enough, this shouldnâ€™t cause conflict issues too often.  It would prove useful to lots of subdomains (especially mathematicians).<br></p><p><br>Alternatively, we could just allow anything outside of the 2nd group to be an operator (including letter-like characters) as long as:<br>1) It is wrapped in parenthesis without spaces (âˆ†) or even (op)<br>2) It has been declared as an operator<br>3) It is not a keyword or otherwise taken<br></p><p>Taken to itâ€™s extreme, that might someday even allow anonymous operators.<br>let (Â©) = { lhs, rhs in â€¦}<br>let ans = a (Â©) b<br></p><p>Thoughts?  Is this possible?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 12:25 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; These can be used as identifiers unless they have been defined as an operator somewhere within the project, at which point they switch to being only usable as operators.<br></p><p>Imagine you&#39;re the compiler and you&#39;ve been handed this source file:<br></p><p>	let party = ðŸŽ‰ðŸŽ‚<br>	prefix operator ðŸŽ‰<br></p><p>You&#39;re going to see a keyword &quot;let&quot;, an identifier &quot;party&quot;, an &quot;=&quot; operator, and then the sequence &quot;ðŸŽ‰ðŸŽ‚&quot;. How will you interpret that sequence? There are a few possibilities:<br></p><p>1. A two-character variable named &quot;ðŸŽ‰ðŸŽ‚&quot;.<br>2. A prefix &quot;ðŸŽ‰&quot; operator followed by a one-character variable name &quot;ðŸŽ‚&quot;.<br>3. A two-character operator &quot;ðŸŽ‰ðŸŽ‚&quot; with an operand to follow on the next line.<br>4. A one-character variable name &quot;ðŸŽ‰&quot; followed by a postfix &quot;ðŸŽ‚&quot; operator.<br></p><p>The operator declaration on the next line will make all of this clearâ€”but we can&#39;t understand the next line until we&#39;ve parsed this line (see #3).<br></p><p>Now, one way around this would be to require all operator declarations to be at the top of the source file. But this would be very strange in Swift, which is otherwise completely insensitive to the order of statements in a declaration scope. And it leads to a strange two-phase behavior when parsing multiple files: You would need to parse each file through the end of its operator declarations before parsing any other code in any of the other files.<br></p><p>I don&#39;t think this is something we want to do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 4:02 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Oct 20, 2016, at 12:25 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; These can be used as identifiers unless they have been defined as an<br>&gt; operator somewhere within the project, at which point they switch to being<br>&gt; only usable as operators.<br>&gt;<br>&gt; Imagine you&#39;re the compiler and you&#39;ve been handed this source file:<br>&gt;<br>&gt;         let party = ðŸŽ‰ðŸŽ‚<br>&gt;         prefix operator ðŸŽ‰<br>&gt;<br>&gt; You&#39;re going to see a keyword &quot;let&quot;, an identifier &quot;party&quot;, an &quot;=&quot;<br>&gt; operator, and then the sequence &quot;ðŸŽ‰ðŸŽ‚&quot;. How will you interpret that<br>&gt; sequence? There are a few possibilities:<br>&gt;<br>&gt; 1. A two-character variable named &quot;ðŸŽ‰ðŸŽ‚&quot;.<br>&gt; 2. A prefix &quot;ðŸŽ‰&quot; operator followed by a one-character variable name &quot;ðŸŽ‚&quot;.<br>&gt; 3. A two-character operator &quot;ðŸŽ‰ðŸŽ‚&quot; with an operand to follow on the next<br>&gt; line.<br>&gt; 4. A one-character variable name &quot;ðŸŽ‰&quot; followed by a postfix &quot;ðŸŽ‚&quot; operator.<br>&gt;<br>&gt; The operator declaration on the next line will make all of this clearâ€”but<br>&gt; we can&#39;t understand the next line until we&#39;ve parsed this line (see #3).<br>&gt;<br></p><p>Nope. There is no scenario in which any of this is clarified by an operator<br>declaration, and certainly one that is not in the lexical scope. What would<br>happen is this:<br></p><p>1. At the LEXICAL level, the sequences ðŸŽ‰ðŸŽ‚ will be handled according to<br>the tokenization rules. If emojis are admitted in Swift, they are<br>definitely in the identifier space, so both of these are &quot;normal&quot;<br>identifiers.<br></p><p>2. At the parse level, no operator is in scope when you encounter the ðŸŽ‰ðŸŽ‚,<br>so it&#39;s simply an identifier.<br></p><p>3. At symbol resolution, no binding is found for that identifier, and an<br>error is raised.<br></p><p>Now let&#39;s consider real examples:<br></p><p>let c = a +++ b  /// +++ is a user infix operator<br></p><p><br>Fails, because +++ is not defined in the lexical scope.<br></p><p>func +++ (a, b) -&gt; int { ...}<br>...<br>let c = a +++ b<br></p><p><br>fails because this tokenizes as LET ident = ident ident ident, which is a<br>parse error. So how about:<br></p><p>func +++ (a, b) -&gt; int { ...}<br>...<br>let c = +++(a, b)<br></p><p><br>succeeds. Tokenizes as LET ident = ident ( ident, ident), which is a<br>function call. OK. Now how about;<br></p><p>infix operator +++ : *SomePrecedence*<br>...<br>let c = a +++ b<br></p><p><br>builds a parse tree in which +++ is bound in the lexical contour of<br>operator symbols, but fails because +++ is *not* bound in the lexical<br>contour of identifiers. What was needed was<br></p><p>func +++(a, b) -&gt; int { ... }<br>infix operator +++ : *SomePrecedence*<br>...<br>let c = a +++ b<br></p><p><br>THIS works. Builds an operator expression parse tree because +++ is bound<br>in the lexical contour of operator reserved words. Identifier resolution<br>then succeeds because +++ is *also* bound in the lexical contour of<br>identifiers.<br></p><p><br>But this would be very strange in Swift, which is otherwise completely<br>&gt; insensitive to the order of statements in a declaration scope. And it leads<br>&gt; to a strange two-phase behavior when parsing multiple files: You would need<br>&gt; to parse each file through the end of its operator declarations before<br>&gt; parsing any other code in any of the other files.<br></p><p><br>If I understand the language reference correctly, what you say is true<br>within a class definition, but not at file or local scope. Normal scopes<br>follow the normal rules for lexical contours. Member scopes have something<br>like the behavior you suggest, but the rules there are more complex than<br>you are describing.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/2231157a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 12:25 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Would it be possible to do the following:<br>&gt;<br>&gt; â€¢ Have 1 group which are always used as identifiers.  This would probably<br>&gt; be the identifiers from this proposal.<br>&gt;<br>&gt; â€¢ Have a 2nd group which are always used as operators (quite a bit larger<br>&gt; than the group proposed by this proposal).  At a minimum, the following<br>&gt; ascii + set operators + math operators:<br>&gt; (Â± â‰  â‰¤ â‰¥ Â¿ Â¡ â„¢ Â¢ Â¶ â€¢ Â° Æ’ Â© âˆš âˆ† â—Š Â§ â‰ˆ  âˆ« Ã· Â¬ ).<br>&gt;<br>&gt; â€¢ Everything else is in a 3rd group.<br></p><p><br>No. This is far, far too complicated, and it mixes up the layers of the<br>compilation process.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/a02f6694/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 5:03 PM, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 12:25 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Would it be possible to do the following:<br>&gt; <br>&gt; â€¢ Have 1 group which are always used as identifiers.  This would probably be the identifiers from this proposal.<br>&gt; <br>&gt; â€¢ Have a 2nd group which are always used as operators (quite a bit larger than the group proposed by this proposal).  At a minimum, the following ascii + set operators + math operators:<br>&gt; (Â± â‰  â‰¤ â‰¥ Â¿ Â¡ â„¢ Â¢ Â¶ â€¢ Â° Æ’ Â© âˆš âˆ† â—Š Â§ â‰ˆ  âˆ« Ã· Â¬ ).<br>&gt; <br>&gt; â€¢ Everything else is in a 3rd group. <br>&gt; <br>&gt; No. This is far, far too complicated, and it mixes up the layers of the compilation process.<br></p><p>Right.  Any proposal that changes parser behavior based on a visible operator declaration will break the ability for Swift to separately compile files.  This will have massive tooling ramifications that are almost certainly a non-starter.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/9c84294d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Just to play devilâ€™s advocate (since I am honestly ok with the less draconian form of the proposal now), wouldnâ€™t it be possible to declare the relevant unicode characters in the moduleâ€™s plist (or similar file)?  I know it isnâ€™t the most elegant solution, but it does move the bar on using those characters from impossible to possible, and it would no longer mix up the compilation layers.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Oct 24, 2016, at 10:10 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 20, 2016, at 5:03 PM, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Oct 20, 2016 at 12:25 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Would it be possible to do the following:<br>&gt;&gt; <br>&gt;&gt; â€¢ Have 1 group which are always used as identifiers.  This would probably be the identifiers from this proposal.<br>&gt;&gt; <br>&gt;&gt; â€¢ Have a 2nd group which are always used as operators (quite a bit larger than the group proposed by this proposal).  At a minimum, the following ascii + set operators + math operators:<br>&gt;&gt; (Â± â‰  â‰¤ â‰¥ Â¿ Â¡ â„¢ Â¢ Â¶ â€¢ Â° Æ’ Â© âˆš âˆ† â—Š Â§ â‰ˆ  âˆ« Ã· Â¬ ).<br>&gt;&gt; <br>&gt;&gt; â€¢ Everything else is in a 3rd group. <br>&gt;&gt; <br>&gt;&gt; No. This is far, far too complicated, and it mixes up the layers of the compilation process.<br>&gt; <br>&gt; Right.  Any proposal that changes parser behavior based on a visible operator declaration will break the ability for Swift to separately compile files.  This will have massive tooling ramifications that are almost certainly a non-starter.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/99df0164/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
