<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  1, 2016 at 01:00:00am</p></header><div class="content"><p>Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br></p><p>The Problem<br></p><p>It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>  let x, y : T<br>  let z = x + y<br></p><p>If T is a loadable type, this will generate SIL somewhat like this:<br> // %x and %y are values of type $T<br>%lhs = copy_value %x<br>%rhs = copy_value %y<br> %operator = function_ref T.+<br> %result = apply %operator(%lhs, %rhs)<br> %z = %result<br></p><p>(copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br></p><p>If T is an address-only type, this will generate SIL somewhat like this:<br>  // %x and %y are values of type $*T<br>  %z = alloc_stack $T<br>  %lhs = alloc_stack $T<br>  copy_addr %x to [initialization] %lhs<br>  %rhs = alloc_stack $T<br>  copy_addr %y to [initialization] %rhs<br>  %operator = function_ref T.+<br>  apply %operator(%z, %lhs, %rhs)<br>  dealloc_stack %rhs<br>  dealloc_stack %lhs<br></p><p>Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br></p><p>It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br></p><p>Addresses and address-only types<br></p><p>Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br></p><p>But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br></p><p>Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>  - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>  - The address of the value may need to be registered elsewhere, as with weak references.<br>  - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>Such types are necessarily address-only at a low level.<br></p><p>Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br></p><p>But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>  - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br>  - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>  - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br></p><p>Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br></p><p>All types as SIL scalars<br></p><p>The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br></p><p> // %value is a $T<br> %enum = enum #MyEnum.foo, %value : $T<br> %any = existential $Any, %enum<br> %fn = function_ref @bar<br>  apply %fn(%any)<br></p><p>If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br></p><p>Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br></p><p>This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br></p><p>However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br></p><p>  try_apply %someFunction() normal %cont, unwind %handler<br>cont(%value: $T):<br>  %enum = enum #MyEnum.foo, %value : $T<br>  %any = existential $Any, %enum<br>  %fn = function_ref @bar<br>  apply %fn(%any)<br>handler(%error: $Error):<br>  throw $error<br></p><p>Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br></p><p>In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br></p><p>Summary<br></p><p>Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>  - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>  - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161001/1d4efdf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October  3, 2016 at 09:00:00am</p></header><div class="content"><p>I feel like moving in this direction is the right thing to do. Some random comments below:<br></p><p>&gt; On Oct 1, 2016, at 1:32 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br>&gt; <br>&gt; The Problem<br>&gt; <br>&gt; It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>&gt;   let x, y : T<br>&gt;   let z = x + y<br>&gt; <br>&gt; If T is a loadable type, this will generate SIL somewhat like this:<br>&gt;  // %x and %y are values of type $T<br>&gt; %lhs = copy_value %x<br>&gt; %rhs = copy_value %y<br>&gt;  %operator = function_ref T.+<br>&gt;  %result = apply %operator(%lhs, %rhs)<br>&gt;  %z = %result<br>&gt; <br>&gt; (copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br>&gt; <br>&gt; If T is an address-only type, this will generate SIL somewhat like this:<br>&gt;   // %x and %y are values of type $*T<br>&gt;   %z = alloc_stack $T<br>&gt;   %lhs = alloc_stack $T<br>&gt;   copy_addr %x to [initialization] %lhs<br>&gt;   %rhs = alloc_stack $T<br>&gt;   copy_addr %y to [initialization] %rhs<br>&gt;   %operator = function_ref T.+<br>&gt;   apply %operator(%z, %lhs, %rhs)<br>&gt;   dealloc_stack %rhs<br>&gt;   dealloc_stack %lhs<br>&gt; <br>&gt; Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br>&gt; <br>&gt; It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br>&gt; <br>&gt; Addresses and address-only types<br>&gt; <br>&gt; Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br>&gt; <br>&gt; But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br>&gt; <br>&gt; Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>&gt;   - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>&gt;   - The address of the value may need to be registered elsewhere, as with weak references.<br>&gt;   - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>&gt; Such types are necessarily address-only at a low level.<br>&gt; <br>&gt; Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br>&gt; <br>&gt; But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>&gt;   - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br></p><p>Even if we want to accommodate ill-behaved C++ value types in the future, it seems to me that we could avoid penalizing the common case by making &quot;WellBehavedValueSemantics&quot; another opt-out type constraint, in the vein of &quot;Copyable&quot; in the move-only types model. If we do want to accommodate C++ types with semantically loaded move or copy operations in Swift, we&#39;ll probably want to make more C++-like guarantees about exactly when move, copy, and assign operations are performed on values of those types, but I don&#39;t think we want generic code to be subject to those constraints by default. If an address-only SIL representation ends up being fundamentally necessary to semantically model ill-behaved C++ types, we&#39;d also want to avoid having to emit the SIL for all generics that way.<br></p><p>&gt;   - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>&gt;   - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br></p><p>We had briefly discussed the possibility of giving &quot;owned&quot; and &quot;borrowed&quot; variants of a type different low-level representations. There are obvious complexities involved in making this a user-facing feature, but it might suffice to have an abstraction model that accommodates only two possibilities—either the owned and borrowed representations are the same, as for most POD or refcounted types, or the borrowed representation is a pointer to the owned representation for types with sharably mutable fields, such as weak references, atomics, mutexes, and so on. We could distinguish owned/borrowed in the SIL type system to make this possible.<br></p><p>&gt; Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br>&gt; <br>&gt; All types as SIL scalars<br>&gt; <br>&gt; The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br>&gt; <br>&gt;  // %value is a $T<br>&gt;  %enum = enum #MyEnum.foo, %value : $T<br>&gt;  %any = existential $Any, %enum<br>&gt;  %fn = function_ref @bar<br>&gt;   apply %fn(%any)<br>&gt; <br>&gt; If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br>&gt; <br>&gt; Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br>&gt; <br>&gt; This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br>&gt; <br>&gt; However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br>&gt; <br>&gt;   try_apply %someFunction() normal %cont, unwind %handler<br>&gt; cont(%value: $T):<br>&gt;   %enum = enum #MyEnum.foo, %value : $T<br>&gt;   %any = existential $Any, %enum<br>&gt;   %fn = function_ref @bar<br>&gt;   apply %fn(%any)<br>&gt; handler(%error: $Error):<br>&gt;   throw $error<br>&gt; <br>&gt; Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br></p><p>I think we can do a reasonable job of avoiding unnecessary moves in most injection cases. Perhaps we could keep the address-oriented SIL instructions around so that this late allocation pass can still be done in SIL (and thereby be subject to the correctness analyses we want to implement) instead of needing to be completely done on-the-fly in IRGen.<br></p><p>-Joe<br></p><p>&gt; In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br>&gt; <br>&gt; Summary<br>&gt; <br>&gt; Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>&gt;   - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>&gt;   - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 9:22 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I feel like moving in this direction is the right thing to do. Some random comments below:<br>&gt; <br>&gt;&gt; On Oct 1, 2016, at 1:32 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br>&gt;&gt; <br>&gt;&gt; The Problem<br>&gt;&gt; <br>&gt;&gt; It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>&gt;&gt;  let x, y : T<br>&gt;&gt;  let z = x + y<br>&gt;&gt; <br>&gt;&gt; If T is a loadable type, this will generate SIL somewhat like this:<br>&gt;&gt; // %x and %y are values of type $T<br>&gt;&gt; %lhs = copy_value %x<br>&gt;&gt; %rhs = copy_value %y<br>&gt;&gt; %operator = function_ref T.+<br>&gt;&gt; %result = apply %operator(%lhs, %rhs)<br>&gt;&gt; %z = %result<br>&gt;&gt; <br>&gt;&gt; (copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br>&gt;&gt; <br>&gt;&gt; If T is an address-only type, this will generate SIL somewhat like this:<br>&gt;&gt;  // %x and %y are values of type $*T<br>&gt;&gt;  %z = alloc_stack $T<br>&gt;&gt;  %lhs = alloc_stack $T<br>&gt;&gt;  copy_addr %x to [initialization] %lhs<br>&gt;&gt;  %rhs = alloc_stack $T<br>&gt;&gt;  copy_addr %y to [initialization] %rhs<br>&gt;&gt;  %operator = function_ref T.+<br>&gt;&gt;  apply %operator(%z, %lhs, %rhs)<br>&gt;&gt;  dealloc_stack %rhs<br>&gt;&gt;  dealloc_stack %lhs<br>&gt;&gt; <br>&gt;&gt; Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br>&gt;&gt; <br>&gt;&gt; It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br>&gt;&gt; <br>&gt;&gt; Addresses and address-only types<br>&gt;&gt; <br>&gt;&gt; Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br>&gt;&gt; <br>&gt;&gt; But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br>&gt;&gt; <br>&gt;&gt; Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>&gt;&gt;  - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>&gt;&gt;  - The address of the value may need to be registered elsewhere, as with weak references.<br>&gt;&gt;  - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>&gt;&gt; Such types are necessarily address-only at a low level.<br>&gt;&gt; <br>&gt;&gt; Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br>&gt;&gt; <br>&gt;&gt; But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>&gt;&gt;  - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br>&gt; <br>&gt; Even if we want to accommodate ill-behaved C++ value types in the future, it seems to me that we could avoid penalizing the common case by making &quot;WellBehavedValueSemantics&quot; another opt-out type constraint, in the vein of &quot;Copyable&quot; in the move-only types model. If we do want to accommodate C++ types with semantically loaded move or copy operations in Swift, we&#39;ll probably want to make more C++-like guarantees about exactly when move, copy, and assign operations are performed on values of those types, but I don&#39;t think we want generic code to be subject to those constraints by default. If an address-only SIL representation ends up being fundamentally necessary to semantically model ill-behaved C++ types, we&#39;d also want to avoid having to emit the SIL for all generics that way.<br></p><p>I completely agree that we&#39;ll need to ask non-value-semantics C++ types to opt out explicitly in some way.  That wasn&#39;t what I had in mind here, though.<br></p><p>My concern is about types that provide a consistent view of their abstract &quot;value&quot; but implement that in ways that change storage; as one example, a pre-C++11 type for which moves are actually implemented as copies.  We would not want to e.g. assume that we can read a property, move the value, and then rely on the old load still being valid.<br></p><p>Generic code should be fine regardless, since the optimizer can&#39;t make assumptions about abstractly-implemented properties.<br></p><p>&gt;&gt;  - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>&gt;&gt;  - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br>&gt; <br>&gt; We had briefly discussed the possibility of giving &quot;owned&quot; and &quot;borrowed&quot; variants of a type different low-level representations. There are obvious complexities involved in making this a user-facing feature, but it might suffice to have an abstraction model that accommodates only two possibilities—either the owned and borrowed representations are the same, as for most POD or refcounted types, or the borrowed representation is a pointer to the owned representation for types with sharably mutable fields, such as weak references, atomics, mutexes, and so on. We could distinguish owned/borrowed in the SIL type system to make this possible.<br></p><p>Yeah, this is something I&#39;m still tossing around in my mind.  The problem is tuples; is a borrowed tuple a tuple of borrows or just that same rule applied to the aggregate?  The latter doesn&#39;t handle any sort of translation we might want to do.<br></p><p>&gt;&gt; Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br>&gt;&gt; <br>&gt;&gt; All types as SIL scalars<br>&gt;&gt; <br>&gt;&gt; The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br>&gt;&gt; <br>&gt;&gt; // %value is a $T<br>&gt;&gt; %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt; %any = existential $Any, %enum<br>&gt;&gt; %fn = function_ref @bar<br>&gt;&gt;  apply %fn(%any)<br>&gt;&gt; <br>&gt;&gt; If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br>&gt;&gt; <br>&gt;&gt; Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br>&gt;&gt; <br>&gt;&gt; This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br>&gt;&gt; <br>&gt;&gt; However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br>&gt;&gt; <br>&gt;&gt;  try_apply %someFunction() normal %cont, unwind %handler<br>&gt;&gt; cont(%value: $T):<br>&gt;&gt;  %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt;  %any = existential $Any, %enum<br>&gt;&gt;  %fn = function_ref @bar<br>&gt;&gt;  apply %fn(%any)<br>&gt;&gt; handler(%error: $Error):<br>&gt;&gt;  throw $error<br>&gt;&gt; <br>&gt;&gt; Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br>&gt; <br>&gt; I think we can do a reasonable job of avoiding unnecessary moves in most injection cases. Perhaps we could keep the address-oriented SIL instructions around so that this late allocation pass can still be done in SIL (and thereby be subject to the correctness analyses we want to implement) instead of needing to be completely done on-the-fly in IRGen.<br></p><p>Yeah, this is probably the right thing to do.  We would probably want to introduce a new phase so that ordinary optimizations can assume away the address-oriented SIL instructions; it&#39;s not clear to me that they work well with a stricter, higher-level SIL, since otherwise I think we can mostly define away uninitialized memory.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br>&gt;&gt; <br>&gt;&gt; Summary<br>&gt;&gt; <br>&gt;&gt; Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>&gt;&gt;  - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>&gt;&gt;  - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>October  3, 2016 at 03:00:00pm</p></header><div class="content"><p>When I first started reading this proposal, my primary objection was going to be that SSA doesn’t seem to really jive well with the idea of values becoming (in)valid at some point in the future (due to moves). You can see this in the definite-init pass, which it works entirely with addresses to handle the idea of a value which becomes assigned “eventually”. But if SIL’s notion of SSA can be extended to handle these problems, this sounds great!<br></p><p>It’s not clear to me how this would work though. How does an optimization pass reason about an SSA register becoming invalid because it was moved out of? Or rather: in what ways do the interesting properties of SSA survive passes needing to handle this? Is this a standard extension that’s been researched/implemented before?<br></p><p>&gt; On Oct 1, 2016, at 4:32 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br>&gt; <br>&gt; The Problem<br>&gt; <br>&gt; It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>&gt;   let x, y : T<br>&gt;   let z = x + y<br>&gt; <br>&gt; If T is a loadable type, this will generate SIL somewhat like this:<br>&gt;  // %x and %y are values of type $T<br>&gt; %lhs = copy_value %x<br>&gt; %rhs = copy_value %y<br>&gt;  %operator = function_ref T.+<br>&gt;  %result = apply %operator(%lhs, %rhs)<br>&gt;  %z = %result<br>&gt; <br>&gt; (copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br>&gt; <br>&gt; If T is an address-only type, this will generate SIL somewhat like this:<br>&gt;   // %x and %y are values of type $*T<br>&gt;   %z = alloc_stack $T<br>&gt;   %lhs = alloc_stack $T<br>&gt;   copy_addr %x to [initialization] %lhs<br>&gt;   %rhs = alloc_stack $T<br>&gt;   copy_addr %y to [initialization] %rhs<br>&gt;   %operator = function_ref T.+<br>&gt;   apply %operator(%z, %lhs, %rhs)<br>&gt;   dealloc_stack %rhs<br>&gt;   dealloc_stack %lhs<br>&gt; <br>&gt; Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br>&gt; <br>&gt; It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br>&gt; <br>&gt; Addresses and address-only types<br>&gt; <br>&gt; Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br>&gt; <br>&gt; But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br>&gt; <br>&gt; Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>&gt;   - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>&gt;   - The address of the value may need to be registered elsewhere, as with weak references.<br>&gt;   - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>&gt; Such types are necessarily address-only at a low level.<br>&gt; <br>&gt; Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br>&gt; <br>&gt; But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>&gt;   - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br>&gt;   - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>&gt;   - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br>&gt; <br>&gt; Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br>&gt; <br>&gt; All types as SIL scalars<br>&gt; <br>&gt; The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br>&gt; <br>&gt;  // %value is a $T<br>&gt;  %enum = enum #MyEnum.foo, %value : $T<br>&gt;  %any = existential $Any, %enum<br>&gt;  %fn = function_ref @bar<br>&gt;   apply %fn(%any)<br>&gt; <br>&gt; If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br>&gt; <br>&gt; Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br>&gt; <br>&gt; This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br>&gt; <br>&gt; However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br>&gt; <br>&gt;   try_apply %someFunction() normal %cont, unwind %handler<br>&gt; cont(%value: $T):<br>&gt;   %enum = enum #MyEnum.foo, %value : $T<br>&gt;   %any = existential $Any, %enum<br>&gt;   %fn = function_ref @bar<br>&gt;   apply %fn(%any)<br>&gt; handler(%error: $Error):<br>&gt;   throw $error<br>&gt; <br>&gt; Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br>&gt; <br>&gt; In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br>&gt; <br>&gt; Summary<br>&gt; <br>&gt; Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>&gt;   - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>&gt;   - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161003/5d8c8738/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>October  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 12:10 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; When I first started reading this proposal, my primary objection was going to be that SSA doesn’t seem to really jive well with the idea of values becoming (in)valid at some point in the future (due to moves). You can see this in the definite-init pass, which it works entirely with addresses to handle the idea of a value which becomes assigned “eventually”. But if SIL’s notion of SSA can be extended to handle these problems, this sounds great!<br>&gt; <br>&gt; It’s not clear to me how this would work though. How does an optimization pass reason about an SSA register becoming invalid because it was moved out of? Or rather: in what ways do the interesting properties of SSA survive passes needing to handle this? Is this a standard extension that’s been researched/implemented before?<br></p><p>I think that’s why John claimed that we need to enforce “pseudo-linear” SIL values types. Moving out of an SSA value must be the last use of that value. SIL will enforce this single-consumer property throughout.<br></p><p>-Andy<br></p><p>&gt; <br>&gt;&gt; On Oct 1, 2016, at 4:32 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br>&gt;&gt; <br>&gt;&gt; The Problem<br>&gt;&gt; <br>&gt;&gt; It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>&gt;&gt;   let x, y : T<br>&gt;&gt;   let z = x + y<br>&gt;&gt; <br>&gt;&gt; If T is a loadable type, this will generate SIL somewhat like this:<br>&gt;&gt;  // %x and %y are values of type $T<br>&gt;&gt; %lhs = copy_value %x<br>&gt;&gt; %rhs = copy_value %y<br>&gt;&gt;  %operator = function_ref T.+<br>&gt;&gt;  %result = apply %operator(%lhs, %rhs)<br>&gt;&gt;  %z = %result<br>&gt;&gt; <br>&gt;&gt; (copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br>&gt;&gt; <br>&gt;&gt; If T is an address-only type, this will generate SIL somewhat like this:<br>&gt;&gt;   // %x and %y are values of type $*T<br>&gt;&gt;   %z = alloc_stack $T<br>&gt;&gt;   %lhs = alloc_stack $T<br>&gt;&gt;   copy_addr %x to [initialization] %lhs<br>&gt;&gt;   %rhs = alloc_stack $T<br>&gt;&gt;   copy_addr %y to [initialization] %rhs<br>&gt;&gt;   %operator = function_ref T.+<br>&gt;&gt;   apply %operator(%z, %lhs, %rhs)<br>&gt;&gt;   dealloc_stack %rhs<br>&gt;&gt;   dealloc_stack %lhs<br>&gt;&gt; <br>&gt;&gt; Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br>&gt;&gt; <br>&gt;&gt; It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br>&gt;&gt; <br>&gt;&gt; Addresses and address-only types<br>&gt;&gt; <br>&gt;&gt; Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br>&gt;&gt; <br>&gt;&gt; But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br>&gt;&gt; <br>&gt;&gt; Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>&gt;&gt;   - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>&gt;&gt;   - The address of the value may need to be registered elsewhere, as with weak references.<br>&gt;&gt;   - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>&gt;&gt; Such types are necessarily address-only at a low level.<br>&gt;&gt; <br>&gt;&gt; Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br>&gt;&gt; <br>&gt;&gt; But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>&gt;&gt;   - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br>&gt;&gt;   - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>&gt;&gt;   - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br>&gt;&gt; <br>&gt;&gt; Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br>&gt;&gt; <br>&gt;&gt; All types as SIL scalars<br>&gt;&gt; <br>&gt;&gt; The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br>&gt;&gt; <br>&gt;&gt;  // %value is a $T<br>&gt;&gt;  %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt;  %any = existential $Any, %enum<br>&gt;&gt;  %fn = function_ref @bar<br>&gt;&gt;   apply %fn(%any)<br>&gt;&gt; <br>&gt;&gt; If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br>&gt;&gt; <br>&gt;&gt; Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br>&gt;&gt; <br>&gt;&gt; This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br>&gt;&gt; <br>&gt;&gt; However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br>&gt;&gt; <br>&gt;&gt;   try_apply %someFunction() normal %cont, unwind %handler<br>&gt;&gt; cont(%value: $T):<br>&gt;&gt;   %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt;   %any = existential $Any, %enum<br>&gt;&gt;   %fn = function_ref @bar<br>&gt;&gt;   apply %fn(%any)<br>&gt;&gt; handler(%error: $Error):<br>&gt;&gt;   throw $error<br>&gt;&gt; <br>&gt;&gt; Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br>&gt;&gt; <br>&gt;&gt; In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br>&gt;&gt; <br>&gt;&gt; Summary<br>&gt;&gt; <br>&gt;&gt; Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>&gt;&gt;   - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>&gt;&gt;   - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161003/542c3432/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Representing &quot;address-only&quot; values in SIL</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October  3, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 3, 2016, at 1:37 PM, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt;&gt; On Oct 3, 2016, at 12:10 PM, Alexis via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When I first started reading this proposal, my primary objection was going to be that SSA doesn’t seem to really jive well with the idea of values becoming (in)valid at some point in the future (due to moves). You can see this in the definite-init pass, which it works entirely with addresses to handle the idea of a value which becomes assigned “eventually”. But if SIL’s notion of SSA can be extended to handle these problems, this sounds great!<br>&gt;&gt; <br>&gt;&gt; It’s not clear to me how this would work though. How does an optimization pass reason about an SSA register becoming invalid because it was moved out of? Or rather: in what ways do the interesting properties of SSA survive passes needing to handle this? Is this a standard extension that’s been researched/implemented before?<br>&gt; <br>&gt; I think that’s why John claimed that we need to enforce “pseudo-linear” SIL values types. Moving out of an SSA value must be the last use of that value. SIL will enforce this single-consumer property throughout.<br></p><p>Precisely.  SSA is already subject to a number of non-trivial formation rules, such as the rule that you can only refer to dominating values.  And SIL already adds a number of rules to that, such as the rule that alloc_stacks have to be statically nested.  I don&#39;t think pseudo-linearity is a problematic extension to that set of rules.<br></p><p>It is, of course, an expressivity limitation on SIL — there will always be cases where you could *prove* correctness but it&#39;s not *structurally valid*.  But that&#39;s true of the SSA dominance restriction as well.<br></p><p>John.<br></p><p>&gt; <br>&gt; -Andy<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 1, 2016, at 4:32 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andy Trick and I had this conversation Thursday, and I thought I&#39;d capture it here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s a longstanding complaint that SIL uses drastically different code patterns for the same sequence of operations based on whether the types of the values involved are loadable or &quot;address-only&quot;.  For example, suppose I have Swift code like this:<br>&gt;&gt;&gt;   let x, y : T<br>&gt;&gt;&gt;   let z = x + y<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If T is a loadable type, this will generate SIL somewhat like this:<br>&gt;&gt;&gt;  // %x and %y are values of type $T<br>&gt;&gt;&gt; %lhs = copy_value %x<br>&gt;&gt;&gt; %rhs = copy_value %y<br>&gt;&gt;&gt;  %operator = function_ref T.+<br>&gt;&gt;&gt;  %result = apply %operator(%lhs, %rhs)<br>&gt;&gt;&gt;  %z = %result<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (copy_value doesn&#39;t currently exist, but it&#39;s easier to understand, and as it happens we&#39;re thinking of adding it back.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If T is an address-only type, this will generate SIL somewhat like this:<br>&gt;&gt;&gt;   // %x and %y are values of type $*T<br>&gt;&gt;&gt;   %z = alloc_stack $T<br>&gt;&gt;&gt;   %lhs = alloc_stack $T<br>&gt;&gt;&gt;   copy_addr %x to [initialization] %lhs<br>&gt;&gt;&gt;   %rhs = alloc_stack $T<br>&gt;&gt;&gt;   copy_addr %y to [initialization] %rhs<br>&gt;&gt;&gt;   %operator = function_ref T.+<br>&gt;&gt;&gt;   apply %operator(%z, %lhs, %rhs)<br>&gt;&gt;&gt;   dealloc_stack %rhs<br>&gt;&gt;&gt;   dealloc_stack %lhs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Notably, we&#39;re explicitly modeling the memory in which values are stored, which is both very verbose and — more importantly — loses any interesting SSA properties for tracking actual values around.  And this has a bunch of secondary effects where various high-level operations like dynamic casts end up needing two different instructions based on whether the value is stored in memory.  This is pretty dumb, and it&#39;s a major contributor to the reality that generic code is currently very poorly optimized.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It does, however, have some significant advantages: since the memory allocation is explicit, it&#39;s quite natural to express optimizations that e.g. hoist or sink those allocations, and the next level of lowering (IRGen) can be very simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addresses and address-only types<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is an imperative language, and imperative languages make formal memory locations part of the high-level semantics.  DI and SSA formation allow us to eliminate formal memory locations for most local variables, but class properties, global variables, escaped local variables, and pointers are all fundamentally un-SSA-able.  Therefore we will always have some concept of an address.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But most values of address-only type aren&#39;t really being stored in that sort of formal memory location; we&#39;re just representing them that way in SIL.  Why do we do this?  What is it about a type that makes it address-only?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, some types are inherently &quot;memory-pinned&quot;: something about their representation only makes sense, or is only implementable, if the value is always kept in memory:<br>&gt;&gt;&gt;   - The representation of the value may involve interior pointers, as with LLVM&#39;s SmallVector.  This isn&#39;t currently a thing in Swift, but it&#39;s a possibility someday with the import of non-POD C++ types.<br>&gt;&gt;&gt;   - The address of the value may need to be registered elsewhere, as with weak references.<br>&gt;&gt;&gt;   - The value may allow internal mutation even from a shared reference, like a C++ class with a mutable field or a Rust atomic type; you can see weak references as analogous to this.<br>&gt;&gt;&gt; Such types are necessarily address-only at a low level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other types are address-only by abstraction: their representation isn&#39;t (fully) known, and so they have to be kept in memory (1) in case that representation includes another address-only value and (2) because there&#39;s no way to store a unbounded amount of data except in memory anyway.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But this sense of address-only types that we&#39;re describing is really a property of the final generated code.  It&#39;s necessary for LLVM IR generation to know about it, but it&#39;s not obviously necessary for SIL to know about it beyond the implications of the inherently memory-pinned cases above:<br>&gt;&gt;&gt;   - it is not generally safe to assume that the stored properties of a non-POD C++ type remain invariant across moves<br>&gt;&gt;&gt;   - weak references *do* represent the same value across moves, but of course that value can change dynamically at any time anyway, per the rules of weak references<br>&gt;&gt;&gt;   - mutable fields can be modified even by a shared borrowed reference, and so (if they are modeled at all in SIL at all, rather than just leaving the type opaque) there must be some way to project a mutable address from a shared borrow and so on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our current representation of address-only types arises directly from the low-level operations that are required, which does admit some interesting optimizations on its own, but the disadvantages of having to support wildly divergent code paths and completely give up SSA use/def chains are crippling.  What would SIL look like if we abandoned this entirely?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All types as SIL scalars<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fundamental issue here is that IR-level lowering does need to place memory-pinned values into memory.  Suppose we take a value, use it as an enum case payload, inject that enum into an Any, and pass that to a function.  In a future world where we consistently SSA all local values, this ideally looks something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  // %value is a $T<br>&gt;&gt;&gt;  %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt;&gt;  %any = existential $Any, %enum<br>&gt;&gt;&gt;  %fn = function_ref @bar<br>&gt;&gt;&gt;   apply %fn(%any)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If all of these types were loadable, lowering this to IR doesn&#39;t impose any abstraction costs, because we can just manipulate it as a bit-pattern in memory, which LLVM (really, any reasonable compiler infrastructure) should be quite good at analyzing and optimizing.  But if all of these types are address-only, that&#39;s not obviously true.  Let&#39;s look at the details of lowering to memory.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because all types are movable — even in a world with Rust-style ownership — there&#39;s a fairly straightforward lowering that works for all possible functions: every address-only SIL value gets its own allocation which is deallocated along the dominance frontier of the value.  Indirect arguments use the passed-in buffer.  Basic block arguments are copied from the allocation for the branch argument value to the allocation for the corresponding destination block parameter.  Indirect return values are copied from the allocation for the return value to the pointer passed in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This admits some obvious optimizations.  If &quot;owned&quot; SIL values are pseudo-linear — i.e. along every path from their definition point, it is statically evident that they are (optionally) borrowed multiple times, consumed exactly once, and then never used again — then the copies can instead be moves.  Standard register-allocation algorithms can recognize when basic block parameters can use the same location as their arguments.  SIL only permits a single return instruction, so there&#39;s no reason not to allocate returned values directly into the return slot.  These optimizations will tend to eliminate a lot of moves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, there&#39;s another problem, which is injections.  Consider the example above.  %any is an opaque existential, and initializing it formally involves allocating a buffer within the existential and moving the argument into that buffer.  Ideally, we would allocate that buffer first and then simply allocate %enum in-place into that buffer.  In this simple example, that&#39;s easy.  But if the control flow were more complex, detecting that this is possible becomes significantly more challenging, as does ensuring that the buffer is properly cleaned up along all paths.  For example, suppose that %value were computed by calling a throwing function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   try_apply %someFunction() normal %cont, unwind %handler<br>&gt;&gt;&gt; cont(%value: $T):<br>&gt;&gt;&gt;   %enum = enum #MyEnum.foo, %value : $T<br>&gt;&gt;&gt;   %any = existential $Any, %enum<br>&gt;&gt;&gt;   %fn = function_ref @bar<br>&gt;&gt;&gt;   apply %fn(%any)<br>&gt;&gt;&gt; handler(%error: $Error):<br>&gt;&gt;&gt;   throw $error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Naive allocation here is going to introduce a lot of moves.  Optimally, we would receive the return value from %someFunction directly in the payload of %enum, which we want to build directly into the allocated existential buffer of %any.  But to do this, we actually need to allocate that existential buffer before executing the try_apply; and if the try_apply throws, we need to deallocate that existential buffer in the handler block.  The need to retroactively insert this kind of clean-up code adds a lot of complexity to this allocation approach.  Moreover, it&#39;s quite possible that complex intermediate control — for example, if there&#39;s a loop somewhere between the definition of a value and its consuming use — will tend to block this kind of analysis and cause more unnecessary moves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In contrast, the current SIL-generation scheme tends to be aware of at least the immediate local uses of values and therefore emits a lot of these kinds of initialization &quot;in-place&quot; already.  But that said, it does proceed from a simple recursive examination of the AST, which means it will miss examples that are just slightly more opaque, like binding a return value as a let and only then returning it.  That kind of thing is currently left to the optimizer for no real good reason.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Summary<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall, I think representing local address-only values as SIL scalars with full SSA use/def chains is really promising, and I do think we can write an allocation pass that does an acceptable job eliminating unnecessary moves.  In order to actually do this, though, I think we need two things:<br>&gt;&gt;&gt;   - We need SIL to be &quot;pseudo-linear&quot; as discussed above.  We really don&#39;t want the allocation pass to have to worry about keeping values alive past consumptions, and thus potentially having to insert copies instead of moves.<br>&gt;&gt;&gt;   - We need the allocation pass to handle exits before initialization (like with try_apply) and other sorts of interfering control flow.  It will not be acceptable for this to be a block-local analysis with only a trivial amount of cross-block argument merging.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161003/8a69dc22/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
