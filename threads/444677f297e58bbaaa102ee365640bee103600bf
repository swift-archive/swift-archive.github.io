<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 24, 2016 at 06:00:00pm</p></header><div class="content"><p>One thing that I see a lot in code, and sometimes have to stop myself from doing, is using shorthand array types, such as [Foo], in function declarations where CollectionType could just as easily be used. For example, the following two declarations can take collections of values, but the first will only take them in the form of an Array:<br></p><p>	func doSomething(values:[Foo]) { … }<br>	func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C) { … }<br></p><p>The latter form is something that new users of Swift tend not to know they can do, and which even experienced Swift developers may not use for the sake of brevity, but it can come up quite a lot. What I’d like to propose is that [Foo], when used in a function, should produce the latter form behind the scenes, requiring the developer to specify Array&lt;Foo&gt; if they actually need it to be an Array for some reason. Though this would become inconsistent with variables/properties which would still have to be Array&lt;Foo&gt; since a type is required.<br></p><p><br>An alternative would be if we could specify protocol generics in a more succinct form, for example:<br></p><p>	func doSomething(values:Collection&lt;Foo&gt;) { … }<br>	func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are linear anyway so could just as easily take sequences<br></p><p>Note: This would not be the same as type-erased wrappers such as AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where Generator.Element:Foo&quot;<br></p><p><br></p><p>In essence I’m hoping to discuss whether we should try to remove the temptation to limit functions to arrays only or not, or if there are other ways to encourage more use of sequence and collection for flexibility; I try wherever possible to have my methods take sequences if they can, and only take collections if they need to (and never arrays only), but I can understand why not everyone does this, as it’s not the friendliest thing to add and declaring [Foo] looks so much neater.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/444600bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 24, 2016 at 10:00:00pm</p></header><div class="content"><p>I don’t see much usefulness in this shorthand.<br></p><p>&gt; On 24 May 2016, at 19:57, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One thing that I see a lot in code, and sometimes have to stop myself from doing, is using shorthand array types, such as [Foo], in function declarations where CollectionType could just as easily be used. For example, the following two declarations can take collections of values, but the first will only take them in the form of an Array:<br>&gt; <br>&gt; 	func doSomething(values:[Foo]) { … }<br>&gt; 	func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C) { … }<br>&gt; <br>&gt; The latter form is something that new users of Swift tend not to know they can do, and which even experienced Swift developers may not use for the sake of brevity, but it can come up quite a lot. What I’d like to propose is that [Foo], when used in a function, should produce the latter form behind the scenes, requiring the developer to specify Array&lt;Foo&gt; if they actually need it to be an Array for some reason. Though this would become inconsistent with variables/properties which would still have to be Array&lt;Foo&gt; since a type is required.<br>&gt; <br>&gt; <br>&gt; An alternative would be if we could specify protocol generics in a more succinct form, for example:<br>&gt; <br>&gt; 	func doSomething(values:Collection&lt;Foo&gt;) { … }<br>&gt; 	func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are linear anyway so could just as easily take sequences<br>&gt; <br>&gt; Note: This would not be the same as type-erased wrappers such as AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where Generator.Element:Foo&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; In essence I’m hoping to discuss whether we should try to remove the temptation to limit functions to arrays only or not, or if there are other ways to encourage more use of sequence and collection for flexibility; I try wherever possible to have my methods take sequences if they can, and only take collections if they need to (and never arrays only), but I can understand why not everyone does this, as it’s not the friendliest thing to add and declaring [Foo] looks so much neater.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/a8c9480b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 24, 2016 at 05:00:00pm</p></header><div class="content"><p>My first question here would be &quot;what&#39;s the gain?&quot; I understand<br>CollectionTypes and arrays may be something different but I myself<br>admit I don&#39;t know and wonder how that change would be a benefit to<br>us?<br></p><p>On 24 May 2016 at 14:57, Haravikk via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; One thing that I see a lot in code, and sometimes have to stop myself from<br>&gt; doing, is using shorthand array types, such as [Foo], in function<br>&gt; declarations where CollectionType could just as easily be used. For example,<br>&gt; the following two declarations can take collections of values, but the first<br>&gt; will only take them in the form of an Array:<br>&gt;<br>&gt; func doSomething(values:[Foo]) { … }<br>&gt; func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C) {<br>&gt; … }<br>&gt;<br>&gt; The latter form is something that new users of Swift tend not to know they<br>&gt; can do, and which even experienced Swift developers may not use for the sake<br>&gt; of brevity, but it can come up quite a lot. What I’d like to propose is that<br>&gt; [Foo], when used in a function, should produce the latter form behind the<br>&gt; scenes, requiring the developer to specify Array&lt;Foo&gt; if they actually need<br>&gt; it to be an Array for some reason. Though this would become inconsistent<br>&gt; with variables/properties which would still have to be Array&lt;Foo&gt; since a<br>&gt; type is required.<br>&gt;<br>&gt;<br>&gt; An alternative would be if we could specify protocol generics in a more<br>&gt; succinct form, for example:<br>&gt;<br>&gt; func doSomething(values:Collection&lt;Foo&gt;) { … }<br>&gt; func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are<br>&gt; linear anyway so could just as easily take sequences<br>&gt;<br>&gt; Note: This would not be the same as type-erased wrappers such as<br>&gt; AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where<br>&gt; Generator.Element:Foo&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; In essence I’m hoping to discuss whether we should try to remove the<br>&gt; temptation to limit functions to arrays only or not, or if there are other<br>&gt; ways to encourage more use of sequence and collection for flexibility; I try<br>&gt; wherever possible to have my methods take sequences if they can, and only<br>&gt; take collections if they need to (and never arrays only), but I can<br>&gt; understand why not everyone does this, as it’s not the friendliest thing to<br>&gt; add and declaring [Foo] looks so much neater.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Better support for existentials (see the generics manifesto,<br>https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md)<br>should obviate the need for any sort of sugar or compiler magic to do this<br>kind of thing.<br></p><p>typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T, ...&gt;<br>func doSomething(collection: AnyCollection&lt;Foo&gt;)<br></p><p>Austin<br></p><p>On Tue, May 24, 2016 at 10:57 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One thing that I see a lot in code, and sometimes have to stop myself from<br>&gt; doing, is using shorthand array types, such as [Foo], in function<br>&gt; declarations where CollectionType could just as easily be used. For<br>&gt; example, the following two declarations can take collections of values, but<br>&gt; the first will only take them in the form of an Array:<br>&gt;<br>&gt; func doSomething(values:[Foo]) { … }<br>&gt; func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C)<br>&gt; { … }<br>&gt;<br>&gt; The latter form is something that new users of Swift tend not to know they<br>&gt; can do, and which even experienced Swift developers may not use for the<br>&gt; sake of brevity, but it can come up quite a lot. What I’d like to propose<br>&gt; is that [Foo], when used in a function, should produce the latter form<br>&gt; behind the scenes, requiring the developer to specify Array&lt;Foo&gt; if they<br>&gt; actually need it to be an Array for some reason. Though this would become<br>&gt; inconsistent with variables/properties which would still have to be<br>&gt; Array&lt;Foo&gt; since a type is required.<br>&gt;<br>&gt;<br>&gt; An alternative would be if we could specify protocol generics in a more<br>&gt; succinct form, for example:<br>&gt;<br>&gt; func doSomething(values:Collection&lt;Foo&gt;) { … }<br>&gt; func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are<br>&gt; linear anyway so could just as easily take sequences<br>&gt;<br>&gt; Note: This would not be the same as type-erased wrappers such as<br>&gt; AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where<br>&gt; Generator.Element:Foo&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; In essence I’m hoping to discuss whether we should try to remove the<br>&gt; temptation to limit functions to arrays only or not, or if there are other<br>&gt; ways to encourage more use of sequence and collection for flexibility; I<br>&gt; try wherever possible to have my methods take sequences if they can, and<br>&gt; only take collections if they need to (and never arrays only), but I can<br>&gt; understand why not everyone does this, as it’s not the friendliest thing to<br>&gt; add and declaring [Foo] looks so much neater.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/e3dfb3e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 24, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 24 May 2016, at 21:14, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; My first question here would be &quot;what&#39;s the gain?&quot; I understand<br>&gt; CollectionTypes and arrays may be something different but I myself<br>&gt; admit I don&#39;t know and wonder how that change would be a benefit to<br>&gt; us?<br></p><p>Instead of functions only accepting an Array, which is a specific type, they would accept any collection type, including all the lazy collections.<br></p><p>&gt; On 24 May 2016, at 21:16, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I agree that Sequence or Collection is what is more often &#39;meant&#39; but what you propose is an awkward to explain/defend betrayal, in my opinion.<br></p><p>I’m not sure I’d call it a “betrayal”, there aren’t many methods on Array that aren’t covered by CollectionType, and those that are aren’t available as an immutable type anyway (which all function parameters are now), so to do anything array-specific requires extra steps that a fix-it might be able to cover if CollectionType is too general for your method.<br></p><p>The problem is that when there’s a shorthand, people tend to use it, but the problem is that most of the time any collection or sequence type will do, and that an array isn’t actually required at all. After seeing a bunch of examples of [Foo] before I knew about how to handle generics properly I found it a tricky habit to break. Could be more of a failing in the way Swift is being taught right now perhaps, but then generics can’t really be taught any sooner either, it’s tricky.<br></p><p>It may be too much of a breaking change I’ll grant, but at the same time it seems better to shake this up and get people using the correct method for passing/receiving collections by default.<br></p><p>&gt; On 24 May 2016, at 21:15, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Better support for existentials (see the generics manifesto, https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt;) should obviate the need for any sort of sugar or compiler magic to do this kind of thing.<br>&gt; <br>&gt; typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T, ...&gt;<br>&gt; func doSomething(collection: AnyCollection&lt;Foo&gt;)<br></p><p>Hmm, that does look like it could cover it, thanks for linking this! Just to double check, but Any is a new root for all types then, so this isn’t the same as a type-erased wrapper?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/81d932c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 5:45 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 24 May 2016, at 21:14, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My first question here would be &quot;what&#39;s the gain?&quot; I understand<br>&gt;&gt; CollectionTypes and arrays may be something different but I myself<br>&gt;&gt; admit I don&#39;t know and wonder how that change would be a benefit to<br>&gt;&gt; us?<br>&gt; <br>&gt; Instead of functions only accepting an Array, which is a specific type, they would accept any collection type, including all the lazy collections.<br>&gt; <br>&gt;&gt; On 24 May 2016, at 21:16, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that Sequence or Collection is what is more often &#39;meant&#39; but what you propose is an awkward to explain/defend betrayal, in my opinion.<br>&gt; <br>&gt; I’m not sure I’d call it a “betrayal”, there aren’t many methods on Array that aren’t covered by CollectionType, and those that are aren’t available as an immutable type anyway (which all function parameters are now), so to do anything array-specific requires extra steps that a fix-it might be able to cover if CollectionType is too general for your method.<br>&gt; <br>&gt; The problem is that when there’s a shorthand, people tend to use it, but the problem is that most of the time any collection or sequence type will do, and that an array isn’t actually required at all. After seeing a bunch of examples of [Foo] before I knew about how to handle generics properly I found it a tricky habit to break. Could be more of a failing in the way Swift is being taught right now perhaps, but then generics can’t really be taught any sooner either, it’s tricky.<br>&gt; <br>&gt; It may be too much of a breaking change I’ll grant, but at the same time it seems better to shake this up and get people using the correct method for passing/receiving collections by default.<br></p><p>The idea of shorthand for commonly used generics and / or existentials is interesting.  I’m not sure stealing the array syntax which is both familiar and similar to other languages is the right approach but it is worth considering. <br></p><p>If we do go down this path I think an important part of the discussion is whether the shorthand introduces an implicit generic parameter, whether it uses an existential, or whether the user has control over this.  Joe Groff has mentioned that he would like these to have the same behavior eventually, but that is not the case today.  I’m not sure what is involved in making the behavior the same or what the timeframe for that might look like.<br></p><p>&gt; <br>&gt;&gt; On 24 May 2016, at 21:15, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Better support for existentials (see the generics manifesto, https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md&gt;) should obviate the need for any sort of sugar or compiler magic to do this kind of thing.<br>&gt;&gt; <br>&gt;&gt; typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T, ...&gt;<br>&gt;&gt; func doSomething(collection: AnyCollection&lt;Foo&gt;)<br>&gt; <br>&gt; Hmm, that does look like it could cover it, thanks for linking this! Just to double check, but Any is a new root for all types then, so this isn’t the same as a type-erased wrapper?<br></p><p>Yes, generalized existentials are roughly equivalent to type-erased wrappers except you don’t have to write them manually.<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/70ae0894/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 5:45 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 24 May 2016, at 21:14, Leonardo Pessoa &lt;me at lmpessoa.com &lt;mailto:me at lmpessoa.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My first question here would be &quot;what&#39;s the gain?&quot; I understand<br>&gt;&gt; CollectionTypes and arrays may be something different but I myself<br>&gt;&gt; admit I don&#39;t know and wonder how that change would be a benefit to<br>&gt;&gt; us?<br>&gt; <br>&gt; Instead of functions only accepting an Array, which is a specific type, they would accept any collection type, including all the lazy collections.<br></p><p>Among other things, one practical advantage of this is that since ArraySlice conforms to CollectionType, one could simply subscript an array if they wanted to send only a subset of its contents to a method, without having to incur the performance cost of creating a new array.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/85cded4c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Better support for existentials (see the generics manifesto, https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md) should obviate the need for any sort of sugar or compiler magic to do this kind of thing.<br>&gt; <br>&gt; typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T, ...&gt;<br>&gt; func doSomething(collection: AnyCollection&lt;Foo&gt;)<br></p><p>That isn&#39;t really the same thing, though. Any&lt;Collection&gt; is an existential; it introduces indirection which would not be present in the generic version and, in this case, it erases several associated types, potentially introducing type-unsafety as well.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 5:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Better support for existentials (see the generics manifesto, https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md) should obviate the need for any sort of sugar or compiler magic to do this kind of thing.<br>&gt;&gt; <br>&gt;&gt; typealias AnyCollection&lt;T&gt; = Any&lt;Collection where .Element == T, ...&gt;<br>&gt;&gt; func doSomething(collection: AnyCollection&lt;Foo&gt;)<br>&gt; <br>&gt; That isn&#39;t really the same thing, though. Any&lt;Collection&gt; is an existential; it introduces indirection which would not be present in the generic version and, in this case, it erases several associated types, potentially introducing type-unsafety as well.<br></p><p>You are right about the indirection.  I mentioned that Joe has talked about making generic arguments have identical behavior to existentials.  I just realized that his comment was with respect to current existentials which don’t have associated types.  It might also be possible to extend this to existentials which bind all associated types to concrete types, but it would not apply to something like AnyCollection&lt;Foo&gt; which leaves several associated types unbound.  So as I mentioned, if we do introduce shorthand for something like AnyCollection we would need to decide whether the shorthand produces an implicit generic parameter or uses the existential.<br></p><p>I’m not sure what you mean about introducing type unsafely.  The generalized existentials proposal goes out of its way to be explicit about the fact that only type safe operations would be visible through the existential.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; I’m not sure what you mean about introducing type unsafely.<br></p><p>What I mean is that once you do this:<br></p><p>	let x: AnyCollection&lt;Character&gt; = myArrayOfCharacters<br>	let y: AnyCollection&lt;Character&gt; = myString.characters<br></p><p>Both `x` and `y` have indices of type `Any&lt;Comparable&gt;`, and will now accept each others&#39; indices:<br></p><p>	for i in x.indices {<br>		print(y[i])		// Oops!<br>	}<br></p><p>If this rule:<br></p><p>&gt; The generalized existentials proposal goes out of its way to be explicit about the fact that only type safe operations would be visible through the existential.<br></p><p>Is trying to say that this isn&#39;t the case because APIs using the collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m not sure what `AnyCollection` is actually supposed to be used for.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 24, 2016, at 6:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I’m not sure what you mean about introducing type unsafely.<br>&gt; <br>&gt; What I mean is that once you do this:<br>&gt; <br>&gt; 	let x: AnyCollection&lt;Character&gt; = myArrayOfCharacters<br>&gt; 	let y: AnyCollection&lt;Character&gt; = myString.characters<br>&gt; <br>&gt; Both `x` and `y` have indices of type `Any&lt;Comparable&gt;`, and will now accept each others&#39; indices:<br>&gt; <br>&gt; 	for i in x.indices {<br>&gt; 		print(y[i])		// Oops!<br>&gt; 	}<br>&gt; <br>&gt; If this rule:<br>&gt; <br>&gt;&gt; The generalized existentials proposal goes out of its way to be explicit about the fact that only type safe operations would be visible through the existential.<br>&gt; <br>&gt; Is trying to say that this isn&#39;t the case because APIs using the collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m not sure what `AnyCollection` is actually supposed to be used for.<br></p><p>Yeah, this is actually a good point.  We will probably have to implement the type-erased wrappers manually if we want this behavior.  I don’t know for sure but I imagine maybe it is considered acceptable in this case because you can already hit a fatal error with a bad array index anyway, so it isn’t totally unexpected.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 07:00:00pm</p></header><div class="content"><p>I regret mentioning existentials; I am aware that an existential that isn&#39;t<br>sufficiently constrained will never be able to provide the same guarantees<br>as a generic type variable. My argument is that even a partially<br>constrained existential is useful if there is a useful set of APIs that<br>don&#39;t touch the associated types in question. I do not believe that they<br>fulfill the same role as generics, and I apologize for writing a response<br>that strongly implied they were.<br></p><p>That being said, my opinion regarding this suggestion is still this: [Foo]<br>is not an array, Collection&lt;Foo&gt; is not a generic protocol, and I am<br>strongly against any sort of compiler magic that makes those types mean<br>anything other than what they appear to be.<br></p><p>Austin<br></p><p>If this rule:<br>&gt;<br>&gt; &gt; The generalized existentials proposal goes out of its way to be explicit<br>&gt; about the fact that only type safe operations would be visible through the<br>&gt; existential.<br>&gt;<br>&gt; Is trying to say that this isn&#39;t the case because APIs using the<br>&gt; collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m<br>&gt; not sure what `AnyCollection` is actually supposed to be used for.<br>&gt;<br></p><p>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/c5fffae1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 07:00:00pm</p></header><div class="content"><p>Sorry. That sentence should read: [Foo] is an array. Collection&lt;Foo&gt; means<br>nothing in Swift right now, but it really does look awfully like a generic<br>protocol by analogy.<br></p><p>Since I&#39;m here, I might as well keep on digging...<br></p><p>Right now, we have good syntax delineation. Generic types and functions are<br>immediately obvious because of the characteristic angle brackets placed<br>after the function or type name (with the exception of the three big<br>sugared generic types in the stdlib - Array, Dictionary, and Optional). We<br>also have protocol&lt;...&gt; to build an existential out of one or more<br>protocols, although there has been some discussion in other threads about<br>whether people might confuse that syntax with generic type syntax and<br>whether it should be changed as a result. Associated types don&#39;t use the<br>angle brackets, but they aren&#39;t really generic types - they can be used to<br>constrain generic types, but they also show up in places like defining<br>constrained protocol extensions, whose methods don&#39;t necessarily need to be<br>used in a generic function.<br></p><p>I think the fact that it&#39;s reasonably easy to tell these three loosely<br>defined families of type features apart is a valuable aspect of the<br>language&#39;s design, and loosening this ability should be done very carefully.<br></p><p>Austin<br></p><p><br></p><p>On Tue, May 24, 2016 at 7:19 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; I regret mentioning existentials; I am aware that an existential that<br>&gt; isn&#39;t sufficiently constrained will never be able to provide the same<br>&gt; guarantees as a generic type variable. My argument is that even a partially<br>&gt; constrained existential is useful if there is a useful set of APIs that<br>&gt; don&#39;t touch the associated types in question. I do not believe that they<br>&gt; fulfill the same role as generics, and I apologize for writing a response<br>&gt; that strongly implied they were.<br>&gt;<br>&gt; That being said, my opinion regarding this suggestion is still this: [Foo]<br>&gt; is not an array, Collection&lt;Foo&gt; is not a generic protocol, and I am<br>&gt; strongly against any sort of compiler magic that makes those types mean<br>&gt; anything other than what they appear to be.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; If this rule:<br>&gt;&gt;<br>&gt;&gt; &gt; The generalized existentials proposal goes out of its way to be<br>&gt;&gt; explicit about the fact that only type safe operations would be visible<br>&gt;&gt; through the existential.<br>&gt;&gt;<br>&gt;&gt; Is trying to say that this isn&#39;t the case because APIs using the<br>&gt;&gt; collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m<br>&gt;&gt; not sure what `AnyCollection` is actually supposed to be used for.<br>&gt;&gt;<br>&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/bd6e0218/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016 at 4:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; I’m not sure what you mean about introducing type unsafely.<br>&gt;<br>&gt; What I mean is that once you do this:<br>&gt;<br>&gt;         let x: AnyCollection&lt;Character&gt; = myArrayOfCharacters<br>&gt;         let y: AnyCollection&lt;Character&gt; = myString.characters<br>&gt;<br>&gt; Both `x` and `y` have indices of type `Any&lt;Comparable&gt;`, and will now<br>&gt; accept each others&#39; indices:<br>&gt;<br>&gt;         for i in x.indices {<br>&gt;                 print(y[i])             // Oops!<br>&gt;         }<br>&gt;<br>&gt; If this rule:<br>&gt;<br>&gt; &gt; The generalized existentials proposal goes out of its way to be explicit<br>&gt; about the fact that only type safe operations would be visible through the<br>&gt; existential.<br>&gt;<br>&gt; Is trying to say that this isn&#39;t the case because APIs using the<br>&gt; collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m<br>&gt; not sure what `AnyCollection` is actually supposed to be used for.<br>&gt;<br>&gt;<br>If there&#39;s any way that the rules that I&#39;ve proposed can be relaxed without<br>sacrificing type safety, I would love to hear it. I think the difference in<br>&#39;power&#39; in this regard between a function that uses generic types and a<br>function that uses existentials is something inherent to how each works,<br>though.<br></p><p><br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/ed90d138/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 24, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 24, 2016, at 9:35 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Tue, May 24, 2016 at 4:24 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; &gt; I’m not sure what you mean about introducing type unsafely.<br>&gt;&gt; <br>&gt;&gt; What I mean is that once you do this:<br>&gt;&gt; <br>&gt;&gt;         let x: AnyCollection&lt;Character&gt; = myArrayOfCharacters<br>&gt;&gt;         let y: AnyCollection&lt;Character&gt; = myString.characters<br>&gt;&gt; <br>&gt;&gt; Both `x` and `y` have indices of type `Any&lt;Comparable&gt;`, and will now accept each others&#39; indices:<br>&gt;&gt; <br>&gt;&gt;         for i in x.indices {<br>&gt;&gt;                 print(y[i])             // Oops!<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; If this rule:<br>&gt;&gt; <br>&gt;&gt; &gt; The generalized existentials proposal goes out of its way to be explicit about the fact that only type safe operations would be visible through the existential.<br>&gt;&gt; <br>&gt;&gt; Is trying to say that this isn&#39;t the case because APIs using the collection&#39;s `Index` are not exposed on an `AnyCollection`, well, then I&#39;m not sure what `AnyCollection` is actually supposed to be used for.<br>&gt;&gt; <br>&gt; <br>&gt; If there&#39;s any way that the rules that I&#39;ve proposed can be relaxed without sacrificing type safety, I would love to hear it. I think the difference in &#39;power&#39; in this regard between a function that uses generic types and a function that uses existentials is something inherent to how each works, though.<br></p><p>The primary difference is the freedom to accept an index which is invalid and call fatalError when you get it.  We don&#39;t want existentials to do something that.  But with user-defined types we have the flexibility to do that if we decide it is the right design.<br></p><p>&gt;  <br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/357acfef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&quot;that [Foo], when used in a function, should produce the latter form behind<br>the scenes, requiring the developer to specify Array&lt;Foo&gt; if they actually<br>need it to be an Array for some reason.&quot;<br></p><p>I disagree with this as a solution.  I agree that Sequence or Collection is<br>what is more often &#39;meant&#39; but what you propose is an awkward to<br>explain/defend betrayal, in my opinion. If I  were learning the language<br>and found out that a change so fundamental was made and that I could avoid<br>the change by saying–so literally–the same thing but in a different way, I<br>would not trust anything. &quot;does something dramatically different happen if<br>I use the other syntax&quot; becomes a reasonable question.<br></p><p><br>On Tue, May 24, 2016 at 1:57 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; One thing that I see a lot in code, and sometimes have to stop myself from<br>&gt; doing, is using shorthand array types, such as [Foo], in function<br>&gt; declarations where CollectionType could just as easily be used. For<br>&gt; example, the following two declarations can take collections of values, but<br>&gt; the first will only take them in the form of an Array:<br>&gt;<br>&gt; func doSomething(values:[Foo]) { … }<br>&gt; func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C)<br>&gt; { … }<br>&gt;<br>&gt; The latter form is something that new users of Swift tend not to know they<br>&gt; can do, and which even experienced Swift developers may not use for the<br>&gt; sake of brevity, but it can come up quite a lot. What I’d like to propose<br>&gt; is that [Foo], when used in a function, should produce the latter form<br>&gt; behind the scenes, requiring the developer to specify Array&lt;Foo&gt; if they<br>&gt; actually need it to be an Array for some reason. Though this would become<br>&gt; inconsistent with variables/properties which would still have to be<br>&gt; Array&lt;Foo&gt; since a type is required.<br>&gt;<br>&gt;<br>&gt; An alternative would be if we could specify protocol generics in a more<br>&gt; succinct form, for example:<br>&gt;<br>&gt; func doSomething(values:Collection&lt;Foo&gt;) { … }<br>&gt; func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are<br>&gt; linear anyway so could just as easily take sequences<br>&gt;<br>&gt; Note: This would not be the same as type-erased wrappers such as<br>&gt; AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where<br>&gt; Generator.Element:Foo&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; In essence I’m hoping to discuss whether we should try to remove the<br>&gt; temptation to limit functions to arrays only or not, or if there are other<br>&gt; ways to encourage more use of sequence and collection for flexibility; I<br>&gt; try wherever possible to have my methods take sequences if they can, and<br>&gt; only take collections if they need to (and never arrays only), but I can<br>&gt; understand why not everyone does this, as it’s not the friendliest thing to<br>&gt; add and declaring [Foo] looks so much neater.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/d9acd5de/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>Late response!<br></p><p>As-specified, although I understand the *motivation* for this suggestion, I can’t support the specific proposal whatsoever.<br></p><p>That said, I do think there’d be a lot of value in a way to add “convenience type predicates” (terrible name, please improve!) to declarations, so that e.g.:<br></p><p>  protocol Sequence {<br></p><p>    // one possibility for a declaration:<br>    typealias of&lt;E&gt; == S: Self where S.Iterator.Element == E<br></p><p>  }<br></p><p>…would allow you to write your examples like this:<br></p><p>  // sequence-accepting variant<br>  func doSomething&lt;S:Sequence.of&lt;Foo&gt;&gt;(values: S) { … }<br></p><p>  // hopefully, this would work also:<br>  func doSomething&lt;C:Collection.of&lt;Foo&gt;&gt;<br></p><p>…either as an extension of the existing generic-typealias syntax or as a separate-but-similar feature.<br></p><p>For the Sequence/Collection it’s a lot of work for IMHO a rather minor convenience, but for more-complex type associated-type relationships it could start to pay its own way.<br></p><p>&gt; On May 24, 2016, at 12:57 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One thing that I see a lot in code, and sometimes have to stop myself from doing, is using shorthand array types, such as [Foo], in function declarations where CollectionType could just as easily be used. For example, the following two declarations can take collections of values, but the first will only take them in the form of an Array:<br>&gt; <br>&gt; 	func doSomething(values:[Foo]) { … }<br>&gt; 	func doSomething&lt;C:CollectionType where C.Generator.Element:Foo&gt;(values:C) { … }<br>&gt; <br>&gt; The latter form is something that new users of Swift tend not to know they can do, and which even experienced Swift developers may not use for the sake of brevity, but it can come up quite a lot. What I’d like to propose is that [Foo], when used in a function, should produce the latter form behind the scenes, requiring the developer to specify Array&lt;Foo&gt; if they actually need it to be an Array for some reason. Though this would become inconsistent with variables/properties which would still have to be Array&lt;Foo&gt; since a type is required.<br>&gt; <br>&gt; <br>&gt; An alternative would be if we could specify protocol generics in a more succinct form, for example:<br>&gt; <br>&gt; 	func doSomething(values:Collection&lt;Foo&gt;) { … }<br>&gt; 	func doSomething(values:Sequence&lt;Foo&gt;) { … } // Many array functions are linear anyway so could just as easily take sequences<br>&gt; <br>&gt; Note: This would not be the same as type-erased wrappers such as AnySequence&lt;Foo&gt;, but rather a shorthand for &quot;Sequence where Generator.Element:Foo&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; In essence I’m hoping to discuss whether we should try to remove the temptation to limit functions to arrays only or not, or if there are other ways to encourage more use of sequence and collection for flexibility; I try wherever possible to have my methods take sequences if they can, and only take collections if they need to (and never arrays only), but I can understand why not everyone does this, as it’s not the friendliest thing to add and declaring [Foo] looks so much neater.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/7a77fba9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 9:31 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For the Sequence/Collection it’s a lot of work for IMHO a rather minor convenience, but for more-complex type associated-type relationships it could start to pay its own way.<br></p><p>Is it really that minor, though? For something so commonly encountered as methods that take sequences/collections, this:<br></p><p>func doSomething(foos: [Foo], bars: [Bar], bazzes: [Baz])<br></p><p>is not only a whole lot easier to type, but is worlds clearer to read than:<br></p><p>func doSomething&lt;S: SequenceType, T: SequenceType, U: SequenceType where S.Generator.Element == Foo, T.Generator.Element == Bar, U.Generator.Element == Baz&gt;(foos: S, bars: T, bazzes: U)<br></p><p>Not only is the latter line intimidating to look at as is, but it separates the contained type from the parameters themselves. Given how unwieldy this second form is, it seems almost certain that the former line will be used more frequently in the real world.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/298eeb72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 12:05 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On May 27, 2016, at 9:31 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For the Sequence/Collection it’s a lot of work for IMHO a rather minor convenience, but for more-complex type associated-type relationships it could start to pay its own way.<br>&gt; <br>&gt; Is it really that minor, though? For something so commonly encountered as methods that take sequences/collections, this:<br>&gt; <br>&gt; func doSomething(foos: [Foo], bars: [Bar], bazzes: [Baz])<br>&gt; <br>&gt; is not only a whole lot easier to type, but is worlds clearer to read than:<br>&gt; <br>&gt; func doSomething&lt;S: SequenceType, T: SequenceType, U: SequenceType where S.Generator.Element == Foo, T.Generator.Element == Bar, U.Generator.Element == Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt; <br>&gt; Not only is the latter line intimidating to look at as is, but it separates the contained type from the parameters themselves. Given how unwieldy this second form is, it seems almost certain that the former line will be used more frequently in the real world.<br></p><p>When generalized existentials are introduced (Austin Zheng has a proposal for this) you will be able to do this (assuming we switch to the `&amp;` syntax:<br></p><p>typealias SequenceOf&lt;T&gt; = Sequence where .Element == T<br></p><p>func doSomething(foos: SequenceOf&lt;Foo&gt;, bars: SequenceOf&lt;Bar&gt;, bazzes: SequenceOf&lt;Baz&gt;)<br></p><p>It’s still slightly more verbose than the array shorthand, but it’s a far cry from what you have to do with generics today.<br></p><p>If you wanted it to be generic you could write it as:<br></p><p>func doSomething&lt;S: SequenceOf&lt;Foo&gt;, T: SequenceOf&lt;Bar&gt;, SequenceOf&lt;Baz&gt;(foos: S, bars: T, bazzes: U)<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/df300d07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 27.05.2016 um 20:47 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 27, 2016, at 12:05 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 9:31 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the Sequence/Collection it’s a lot of work for IMHO a rather minor convenience, but for more-complex type associated-type relationships it could start to pay its own way.<br>&gt;&gt; <br>&gt;&gt; Is it really that minor, though? For something so commonly encountered as methods that take sequences/collections, this:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foos: [Foo], bars: [Bar], bazzes: [Baz])<br>&gt;&gt; <br>&gt;&gt; is not only a whole lot easier to type, but is worlds clearer to read than:<br>&gt;&gt; <br>&gt;&gt; func doSomething&lt;S: SequenceType, T: SequenceType, U: SequenceType where S.Generator.Element == Foo, T.Generator.Element == Bar, U.Generator.Element == Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt;&gt; <br>&gt;&gt; Not only is the latter line intimidating to look at as is, but it separates the contained type from the parameters themselves. Given how unwieldy this second form is, it seems almost certain that the former line will be used more frequently in the real world.<br>&gt; <br>&gt; When generalized existentials are introduced (Austin Zheng has a proposal for this) you will be able to do this (assuming we switch to the `&amp;` syntax:<br>&gt; <br>&gt; typealias SequenceOf&lt;T&gt; = Sequence where .Element == T<br>&gt; <br>&gt; func doSomething(foos: SequenceOf&lt;Foo&gt;, bars: SequenceOf&lt;Bar&gt;, bazzes: SequenceOf&lt;Baz&gt;)<br></p><p>That’s a really nice solution, which gets even nicer with plx suggestion of putting the typealias within the protocol like this: <br></p><p>protocol Sequence {<br>    typealias of&lt;E&gt; = S: Self where .Element == E<br>}<br></p><p>-Thorsten<br></p><p><br></p><p>&gt; <br>&gt; It’s still slightly more verbose than the array shorthand, but it’s a far cry from what you have to do with generics today.<br>&gt; <br>&gt; If you wanted it to be generic you could write it as:<br>&gt; <br>&gt; func doSomething&lt;S: SequenceOf&lt;Foo&gt;, T: SequenceOf&lt;Bar&gt;, SequenceOf&lt;Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/fcbe56ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 28, 2016, at 12:40 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 27.05.2016 um 20:47 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 12:05 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 27, 2016, at 9:31 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the Sequence/Collection it’s a lot of work for IMHO a rather minor convenience, but for more-complex type associated-type relationships it could start to pay its own way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it really that minor, though? For something so commonly encountered as methods that take sequences/collections, this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foos: [Foo], bars: [Bar], bazzes: [Baz])<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is not only a whole lot easier to type, but is worlds clearer to read than:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething&lt;S: SequenceType, T: SequenceType, U: SequenceType where S.Generator.Element == Foo, T.Generator.Element == Bar, U.Generator.Element == Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not only is the latter line intimidating to look at as is, but it separates the contained type from the parameters themselves. Given how unwieldy this second form is, it seems almost certain that the former line will be used more frequently in the real world.<br>&gt;&gt; <br>&gt;&gt; When generalized existentials are introduced (Austin Zheng has a proposal for this) you will be able to do this (assuming we switch to the `&amp;` syntax:<br>&gt;&gt; <br>&gt;&gt; typealias SequenceOf&lt;T&gt; = Sequence where .Element == T<br>&gt;&gt; <br>&gt;&gt; func doSomething(foos: SequenceOf&lt;Foo&gt;, bars: SequenceOf&lt;Bar&gt;, bazzes: SequenceOf&lt;Baz&gt;)<br>&gt; <br>&gt; That’s a really nice solution, which gets even nicer with plx suggestion of putting the typealias within the protocol like this: <br>&gt; <br>&gt; protocol Sequence {<br>&gt;     typealias of&lt;E&gt; = S: Self where .Element == E<br>&gt; }<br></p><p>That is very nice!<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; It’s still slightly more verbose than the array shorthand, but it’s a far cry from what you have to do with generics today.<br>&gt;&gt; <br>&gt;&gt; If you wanted it to be generic you could write it as:<br>&gt;&gt; <br>&gt;&gt; func doSomething&lt;S: SequenceOf&lt;Foo&gt;, T: SequenceOf&lt;Bar&gt;, SequenceOf&lt;Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/612d8202/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 27, 2016 at 06:00:00pm</p></header><div class="content"><p>Firstly, the syntax is about to get a lot cleaner. Soon, your example will<br>be:<br></p><p>func doSomething&lt;<br>S: Sequence, T: Sequence, U: Sequence<br>&gt;(foos: S, bars: T, bazzes: U)<br>where S.Element == Foo, T.Element == Bar, U.Element == Baz<br></p><p>Second, this syntax shows necessary complexity. Case in point: an array is<br>a Collection with randomly accessible elements, yet in your example you<br>chose SequenceType (aka Sequence). An instance of a type conforming to<br>Sequence may or may not have randomly accessible elements, it may or may<br>not be consumed after one pass, it may or may not have copy-on-write<br>behavior, and it may or may not be laid out contiguously in memory (which<br>is not guaranteed for all arrays but is for arrays with elements of<br>primitive type)--and that&#39;s if it&#39;s entirely held in memory at all.<br></p><p>By writing out the function declaration the way it&#39;s shown above, it&#39;s<br>clear what considerations that function will have to take into account.<br>Assuming that it can operate on arbitrary sequences just like it can an<br>array is a recipe for a lot of pain.<br></p><p>On Fri, May 27, 2016 at 12:05 Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On May 27, 2016, at 9:31 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; For the Sequence/Collection it’s a lot of work for IMHO a rather minor<br>&gt; convenience, but for more-complex type associated-type relationships it<br>&gt; could start to pay its own way.<br>&gt;<br>&gt;<br>&gt; Is it really that minor, though? For something so commonly encountered as<br>&gt; methods that take sequences/collections, this:<br>&gt;<br>&gt; func doSomething(foos: [Foo], bars: [Bar], bazzes: [Baz])<br>&gt;<br>&gt; is not only a whole lot easier to type, but is worlds clearer to read than:<br>&gt;<br>&gt; func doSomething&lt;S: SequenceType, T: SequenceType, U: SequenceType where<br>&gt; S.Generator.Element == Foo, T.Generator.Element == Bar, U.Generator.Element<br>&gt; == Baz&gt;(foos: S, bars: T, bazzes: U)<br>&gt;<br>&gt; Not only is the latter line intimidating to look at as is, but it<br>&gt; separates the contained type from the parameters themselves. Given how<br>&gt; unwieldy this second form is, it seems almost certain that the former line<br>&gt; will be used more frequently in the real world.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/72f0becb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 27, 2016, at 1:53 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Firstly, the syntax is about to get a lot cleaner. Soon, your example will be:<br>&gt; <br>&gt; func doSomething&lt;<br>&gt; S: Sequence, T: Sequence, U: Sequence<br>&gt; &gt;(foos: S, bars: T, bazzes: U)<br>&gt; where S.Element == Foo, T.Element == Bar, U.Element == Baz<br></p><p>I wonder if it would be possible to introduce angle brackets on protocols to enumerate associated-type requirements? AFAIK, currently the angle brackets are not allowed at all, so it would be purely additive. Then, you could do something like:<br></p><p>func doSomething(foos: Sequence&lt;Element == Foo&gt;, bars: Sequence&lt;Element == Bar&gt;, bazzes: Sequence&lt;Element == Baz&gt;)<br></p><p>I don’t know about you, but that looks so much cleaner, for a function that doesn’t itself need to be generic.<br></p><p>(The generalized existentials solution is good, too. However, it requires making a separate typealias for every protocol you want to do this with, whereas the above idea wouldn’t.)<br></p><p>&gt; Second, this syntax shows necessary complexity. Case in point: an array is a Collection with randomly accessible elements, yet in your example you chose SequenceType (aka Sequence). An instance of a type conforming to Sequence may or may not have randomly accessible elements, it may or may not be consumed after one pass, it may or may not have copy-on-write behavior, and it may or may not be laid out contiguously in memory (which is not guaranteed for all arrays but is for arrays with elements of primitive type)--and that&#39;s if it&#39;s entirely held in memory at all.<br>&gt; <br>&gt; By writing out the function declaration the way it&#39;s shown above, it&#39;s clear what considerations that function will have to take into account. Assuming that it can operate on arbitrary sequences just like it can an array is a recipe for a lot of pain.<br></p><p>Yeah, I defaulted to Sequence just because I’ve been writing stuff lately that just iterates through a collection that’s passed in. If what the OP is proposing came to pass, it would need to map to Collection instead. Of course, sometimes all you need is a Sequence, so your point is well-taken. We do need *some* way to simplify this syntax, though.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160527/0b3b9c1a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 27 May 2016, at 15:31, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;   protocol Sequence {<br>&gt;     typealias of&lt;E&gt; == S: Self where S.Iterator.Element == E<br>&gt;   }<br>&gt; <br>&gt;   // sequence-accepting variant<br>&gt;   func doSomething&lt;S:Sequence.of&lt;Foo&gt;&gt;(values: S) { … }<br></p><p>This is a nice alternative; would it actually need to be declared in the angle brackets? Could it be done as:<br></p><p>	func doSomething(values:Sequence.of&lt;Foo&gt;) { … }<br></p><p>As long as it would work the same as a generic declaration this could be a good way to do it, either that or a SequenceOf type alias as mentioned.<br></p><p><br>Still, I kind of feel like we need to do something with the array type shorthand, but I wonder if perhaps we could just get rid of it altogether, to prevent its use entirely? i.e- all instances of [Foo] can be replaced with Array&lt;Foo&gt;, but we would encourage the use of Sequence.of/SequenceOf/Collection.of/CollectionOf first wherever possible.<br></p><p>As more types become available that are ArrayLiteralConvertible it seems like we should discourage restriction of a parameter to Array except when a developer explicitly chooses it. This problem will come up with the Dictionary type shorthand as well if Swift gets some kind of Map protocol to abstract it, and we don’t even have a Set-specific syntax so it seems like it may be fairer to remove these shorthands.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/571ebb47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>I couldn&#39;t disagree more. Generic programming is a far more advanced<br>concept than arrays and dictionaries, and learners should be able to use<br>them without contending with angle brackets they don&#39;t understand.<br></p><p>Fundamentally, even for an experienced user of the language, working with<br>Collections and Sequences requires more consideration than working with<br>arrays. It&#39;s not just a matter of how these things are spelled. It seems<br>like you want to punish users who don&#39;t have the time or inclination to<br>genericize their algorithms by making them write more, in the hopes that if<br>you make working with arrays difficult enough, people will switch to<br>generic containers. That&#39;s bonkers.<br></p><p>On Sat, May 28, 2016 at 14:38 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 27 May 2016, at 15:31, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;   protocol Sequence {<br>&gt;<br>&gt;     typealias of&lt;E&gt; == S: Self where S.Iterator.Element == E<br>&gt;   }<br>&gt;<br>&gt;   // sequence-accepting variant<br>&gt;   func doSomething&lt;S:Sequence.of&lt;Foo&gt;&gt;(values: S) { … }<br>&gt;<br>&gt;<br>&gt; This is a nice alternative; would it actually need to be declared in the<br>&gt; angle brackets? Could it be done as:<br>&gt;<br>&gt; func doSomething(values:Sequence.of&lt;Foo&gt;) { … }<br>&gt;<br>&gt; As long as it would work the same as a generic declaration this could be a<br>&gt; good way to do it, either that or a SequenceOf type alias as mentioned.<br>&gt;<br>&gt;<br>&gt; Still, I kind of feel like we need to do something with the array type<br>&gt; shorthand, but I wonder if perhaps we could just get rid of it altogether,<br>&gt; to prevent its use entirely? i.e- all instances of [Foo] can be replaced<br>&gt; with Array&lt;Foo&gt;, but we would encourage the use of<br>&gt; Sequence.of/SequenceOf/Collection.of/CollectionOf first wherever possible.<br>&gt;<br>&gt; As more types become available that are ArrayLiteralConvertible it seems<br>&gt; like we should discourage restriction of a parameter to Array except when a<br>&gt; developer explicitly chooses it. This problem will come up with the<br>&gt; Dictionary type shorthand as well if Swift gets some kind of Map protocol<br>&gt; to abstract it, and we don’t even have a Set-specific syntax so it seems<br>&gt; like it may be fairer to remove these shorthands.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c3a6e3e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 28 May 2016, at 20:16, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I couldn&#39;t disagree more. Generic programming is a far more advanced concept than arrays and dictionaries, and learners should be able to use them without contending with angle brackets they don&#39;t understand.<br>&gt; <br>&gt; Fundamentally, even for an experienced user of the language, working with Collections and Sequences requires more consideration than working with arrays. It&#39;s not just a matter of how these things are spelled. It seems like you want to punish users who don&#39;t have the time or inclination to genericize their algorithms by making them write more, in the hopes that if you make working with arrays difficult enough, people will switch to generic containers. That&#39;s bonkers.<br></p><p>It’s not about making working with arrays difficult, but if we can make working with basic generic collections/sequences just as easy, then it makes sense to encourage their use as much as possible. Like in the example below, Sequence.of&lt;Foo&gt; is pretty straightforward, and far more flexible and useful than just using [Foo], as you can trivially change the type of collection you use later.<br></p><p>More complex generics definitely need to be explored separately, but Sequence.of&lt;Foo&gt; should be just as simple to use as [Foo], it’s just a little longer because of the ability to distinguish between sequence and collection.<br></p><p>&gt; On Sat, May 28, 2016 at 14:38 Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 27 May 2016, at 15:31, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;   protocol Sequence {<br>&gt; <br>&gt;&gt;     typealias of&lt;E&gt; == S: Self where S.Iterator.Element == E<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt; <br>&gt;&gt;   // sequence-accepting variant<br>&gt;&gt;   func doSomething&lt;S:Sequence.of&lt;Foo&gt;&gt;(values: S) { … }<br>&gt; <br>&gt; <br>&gt; This is a nice alternative; would it actually need to be declared in the angle brackets? Could it be done as:<br>&gt; <br>&gt; 	func doSomething(values:Sequence.of&lt;Foo&gt;) { … }<br>&gt; <br>&gt; As long as it would work the same as a generic declaration this could be a good way to do it, either that or a SequenceOf type alias as mentioned.<br>&gt; <br>&gt; <br>&gt; Still, I kind of feel like we need to do something with the array type shorthand, but I wonder if perhaps we could just get rid of it altogether, to prevent its use entirely? i.e- all instances of [Foo] can be replaced with Array&lt;Foo&gt;, but we would encourage the use of Sequence.of/SequenceOf/Collection.of/CollectionOf first wherever possible.<br>&gt; <br>&gt; As more types become available that are ArrayLiteralConvertible it seems like we should discourage restriction of a parameter to Array except when a developer explicitly chooses it. This problem will come up with the Dictionary type shorthand as well if Swift gets some kind of Map protocol to abstract it, and we don’t even have a Set-specific syntax so it seems like it may be fairer to remove these shorthands.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/5e0c6dbe/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pre-proposal] Replace [Foo] With CollectionType</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 28, 2016, at 1:38 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 May 2016, at 15:31, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;   protocol Sequence {<br>&gt;&gt;     typealias of&lt;E&gt; == S: Self where S.Iterator.Element == E<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // sequence-accepting variant<br>&gt;&gt;   func doSomething&lt;S:Sequence.of&lt;Foo&gt;&gt;(values: S) { … }<br>&gt; <br>&gt; This is a nice alternative; would it actually need to be declared in the angle brackets? Could it be done as:<br>&gt; <br>&gt; 	func doSomething(values:Sequence.of&lt;Foo&gt;) { … }<br>&gt; <br>&gt; As long as it would work the same as a generic declaration this could be a good way to do it, either that or a SequenceOf type alias as mentioned.<br></p><p>I think I showed both existential and generic variations didn&#39;t I?  You certainly could do it either way.  Placing the typealias in the protocol is not a bad idea either!<br></p><p>&gt; <br>&gt; <br>&gt; Still, I kind of feel like we need to do something with the array type shorthand, but I wonder if perhaps we could just get rid of it altogether, to prevent its use entirely? i.e- all instances of [Foo] can be replaced with Array&lt;Foo&gt;, but we would encourage the use of Sequence.of/SequenceOf/Collection.of/CollectionOf first wherever possible.<br>&gt; <br>&gt; As more types become available that are ArrayLiteralConvertible it seems like we should discourage restriction of a parameter to Array except when a developer explicitly chooses it. This problem will come up with the Dictionary type shorthand as well if Swift gets some kind of Map protocol to abstract it, and we don’t even have a Set-specific syntax so it seems like it may be fairer to remove these shorthands.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/c4004f6b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
