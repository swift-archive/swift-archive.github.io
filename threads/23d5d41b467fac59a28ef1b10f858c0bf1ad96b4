<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;  On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;<br>&gt;  On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;  wrote:<br>&gt;<br>&gt;  I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;<br>&gt;  John.<br>&gt;<br>&gt;  I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;  Having free functions or magic operators seems to be another holdover from C. <br>&gt;<br>&gt;  Int.size<br>&gt;  Int.alignment<br>&gt;  Int.spacing<br>&gt;<br>&gt;  let x: Any = 5<br>&gt;  type(of: x).size<br>&gt;<br>&gt;  The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt;<br>&gt; Two reasons. The first is that this is a user-extensible namespace via<br>&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names<br>&gt; from the library. The second is that there&#39;s currently no language<br>&gt; mechanism for adding a static member to every type, so this would have<br>&gt; to be built-in. <br></p><p>More fundamental reasons:<br></p><p><br>* `Array&lt;Int&gt;.size` is easily misinterpreted.  The identifier<br>  `MemoryLayout` was suggested in order to set the proper mental context<br>  at the use site.<br></p><p>* I don&#39;t want “size,” “alignment,” and “spacing” appearing in the<br>  code-completion list for every type.  <br></p><p>* I can easily imagine users wanting to use static properties by these<br>  names for their own types, with completely different meaning.<br></p><p>&gt; But I agree that in the abstract a static property would be<br>&gt; preferable.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>June  6, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;d like to cast another vote in favor of something like the MemoryLayout struct. In general, people aren&#39;t always making the right choice about which of these values to use. Combining them into one data type would mean they see that there are three related values and can find out when to use which easily.<br></p><p>Would MemoryLayout need to be generic? Accessing a static property on a generic type doesn&#39;t seem as straightforward as a function call or the properties of a struct. I think I&#39;d prefer something closer to the way Mirror works, but really, I defer to those with stronger convictions / actual reasons:<br></p><p>func type&lt;T&gt;(of value: T) -&gt; T.Type {<br>    return T.self<br>}<br></p><p>struct MemoryLayout {<br>    let size: Int<br>    let stride: Int<br>    let alignment: Int<br>    <br>    init&lt;T&gt;(of type: T.Type) {<br>        size = sizeof(type)<br>        stride = strideof(type)<br>        alignment = alignof(type)<br>    }<br>}<br>Nate<br></p><p>&gt; On Jun 5, 2016, at 7:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt;&gt; <br>&gt;&gt; Int.size<br>&gt;&gt; Int.alignment<br>&gt;&gt; Int.spacing<br>&gt;&gt; <br>&gt;&gt; let x: Any = 5<br>&gt;&gt; type(of: x).size<br>&gt;&gt; <br>&gt;&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt;&gt; <br>&gt;&gt; Two reasons. The first is that this is a user-extensible namespace via<br>&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names<br>&gt;&gt; from the library. The second is that there&#39;s currently no language<br>&gt;&gt; mechanism for adding a static member to every type, so this would have<br>&gt;&gt; to be built-in. <br>&gt; <br>&gt; More fundamental reasons:<br>&gt; <br>&gt; <br>&gt; * `Array&lt;Int&gt;.size` is easily misinterpreted.  The identifier<br>&gt;  `MemoryLayout` was suggested in order to set the proper mental context<br>&gt;  at the use site.<br>&gt; <br>&gt; * I don&#39;t want “size,” “alignment,” and “spacing” appearing in the<br>&gt;  code-completion list for every type.  <br>&gt; <br>&gt; * I can easily imagine users wanting to use static properties by these<br>&gt;  names for their own types, with completely different meaning.<br>&gt; <br>&gt;&gt; But I agree that in the abstract a static property would be<br>&gt;&gt; preferable.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/0436ce44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jun 06 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br></p><p>&gt; I&#39;d like to cast another vote in favor of something like the<br>&gt; MemoryLayout struct. In general, people aren&#39;t always making the right<br>&gt; choice about which of these values to use. Combining them into one<br>&gt; data type would mean they see that there are three related values and<br>&gt; can find out when to use which easily.<br>&gt;<br>&gt; Would MemoryLayout need to be generic? Accessing a static property on<br>&gt; a generic type doesn&#39;t seem as straightforward as a function call or<br>&gt; the properties of a struct. I think I&#39;d prefer something closer to the<br>&gt; way Mirror works, but really, I defer to those with stronger<br>&gt; convictions / actual reasons:<br>&gt;<br>&gt; func type&lt;T&gt;(of value: T) -&gt; T.Type {<br>&gt;     return T.self<br>&gt; }<br>&gt;<br>&gt; struct MemoryLayout {<br>&gt;     let size: Int<br>&gt;     let stride: Int<br>&gt;     let alignment: Int<br>&gt;<br>&gt;     init&lt;T&gt;(of type: T.Type) {<br></p><p>I see no need for an argument label here.<br></p><p>&gt;         size = sizeof(type)<br>&gt;         stride = strideof(type)<br>&gt;         alignment = alignof(type)<br>&gt;     }<br>&gt; }<br></p><p>These are all possible syntaxes, but I think #3 is best:<br></p><p>1. MemoryLayout(Int.self).size<br>2. memoryLayout(Int.self).size<br>3. MemoryLayout&lt;Int&gt;.size<br></p><p>I don&#39;t see any advantage of #1 over #2, and there&#39;s no need at all to<br>define a new nominal type if we only want #2:<br></p><p> func memoryLayout&lt;T&gt;(_ T.type) -&gt; (size: Int, stride: Int, alignment: Int) {<br>    // implementation<br> }<br></p><p>&gt; Nate<br>&gt;<br>&gt;&gt; On Jun 5, 2016, at 7:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int.size<br>&gt;&gt;&gt; Int.alignment<br>&gt;&gt;&gt; Int.spacing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: Any = 5<br>&gt;&gt;&gt; type(of: x).size<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Two reasons. The first is that this is a user-extensible namespace via<br>&gt;&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names<br>&gt;&gt;&gt; from the library. The second is that there&#39;s currently no language<br>&gt;&gt;&gt; mechanism for adding a static member to every type, so this would have<br>&gt;&gt;&gt; to be built-in. <br>&gt;&gt; <br>&gt;&gt; More fundamental reasons:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * `Array&lt;Int&gt;.size` is easily misinterpreted.  The identifier<br>&gt;&gt;  `MemoryLayout` was suggested in order to set the proper mental context<br>&gt;&gt;  at the use site.<br>&gt;&gt; <br>&gt;&gt; * I don&#39;t want “size,” “alignment,” and “spacing” appearing in the<br>&gt;&gt;  code-completion list for every type.  <br>&gt;&gt; <br>&gt;&gt; * I can easily imagine users wanting to use static properties by these<br>&gt;&gt;  names for their own types, with completely different meaning.<br>&gt;&gt; <br>&gt;&gt;&gt; But I agree that in the abstract a static property would be<br>&gt;&gt;&gt; preferable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Pitch] Renaming sizeof, sizeofValue, strideof, strideofValue</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June  6, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 on #3<br>3. MemoryLayout&lt;Int&gt;.size<br></p><p>http://i.gifntext.com/29412-number-3-my-lord.gif &lt;http://i.gifntext.com/29412-number-3-my-lord.gif&gt;<br></p><p>&gt; On Jun 6, 2016, at 3:37 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 06 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;d like to cast another vote in favor of something like the<br>&gt;&gt; MemoryLayout struct. In general, people aren&#39;t always making the right<br>&gt;&gt; choice about which of these values to use. Combining them into one<br>&gt;&gt; data type would mean they see that there are three related values and<br>&gt;&gt; can find out when to use which easily.<br>&gt;&gt; <br>&gt;&gt; Would MemoryLayout need to be generic? Accessing a static property on<br>&gt;&gt; a generic type doesn&#39;t seem as straightforward as a function call or<br>&gt;&gt; the properties of a struct. I think I&#39;d prefer something closer to the<br>&gt;&gt; way Mirror works, but really, I defer to those with stronger<br>&gt;&gt; convictions / actual reasons:<br>&gt;&gt; <br>&gt;&gt; func type&lt;T&gt;(of value: T) -&gt; T.Type {<br>&gt;&gt;    return T.self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MemoryLayout {<br>&gt;&gt;    let size: Int<br>&gt;&gt;    let stride: Int<br>&gt;&gt;    let alignment: Int<br>&gt;&gt; <br>&gt;&gt;    init&lt;T&gt;(of type: T.Type) {<br>&gt; <br>&gt; I see no need for an argument label here.<br>&gt; <br>&gt;&gt;        size = sizeof(type)<br>&gt;&gt;        stride = strideof(type)<br>&gt;&gt;        alignment = alignof(type)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; These are all possible syntaxes, but I think #3 is best:<br>&gt; <br>&gt; 1. MemoryLayout(Int.self).size<br>&gt; 2. memoryLayout(Int.self).size<br>&gt; 3. MemoryLayout&lt;Int&gt;.size<br>&gt; <br>&gt; I don&#39;t see any advantage of #1 over #2, and there&#39;s no need at all to<br>&gt; define a new nominal type if we only want #2:<br>&gt; <br>&gt; func memoryLayout&lt;T&gt;(_ T.type) -&gt; (size: Int, stride: Int, alignment: Int) {<br>&gt;    // implementation<br>&gt; }<br>&gt; <br>&gt;&gt; Nate<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 7:54 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jun 02 2016, John McCall &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 1:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 2, 2016, at 11:30 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still think the value-based APIs are misleading and that it would be better to ask people to just use a type explicitly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree; in fact why aren’t these properties on the type itself? The type is what matters; why can’t the type just tell me it’s size? <br>&gt;&gt;&gt;&gt; Having free functions or magic operators seems to be another holdover from C. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Int.size<br>&gt;&gt;&gt;&gt; Int.alignment<br>&gt;&gt;&gt;&gt; Int.spacing<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x: Any = 5<br>&gt;&gt;&gt;&gt; type(of: x).size<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler should be able to statically know the first three values and inline them. The second is discovering the size dynamically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Two reasons. The first is that this is a user-extensible namespace via<br>&gt;&gt;&gt;&gt; static members, so it&#39;s somewhat unfortunate to pollute it with names<br>&gt;&gt;&gt;&gt; from the library. The second is that there&#39;s currently no language<br>&gt;&gt;&gt;&gt; mechanism for adding a static member to every type, so this would have<br>&gt;&gt;&gt;&gt; to be built-in. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More fundamental reasons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * `Array&lt;Int&gt;.size` is easily misinterpreted.  The identifier<br>&gt;&gt;&gt; `MemoryLayout` was suggested in order to set the proper mental context<br>&gt;&gt;&gt; at the use site.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I don&#39;t want “size,” “alignment,” and “spacing” appearing in the<br>&gt;&gt;&gt; code-completion list for every type.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I can easily imagine users wanting to use static properties by these<br>&gt;&gt;&gt; names for their own types, with completely different meaning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I agree that in the abstract a static property would be<br>&gt;&gt;&gt;&gt; preferable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/adb07620/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
