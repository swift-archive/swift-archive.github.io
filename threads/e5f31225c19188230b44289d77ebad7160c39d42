<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Fwd: [swift-evolution] [Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>More thoughts on protocols used more systematically to replace compiler magic.<br></p><p>Begin forwarded message:<br></p><p>&gt; From: L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;<br>&gt; Date: June 8, 2016 at 8:07:02 AM GMT+2<br>&gt; To: Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; Cc: Michael Peternell &lt;michael.peternell at gmx.at&gt;, swift-evolution &lt;swift-evolution at swift.org&gt;, Dave Abrahams &lt;dabrahams at apple.com&gt;, Douglas Gregor &lt;dgregor at apple.com&gt;, Joe Groff &lt;jgroff at apple.com&gt;, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; Subject: Re: [swift-evolution] [Draft] Change @noreturn to unconstructible return type<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 7:49 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 6:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for a real bottom type<br>&gt;&gt;&gt; +1 for calling it Never<br>&gt;&gt; <br>&gt;&gt; +1 on all accounts (it is not the first time I find myself in agreement with many of the choices you support, and more interestingly, with the rational you use to support them: usually a mix between references to other examples and pragmatism).<br>&gt;&gt; <br>&gt;&gt; here is another twist on Never… see further down...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt;&gt;&gt;&gt; We have to keep it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Consider for a moment that the bottom type is a technical aspect of the runtime., the thing that the compiler needs so avoid some internal magic while steering towards expressing more things that can be expressed with protocols, using protocols. So that would give the compiler what it needs to have more internal symmetry. But then nothing says that our needs are the same as the compiler’s, particularly when it comes to expressivity. So that leaves us with the possibility of having a bottom type, and having something based on it that can present a more user friendly interface. And while we are at it, nothing says that the user facing side has to be universal, fitting all possible use cases. So then that opens up the possibility of <br>&gt;&gt; <br>&gt;&gt; 1) have a bottom type<br>&gt;&gt; 2) have use site derived notions (the ones we users will learn) that are internally linkable to 1), but outside of what we care about<br>&gt;&gt; <br>&gt;&gt; which bring us back to something like the following scenario:<br>&gt;&gt; <br>&gt;&gt; 1)  create a  protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, but the argument also goes that BuiltinXxxxLiteral can be converted to SwiftXxxxLiteral  ]. This is something only the compiler cares about, but a building block for what we need. it would be simple to enforce in the compiler that SwiftXXXXX protocols cannot be the target of any user defined conformances if need be. <br>&gt;&gt; In fact, these SwiftXxxxxx protocols could be considered so critical for the existence of the language/compiler (i.e. ‘below&#39; the stdlib) that might might not even be represented in the sodlib, but directly manufactured into the TEXT.__swift3_builtin (don’t quote me on this one versus the meaning of the __swift2_proto??? can&#39;t recall its name at the moment) section of the libswiftRuntime.a (runtime lib already deals with all the metadata loading, low level existential, and internal reflection)<br>&gt;&gt; <br>&gt;&gt; then :<br>&gt;&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>&gt;&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>&gt;&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; can become (or stay as it is but, the point is that they are unified, and have become a pattern for future extensibility)<br>&gt;&gt; <br>&gt;&gt; BUILTIN_CORE_PROTOCOL_(SwiftBooleanLiteralConvertible)  // btw, they can all retain the BuiltinXxxxxxxx pattern<br>&gt;&gt; BUILTIN_CORE_PROTOCOL_(SwiftExtendedGraphemeClusterLiteralConvertible)<br>&gt;&gt; BUILTIN_CORE_PROTOCOL_(SwiftFloatLiteralConvertible)<br>&gt;&gt; BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new guys<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2) then create  a  enum NoReturn: SwiftBottomType {}  that we learn about (and name it Never, or …. to match the returning situation. And as time goes, there may be other synonymous that will be built with the best possible user facing name for these circumstances.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; When looking at this question and a couple of other related ones, a pattern should form, whose rational is self evident (I am listing a couple others in a separate doc just because IMHO it is a somewhat elegant binding for the low level)<br>&gt; <br>&gt; <br>&gt; btw, I know that BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_ have to be treated differently, but I think it is still possible to use the pattern they form to express other critically essential language notions via Protocols as opposed to contextual keywords (eg .Type .Self ) or some other types of secret hand-shakes.<br>&gt; <br>&gt; For example at the moment they all are statically declared in the compiler, which also means that adding a new one requires recompiling the compiler, or that users cannot follow in the footsteps with their own literal convertibles (ours have to remain on the other side of a possible very smart thing the compiler would learn to do in the future). Which means that nothing says the following cannot be done<br>&gt; <br>&gt; Replace :<br>&gt; <br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinIntegerLiteralConvertible)<br>&gt; ...<br>&gt; <br>&gt; with <br>&gt; <br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftLiteralConvertible)  	// a single core protocol to flag for the compiler the entire literal convertible pattern<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new core guys<br>&gt; <br>&gt; BUILTIN_SPECIALISED_PROTOCOL_(BuiltinBooleanLiteralConvertible, SwiftLiteralConvertible)<br>&gt; BUILTIN_SPECIALISED_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible, SwiftLiteralConvertible)<br>&gt; <br>&gt; and then maybe the second type can be opened to us too… or these secondary definitions get out of the c++ code and back into the sodlib .swift code, which means that we can pattern some MyOwnSmartLiteralConvertibleThatISwearWillBehaveLikeYours after this model and have it equally discoverable as the lib&#39;s<br>&gt; <br>&gt; <br>&gt; reading your code is a very humbling experience.. I just think some additional symmetries might simplify certain things.<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160608/e5f39d42/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
