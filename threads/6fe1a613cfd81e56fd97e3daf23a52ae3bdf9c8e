<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/225242c158c149635596c786c8971fbc?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Niall Young</string> &lt;niall at iinet.net.au&gt;<p>April 21, 2016 at 07:00:00pm</p></header><div class="content"><p>At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br></p><p>&gt; I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt; Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt; mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt; member data) or inheritance (which, as you mentioned, can only have one<br>&gt; base type) -- it&#39;s to extract a third type that handles<br></p><p>What you&#39;re describing sounds _exactly_ like Traits :-)<br></p><p> 	http://scg.unibe.ch/research/traits<br></p><p>Traits could be a peer of extensions, filling a niche that isn&#39;t quite the same niche as a default implementation, but it could be consistently and safely consumed like an extension, with its own rules of consumption (flattening) - to implement any need or explicit protocol requirement that a Class, Value Type or Protocol has at compile-time.<br></p><p>Think of a Trait as providing a consumable set of functions.  Now imagine that we&#39;re combining the collective declarations of 1..N Traits all together, consumed by a Class or Value Type (or Protocol!) in a predicable and safe way (flattening: see the first Traits white paper).<br></p><p>i.e. we get the same result regardless of the order of consumption, how many times any given Trait(s) were consumed, Traits dependent on other Traits etc.  Predictable results, given the same input we always get the same output.  This is flattening, but read the white papers for more detail.<br></p><p>The process of flattening itself could be a peer of the existing rules around static dispatch vs. dynamic dispatch around default-implementations/extensions vs. class overrides.<br></p><p>A Trait declaration could look something ~like:<br></p><p> 	trait TraitX (ProtocolAdherenceY): DependentTrait1, DependentTrait2 {<br></p><p> 		private var foo<br> 		private let bah { .. }<br></p><p> 		func fooify { .. }<br> 		mutating func bahify { .. }<br> 		private func hah { .. }<br></p><p> 	}<br></p><p>with a Trait being a closure, where _only private_ data Properties can be declared, providing 1..N function implementations.  It could conform _towards_ a Protocol (partial to full conformance), and also be dependent upon other names Traits, which would be consumed in parallel as a first-class citizen with the Trait that depends on it.<br></p><p>Traits could be consumed by a class or value type, to provide function implementations which could be satisfying a Protocol implementation requirement, along with its own private functions and private data for its (private to Trait) local state etc.  The consumption syntax I&#39;m still unsure of, but a clear declarative &quot;flattens Trait1, Trait2, .. , TraitN&quot; or similar would do.<br></p><p>The consuming Class or Value Type would remain fully responsible for its own Protocol conformance, and if any of the consumed Trait public implementations conflict or overlap with each other, then the conflicts must be resolved explicitly by the Class or Value Type itself, where it is consumed.<br></p><p>The resulting &quot;flattened&quot; set of Traits would be input towards the Type&#39;s own compiler requirements, with the author being required to explicitly resolve any and all conflicts at compile-time.  Cconsumption at run-time could be a later feature as Swift&#39;s core stabilises and specific run-time metaprogramming facilities are exposed.<br></p><p>Explicit conflict resolution, via a flattened 2D matrix of Trait:func identifying conflicts that need to be resolved by the consumer, also gives reliable results with no cognitive overhead as Brian&#39;s identified in resolving Mixin consumption.  Plus there is no diamond-problem, as there is no inheritance.  With Traits, it _must_ be resolved explicitly in code, with suitable compiler errors for malformed Types that have consumed 1..N Trait(s).<br></p><p>Stateful Traits suggest that as long as the data is private _to the Trait_ then we can safely ignore some of the complexity of state in Traits - it just isn&#39;t exposed as the Trait declaration itself is a closure.  Dependency on state in the consumer could proxy to class/instance/value-type data via Protocol.<br></p><p>Swift and Protocols seem like a perfect match for &quot;capital-T&quot; Traits.  Any thoughts on if this is suitable for a 3.0 or 4.0 Proposal?<br></p><p>I&#39;ve recently built similar mechanisms exploring these concepts with basic metaprogramming and a common root class in a dynamic language, but as a core language feature of Swift I think it could very much complement the existing protocols and extension concepts, with 1..N re-usable implementations, and it also could help to resolves the uncertainty/rules around static vs. dynamic dispatch: static could remain the domain of extensions / default implementations; with dynamic dispatch available to Classes and Traits?<br></p><p>More Reading:<br></p><p> 	http://scg.unibe.ch/research/traits<br></p><p>Cheers,<br></p><p>--<br>Niall Young<br>niall at iinet.net.au<br></p><p><br>At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br></p><p>&gt; I think this sort of composition is preferable to inheritance in a lot of<br>&gt; ways, and Swift has some built-in tools that can augment it: a robust<br>&gt; protocol and extension system, a type constraint system that allows for<br>&gt; lots of flexibility at compile-time, etc.<br>&gt; <br>&gt; Mixins (and in general, the sharing of code primarily via inheritance) tend<br>&gt; to create large objects with lots of responsibilities, and that tends to<br>&gt; bloat APIs as you need to either pick extremely specific names to avoid<br>&gt; collisions, or worse, keep the cognitive overhead of &quot;shoot, what is this<br>&gt; method aliased to again?&quot; in your head all the time. If something *is* both<br>&gt; an A and a B, it needs to act like (and speak the same language of) an A or<br>&gt; a B *all* of the time.<br>&gt; <br>&gt; Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt; compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt; class C that inherits from bases A and B, which implement protocol P and Q<br>&gt; respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>&gt; Qs will have to know about the renaming of conflicts from the combination<br>&gt; of A+B? Unless I&#39;m missing something, it feels like this complexity would<br>&gt; continue to spread out to all sorts of collaborators, when the current<br>&gt; system isolates it much more effectively.<br></p><p>&gt; I think protocols and protocol extensions (mixed with lots of composition)<br>&gt; is a better scenario than abstract classes or multiple inheritance, and<br>&gt; therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle; this<br>&gt; proposal actually argues the case very well).<br>&gt;<br>&gt; - Brian<br></p><p>And agreed Thorsten!:<br></p><p>&gt;&gt; Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt;&gt; vs. OOP suffer from having forgotten achievements of the past which results<br>&gt;&gt; in creating differences where none should be.<br></p><p>&gt;&gt; It is unfortunate and IMO just for historical reasons that there is a<br>&gt;&gt; dichotomy between protocols and classes at all instead of having just<br>&gt;&gt; classes with multiple inheritance done right (and abstract methods).<br></p><p>&gt;&gt; - We should extend protocols to support real multiple inheritance with<br>&gt;&gt; renaming<br></p><p>&gt;&gt; -Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>April 21, 2016 at 05:00:00pm</p></header><div class="content"><p>Another traits implemenation<br></p><p>http://php.net/manual/en/language.oop5.traits.php<br>On Apr 21, 2016 5:53 PM, &quot;Niall Young via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;<br>&gt; I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt;&gt; Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt;&gt; mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt;&gt; member data) or inheritance (which, as you mentioned, can only have one<br>&gt;&gt; base type) -- it&#39;s to extract a third type that handles<br>&gt;&gt;<br>&gt;<br>&gt; What you&#39;re describing sounds _exactly_ like Traits :-)<br>&gt;<br>&gt;         http://scg.unibe.ch/research/traits<br>&gt;<br>&gt; Traits could be a peer of extensions, filling a niche that isn&#39;t quite the<br>&gt; same niche as a default implementation, but it could be consistently and<br>&gt; safely consumed like an extension, with its own rules of consumption<br>&gt; (flattening) - to implement any need or explicit protocol requirement that<br>&gt; a Class, Value Type or Protocol has at compile-time.<br>&gt;<br>&gt; Think of a Trait as providing a consumable set of functions.  Now imagine<br>&gt; that we&#39;re combining the collective declarations of 1..N Traits all<br>&gt; together, consumed by a Class or Value Type (or Protocol!) in a predicable<br>&gt; and safe way (flattening: see the first Traits white paper).<br>&gt;<br>&gt; i.e. we get the same result regardless of the order of consumption, how<br>&gt; many times any given Trait(s) were consumed, Traits dependent on other<br>&gt; Traits etc.  Predictable results, given the same input we always get the<br>&gt; same output.  This is flattening, but read the white papers for more detail.<br>&gt;<br>&gt; The process of flattening itself could be a peer of the existing rules<br>&gt; around static dispatch vs. dynamic dispatch around<br>&gt; default-implementations/extensions vs. class overrides.<br>&gt;<br>&gt; A Trait declaration could look something ~like:<br>&gt;<br>&gt;         trait TraitX (ProtocolAdherenceY): DependentTrait1,<br>&gt; DependentTrait2 {<br>&gt;<br>&gt;                 private var foo<br>&gt;                 private let bah { .. }<br>&gt;<br>&gt;                 func fooify { .. }<br>&gt;                 mutating func bahify { .. }<br>&gt;                 private func hah { .. }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt; with a Trait being a closure, where _only private_ data Properties can be<br>&gt; declared, providing 1..N function implementations.  It could conform<br>&gt; _towards_ a Protocol (partial to full conformance), and also be dependent<br>&gt; upon other names Traits, which would be consumed in parallel as a<br>&gt; first-class citizen with the Trait that depends on it.<br>&gt;<br>&gt; Traits could be consumed by a class or value type, to provide function<br>&gt; implementations which could be satisfying a Protocol implementation<br>&gt; requirement, along with its own private functions and private data for its<br>&gt; (private to Trait) local state etc.  The consumption syntax I&#39;m still<br>&gt; unsure of, but a clear declarative &quot;flattens Trait1, Trait2, .. , TraitN&quot;<br>&gt; or similar would do.<br>&gt;<br>&gt; The consuming Class or Value Type would remain fully responsible for its<br>&gt; own Protocol conformance, and if any of the consumed Trait public<br>&gt; implementations conflict or overlap with each other, then the conflicts<br>&gt; must be resolved explicitly by the Class or Value Type itself, where it is<br>&gt; consumed.<br>&gt;<br>&gt; The resulting &quot;flattened&quot; set of Traits would be input towards the Type&#39;s<br>&gt; own compiler requirements, with the author being required to explicitly<br>&gt; resolve any and all conflicts at compile-time.  Cconsumption at run-time<br>&gt; could be a later feature as Swift&#39;s core stabilises and specific run-time<br>&gt; metaprogramming facilities are exposed.<br>&gt;<br>&gt; Explicit conflict resolution, via a flattened 2D matrix of Trait:func<br>&gt; identifying conflicts that need to be resolved by the consumer, also gives<br>&gt; reliable results with no cognitive overhead as Brian&#39;s identified in<br>&gt; resolving Mixin consumption.  Plus there is no diamond-problem, as there is<br>&gt; no inheritance.  With Traits, it _must_ be resolved explicitly in code,<br>&gt; with suitable compiler errors for malformed Types that have consumed 1..N<br>&gt; Trait(s).<br>&gt;<br>&gt; Stateful Traits suggest that as long as the data is private _to the Trait_<br>&gt; then we can safely ignore some of the complexity of state in Traits - it<br>&gt; just isn&#39;t exposed as the Trait declaration itself is a closure.<br>&gt; Dependency on state in the consumer could proxy to<br>&gt; class/instance/value-type data via Protocol.<br>&gt;<br>&gt; Swift and Protocols seem like a perfect match for &quot;capital-T&quot; Traits.  Any<br>&gt; thoughts on if this is suitable for a 3.0 or 4.0 Proposal?<br>&gt;<br>&gt; I&#39;ve recently built similar mechanisms exploring these concepts with basic<br>&gt; metaprogramming and a common root class in a dynamic language, but as a<br>&gt; core language feature of Swift I think it could very much complement the<br>&gt; existing protocols and extension concepts, with 1..N re-usable<br>&gt; implementations, and it also could help to resolves the uncertainty/rules<br>&gt; around static vs. dynamic dispatch: static could remain the domain of<br>&gt; extensions / default implementations; with dynamic dispatch available to<br>&gt; Classes and Traits?<br>&gt;<br>&gt; More Reading:<br>&gt;<br>&gt;         http://scg.unibe.ch/research/traits<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; --<br>&gt; Niall Young<br>&gt; niall at iinet.net.au<br>&gt;<br>&gt;<br>&gt; At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt;<br>&gt; I think this sort of composition is preferable to inheritance in a lot of<br>&gt;&gt; ways, and Swift has some built-in tools that can augment it: a robust<br>&gt;&gt; protocol and extension system, a type constraint system that allows for<br>&gt;&gt; lots of flexibility at compile-time, etc.<br>&gt;&gt;<br>&gt;&gt; Mixins (and in general, the sharing of code primarily via inheritance)<br>&gt;&gt; tend<br>&gt;&gt; to create large objects with lots of responsibilities, and that tends to<br>&gt;&gt; bloat APIs as you need to either pick extremely specific names to avoid<br>&gt;&gt; collisions, or worse, keep the cognitive overhead of &quot;shoot, what is this<br>&gt;&gt; method aliased to again?&quot; in your head all the time. If something *is*<br>&gt;&gt; both<br>&gt;&gt; an A and a B, it needs to act like (and speak the same language of) an A<br>&gt;&gt; or<br>&gt;&gt; a B *all* of the time.<br>&gt;&gt;<br>&gt;&gt; Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt;&gt; compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt;&gt; class C that inherits from bases A and B, which implement protocol P and Q<br>&gt;&gt; respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>&gt;&gt; Qs will have to know about the renaming of conflicts from the combination<br>&gt;&gt; of A+B? Unless I&#39;m missing something, it feels like this complexity would<br>&gt;&gt; continue to spread out to all sorts of collaborators, when the current<br>&gt;&gt; system isolates it much more effectively.<br>&gt;&gt;<br>&gt;<br>&gt; I think protocols and protocol extensions (mixed with lots of composition)<br>&gt;&gt; is a better scenario than abstract classes or multiple inheritance, and<br>&gt;&gt; therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle; this<br>&gt;&gt; proposal actually argues the case very well).<br>&gt;&gt;<br>&gt;&gt; - Brian<br>&gt;&gt;<br>&gt;<br>&gt; And agreed Thorsten!:<br>&gt;<br>&gt; Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt;&gt;&gt; vs. OOP suffer from having forgotten achievements of the past which<br>&gt;&gt;&gt; results<br>&gt;&gt;&gt; in creating differences where none should be.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; It is unfortunate and IMO just for historical reasons that there is a<br>&gt;&gt;&gt; dichotomy between protocols and classes at all instead of having just<br>&gt;&gt;&gt; classes with multiple inheritance done right (and abstract methods).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; - We should extend protocols to support real multiple inheritance with<br>&gt;&gt;&gt; renaming<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/217ba4af/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April 21, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 21, 2016, at 3:52 AM, Niall Young via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; At Tue Mar 1 19:00:21 CST 2016, Brian Pratt brian at pratt.io wrote:<br>&gt; <br>&gt;&gt; I feel like the solution to the Arrow/Enemy problem that best fits with<br>&gt;&gt; Swift&#39;s current available tools is neither a protocol (which, as you<br>&gt;&gt; mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>&gt;&gt; member data) or inheritance (which, as you mentioned, can only have one<br>&gt;&gt; base type) -- it&#39;s to extract a third type that handles<br>&gt; <br>&gt; What you&#39;re describing sounds _exactly_ like Traits :-)<br>&gt; <br>&gt; 	http://scg.unibe.ch/research/traits<br>&gt; <br>&gt; Traits could be a peer of extensions, filling a niche that isn&#39;t quite the same niche as a default implementation, but it could be consistently and safely consumed like an extension, with its own rules of consumption (flattening) - to implement any need or explicit protocol requirement that a Class, Value Type or Protocol has at compile-time.<br>&gt; <br>&gt; Think of a Trait as providing a consumable set of functions.  Now imagine that we&#39;re combining the collective declarations of 1..N Traits all together, consumed by a Class or Value Type (or Protocol!) in a predicable and safe way (flattening: see the first Traits white paper).<br></p><p>extensions give us something trait-like, but with only one, non-opt-in implementation and usually per protocol. I’d imagine a true trait system to allow for more specific default implementations of Sequence, for example.<br></p><p>&gt; i.e. we get the same result regardless of the order of consumption, how many times any given Trait(s) were consumed, Traits dependent on other Traits etc.  Predictable results, given the same input we always get the same output.  This is flattening, but read the white papers for more detail.<br>&gt; <br>&gt; The process of flattening itself could be a peer of the existing rules around static dispatch vs. dynamic dispatch around default-implementations/extensions vs. class overrides.<br>&gt; <br>&gt; A Trait declaration could look something ~like:<br>&gt; <br>&gt; 	trait TraitX (ProtocolAdherenceY): DependentTrait1, DependentTrait2 {<br>&gt; <br>&gt; 		private var foo<br>&gt; 		private let bah { .. }<br>&gt; <br>&gt; 		func fooify { .. }<br>&gt; 		mutating func bahify { .. }<br>&gt; 		private func hah { .. }<br>&gt; <br>&gt; 	}<br>&gt; <br>&gt; with a Trait being a closure, where _only private_ data Properties can be declared, providing 1..N function implementations.  It could conform _towards_ a Protocol (partial to full conformance), and also be dependent upon other names Traits, which would be consumed in parallel as a first-class citizen with the Trait that depends on it.<br></p><p>Traits typically cannot declare fields/state. Is this not where you start to cross over to Mixins?<br></p><p>I attempted to model this (today) via delegates for behavioral dependencies on traits and self-wiring, but this creates issues with value type copying and circular references in reference types. For that reason, I didn’t feel it was appropriate to make a formal trait proposal until more definition toward behaviors (e.g. Joe Groff’s property behaviors) or macros were in the discussion.<br></p><p>&lt;snip&gt;<br>&gt; Stateful Traits suggest that as long as the data is private _to the Trait_ then we can safely ignore some of the complexity of state in Traits - it just isn&#39;t exposed as the Trait declaration itself is a closure.  Dependency on state in the consumer could proxy to class/instance/value-type data via Protocol.<br></p><p>Yes, but this means that said data may be duplicated and need to be kept in sync between traits and the main type. It also means that traits cannot be used while extending an existing type to meet new protocol requirements outside a module, as that may change the size of the type itself to be different than what precompiled code expects.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/225242c158c149635596c786c8971fbc?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Niall Young</string> &lt;niall at iinet.net.au&gt;<p>April 22, 2016 at 10:00:00am</p></header><div class="content"><p>On Thu, 21 Apr 2016, David Waite wrote:<br></p><p>&gt;&gt; Think of a Trait as providing a consumable set of functions.  Now imagine that we&#39;re combining the collective declarations of 1..N Traits all together, consumed by a Class or Value Type (or Protocol!) in a predicable and safe way (flattening: see the first Traits white paper).<br>&gt;<br>&gt; extensions give us something trait-like, but with only one, non-opt-in implementation and usually per protocol. I’d imagine a true trait system to allow for more specific default implementations of Sequence, for example.<br></p><p>Exactly, Sequence protocol requirements could be met and provided directly by any Trait(s) consumed by the protocol as default implementation(s), or consumed by a Class or Value Type to partially or fully meet its protocol conformance requirements.  Fine-grained Traits of behaviour could be consumed in many different contexts, so it&#39;s similar in some respects to AOP in that the code relating to that &quot;aspect&quot; or behaviour is centralised into a composable entity which any class, value type or protocol could consume and use.<br></p><p>&gt;&gt; with a Trait being a closure, where _only private_ data Properties can be declared, providing 1..N function implementations.  It could conform _towards_ a Protocol (partial to full conformance), and also be dependent upon other names Traits, which would be consumed in parallel as a first-class citizen with the Trait that depends on it.<br>&gt;<br>&gt; Traits typically cannot declare fields/state. Is this not where you start to cross over to Mixins?<br></p><p>The Stateful Traits papers have explored the issues with introducing state on top of behaviour, but a simple solution to avoid this complexity is to not allow state period, or keep all state private to the Trait and never visible to any Trait consumer.  I wouldn&#39;t necessarily mandate that Traits for Swift should or could deal with state, they could be method-only behaviours and side-step these issues entirely, declaring their own requirements in terms of state that the consumer must provide, for example, or adherence to a protocol that the consumer must satisfy.<br></p><p>&gt; I attempted to model this (today) via delegates for behavioral dependencies on traits and self-wiring, but this creates issues with value type copying and circular references in reference types. For that reason, I didn’t feel it was appropriate to make a formal trait proposal until more definition toward behaviors (e.g. Joe Groff’s property behaviors) or macros were in the discussion.<br></p><p>I&#39;ll do some reading - was this a previous swift-evolution thread?  I&#39;ve not started looking at Swift&#39;s own implementation, so I haven&#39;t thought out exactly how they could be implemented, but on the surface at a syntactic and feature level it seems like a good fit for Swift and a perfect complement to protocols, enabling fine-grained code re-use with inherent predictability and safety.<br></p><p>&gt; &lt;snip&gt;<br>&gt;&gt; Stateful Traits suggest that as long as the data is private _to the Trait_ then we can safely ignore some of the complexity of state in Traits - it just isn&#39;t exposed as the Trait declaration itself is a closure.  Dependency on state in the consumer could proxy to class/instance/value-type data via Protocol.<br>&gt;<br>&gt; Yes, but this means that said data may be duplicated and need to be kept in sync between traits and the main type. It also means that traits cannot be used while extending an existing type to meet new protocol requirements outside a module, as that may change the size of the type itself to be different than what precompiled code expects.<br></p><p>If I understand you correctly (please elaborate if I don&#39;t :)) the data that a Trait owns would never be visible to any consumer, other Trait(s), or any other instance where that same Trait has been consumed.  It wouldn&#39;t necessarily need to be stored against the consuming Type, only made visible to that specific Trait &quot;instance&quot; for use by its methods.  Trait data wouldn&#39;t be shared with any other code, the consumer or even other &quot;instances&quot; of that Trait being consumed elsewhere, so I think of it more as lexically scoped private variables - similar to contextual data visible to a closure, yet no other code will be able to see or access them.  It wouldn&#39;t necessarily need to be stored with the consuming Type, but I don&#39;t know if that&#39;s even feasible or desirable yet.<br></p><p>Exactly how Traits could be implemented under the hood for Swift - I&#39;ll do some reading and walk through the source, but others would be better placed to comment on the feasibility of this right now.  I&#39;m curious, so I&#39;ll see what I can come up with on my own.<br></p><p>Cheers,<br></p><p>--<br>Niall Young<br>niall at iinet.net.au<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
