<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>This thread is related to the review of new API guidelines, but it&#39;s not<br>a review thread; it&#39;s exploratory.  The goal is to come up with<br>guidelines that:<br></p><p>* describe when and where to use argument labels<br>* require labels in many of the cases people have asked for them<br>* are understandable by humans<br>* preserve important semantics communicated by existing APIs.<br></p><p>Here&#39;s what I&#39;m thinking<br></p><p>1. If and only if the first argument could complete a sentence*<br>   beginning in the base name and describing the primary semantics of<br>   the call, it gets no argument label:<br></p><p>     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br></p><p>     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>                            // doesn&#39;t describe the semantics at all, <br>                            // thus we add a label for b.<br></p><p>     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>                              // but doesn&#39;t describe the primary <br>                              // semantics, which are to move in both<br>                              // x and y.  Thus, x gets a label.<br></p><p>     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>                              // the primary semantics, so u gets no<br>                              // label. b is an<br>                              // option that tunes the primary<br>                              // semantics<br></p><p>   [Note that this covers all the direct object cases and, I believe,<br>   all the default argument cases too, so maybe that exception can be<br>   dropped.  We still need the exceptions for full-width type<br>   conversions and indistinguishable peers]<br></p><p>   Note: when there is a noun in the base name describing the role of the<br>   first argument, we skip it in considering this criterion:<br></p><p>      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>                       // the semantics.  &quot;Observer&quot; is omitted in <br>                       // making this determination.<br></p><p>* We could say &quot;clause&quot; here but I think making it an *independent*<br>  clause doesn&#39;t rule out any important use-cases (see<br>  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>  point, you might as well say &quot;sentence,&quot; which is a more<br>  universally-understood term.<br></p><p>2. Words that describe attributes of an *already-existing* instance<br>   should go in the base name rather than in a label:<br></p><p>      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br></p><p>      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br></p><p>   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>   ambiguous]<br></p><p>   Words that describe attributes of an instance *to be created* should<br>   go in argument labels, rather than the base name (for parity with<br>   initializers):<br></p><p>      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br></p><p>      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br></p><p>3. (this one is separable) When the first argument is the *name* or<br>   *identifier* of the subject in the base name, do not label it or<br>   describe it in the base name.<br></p><p>      a.transitionToScene(.GreatHall)               // yes<br>      a.transitionToSceneWithIdentifier(.GreatHall) // no<br></p><p>      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br></p><p>Thoughts?<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 for 1 and 3<br>-1 for 2<br></p><p>I didn&#39;t take to 2, the no examples seemed as least as clear as the yes,<br>e.g. I liked:<br></p><p>    a.tracks(mediaType: &quot;Wax Cylinder&quot;)<br></p><p>and it is consistent with everything else. Therefore I suggest you just<br>delete clause 2.<br></p><p>(Very nice write up of your thoughts!)<br></p><p><br>On 3 February 2016 at 11:32, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt;<br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt;<br>&gt; Here&#39;s what I&#39;m thinking<br>&gt;<br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;    beginning in the base name and describing the primary semantics of<br>&gt;    the call, it gets no argument label:<br>&gt;<br>&gt;      a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;      a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;<br>&gt;      a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;                             // doesn&#39;t describe the semantics at all,<br>&gt;                             // thus we add a label for b.<br>&gt;<br>&gt;      a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;                               // but doesn&#39;t describe the primary<br>&gt;                               // semantics, which are to move in both<br>&gt;                               // x and y.  Thus, x gets a label.<br>&gt;<br>&gt;      a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                               // the primary semantics, so u gets no<br>&gt;                               // label. b is an<br>&gt;                               // option that tunes the primary<br>&gt;                               // semantics<br>&gt;<br>&gt;    [Note that this covers all the direct object cases and, I believe,<br>&gt;    all the default argument cases too, so maybe that exception can be<br>&gt;    dropped.  We still need the exceptions for full-width type<br>&gt;    conversions and indistinguishable peers]<br>&gt;<br>&gt;    Note: when there is a noun in the base name describing the role of the<br>&gt;    first argument, we skip it in considering this criterion:<br>&gt;<br>&gt;       a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;                        // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;                        // making this determination.<br>&gt;<br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;   clause doesn&#39;t rule out any important use-cases (see<br>&gt;   https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;   point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;   universally-understood term.<br>&gt;<br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;    should go in the base name rather than in a label:<br>&gt;<br>&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;<br>&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;<br>&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;    ambiguous]<br>&gt;<br>&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;    initializers):<br>&gt;<br>&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;    *identifier* of the subject in the base name, do not label it or<br>&gt;    describe it in the base name.<br>&gt;<br>&gt;       a.transitionToScene(.GreatHall)               // yes<br>&gt;       a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;<br>&gt;       let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;       let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;       let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/2ce5febc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 to all three of these.<br></p><p>Charles<br></p><p>&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  2, 2016 at 06:00:00pm</p></header><div class="content"><p>+1. This list makes sense to me. <br></p><p>Wish I had the time to give this more thought, as argument labels are one of my favorite features of Swift.  I’m glad to see them getting the amount of discussion they have though.<br></p><p>Matt<br></p><p><br>&gt; On Feb 2, 2016, at 16:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February  2, 2016 at 06:00:00pm</p></header><div class="content"><p>+1 to all three rules. One question though: is Rule 2 intended to apply to cases where there are multiple “attribute” parameters? Would it be:<br></p><p>a.tracksHavingMediaType(“Wax Cylinder”, genre: “Jazz”)<br>or:<br>a.tracks(mediaType: “Wax Cylinder” , genre: “Jazz”)<br>or, for that matter:<br>a.tracksMatching(mediaType: “Wax Cylinder” , genre: “Jazz”)<br>?<br></p><p>The “sentence” requirement of Rule 1 doesn’t seem to be met here, but the “primary semantics” part would still apply?<br></p><p>—CK<br></p><p>&gt; On Feb 2, 2016, at 4:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>February  2, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 for 1, with an asterisk<br>mixed feelings about 2<br>+1 for 3<br></p><p>Notes inline below.<br></p><p><br>&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br></p><p>Yes. The thoughts of “sentence” and “primary semantics” succinctly capture a lot of good ideas from previous discussion.<br></p><p>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br></p><p>All these examples seem totally solid.<br></p><p>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br></p><p>Not sure about this one in theory … but yes, I can see how it would play out that way in practice.<br></p><p>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br></p><p>Not sure you need this complicating exception. “a, add observer b” is still a sentence.<br></p><p>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br></p><p>Yes.<br></p><p>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br></p><p>I have reservations about this. It doesn’t generalize perfectly well:<br></p><p>	a.tracksHavingMediaType(&quot;Wax Cylinder”, andPianist: “Brahms”)<br></p><p>…strikes me as awkward compared to one of these:<br></p><p>	a.tracksHaving(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br>	// or <br>	a.tracksMatchingCriteria(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br>	// or even<br>	a.tracks(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br></p><p>…especially since, in a method of that form, _all_ the arguments are likely to have a default value of nil:<br></p><p>	a.tracks(mediaType: &quot;Wax Cylinder”)<br>	a.tracks(pianist: “Brahms”)<br></p><p>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br></p><p>Yes, definitely.<br></p><p>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br></p><p>Yes, seems solid.<br></p><p>Cheers, P<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>I tend to agree with Paul and Charles&#39; concerns here. I think it&#39;s still missing Erica&#39;s point about some paramaters being more tightly coupled to each other than to the base name. That&#39;s sort of addressed with this:<br></p><p>&gt;    a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                             // but doesn&#39;t describe the primary <br>&gt;                             // semantics, which are to move in both<br>&gt;                             // x and y.  Thus, x gets a label.<br></p><p>but I think &quot;describing the primary semantics of the call&quot; could be more explicit. Even just the word &quot;fully [describing]&quot; would help. Given that, &quot;a.tracksHavingMediaType(.WaxCylinder, genre: .Jazz)&quot; would be incorrect, because you can&#39;t ignore the &quot;genre&quot; part when describing the call. &#39;tracks(mediaType:genre:)&#39; or &#39;tracksMatching(mediaType:genre:)&#39; would both be fine, though the former includes a new convention that plural noun basenames mean filtered fetches.<br></p><p>Then the next problem is that the first version of the library may only have one form, and &quot;tracksMatching(mediaType:)&quot; would seem redundant, so it&#39;s just &quot;tracksMatching(_:)&quot;. Then the two-argument form is added later, and suddenly they&#39;re not quite symmetrical. On second thought, maybe that&#39;s okay as long as they have the same base name.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/5f5bca80/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  3, 2016 at 07:00:00am</p></header><div class="content"><p>I have one comment (below) about this part:<br></p><p>&gt; On Feb 2, 2016, at 18:59, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have reservations about this. It doesn’t generalize perfectly well:<br>&gt; <br>&gt; 	a.tracksHavingMediaType(&quot;Wax Cylinder”, andPianist: “Brahms”)<br>&gt; <br>&gt; …strikes me as awkward compared to one of these:<br>&gt; <br>&gt; 	a.tracksHaving(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br>&gt; 	// or <br>&gt; 	a.tracksMatchingCriteria(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br>&gt; 	// or even<br>&gt; 	a.tracks(mediaType: &quot;Wax Cylinder”, pianist: “Brahms”)<br>&gt; <br>&gt; …especially since, in a method of that form, _all_ the arguments are likely to have a default value of nil:<br>&gt; <br>&gt; 	a.tracks(mediaType: &quot;Wax Cylinder”)<br>&gt; 	a.tracks(pianist: “Brahms”)<br></p><p>I prefer the original:<br></p><p>a.tracksHavingMediaType(&quot;Wax Cylinder&quot;, andPianist: &quot;Brahms”)<br></p><p>to any of these,<br></p><p>a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;, pianist: &quot;Brahms&quot;)<br>// or<br>a.tracksMatchingCriteria(mediaType: &quot;Wax Cylinder&quot;, pianist: &quot;Brahms&quot;)<br>// or even<br>a.tracks(mediaType: &quot;Wax Cylinder&quot;, pianist: &quot;Brahms”)<br></p><p>Because to me, the 3 alternatives, especially the last one, all read more like hashmap accesses than method calls.  In other words, they make it appear as if you are passing in arbitrary keys to be queried, rather than calling one specific method.<br></p><p>Matt<br></p><p> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/e82ba4ca/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February  3, 2016 at 02:00:00am</p></header><div class="content"><p>+1. This is the propose that make more sense for me until now. :-)<br></p><p>On Tue, Feb 2, 2016 at 10:32 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt;<br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt;<br>&gt; Here&#39;s what I&#39;m thinking<br>&gt;<br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;    beginning in the base name and describing the primary semantics of<br>&gt;    the call, it gets no argument label:<br>&gt;<br>&gt;      a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;      a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;<br>&gt;      a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;                             // doesn&#39;t describe the semantics at all,<br>&gt;                             // thus we add a label for b.<br>&gt;<br>&gt;      a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;                               // but doesn&#39;t describe the primary<br>&gt;                               // semantics, which are to move in both<br>&gt;                               // x and y.  Thus, x gets a label.<br>&gt;<br>&gt;      a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                               // the primary semantics, so u gets no<br>&gt;                               // label. b is an<br>&gt;                               // option that tunes the primary<br>&gt;                               // semantics<br>&gt;<br>&gt;    [Note that this covers all the direct object cases and, I believe,<br>&gt;    all the default argument cases too, so maybe that exception can be<br>&gt;    dropped.  We still need the exceptions for full-width type<br>&gt;    conversions and indistinguishable peers]<br>&gt;<br>&gt;    Note: when there is a noun in the base name describing the role of the<br>&gt;    first argument, we skip it in considering this criterion:<br>&gt;<br>&gt;       a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;                        // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;                        // making this determination.<br>&gt;<br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;   clause doesn&#39;t rule out any important use-cases (see<br>&gt;   https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;   point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;   universally-understood term.<br>&gt;<br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;    should go in the base name rather than in a label:<br>&gt;<br>&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;<br>&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;<br>&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;    ambiguous]<br>&gt;<br>&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;    initializers):<br>&gt;<br>&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;    *identifier* of the subject in the base name, do not label it or<br>&gt;    describe it in the base name.<br>&gt;<br>&gt;       a.transitionToScene(.GreatHall)               // yes<br>&gt;       a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;<br>&gt;       let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;       let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;       let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/c591b6e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>Thoughts? Thoughts:<br></p><p>Swift prizes clarity. Its parameter labeling system emphasizes self-documentation and guides code production. In nearly every case, labels follow three simple rules:<br></p><p>Skip argument labels for a method or function&#39;s first parameter<br>Use argument labels for a method or function&#39;s subsequent parameters<br>Require argument labels for initializers<br>These base rules enhance Swift legibility. Unlike other languages whose positional argument names have meaning only within the implementation context, Swift&#39;s labels convey use and meaning at the calling site. This creates better communication, enhances maintainability, and adheres to the principle that code is written rarely and read and reviewed often.<br></p><p>At times, special circumstances may apply to your code as explored in the following rules:<br></p><p>Skip first argument labels when the first argument completes a sentence established in the base name. If the argument describes a call&#39;s primary semantics, it does not require a label:<br>    a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>    a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>    a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>                             // primary semantics so u gets no<br>                             // label. <br>                             // b is an option that tunes the <br>                             // primary semantics<br>Skip the first argument label when a noun in the base name describes the first argument&#39;s role.<br>   a.addObserver(b) // &quot;add b&quot; completes a meaningful sentence that<br>                    // defines the intentended semantics.  The first<br>                    // argument is the &quot;Observer&quot;.<br>Move the first argument label to the base name when it describes a name or identifier that acts as the subject of the base action.<br>     a.transitionToScene(.GreatHall)               // yes<br>     a.transitionToSceneWithIdentifier(.GreatHall) // no<br></p><p>     let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>     let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>     let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>Move the first argument label to the base name when it describes argument attributes of existing instances.<br>     a.tracksOfMediaType(&quot;Wax Cylinder&quot;)      // yes<br>     a.removeFirstTrackOfMediaType(&quot;BetaMax&quot;) // yes<br></p><p>     a.tracks(mediaType: &quot;Wax Cylinder&quot;)            // no<br>     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>Use first label arguments when the first parameter is semantically distinct from the base name and does not complete a meaningful &quot;sentence&quot;<br>    a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>                           // doesn&#39;t describe the semantics at all, <br>                           // thus we add a label for b.<br>Use all argument labels when the relationship between arguments is semantically stronger than the relationship between the first argument and the base name.<br>    moveTo(x: a, y: b)<br>    login(userName: a, password: b)<br>    constructColor(red: r, green: g, blue: b, alpha: a)<br>Omit labels for argument peers that cannot be usefully distinguished.<br>    min(number1, number2)<br>    zip(sequence1, sequence2)<br>Use explicit argument labels to describe attributes of an instance that&#39;s being created. Your calls should resemble initializers.<br>     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br></p><p>     trackFactory.newTrackOfMediaType(&quot;Wax Cylinder&quot;)   // no<br>Use first argument labels that would have normally appeared in the base name when building groups of related calls whose implementations are distinguished specifically by their parameters. Your calls should resemble initializers. <br>  login(userName: a, password: b) // not loginWithUserName(a, password: b)<br>  login(credential: a) // not loginWithCredential(a)<br>Skip first argument labels for initializers when using full width type conversions, that is when initializing from instances of another type.<br> extension String { <br>     // Convert `x` into its textual representation <br>     // in the given radix<br>     init(_ x: BigInt, radix: Int = 10) <br> }<br> text = &quot;The value is: &quot;<br> text += String(veryLargeNumber)<br> text += &quot; and in hexadecimal, it&#39;s&quot;<br> text += String(veryLargeNumber, radix: 16)<br>Use first argument labels when narrowing initial values to make it conform to restrictions within the new type. The label should describe how the instance will be modified:<br> extension UInt32 {<br>     init(_ value: Int16) // Widening, so no label <br>     init(truncating bits: UInt64)<br>     init(saturating value: UInt64)<br> }<br></p><p><br>-- E<br></p><p><br>&gt; On Feb 2, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/15025923/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February  3, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Erica and Dave,<br></p><p>I personally like it and I agree with all except the following:<br></p><p>let p = someFont.glyph(&quot;propellor&quot;)<br>let p = someFont.glyphWithName(&quot;propellor&quot;)<br></p><p>I found the second one more clear.  I am not familiar with the API and when I read the first one I started wondering what it would do. Then I read glyphWithName() and I knew that I would be getting me a glyph back named &quot;propellor&quot;. <br></p><p>Also, the bullet reads:<br>&gt; Move the first argument label to the base name when it describes a name or identifier that acts as the subject of the base action<br>I think it should also mention that the word &quot;Name&quot; and &quot;Identifier&quot; should be omitted from the base name of the function or method. <br></p><p>Everything else looks great in my opinion. <br></p><p>Thank you<br></p><p><br>Sent from my iPhone<br></p><p>&gt; On Feb 3, 2016, at 12:07 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thoughts? Thoughts:<br>&gt; <br>&gt; Swift prizes clarity. Its parameter labeling system emphasizes self-documentation and guides code production. In nearly every case, labels follow three simple rules:<br>&gt; <br>&gt; Skip argument labels for a method or function&#39;s first parameter<br>&gt; Use argument labels for a method or function&#39;s subsequent parameters<br>&gt; Require argument labels for initializers<br>&gt; These base rules enhance Swift legibility. Unlike other languages whose positional argument names have meaning only within the implementation context, Swift&#39;s labels convey use and meaning at the calling site. This creates better communication, enhances maintainability, and adheres to the principle that code is written rarely and read and reviewed often.<br>&gt; <br>&gt; At times, special circumstances may apply to your code as explored in the following rules:<br>&gt; <br>&gt; Skip first argument labels when the first argument completes a sentence established in the base name. If the argument describes a call&#39;s primary semantics, it does not require a label:<br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // primary semantics so u gets no<br>&gt;                              // label. <br>&gt;                              // b is an option that tunes the <br>&gt;                              // primary semantics<br>&gt; Skip the first argument label when a noun in the base name describes the first argument&#39;s role.<br>&gt;    a.addObserver(b) // &quot;add b&quot; completes a meaningful sentence that<br>&gt;                     // defines the intentended semantics.  The first<br>&gt;                     // argument is the &quot;Observer&quot;.<br>&gt; Move the first argument label to the base name when it describes a name or identifier that acts as the subject of the base action.<br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; Move the first argument label to the base name when it describes argument attributes of existing instances.<br>&gt;      a.tracksOfMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackOfMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)            // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; Use first label arguments when the first parameter is semantically distinct from the base name and does not complete a meaningful &quot;sentence&quot;<br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; Use all argument labels when the relationship between arguments is semantically stronger than the relationship between the first argument and the base name.<br>&gt;     moveTo(x: a, y: b)<br>&gt;     login(userName: a, password: b)<br>&gt;     constructColor(red: r, green: g, blue: b, alpha: a)<br>&gt; Omit labels for argument peers that cannot be usefully distinguished.<br>&gt;     min(number1, number2)<br>&gt;     zip(sequence1, sequence2)<br>&gt; Use explicit argument labels to describe attributes of an instance that&#39;s being created. Your calls should resemble initializers.<br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackOfMediaType(&quot;Wax Cylinder&quot;)   // no<br>&gt; Use first argument labels that would have normally appeared in the base name when building groups of related calls whose implementations are distinguished specifically by their parameters. Your calls should resemble initializers. <br>&gt;   login(userName: a, password: b) // not loginWithUserName(a, password: b)<br>&gt;   login(credential: a) // not loginWithCredential(a)<br>&gt; Skip first argument labels for initializers when using full width type conversions, that is when initializing from instances of another type.<br>&gt;  extension String { <br>&gt;      // Convert `x` into its textual representation <br>&gt;      // in the given radix<br>&gt;      init(_ x: BigInt, radix: Int = 10) <br>&gt;  }<br>&gt;  text = &quot;The value is: &quot;<br>&gt;  text += String(veryLargeNumber)<br>&gt;  text += &quot; and in hexadecimal, it&#39;s&quot;<br>&gt;  text += String(veryLargeNumber, radix: 16)<br>&gt; Use first argument labels when narrowing initial values to make it conform to restrictions within the new type. The label should describe how the instance will be modified:<br>&gt;  extension UInt32 {<br>&gt;      init(_ value: Int16) // Widening, so no label <br>&gt;      init(truncating bits: UInt64)<br>&gt;      init(saturating value: UInt64)<br>&gt;  }<br>&gt; <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt; <br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt; <br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;   beginning in the base name and describing the primary semantics of<br>&gt;&gt;   the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                            // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                              // but doesn&#39;t describe the primary <br>&gt;&gt;                              // semantics, which are to move in both<br>&gt;&gt;                              // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                              // the primary semantics, so u gets no<br>&gt;&gt;                              // label. b is an<br>&gt;&gt;                              // option that tunes the primary<br>&gt;&gt;                              // semantics<br>&gt;&gt; <br>&gt;&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;&gt;   conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;   first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                       // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt;  universally-understood term.<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;   should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;   ambiguous]<br>&gt;&gt; <br>&gt;&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;&gt;   initializers):<br>&gt;&gt; <br>&gt;&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;   describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/bf02ba7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February  3, 2016 at 08:00:00am</p></header><div class="content"><p>I’m in agreement with what Ricardo is saying here:<br></p><p>&gt; I personally like it and I agree with all except the following:<br>&gt; <br>&gt; let p = someFont.glyph(&quot;propellor&quot;)<br>&gt; let p = someFont.glyphWithName(&quot;propellor”)<br></p><p>To be more specific, this example looks good to me:<br>a.transitionToScene(.GreatHall)               // yes<br></p><p>but this one:<br>let p = someFont.glyph(&quot;propellor&quot;)           // yes<br></p><p>somehow doesn’t.  Maybe because it reads more like subscripting a dictionary.  As a result, I think this second example kind of detracts from this section of the guidelines.<br></p><p>Matt  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/0807c205/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>February  2, 2016 at 09:00:00pm</p></header><div class="content"><p>Awesome for putting this together. I think the rules add some needed clarity, but they have the bias that the first argument *should* have a defaulted empty parameter label. I actually think that complicates matters.<br></p><p>Instead, if the premise was that the first argument is treated no differently then other arguments, then the rule becomes simply a list of exceptions on when the label is not necessary:<br></p><p>If the argument&#39;s purpose in the primary semantics is clear from the name of the function, then no argument label is required (regardless of argument position).<br></p><p>To be clear, this rule does not change the API guidelines statement that all labelled arguments should be placed after non-labelled arguments.<br></p><p>Examples:<br></p><p>Remove Label(s)<br></p><p>a.contains(b)  // the question of containment of b in a is the primary semantic<br>a.merging(b)   // combining b with a is the primary semantic<br></p><p>a.moveTo(300, 400)  // moving to coordinates is a primary semantic of a<br>                    // the labels can be removed when a has a clear semantic<br>                    // limitation of a two-pair coordinate system<br></p><p>a.readFrom(u, ofType: b)  // u is clearly the target of the primary semantic<br>                          // &quot;reading&quot;, ofType labeled as it&#39;s a modifier<br></p><p>Keep Label(s) - the default behavior<br></p><p>a.dismiss(animated: b)  // dismissal is the primary semantic;<br>                        // `animated` is a modifier to that semantic, so<br>                        // keep the label<br></p><p>a.moveTo(x: 300, y: 400)  // moving is the primary semantic, however a<br>                          // has no clear semantic limitation to a 2D<br>                          // coordinate context so keep the labels<br></p><p>a.read(from: u, ofType: b)  // keep from as there is no non-ambiguous semantic<br>                            // relationship between u and what is being read<br>                            // without the label. e.g. without from, it&#39;s not<br>                            // clear that read is reading from u, it could read<br>                            // from stdin.<br></p><p>The `moveTo` example is also an illustration of why `max` would have no labels:<br></p><p>max(x, y)  // maximum value is primary semantic of the parameter set<br></p><p>I put the `a.readFrom(_:ofType:)` and `a.read(from:ofType:)` as an illustration of two valid API names that would have different applications of the rule depending on choice of the first part of the function identifier. I&#39;ll argue below which I think is better, in the general case, and the modification of rule #2 to support it.<br></p><p><br>&gt; 2. Words that describe attributes of an *already-existing* instance<br></p><p>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br></p><p>I see this rule as more about how to name the APIs instead of being about the argument labels. This is also strikes at the root of our fundamental disagreement that we cannot seem to resolve. =)<br></p><p>You seem to treat the entire function identifier to two disjoint parts (please correct me if I&#39;m misunderstanding you): the base name, including the relationship to the first parameter, and the supporting labels. The base name is the primary indicator of what the function does, with the inclusion of how the first argument relates to that semantic. The remaining argument labels are there mostly as secondary information.<br></p><p>a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)<br>// identifier: tracksHavingMediaType(_:)<br></p><p>However, I treat the entire identifier as a complete whole with no real deference to the base name over the argument labels. So the above example would be broken down like this:<br></p><p>a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;)<br>// identifier: tracksHaving(mediaType:)<br></p><p>**IF** we start with the premise that argument labels are required by default, the simplified ruleset I used above already answers how to put the label on regardless of which &quot;base name&quot; you chose. <br></p><p>I would then change rule #2 to this: the &quot;base name&quot; of the function describes the semantic intention while the argument labels are used to describe their relationship to that semantic intention or modification of how that intent is to be carried out.<br></p><p>a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)    // no, `MediaType` relates to the argument, not<br>                                           // primary intent of the function.<br></p><p>a.tracksHaving(mediaType: &quot;Wax Cylinder&quot;)  // yes, the primary intent is to find tracks<br>                                           // based on some criteria. <br></p><p>No special rules or exceptions are necessary.<br></p><p>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br></p><p>The labelling piece is already covered by the simplified rule #1 above and by my modified rule #2, so this rule is redundant. `WithIdentifier` and `WithName` should never be present because they belong to the first parameter, not to the semantic intention of the function.<br></p><p>The choice between `transitionToScene(_:)`, `transitionTo(_:)`, or even `transitionTo(scene:)` is an interesting one. I do not think there is an objectively clear winner based on the limited sample context. Though if we followed the more direct guidance of the modified rule #2, the only real options left would be: `transitionTo(_:)` and `transitionTo(scene:)`.<br></p><p>If `a` were a scene manager and the only transitioning that would take place, it could be argued that `transitionTo(_:)` is enough.<br>If `a` were a general transitioning engine, then `transitionTo(scene:)` would be the choice based on the modified rules #1 and #2 as the semantic intention of transitioning is clear, but the target would not be, so the `scene` label would be kept.<br></p><p>For clarity: `transitionToScene(_:)` would not be a candidate as rule #2 states that qualifiers for arguments, in this case `Scene`, belong with the argument itself.<br></p><p>In the very least, I hope this better articulates why I don&#39;t prefer the treatment of the first argument as special, and why I do not put first argument information into the &quot;base name&quot; of the function.<br></p><p>Cheers!<br></p><p>-David<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/53b904a9/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br></p><p>I&#39;ve been considering this for a bit, and I&#39;d like to suggest a different way of thinking about things. This is kind of high-level and may need to be translated into concrete guidelines, but it&#39;s guided my thinking about good Swift method names recently.<br></p><p>You can broadly separate parameters into operands and options. Operands slot into the &quot;sentence&quot; formed by the method name; options generally do not.<br></p><p>Operands should generally *not* be labeled explicitly with the name of what&#39;s being passed in that slot; the name should fall out by grammatical implication. For instance, in:<br></p><p>	foo.remove(bar)<br></p><p>The only sensible way of reading that is that `bar` will be removed from `foo`. If it were the other way around, it would have to be:<br></p><p>	foo.removeFrom(bar)<br></p><p>A second operand should usually be labeled, but not explicitly—only by grammatical implication. Again, this is because the structure of the &quot;sentence&quot; should imply the role of each operand. So when we want to insert into an array, which has two operands, we say:<br></p><p>	foo.insert(bar, at: 0)<br></p><p>The grammar used to label the first parameter, however, should be included in the method name itself. In a sense, the method&#39;s name should be thought of as &quot;insert at&quot;, but the constraints of Swift syntax demands we use a parameter label for the &quot;at&quot;.<br></p><p>(There are, of course, the twin exceptions of omitting completely vacuous labels and labeling the meaning of operands whose type is not specific enough to imply their meaning. Both of these are at work in `reduce(_:combine:)`; it should theoretically be something like `reduce(_:with:)`, but `with` is vacuous and the type of the parameter is not strong enough to imply its meaning and it needs to be labeled `combine`.)<br></p><p>Options, on the other hand, *are* explicitly labeled with the meaning of the parameter, because they aren&#39;t as directly connected to the sentence and it would be difficult to imply their role. Hence, in something like:<br></p><p>	foo.lexicographicalCompare(foo2, isOrderedBefore: &lt;)<br></p><p>The second parameter is an option and has to be explicitly labeled with its meaning. Options *often* have default values, but not always; for instance, the `animated` parameter in many UIKit methods is an option, but Swift does not give it a default value. <br></p><p>Because options should be explicitly labeled with their meaning but operands should have their meaning implied, options usually have the same label and variable name, while operands usually have different labels and variable names. This is not *always* the case, but it&#39;s a pretty strong hint.<br></p><p>*Usually* the first parameter is an operand and the other parameters are options, and so by default, Swift gives the first parameter an empty label and the remaining parameters a label matching their variable name. But you may have to override that in either direction if your method doesn&#39;t quite fit that norm.<br></p><p>Incidentally, I would like to suggest one small change based on this conception: the `min` and `max` free functions should be called `minOf` and `maxOf`. This both reads slightly better and gives them distinct names from the `Collection` methods.<br></p><p>* * *<br></p><p>As long as I&#39;m here, a word about method names.<br></p><p>I&#39;ve seen some suggestions that method names should be only verbs, and so `-addSubview:` should be `add(subview:)`. I don&#39;t think this is useful or appropriate.<br></p><p>What you need to understand about this is that the `Subview` in `-addSubview:` is not really labeling the parameter. It&#39;s connecting the method to the `subviews` collection. Similarly, in `-addObserver:forKeyPath:options:context:`, the `Observer` is connecting the method to the (private, side-table-stored) observer list. This also reflects the fact that, even though these two operations both &quot;add&quot; something, they are massively different—`addObserver` and `addSubview` have almost nothing in common.<br></p><p>Importing `-addSubview:` as `add(subview:)` would be like importing `-setNeedsDisplayInRect:` as `set(needsDisplayInRect:)`. The method name quite simply no longer describes the operation being performed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  2, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt;<br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt;<br>&gt; Here&#39;s what I&#39;m thinking<br>&gt;<br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;    beginning in the base name and describing the primary semantics of<br>&gt;    the call, it gets no argument label:<br>&gt;<br>&gt;      a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;      a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;<br>&gt;      a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;                             // doesn&#39;t describe the semantics at all,<br>&gt;                             // thus we add a label for b.<br>&gt;<br>&gt;      a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;                               // but doesn&#39;t describe the primary<br>&gt;                               // semantics, which are to move in both<br>&gt;                               // x and y.  Thus, x gets a label.<br>&gt;<br>&gt;      a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                               // the primary semantics, so u gets no<br>&gt;                               // label. b is an<br>&gt;                               // option that tunes the primary<br>&gt;                               // semantics<br>&gt;<br>&gt;    [Note that this covers all the direct object cases and, I believe,<br>&gt;    all the default argument cases too, so maybe that exception can be<br>&gt;    dropped.  We still need the exceptions for full-width type<br>&gt;    conversions and indistinguishable peers]<br>&gt;<br>&gt;    Note: when there is a noun in the base name describing the role of the<br>&gt;    first argument, we skip it in considering this criterion:<br>&gt;<br>&gt;       a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;                        // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;                        // making this determination.<br>&gt;<br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;   clause doesn&#39;t rule out any important use-cases (see<br>&gt;   https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;   point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;   universally-understood term.<br>&gt;<br>&gt;<br>+1<br></p><p><br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;    should go in the base name rather than in a label:<br>&gt;<br>&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;<br>&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;<br>&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;    ambiguous]<br>&gt;<br>&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;    initializers):<br>&gt;<br>&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt;<br>Very mixed feelings on this, probably adding up to a +0.2 or so.  I&#39;ll<br>mention a couple concerns that I haven&#39;t seen anyone raise:<br></p><p>Please consider the first-class function case when naming.  Particularly<br>since Swift encourages passing functions around as objects rather than<br>using string selectors.  #2 implies that the prepositional phrase will<br>appear when *referencing* the method (vs. calling it):<br></p><p>  let ops = [<br>    self.removeFirstTrackHavingMediaType,<br>    self.addTrackWithMediaType<br>    self.populateTrackOperationsForMediaType<br>    self.play<br>  ]<br></p><p>vs.<br></p><p>  let ops = [<br>    self.removeFirstTrack<br>    self.addTrack<br>    self.populateTrackOperations<br>    self.play<br>  ]<br></p><p>The second option wins on verbosity, but the first arguably gives more<br>clarity as to what the methods actually do.  Also, the second has a<br>potentially annoying semantic problem: if you have overloads for these<br>methods that differ only in keyword, Swift won&#39;t be able to disambiguate<br>them:<br></p><p>  // Compile error: Invalid redeclaration of removeFirstTrack<br>  func removeFirstTrack(havingMediaType: String) { ... }<br>  func removeFirstTrack(named: String) { ... }<br>  func removeFirstTrack(byArtist: String) { ... }<br></p><p>  // Compile error only when the function is referenced<br>  func removeTrack(n: Int, named: String)<br>  func removeTrack(n: Int, byArtist: String)<br>  let f = self.removeTrack   // named: or byArtist:?<br></p><p>  // Legal...<br>  func removeFirstTrackHavingMediaType(_: String) { ... }<br>  func removeFirstTrackNamed(_: String) { ... }<br>  func removeFirstTrackByArtist(_: String) { ... }<br></p><p>Unless the Swift compiler were to change to make the former set legal, I<br>think this is a powerful argument in favor of this proposal, because<br>otherwise you may find that the compiler prevents you from writing the code<br>that the guidelines encourage.  You might also find that changing the type<br>of an overload means you have to change the name to prevent a collision,<br>which could be very surprising to users.<br></p><p>My other reservation is the flip side of this argument: when you use a<br>function in a first-class context, often you *want* to leave things<br>unspecified.  After all, the whole point of parameterized code is so that<br>it can be used in more contexts.  This comes most often with containers or<br>other generic functions:<br></p><p>  myStringArray.map(myString.appendContentsOf)    // wordy and awkward<br>  myStringArray.map(myString.append)  // cleaner<br></p><p>I&#39;d consider this a less severe problem, but something I&#39;d still like<br>considered, particularly given the existence of several higher-order<br>functions in the standard library.<br></p><p><br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;    *identifier* of the subject in the base name, do not label it or<br>&gt;    describe it in the base name.<br>&gt;<br>&gt;       a.transitionToScene(.GreatHall)               // yes<br>&gt;       a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;<br>&gt;       let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;       let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;       let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;<br>&gt;<br>&gt;<br>+1<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/f424e07b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 2, 2016, at 10:17 PM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;    should go in the base name rather than in a label:<br>&gt; <br>&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;    ambiguous]<br>&gt; <br>&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;    initializers):<br>&gt; <br>&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; <br>&gt; Very mixed feelings on this, probably adding up to a +0.2 or so.  I&#39;ll mention a couple concerns that I haven&#39;t seen anyone raise:<br>&gt; <br>&gt; Please consider the first-class function case when naming.  Particularly since Swift encourages passing functions around as objects rather than using string selectors.  #2 implies that the prepositional phrase will appear when *referencing* the method (vs. calling it):<br>&gt; <br>&gt;   let ops = [<br>&gt;     self.removeFirstTrackHavingMediaType,<br>&gt;     self.addTrackWithMediaType<br>&gt;     self.populateTrackOperationsForMediaType<br>&gt;     self.play<br>&gt;   ]<br>&gt; <br>&gt; vs.<br>&gt; <br>&gt;   let ops = [<br>&gt;     self.removeFirstTrack<br>&gt;     self.addTrack<br>&gt;     self.populateTrackOperations<br>&gt;     self.play<br>&gt;   ]<br>&gt; <br>&gt; The second option wins on verbosity, but the first arguably gives more clarity as to what the methods actually do.  Also, the second has a potentially annoying semantic problem: if you have overloads for these methods that differ only in keyword, Swift won&#39;t be able to disambiguate them:<br>&gt; <br>&gt;   // Compile error: Invalid redeclaration of removeFirstTrack<br>&gt;   func removeFirstTrack(havingMediaType: String) { ... }<br>&gt;   func removeFirstTrack(named: String) { ... }<br>&gt;   func removeFirstTrack(byArtist: String) { ... }<br>&gt; <br>&gt;   // Compile error only when the function is referenced<br>&gt;   func removeTrack(n: Int, named: String)<br>&gt;   func removeTrack(n: Int, byArtist: String)<br>&gt;   let f = self.removeTrack   // named: or byArtist:?<br>&gt; <br>&gt;   // Legal...<br>&gt;   func removeFirstTrackHavingMediaType(_: String) { ... }<br>&gt;   func removeFirstTrackNamed(_: String) { ... }<br>&gt;   func removeFirstTrackByArtist(_: String) { ... }<br>&gt; <br>&gt; Unless the Swift compiler were to change to make the former set legal, I think this is a powerful argument in favor of this proposal, because otherwise you may find that the compiler prevents you from writing the code that the guidelines encourage.  You might also find that changing the type of an overload means you have to change the name to prevent a collision, which could be very surprising to users.<br></p><p>I suspect that you missed SE-0021:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md<br></p><p>which lets you name the arguments in a function reference, e.g:<br></p><p>	let f = self.removeTrack(_:named:)<br>	let f2 = self.removeTrack(_:byArtist:)<br></p><p>	let ops = [<br>	  self.removeFirstTrack(mediaType:),<br>	  self.addTrack(mediaType:),<br>	  self.populateTrackOperationsForMediaType,<br>	  self.play<br>	]<br>	<br>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/630627e6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Feb 3, 2016 at 9:44 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 2, 2016, at 10:17 PM, Jonathan Tang via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;    should go in the base name rather than in a label:<br>&gt;&gt;<br>&gt;&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;<br>&gt;&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;<br>&gt;&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;    ambiguous]<br>&gt;&gt;<br>&gt;&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;&gt;    initializers):<br>&gt;&gt;<br>&gt;&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;<br>&gt;&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Very mixed feelings on this, probably adding up to a +0.2 or so.  I&#39;ll<br>&gt; mention a couple concerns that I haven&#39;t seen anyone raise:<br>&gt;<br>&gt; Please consider the first-class function case when naming.  Particularly<br>&gt; since Swift encourages passing functions around as objects rather than<br>&gt; using string selectors.  #2 implies that the prepositional phrase will<br>&gt; appear when *referencing* the method (vs. calling it):<br>&gt;<br>&gt;   let ops = [<br>&gt;     self.removeFirstTrackHavingMediaType,<br>&gt;     self.addTrackWithMediaType<br>&gt;     self.populateTrackOperationsForMediaType<br>&gt;     self.play<br>&gt;   ]<br>&gt;<br>&gt; vs.<br>&gt;<br>&gt;   let ops = [<br>&gt;     self.removeFirstTrack<br>&gt;     self.addTrack<br>&gt;     self.populateTrackOperations<br>&gt;     self.play<br>&gt;   ]<br>&gt;<br>&gt; The second option wins on verbosity, but the first arguably gives more<br>&gt; clarity as to what the methods actually do.  Also, the second has a<br>&gt; potentially annoying semantic problem: if you have overloads for these<br>&gt; methods that differ only in keyword, Swift won&#39;t be able to disambiguate<br>&gt; them:<br>&gt;<br>&gt;   // Compile error: Invalid redeclaration of removeFirstTrack<br>&gt;   func removeFirstTrack(havingMediaType: String) { ... }<br>&gt;   func removeFirstTrack(named: String) { ... }<br>&gt;   func removeFirstTrack(byArtist: String) { ... }<br>&gt;<br>&gt;   // Compile error only when the function is referenced<br>&gt;   func removeTrack(n: Int, named: String)<br>&gt;   func removeTrack(n: Int, byArtist: String)<br>&gt;   let f = self.removeTrack   // named: or byArtist:?<br>&gt;<br>&gt;   // Legal...<br>&gt;   func removeFirstTrackHavingMediaType(_: String) { ... }<br>&gt;   func removeFirstTrackNamed(_: String) { ... }<br>&gt;   func removeFirstTrackByArtist(_: String) { ... }<br>&gt;<br>&gt; Unless the Swift compiler were to change to make the former set legal, I<br>&gt; think this is a powerful argument in favor of this proposal, because<br>&gt; otherwise you may find that the compiler prevents you from writing the code<br>&gt; that the guidelines encourage.  You might also find that changing the type<br>&gt; of an overload means you have to change the name to prevent a collision,<br>&gt; which could be very surprising to users.<br>&gt;<br>&gt;<br>&gt; I suspect that you missed SE-0021:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md<br>&gt;<br>&gt; which lets you name the arguments in a function reference, e.g:<br>&gt;<br>&gt; let f = self.removeTrack(_:named:)<br>&gt; let f2 = self.removeTrack(_:byArtist:)<br>&gt;<br>&gt; let ops = [<br>&gt;   self.removeFirstTrack(mediaType:),<br>&gt;   self.addTrack(mediaType:),<br>&gt;   self.populateTrackOperationsForMediaType,<br>&gt;   self.play<br>&gt; ]<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br></p><p>There&#39;s still no outstanding proposal to that lets you disambiguate<br>functions only by the first argument at the point of definition, right?<br></p><p>  class C {<br>    // Still a compiler error: &quot;Invalid redeclaration of doSomething&quot;<br>    func doSomething(withBar: String) -&gt; String { return &quot;Bar\(withBar)&quot; }<br>    func doSomething(withFoo: String) -&gt; String { return &quot;Foo\(withFoo)&quot; }<br>  }<br></p><p>Without this, I think there&#39;s still a big problem with moving the<br>preposition to the first argument label, because it leads to recommended<br>names that don&#39;t compile.<br></p><p>With SE-0021 and the ability to define overloads that differ only in the<br>first-arg label (they&#39;d have to be called or referenced with the label,<br>otherwise you&#39;d get a compiler error at point of use) I think I&#39;d move to<br>about -0.5 on proposal #2, because:<br></p><p>1. Moving the preposition to the first argument adds brevity in the common<br>case where there is no overload conflict.<br>2. You can still disambiguate or add clarity at the point of reference by<br>including all the argument labels<br>3. It&#39;s more uniform with how you&#39;d reference multi-arg functions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/081a8962/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 1:10 PM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Feb 3, 2016 at 9:44 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 10:17 PM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;    should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;    ambiguous]<br>&gt;&gt; <br>&gt;&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;&gt;    initializers):<br>&gt;&gt; <br>&gt;&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Very mixed feelings on this, probably adding up to a +0.2 or so.  I&#39;ll mention a couple concerns that I haven&#39;t seen anyone raise:<br>&gt;&gt; <br>&gt;&gt; Please consider the first-class function case when naming.  Particularly since Swift encourages passing functions around as objects rather than using string selectors.  #2 implies that the prepositional phrase will appear when *referencing* the method (vs. calling it):<br>&gt;&gt; <br>&gt;&gt;   let ops = [<br>&gt;&gt;     self.removeFirstTrackHavingMediaType,<br>&gt;&gt;     self.addTrackWithMediaType<br>&gt;&gt;     self.populateTrackOperationsForMediaType<br>&gt;&gt;     self.play<br>&gt;&gt;   ]<br>&gt;&gt; <br>&gt;&gt; vs.<br>&gt;&gt; <br>&gt;&gt;   let ops = [<br>&gt;&gt;     self.removeFirstTrack<br>&gt;&gt;     self.addTrack<br>&gt;&gt;     self.populateTrackOperations<br>&gt;&gt;     self.play<br>&gt;&gt;   ]<br>&gt;&gt; <br>&gt;&gt; The second option wins on verbosity, but the first arguably gives more clarity as to what the methods actually do.  Also, the second has a potentially annoying semantic problem: if you have overloads for these methods that differ only in keyword, Swift won&#39;t be able to disambiguate them:<br>&gt;&gt; <br>&gt;&gt;   // Compile error: Invalid redeclaration of removeFirstTrack<br>&gt;&gt;   func removeFirstTrack(havingMediaType: String) { ... }<br>&gt;&gt;   func removeFirstTrack(named: String) { ... }<br>&gt;&gt;   func removeFirstTrack(byArtist: String) { ... }<br>&gt;&gt; <br>&gt;&gt;   // Compile error only when the function is referenced<br>&gt;&gt;   func removeTrack(n: Int, named: String)<br>&gt;&gt;   func removeTrack(n: Int, byArtist: String)<br>&gt;&gt;   let f = self.removeTrack   // named: or byArtist:?<br>&gt;&gt; <br>&gt;&gt;   // Legal...<br>&gt;&gt;   func removeFirstTrackHavingMediaType(_: String) { ... }<br>&gt;&gt;   func removeFirstTrackNamed(_: String) { ... }<br>&gt;&gt;   func removeFirstTrackByArtist(_: String) { ... }<br>&gt;&gt; <br>&gt;&gt; Unless the Swift compiler were to change to make the former set legal, I think this is a powerful argument in favor of this proposal, because otherwise you may find that the compiler prevents you from writing the code that the guidelines encourage.  You might also find that changing the type of an overload means you have to change the name to prevent a collision, which could be very surprising to users.<br>&gt; <br>&gt; I suspect that you missed SE-0021:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt;<br>&gt; <br>&gt; which lets you name the arguments in a function reference, e.g:<br>&gt; <br>&gt; 	let f = self.removeTrack(_:named:)<br>&gt; 	let f2 = self.removeTrack(_:byArtist:)<br>&gt; <br>&gt; 	let ops = [<br>&gt; 	  self.removeFirstTrack(mediaType:),<br>&gt; 	  self.addTrack(mediaType:),<br>&gt; 	  self.populateTrackOperationsForMediaType,<br>&gt; 	  self.play<br>&gt; 	]<br>&gt; 	<br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; There&#39;s still no outstanding proposal to that lets you disambiguate functions only by the first argument at the point of definition, right?<br>&gt; <br>&gt;   class C {<br>&gt;     // Still a compiler error: &quot;Invalid redeclaration of doSomething&quot;<br>&gt;     func doSomething(withBar: String) -&gt; String { return &quot;Bar\(withBar)&quot; }<br>&gt;     func doSomething(withFoo: String) -&gt; String { return &quot;Foo\(withFoo)&quot; }<br>&gt;   }<br>&gt; <br>&gt; Without this, I think there&#39;s still a big problem with moving the preposition to the first argument label, because it leads to recommended names that don&#39;t compile.<br></p><p>You’re tripping over the default behavior. If you want two different functions, doSomething(withBar:) and doSomething(withFoo:), then you need to specifically provide an argument label for each:<br></p><p>	class C {<br>	  func doSomething(withBar bar: String) -&gt; String { return “Bar\(withBar)” }<br>	  func doSomething(withFoo foo: String) -&gt; String { return “Foo\(withFoo)” }<br>	}<br></p><p>Per SE-0021, you can reference these with “C.doSomething(withBar:)” and “C.doSomething(withFoo:)”, respectively.<br></p><p>&gt; With SE-0021 and the ability to define overloads that differ only in the first-arg label (they&#39;d have to be called or referenced with the label, otherwise you&#39;d get a compiler error at point of use) I think I&#39;d move to about -0.5 on proposal #2, because:<br>&gt; <br>&gt; 1. Moving the preposition to the first argument adds brevity in the common case where there is no overload conflict.<br>&gt; 2. You can still disambiguate or add clarity at the point of reference by including all the argument labels<br>&gt; 3. It&#39;s more uniform with how you&#39;d reference multi-arg functions.<br></p><p>Given the above clarification, does this opinion still hold?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/d2e57000/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Feb 3, 2016 at 1:17 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Feb 3, 2016, at 1:10 PM, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Feb 3, 2016 at 9:44 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 2, 2016, at 10:17 PM, Jonathan Tang via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;&gt;    should go in the base name rather than in a label:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;&gt;    ambiguous]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;&gt;&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;&gt;&gt;    initializers):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; Very mixed feelings on this, probably adding up to a +0.2 or so.  I&#39;ll<br>&gt;&gt; mention a couple concerns that I haven&#39;t seen anyone raise:<br>&gt;&gt;<br>&gt;&gt; Please consider the first-class function case when naming.  Particularly<br>&gt;&gt; since Swift encourages passing functions around as objects rather than<br>&gt;&gt; using string selectors.  #2 implies that the prepositional phrase will<br>&gt;&gt; appear when *referencing* the method (vs. calling it):<br>&gt;&gt;<br>&gt;&gt;   let ops = [<br>&gt;&gt;     self.removeFirstTrackHavingMediaType,<br>&gt;&gt;     self.addTrackWithMediaType<br>&gt;&gt;     self.populateTrackOperationsForMediaType<br>&gt;&gt;     self.play<br>&gt;&gt;   ]<br>&gt;&gt;<br>&gt;&gt; vs.<br>&gt;&gt;<br>&gt;&gt;   let ops = [<br>&gt;&gt;     self.removeFirstTrack<br>&gt;&gt;     self.addTrack<br>&gt;&gt;     self.populateTrackOperations<br>&gt;&gt;     self.play<br>&gt;&gt;   ]<br>&gt;&gt;<br>&gt;&gt; The second option wins on verbosity, but the first arguably gives more<br>&gt;&gt; clarity as to what the methods actually do.  Also, the second has a<br>&gt;&gt; potentially annoying semantic problem: if you have overloads for these<br>&gt;&gt; methods that differ only in keyword, Swift won&#39;t be able to disambiguate<br>&gt;&gt; them:<br>&gt;&gt;<br>&gt;&gt;   // Compile error: Invalid redeclaration of removeFirstTrack<br>&gt;&gt;   func removeFirstTrack(havingMediaType: String) { ... }<br>&gt;&gt;   func removeFirstTrack(named: String) { ... }<br>&gt;&gt;   func removeFirstTrack(byArtist: String) { ... }<br>&gt;&gt;<br>&gt;&gt;   // Compile error only when the function is referenced<br>&gt;&gt;   func removeTrack(n: Int, named: String)<br>&gt;&gt;   func removeTrack(n: Int, byArtist: String)<br>&gt;&gt;   let f = self.removeTrack   // named: or byArtist:?<br>&gt;&gt;<br>&gt;&gt;   // Legal...<br>&gt;&gt;   func removeFirstTrackHavingMediaType(_: String) { ... }<br>&gt;&gt;   func removeFirstTrackNamed(_: String) { ... }<br>&gt;&gt;   func removeFirstTrackByArtist(_: String) { ... }<br>&gt;&gt;<br>&gt;&gt; Unless the Swift compiler were to change to make the former set legal, I<br>&gt;&gt; think this is a powerful argument in favor of this proposal, because<br>&gt;&gt; otherwise you may find that the compiler prevents you from writing the code<br>&gt;&gt; that the guidelines encourage.  You might also find that changing the type<br>&gt;&gt; of an overload means you have to change the name to prevent a collision,<br>&gt;&gt; which could be very surprising to users.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I suspect that you missed SE-0021:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md<br>&gt;&gt;<br>&gt;&gt; which lets you name the arguments in a function reference, e.g:<br>&gt;&gt;<br>&gt;&gt; let f = self.removeTrack(_:named:)<br>&gt;&gt; let f2 = self.removeTrack(_:byArtist:)<br>&gt;&gt;<br>&gt;&gt; let ops = [<br>&gt;&gt;   self.removeFirstTrack(mediaType:),<br>&gt;&gt;   self.addTrack(mediaType:),<br>&gt;&gt;   self.populateTrackOperationsForMediaType,<br>&gt;&gt;   self.play<br>&gt;&gt; ]<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; There&#39;s still no outstanding proposal to that lets you disambiguate<br>&gt; functions only by the first argument at the point of definition, right?<br>&gt;<br>&gt;   class C {<br>&gt;     // Still a compiler error: &quot;Invalid redeclaration of doSomething&quot;<br>&gt;     func doSomething(withBar: String) -&gt; String { return &quot;Bar\(withBar)&quot; }<br>&gt;     func doSomething(withFoo: String) -&gt; String { return &quot;Foo\(withFoo)&quot; }<br>&gt;   }<br>&gt;<br>&gt; Without this, I think there&#39;s still a big problem with moving the<br>&gt; preposition to the first argument label, because it leads to recommended<br>&gt; names that don&#39;t compile.<br>&gt;<br>&gt;<br>&gt; You’re tripping over the default behavior. If you want two different<br>&gt; functions, doSomething(withBar:) and doSomething(withFoo:), then you need<br>&gt; to specifically provide an argument label for each:<br>&gt;<br>&gt; class C {<br>&gt;   func doSomething(withBar bar: String) -&gt; String { return “Bar\(withBar)”<br>&gt; }<br>&gt;   func doSomething(withFoo foo: String) -&gt; String { return “Foo\(withFoo)”<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Per SE-0021, you can reference these with “C.doSomething(withBar:)” and<br>&gt; “C.doSomething(withFoo:)”, respectively.<br>&gt;<br>&gt; With SE-0021 and the ability to define overloads that differ only in the<br>&gt; first-arg label (they&#39;d have to be called or referenced with the label,<br>&gt; otherwise you&#39;d get a compiler error at point of use) I think I&#39;d move to<br>&gt; about -0.5 on proposal #2, because:<br>&gt;<br>&gt; 1. Moving the preposition to the first argument adds brevity in the common<br>&gt; case where there is no overload conflict.<br>&gt; 2. You can still disambiguate or add clarity at the point of reference by<br>&gt; including all the argument labels<br>&gt; 3. It&#39;s more uniform with how you&#39;d reference multi-arg functions.<br>&gt;<br>&gt;<br>&gt; Given the above clarification, does this opinion still hold?<br>&gt;<br>&gt;<br>&gt;<br>Thanks, yes it does.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/39a68e15/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m quite certain that it isn&#39;t feasible to construct a set of rules that always ensure &quot;perfect&quot; labeling (therefore I&#39;m not that happy that Swift has several different rules for label handling that push users towards a choice that is quite common, but doesn&#39;t fit in a significant amount of cases — but that&#39;s another topic :)<br></p><p>My personal guidelines are:<br>- When a method has a &quot;target&quot; object, this should be the first parameter and have no label (&quot;addSubview&quot;, &quot;moveToPoint&quot;).<br>- The same is true when there are several targets (many examples for this a global functions like &quot;max&quot;, &quot;add&quot; — and vararg arguments, which fit in fine).<br>- If the target is a combination of parameters, each parameter deserves its own label (&quot;moveTo(x: 1, y: 2)&quot; is a perfect example; I consider the target to be a tuple of two numbers)<br></p><p>Based on this, there are some rules of thumb:<br>- Parameters that specify how something should be done always have a label (&quot;popViewController(animated: Bool)&quot;: &quot;self&quot; is the only target, &quot;animated&quot; is just a detail)<br>- Command names consisting of more than three words have a bad smell:<br>verb, [adjective/adverb], noun is all you need for clear instructions.<br>I wrote &quot;command&quot; instead of &quot;method&quot; on purpose, because query-like statements often need more words. Example: &quot;isDescendantOfView(container)&quot;<br>Methods like<br>func exchangeSubviewAtIndex(_ index1: Int &lt;https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_Int_Structure/index.html#//apple_ref/swift/struct/s:Si&gt;,<br>         withSubviewAtIndex index2: Int &lt;https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_Int_Structure/index.html#//apple_ref/swift/struct/s:Si&gt;)<br>still fit into that scheme, as they look like a shortcut combining a query with a command.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/3cf512b6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February  3, 2016 at 08:00:00am</p></header><div class="content"><p>After reading these guidelines and seeing the responses I am glad to see some consideration given to argument labeling.<br></p><p>After thinking it over, I think the rules *I* would like to see can be expressed very straightforwardly much more  can be made much A minor point, but I think it’s important to distinguish between single-argument functions and multi-argument functions; doing so seems to simplify the rules (even if there are more of them).<br></p><p>Everything that follows is my preferences, but I generally agree with Erica’s suggestions in the concrete cases. I also think the emphasis on quasi-grammatical rules-and-roles is something of a dead-end for design guidelines and won’t include such considerations in what follows.<br></p><p>## RULES<br></p><p>### I. Single-Argument Functions:<br></p><p>#### RULES:<br></p><p>- general rule: don’t label the first argument<br>- exceptions:<br>  - (a) the argument has a default value (`removeAll(keepCapacity: Bool = default)`)<br>  - (b) the function acts-like a constructor (covered in your rule 2)<br>  - (c) the “ecosystem rule” (see section III)<br>  - (d) the semantics of the argument are non-obvious (see below)<br></p><p>#### REMARKS:<br></p><p>I’m not sure (d) actually exists, though; every concrete example I can think up either falls under rule (b) or rule (c). It may not actually need to be a rule (other than as, perhaps, the underlying motivation for rules (b) and (c)). <br></p><p>My intent with (d) was to address a similar concern as in Erica’s `init(truncating …)` and `init(saturating …)`: “if a reasonable reader would be unclear which of N plausible implementation choices you are making, you may wish to label the argument, even if you only have a single such function”…but, again, it’s hard to find any examples for (d) that aren’t also some mixture of (b) and/or (c).<br></p><p>### II. Multi-Argument Functions:<br></p><p>#### RULES:<br></p><p>- general rule: label all arguments<br>- exceptions:<br>  - (a) omit the first label whenever the first argument is the semantic focus, and the other arguments are some mix of “details, adjustments, or modifiers”<br>  - (b) omit labels entirely whenever argument-ordering is irrelevant to the output (see below)<br></p><p>#### REMARKS:<br></p><p>For (a), the assumption is that we have a general consensus that “in methods for which one of the arguments is the semantic focus, that argument should be the first argument”; this seems pretty widely followed. <br></p><p>This rule seems to cover e.g. `addObserver(_:forKeyPath:)` and `addObserver(_:selector:name:object:)` and `encodeObject(_:forKey:)` and `present(_:animated:completion:)` (née `presentViewController(_:animated:completion:)`), and so on.<br></p><p>A point to bring up is that under these rules, the “evolution” of a name would be different: the just-so story for how `addObserver(_:forKeyPath:)` came to be so-called is that it *began* as `add(observer:forKeyPath:)`, but b/c the `observer` argument is the semantic focus it &quot;made sense to move `observer` into the method name”; that is, the assumption is that functions like `addObserver(_:forKeyPath:)` are considered to be exceptions to the &quot;base convention” and need to be justified.<br></p><p>Also note that &quot;counter-examples&quot; to rule (a) are anything for which no one argument is easily-identifiable as the semantic focus.<br></p><p>EG, in a function like: `adjudicate(plaintiff:defendant:circumstances:)` we can colorably claim `circumstances` is a modifier-type parameter, but we don’t—and shouldn’t!—treat either `plaintiff` or `defendant` as the semantic-focus. If you have two focuses then you have no focus, as it were.<br></p><p>For (b), the intuition is that whenever argument-order is irrelevant, arguments should be unlabelled; thus e.g.:<br></p><p>- min/max: don’t label the arguments<br>- hypot: don’t label the arguments<br>- copysign: ideally, label the arguments<br>- atan2: ideally, label the arguments<br></p><p>…and so on. Note that these examples are all &quot;free functions”; there don’t seem to be many natural examples that *aren’t* free functions. Also, please don’t be mislead by your familiarity with e.g. `copysign` and/or `atan2`; they are used here to illustrate a general principle (argument-ordering) only, but in practice such highly-familiar “legacy functions” might be best-off given special-case handling.<br></p><p>### III. Naming Functions/Ecosystem Rule<br></p><p>The previous sections essentially assumed the function names are already-chosen (in line with existing conventions) and voice specific argument-labeling preferences.<br></p><p>This section deals with a few changes to how function names should be chosen.<br></p><p>The over-arching consideration is what I’ve been calling the “Ecosystem rule”: whenever a method a member of a “method family&quot;—or could foreseeably become a member of such—one should aim for consistency in the base name, and use argument-labels as necessary; note that method families need not *require* argument labels: <br></p><p>`contains(_: Point)`<br>`contains(_: Line)`<br>`contains(_: Shape)`<br></p><p>…but they *may* require them, as for example in the `login` function that has already been discussed.<br></p><p>The “ecosystem-rule&quot; can also be applied somewhat more-broadly; consider the following name suggestions:<br></p><p>`animate(duration:animations:)`<br>`animate(duration:animations:completion:)`<br>`animate(duration:delay:options:animations:completion:)`<br>`animateUsingKeyFrames(duration:delay:options:animations:completion:)`<br>`animateUsingSpring(duration:delay:damping:initialVelocity:options:animations:completion:)`<br></p><p>…where the first three form an obvious family, and the next two are obvious “cousins” of that family due to choice of base names.<br></p><p>A corollary of this policy is that the rule (3) suggestion—of omitting something like `…ForIdentifier...` or `(forIdentifier:…)`—will sometimes be overruled out of ecosystem concerns, but I suspect this will be somewhat rare in practice.<br></p><p>For example, consider the following naming suggestions for the “tracks” example:<br></p><p>// solo method (not part of any family)<br>asset.trackWith(trackID)<br></p><p>// family<br>asset.allTracksWith(mediaCharacteristic: …)<br>asset.allTracksWith(mediaType: ...<br></p><p>// the below, instead of `trackWith` or `track(<br>asset.firstTrackWith(mediaCharacteristic: ...)<br>asset.firstTrackWith(mediaType: …)<br></p><p>…or the same again, but perhaps dropping the `With` if that’s the overall preference.<br></p><p>In any case, the overall goal behind the &quot;ecosystem rule” is that similar things should be named similarly, and when semantic differences are small-enough it makes sense to use argument labels to make distinctions; different base names should be for functions that are at least a little different from each other.<br></p><p>## GENERAL REMARKS<br></p><p>Note that with the way I’ve tried to formulate these rules the Swift standard library should largely stay as-is. In particular:<br></p><p>- methods without an identifiable “semantic focus” seem rare in a standard-library context; IMHO they occur naturally, but only really within UI/application-level code, not “basic building blocks” code<br>- &quot;method families” seem somewhat unnatural in “Swift-y” code outside of a small number of special-case scenarios (`contains`, various `init` families, etc.); they seem more common in UI/application-level code (e.g. for Objective-C interoperation), as default arguments cover most of the motivating use-cases<br></p><p>…and most of the intent in these rules is to free up some room in the guidelines so that application-level code can be written to the guidelines without going through bizarre contortions (e.g. no one would ever have *chosen* `func dismissViewControllerAnimated(_:completion:)`, and we shouldn’t have to chose between either (a) using equally-awkward constructs in our own code or (b) being “non-guideline-compliant”). <br></p><p>## REMARKS ON RULE 3<br></p><p>Separately, I think rule 3 is a hair too coarse to be a good guideline as-stated.<br></p><p>I would split the “asking for X by name/identifier/etc.” into two cases:<br></p><p>- (a) asking for X by some well-known/canonical $ID (e.g., such that it is a *major* error if no X is found for $ID)<br>- (b) asking for X by some identifier (without a strong expectation as to whether or not such an X will or won’t be found)<br></p><p>…and at least as a code-reader:<br></p><p>- I have no objection to the proposed rule (3) in scenario (a)<br>- I find rule (3) very odd in scenario (b)<br>- I think very differently about scenario (a) and scenario (b), and would thus prefer that they look different<br></p><p>…and that’s my thoughts, here.<br></p><p>&gt; On Feb 2, 2016, at 6:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>February  3, 2016 at 08:00:00am</p></header><div class="content"><p>I find arguments with prepositions easier to read, on the whole, even when<br>they&#39;re not strictly necessary.<br></p><p>Even though, this code makes sense:<br></p><p>*     a.move_to( b )*<br></p><p>*     draw_line( origin: b, conclusion: c )*<br></p><p>I&#39;d prefer to see this:<br></p><p>*     a.move( to_point: b )*<br></p><p>*     draw_line( from_point: b, to_point: c )*<br></p><p>Similarly, for the example &quot;*a.read_from( u, of_type: b )*&quot; I find this<br>easier to read:<br></p><p>*     a.read( from_url: u, from_type: b)*<br></p><p>Which makes it easier to understand if it&#39;s followed by:<br></p><p><br>*     a.read( from_url: u, to_type: b)*<br></p><p>I find it helpful in my own code. Having said that, I&#39;m not sure if it<br>would suit huge multi-person projects, since it leads to a lot of similarly<br>named functions.<br></p><p>On Tue, Feb 2, 2016 at 4:32 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt;<br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt;<br>&gt; Here&#39;s what I&#39;m thinking<br>&gt;<br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;    beginning in the base name and describing the primary semantics of<br>&gt;    the call, it gets no argument label:<br>&gt;<br>&gt;      a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;      a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;<br>&gt;      a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;                             // doesn&#39;t describe the semantics at all,<br>&gt;                             // thus we add a label for b.<br>&gt;<br>&gt;      a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;                               // but doesn&#39;t describe the primary<br>&gt;                               // semantics, which are to move in both<br>&gt;                               // x and y.  Thus, x gets a label.<br>&gt;<br>&gt;      a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                               // the primary semantics, so u gets no<br>&gt;                               // label. b is an<br>&gt;                               // option that tunes the primary<br>&gt;                               // semantics<br>&gt;<br>&gt;    [Note that this covers all the direct object cases and, I believe,<br>&gt;    all the default argument cases too, so maybe that exception can be<br>&gt;    dropped.  We still need the exceptions for full-width type<br>&gt;    conversions and indistinguishable peers]<br>&gt;<br>&gt;    Note: when there is a noun in the base name describing the role of the<br>&gt;    first argument, we skip it in considering this criterion:<br>&gt;<br>&gt;       a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;                        // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;                        // making this determination.<br>&gt;<br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;   clause doesn&#39;t rule out any important use-cases (see<br>&gt;   https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;   point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;   universally-understood term.<br>&gt;<br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;    should go in the base name rather than in a label:<br>&gt;<br>&gt;       a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;       a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;<br>&gt;       a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;       a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;<br>&gt;    [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;    ambiguous]<br>&gt;<br>&gt;    Words that describe attributes of an instance *to be created* should<br>&gt;    go in argument labels, rather than the base name (for parity with<br>&gt;    initializers):<br>&gt;<br>&gt;       AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;       trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt;       trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;<br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;    *identifier* of the subject in the base name, do not label it or<br>&gt;    describe it in the base name.<br>&gt;<br>&gt;       a.transitionToScene(.GreatHall)               // yes<br>&gt;       a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;<br>&gt;       let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;       let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;       let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; --<br>&gt; -Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/2baaf8a7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Overall, great guidelines (and +1 to the rules Erica wrote up), and I’m +1 on conveying these nuances in the guidelines.<br></p><p>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br></p><p>The rationale for doing this is stronger when we talk about automatic translation of Objective-C APIs.<br></p><p>But in APIs designed for Swift, I feel like this is wrong IMHO, because:<br></p><p>- “media type” is still a parameter, so it shouldn’t be in the base name itself<br>- this breaks the symmetry with other methods due to the reason above (like the “newTrack” you mentioned yourself)<br>- doesn’t play well with method families (searching for tracks is searching for tracks. the criteria for search are just parameters).<br></p><p>If we do<br></p><p>   trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br></p><p>I don’t see why it’s OK to do<br></p><p>   a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br></p><p>Of course just “tracks” is confusing, and we agree on that, but I would strongly recommend that for new APIs we don’t just name the method with a word of an already-existing instance, rather, we start it with a verb:<br></p><p>a.findTracks(mediaType: “BetaMax”) // or “searchTracks”, or alternatively “tracksMatching&quot;<br>a.removeFirstTrackMatching(mediaType: “BetaMax”)   — ad 2<br>fac.newTrack(mediaType: “Wax Cylinder”)<br></p><p>Symmetric, predictable, follows the same convention, plays well with method families (i.e. different search criterion than media type), and no clarity problems.<br></p><p>Ad 2: I can see why you don’t like “removeFirstTrack”. It sounds like removing _the_ first track, rather than the first track that matches criteria in parameters list. Perhaps a word like “Matching” would work well to fix this concern. (And sounds/conveys intention better than “with” or “having” IMHO)<br></p><p>Just my 2¢,<br>— Radek<br></p><p>&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February  3, 2016 at 06:00:00pm</p></header><div class="content"><p>By the way. I know this isn’t the main topic for the thread, but I would adding back a shortcut syntax for making a variable name the external label. It’s tiring to have to write:<br></p><p>methodName(moreThanTwoWords moreThanTwoWords: Type) // exaggerated for dramatic effect.<br></p><p>Most methods, in my experience, still don’t need a label for the first argument, but in the ones that do, we shouldn’t penalize doing so with ugly repetitiveness.<br></p><p>(The Q is what syntax should do this. The old “#argument” obviously feels wrong, as “#” is otherwise reserved as “macro-like, or compiler-generated”.)<br></p><p>— Radek<br></p><p>&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt; guidelines that:<br>&gt; <br>&gt; * describe when and where to use argument labels<br>&gt; * require labels in many of the cases people have asked for them<br>&gt; * are understandable by humans<br>&gt; * preserve important semantics communicated by existing APIs.<br>&gt; <br>&gt; Here&#39;s what I&#39;m thinking<br>&gt; <br>&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;   beginning in the base name and describing the primary semantics of<br>&gt;   the call, it gets no argument label:<br>&gt; <br>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt; <br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br>&gt; <br>&gt;     a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;                              // but doesn&#39;t describe the primary <br>&gt;                              // semantics, which are to move in both<br>&gt;                              // x and y.  Thus, x gets a label.<br>&gt; <br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // the primary semantics, so u gets no<br>&gt;                              // label. b is an<br>&gt;                              // option that tunes the primary<br>&gt;                              // semantics<br>&gt; <br>&gt;   [Note that this covers all the direct object cases and, I believe,<br>&gt;   all the default argument cases too, so maybe that exception can be<br>&gt;   dropped.  We still need the exceptions for full-width type<br>&gt;   conversions and indistinguishable peers]<br>&gt; <br>&gt;   Note: when there is a noun in the base name describing the role of the<br>&gt;   first argument, we skip it in considering this criterion:<br>&gt; <br>&gt;      a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;                       // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;                       // making this determination.<br>&gt; <br>&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;  clause doesn&#39;t rule out any important use-cases (see<br>&gt;  https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;  point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;  universally-understood term.<br>&gt; <br>&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;   should go in the base name rather than in a label:<br>&gt; <br>&gt;      a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt; <br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt; <br>&gt;   [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;   ambiguous]<br>&gt; <br>&gt;   Words that describe attributes of an instance *to be created* should<br>&gt;   go in argument labels, rather than the base name (for parity with<br>&gt;   initializers):<br>&gt; <br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt; <br>&gt;      trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt; <br>&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;   *identifier* of the subject in the base name, do not label it or<br>&gt;   describe it in the base name.<br>&gt; <br>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt; <br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/df6c4df2577aeca9491e42e0e33190e9?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Eric Summers</string> &lt;eric.summers at icloud.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>The current syntax doesn’t bother me too much, but I think just omitting the first argument and treating the second as the first could work:<br>func methodName(, moreThanTwoWords: Type) { … }<br></p><p>It may be less confusing when a function has a labeled variant with the same name:<br>func methodName(, aLabel: Type) { … }<br>func methodName(notALabel: Type) { … }<br></p><p>However, I think this would not be common enough to worry about.<br></p><p>Eric<br></p><p>&gt; On Feb 3, 2016, at 12:19 PM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; By the way. I know this isn’t the main topic for the thread, but I would adding back a shortcut syntax for making a variable name the external label. It’s tiring to have to write:<br>&gt; <br>&gt; methodName(moreThanTwoWords moreThanTwoWords: Type) // exaggerated for dramatic effect.<br>&gt; <br>&gt; Most methods, in my experience, still don’t need a label for the first argument, but in the ones that do, we shouldn’t penalize doing so with ugly repetitiveness.<br>&gt; <br>&gt; (The Q is what syntax should do this. The old “#argument” obviously feels wrong, as “#” is otherwise reserved as “macro-like, or compiler-generated”.)<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 03 Feb 2016, at 01:32, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;&gt; a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;&gt; guidelines that:<br>&gt;&gt; <br>&gt;&gt; * describe when and where to use argument labels<br>&gt;&gt; * require labels in many of the cases people have asked for them<br>&gt;&gt; * are understandable by humans<br>&gt;&gt; * preserve important semantics communicated by existing APIs.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s what I&#39;m thinking<br>&gt;&gt; <br>&gt;&gt; 1. If and only if the first argument could complete a sentence*<br>&gt;&gt;  beginning in the base name and describing the primary semantics of<br>&gt;&gt;  the call, it gets no argument label:<br>&gt;&gt; <br>&gt;&gt;    a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;&gt;    a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;&gt; <br>&gt;&gt;    a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;&gt;                           // doesn&#39;t describe the semantics at all, <br>&gt;&gt;                           // thus we add a label for b.<br>&gt;&gt; <br>&gt;&gt;    a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence <br>&gt;&gt;                             // but doesn&#39;t describe the primary <br>&gt;&gt;                             // semantics, which are to move in both<br>&gt;&gt;                             // x and y.  Thus, x gets a label.<br>&gt;&gt; <br>&gt;&gt;    a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;&gt;                             // the primary semantics, so u gets no<br>&gt;&gt;                             // label. b is an<br>&gt;&gt;                             // option that tunes the primary<br>&gt;&gt;                             // semantics<br>&gt;&gt; <br>&gt;&gt;  [Note that this covers all the direct object cases and, I believe,<br>&gt;&gt;  all the default argument cases too, so maybe that exception can be<br>&gt;&gt;  dropped.  We still need the exceptions for full-width type<br>&gt;&gt;  conversions and indistinguishable peers]<br>&gt;&gt; <br>&gt;&gt;  Note: when there is a noun in the base name describing the role of the<br>&gt;&gt;  first argument, we skip it in considering this criterion:<br>&gt;&gt; <br>&gt;&gt;     a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing <br>&gt;&gt;                      // the semantics.  &quot;Observer&quot; is omitted in <br>&gt;&gt;                      // making this determination.<br>&gt;&gt; <br>&gt;&gt; * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;&gt; clause doesn&#39;t rule out any important use-cases (see<br>&gt;&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;&gt; point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;&gt; universally-understood term.<br>&gt;&gt; <br>&gt;&gt; 2. Words that describe attributes of an *already-existing* instance<br>&gt;&gt;  should go in the base name rather than in a label:<br>&gt;&gt; <br>&gt;&gt;     a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;&gt;     a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;&gt; <br>&gt;&gt;     a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;&gt;     a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;&gt; <br>&gt;&gt;  [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;&gt;  ambiguous]<br>&gt;&gt; <br>&gt;&gt;  Words that describe attributes of an instance *to be created* should<br>&gt;&gt;  go in argument labels, rather than the base name (for parity with<br>&gt;&gt;  initializers):<br>&gt;&gt; <br>&gt;&gt;     AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;&gt;     trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;&gt; <br>&gt;&gt;     trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;&gt; <br>&gt;&gt; 3. (this one is separable) When the first argument is the *name* or<br>&gt;&gt;  *identifier* of the subject in the base name, do not label it or<br>&gt;&gt;  describe it in the base name.<br>&gt;&gt; <br>&gt;&gt;     a.transitionToScene(.GreatHall)               // yes<br>&gt;&gt;     a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;&gt; <br>&gt;&gt;     let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;&gt;     let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;&gt;     let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
