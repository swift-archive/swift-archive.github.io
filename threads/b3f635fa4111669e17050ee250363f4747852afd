<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d128cffeaf768e0ad7c47488aaa95f13?s=50"></div><header><strong>Re-Visit Proposal: Weak Native Swift Containers (12 2015)</strong> from <string>Dominik Pich</string> &lt;dominik at pich.info&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Hello,<br>I&#39;d like to re-visit a proposal from Riley Testut about weak  <br>containers. Since no conclusion/outcome was achieved (AFAICS from  <br>looking at the archives and the repository)<br>and since I just would have needed this again too... I found it a good  <br>time to re-propose this :D<br></p><p>---<br></p><p>&quot;<br>In multiple places in my projects, I essentially recreate the  <br>“multiple observer” pattern used by NSNotificationCenter. Originally  <br>this was implemented by simply maintaining an array of observers, and  <br>adding to/removing from it as necessary. However, this had the  <br>unintended side effect of maintaining a strong reference to the  <br>observers, which in many cases is undesirable (for the same reasons  <br>it’s common to mark delegate properties as weak).<br></p><p>Now, I’m using a private NSHashTable instance, and expose the  <br>observers as public API by creating a public computed property which  <br>essentially returns an array derived from the NSHashTable like so:<br></p><p>public var receivers: [GameControllerReceiverType] {<br>     // self.privateReceivers.allObjects as!  <br>[GameControllerReceiverType] crashes Swift :(<br>     return self.privateReceivers.allObjects.map({ $0 as!  <br>GameControllerReceiverType })<br>}<br></p><p>This workaround works, but is undesirable for a number of reasons.  <br>Most notably:<br></p><p>• NSHashTable is not a native Swift collection, and is also not in the  <br>Foundation Swift port, so it is not portable to other systems.<br>• It also has not yet been annotated with generics, so it loses the  <br>nice type safety of other Swift collections. Because of this, I have  <br>to map the objects to the appropriate type before returning the  <br>allObjects array, which runs in O(n) time instead of O(1).<br>• It’s repetitive. For every type that wants to implement this  <br>pattern, they must maintain both a public computed method and a  <br>private NSHashTable instance. This gets worse when this should be part  <br>of a protocol; there’s no way to enforce that each type conforming to  <br>it has a NSHashTable, while also keeping that information private from  <br>the consumer of the API.<br></p><p>I think native swift collections with support for weak references for  <br>their contents would be very useful, and in more places than just  <br>listed above. I don’t think Array could be easily extended to support  <br>it (what happens if a value is released? does everything shift down?  <br>do they keep their indices?), but Set and Dictionary (where the keys  <br>and/or values could be weak, akin to NSMapTable) would be good  <br>candidates IMO.<br></p><p>Thoughts?&quot;<br></p><p>--reference to last message thread:  <br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001579.html<br>(last messages were &#39;arguing&#39; how to implement it)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Re-Visit Proposal: Weak Native Swift Containers (12 2015)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I’ve used the following in some similar cases:<br></p><p>	struct Weak&lt;T&gt; {<br>		weak var value:T?<br>		init(_ value:T) { self.value = value }<br>	}<br>	let myCache = Array&lt;Weak&lt;Foo&gt;&gt;()<br></p><p>When inserting new values I just look for the first one that’s nil or append if it’s taking too long, but you’re right, something more reactive would be better, for example if the above were observable I could do something about it as soon as it became nil.<br></p><p>&gt; On 11 May 2016, at 14:00, Dominik Pich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; I&#39;d like to re-visit a proposal from Riley Testut about weak containers. Since no conclusion/outcome was achieved (AFAICS from looking at the archives and the repository)<br>&gt; and since I just would have needed this again too... I found it a good time to re-propose this :D<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; &quot;<br>&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt; <br>&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt; <br>&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;    // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;    return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt; }<br>&gt; <br>&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt; <br>&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt; <br>&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt; <br>&gt; Thoughts?&quot;<br>&gt; <br>&gt; --reference to last message thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001579.html<br>&gt; (last messages were &#39;arguing&#39; how to implement it)<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>Re-Visit Proposal: Weak Native Swift Containers (12 2015)</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>I remember reading that Swift’s weak references are ‘lazy’, and only clear (and release if needed) when they are next accessed. So you couldn’t observe them AFAIK.<br></p><p><br>&gt; On 11 May 2016, at 11:23 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve used the following in some similar cases:<br>&gt; <br>&gt; 	struct Weak&lt;T&gt; {<br>&gt; 		weak var value:T?<br>&gt; 		init(_ value:T) { self.value = value }<br>&gt; 	}<br>&gt; 	let myCache = Array&lt;Weak&lt;Foo&gt;&gt;()<br>&gt; <br>&gt; When inserting new values I just look for the first one that’s nil or append if it’s taking too long, but you’re right, something more reactive would be better, for example if the above were observable I could do something about it as soon as it became nil.<br>&gt; <br>&gt;&gt; On 11 May 2016, at 14:00, Dominik Pich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; I&#39;d like to re-visit a proposal from Riley Testut about weak containers. Since no conclusion/outcome was achieved (AFAICS from looking at the archives and the repository)<br>&gt;&gt; and since I just would have needed this again too... I found it a good time to re-propose this :D<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; &quot;<br>&gt;&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt;&gt; <br>&gt;&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt;&gt; <br>&gt;&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;&gt;   // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;&gt;   return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt;&gt; <br>&gt;&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt;&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt;&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt;&gt; <br>&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;&gt; <br>&gt;&gt; Thoughts?&quot;<br>&gt;&gt; <br>&gt;&gt; --reference to last message thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001579.html<br>&gt;&gt; (last messages were &#39;arguing&#39; how to implement it)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Re-Visit Proposal: Weak Native Swift Containers (12 2015)</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Associated object based tricks may be used in the meantime, KVO on objects with an uncertain duration was always problematic.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 11 May 2016, at 14:30, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I remember reading that Swift’s weak references are ‘lazy’, and only clear (and release if needed) when they are next accessed. So you couldn’t observe them AFAIK.<br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 11:23 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve used the following in some similar cases:<br>&gt;&gt; <br>&gt;&gt;    struct Weak&lt;T&gt; {<br>&gt;&gt;        weak var value:T?<br>&gt;&gt;        init(_ value:T) { self.value = value }<br>&gt;&gt;    }<br>&gt;&gt;    let myCache = Array&lt;Weak&lt;Foo&gt;&gt;()<br>&gt;&gt; <br>&gt;&gt; When inserting new values I just look for the first one that’s nil or append if it’s taking too long, but you’re right, something more reactive would be better, for example if the above were observable I could do something about it as soon as it became nil.<br>&gt;&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 14:00, Dominik Pich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt; I&#39;d like to re-visit a proposal from Riley Testut about weak containers. Since no conclusion/outcome was achieved (AFAICS from looking at the archives and the repository)<br>&gt;&gt;&gt; and since I just would have needed this again too... I found it a good time to re-propose this :D<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;&gt;&gt;  // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;&gt;&gt;  return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt;&gt;&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt;&gt;&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --reference to last message thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001579.html<br>&gt;&gt;&gt; (last messages were &#39;arguing&#39; how to implement it)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Re-Visit Proposal: Weak Native Swift Containers (12 2015)</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>Thanks for reviving this Dominik! I left it for a while because I wasn&#39;t sure if there was a big enough demand for it (or at least for now while focusing on Swift 3), but if others still think this would be useful I&#39;m very interested in pushing this forward.<br></p><p>Unfortunately because (AFAICT) NSHashTable/NSHashMap don&#39;t have CoreFoundation equivalents, any progress on this would have to be more or less from scratch (or so I&#39;m assuming), and not part of the corelibs-foundation project. Maybe some input from the Core Team on how feasible this would be would be helpful.<br></p><p>&gt; On May 11, 2016, at 8:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Associated object based tricks may be used in the meantime, KVO on objects with an uncertain duration was always problematic.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 11 May 2016, at 14:30, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I remember reading that Swift’s weak references are ‘lazy’, and only clear (and release if needed) when they are next accessed. So you couldn’t observe them AFAIK.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 11:23 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve used the following in some similar cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   struct Weak&lt;T&gt; {<br>&gt;&gt;&gt;       weak var value:T?<br>&gt;&gt;&gt;       init(_ value:T) { self.value = value }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   let myCache = Array&lt;Weak&lt;Foo&gt;&gt;()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When inserting new values I just look for the first one that’s nil or append if it’s taking too long, but you’re right, something more reactive would be better, for example if the above were observable I could do something about it as soon as it became nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 11 May 2016, at 14:00, Dominik Pich via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt;&gt; I&#39;d like to re-visit a proposal from Riley Testut about weak containers. Since no conclusion/outcome was achieved (AFAICS from looking at the archives and the repository)<br>&gt;&gt;&gt;&gt; and since I just would have needed this again too... I found it a good time to re-propose this :D<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ---<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;<br>&gt;&gt;&gt;&gt; In multiple places in my projects, I essentially recreate the “multiple observer” pattern used by NSNotificationCenter. Originally this was implemented by simply maintaining an array of observers, and adding to/removing from it as necessary. However, this had the unintended side effect of maintaining a strong reference to the observers, which in many cases is undesirable (for the same reasons it’s common to mark delegate properties as weak).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, I’m using a private NSHashTable instance, and expose the observers as public API by creating a public computed property which essentially returns an array derived from the NSHashTable like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public var receivers: [GameControllerReceiverType] {<br>&gt;&gt;&gt;&gt; // self.privateReceivers.allObjects as! [GameControllerReceiverType] crashes Swift :(<br>&gt;&gt;&gt;&gt; return self.privateReceivers.allObjects.map({ $0 as! GameControllerReceiverType })<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This workaround works, but is undesirable for a number of reasons. Most notably:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; • NSHashTable is not a native Swift collection, and is also not in the Foundation Swift port, so it is not portable to other systems.<br>&gt;&gt;&gt;&gt; • It also has not yet been annotated with generics, so it loses the nice type safety of other Swift collections. Because of this, I have to map the objects to the appropriate type before returning the allObjects array, which runs in O(n) time instead of O(1).<br>&gt;&gt;&gt;&gt; • It’s repetitive. For every type that wants to implement this pattern, they must maintain both a public computed method and a private NSHashTable instance. This gets worse when this should be part of a protocol; there’s no way to enforce that each type conforming to it has a NSHashTable, while also keeping that information private from the consumer of the API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think native swift collections with support for weak references for their contents would be very useful, and in more places than just listed above. I don’t think Array could be easily extended to support it (what happens if a value is released? does everything shift down? do they keep their indices?), but Set and Dictionary (where the keys and/or values could be weak, akin to NSMapTable) would be good candidates IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --reference to last message thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001579.html<br>&gt;&gt;&gt;&gt; (last messages were &#39;arguing&#39; how to implement it)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
