<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>Sorry if this has been asked before (searched but couldn&#39;t find anything).<br>I&#39;ll explain what I mean by an example of a situation where I think it<br>would be reasonable to expect a compile time error rather than the current<br>runtime error:<br></p><p>import simd<br>let a: float4 = [1, 2, 3]<br>print(a)<br></p><p>The SIMD float4 type conforms to ArrayLiteralConvertible, and the required<br>initializer has a check that makes sure the array literal has 4 elements.<br>The check can only be performed at runtime even though the number of<br>elements of that array literal is (presumably) statically knowable, as is<br>the number it is checked against (i.e. it probably ends up being an integer<br>literal 4 somewhere (although I haven&#39;t actually checked the code)).<br></p><p>I assume that there are good reasons for why this is currently a runtime<br>check, but I&#39;d like to know what these reasons are, i.e. why isn&#39;t there<br>something like C++&#39;s static_assert?<br></p><p>Any pointers to previous discussions or information about how Swift relates<br>to this and similar topics (static computation / constexpr, macro system)<br>would be highly appreciated.<br></p><p>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/80bdc6d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 8:16 AM, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry if this has been asked before (searched but couldn&#39;t find anything).<br>&gt; I&#39;ll explain what I mean by an example of a situation where I think it would be reasonable to expect a compile time error rather than the current runtime error:<br>&gt; <br>&gt; import simd<br>&gt; let a: float4 = [1, 2, 3]<br>&gt; print(a)<br>&gt; <br>&gt; The SIMD float4 type conforms to ArrayLiteralConvertible, and the required initializer has a check that makes sure the array literal has 4 elements.<br>&gt; The check can only be performed at runtime even though the number of elements of that array literal is (presumably) statically knowable, as is the number it is checked against (i.e. it probably ends up being an integer literal 4 somewhere (although I haven&#39;t actually checked the code)).<br>&gt; <br>&gt; I assume that there are good reasons for why this is currently a runtime check, but I&#39;d like to know what these reasons are, i.e. why isn&#39;t there something like C++&#39;s static_assert?<br>&gt; <br>&gt; Any pointers to previous discussions or information about how Swift relates to this and similar topics (static computation / constexpr, macro system) would be highly appreciated.<br></p><p>We haven&#39;t designed any facilities for any of this yet, or really had serious discussions about them that I know of. They&#39;re definitely interesting directions for the future. There is some infrastructure for limited compile-time evaluation and diagnostics based on SIL; for instance, we produce diagnostics when literal integer expressions overflow their target type, as in `let x: Int8 = 128`, by doing constant-folding of `@_transparent` functions. There&#39;s a more generalized compile-time reporting mechanism we prototyped, but I don&#39;t think we currently take advantage of it; grep around for `staticReport`. `staticReport` in @_transparent function together could approximate static_assert in cases the compiler knows how to constant-fold.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>December 22, 2015 at 08:00:00am</p></header><div class="content"><p>Thanks!<br>(As a side note related to overflow, I filed<br>https://bugs.swift.org/browse/SR-297 demonstrating that a<br>T : UnsignedIntegerType can be set to eg literal -1 without trapping the<br>overflow.)<br></p><p>On Mon, Dec 21, 2015 at 7:22 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 21, 2015, at 8:16 AM, Jens Persson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Sorry if this has been asked before (searched but couldn&#39;t find<br>&gt; anything).<br>&gt; &gt; I&#39;ll explain what I mean by an example of a situation where I think it<br>&gt; would be reasonable to expect a compile time error rather than the current<br>&gt; runtime error:<br>&gt; &gt;<br>&gt; &gt; import simd<br>&gt; &gt; let a: float4 = [1, 2, 3]<br>&gt; &gt; print(a)<br>&gt; &gt;<br>&gt; &gt; The SIMD float4 type conforms to ArrayLiteralConvertible, and the<br>&gt; required initializer has a check that makes sure the array literal has 4<br>&gt; elements.<br>&gt; &gt; The check can only be performed at runtime even though the number of<br>&gt; elements of that array literal is (presumably) statically knowable, as is<br>&gt; the number it is checked against (i.e. it probably ends up being an integer<br>&gt; literal 4 somewhere (although I haven&#39;t actually checked the code)).<br>&gt; &gt;<br>&gt; &gt; I assume that there are good reasons for why this is currently a runtime<br>&gt; check, but I&#39;d like to know what these reasons are, i.e. why isn&#39;t there<br>&gt; something like C++&#39;s static_assert?<br>&gt; &gt;<br>&gt; &gt; Any pointers to previous discussions or information about how Swift<br>&gt; relates to this and similar topics (static computation / constexpr, macro<br>&gt; system) would be highly appreciated.<br>&gt;<br>&gt; We haven&#39;t designed any facilities for any of this yet, or really had<br>&gt; serious discussions about them that I know of. They&#39;re definitely<br>&gt; interesting directions for the future. There is some infrastructure for<br>&gt; limited compile-time evaluation and diagnostics based on SIL; for instance,<br>&gt; we produce diagnostics when literal integer expressions overflow their<br>&gt; target type, as in `let x: Int8 = 128`, by doing constant-folding of<br>&gt; `@_transparent` functions. There&#39;s a more generalized compile-time<br>&gt; reporting mechanism we prototyped, but I don&#39;t think we currently take<br>&gt; advantage of it; grep around for `staticReport`. `staticReport` in<br>&gt; @_transparent function together could approximate static_assert in cases<br>&gt; the compiler knows how to constant-fold.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/20daf228/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:18 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt; <br>&gt; Thanks!<br>&gt; (As a side note related to overflow, I filed https://bugs.swift.org/browse/SR-297 &lt;https://bugs.swift.org/browse/SR-297&gt; demonstrating that a<br>&gt; T : UnsignedIntegerType can be set to eg literal -1 without trapping the overflow.)<br></p><p>Thanks! Yeah, we only ever handled overflow in concrete integer types. Compile-time diagnostics for protocol invariants would be another interesting thing to add. It might be possible by refactoring how IntegerLiteralConvertible interfaces with _BuiltinIntegerLiteralConvertible, making the diagnostics occur while narrowing Builtin.Int2048 to the literal type.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/23381310/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>Joe,<br></p><p>quick side question: is @_transparent documented somewhere? I’ve seen it in the standard library source code, but i cannot see out covered in any of the docs…<br></p><p>thanx!<br>marc<br></p><p>&gt; On Dec 21, 2015, at 2:22 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 8:16 AM, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry if this has been asked before (searched but couldn&#39;t find anything).<br>&gt;&gt; I&#39;ll explain what I mean by an example of a situation where I think it would be reasonable to expect a compile time error rather than the current runtime error:<br>&gt;&gt; <br>&gt;&gt; import simd<br>&gt;&gt; let a: float4 = [1, 2, 3]<br>&gt;&gt; print(a)<br>&gt;&gt; <br>&gt;&gt; The SIMD float4 type conforms to ArrayLiteralConvertible, and the required initializer has a check that makes sure the array literal has 4 elements.<br>&gt;&gt; The check can only be performed at runtime even though the number of elements of that array literal is (presumably) statically knowable, as is the number it is checked against (i.e. it probably ends up being an integer literal 4 somewhere (although I haven&#39;t actually checked the code)).<br>&gt;&gt; <br>&gt;&gt; I assume that there are good reasons for why this is currently a runtime check, but I&#39;d like to know what these reasons are, i.e. why isn&#39;t there something like C++&#39;s static_assert?<br>&gt;&gt; <br>&gt;&gt; Any pointers to previous discussions or information about how Swift relates to this and similar topics (static computation / constexpr, macro system) would be highly appreciated.<br>&gt; <br>&gt; We haven&#39;t designed any facilities for any of this yet, or really had serious discussions about them that I know of. They&#39;re definitely interesting directions for the future. There is some infrastructure for limited compile-time evaluation and diagnostics based on SIL; for instance, we produce diagnostics when literal integer expressions overflow their target type, as in `let x: Int8 = 128`, by doing constant-folding of `@_transparent` functions. There&#39;s a more generalized compile-time reporting mechanism we prototyped, but I don&#39;t think we currently take advantage of it; grep around for `staticReport`. `staticReport` in @_transparent function together could approximate static_assert in cases the compiler knows how to constant-fold.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 7:26 AM, marc hoffman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe,<br>&gt; <br>&gt; quick side question: is @_transparent documented somewhere? I’ve seen it in the standard library source code, but i cannot see out covered in any of the docs…<br></p><p>It&#39;s not publicly documented, because it&#39;s intended to be an implementation detail. It only really works within the standard library, and is likely to be replaced by our proper resilience model for cross-module inlining. Check out docs/TransparentAttr.rst for the internal documentation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>Thanx!<br></p><p>i understand it’s internal, but i’m asking because i work on http://www.elementscompiler.com/silver, and eventually we’d love to be able to compile parts of the standard library ourselves ;)<br></p><p>—marc<br></p><p>&gt; On Dec 22, 2015, at 11:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 7:26 AM, marc hoffman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Joe,<br>&gt;&gt; <br>&gt;&gt; quick side question: is @_transparent documented somewhere? I’ve seen it in the standard library source code, but i cannot see out covered in any of the docs…<br>&gt; <br>&gt; It&#39;s not publicly documented, because it&#39;s intended to be an implementation detail. It only really works within the standard library, and is likely to be replaced by our proper resilience model for cross-module inlining. Check out docs/TransparentAttr.rst for the internal documentation.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 10:03 AM, marc hoffman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanx!<br>&gt; <br>&gt; i understand it’s internal, but i’m asking because i work on http://www.elementscompiler.com/silver, and eventually we’d love to be able to compile parts of the standard library ourselves ;)<br></p><p>Given the deep dependence in our standard library on LLVM primitives and semantics, as well as the rather messy interactions between our compiler, stdlib, and runtime in general, I&#39;m not sure that&#39;s a practical goal. Maybe if there were a better-factored &#39;core&#39; that defined the basic interfaces in terms of the substrate, giving you Int/String/etc. in terms of LLVM/CLR/JavaScript/WebAssembly/whatever primitives, that was isolated from the higher-level parts of the stdlib, but that&#39;s a sizable effort in itself. I know you all already define your own versions of stdlib interfaces in terms of common .NET/JVM abstractions, and change semantics in many places as a result. <br></p><p>-Joe<br></p><p>&gt; —marc<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 11:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 7:26 AM, marc hoffman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; quick side question: is @_transparent documented somewhere? I’ve seen it in the standard library source code, but i cannot see out covered in any of the docs…<br>&gt;&gt; <br>&gt;&gt; It&#39;s not publicly documented, because it&#39;s intended to be an implementation detail. It only really works within the standard library, and is likely to be replaced by our proper resilience model for cross-module inlining. Check out docs/TransparentAttr.rst for the internal documentation.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47dd6e088b6ba4fb06a7030dda8b7122?s=50"></div><header><strong>Compile time assertion / checking?</strong> from <string>marc hoffman</string> &lt;mh at remobjects.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>Joe,<br></p><p>&gt; Given the deep dependence in our standard library on LLVM primitives and semantics, as well as the rather messy interactions between our compiler, stdlib, and runtime in general, I&#39;m not sure that&#39;s a practical goal.<br></p><p>Probably not no. I just figured, the more syntax — even internal/hidden/unsupported ones - we can support, the easier it will be to move stuff over or keep it in sync. Reviewing the official standard lib and bringing our up to speed with it (on the outside) is my next big goal, and even just being able to copy a class skeleton over can help ;)_<br></p><p>&gt; Maybe if there were a better-factored &#39;core&#39; that defined the basic interfaces in terms of the substrate, giving you Int/String/etc. in terms of LLVM/CLR/JavaScript/WebAssembly/whatever primitives, that was isolated from the higher-level parts of the stdlib, but that&#39;s a sizable effort in itself. I know you all already define your own versions of stdlib interfaces in terms of common .NET/JVM abstractions, and change semantics in many places as a result. <br></p><p>Yeah.<br></p><p>—marc<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
