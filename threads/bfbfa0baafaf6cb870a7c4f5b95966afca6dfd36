<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>The idea is simple but the reasoning is long. So please bear with me.<br>You can read on github for a better reading experience:<br>https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md.<br></p><p>## Introduction<br></p><p>The coexistence of `static` and `class` keywords for declaring type<br>properties and methods is confusing and causes inconsistency between<br>type and instance member declarations. This document reasons why we<br>don’t need both and suggests we unify them with a better keyword<br>`type`.<br></p><p>## Motivation<br></p><p>### Confusion<br></p><p>One “language enhancement” of [Swift<br>1.2](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6)<br>is:<br>&gt; “static” methods and properties are now allowed in classes (as an alias for class final). You are now allowed to declare static stored properties in classes, which have global storage and are lazily initialized on first access (like global variables). Protocols now declare type requirements as static requirements instead of declaring them as class requirements. (17198298)<br></p><p>If even the Swift team itself has difficulties in picking one from the<br>two and had to revert its initial decision after several revisions, we<br>know these keywords are indeed confusing.<br></p><p>So now protocols use `static` to declare type methods, when a class<br>adapts such protocols, should it implement those static methods, as<br>static methods or class methods?<br></p><p>But static means final, right? Does it mean we can not override these<br>methods in subclasses of the conforming class?<br></p><p>These kinds of unnecessary confusion and hesitation should be<br>resolved, and could if this proposal is implemented.<br></p><p>### Unnecessary and inconsistent differentiation<br></p><p>The `class` keyword is only used in classes. In the current<br>implementation of Swift the differences between `class` and `static`<br>are:<br></p><p>1. Class properties can only be calculated properties but not stored properties.<br>2. Class methods(also calculated properties) are dynamically<br>dispatched while static ones are statically dispatched.<br></p><p>If we can eliminate the differences or find better ways to<br>differentiate we can use one unified keyword instead for declaring<br>type properties and methods.<br></p><p>Let’s see.<br></p><p>#### Class stored properties VS. static stored properties<br></p><p>If you use the `class` keyword to declare a stored property in a class<br>you will get this compiling error:<br>&gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br></p><p>So what are class stored properties? How are they different from<br>static stored properties?<br></p><p>As far as I know, class stored properties, if ever implemented in<br>Swift, “would be what Ruby calls ‘class instance<br>variables’”.&lt;sup&gt;[1](https://twitter.com/UINT_MIN/status/584104757117095936)&lt;/sup&gt;<br></p><p>So what are class instance variables?<br></p><p>The best explanation I can find is this<br>[one](http://martinfowler.com/bliki/ClassInstanceVariable.html) from<br>Martin Fowler.<br></p><p>Do we really want this feature in Swift? “If we didn&#39;t already have<br>these, would we add them to Swift 3?&quot;<br></p><p>I strongly believe we won’t add it to Swift 3. Actually I believe we<br>will never add it to Swift, because its use cases are so rare which is<br>also why it hasn’t been implemented so far in Swift.<br></p><p>If we agree we are not going to support class stored properties, there<br>is and will be only one kind of stored properties for types and we<br>only need one keyword to declare such properties.<br></p><p>#### Class methods VS. static methods<br></p><p>*Since calculated properties are also methods in essence they are also<br>covered by this section.*<br></p><p>The only difference is how methods are dispatched.<br></p><p>Let’s see [how we handle it for instance<br>methods](https://developer.apple.com/swift/blog/?id=27):<br></p><p>* Methods are overridable hence dynamically dispatched by default.<br>* In performance critical code use these techniques to restrict this<br>dynamic behavior when it isn’t needed to improve performance:<br></p><p>    1. Use the `final` keyword when we know that a declaration does<br>not need to be overridden.<br>    2. Infer `final` on declarations referenced in one file by<br>applying the `private` keyword.<br>    3. Use `Whole Module Optimization` to infer `final` on `internal`<br>declarations.<br></p><p>So why abandon this whole system to use another totally different one<br>for differentiating `static dispatch` and `dynamic dispatch` for type<br>methods?<br></p><p>If we reuse this system for type methods, not only can we have a<br>consistent design for both instance and type methods, but also we can<br>get rid of the last place where two keywords for type member<br>declarations are needed.<br></p><p>## Proposed solution<br></p><p>1. Use the keyword `type` to declare type properties and methods.<br>2. Type properties and methods are overridable hence dynamically<br>dispatched by default. Use the `final` keyword or inferred `final` to<br>make them final and statically dispatched, just like instance<br>properties and methods.<br>3. Type properties can be stored or calculated, just like instance properties.<br></p><p>As you can see, it is a very simple and elegant design:<br></p><p>* Just a single keyword `type` to differentiate type member<br>declarations from instance member declarations. `type` is a good<br>keyword because:<br></p><p>    1. It is consistent with the wording of the concepts of `type<br>properties` and `type methods`.<br>    2. It is never used as a keyword before in Swift, Objective-C or<br>C. There will be no conflicts or overloading of it meanings.<br>* Except for that, how things are declared, differentiated and<br>optimized are exactly the same in both type and instance world. Very<br>consistent.<br></p><p>## Comparison with current design<br></p><p>* Dynamic Dispatch VS. Static Dispatch<br></p><p>```swift<br>// Old<br>class Foo {<br>    func dynamicInstanceMethod() {}<br>    final func staticInstanceMethod() {}<br></p><p>    class func dynamicTypeMethod() {}<br>    static func staticTypeMethod() {}<br>}<br>```<br></p><p>```swift<br>// New<br>class Foo {<br>    func dynamicInstanceMethod() {}<br>    final func staticInstanceMethod() {}<br></p><p>    type func dynamicTypeMethod() {}<br>    final type func staticTypeMethod() {}<br>}<br>```<br></p><p>* Stored Properties VS. Calculated Properties<br></p><p>```swift<br>// Old<br>class Bar {<br>    static let i = 1<br></p><p>    class var j: Int {<br>        return 1<br>    }<br>}<br>```<br></p><p>```swift<br>// New<br>class Bar {<br>    type let i = 1<br></p><p>    type var j: Int {<br>        return 1<br>    }<br>}<br>```<br></p><p>* Struct Implementation VS. Class Implementation of Protocol<br></p><p>```swift<br>// Old<br>protocol P {<br>    static func foo()<br>}<br></p><p>struct S: P {<br>    static func foo() {}<br>}<br></p><p>class C: P {<br>    class func foo() {}<br>}<br>```<br></p><p>```swift<br>// New<br>protocol P {<br>    type func foo()<br>}<br></p><p>struct S: P {<br>    type func foo() {}<br>}<br></p><p>class C: P {<br>    type func foo() {}<br>}<br>```<br></p><p>## Impact on existing code<br></p><p>With the help of a good migration tool, there will be no impact on<br>existing code at all. And the migration rules are very clear and<br>simple:<br></p><p>* Map `static` to `type` in protocols.<br>* Map `static` to `type` in structs and enums.<br>* Map `class` to `type` and `static` to `final type` in classes.<br></p><p>One concern I can think of is: because type methods are dynamically<br>dispatched by default in the new design, will we forget to do the<br>`final` optimization so the general performance of Swift code become<br>worse?<br></p><p>I think it is probably true. But we also forget to do the `final`<br>optimization for instance methods from time to time. Since there are<br>way more instance methods than type methods in most code the<br>performance impact will be very small. Maybe this change is a good<br>opportunity to remind us to do the `final` optimization for instance<br>methods thus even results in a better general performance.<br></p><p>And don’t forget we have the tools to automatically infer `final` for<br>us in many cases if we write the proper code and use the proper<br>compiler features.<br></p><p>After all, it is mainly on us to write good code to produce good final<br>products. If the system is consistent we’ll have better chances to<br>master it and use it properly.<br></p><p>## Alternatives considered<br></p><p>Alternatively we could:<br>* Keep using `static` and `class` keywords.<br>* Keep the confusion when implementing `static` protocol requirements<br>using `class` properties and methods in conforming classes.<br>* Keep the inconsistency between type member declarations and instance<br>member declarations.<br>* Keep overloading meanings on the `static` keyword that is already<br>historically overloaded in C and Objective-C with which Swift must mix<br>and match.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>ChrisLattner wrote:<br></p><p><br></p><p>We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but<br>that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are<br>good for familiarity and are quite descriptive (once you understand how +<br>methods work), and open the door for potentially adding truly static<br>methods to classes.  The primary weirdness of this model is that protocols<br>have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the<br>right tradeoff.<br></p><p><br></p><p>-Chris<br></p><p>Jul 5, 2014<br></p><p>https://devforums.apple.com/message/998365#998365<br></p><p><br></p><p>On Monday, December 7, 2015, an0 via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt; You can read on github for a better reading experience:<br>&gt;<br>&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md<br>&gt; .<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt; properties and methods is confusing and causes inconsistency between<br>&gt; type and instance member declarations. This document reasons why we<br>&gt; don’t need both and suggests we unify them with a better keyword<br>&gt; `type`.<br>&gt;<br>&gt; ## Motivation<br>&gt;<br>&gt; ### Confusion<br>&gt;<br>&gt; One “language enhancement” of [Swift<br>&gt; 1.2](<br>&gt; https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6<br>&gt; )<br>&gt; is:<br>&gt; &gt; “static” methods and properties are now allowed in classes (as an alias<br>&gt; for class final). You are now allowed to declare static stored properties<br>&gt; in classes, which have global storage and are lazily initialized on first<br>&gt; access (like global variables). Protocols now declare type requirements as<br>&gt; static requirements instead of declaring them as class requirements.<br>&gt; (17198298)<br>&gt;<br>&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt; two and had to revert its initial decision after several revisions, we<br>&gt; know these keywords are indeed confusing.<br>&gt;<br>&gt; So now protocols use `static` to declare type methods, when a class<br>&gt; adapts such protocols, should it implement those static methods, as<br>&gt; static methods or class methods?<br>&gt;<br>&gt; But static means final, right? Does it mean we can not override these<br>&gt; methods in subclasses of the conforming class?<br>&gt;<br>&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt; resolved, and could if this proposal is implemented.<br>&gt;<br>&gt; ### Unnecessary and inconsistent differentiation<br>&gt;<br>&gt; The `class` keyword is only used in classes. In the current<br>&gt; implementation of Swift the differences between `class` and `static`<br>&gt; are:<br>&gt;<br>&gt; 1. Class properties can only be calculated properties but not stored<br>&gt; properties.<br>&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt; dispatched while static ones are statically dispatched.<br>&gt;<br>&gt; If we can eliminate the differences or find better ways to<br>&gt; differentiate we can use one unified keyword instead for declaring<br>&gt; type properties and methods.<br>&gt;<br>&gt; Let’s see.<br>&gt;<br>&gt; #### Class stored properties VS. static stored properties<br>&gt;<br>&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt; you will get this compiling error:<br>&gt; &gt; class stored properties not yet supported in classes; did you mean<br>&gt; &#39;static&#39;?<br>&gt;<br>&gt; So what are class stored properties? How are they different from<br>&gt; static stored properties?<br>&gt;<br>&gt; As far as I know, class stored properties, if ever implemented in<br>&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt; variables’”.&lt;sup&gt;[1](<br>&gt; https://twitter.com/UINT_MIN/status/584104757117095936)&lt;/sup&gt;<br>&gt;<br>&gt; So what are class instance variables?<br>&gt;<br>&gt; The best explanation I can find is this<br>&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html) from<br>&gt; Martin Fowler.<br>&gt;<br>&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt; these, would we add them to Swift 3?&quot;<br>&gt;<br>&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;<br>&gt; If we agree we are not going to support class stored properties, there<br>&gt; is and will be only one kind of stored properties for types and we<br>&gt; only need one keyword to declare such properties.<br>&gt;<br>&gt; #### Class methods VS. static methods<br>&gt;<br>&gt; *Since calculated properties are also methods in essence they are also<br>&gt; covered by this section.*<br>&gt;<br>&gt; The only difference is how methods are dispatched.<br>&gt;<br>&gt; Let’s see [how we handle it for instance<br>&gt; methods](https://developer.apple.com/swift/blog/?id=27):<br>&gt;<br>&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt; * In performance critical code use these techniques to restrict this<br>&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;<br>&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt; not need to be overridden.<br>&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt; applying the `private` keyword.<br>&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt; declarations.<br>&gt;<br>&gt; So why abandon this whole system to use another totally different one<br>&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt; methods?<br>&gt;<br>&gt; If we reuse this system for type methods, not only can we have a<br>&gt; consistent design for both instance and type methods, but also we can<br>&gt; get rid of the last place where two keywords for type member<br>&gt; declarations are needed.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt; make them final and statically dispatched, just like instance<br>&gt; properties and methods.<br>&gt; 3. Type properties can be stored or calculated, just like instance<br>&gt; properties.<br>&gt;<br>&gt; As you can see, it is a very simple and elegant design:<br>&gt;<br>&gt; * Just a single keyword `type` to differentiate type member<br>&gt; declarations from instance member declarations. `type` is a good<br>&gt; keyword because:<br>&gt;<br>&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt; properties` and `type methods`.<br>&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt; * Except for that, how things are declared, differentiated and<br>&gt; optimized are exactly the same in both type and instance world. Very<br>&gt; consistent.<br>&gt;<br>&gt; ## Comparison with current design<br>&gt;<br>&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;<br>&gt; ```swift<br>&gt; // Old<br>&gt; class Foo {<br>&gt;     func dynamicInstanceMethod() {}<br>&gt;     final func staticInstanceMethod() {}<br>&gt;<br>&gt;     class func dynamicTypeMethod() {}<br>&gt;     static func staticTypeMethod() {}<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ```swift<br>&gt; // New<br>&gt; class Foo {<br>&gt;     func dynamicInstanceMethod() {}<br>&gt;     final func staticInstanceMethod() {}<br>&gt;<br>&gt;     type func dynamicTypeMethod() {}<br>&gt;     final type func staticTypeMethod() {}<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; * Stored Properties VS. Calculated Properties<br>&gt;<br>&gt; ```swift<br>&gt; // Old<br>&gt; class Bar {<br>&gt;     static let i = 1<br>&gt;<br>&gt;     class var j: Int {<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ```swift<br>&gt; // New<br>&gt; class Bar {<br>&gt;     type let i = 1<br>&gt;<br>&gt;     type var j: Int {<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;<br>&gt; ```swift<br>&gt; // Old<br>&gt; protocol P {<br>&gt;     static func foo()<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt;     static func foo() {}<br>&gt; }<br>&gt;<br>&gt; class C: P {<br>&gt;     class func foo() {}<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ```swift<br>&gt; // New<br>&gt; protocol P {<br>&gt;     type func foo()<br>&gt; }<br>&gt;<br>&gt; struct S: P {<br>&gt;     type func foo() {}<br>&gt; }<br>&gt;<br>&gt; class C: P {<br>&gt;     type func foo() {}<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; With the help of a good migration tool, there will be no impact on<br>&gt; existing code at all. And the migration rules are very clear and<br>&gt; simple:<br>&gt;<br>&gt; * Map `static` to `type` in protocols.<br>&gt; * Map `static` to `type` in structs and enums.<br>&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;<br>&gt; One concern I can think of is: because type methods are dynamically<br>&gt; dispatched by default in the new design, will we forget to do the<br>&gt; `final` optimization so the general performance of Swift code become<br>&gt; worse?<br>&gt;<br>&gt; I think it is probably true. But we also forget to do the `final`<br>&gt; optimization for instance methods from time to time. Since there are<br>&gt; way more instance methods than type methods in most code the<br>&gt; performance impact will be very small. Maybe this change is a good<br>&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt; methods thus even results in a better general performance.<br>&gt;<br>&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt; us in many cases if we write the proper code and use the proper<br>&gt; compiler features.<br>&gt;<br>&gt; After all, it is mainly on us to write good code to produce good final<br>&gt; products. If the system is consistent we’ll have better chances to<br>&gt; master it and use it properly.<br>&gt;<br>&gt; ## Alternatives considered<br>&gt;<br>&gt; Alternatively we could:<br>&gt; * Keep using `static` and `class` keywords.<br>&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt; using `class` properties and methods in conforming classes.<br>&gt; * Keep the inconsistency between type member declarations and instance<br>&gt; member declarations.<br>&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt; and match.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/218bdfd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>I read that. But that&#39;s a long time ago, Swift has evolved a lot since<br>then. I believe the Swift team may have some new ideas about it or at least<br>could take a look at the ideas in this proposal.<br></p><p>Do you have any ideas of your own about this proposal? I&#39;d really like to<br>learn:)<br></p><p>On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>wrote:<br></p><p>&gt; ChrisLattner wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but<br>&gt; that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are<br>&gt; good for familiarity and are quite descriptive (once you understand how +<br>&gt; methods work), and open the door for potentially adding truly static<br>&gt; methods to classes.  The primary weirdness of this model is that protocols<br>&gt; have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the<br>&gt; right tradeoff.<br>&gt;<br>&gt;<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; Jul 5, 2014<br>&gt;<br>&gt; https://devforums.apple.com/message/998365#998365<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt;<br>&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md<br>&gt;&gt; .<br>&gt;&gt;<br>&gt;&gt; ## Introduction<br>&gt;&gt;<br>&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt; `type`.<br>&gt;&gt;<br>&gt;&gt; ## Motivation<br>&gt;&gt;<br>&gt;&gt; ### Confusion<br>&gt;&gt;<br>&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt; 1.2](<br>&gt;&gt; https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6<br>&gt;&gt; )<br>&gt;&gt; is:<br>&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an alias<br>&gt;&gt; for class final). You are now allowed to declare static stored properties<br>&gt;&gt; in classes, which have global storage and are lazily initialized on first<br>&gt;&gt; access (like global variables). Protocols now declare type requirements as<br>&gt;&gt; static requirements instead of declaring them as class requirements.<br>&gt;&gt; (17198298)<br>&gt;&gt;<br>&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt;<br>&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt; static methods or class methods?<br>&gt;&gt;<br>&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt;<br>&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt;<br>&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt;<br>&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt; are:<br>&gt;&gt;<br>&gt;&gt; 1. Class properties can only be calculated properties but not stored<br>&gt;&gt; properties.<br>&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt;<br>&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt; type properties and methods.<br>&gt;&gt;<br>&gt;&gt; Let’s see.<br>&gt;&gt;<br>&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt;<br>&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt; you will get this compiling error:<br>&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean<br>&gt;&gt; &#39;static&#39;?<br>&gt;&gt;<br>&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt; static stored properties?<br>&gt;&gt;<br>&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt; variables’”.&lt;sup&gt;[1](<br>&gt;&gt; https://twitter.com/UINT_MIN/status/584104757117095936)&lt;/sup&gt;<br>&gt;&gt;<br>&gt;&gt; So what are class instance variables?<br>&gt;&gt;<br>&gt;&gt; The best explanation I can find is this<br>&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html) from<br>&gt;&gt; Martin Fowler.<br>&gt;&gt;<br>&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt;<br>&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt;<br>&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt;<br>&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt;<br>&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt; covered by this section.*<br>&gt;&gt;<br>&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt;<br>&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27):<br>&gt;&gt;<br>&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt;<br>&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt; not need to be overridden.<br>&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt; applying the `private` keyword.<br>&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt; declarations.<br>&gt;&gt;<br>&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt; methods?<br>&gt;&gt;<br>&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt; declarations are needed.<br>&gt;&gt;<br>&gt;&gt; ## Proposed solution<br>&gt;&gt;<br>&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt; properties and methods.<br>&gt;&gt; 3. Type properties can be stored or calculated, just like instance<br>&gt;&gt; properties.<br>&gt;&gt;<br>&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt;<br>&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt; keyword because:<br>&gt;&gt;<br>&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt; properties` and `type methods`.<br>&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt; consistent.<br>&gt;&gt;<br>&gt;&gt; ## Comparison with current design<br>&gt;&gt;<br>&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; class Foo {<br>&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;<br>&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; class Foo {<br>&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;<br>&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; class Bar {<br>&gt;&gt;     static let i = 1<br>&gt;&gt;<br>&gt;&gt;     class var j: Int {<br>&gt;&gt;         return 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; class Bar {<br>&gt;&gt;     type let i = 1<br>&gt;&gt;<br>&gt;&gt;     type var j: Int {<br>&gt;&gt;         return 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; protocol P {<br>&gt;&gt;     static func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct S: P {<br>&gt;&gt;     static func foo() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C: P {<br>&gt;&gt;     class func foo() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; protocol P {<br>&gt;&gt;     type func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct S: P {<br>&gt;&gt;     type func foo() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C: P {<br>&gt;&gt;     type func foo() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; ## Impact on existing code<br>&gt;&gt;<br>&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt; simple:<br>&gt;&gt;<br>&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt;<br>&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt; worse?<br>&gt;&gt;<br>&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt;<br>&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt; compiler features.<br>&gt;&gt;<br>&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt; master it and use it properly.<br>&gt;&gt;<br>&gt;&gt; ## Alternatives considered<br>&gt;&gt;<br>&gt;&gt; Alternatively we could:<br>&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt; member declarations.<br>&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt; and match.<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/b329dc0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>Hi Ling,<br></p><p>In April 2015 you said on your blog that &quot;I was not convinced so I filed an<br>radar.&quot; It would seem to me that you are not convinced now either, even<br>after Chris explained that what you are asking for was<br>implemented, reverted and ultimately rejected.  I appreciate the fact that<br>you are thinking and worry about the apparent inconstancy. I rather the<br>swift swift team spend more time focusing on ABI stability than on non<br>issue items. Swift is young. Who knows maybe your ideas will make it in a<br>future version of Swift.<br></p><p>wangling.me/2015/04/unify-type-properties-and-methods.html<br>https://devforums.apple.com/message/1123857<br></p><p><br>On Monday, December 7, 2015, an0 &lt;an00na at gmail.com&gt; wrote:<br></p><p>&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since<br>&gt; then. I believe the Swift team may have some new ideas about it or at least<br>&gt; could take a look at the ideas in this proposal.<br>&gt;<br>&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to<br>&gt; learn:)<br>&gt;<br>&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cheyo at masters3d.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; ChrisLattner wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but<br>&gt;&gt; that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are<br>&gt;&gt; good for familiarity and are quite descriptive (once you understand how +<br>&gt;&gt; methods work), and open the door for potentially adding truly static<br>&gt;&gt; methods to classes.  The primary weirdness of this model is that protocols<br>&gt;&gt; have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the<br>&gt;&gt; right tradeoff.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; Jul 5, 2014<br>&gt;&gt;<br>&gt;&gt; https://devforums.apple.com/message/998365#998365<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md<br>&gt;&gt;&gt; .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt;&gt; `type`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ### Confusion<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt;&gt; 1.2](<br>&gt;&gt;&gt; https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; is:<br>&gt;&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an<br>&gt;&gt;&gt; alias for class final). You are now allowed to declare static stored<br>&gt;&gt;&gt; properties in classes, which have global storage and are lazily initialized<br>&gt;&gt;&gt; on first access (like global variables). Protocols now declare type<br>&gt;&gt;&gt; requirements as static requirements instead of declaring them as class<br>&gt;&gt;&gt; requirements. (17198298)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt;&gt; static methods or class methods?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt;&gt; are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Class properties can only be calculated properties but not stored<br>&gt;&gt;&gt; properties.<br>&gt;&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt;&gt; type properties and methods.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let’s see.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt;&gt; you will get this compiling error:<br>&gt;&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean<br>&gt;&gt;&gt; &#39;static&#39;?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt;&gt; static stored properties?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt;&gt; variables’”.&lt;sup&gt;[1](<br>&gt;&gt;&gt; https://twitter.com/UINT_MIN/status/584104757117095936)&lt;/sup&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So what are class instance variables?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The best explanation I can find is this<br>&gt;&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html) from<br>&gt;&gt;&gt; Martin Fowler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt;&gt; covered by this section.*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt;&gt; not need to be overridden.<br>&gt;&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt;&gt; applying the `private` keyword.<br>&gt;&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt;&gt; declarations.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt;&gt; methods?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt;&gt; declarations are needed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt;&gt; properties and methods.<br>&gt;&gt;&gt; 3. Type properties can be stored or calculated, just like instance<br>&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt;&gt; keyword because:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt;&gt; properties` and `type methods`.<br>&gt;&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt;&gt; consistent.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Comparison with current design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;     static let i = 1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class var j: Int {<br>&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;     type let i = 1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     type var j: Int {<br>&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     static func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;     static func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;     class func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     type func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt;&gt; simple:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt;&gt; worse?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt;&gt; compiler features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt;&gt; master it and use it properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatively we could:<br>&gt;&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt;&gt; member declarations.<br>&gt;&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt;&gt; and match.<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/d99b40c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>Just if it helps someway, in my opinion:<br></p><p>- static is well known keyword modifier from long ago, but I think is an unfortunate one because is named that way from a complier point fo view, not from a language programmer user.<br></p><p>- I don’t understand static as having an implicit final behaviour. <br></p><p>- It seems we want to mix in one word parallel variables modifiers when is not a goal reduce code typing.<br></p><p>- I found confusing using class keyword instead of static just to note that a static computed variable is not final (same for methods). More when the language provides the final keyword to identify this behaviour.<br></p><p>- why not ?<br></p><p>class SomeClass {<br></p><p>    static var storedTypeProperty = &quot;Some value.&quot;<br>    static var computedTypeProperty: Int {<br>        return 27<br>    }<br>    static final var nonOverrideableComputedTypeProperty: Int {<br>        return 107<br>    }<br>}<br></p><p>-But as I mentioned I think static is not a good keyword, only we have been used to it.<br></p><p>Maybe shared ? Adding overridable in case?<br></p><p>class SomeClass {<br>    shared var storedTypeProperty = “Some value.&quot;<br>    shared var computedTypeProperty: Int {<br>        return 27<br>    }<br>    shared overridable var overrideableComputedTypeProperty: Int {<br>        return 107<br>    }<br>}<br></p><p><br>Or:<br></p><p>class SomeClass {<br>    shared var storedTypeProperty = “Some value.&quot;<br>    shared var computedTypeProperty: Int {<br>        return 27<br>    }<br>    shared final var nonOverrideableComputedTypeProperty: Int {<br>        return 107<br>    }<br>}<br></p><p><br>Thanks,<br></p><p>Daniel<br></p><p>Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br></p><p><br>Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br></p><p>&gt; El 8 des 2015, a les 5:22, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; va escriure:<br>&gt; <br>&gt; Hi Ling,<br>&gt; <br>&gt; In April 2015 you said on your blog that &quot;I was not convinced so I filed an radar.&quot; It would seem to me that you are not convinced now either, even after Chris explained that what you are asking for was implemented, reverted and ultimately rejected.  I appreciate the fact that you are thinking and worry about the apparent inconstancy. I rather the swift swift team spend more time focusing on ABI stability than on non issue items. Swift is young. Who knows maybe your ideas will make it in a future version of Swift. <br>&gt; <br>&gt; wangling.me/2015/04/unify-type-properties-and-methods.html &lt;http://wangling.me/2015/04/unify-type-properties-and-methods.html&gt;<br>&gt; https://devforums.apple.com/message/1123857 &lt;https://devforums.apple.com/message/1123857&gt;<br>&gt; <br>&gt; <br>&gt; On Monday, December 7, 2015, an0 &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since then. I believe the Swift team may have some new ideas about it or at least could take a look at the ideas in this proposal.<br>&gt; <br>&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to learn:)<br>&gt; <br>&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cheyo at masters3d.com&#39;);&gt;&gt; wrote:<br>&gt; ChrisLattner wrote:<br>&gt;  <br>&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are good for familiarity and are quite descriptive (once you understand how + methods work), and open the door for potentially adding truly static methods to classes.  The primary weirdness of this model is that protocols have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the right tradeoff.<br>&gt;  <br>&gt; -Chris<br>&gt; Jul 5, 2014 <br>&gt; <br>&gt; https://devforums.apple.com/message/998365#998365 &lt;https://devforums.apple.com/message/998365#998365&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt; You can read on github for a better reading experience:<br>&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md&gt;.<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt; properties and methods is confusing and causes inconsistency between<br>&gt; type and instance member declarations. This document reasons why we<br>&gt; don’t need both and suggests we unify them with a better keyword<br>&gt; `type`.<br>&gt; <br>&gt; ## Motivation<br>&gt; <br>&gt; ### Confusion<br>&gt; <br>&gt; One “language enhancement” of [Swift<br>&gt; 1.2](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6 &lt;https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6&gt;)<br>&gt; is:<br>&gt; &gt; “static” methods and properties are now allowed in classes (as an alias for class final). You are now allowed to declare static stored properties in classes, which have global storage and are lazily initialized on first access (like global variables). Protocols now declare type requirements as static requirements instead of declaring them as class requirements. (17198298)<br>&gt; <br>&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt; two and had to revert its initial decision after several revisions, we<br>&gt; know these keywords are indeed confusing.<br>&gt; <br>&gt; So now protocols use `static` to declare type methods, when a class<br>&gt; adapts such protocols, should it implement those static methods, as<br>&gt; static methods or class methods?<br>&gt; <br>&gt; But static means final, right? Does it mean we can not override these<br>&gt; methods in subclasses of the conforming class?<br>&gt; <br>&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt; resolved, and could if this proposal is implemented.<br>&gt; <br>&gt; ### Unnecessary and inconsistent differentiation<br>&gt; <br>&gt; The `class` keyword is only used in classes. In the current<br>&gt; implementation of Swift the differences between `class` and `static`<br>&gt; are:<br>&gt; <br>&gt; 1. Class properties can only be calculated properties but not stored properties.<br>&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt; dispatched while static ones are statically dispatched.<br>&gt; <br>&gt; If we can eliminate the differences or find better ways to<br>&gt; differentiate we can use one unified keyword instead for declaring<br>&gt; type properties and methods.<br>&gt; <br>&gt; Let’s see.<br>&gt; <br>&gt; #### Class stored properties VS. static stored properties<br>&gt; <br>&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt; you will get this compiling error:<br>&gt; &gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt; <br>&gt; So what are class stored properties? How are they different from<br>&gt; static stored properties?<br>&gt; <br>&gt; As far as I know, class stored properties, if ever implemented in<br>&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt; variables’”.&lt;sup&gt;[1](https://twitter.com/UINT_MIN/status/584104757117095936 &lt;https://twitter.com/UINT_MIN/status/584104757117095936&gt;)&lt;/sup&gt;<br>&gt; <br>&gt; So what are class instance variables?<br>&gt; <br>&gt; The best explanation I can find is this<br>&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html &lt;http://martinfowler.com/bliki/ClassInstanceVariable.html&gt;) from<br>&gt; Martin Fowler.<br>&gt; <br>&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt; these, would we add them to Swift 3?&quot;<br>&gt; <br>&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt; also why it hasn’t been implemented so far in Swift.<br>&gt; <br>&gt; If we agree we are not going to support class stored properties, there<br>&gt; is and will be only one kind of stored properties for types and we<br>&gt; only need one keyword to declare such properties.<br>&gt; <br>&gt; #### Class methods VS. static methods<br>&gt; <br>&gt; *Since calculated properties are also methods in essence they are also<br>&gt; covered by this section.*<br>&gt; <br>&gt; The only difference is how methods are dispatched.<br>&gt; <br>&gt; Let’s see [how we handle it for instance<br>&gt; methods](https://developer.apple.com/swift/blog/?id=27 &lt;https://developer.apple.com/swift/blog/?id=27&gt;):<br>&gt; <br>&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt; * In performance critical code use these techniques to restrict this<br>&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt; <br>&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt; not need to be overridden.<br>&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt; applying the `private` keyword.<br>&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt; declarations.<br>&gt; <br>&gt; So why abandon this whole system to use another totally different one<br>&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt; methods?<br>&gt; <br>&gt; If we reuse this system for type methods, not only can we have a<br>&gt; consistent design for both instance and type methods, but also we can<br>&gt; get rid of the last place where two keywords for type member<br>&gt; declarations are needed.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt; make them final and statically dispatched, just like instance<br>&gt; properties and methods.<br>&gt; 3. Type properties can be stored or calculated, just like instance properties.<br>&gt; <br>&gt; As you can see, it is a very simple and elegant design:<br>&gt; <br>&gt; * Just a single keyword `type` to differentiate type member<br>&gt; declarations from instance member declarations. `type` is a good<br>&gt; keyword because:<br>&gt; <br>&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt; properties` and `type methods`.<br>&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt; * Except for that, how things are declared, differentiated and<br>&gt; optimized are exactly the same in both type and instance world. Very<br>&gt; consistent.<br>&gt; <br>&gt; ## Comparison with current design<br>&gt; <br>&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt; <br>&gt; ```swift<br>&gt; // Old<br>&gt; class Foo {<br>&gt;     func dynamicInstanceMethod() {}<br>&gt;     final func staticInstanceMethod() {}<br>&gt; <br>&gt;     class func dynamicTypeMethod() {}<br>&gt;     static func staticTypeMethod() {}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ```swift<br>&gt; // New<br>&gt; class Foo {<br>&gt;     func dynamicInstanceMethod() {}<br>&gt;     final func staticInstanceMethod() {}<br>&gt; <br>&gt;     type func dynamicTypeMethod() {}<br>&gt;     final type func staticTypeMethod() {}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; * Stored Properties VS. Calculated Properties<br>&gt; <br>&gt; ```swift<br>&gt; // Old<br>&gt; class Bar {<br>&gt;     static let i = 1<br>&gt; <br>&gt;     class var j: Int {<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ```swift<br>&gt; // New<br>&gt; class Bar {<br>&gt;     type let i = 1<br>&gt; <br>&gt;     type var j: Int {<br>&gt;         return 1<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt; <br>&gt; ```swift<br>&gt; // Old<br>&gt; protocol P {<br>&gt;     static func foo()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     static func foo() {}<br>&gt; }<br>&gt; <br>&gt; class C: P {<br>&gt;     class func foo() {}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ```swift<br>&gt; // New<br>&gt; protocol P {<br>&gt;     type func foo()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     type func foo() {}<br>&gt; }<br>&gt; <br>&gt; class C: P {<br>&gt;     type func foo() {}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; With the help of a good migration tool, there will be no impact on<br>&gt; existing code at all. And the migration rules are very clear and<br>&gt; simple:<br>&gt; <br>&gt; * Map `static` to `type` in protocols.<br>&gt; * Map `static` to `type` in structs and enums.<br>&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt; <br>&gt; One concern I can think of is: because type methods are dynamically<br>&gt; dispatched by default in the new design, will we forget to do the<br>&gt; `final` optimization so the general performance of Swift code become<br>&gt; worse?<br>&gt; <br>&gt; I think it is probably true. But we also forget to do the `final`<br>&gt; optimization for instance methods from time to time. Since there are<br>&gt; way more instance methods than type methods in most code the<br>&gt; performance impact will be very small. Maybe this change is a good<br>&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt; methods thus even results in a better general performance.<br>&gt; <br>&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt; us in many cases if we write the proper code and use the proper<br>&gt; compiler features.<br>&gt; <br>&gt; After all, it is mainly on us to write good code to produce good final<br>&gt; products. If the system is consistent we’ll have better chances to<br>&gt; master it and use it properly.<br>&gt; <br>&gt; ## Alternatives considered<br>&gt; <br>&gt; Alternatively we could:<br>&gt; * Keep using `static` and `class` keywords.<br>&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt; using `class` properties and methods in conforming classes.<br>&gt; * Keep the inconsistency between type member declarations and instance<br>&gt; member declarations.<br>&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt; and match.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/8862ec2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>Yes, the `static` is badly overloaded with many different meanings:<br>1. static storage (old, from C)<br>2. static linking (old, from C)<br>3. final (new in Swift)<br></p><p>That’s why I’m proposing we use a new keyword. My initial suggestion is `type` but I welcome any better alternative.<br></p><p>`overridable` is unnecessary since we already have `final`.<br></p><p>&gt; On Dec 8, 2015, at 7:33 AM, Daniel Valls Estella &lt;daniel at upzzle.com&gt; wrote:<br>&gt; <br>&gt; Just if it helps someway, in my opinion:<br>&gt; <br>&gt; - static is well known keyword modifier from long ago, but I think is an unfortunate one because is named that way from a complier point fo view, not from a language programmer user.<br>&gt; <br>&gt; - I don’t understand static as having an implicit final behaviour. <br>&gt; <br>&gt; - It seems we want to mix in one word parallel variables modifiers when is not a goal reduce code typing.<br>&gt; <br>&gt; - I found confusing using class keyword instead of static just to note that a static computed variable is not final (same for methods). More when the language provides the final keyword to identify this behaviour.<br>&gt; <br>&gt; - why not ?<br>&gt; <br>&gt; class SomeClass {<br>&gt; <br>&gt;     static var storedTypeProperty = &quot;Some value.&quot;<br>&gt;     static var computedTypeProperty: Int {<br>&gt;         return 27<br>&gt;     }<br>&gt;     static final var nonOverrideableComputedTypeProperty: Int {<br>&gt;         return 107<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; -But as I mentioned I think static is not a good keyword, only we have been used to it.<br>&gt; <br>&gt; Maybe shared ? Adding overridable in case?<br>&gt; <br>&gt; class SomeClass {<br>&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;     shared var computedTypeProperty: Int {<br>&gt;         return 27<br>&gt;     }<br>&gt;     shared overridable var overrideableComputedTypeProperty: Int {<br>&gt;         return 107<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Or:<br>&gt; <br>&gt; class SomeClass {<br>&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;     shared var computedTypeProperty: Int {<br>&gt;         return 27<br>&gt;     }<br>&gt;     shared final var nonOverrideableComputedTypeProperty: Int {<br>&gt;         return 107<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt; <br>&gt; <br>&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt; <br>&gt;&gt; El 8 des 2015, a les 5:22, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; va escriure:<br>&gt;&gt; <br>&gt;&gt; Hi Ling,<br>&gt;&gt; <br>&gt;&gt; In April 2015 you said on your blog that &quot;I was not convinced so I filed an radar.&quot; It would seem to me that you are not convinced now either, even after Chris explained that what you are asking for was implemented, reverted and ultimately rejected.  I appreciate the fact that you are thinking and worry about the apparent inconstancy. I rather the swift swift team spend more time focusing on ABI stability than on non issue items. Swift is young. Who knows maybe your ideas will make it in a future version of Swift. <br>&gt;&gt; <br>&gt;&gt; wangling.me/2015/04/unify-type-properties-and-methods.html &lt;http://wangling.me/2015/04/unify-type-properties-and-methods.html&gt;<br>&gt;&gt; https://devforums.apple.com/message/1123857 &lt;https://devforums.apple.com/message/1123857&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Monday, December 7, 2015, an0 &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since then. I believe the Swift team may have some new ideas about it or at least could take a look at the ideas in this proposal.<br>&gt;&gt; <br>&gt;&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to learn:)<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cheyo at masters3d.com&#39;);&gt;&gt; wrote:<br>&gt;&gt; ChrisLattner wrote:<br>&gt;&gt;  <br>&gt;&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are good for familiarity and are quite descriptive (once you understand how + methods work), and open the door for potentially adding truly static methods to classes.  The primary weirdness of this model is that protocols have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the right tradeoff.<br>&gt;&gt;  <br>&gt;&gt; -Chris<br>&gt;&gt; Jul 5, 2014 <br>&gt;&gt; <br>&gt;&gt; https://devforums.apple.com/message/998365#998365 &lt;https://devforums.apple.com/message/998365#998365&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md&gt;.<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt; `type`.<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; ### Confusion<br>&gt;&gt; <br>&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt; 1.2](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6 &lt;https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6&gt;)<br>&gt;&gt; is:<br>&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an alias for class final). You are now allowed to declare static stored properties in classes, which have global storage and are lazily initialized on first access (like global variables). Protocols now declare type requirements as static requirements instead of declaring them as class requirements. (17198298)<br>&gt;&gt; <br>&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt; <br>&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt; static methods or class methods?<br>&gt;&gt; <br>&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt; <br>&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt; <br>&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt; <br>&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt; are:<br>&gt;&gt; <br>&gt;&gt; 1. Class properties can only be calculated properties but not stored properties.<br>&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt; <br>&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt; type properties and methods.<br>&gt;&gt; <br>&gt;&gt; Let’s see.<br>&gt;&gt; <br>&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt; <br>&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt; you will get this compiling error:<br>&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt;&gt; <br>&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt; static stored properties?<br>&gt;&gt; <br>&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt; variables’”.&lt;sup&gt;[1](https://twitter.com/UINT_MIN/status/584104757117095936 &lt;https://twitter.com/UINT_MIN/status/584104757117095936&gt;)&lt;/sup&gt;<br>&gt;&gt; <br>&gt;&gt; So what are class instance variables?<br>&gt;&gt; <br>&gt;&gt; The best explanation I can find is this<br>&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html &lt;http://martinfowler.com/bliki/ClassInstanceVariable.html&gt;) from<br>&gt;&gt; Martin Fowler.<br>&gt;&gt; <br>&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt; <br>&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt; <br>&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt; <br>&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt; <br>&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt; covered by this section.*<br>&gt;&gt; <br>&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt; <br>&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27 &lt;https://developer.apple.com/swift/blog/?id=27&gt;):<br>&gt;&gt; <br>&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt; <br>&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt; not need to be overridden.<br>&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt; applying the `private` keyword.<br>&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt; declarations.<br>&gt;&gt; <br>&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt; methods?<br>&gt;&gt; <br>&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt; declarations are needed.<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt; properties and methods.<br>&gt;&gt; 3. Type properties can be stored or calculated, just like instance properties.<br>&gt;&gt; <br>&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt; <br>&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt; keyword because:<br>&gt;&gt; <br>&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt; properties` and `type methods`.<br>&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt; consistent.<br>&gt;&gt; <br>&gt;&gt; ## Comparison with current design<br>&gt;&gt; <br>&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; class Foo {<br>&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt; <br>&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; class Foo {<br>&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt; <br>&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; class Bar {<br>&gt;&gt;     static let i = 1<br>&gt;&gt; <br>&gt;&gt;     class var j: Int {<br>&gt;&gt;         return 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; class Bar {<br>&gt;&gt;     type let i = 1<br>&gt;&gt; <br>&gt;&gt;     type var j: Int {<br>&gt;&gt;         return 1<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // Old<br>&gt;&gt; protocol P {<br>&gt;&gt;     static func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     static func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {<br>&gt;&gt;     class func foo() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; // New<br>&gt;&gt; protocol P {<br>&gt;&gt;     type func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     type func foo() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {<br>&gt;&gt;     type func foo() {}<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt; simple:<br>&gt;&gt; <br>&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt; <br>&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt; worse?<br>&gt;&gt; <br>&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt; <br>&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt; compiler features.<br>&gt;&gt; <br>&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt; master it and use it properly.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Alternatively we could:<br>&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt; member declarations.<br>&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt; and match.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/809be885/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5c03d71ebd1813a9c856bff896009b7?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Daniel Valls Estella</string> &lt;daniel at upzzle.com&gt;<p>December  8, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; `overridable` is unnecessary since we already have `final`.<br></p><p><br>Agree in part, but it’s to keep the current behaviour of being final by default, without anotating it, that maybe is a better aproach for shared properties.<br></p><p>&gt; El 8 des 2015, a les 16:51, Ling Wang &lt;an00na at gmail.com&gt; va escriure:<br>&gt; <br>&gt; Yes, the `static` is badly overloaded with many different meanings:<br>&gt; 1. static storage (old, from C)<br>&gt; 2. static linking (old, from C)<br>&gt; 3. final (new in Swift)<br>&gt; <br>&gt; That’s why I’m proposing we use a new keyword. My initial suggestion is `type` but I welcome any better alternative.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 7:33 AM, Daniel Valls Estella &lt;daniel at upzzle.com &lt;mailto:daniel at upzzle.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just if it helps someway, in my opinion:<br>&gt;&gt; <br>&gt;&gt; - static is well known keyword modifier from long ago, but I think is an unfortunate one because is named that way from a complier point fo view, not from a language programmer user.<br>&gt;&gt; <br>&gt;&gt; - I don’t understand static as having an implicit final behaviour. <br>&gt;&gt; <br>&gt;&gt; - It seems we want to mix in one word parallel variables modifiers when is not a goal reduce code typing.<br>&gt;&gt; <br>&gt;&gt; - I found confusing using class keyword instead of static just to note that a static computed variable is not final (same for methods). More when the language provides the final keyword to identify this behaviour.<br>&gt;&gt; <br>&gt;&gt; - why not ?<br>&gt;&gt; <br>&gt;&gt; class SomeClass {<br>&gt;&gt; <br>&gt;&gt;     static var storedTypeProperty = &quot;Some value.&quot;<br>&gt;&gt;     static var computedTypeProperty: Int {<br>&gt;&gt;         return 27<br>&gt;&gt;     }<br>&gt;&gt;     static final var nonOverrideableComputedTypeProperty: Int {<br>&gt;&gt;         return 107<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -But as I mentioned I think static is not a good keyword, only we have been used to it.<br>&gt;&gt; <br>&gt;&gt; Maybe shared ? Adding overridable in case?<br>&gt;&gt; <br>&gt;&gt; class SomeClass {<br>&gt;&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;&gt;     shared var computedTypeProperty: Int {<br>&gt;&gt;         return 27<br>&gt;&gt;     }<br>&gt;&gt;     shared overridable var overrideableComputedTypeProperty: Int {<br>&gt;&gt;         return 107<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or:<br>&gt;&gt; <br>&gt;&gt; class SomeClass {<br>&gt;&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;&gt;     shared var computedTypeProperty: Int {<br>&gt;&gt;         return 27<br>&gt;&gt;     }<br>&gt;&gt;     shared final var nonOverrideableComputedTypeProperty: Int {<br>&gt;&gt;         return 107<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt; Daniel<br>&gt;&gt; <br>&gt;&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt;&gt; <br>&gt;&gt;&gt; El 8 des 2015, a les 5:22, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; va escriure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Ling,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In April 2015 you said on your blog that &quot;I was not convinced so I filed an radar.&quot; It would seem to me that you are not convinced now either, even after Chris explained that what you are asking for was implemented, reverted and ultimately rejected.  I appreciate the fact that you are thinking and worry about the apparent inconstancy. I rather the swift swift team spend more time focusing on ABI stability than on non issue items. Swift is young. Who knows maybe your ideas will make it in a future version of Swift. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; wangling.me/2015/04/unify-type-properties-and-methods.html &lt;http://wangling.me/2015/04/unify-type-properties-and-methods.html&gt;<br>&gt;&gt;&gt; https://devforums.apple.com/message/1123857 &lt;https://devforums.apple.com/message/1123857&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Monday, December 7, 2015, an0 &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since then. I believe the Swift team may have some new ideas about it or at least could take a look at the ideas in this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to learn:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cheyo at masters3d.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; ChrisLattner wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are good for familiarity and are quite descriptive (once you understand how + methods work), and open the door for potentially adding truly static methods to classes.  The primary weirdness of this model is that protocols have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the right tradeoff.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; Jul 5, 2014 <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://devforums.apple.com/message/998365#998365 &lt;https://devforums.apple.com/message/998365#998365&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt;&gt; `type`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Confusion<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt;&gt; 1.2](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6 &lt;https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6&gt;)<br>&gt;&gt;&gt; is:<br>&gt;&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an alias for class final). You are now allowed to declare static stored properties in classes, which have global storage and are lazily initialized on first access (like global variables). Protocols now declare type requirements as static requirements instead of declaring them as class requirements. (17198298)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt;&gt; static methods or class methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt;&gt; are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Class properties can only be calculated properties but not stored properties.<br>&gt;&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt;&gt; type properties and methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt;&gt; you will get this compiling error:<br>&gt;&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt;&gt; static stored properties?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt;&gt; variables’”.&lt;sup&gt;[1](https://twitter.com/UINT_MIN/status/584104757117095936 &lt;https://twitter.com/UINT_MIN/status/584104757117095936&gt;)&lt;/sup&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what are class instance variables?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The best explanation I can find is this<br>&gt;&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html &lt;http://martinfowler.com/bliki/ClassInstanceVariable.html&gt;) from<br>&gt;&gt;&gt; Martin Fowler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt;&gt; covered by this section.*<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27 &lt;https://developer.apple.com/swift/blog/?id=27&gt;):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt;&gt; not need to be overridden.<br>&gt;&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt;&gt; applying the `private` keyword.<br>&gt;&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt;&gt; declarations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt;&gt; methods?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt;&gt; declarations are needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt;&gt; properties and methods.<br>&gt;&gt;&gt; 3. Type properties can be stored or calculated, just like instance properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt;&gt; keyword because:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt;&gt; properties` and `type methods`.<br>&gt;&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt;&gt; consistent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Comparison with current design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;     static let i = 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     class var j: Int {<br>&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;     type let i = 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     type var j: Int {<br>&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // Old<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     static func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;     static func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;     class func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; // New<br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;     type func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt;&gt; simple:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt;&gt; worse?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt;&gt; compiler features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt;&gt; master it and use it properly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively we could:<br>&gt;&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt;&gt; member declarations.<br>&gt;&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt;&gt; and match.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/820cf028/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>I understand the intention to keep total compatibility with existing code. But it probably doesn’t deserve a new keyword just for that since &quot;final by default&quot; is really not so important performance-wise: https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#impact-on-existing-code &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#impact-on-existing-code&gt;. <br></p><p>&gt; On Dec 8, 2015, at 10:44 AM, Daniel Valls Estella &lt;daniel at upzzle.com&gt; wrote:<br>&gt; <br>&gt;&gt; `overridable` is unnecessary since we already have `final`.<br>&gt; <br>&gt; <br>&gt; Agree in part, but it’s to keep the current behaviour of being final by default, without anotating it, that maybe is a better aproach for shared properties.<br>&gt; <br>&gt;&gt; El 8 des 2015, a les 16:51, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; va escriure:<br>&gt;&gt; <br>&gt;&gt; Yes, the `static` is badly overloaded with many different meanings:<br>&gt;&gt; 1. static storage (old, from C)<br>&gt;&gt; 2. static linking (old, from C)<br>&gt;&gt; 3. final (new in Swift)<br>&gt;&gt; <br>&gt;&gt; That’s why I’m proposing we use a new keyword. My initial suggestion is `type` but I welcome any better alternative.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 7:33 AM, Daniel Valls Estella &lt;daniel at upzzle.com &lt;mailto:daniel at upzzle.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just if it helps someway, in my opinion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - static is well known keyword modifier from long ago, but I think is an unfortunate one because is named that way from a complier point fo view, not from a language programmer user.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I don’t understand static as having an implicit final behaviour. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - It seems we want to mix in one word parallel variables modifiers when is not a goal reduce code typing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I found confusing using class keyword instead of static just to note that a static computed variable is not final (same for methods). More when the language provides the final keyword to identify this behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - why not ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeClass {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     static var storedTypeProperty = &quot;Some value.&quot;<br>&gt;&gt;&gt;     static var computedTypeProperty: Int {<br>&gt;&gt;&gt;         return 27<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     static final var nonOverrideableComputedTypeProperty: Int {<br>&gt;&gt;&gt;         return 107<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -But as I mentioned I think static is not a good keyword, only we have been used to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe shared ? Adding overridable in case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeClass {<br>&gt;&gt;&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;&gt;&gt;     shared var computedTypeProperty: Int {<br>&gt;&gt;&gt;         return 27<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     shared overridable var overrideableComputedTypeProperty: Int {<br>&gt;&gt;&gt;         return 107<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class SomeClass {<br>&gt;&gt;&gt;     shared var storedTypeProperty = “Some value.&quot;<br>&gt;&gt;&gt;     shared var computedTypeProperty: Int {<br>&gt;&gt;&gt;         return 27<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     shared final var nonOverrideableComputedTypeProperty: Int {<br>&gt;&gt;&gt;         return 107<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Daniel<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fragment de: Apple Inc. “The Swift Programming Language (Swift 2.2)“. iBooks. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; El 8 des 2015, a les 5:22, J. Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; va escriure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Ling,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In April 2015 you said on your blog that &quot;I was not convinced so I filed an radar.&quot; It would seem to me that you are not convinced now either, even after Chris explained that what you are asking for was implemented, reverted and ultimately rejected.  I appreciate the fact that you are thinking and worry about the apparent inconstancy. I rather the swift swift team spend more time focusing on ABI stability than on non issue items. Swift is young. Who knows maybe your ideas will make it in a future version of Swift. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; wangling.me/2015/04/unify-type-properties-and-methods.html &lt;http://wangling.me/2015/04/unify-type-properties-and-methods.html&gt;<br>&gt;&gt;&gt;&gt; https://devforums.apple.com/message/1123857 &lt;https://devforums.apple.com/message/1123857&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Monday, December 7, 2015, an0 &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since then. I believe the Swift team may have some new ideas about it or at least could take a look at the ideas in this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to learn:)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;cheyo at masters3d.com&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; ChrisLattner wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword), but that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot; are good for familiarity and are quite descriptive (once you understand how + methods work), and open the door for potentially adding truly static methods to classes.  The primary weirdness of this model is that protocols have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the right tradeoff.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; Jul 5, 2014 <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://devforums.apple.com/message/998365#998365 &lt;https://devforums.apple.com/message/998365#998365&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt;&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt;&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt;&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt;&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt;&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt;&gt;&gt; `type`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### Confusion<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt;&gt;&gt; 1.2](https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6 &lt;https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6&gt;)<br>&gt;&gt;&gt;&gt; is:<br>&gt;&gt;&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an alias for class final). You are now allowed to declare static stored properties in classes, which have global storage and are lazily initialized on first access (like global variables). Protocols now declare type requirements as static requirements instead of declaring them as class requirements. (17198298)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt;&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt;&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt;&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt;&gt;&gt; static methods or class methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt;&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt;&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt;&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt;&gt;&gt; are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Class properties can only be calculated properties but not stored properties.<br>&gt;&gt;&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt;&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt;&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt;&gt;&gt; type properties and methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s see.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt;&gt;&gt; you will get this compiling error:<br>&gt;&gt;&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt;&gt;&gt; static stored properties?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt;&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt;&gt;&gt; variables’”.&lt;sup&gt;[1](https://twitter.com/UINT_MIN/status/584104757117095936 &lt;https://twitter.com/UINT_MIN/status/584104757117095936&gt;)&lt;/sup&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what are class instance variables?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The best explanation I can find is this<br>&gt;&gt;&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html &lt;http://martinfowler.com/bliki/ClassInstanceVariable.html&gt;) from<br>&gt;&gt;&gt;&gt; Martin Fowler.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt;&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt;&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt;&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt;&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt;&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt;&gt;&gt; covered by this section.*<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt;&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27 &lt;https://developer.apple.com/swift/blog/?id=27&gt;):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt;&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt;&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt;&gt;&gt; not need to be overridden.<br>&gt;&gt;&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt;&gt;&gt; applying the `private` keyword.<br>&gt;&gt;&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt;&gt;&gt; declarations.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt;&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt;&gt;&gt; methods?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt;&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt;&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt;&gt;&gt; declarations are needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt;&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt;&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt;&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt;&gt;&gt; properties and methods.<br>&gt;&gt;&gt;&gt; 3. Type properties can be stored or calculated, just like instance properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt;&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt;&gt;&gt; keyword because:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt;&gt;&gt; properties` and `type methods`.<br>&gt;&gt;&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt;&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt;&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt;&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt;&gt;&gt; consistent.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Comparison with current design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;&gt;     static let i = 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     class var j: Int {<br>&gt;&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;&gt;     type let i = 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     type var j: Int {<br>&gt;&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     static func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt;     static func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;     class func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     type func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt;&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt;&gt;&gt; simple:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt;&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt;&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt;&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt;&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt;&gt;&gt; worse?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt;&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt;&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt;&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt;&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt;&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt;&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt;&gt;&gt; compiler features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt;&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt;&gt;&gt; master it and use it properly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively we could:<br>&gt;&gt;&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt;&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt;&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt;&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt;&gt;&gt; member declarations.<br>&gt;&gt;&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt;&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt;&gt;&gt; and match.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/c673f772/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 7:51 AM, Ling Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, the `static` is badly overloaded with many different meanings:<br>&gt; 1. static storage (old, from C)<br>&gt; 2. static linking (old, from C)<br>&gt; 3. final (new in Swift)<br></p><p>static means something like 9 different things in C, including the little known C99 static array parameter size use.  That said, it is not overloaded in swift, and its use in Java and C# is very similar to that in Swift.  Further, again, I have not heard of any problems in practice with the use of the static keyword here.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>`static` at least has two meanings in Swift:<br>1. It means `final` for type methods.<br>2. It also means static storage for stored type properties.<br></p><p>But Swift must mix and match with Objective-C and C so all the existing meanings in these two languages are also inherited in Swift.<br></p><p>Yes, if we all either don’t use it or get used to its usage we won’t feel the design flaws because we won’t think about it. But if we step back and think carefully about it at the design level, we should be able to see the issues. As you advocate in several other proposals like removing ++/— and removing C for-loop, if we have opportunities to do things better in Swift we should do them even if they break old conventions and assumptions.<br></p><p>Also, consider how totally new programmers will feel. I believe they will feel the overloading of meanings on `static`, the dichotomy of static and class methods especially when implementing a static requirement from a protocol, the inconsistency between class and instance member declarations.<br></p><p>- Ling<br></p><p>&gt; On Dec 8, 2015, at 11:37 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 7:51 AM, Ling Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, the `static` is badly overloaded with many different meanings:<br>&gt;&gt; 1. static storage (old, from C)<br>&gt;&gt; 2. static linking (old, from C)<br>&gt;&gt; 3. final (new in Swift)<br>&gt; <br>&gt; static means something like 9 different things in C, including the little known C99 static array parameter size use.  That said, it is not overloaded in swift, and its use in Java and C# is very similar to that in Swift.  Further, again, I have not heard of any problems in practice with the use of the static keyword here.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  8, 2015 at 02:00:00pm</p></header><div class="content"><p>The fact that there are other issues does not mean this is non issue. You<br>agree we have inconsistency here, right?<br></p><p>Also, there are misunderstandings by Chris to my proposal. Please read my<br>last response to him. If these misunderstandings are resolved I believe<br>we&#39;ll have much more common ground to build a better design that is never<br>tried before.<br></p><p>On Mon, Dec 7, 2015 at 10:22 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>wrote:<br></p><p>&gt; Hi Ling,<br>&gt;<br>&gt; In April 2015 you said on your blog that &quot;I was not convinced so I filed<br>&gt; an radar.&quot; It would seem to me that you are not convinced now<br>&gt; either, even after Chris explained that what you are asking for was<br>&gt; implemented, reverted and ultimately rejected.  I appreciate the fact that<br>&gt; you are thinking and worry about the apparent inconstancy. I rather the<br>&gt; swift swift team spend more time focusing on ABI stability than on non<br>&gt; issue items. Swift is young. Who knows maybe your ideas will make it in a<br>&gt; future version of Swift.<br>&gt;<br>&gt; wangling.me/2015/04/unify-type-properties-and-methods.html<br>&gt; https://devforums.apple.com/message/1123857<br>&gt;<br>&gt;<br>&gt; On Monday, December 7, 2015, an0 &lt;an00na at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I read that. But that&#39;s a long time ago, Swift has evolved a lot since<br>&gt;&gt; then. I believe the Swift team may have some new ideas about it or at least<br>&gt;&gt; could take a look at the ideas in this proposal.<br>&gt;&gt;<br>&gt;&gt; Do you have any ideas of your own about this proposal? I&#39;d really like to<br>&gt;&gt; learn:)<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 7, 2015 at 12:49 PM J. Cheyo Jimenez &lt;cheyo at masters3d.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; ChrisLattner wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We considered unifying the syntax (e.g. using &quot;type&quot; as the keyword),<br>&gt;&gt;&gt; but that doesn&#39;t actually simply things.  The keywords &quot;class&quot; and &quot;static&quot;<br>&gt;&gt;&gt; are good for familiarity and are quite descriptive (once you understand how<br>&gt;&gt;&gt; + methods work), and open the door for potentially adding truly static<br>&gt;&gt;&gt; methods to classes.  The primary weirdness of this model is that protocols<br>&gt;&gt;&gt; have to pick a keyword (and we chose &quot;class&quot;), but on balance it is the<br>&gt;&gt;&gt; right tradeoff.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jul 5, 2014<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://devforums.apple.com/message/998365#998365<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Monday, December 7, 2015, an0 via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The idea is simple but the reasoning is long. So please bear with me.<br>&gt;&gt;&gt;&gt; You can read on github for a better reading experience:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md<br>&gt;&gt;&gt;&gt; .<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt;&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt;&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt;&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt;&gt;&gt; `type`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ### Confusion<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One “language enhancement” of [Swift<br>&gt;&gt;&gt;&gt; 1.2](<br>&gt;&gt;&gt;&gt; https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html#//apple_ref/doc/uid/TP40001051-CH4-SW6<br>&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt; is:<br>&gt;&gt;&gt;&gt; &gt; “static” methods and properties are now allowed in classes (as an<br>&gt;&gt;&gt;&gt; alias for class final). You are now allowed to declare static stored<br>&gt;&gt;&gt;&gt; properties in classes, which have global storage and are lazily initialized<br>&gt;&gt;&gt;&gt; on first access (like global variables). Protocols now declare type<br>&gt;&gt;&gt;&gt; requirements as static requirements instead of declaring them as class<br>&gt;&gt;&gt;&gt; requirements. (17198298)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If even the Swift team itself has difficulties in picking one from the<br>&gt;&gt;&gt;&gt; two and had to revert its initial decision after several revisions, we<br>&gt;&gt;&gt;&gt; know these keywords are indeed confusing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So now protocols use `static` to declare type methods, when a class<br>&gt;&gt;&gt;&gt; adapts such protocols, should it implement those static methods, as<br>&gt;&gt;&gt;&gt; static methods or class methods?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But static means final, right? Does it mean we can not override these<br>&gt;&gt;&gt;&gt; methods in subclasses of the conforming class?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; These kinds of unnecessary confusion and hesitation should be<br>&gt;&gt;&gt;&gt; resolved, and could if this proposal is implemented.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ### Unnecessary and inconsistent differentiation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The `class` keyword is only used in classes. In the current<br>&gt;&gt;&gt;&gt; implementation of Swift the differences between `class` and `static`<br>&gt;&gt;&gt;&gt; are:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Class properties can only be calculated properties but not stored<br>&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt; 2. Class methods(also calculated properties) are dynamically<br>&gt;&gt;&gt;&gt; dispatched while static ones are statically dispatched.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we can eliminate the differences or find better ways to<br>&gt;&gt;&gt;&gt; differentiate we can use one unified keyword instead for declaring<br>&gt;&gt;&gt;&gt; type properties and methods.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let’s see.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt;&gt;&gt; you will get this compiling error:<br>&gt;&gt;&gt;&gt; &gt; class stored properties not yet supported in classes; did you mean<br>&gt;&gt;&gt;&gt; &#39;static&#39;?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt;&gt;&gt; static stored properties?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As far as I know, class stored properties, if ever implemented in<br>&gt;&gt;&gt;&gt; Swift, “would be what Ruby calls ‘class instance<br>&gt;&gt;&gt;&gt; variables’”.&lt;sup&gt;[1](<br>&gt;&gt;&gt;&gt; https://twitter.com/UINT_MIN/status/584104757117095936)&lt;/sup&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So what are class instance variables?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The best explanation I can find is this<br>&gt;&gt;&gt;&gt; [one](http://martinfowler.com/bliki/ClassInstanceVariable.html) from<br>&gt;&gt;&gt;&gt; Martin Fowler.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Do we really want this feature in Swift? “If we didn&#39;t already have<br>&gt;&gt;&gt;&gt; these, would we add them to Swift 3?&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I strongly believe we won’t add it to Swift 3. Actually I believe we<br>&gt;&gt;&gt;&gt; will never add it to Swift, because its use cases are so rare which is<br>&gt;&gt;&gt;&gt; also why it hasn’t been implemented so far in Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we agree we are not going to support class stored properties, there<br>&gt;&gt;&gt;&gt; is and will be only one kind of stored properties for types and we<br>&gt;&gt;&gt;&gt; only need one keyword to declare such properties.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; #### Class methods VS. static methods<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; *Since calculated properties are also methods in essence they are also<br>&gt;&gt;&gt;&gt; covered by this section.*<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The only difference is how methods are dispatched.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let’s see [how we handle it for instance<br>&gt;&gt;&gt;&gt; methods](https://developer.apple.com/swift/blog/?id=27):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Methods are overridable hence dynamically dispatched by default.<br>&gt;&gt;&gt;&gt; * In performance critical code use these techniques to restrict this<br>&gt;&gt;&gt;&gt; dynamic behavior when it isn’t needed to improve performance:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     1. Use the `final` keyword when we know that a declaration does<br>&gt;&gt;&gt;&gt; not need to be overridden.<br>&gt;&gt;&gt;&gt;     2. Infer `final` on declarations referenced in one file by<br>&gt;&gt;&gt;&gt; applying the `private` keyword.<br>&gt;&gt;&gt;&gt;     3. Use `Whole Module Optimization` to infer `final` on `internal`<br>&gt;&gt;&gt;&gt; declarations.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So why abandon this whole system to use another totally different one<br>&gt;&gt;&gt;&gt; for differentiating `static dispatch` and `dynamic dispatch` for type<br>&gt;&gt;&gt;&gt; methods?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If we reuse this system for type methods, not only can we have a<br>&gt;&gt;&gt;&gt; consistent design for both instance and type methods, but also we can<br>&gt;&gt;&gt;&gt; get rid of the last place where two keywords for type member<br>&gt;&gt;&gt;&gt; declarations are needed.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Use the keyword `type` to declare type properties and methods.<br>&gt;&gt;&gt;&gt; 2. Type properties and methods are overridable hence dynamically<br>&gt;&gt;&gt;&gt; dispatched by default. Use the `final` keyword or inferred `final` to<br>&gt;&gt;&gt;&gt; make them final and statically dispatched, just like instance<br>&gt;&gt;&gt;&gt; properties and methods.<br>&gt;&gt;&gt;&gt; 3. Type properties can be stored or calculated, just like instance<br>&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As you can see, it is a very simple and elegant design:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Just a single keyword `type` to differentiate type member<br>&gt;&gt;&gt;&gt; declarations from instance member declarations. `type` is a good<br>&gt;&gt;&gt;&gt; keyword because:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     1. It is consistent with the wording of the concepts of `type<br>&gt;&gt;&gt;&gt; properties` and `type methods`.<br>&gt;&gt;&gt;&gt;     2. It is never used as a keyword before in Swift, Objective-C or<br>&gt;&gt;&gt;&gt; C. There will be no conflicts or overloading of it meanings.<br>&gt;&gt;&gt;&gt; * Except for that, how things are declared, differentiated and<br>&gt;&gt;&gt;&gt; optimized are exactly the same in both type and instance world. Very<br>&gt;&gt;&gt;&gt; consistent.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Comparison with current design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Dynamic Dispatch VS. Static Dispatch<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class func dynamicTypeMethod() {}<br>&gt;&gt;&gt;&gt;     static func staticTypeMethod() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;&gt;     func dynamicInstanceMethod() {}<br>&gt;&gt;&gt;&gt;     final func staticInstanceMethod() {}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     type func dynamicTypeMethod() {}<br>&gt;&gt;&gt;&gt;     final type func staticTypeMethod() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Stored Properties VS. Calculated Properties<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;&gt;     static let i = 1<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class var j: Int {<br>&gt;&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; class Bar {<br>&gt;&gt;&gt;&gt;     type let i = 1<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     type var j: Int {<br>&gt;&gt;&gt;&gt;         return 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Struct Implementation VS. Class Implementation of Protocol<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // Old<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     static func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt;     static func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;     class func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt;&gt; // New<br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;     type func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct S: P {<br>&gt;&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;     type func foo() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; With the help of a good migration tool, there will be no impact on<br>&gt;&gt;&gt;&gt; existing code at all. And the migration rules are very clear and<br>&gt;&gt;&gt;&gt; simple:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Map `static` to `type` in protocols.<br>&gt;&gt;&gt;&gt; * Map `static` to `type` in structs and enums.<br>&gt;&gt;&gt;&gt; * Map `class` to `type` and `static` to `final type` in classes.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One concern I can think of is: because type methods are dynamically<br>&gt;&gt;&gt;&gt; dispatched by default in the new design, will we forget to do the<br>&gt;&gt;&gt;&gt; `final` optimization so the general performance of Swift code become<br>&gt;&gt;&gt;&gt; worse?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think it is probably true. But we also forget to do the `final`<br>&gt;&gt;&gt;&gt; optimization for instance methods from time to time. Since there are<br>&gt;&gt;&gt;&gt; way more instance methods than type methods in most code the<br>&gt;&gt;&gt;&gt; performance impact will be very small. Maybe this change is a good<br>&gt;&gt;&gt;&gt; opportunity to remind us to do the `final` optimization for instance<br>&gt;&gt;&gt;&gt; methods thus even results in a better general performance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; And don’t forget we have the tools to automatically infer `final` for<br>&gt;&gt;&gt;&gt; us in many cases if we write the proper code and use the proper<br>&gt;&gt;&gt;&gt; compiler features.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; After all, it is mainly on us to write good code to produce good final<br>&gt;&gt;&gt;&gt; products. If the system is consistent we’ll have better chances to<br>&gt;&gt;&gt;&gt; master it and use it properly.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ## Alternatives considered<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Alternatively we could:<br>&gt;&gt;&gt;&gt; * Keep using `static` and `class` keywords.<br>&gt;&gt;&gt;&gt; * Keep the confusion when implementing `static` protocol requirements<br>&gt;&gt;&gt;&gt; using `class` properties and methods in conforming classes.<br>&gt;&gt;&gt;&gt; * Keep the inconsistency between type member declarations and instance<br>&gt;&gt;&gt;&gt; member declarations.<br>&gt;&gt;&gt;&gt; * Keep overloading meanings on the `static` keyword that is already<br>&gt;&gt;&gt;&gt; historically overloaded in C and Objective-C with which Swift must mix<br>&gt;&gt;&gt;&gt; and match.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/2278da8c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 7, 2015, at 8:13 AM, an0 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt; properties and methods is confusing and causes inconsistency between<br>&gt; type and instance member declarations. This document reasons why we<br>&gt; don’t need both and suggests we unify them with a better keyword<br>&gt; `type`.<br></p><p>I’m sure you know this, but for folks who haven’t dug through the history, the design team has already implemented, evaluated and rejected this idea.  We have also spent a lot of time over the years discussing and debating the issue, and have come to the current approach.  Since the Swift 1.2 changes went in, we haven’t seen significant confusion.<br></p><p>&gt; #### Class stored properties VS. static stored properties<br>&gt; <br>&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt; you will get this compiling error:<br>&gt;&gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt; <br>&gt; So what are class stored properties? How are they different from<br>&gt; static stored properties?<br></p><p>This is a well-defined concept that comes from the Objective-C language, where class methods are dynamically dispatched.  We are not willing to sacrifice compatibility with this concept.  Similarly, we need and want “static” methods in classes for the common case in which dynamic dispatch is not desired.<br></p><p>Further, the current Swift design works well for folks more familiar with Java or C++ object models can just ignore class methods and use static methods.  They behave pretty much as they would expect.<br></p><p>&gt; Class stored properties VS. static stored properties<br></p><p><br>You list many complaints about class properties, then go on to suggest that we replace “class” with “type”.  It seems that your complaints aren’t actually relevant to the proposal, since you’re not actually removing them from the model.  In fact, instead of “static var x” you’d have to write “final type var x”, which would be an unfortunate regression.<br></p><p><br>&gt; ## Proposed solution: type.<br></p><p>This sacrifices all familiarity for folks coming from other extended C-family of languages, is not precedented in a popular language that I’m aware of, and is an unfortunate word to take as a keyword.<br></p><p>Beyond that, what you’re attempting to address is pretty much a non-problem.  I’m aware of a lot of problems with Swift :-) but I have never seen the Swift 1.2+ design cause practical problems.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 6:21 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 7, 2015, at 8:13 AM, an0 via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; The coexistence of `static` and `class` keywords for declaring type<br>&gt;&gt; properties and methods is confusing and causes inconsistency between<br>&gt;&gt; type and instance member declarations. This document reasons why we<br>&gt;&gt; don’t need both and suggests we unify them with a better keyword<br>&gt;&gt; `type`.<br>&gt; <br>&gt; I’m sure you know this, but for folks who haven’t dug through the history, the design team has already implemented, evaluated and rejected this idea.  We have also spent a lot of time over the years discussing and debating the issue, and have come to the current approach.  Since the Swift 1.2 changes went in, we haven’t seen significant confusion.<br>&gt; <br>&gt;&gt; #### Class stored properties VS. static stored properties<br>&gt;&gt; <br>&gt;&gt; If you use the `class` keyword to declare a stored property in a class<br>&gt;&gt; you will get this compiling error:<br>&gt;&gt;&gt; class stored properties not yet supported in classes; did you mean &#39;static&#39;?<br>&gt;&gt; <br>&gt;&gt; So what are class stored properties? How are they different from<br>&gt;&gt; static stored properties?<br>&gt; <br>&gt; This is a well-defined concept that comes from the Objective-C language, where class methods are dynamically dispatched.  We are not willing to sacrifice compatibility with this concept.  <br>I didn’t say anything against &quot;class methods are dynamically dispatched”. Actually my proposal states that type methods are dynamically dispatched by default.<br>&gt; Similarly, we need and want “static” methods in classes for the common case in which dynamic dispatch is not desired.<br>I know it is for performance optimization. But why not use `final`? Also, did you read my optimization concern in this part: https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#impact-on-existing-code? &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#impact-on-existing-code?&gt; How do we enforce “static” dispatching for instance methods that are way more than type methods in most code?<br>&gt; <br>&gt; Further, the current Swift design works well for folks more familiar with Java or C++ object models can just ignore class methods and use static methods.  They behave pretty much as they would expect.<br>Did you read the part about inconsistency between type and instance member declarations(https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#class-methods-vs-static-methods &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#class-methods-vs-static-methods&gt;) &lt;https://github.com/an0/swift-evolution/blob/master/proposals/NNNN-unify-static-and-class-keywords.md#class-methods-vs-static-methods?&gt;? What do you think about it? Do you think compatibilities with other older languages are more important than the consistencies within Swift itself?<br>&gt; <br>&gt;&gt; Class stored properties VS. static stored properties<br>&gt; <br>&gt; <br>&gt; You list many complaints about class properties, then go on to suggest that we replace “class” with “type”.  It seems that your complaints aren’t actually relevant to the proposal, since you’re not actually removing them from the model.  In fact, instead of “static var x” you’d have to write “final type var x”, which would be an unfortunate regression.<br>When you said &quot;You list many complaints about class properties” you meant “class stored properties”, right?<br></p><p>If so I don’t think I’ve ever complained about it because Swift doesn’t support class stored properties yet. My points about class stored properties are:<br>1. Are they useful enough? Do we want it in Swift?<br>2. Are we going to add it in Swift? If yes, when?<br>3. If no, then we only have one kind of type stored properties, why do we need two keywords for them?<br>&gt; <br>&gt; <br>&gt;&gt; ## Proposed solution: type.<br>&gt; <br>&gt; This sacrifices all familiarity for folks coming from other extended C-family of languages, is not precedented in a popular language that I’m aware of, and is an unfortunate word to take as a keyword.<br>As said above, I think consistencies within Swift itself are more important than compatibilities and familiarity with other languages.<br>&gt; <br>&gt; <br>&gt; Beyond that, what you’re attempting to address is pretty much a non-problem.  I’m aware of a lot of problems with Swift :-) but I have never seen the Swift 1.2+ design cause practical problems.<br>I know there are a lot other problems that are more urgent than what we are talking about here. But I can’t agree that the inconsistency I mentioned in this proposal is a non-problem. <br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/2062aff6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:09 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Class stored properties VS. static stored properties<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You list many complaints about class properties, then go on to suggest that we replace “class” with “type”.  It seems that your complaints aren’t actually relevant to the proposal, since you’re not actually removing them from the model.  In fact, instead of “static var x” you’d have to write “final type var x”, which would be an unfortunate regression.<br>&gt; When you said &quot;You list many complaints about class properties” you meant “class stored properties”, right?<br>&gt; <br>&gt; If so I don’t think I’ve ever complained about it because Swift doesn’t support class stored properties yet. My points about class stored properties are:<br>&gt; 1. Are they useful enough? Do we want it in Swift?<br>&gt; 2. Are we going to add it in Swift? If yes, when?<br></p><p>Perhaps, but they are very low priority. <br></p><p>&gt; 3. If no, then we only have one kind of type stored properties, why do we need two keywords for them?<br></p><p>You’re missing what I’m trying to say.  With your design:<br></p><p>class Foo {<br>  type var x : Int<br>}<br></p><p>This would be a stored class property, which isn’t supported and won’t be for the forseeable.  This would require people to write:<br></p><p>class Foo {<br>  final type var x : Int<br>}<br></p><p>This is a lot worse than:<br></p><p>class Foo {<br>  static var x : Int<br>}<br></p><p>... both in terms of boilerplate noise, but also in that it leads them down the wrong path.  Many people would write “type var x : Int” wanting a static member, because they don’t understand how class variables work.<br></p><p>Your approach would make class members *more* prominent, not less.  We’ve tried this, this is not a theoretical concern.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/5b6267a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>Now I understand your concerns. But you misunderstood my proposal. I&#39;ll restate my points about “type properties”:<br></p><p>1. Stored class properties(let’s call them “class instance variables” for better discussion about “stored type properties” below) are not very useful or needed. So we are not likely to add them to Swift. This one we both agree. So there is only one kind of stored properties for types and they are stored like global variables, which are now called “static stored properties“. <br></p><p>2. `type` properties in my proposal covers both stored properties and calculated properties. Except for the `type` keyword, the way they are declared are exactly the same as that of instance properties:<br>```<br>class Foo {<br>    type let i = 1 // stored type property<br>    type var k: Int { // calculated type property<br>        return 1<br>    }<br>} <br>```<br></p><p>3. Since we’ve already excluded “class instance variables” in point 1, stored type properies in my proposal are certainly not “class instance variables”. They behave the same as the current “static stored properties”. This is where you misunderstood me. <br></p><p>So you don’t need the `final` keyword to make them “static”. If they are “stored”(VS calculated) they are “static”. We just don’t use `static` as the keyword.<br></p><p>Static storage is the implementation details. Just like global variable declarations don’t need `static` keyword though they use static storage, stored type property declarations don’t need `static` keyword to denote they use static storage. After all there is only one kind of stored type properties.<br></p><p>As you said most people expect type properties to be “static”, together with the fact that most people don’t know about “class instance variables”, stored type properties being “static” is simply the commonly accepted default behavior.<br></p><p>As to those who know about “class instance variables” we need to explain to them that stored type properties are not “class instance variables”. But since we need to tell them that Swift doens’t support “class instance variables” at all in the first place, it is not an extra complication.<br></p><p>Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br></p><p>Thanks for discussing with me:)<br></p><p>- Ling<br></p><p>&gt; On Dec 7, 2015, at 7:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:09 PM, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Class stored properties VS. static stored properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You list many complaints about class properties, then go on to suggest that we replace “class” with “type”.  It seems that your complaints aren’t actually relevant to the proposal, since you’re not actually removing them from the model.  In fact, instead of “static var x” you’d have to write “final type var x”, which would be an unfortunate regression.<br>&gt;&gt; When you said &quot;You list many complaints about class properties” you meant “class stored properties”, right?<br>&gt;&gt; <br>&gt;&gt; If so I don’t think I’ve ever complained about it because Swift doesn’t support class stored properties yet. My points about class stored properties are:<br>&gt;&gt; 1. Are they useful enough? Do we want it in Swift?<br>&gt;&gt; 2. Are we going to add it in Swift? If yes, when?<br>&gt; <br>&gt; Perhaps, but they are very low priority. <br>&gt; <br>&gt;&gt; 3. If no, then we only have one kind of type stored properties, why do we need two keywords for them?<br>&gt; <br>&gt; You’re missing what I’m trying to say.  With your design:<br>&gt; <br>&gt; class Foo {<br>&gt;   type var x : Int<br>&gt; }<br>&gt; <br>&gt; This would be a stored class property, which isn’t supported and won’t be for the forseeable.  This would require people to write:<br>&gt; <br>&gt; class Foo {<br>&gt;   final type var x : Int<br>&gt; }<br>&gt; <br>&gt; This is a lot worse than:<br>&gt; <br>&gt; class Foo {<br>&gt;   static var x : Int<br>&gt; }<br>&gt; <br>&gt; ... both in terms of boilerplate noise, but also in that it leads them down the wrong path.  Many people would write “type var x : Int” wanting a static member, because they don’t understand how class variables work.<br>&gt; <br>&gt; Your approach would make class members *more* prominent, not less.  We’ve tried this, this is not a theoretical concern.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/073c8e94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt; <br></p><p>Please remember that stored properties can be overridden in Swift:<br></p><p>class Base {<br>  /*instance*/ var flag: Bool = true<br>}<br></p><p>class Sub : Base {<br>  override var flag: Bool {<br>    didSet {<br>      if flag { print(&quot;The flag was set!&quot;) }<br>    }<br>  }<br>}<br></p><p>This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/9e25d5ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>This is a legit concern that I didn’t consider before.<br></p><p>I think there are several options, from the most general to the most subtle:<br>1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.<br>2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.<br>3. Store type vars are overridable but can not be observed. <br></p><p>There could be a even more subtle option if my understanding of how classes exist in runtime is correct.<br></p><p>In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.<br></p><p>In this modal, the 4th option is:<br>4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.<br></p><p>Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.<br></p><p>This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.<br></p><p>So one addition to option 4:<br>4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.<br></p><p>But it is such a corner case that probably this limitation is acceptable.<br></p><p>What do you think? Is my understanding of class objects correct? Which option do you like best?<br></p><p>- Ling<br></p><p>&gt; On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt;&gt; <br>&gt; <br>&gt; Please remember that stored properties can be overridden in Swift:<br>&gt; <br>&gt; class Base {<br>&gt;   /*instance*/ var flag: Bool = true<br>&gt; }<br>&gt; <br>&gt; class Sub : Base {<br>&gt;   override var flag: Bool {<br>&gt;     didSet {<br>&gt;       if flag { print(&quot;The flag was set!&quot;) }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/4f47a91a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>When verifying my class object modal I actually found one issue of the current class property observers.<br></p><p>In the current implementation, when super class’s class property setter is called, subclasses’ observers don’t get called. But after the call of super setter, the value of this property accessed via subclasses(suppose them don’t overload get/set) does change. It means their properties are changed without their knowing it even though they explicitly define observers to observe the changes.<br></p><p>```<br>var backingVarForFooI = 0<br></p><p>class Foo {<br>    class var i: Int {<br>        get {<br>            return backingVarForFooI<br>        }<br>        <br>        set {<br>            backingVarForFooI = newValue<br>            print(&quot;Foo.i.set \(newValue)&quot;)<br>        }<br>    }<br>}<br></p><p>class Bar: Foo {<br>    override class var i: Int {<br>        didSet {<br>            print(&quot;Bar.i.didSet \(i)&quot;)<br>        }<br>    }<br>}<br></p><p>print(Bar.i)<br>Foo.i = 3<br>print(Bar.i)<br>```<br></p><p>If we think about it, it doesn’t matter whether the proper is stored or calculated. Storage is just the implementation details, it doesn’t affect the interface or the concept. Besides, even calculated properties need storage if they are mutable.<br></p><p>After super class changes a property, people expect to get the changed value when they access the property via their subclasses(suppose they don’t overload get/set) and expect the corresponding observers to get called. So the class object modal that I speculated sharing properties among all subclasses and super class and notifying them about property changes is the only sound modal in this aspect. So the concern about overloading stored type properties with observers is not only about stored type properties but about all type properties.<br></p><p>So there is nothing special to separate stored type properties from calculated type properties. It supports my proposal to unite them under a more general keyword.<br></p><p>- Ling<br></p><p>&gt; On Dec 9, 2015, at 10:23 AM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is a legit concern that I didn’t consider before.<br>&gt; <br>&gt; I think there are several options, from the most general to the most subtle:<br>&gt; 1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.<br>&gt; 2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.<br>&gt; 3. Store type vars are overridable but can not be observed. <br>&gt; <br>&gt; There could be a even more subtle option if my understanding of how classes exist in runtime is correct.<br>&gt; <br>&gt; In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.<br>&gt; <br>&gt; In this modal, the 4th option is:<br>&gt; 4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.<br>&gt; <br>&gt; Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.<br>&gt; <br>&gt; This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.<br>&gt; <br>&gt; So one addition to option 4:<br>&gt; 4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.<br>&gt; <br>&gt; But it is such a corner case that probably this limitation is acceptable.<br>&gt; <br>&gt; What do you think? Is my understanding of class objects correct? Which option do you like best?<br>&gt; <br>&gt; - Ling<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Please remember that stored properties can be overridden in Swift:<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;   /*instance*/ var flag: Bool = true<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Sub : Base {<br>&gt;&gt;   override var flag: Bool {<br>&gt;&gt;     didSet {<br>&gt;&gt;       if flag { print(&quot;The flag was set!&quot;) }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/a4196028/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>The current behavior is not a bug; it matches the behavior for instance computed properties. To put it another way, if the base class&#39;s computed implementation stored values in a dictionary keyed by &#39;self&#39;, it would effectively be an implementation of true class properties. (People do indeed do this in Objective-C, although it&#39;s not common.)<br></p><p>We definitely don&#39;t want setting a base class property to invoke an arbitrary number of arbitrarily-ordered observers. Moreover, what if some of the subclasses actually override the setter entirely, instead of just adding an observer? That&#39;s clearly not implementable.<br></p><p>Again, I&#39;m not saying you/we can&#39;t pick a behavior and stick with it. I just want the tradeoffs to be clear.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 10, 2015, at 7:23, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt; When verifying my class object modal I actually found one issue of the current class property observers.<br>&gt; <br>&gt; In the current implementation, when super class’s class property setter is called, subclasses’ observers don’t get called. But after the call of super setter, the value of this property accessed via subclasses(suppose them don’t overload get/set) does change. It means their properties are changed without their knowing it even though they explicitly define observers to observe the changes.<br>&gt; <br>&gt; ```<br>&gt; var backingVarForFooI = 0<br>&gt; <br>&gt; class Foo {<br>&gt;     class var i: Int {<br>&gt;         get {<br>&gt;             return backingVarForFooI<br>&gt;         }<br>&gt;         <br>&gt;         set {<br>&gt;             backingVarForFooI = newValue<br>&gt;             print(&quot;Foo.i.set \(newValue)&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Bar: Foo {<br>&gt;     override class var i: Int {<br>&gt;         didSet {<br>&gt;             print(&quot;Bar.i.didSet \(i)&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; print(Bar.i)<br>&gt; Foo.i = 3<br>&gt; print(Bar.i)<br>&gt; ```<br>&gt; <br>&gt; If we think about it, it doesn’t matter whether the proper is stored or calculated. Storage is just the implementation details, it doesn’t affect the interface or the concept. Besides, even calculated properties need storage if they are mutable.<br>&gt; <br>&gt; After super class changes a property, people expect to get the changed value when they access the property via their subclasses(suppose they don’t overload get/set) and expect the corresponding observers to get called. So the class object modal that I speculated sharing properties among all subclasses and super class and notifying them about property changes is the only sound modal in this aspect. So the concern about overloading stored type properties with observers is not only about stored type properties but about all type properties.<br>&gt; <br>&gt; So there is nothing special to separate stored type properties from calculated type properties. It supports my proposal to unite them under a more general keyword.<br>&gt; <br>&gt; - Ling<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 10:23 AM, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a legit concern that I didn’t consider before.<br>&gt;&gt; <br>&gt;&gt; I think there are several options, from the most general to the most subtle:<br>&gt;&gt; 1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.<br>&gt;&gt; 2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.<br>&gt;&gt; 3. Store type vars are overridable but can not be observed. <br>&gt;&gt; <br>&gt;&gt; There could be a even more subtle option if my understanding of how classes exist in runtime is correct.<br>&gt;&gt; <br>&gt;&gt; In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.<br>&gt;&gt; <br>&gt;&gt; In this modal, the 4th option is:<br>&gt;&gt; 4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.<br>&gt;&gt; <br>&gt;&gt; Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.<br>&gt;&gt; <br>&gt;&gt; This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.<br>&gt;&gt; <br>&gt;&gt; So one addition to option 4:<br>&gt;&gt; 4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.<br>&gt;&gt; <br>&gt;&gt; But it is such a corner case that probably this limitation is acceptable.<br>&gt;&gt; <br>&gt;&gt; What do you think? Is my understanding of class objects correct? Which option do you like best?<br>&gt;&gt; <br>&gt;&gt; - Ling<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please remember that stored properties can be overridden in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;   /*instance*/ var flag: Bool = true<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Sub : Base {<br>&gt;&gt;&gt;   override var flag: Bool {<br>&gt;&gt;&gt;     didSet {<br>&gt;&gt;&gt;       if flag { print(&quot;The flag was set!&quot;) }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/2d0a3f3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 10, 2015 at 02:00:00pm</p></header><div class="content"><p>I just realized that I wrote `overload` when I meant `override` in some places. Sorry for that.<br></p><p>I didn’t say it is a bug, just an issue. An issue like I only get notified when I draw money from the bank account I inherited from my father but not when my father draw from it. :p<br></p><p>The underlying implementation may match match that for instance computed properties. But we can&#39;t demonstrate this behavior on instance properties, can we? How can a Swift user trigger super setter without triggering subclass observer when writing to an instance property?<br></p><p>There is no clear solution to overriding setter and overriding with observer at the same time.<br></p><p>When I talked about the issue, my major point is that there is no necessary and meaningful difference between stored and calculated type properties, even the issues are the same, so we can unite them with a single keyword.<br></p><p>I thought I got it from your first mail, but after these discussion I got lost:( What exactly is your concern of stored type properties from my proposal? Why doesn&#39;t it apply to calculated type properties?<br></p><p>- Ling<br></p><p>&gt; On Dec 10, 2015, at 12:17 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; The current behavior is not a bug; it matches the behavior for instance computed properties. To put it another way, if the base class&#39;s computed implementation stored values in a dictionary keyed by &#39;self&#39;, it would effectively be an implementation of true class properties. (People do indeed do this in Objective-C, although it&#39;s not common.)<br>&gt; <br>&gt; We definitely don&#39;t want setting a base class property to invoke an arbitrary number of arbitrarily-ordered observers. Moreover, what if some of the subclasses actually override the setter entirely, instead of just adding an observer? That&#39;s clearly not implementable.<br>&gt; <br>&gt; Again, I&#39;m not saying you/we can&#39;t pick a behavior and stick with it. I just want the tradeoffs to be clear.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 7:23, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When verifying my class object modal I actually found one issue of the current class property observers.<br>&gt;&gt; <br>&gt;&gt; In the current implementation, when super class’s class property setter is called, subclasses’ observers don’t get called. But after the call of super setter, the value of this property accessed via subclasses(suppose them don’t overload get/set) does change. It means their properties are changed without their knowing it even though they explicitly define observers to observe the changes.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; var backingVarForFooI = 0<br>&gt;&gt; <br>&gt;&gt; class Foo {<br>&gt;&gt;     class var i: Int {<br>&gt;&gt;         get {<br>&gt;&gt;             return backingVarForFooI<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         set {<br>&gt;&gt;             backingVarForFooI = newValue<br>&gt;&gt;             print(&quot;Foo.i.set \(newValue)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Bar: Foo {<br>&gt;&gt;     override class var i: Int {<br>&gt;&gt;         didSet {<br>&gt;&gt;             print(&quot;Bar.i.didSet \(i)&quot;)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; print(Bar.i)<br>&gt;&gt; Foo.i = 3<br>&gt;&gt; print(Bar.i)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; If we think about it, it doesn’t matter whether the proper is stored or calculated. Storage is just the implementation details, it doesn’t affect the interface or the concept. Besides, even calculated properties need storage if they are mutable.<br>&gt;&gt; <br>&gt;&gt; After super class changes a property, people expect to get the changed value when they access the property via their subclasses(suppose they don’t overload get/set) and expect the corresponding observers to get called. So the class object modal that I speculated sharing properties among all subclasses and super class and notifying them about property changes is the only sound modal in this aspect. So the concern about overloading stored type properties with observers is not only about stored type properties but about all type properties.<br>&gt;&gt; <br>&gt;&gt; So there is nothing special to separate stored type properties from calculated type properties. It supports my proposal to unite them under a more general keyword.<br>&gt;&gt; <br>&gt;&gt; - Ling<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 10:23 AM, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a legit concern that I didn’t consider before.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think there are several options, from the most general to the most subtle:<br>&gt;&gt;&gt; 1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.<br>&gt;&gt;&gt; 2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.<br>&gt;&gt;&gt; 3. Store type vars are overridable but can not be observed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There could be a even more subtle option if my understanding of how classes exist in runtime is correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this modal, the 4th option is:<br>&gt;&gt;&gt; 4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So one addition to option 4:<br>&gt;&gt;&gt; 4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it is such a corner case that probably this limitation is acceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think? Is my understanding of class objects correct? Which option do you like best?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Ling<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please remember that stored properties can be overridden in Swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;   /*instance*/ var flag: Bool = true<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Sub : Base {<br>&gt;&gt;&gt;&gt;   override var flag: Bool {<br>&gt;&gt;&gt;&gt;     didSet {<br>&gt;&gt;&gt;&gt;       if flag { print(&quot;The flag was set!&quot;) }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/41df367f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 10, 2015 at 05:00:00pm</p></header><div class="content"><p>Here is your code, minus the &quot;class&quot; qualifier.<br></p><p>var backingVarForFooI = 0<br></p><p>class Foo {<br>    var i: Int { // was &quot;class&quot;<br>        get {<br>            return backingVarForFooI<br>        }<br>        <br>        set {<br>            backingVarForFooI = newValue<br>            print(&quot;Foo.i.set \(newValue)&quot;)<br>        }<br>    }<br>}<br></p><p>class Bar: Foo {<br>    override var i: Int { // was &quot;class&quot;<br>        didSet {<br>            print(&quot;Bar.i.didSet \(i)&quot;)<br>        }<br>    }<br>}<br></p><p>print(Bar.i)<br>Foo.i = 3<br>print(Bar.i)<br></p><p>Now, clearly this is rather silly code, but my point is &quot;if you choose to use a global variable as the backing storage of a computed property, you can mutate it in multiple ways&quot;. Whether the computed property is a class property or an instance property doesn&#39;t affect that.<br></p><p>That&#39;s not an argument against unifying &quot;class&quot; and &quot;static&quot;. It&#39;s just pointing out that the existing behavior of computed class variables isn&#39;t an argument for unifying &quot;class&quot; and &quot;static&quot; either.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 10, 2015, at 12:19, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt; I just realized that I wrote `overload` when I meant `override` in some places. Sorry for that.<br>&gt; <br>&gt; I didn’t say it is a bug, just an issue. An issue like I only get notified when I draw money from the bank account I inherited from my father but not when my father draw from it. :p<br>&gt; <br>&gt; The underlying implementation may match match that for instance computed properties. But we can&#39;t demonstrate this behavior on instance properties, can we? How can a Swift user trigger super setter without triggering subclass observer when writing to an instance property?<br>&gt; <br>&gt; There is no clear solution to overriding setter and overriding with observer at the same time.<br>&gt; <br>&gt; When I talked about the issue, my major point is that there is no necessary and meaningful difference between stored and calculated type properties, even the issues are the same, so we can unite them with a single keyword.<br>&gt; <br>&gt; I thought I got it from your first mail, but after these discussion I got lost:( What exactly is your concern of stored type properties from my proposal? Why doesn&#39;t it apply to calculated type properties?<br>&gt; <br>&gt; - Ling<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 12:17 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The current behavior is not a bug; it matches the behavior for instance computed properties. To put it another way, if the base class&#39;s computed implementation stored values in a dictionary keyed by &#39;self&#39;, it would effectively be an implementation of true class properties. (People do indeed do this in Objective-C, although it&#39;s not common.)<br>&gt;&gt; <br>&gt;&gt; We definitely don&#39;t want setting a base class property to invoke an arbitrary number of arbitrarily-ordered observers. Moreover, what if some of the subclasses actually override the setter entirely, instead of just adding an observer? That&#39;s clearly not implementable.<br>&gt;&gt; <br>&gt;&gt; Again, I&#39;m not saying you/we can&#39;t pick a behavior and stick with it. I just want the tradeoffs to be clear.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 7:23, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When verifying my class object modal I actually found one issue of the current class property observers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the current implementation, when super class’s class property setter is called, subclasses’ observers don’t get called. But after the call of super setter, the value of this property accessed via subclasses(suppose them don’t overload get/set) does change. It means their properties are changed without their knowing it even though they explicitly define observers to observe the changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; var backingVarForFooI = 0<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo {<br>&gt;&gt;&gt;     class var i: Int {<br>&gt;&gt;&gt;         get {<br>&gt;&gt;&gt;             return backingVarForFooI<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         set {<br>&gt;&gt;&gt;             backingVarForFooI = newValue<br>&gt;&gt;&gt;             print(&quot;Foo.i.set \(newValue)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Bar: Foo {<br>&gt;&gt;&gt;     override class var i: Int {<br>&gt;&gt;&gt;         didSet {<br>&gt;&gt;&gt;             print(&quot;Bar.i.didSet \(i)&quot;)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(Bar.i)<br>&gt;&gt;&gt; Foo.i = 3<br>&gt;&gt;&gt; print(Bar.i)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we think about it, it doesn’t matter whether the proper is stored or calculated. Storage is just the implementation details, it doesn’t affect the interface or the concept. Besides, even calculated properties need storage if they are mutable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After super class changes a property, people expect to get the changed value when they access the property via their subclasses(suppose they don’t overload get/set) and expect the corresponding observers to get called. So the class object modal that I speculated sharing properties among all subclasses and super class and notifying them about property changes is the only sound modal in this aspect. So the concern about overloading stored type properties with observers is not only about stored type properties but about all type properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So there is nothing special to separate stored type properties from calculated type properties. It supports my proposal to unite them under a more general keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Ling<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 10:23 AM, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a legit concern that I didn’t consider before.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think there are several options, from the most general to the most subtle:<br>&gt;&gt;&gt;&gt; 1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.<br>&gt;&gt;&gt;&gt; 2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.<br>&gt;&gt;&gt;&gt; 3. Store type vars are overridable but can not be observed. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There could be a even more subtle option if my understanding of how classes exist in runtime is correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this modal, the 4th option is:<br>&gt;&gt;&gt;&gt; 4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So one addition to option 4:<br>&gt;&gt;&gt;&gt; 4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it is such a corner case that probably this limitation is acceptable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think? Is my understanding of class objects correct? Which option do you like best?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Ling<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please remember that stored properties can be overridden in Swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;&gt;&gt;   /*instance*/ var flag: Bool = true<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Sub : Base {<br>&gt;&gt;&gt;&gt;&gt;   override var flag: Bool {<br>&gt;&gt;&gt;&gt;&gt;     didSet {<br>&gt;&gt;&gt;&gt;&gt;       if flag { print(&quot;The flag was set!&quot;) }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/8d1d5a1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 11, 2015 at 01:00:00am</p></header><div class="content"><p>But can your code compile and run? How can you access instance properties via class interface?<br>I didn&#39;t bring up this behavior of computed class variables as an argument for unifying &quot;class&quot; and &quot;static&quot;. I brought up it to demonstrate the similarity between computed and stored type properties, even on limitation/issue level, which is an argument for unifying &quot;class&quot; and &quot;static&quot;. <br></p><p>- Ling<br>    _____________________________<br>From: Jordan Rose &lt;jordan_rose at apple.com&gt;<br>Sent: Thursday, December 10, 2015 7:06 PM<br>Subject: Re: [swift-evolution] Unify `static` and `class` keywords<br>To: Ling Wang &lt;an00na at gmail.com&gt;<br>Cc: swift-evolution &lt;swift-evolution at swift.org&gt;<br></p><p><br>          Here is your code, minus the &quot;class&quot; qualifier.       <br>                var backingVarForFooI = 0                   <br>                   class Foo {                       var i: Int {      // was &quot;class&quot;                           get {                               return backingVarForFooI                           }                                                      set {                               backingVarForFooI = newValue                               print(&quot;Foo.i.set \(newValue)&quot;)                           }                       }                   }                   <br>                   class Bar: Foo {                       override var i: Int {      // was &quot;class&quot;                           didSet {                               print(&quot;Bar.i.didSet \(i)&quot;)                           }                       }                   }                   <br>                   print(Bar.i)                   Foo.i = 3                   print(Bar.i)                <br>       Now, clearly this is rather silly code, but my point is &quot;if you choose to use a global variable as the backing storage of a computed property, you can mutate it in multiple ways&quot;. Whether the computed property is a class property or an instance property doesn&#39;t affect that.       <br>       That&#39;s not an argument against unifying &quot;class&quot; and &quot;static&quot;. It&#39;s just pointing out that the existing behavior of computed class variables isn&#39;t an argument    for unifying &quot;class&quot; and &quot;static&quot; either.       <br>       Jordan       <br>    <br>              On Dec 10, 2015, at 12:19, Ling Wang &lt;     an00na at gmail.com&gt; wrote:        <br>                           I just realized that I wrote `overload` when I meant `override` in some places. Sorry for that.                   <br>      I didn’t say it is a bug, just an issue. An issue like I only get notified when I draw money from the bank account I inherited from my father but not when my father draw from it. :p             <br>                   The underlying implementation may match match that for instance computed properties. But we can&#39;t demonstrate this behavior on instance properties, can we? How can a Swift user trigger super setter without triggering subclass observer when writing to an instance property?                   <br>                   There is no clear solution to overriding setter and overriding with observer at the same time.                   <br>                   When I talked about the issue, my major point is that there is no necessary and meaningful difference between stored and calculated type properties, even the issues are the same, so we can unite them with a single keyword.                   <br>I thought I got it from your first mail, but after these discussion I got lost:( What exactly is your concern of stored type properties from my proposal? Why doesn&#39;t it apply to calculated type properties?       <br>       <br>               - Ling        <br>                 <br>                                          On Dec 10, 2015, at 12:17 PM, Jordan Rose &lt;            jordan_rose at apple.com&gt; wrote:                      <br>                                                              The current behavior is not a bug; it matches the behavior for instance computed properties. To put it another way, if the base class&#39;s computed implementation stored values in a dictionary keyed by &#39;self&#39;, it would effectively be an implementation of true class properties. (People do indeed do this in Objective-C, although it&#39;s not common.)                                        <br>                                        We definitely don&#39;t want setting a base class property to invoke an arbitrary number of arbitrarily-ordered observers. Moreover, what if some of the subclasses actually override the setter entirely, instead of just adding an observer? That&#39;s clearly not implementable.                                        <br>                                        Again, I&#39;m not saying you/we can&#39;t pick a behavior and stick with it. I just want the tradeoffs to be clear.                                        <br>                                        Jordan                                        <br>                          <br>                                                          On Dec 10, 2015, at 7:23, Ling Wang &lt;                an00na at gmail.com&gt; wrote:                              <br>                                                                                  When verifying my class object modal I actually found one issue of the current class property observers.                                                    <br>                                                    In the current implementation, when super class’s class property setter is called, subclasses’ observers don’t get called. But after the call of super setter, the value of this property accessed via subclasses(suppose them don’t overload get/set) does change. It means their properties are changed without their knowing it even though they explicitly define observers to observe the changes.                                                    <br>                                                                       ```                                                       var backingVarForFooI = 0                   <br>                   <br>class Foo {                   <br>    class var i: Int {                   <br>        get {                   <br>            return backingVarForFooI                   <br>        }                   <br>                           <br>        set {                   <br>            backingVarForFooI = newValue                   <br>            print(&quot;Foo.i.set \(newValue)&quot;)                   <br>        }                   <br>    }                   <br>}                   <br>                   <br>class Bar: Foo {                   <br>    override class var i: Int {                   <br>        didSet {                   <br>            print(&quot;Bar.i.didSet \(i)&quot;)                   <br>        }                   <br>    }                   <br>}                   <br>                   <br>print(Bar.i)                   <br>Foo.i = 3                   <br>print(Bar.i)                                                       ```                                                                      <br>                                                    If we think about it, it doesn’t matter whether the proper is stored or calculated. Storage is just the implementation details, it doesn’t affect the interface or the concept. Besides, even calculated properties need storage if they are mutable.                                                    <br>                                                    After super class changes a property, people expect to get the changed value when they access the property via their subclasses(suppose they don’t overload get/set) and expect the corresponding observers to get called. So the class object modal that I speculated sharing properties among all subclasses and super class and notifying them about property changes is the only sound modal in this aspect. So the concern about overloading stored type properties with observers is not only about stored type properties but about all type properties.                                                    <br>                                                    So there is nothing special to separate stored type properties from calculated type properties. It supports my proposal to unite them under a more general keyword.                                                    <br>                                                    - Ling                                                    <br>                                                                                           On Dec 9, 2015, at 10:23 AM, Ling Wang &lt;                    an00na at gmail.com&gt; wrote:                                      <br>                                                                                                      This is a legit concern that I didn’t consider before.                                                                <br>                                                                I think there are several options, from the most general to the most subtle:                                                                1. Stored type properties are implicit `final`, so behave exactly the same as the current static stored properties.                                                                2. Stored type vars are implicit `final`, as you suggested, so behave exactly the same as the current static stored vars. All other type properties(including stored type lets) are normally overridable.                                                                3. Store type vars are overridable but can not be observed.                                                                 <br>                                                                There could be a even more subtle option if my understanding of how classes exist in runtime is correct.                                                                <br>                                                                In my understanding, classes exist as singleton instances of their meta classes. If it is true, which I believe is the image in most people’s heads if they know about meta classes, then the class objects tree is exactly the same as the class hierarchy tree. Every subclass object contains(or points to) its super class object in its layout. The super class part is shared by all subclass objects and the super class object per se. So stored type properties are conceptually and naturally shared by the super class and all its subclasses, which behave exactly like the current static stored properties.                                                                <br>                                                                In this modal, the 4th option is:                                                                4. Stored type vars are overridable and observable. When they are assigned new values, all their property observers defined in the class hierarchy are called, calling order is not significant, the reason of which will be addressed later.                                                                <br>                                                                Unfortunately, there is one last catch: if more than one classes assign a value to the property within their didSet observer, the final result is undefined.                                                                <br>                                                                This issue can not even be resolved by ordering observer calls from top to bottom in the class hierarchy because we can not meaningfully define the order within the same level if there are more than one subclasses in it.                                                                <br>                                                                So one addition to option 4:                                                                4-1. Stored type vars’ didSet observers are not allowed to reassign value to the observed property.                                                                <br>                                                                But it is such a corner case that probably this limitation is acceptable.                                                                <br>                                                                What do you think? Is my understanding of class objects correct? Which option do you like best?                                                                <br>                                                                - Ling                                                                <br>                                                                                                               On Dec 8, 2015, at 5:40 PM, Jordan Rose &lt;                        jordan_rose at apple.com&gt; wrote:                                              <br>                                                                                                <br>                                                                                                          On Dec 7, 2015, at 19:12, Ling Wang via swift-evolution &lt;                            swift-evolution at swift.org&gt; wrote:                                                      <br>                                                                                    Besides, we shouldn’t use `final` to denote storage at all for `final` is about inheritability/overridability not about storage.                                                        <br>                                                                                                       <br>                                                   Please remember that stored properties                           can be overridden in Swift:                                                                            <br>                                                                                                       class Base {                                                                                 /*instance*/ var flag: Bool = true                                                                               }                                                                               <br>                                                                               class Sub : Base {                                                                                 override var flag: Bool {                                                                                   didSet {                                                                                     if flag { print(&quot;The flag was set!&quot;) }                                                                                   }                                                                                 }                                                                               }                                                                            <br>                                                   This is theoretically possible at the class level as well, but doesn&#39;t really make sense for what&#39;s currently spelled &quot;static var&quot;, since you&#39;d be accessing the same storage in different ways. Does the proposal mean that a stored &quot;type var&quot; is non-overrideable, but a computed &quot;type var&quot; is overrideable, implicitly?                                                                            <br>                                                                            Jordan                                                                                                                                        <br>                                                                                           <br>                                                                       <br>                                                   <br>                                     <br> <br></p><p><br>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/eb9ef4bf/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 7:12 PM, Ling Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now I understand your concerns. But you misunderstood my proposal. I&#39;ll restate my points about “type properties”:<br>&gt; <br>&gt; 1. Stored class properties(let’s call them “class instance variables” for better discussion about “stored type properties” below) are not very useful or needed. So we are not likely to add them to Swift. This one we both agree. So there is only one kind of stored properties for types and they are stored like global variables, which are now called “static stored properties“. <br>&gt; <br>&gt; 2. `type` properties in my proposal covers both stored properties and calculated properties. Except for the `type` keyword, the way they are declared are exactly the same as that of instance properties:<br>&gt; ```<br>&gt; class Foo {<br>&gt;     type let i = 1 // stored type property<br>&gt;     type var k: Int { // calculated type property<br>&gt;         return 1<br>&gt;     }<br>&gt; } <br>&gt; ```<br>&gt; <br>&gt; 3. Since we’ve already excluded “class instance variables” in point 1, stored type properies in my proposal are certainly not “class instance variables”. They behave the same as the current “static stored properties”. This is where you misunderstood me. <br>&gt; <br>&gt; So you don’t need the `final` keyword to make them “static”. If they are “stored”(VS calculated) they are “static”. We just don’t use `static` as the keyword.<br>&gt; <br>&gt; Static storage is the implementation details. Just like global variable declarations don’t need `static` keyword though they use static storage, stored type property declarations don’t need `static` keyword to denote they use static storage. After all there is only one kind of stored type properties.<br></p><p>The problem is one of consistency.  It would be very problematic for a “type var” to have one set of semantics, but a “type func” to have completely different semantics.  Also keep in mind that we *do* have *computed* static and computed class properties, today.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>Can you explain the inconsistency between the semantics of “type var” and “type func”?<br></p><p>I don’t see any inconsistency:<br>1. For calculated properties, “type var” and “type func” are essentially the same thing. My proposal doesn’t treat them differently.<br>2. For stored properties, “type var” and “type func” are totally different things, by definition. One is data, one is function. It is the same for instance properties and methods. This difference is inherent in object-orientated programming.<br></p><p>- Ling<br></p><p>&gt; On Dec 9, 2015, at 12:01 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 7:12 PM, Ling Wang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Now I understand your concerns. But you misunderstood my proposal. I&#39;ll restate my points about “type properties”:<br>&gt;&gt; <br>&gt;&gt; 1. Stored class properties(let’s call them “class instance variables” for better discussion about “stored type properties” below) are not very useful or needed. So we are not likely to add them to Swift. This one we both agree. So there is only one kind of stored properties for types and they are stored like global variables, which are now called “static stored properties“. <br>&gt;&gt; <br>&gt;&gt; 2. `type` properties in my proposal covers both stored properties and calculated properties. Except for the `type` keyword, the way they are declared are exactly the same as that of instance properties:<br>&gt;&gt; ```<br>&gt;&gt; class Foo {<br>&gt;&gt;    type let i = 1 // stored type property<br>&gt;&gt;    type var k: Int { // calculated type property<br>&gt;&gt;        return 1<br>&gt;&gt;    }<br>&gt;&gt; } <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; 3. Since we’ve already excluded “class instance variables” in point 1, stored type properies in my proposal are certainly not “class instance variables”. They behave the same as the current “static stored properties”. This is where you misunderstood me. <br>&gt;&gt; <br>&gt;&gt; So you don’t need the `final` keyword to make them “static”. If they are “stored”(VS calculated) they are “static”. We just don’t use `static` as the keyword.<br>&gt;&gt; <br>&gt;&gt; Static storage is the implementation details. Just like global variable declarations don’t need `static` keyword though they use static storage, stored type property declarations don’t need `static` keyword to denote they use static storage. After all there is only one kind of stored type properties.<br>&gt; <br>&gt; The problem is one of consistency.  It would be very problematic for a “type var” to have one set of semantics, but a “type func” to have completely different semantics.  Also keep in mind that we *do* have *computed* static and computed class properties, today.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Unify `static` and `class` keywords</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; ... both in terms of boilerplate noise, but also in that it leads them down the wrong path.  Many people would write “type var x : Int” wanting a static member, because they don’t understand how class variables work.<br>&gt; <br>&gt; Your approach would make class members *more* prominent, not less.  We’ve tried this, this is not a theoretical concern.<br></p><p>This is only true as long as final is not the default.  That is obviously an orthogonal issue but it is one I feel is worth reconsidering.  It&#39;s interesting to note how final not being the default has caused difficulty in this corner of the language.<br></p><p>Maybe if final were the default and we decide to forgo class variables unification would become possible without the issues that arose the first time around.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
