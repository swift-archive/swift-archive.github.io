<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>January  6, 2016 at 10:00:00pm</p></header><div class="content"><p>I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br></p><p>Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.  <br></p><p><br>Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br></p><p><br>—russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ff1daab58cd5e44a457908d1905c322?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Krzysztof Siejkowski</string> &lt;krzysztof at siejkowski.net&gt;<p>January  7, 2016 at 08:00:00am</p></header><div class="content"><p>FWIW, not sure if it fits your desired outcome, but some time ago I’ve proposed the idea of `CustomOptionalConvertible` protocol:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000918.html <br></p><p>This could be used to extend the let binding syntax to any arbitrary type, as long as the user provides the valid translation to Optional&lt;Type&gt;.<br></p><p>The proposal, unfortunately, did not get a lot of attention at the time.<br></p><p>The main drawback to such a solution for your case is that CustomOptionalConvertible is an opt-in mechanism, so you’d need to write the implementation of CustomOptionalConvertible to each type you wish to let bind:<br></p><p>extension Type : CustomOptionalConvertible {<br>	typealias Wrapped = Type<br>	public var optional: Optional&lt;Type&gt; { get {<br>		return .Some(self)<br>	}}<br>}<br></p><p>Would the necessity for the above boilerplate be a show-stopper to you? <br>If so, would you rather see the extension of let bind syntax as default on for all the types?<br></p><p>Cheers,<br>Krzysztof<br></p><p>On 7 January 2016 at 07:41:06, Russ Bishop via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br></p><p>Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.  <br></p><p><br>Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br></p><p><br>—russ<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/32141a99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 12:00:00am</p></header><div class="content"><p>+1. I&#39;ve had a hard time cleaning up certain pieces of code that involve<br>multiple optional chains and condition checks.<br></p><p>One solution I came up with, but have never used in practice (because it&#39;s<br>too obscure), is this:<br></p><p>    extension Equatable {<br>        func *except*(excludedValue: Self) -&gt; Self? {<br>            return self == excludedValue ? nil : self<br>        }<br>    }<br></p><p>Then you can make a non-optional Equatable value into an Optional by<br>checking against a known excluded value:<br></p><p>    if let input = inputs.first, ...,<br>        let matchLoc = regex.rangeOfFirstMatchInString(...).location.<br>*except*(NSNotFound)<br>    {<br>        // Do something with matchLoc<br>    } else ...<br></p><p><br>Another, more flexible, option is to make a new protocol with an extension<br>that provides similar functionality, but with a closure argument. Then you<br>unfortunately have to add a trivial conformance for any type you need to<br>use.<br></p><p>    protocol Satisfying {}<br>    extension Satisfying {<br>        func *satisfying*(@noescape predicate: Self -&gt; Bool) -&gt; Self? {<br>            return predicate(self) ? self : nil<br>        }<br>    }<br></p><p>    extension NSRange: Satisfying {}<br></p><p>    if let input = inputs.first, ...,<br>        let matchRange = regex.rangeOfFirstMatchInString(...).*satisfying*({<br>$0.location != NSNotFound })<br>    {<br>        // Do something with matchRange<br>    } else ...<br></p><p><br>To be clear, here&#39;s what the user *wants* to do; the clearest code:<br></p><p>    if let input = inputs.first, ...,<br>        let matchRange = regex.rangeOfFirstMatchInString(...)<br>        *where* matchRange.location != NSNotFound<br>    {<br>        // Do something with matchRange<br>    } else ...<br></p><p>But that&#39;s not allowed, because rangeOfFirstMatchInString returns a<br>non-optional NSRange.<br></p><p>(Arguably this is a bug to be fixed in the regex API, which should be<br>replacing NSRange with Range&lt;Int&gt;?, but it&#39;s a good example of something<br>that crops up in plenty of other places.)<br></p><p>Jacob<br></p><p>On Wed, Jan 6, 2016 at 11:06 PM, Krzysztof Siejkowski via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; FWIW, not sure if it fits your desired outcome, but some time ago I’ve<br>&gt; proposed the idea of `CustomOptionalConvertible` protocol:<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000918.html<br>&gt;<br>&gt;<br>&gt; This could be used to extend the let binding syntax to any arbitrary type,<br>&gt; as long as the user provides the valid translation to Optional&lt;Type&gt;.<br>&gt;<br>&gt; The proposal, unfortunately, did not get a lot of attention at the time.<br>&gt;<br>&gt; The main drawback to such a solution for your case is that<br>&gt; CustomOptionalConvertible is an opt-in mechanism, so you’d need to write<br>&gt; the implementation of CustomOptionalConvertible to each type you wish to<br>&gt; let bind:<br>&gt;<br>&gt; extension Type : CustomOptionalConvertible {<br>&gt; typealias Wrapped = Type<br>&gt; public var optional: Optional&lt;Type&gt; { get {<br>&gt; return .Some(self)<br>&gt; }}<br>&gt; }<br>&gt;<br>&gt; Would the necessity for the above boilerplate be a show-stopper to you?<br>&gt; If so, would you rather see the extension of let bind syntax as default on<br>&gt; for all the types?<br>&gt;<br>&gt; Cheers,<br>&gt; Krzysztof<br>&gt;<br>&gt;<br>&gt; On 7 January 2016 at 07:41:06, Russ Bishop via swift-evolution (<br>&gt; swift-evolution at swift.org) wrote:<br>&gt;<br>&gt; I often want to bind variables to a specific scope, or perhaps I have<br>&gt; three optionals I want to bind and one non-optional. (Often I need that<br>&gt; non-optional value as part of a where condition check but not being able to<br>&gt; bind it means I leak the variable to the outer scope).<br>&gt;<br>&gt; Not being able to bind non-optionals breaks the flow of the code and<br>&gt; forces me to make a minor context switch when it really doesn’t matter, nor<br>&gt; does it aid code clarity.<br>&gt;<br>&gt;<br>&gt; Does anyone have strong thoughts about this? I tried searching the<br>&gt; evolution repo and the mailing list and didn’t see anything.<br>&gt;<br>&gt;<br>&gt; —russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/451fa4e2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d5b4312f2c023d1ec299c30993bf0ac9?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>H2CO3</string> &lt;h2co3 at h2co3.org&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>+1 to that. It&#39;s really useful; I think optional binding is a special case of the more general notion of &quot;bind and check as Boolean&quot;, which is a pattern that comes up everywhere. It&#39;s really more convenient than having to declare another variable in the outer scope (cluttering it).<br></p><p>Sent from my iPad<br></p><p>On 2016. jan. 7., at 7:40, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br></p><p>I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br></p><p>Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.  <br></p><p><br>Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br></p><p><br>—russ<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>+1.<br></p><p>`if let` does two things: 1. unwrap the optional, 2. define a new variable, scoped to the `if` statement.<br></p><p>Sometimes we don’t need the unwrapping, but we’d like the new, temporary, scoped variable.<br></p><p>Gwendal<br></p><p><br>&gt; Le 7 janv. 2016 à 07:40, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br>&gt; <br>&gt; Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.  <br>&gt; <br>&gt; <br>&gt; Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br>&gt; <br>&gt; <br>&gt; —russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>Well, I don&#39;t think it should be universally allowed.<br></p><p>Consider:<br></p><p>    if let value = getValue() {<br>        // do something with value<br>    }<br></p><p>If getValue() returns an optional, this is fine. But if it&#39;s non-optional,<br>then you&#39;ve introduced an &quot;if&quot; when there really is *no* conditional<br>control flow happening. This should still be a compiler error.<br></p><p>It gets trickier when you mix optional and non-optional values:<br></p><p>    if let value1 = somethingOptional(),<br>        let value2 = somethingNonOptional()<br>    {<br>        // should this be allowed?<br>    }<br></p><p><br>    if let value1 = somethingNonOptional(),<br>        let value2 = somethingOptional()<br>    {<br>        // How about this?<br>    }<br></p><p>Here&#39;s an alternative idea: allow non-optional bindings in &quot;do&quot; blocks:<br></p><p>    *do let* value = somethingNonOptional() {<br>        // use value<br>    } // value is out of scope now<br></p><p><br>And perhaps you could combine them with if-statements:<br></p><p>    if let value1 = somethingOptional(),<br>        *do let* value2 = somethingNonOptional()<br>        where value2 &lt; value1<br>    {<br>        // use the values<br>    }<br></p><p><br>Jacob Bandes-Storch<br></p><p>On Thu, Jan 7, 2016 at 10:41 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; +1.<br>&gt;<br>&gt; `if let` does two things: 1. unwrap the optional, 2. define a new<br>&gt; variable, scoped to the `if` statement.<br>&gt;<br>&gt; Sometimes we don’t need the unwrapping, but we’d like the new, temporary,<br>&gt; scoped variable.<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt;<br>&gt; &gt; Le 7 janv. 2016 à 07:40, Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; I often want to bind variables to a specific scope, or perhaps I have<br>&gt; three optionals I want to bind and one non-optional. (Often I need that<br>&gt; non-optional value as part of a where condition check but not being able to<br>&gt; bind it means I leak the variable to the outer scope).<br>&gt; &gt;<br>&gt; &gt; Not being able to bind non-optionals breaks the flow of the code and<br>&gt; forces me to make a minor context switch when it really doesn’t matter, nor<br>&gt; does it aid code clarity.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Does anyone have strong thoughts about this? I tried searching the<br>&gt; evolution repo and the mailing list and didn’t see anything.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; —russ<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/0b4acda5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:59 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;         do let value2 = somethingNonOptional()<br>&gt; <br></p><p>&#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that unconditionally matches anything.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/94e569f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Jan 7, 2016 at 11:02 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 7, 2016, at 10:59 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         *do let* value2 = somethingNonOptional()<br>&gt;<br>&gt;<br>&gt; &#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that<br>&gt; unconditionally matches anything.<br>&gt;<br>&gt; -Joe<br>&gt;<br></p><p>You learn something new every day on this list!<br></p><p>This effectively solves the problems I&#39;ve had. However, I think the<br>resulting code is misleading, because &quot;if case let&quot; or just &quot;case let&quot; look<br>like conditional expressions, when really they aren&#39;t.<br></p><p>    if case let x = somethingNonOptional() {<br>        // use x, *unconditionally*<br>    } // x out of scope now<br></p><p>I think &quot;do let&quot; would improve readability considerably...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/050e8f92/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 7 janv. 2016 à 20:02, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:59 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;         do let value2 = somethingNonOptional()<br>&gt;&gt; <br>&gt; <br>&gt; &#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that unconditionally matches anything.<br>&gt; <br>&gt; -Joe<br></p><p>Well, the compiler complains, and does not provide any nice suggestion.<br></p><p>I, and most code I’ve seen so far (including StackOverflow), solve this issue with an extra variable declared in the outer scope:<br></p><p>	// error<br>	if let x = value...<br>	<br>	// OK<br>	let x = value<br>	if …<br></p><p>Remember the double role of `if let`: 1. unwrap the optional, 2. define a new variable, scoped to the `if` statement. We have 1, but not 2, and this is the gist of this thread.<br></p><p>Gwendal<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/6ed82f62/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>I think you might have misunderstood Joe&#39;s suggestion — it does work for<br>me. Here&#39;s an example:<br></p><p>    if let y = somethingOptional(),<br>        case let x = somethingNonOptional()<br>        where x != y<br>    {<br>        // Rejoice!<br>    }<br></p><p><br>Jacob Bandes-Storch<br></p><p>On Thu, Jan 7, 2016 at 11:07 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; Le 7 janv. 2016 à 20:02, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;<br>&gt;<br>&gt; On Jan 7, 2016, at 10:59 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;         *do let* value2 = somethingNonOptional()<br>&gt;<br>&gt;<br>&gt; &#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that<br>&gt; unconditionally matches anything.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; Well, the compiler complains, and does not provide any nice suggestion.<br>&gt;<br>&gt; I, and most code I’ve seen so far (including StackOverflow), solve this<br>&gt; issue with an extra variable declared in the outer scope:<br>&gt;<br>&gt; // error<br>&gt; if let x = value...<br>&gt; // OK<br>&gt; let x = value<br>&gt; if …<br>&gt;<br>&gt; Remember the double role of `if let`: 1. unwrap the optional, 2. define a<br>&gt; new variable, scoped to the `if` statement. We have 1, but not 2, and this<br>&gt; is the gist of this thread.<br>&gt;<br>&gt; Gwendal<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/e93f4534/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>I see I spoke to soon. Indeed there is a warning &quot;&#39;if&#39; condition is always<br>true&quot; when you use *only* &quot;if case let x = nonOptional()&quot; with no actual<br>conditions. That&#39;s good, but as you said, leaves us without a solution for<br>the original problem (in the case where you&#39;re not trying to mix it with<br>optionals).<br></p><p>As much as I think &quot;do let&quot; makes sense:<br></p><p>    do let x = somethingNonOptional() {<br>        // use x<br>    }<br></p><p>It&#39;s worth pointing out that this works today by just moving the brace<br>around:<br></p><p>    do { let x = somethingNonOptional()<br>        // use x<br>    }<br></p><p>Jacob Bandes-Storch<br></p><p>On Thu, Jan 7, 2016 at 11:08 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>wrote:<br></p><p>&gt; I think you might have misunderstood Joe&#39;s suggestion — it does work for<br>&gt; me. Here&#39;s an example:<br>&gt;<br>&gt;     if let y = somethingOptional(),<br>&gt;         case let x = somethingNonOptional()<br>&gt;         where x != y<br>&gt;     {<br>&gt;         // Rejoice!<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Thu, Jan 7, 2016 at 11:07 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Le 7 janv. 2016 à 20:02, Joe Groff &lt;jgroff at apple.com&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 7, 2016, at 10:59 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         *do let* value2 = somethingNonOptional()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that<br>&gt;&gt; unconditionally matches anything.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, the compiler complains, and does not provide any nice suggestion.<br>&gt;&gt;<br>&gt;&gt; I, and most code I’ve seen so far (including StackOverflow), solve this<br>&gt;&gt; issue with an extra variable declared in the outer scope:<br>&gt;&gt;<br>&gt;&gt; // error<br>&gt;&gt; if let x = value...<br>&gt;&gt; // OK<br>&gt;&gt; let x = value<br>&gt;&gt; if …<br>&gt;&gt;<br>&gt;&gt; Remember the double role of `if let`: 1. unwrap the optional, 2. define a<br>&gt;&gt; new variable, scoped to the `if` statement. We have 1, but not 2, and this<br>&gt;&gt; is the gist of this thread.<br>&gt;&gt;<br>&gt;&gt; Gwendal<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/414f0897/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 7 janv. 2016, at 12:02, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &#39;case let&#39; already works like this, by declaring a pattern &#39;let a&#39; that unconditionally matches anything.<br></p><p>This is an interesting workaround! However, outside of switch statements I don’t think I’ve used a “case let” that made for clear re-reading. Maybe I’m hobbled by switches.<br></p><p>The workaround I’ve used for Russ’s situation is to build a temporary Optional; `case let` hardly helps:<br></p><p>if let x = x, y = Optional(calculate(x, z)) where condition(x, y) { print(x, y) }<br></p><p>if let x = x, case let y = calculate(x, z) where condition(x, y) { print(x, y) }<br></p><p>In any case, I agree with Russ that this variable binding behaviour is an occasional irritant.<br></p><p>Guillaume Lessard<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>That would be fine for me, as long as Xcode suggests adding the missing `do`, or replacing `if` with `do` when I forget one!<br></p><p>Gwendal<br></p><p>&gt; Le 7 janv. 2016 à 19:59, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Well, I don&#39;t think it should be universally allowed.<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt;     if let value = getValue() {<br>&gt;         // do something with value<br>&gt;     }<br>&gt; <br>&gt; If getValue() returns an optional, this is fine. But if it&#39;s non-optional, then you&#39;ve introduced an &quot;if&quot; when there really is no conditional control flow happening. This should still be a compiler error.<br>&gt; <br>&gt; It gets trickier when you mix optional and non-optional values:<br>&gt; <br>&gt;     if let value1 = somethingOptional(),<br>&gt;         let value2 = somethingNonOptional()<br>&gt;     {<br>&gt;         // should this be allowed?<br>&gt;     }<br>&gt; <br>&gt; <br>&gt;     if let value1 = somethingNonOptional(),<br>&gt;         let value2 = somethingOptional()<br>&gt;     {<br>&gt;         // How about this?<br>&gt;     }<br>&gt; <br>&gt; Here&#39;s an alternative idea: allow non-optional bindings in &quot;do&quot; blocks:<br>&gt; <br>&gt;     do let value = somethingNonOptional() {<br>&gt;         // use value<br>&gt;     } // value is out of scope now<br>&gt; <br>&gt; <br>&gt; And perhaps you could combine them with if-statements:<br>&gt; <br>&gt;     if let value1 = somethingOptional(),<br>&gt;         do let value2 = somethingNonOptional()<br>&gt;         where value2 &lt; value1<br>&gt;     {<br>&gt;         // use the values<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 10:41 AM, Gwendal Roué &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1.<br>&gt; <br>&gt; `if let` does two things: 1. unwrap the optional, 2. define a new variable, scoped to the `if` statement.<br>&gt; <br>&gt; Sometimes we don’t need the unwrapping, but we’d like the new, temporary, scoped variable.<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; <br>&gt; &gt; Le 7 janv. 2016 à 07:40, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br>&gt; &gt;<br>&gt; &gt; Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; —russ<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/d853d694/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Allow let binding of non-optionals</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  8, 2016 at 08:00:00am</p></header><div class="content"><p>I think in the second case the compiler could give you a warning.<br></p><p><br>Sent from my iPhone<br></p><p>&gt; On 7 Jan 2016, at 18:59, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, I don&#39;t think it should be universally allowed.<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt;     if let value = getValue() {<br>&gt;         // do something with value<br>&gt;     }<br>&gt; <br>&gt; If getValue() returns an optional, this is fine. But if it&#39;s non-optional, then you&#39;ve introduced an &quot;if&quot; when there really is no conditional control flow happening. This should still be a compiler error.<br>&gt; <br>&gt; It gets trickier when you mix optional and non-optional values:<br>&gt; <br>&gt;     if let value1 = somethingOptional(),<br>&gt;         let value2 = somethingNonOptional()<br>&gt;     {<br>&gt;         // should this be allowed?<br>&gt;     }<br>&gt; <br>&gt; <br>&gt;     if let value1 = somethingNonOptional(),<br>&gt;         let value2 = somethingOptional()<br>&gt;     {<br>&gt;         // How about this?<br>&gt;     }<br>&gt; <br>&gt; Here&#39;s an alternative idea: allow non-optional bindings in &quot;do&quot; blocks:<br>&gt; <br>&gt;     do let value = somethingNonOptional() {<br>&gt;         // use value<br>&gt;     } // value is out of scope now<br>&gt; <br>&gt; <br>&gt; And perhaps you could combine them with if-statements:<br>&gt; <br>&gt;     if let value1 = somethingOptional(),<br>&gt;         do let value2 = somethingNonOptional()<br>&gt;         where value2 &lt; value1<br>&gt;     {<br>&gt;         // use the values<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt;&gt; On Thu, Jan 7, 2016 at 10:41 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1.<br>&gt;&gt; <br>&gt;&gt; `if let` does two things: 1. unwrap the optional, 2. define a new variable, scoped to the `if` statement.<br>&gt;&gt; <br>&gt;&gt; Sometimes we don’t need the unwrapping, but we’d like the new, temporary, scoped variable.<br>&gt;&gt; <br>&gt;&gt; Gwendal<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; Le 7 janv. 2016 à 07:40, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I often want to bind variables to a specific scope, or perhaps I have three optionals I want to bind and one non-optional. (Often I need that non-optional value as part of a where condition check but not being able to bind it means I leak the variable to the outer scope).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Not being able to bind non-optionals breaks the flow of the code and forces me to make a minor context switch when it really doesn’t matter, nor does it aid code clarity.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Does anyone have strong thoughts about this? I tried searching the evolution repo and the mailing list and didn’t see anything.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; —russ<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/d0978243/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
