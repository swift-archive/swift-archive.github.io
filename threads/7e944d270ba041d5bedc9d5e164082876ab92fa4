<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>September 13, 2016 at 04:00:00am</p></header><div class="content"><p>Nick, I like where you’re headed with the instance-methods-as-closures idea.  Here’s where I’m headed with it:<br></p><p>Closures are too often used to write the contents of what should be another function, producing code similar to the “pyramid of doom” avoided by guard.  I now generally write as little code as possible in a closure, and use it merely to dispatch out to a private function as quickly as possible.  This means I really do want classes to reference their own functions.  I look at closures more as providing the captured scope as the &quot;void* context&quot; that goes along with an old C function reference, as opposed to being the scope in which the code should be written.<br></p><p>I loved the “get a closure to implicit self using nothing but the function name” feature of Swift, but after running over a dead line by spending 1.5 days with 3 other developers trying to find a retain cycle caused by its use, we added it to our list of reasons to not merge code, hereafter referred to as “the list&quot;.  This from a guy who used to write flawless manual retain/release code, back in the day.<br></p><p>Incidentally, we also put “unowned&quot; on &quot;the list&quot;.  We always use “weak” instead.  The bottom line is unowned CAN crash, and weak can’t.  There is no way to know if a call to unowned will crash or not.  So we prefer to write code that can’t crash. (No, we don’t force-unwrap weak optionals, “!” is on &quot;the list”, and we nicknamed it the “Russian Roulette operator”)  So instead of “something like [unowned self] syntax...”, I’m suggesting “something like [weak self] syntax...&quot;<br></p><p>So I’d prefer something like “weakself?.functionName” to produce a closure which wraps a weak-self reference and a call to the given method if self isn’t nil.  This seems like a trivial task for the compiler when return types are Void or Optional.  Given the expectations of optional chaining, and the zeroing behavior of any not-owned relationship, I’m not sure it makes sense to demand a non-optional return type for a call to a parent.  So I don’t think such a feature even needs to worry about what if the expected return type isn’t optional.<br></p><p>I’d be happy to see any of the following syntaxes:<br></p><p>weakself.functionName<br>weakself?.functionName<br>?functionName<br>welf.functionName<br>self?.functionName<br>weak(self)?.functionName<br></p><p>Obviously, one work around is to declare a protocol, and pass self, letting the receiving class store a weak reference.  But declaring protocols for every single closure reference is a bit tedious.  Literally just the back and forth on naming them is a waste of time.  And there’s the running joke that we’d just tack “able” on the end of the method name.<br></p><p>Another work around is to create several generic classes which generate closures which weakly capture self and an unapplied method reference, and overloaded functions or operators to provide the correct class.  Unfortunately, this still requires writing “self” explicitly, and also explicitly writing the type of self to obtain an unapplied method reference.<br></p><p>Given our experience, I would consider giving a warning when an implicit-self closure goes into an @escaping context.<br></p><p>	class SomeClass {<br>	var someFunction:(()-&gt;())?<br>	func setup() {<br>		prepare(closure: trigger)	//this should probably be a warning<br>	}<br>	func prepare(closure:@escaping()-&gt;()) {<br>		someFunction = closure<br>	}<br>	func trigger() {<br>	}<br>	}<br></p><p>Self is already required when used inside an closure, for exactly this reason.<br>Perhaps we should require the developer to write explicit “self” or “self?” to indicate strong or weak capture of self.<br>	prepare(closure: self.trigger)	//ok, strong self<br>	prepare(closure: self?.trigger)	//ok, weak self<br>Or if they would like to use unowned, <br>	prepare(closure: RussianRoulette(self).trigger)	// ;-)<br></p><p>In the end, however, closures do occasionally capture non-instance-property scope, which would need to be adapted in the wrapping closure around the call to another method, so the number of no-adapting-needed methods may be quite low.  I expect given current priorities that this wouldn’t make it in to Swift 3.1.  But given the severity of the consequences and the simplicity of the implementation, I would hope it would make it by Swift 4.<br></p><p>-Ben Spratling<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 13, 2016 at 07:00:00pm</p></header><div class="content"><p>Weak references can have a non-trivial amount of overhead in high-performance code. In some cases you can guarantee that a pointer should never be null - and that if it is, a serious logic error has occcurred and you *should* crash.<br>  <br></p><p>  <br>I prefer crashing to running in an inconsistent state. Who knows what can happen in the latter case - data corruption? I&#39;d prefer to crash, get a report and fix the bug.<br>  <br></p><p>  <br>Karl<br>  <br>  <br>   This (https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email)  is how I Email now<br>  <br>  <br>  <br>  <br></p><p>  <br>  <br>&gt;   <br>&gt; On Sep 13, 2016 at 11:07 am,  &lt;Benjamin Spratling via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;  Nick, I like where you’re headed with the instance-methods-as-closures idea. Here’s where I’m headed with it:<br>&gt;<br>&gt; Closures are too often used to write the contents of what should be another function, producing code similar to the “pyramid of doom” avoided by guard. I now generally write as little code as possible in a closure, and use it merely to dispatch out to a private function as quickly as possible. This means I really do want classes to reference their own functions. I look at closures more as providing the captured scope as the &quot;void* context&quot; that goes along with an old C function reference, as opposed to being the scope in which the code should be written.<br>&gt;<br>&gt; I loved the “get a closure to implicit self using nothing but the function name” feature of Swift, but after running over a dead line by spending 1.5 days with 3 other developers trying to find a retain cycle caused by its use, we added it to our list of reasons to not merge code, hereafter referred to as “the list&quot;. This from a guy who used to write flawless manual retain/release code, back in the day.<br>&gt;<br>&gt; Incidentally, we also put “unowned&quot; on &quot;the list&quot;. We always use “weak” instead. The bottom line is unowned CAN crash, and weak can’t. There is no way to know if a call to unowned will crash or not. So we prefer to write code that can’t crash. (No, we don’t force-unwrap weak optionals, “!” is on &quot;the list”, and we nicknamed it the “Russian Roulette operator”) So instead of “something like [unowned self] syntax...”, I’m suggesting “something like [weak self] syntax...&quot;<br>&gt;<br>&gt; So I’d prefer something like “weakself?.functionName” to produce a closure which wraps a weak-self reference and a call to the given method if self isn’t nil. This seems like a trivial task for the compiler when return types are Void or Optional. Given the expectations of optional chaining, and the zeroing behavior of any not-owned relationship, I’m not sure it makes sense to demand a non-optional return type for a call to a parent. So I don’t think such a feature even needs to worry about what if the expected return type isn’t optional.<br>&gt;<br>&gt; I’d be happy to see any of the following syntaxes:<br>&gt;<br>&gt; weakself.functionName<br>&gt; weakself?.functionName<br>&gt; ?functionName<br>&gt; welf.functionName<br>&gt; self?.functionName<br>&gt; weak(self)?.functionName<br>&gt;<br>&gt; Obviously, one work around is to declare a protocol, and pass self, letting the receiving class store a weak reference. But declaring protocols for every single closure reference is a bit tedious. Literally just the back and forth on naming them is a waste of time. And there’s the running joke that we’d just tack “able” on the end of the method name.<br>&gt;<br>&gt; Another work around is to create several generic classes which generate closures which weakly capture self and an unapplied method reference, and overloaded functions or operators to provide the correct class. Unfortunately, this still requires writing “self” explicitly, and also explicitly writing the type of self to obtain an unapplied method reference.<br>&gt;<br>&gt; Given our experience, I would consider giving a warning when an implicit-self closure goes into an @escaping context.<br>&gt;<br>&gt;  class SomeClass {<br>&gt;  var someFunction:(()-&gt;())?<br>&gt;  func setup() {<br>&gt;  prepare(closure: trigger) //this should probably be a warning<br>&gt;  }<br>&gt;  func prepare(closure:@escaping()-&gt;()) {<br>&gt;  someFunction = closure<br>&gt;  }<br>&gt;  func trigger() {<br>&gt;  }<br>&gt;  }<br>&gt;<br>&gt; Self is already required when used inside an closure, for exactly this reason.<br>&gt; Perhaps we should require the developer to write explicit “self” or “self?” to indicate strong or weak capture of self.<br>&gt;  prepare(closure: self.trigger) //ok, strong self<br>&gt;  prepare(closure: self?.trigger) //ok, weak self<br>&gt; Or if they would like to use unowned,  <br>&gt;  prepare(closure: RussianRoulette(self).trigger) // ;-)<br>&gt;<br>&gt; In the end, however, closures do occasionally capture non-instance-property scope, which would need to be adapted in the wrapping closure around the call to another method, so the number of no-adapting-needed methods may be quite low. I expect given current priorities that this wouldn’t make it in to Swift 3.1. But given the severity of the consequences and the simplicity of the implementation, I would hope it would make it by Swift 4.<br>&gt;<br>&gt; -Ben Spratling<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing  list (mailto:listswift-evolution at swift.orghttps)<br>&gt; swift-evolution at swift.org (mailto:listswift-evolution at swift.orghttps)<br>&gt; https (mailto:listswift-evolution at swift.orghttps)://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160913/20d63a9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>September 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Well, then also add an unowned convenience.<br>But I’ve never been handed a story from UX that said, “As a user, when ____ I want the app to crash.”<br>Using weak, the compiler can tell me when I’ve missed a possible case where it’s nil.<br>But the point here is to get closure references that don’t create retain cycles.  Obviously, there’s desire for both weak and unowned variants without the syntactic overhead of a full closure.<br></p><p>&gt; On Sep 13, 2016, at 12:22 PM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; Weak references can have a non-trivial amount of overhead in high-performance code. In some cases you can guarantee that a pointer should never be null - and that if it is, a serious logic error has occcurred and you *should* crash.<br>&gt; <br>&gt; I prefer crashing to running in an inconsistent state. Who knows what can happen in the latter case - data corruption? I&#39;d prefer to crash, get a report and fix the bug.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt; This &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email&gt; is how I Email now<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 13, 2016 at 11:07 am, &lt;Benjamin Spratling via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Nick, I like where you’re headed with the instance-methods-as-closures idea.  Here’s where I’m headed with it:<br>&gt;&gt; <br>&gt;&gt; Closures are too often used to write the contents of what should be another function, producing code similar to the “pyramid of doom” avoided by guard.  I now generally write as little code as possible in a closure, and use it merely to dispatch out to a private function as quickly as possible.  This means I really do want classes to reference their own functions.  I look at closures more as providing the captured scope as the &quot;void* context&quot; that goes along with an old C function reference, as opposed to being the scope in which the code should be written.<br>&gt;&gt; <br>&gt;&gt; I loved the “get a closure to implicit self using nothing but the function name” feature of Swift, but after running over a dead line by spending 1.5 days with 3 other developers trying to find a retain cycle caused by its use, we added it to our list of reasons to not merge code, hereafter referred to as “the list&quot;.  This from a guy who used to write flawless manual retain/release code, back in the day.<br>&gt;&gt; <br>&gt;&gt; Incidentally, we also put “unowned&quot; on &quot;the list&quot;.  We always use “weak” instead.  The bottom line is unowned CAN crash, and weak can’t.  There is no way to know if a call to unowned will crash or not.  So we prefer to write code that can’t crash. (No, we don’t force-unwrap weak optionals, “!” is on &quot;the list”, and we nicknamed it the “Russian Roulette operator”)  So instead of “something like [unowned self] syntax...”, I’m suggesting “something like [weak self] syntax...&quot;<br>&gt;&gt; <br>&gt;&gt; So I’d prefer something like “weakself?.functionName” to produce a closure which wraps a weak-self reference and a call to the given method if self isn’t nil.  This seems like a trivial task for the compiler when return types are Void or Optional.  Given the expectations of optional chaining, and the zeroing behavior of any not-owned relationship, I’m not sure it makes sense to demand a non-optional return type for a call to a parent.  So I don’t think such a feature even needs to worry about what if the expected return type isn’t optional.<br>&gt;&gt; <br>&gt;&gt; I’d be happy to see any of the following syntaxes:<br>&gt;&gt; <br>&gt;&gt; weakself.functionName<br>&gt;&gt; weakself?.functionName<br>&gt;&gt; ?functionName<br>&gt;&gt; welf.functionName<br>&gt;&gt; self?.functionName<br>&gt;&gt; weak(self)?.functionName<br>&gt;&gt; <br>&gt;&gt; Obviously, one work around is to declare a protocol, and pass self, letting the receiving class store a weak reference.  But declaring protocols for every single closure reference is a bit tedious.  Literally just the back and forth on naming them is a waste of time.  And there’s the running joke that we’d just tack “able” on the end of the method name.<br>&gt;&gt; <br>&gt;&gt; Another work around is to create several generic classes which generate closures which weakly capture self and an unapplied method reference, and overloaded functions or operators to provide the correct class.  Unfortunately, this still requires writing “self” explicitly, and also explicitly writing the type of self to obtain an unapplied method reference.<br>&gt;&gt; <br>&gt;&gt; Given our experience, I would consider giving a warning when an implicit-self closure goes into an @escaping context.<br>&gt;&gt; <br>&gt;&gt; 	class SomeClass {<br>&gt;&gt; 	var someFunction:(()-&gt;())?<br>&gt;&gt; 	func setup() {<br>&gt;&gt; 		prepare(closure: trigger)	//this should probably be a warning<br>&gt;&gt; 	}<br>&gt;&gt; 	func prepare(closure:@escaping()-&gt;()) {<br>&gt;&gt; 		someFunction = closure<br>&gt;&gt; 	}<br>&gt;&gt; 	func trigger() {<br>&gt;&gt; 	}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Self is already required when used inside an closure, for exactly this reason.<br>&gt;&gt; Perhaps we should require the developer to write explicit “self” or “self?” to indicate strong or weak capture of self.<br>&gt;&gt; 	prepare(closure: self.trigger)	//ok, strong self<br>&gt;&gt; 	prepare(closure: self?.trigger)	//ok, weak self<br>&gt;&gt; Or if they would like to use unowned, <br>&gt;&gt; 	prepare(closure: RussianRoulette(self).trigger)	// ;-)<br>&gt;&gt; <br>&gt;&gt; In the end, however, closures do occasionally capture non-instance-property scope, which would need to be adapted in the wrapping closure around the call to another method, so the number of no-adapting-needed methods may be quite low.  I expect given current priorities that this wouldn’t make it in to Swift 3.1.  But given the severity of the consequences and the simplicity of the implementation, I would hope it would make it by Swift 4.<br>&gt;&gt; <br>&gt;&gt; -Ben Spratling<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list &lt;mailto:listswift-evolution at swift.orghttps&gt;<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:listswift-evolution at swift.orghttps&gt;<br>&gt;&gt; https &lt;mailto:listswift-evolution at swift.orghttps&gt;://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160913/32163906/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>September 13, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 13, 2016, at 10:29 AM, Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, then also add an unowned convenience.<br>&gt; But I’ve never been handed a story from UX that said, “As a user, when ____ I want the app to crash.”<br>&gt; Using weak, the compiler can tell me when I’ve missed a possible case where it’s nil.<br></p><p>Honestly, I’d be fine with / prefer only allowing unowned (at all) if it’s @noescape, if that, requiring strong or weak for anything that escapes. That seems to go along with swift’s emphasis on safety. <br></p><p>&gt; But the point here is to get closure references that don’t create retain cycles.  Obviously, there’s desire for both weak and unowned variants without the syntactic overhead of a full closure.<br>&gt; <br>&gt;&gt; On Sep 13, 2016, at 12:22 PM, Karl Wagner &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Weak references can have a non-trivial amount of overhead in high-performance code. In some cases you can guarantee that a pointer should never be null - and that if it is, a serious logic error has occcurred and you *should* crash.<br>&gt;&gt; <br>&gt;&gt; I prefer crashing to running in an inconsistent state. Who knows what can happen in the latter case - data corruption? I&#39;d prefer to crash, get a report and fix the bug.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; This &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email&gt; is how I Email now<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 13, 2016 at 11:07 am, &lt;Benjamin Spratling via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nick, I like where you’re headed with the instance-methods-as-closures idea.  Here’s where I’m headed with it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Closures are too often used to write the contents of what should be another function, producing code similar to the “pyramid of doom” avoided by guard.  I now generally write as little code as possible in a closure, and use it merely to dispatch out to a private function as quickly as possible.  This means I really do want classes to reference their own functions.  I look at closures more as providing the captured scope as the &quot;void* context&quot; that goes along with an old C function reference, as opposed to being the scope in which the code should be written.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I loved the “get a closure to implicit self using nothing but the function name” feature of Swift, but after running over a dead line by spending 1.5 days with 3 other developers trying to find a retain cycle caused by its use, we added it to our list of reasons to not merge code, hereafter referred to as “the list&quot;.  This from a guy who used to write flawless manual retain/release code, back in the day.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incidentally, we also put “unowned&quot; on &quot;the list&quot;.  We always use “weak” instead.  The bottom line is unowned CAN crash, and weak can’t.  There is no way to know if a call to unowned will crash or not.  So we prefer to write code that can’t crash. (No, we don’t force-unwrap weak optionals, “!” is on &quot;the list”, and we nicknamed it the “Russian Roulette operator”)  So instead of “something like [unowned self] syntax...”, I’m suggesting “something like [weak self] syntax...&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I’d prefer something like “weakself?.functionName” to produce a closure which wraps a weak-self reference and a call to the given method if self isn’t nil.  This seems like a trivial task for the compiler when return types are Void or Optional.  Given the expectations of optional chaining, and the zeroing behavior of any not-owned relationship, I’m not sure it makes sense to demand a non-optional return type for a call to a parent.  So I don’t think such a feature even needs to worry about what if the expected return type isn’t optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be happy to see any of the following syntaxes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; weakself.functionName<br>&gt;&gt;&gt; weakself?.functionName<br>&gt;&gt;&gt; ?functionName<br>&gt;&gt;&gt; welf.functionName<br>&gt;&gt;&gt; self?.functionName<br>&gt;&gt;&gt; weak(self)?.functionName<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously, one work around is to declare a protocol, and pass self, letting the receiving class store a weak reference.  But declaring protocols for every single closure reference is a bit tedious.  Literally just the back and forth on naming them is a waste of time.  And there’s the running joke that we’d just tack “able” on the end of the method name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another work around is to create several generic classes which generate closures which weakly capture self and an unapplied method reference, and overloaded functions or operators to provide the correct class.  Unfortunately, this still requires writing “self” explicitly, and also explicitly writing the type of self to obtain an unapplied method reference.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given our experience, I would consider giving a warning when an implicit-self closure goes into an @escaping context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	class SomeClass {<br>&gt;&gt;&gt; 	var someFunction:(()-&gt;())?<br>&gt;&gt;&gt; 	func setup() {<br>&gt;&gt;&gt; 		prepare(closure: trigger)	//this should probably be a warning<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	func prepare(closure:@escaping()-&gt;()) {<br>&gt;&gt;&gt; 		someFunction = closure<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	func trigger() {<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self is already required when used inside an closure, for exactly this reason.<br>&gt;&gt;&gt; Perhaps we should require the developer to write explicit “self” or “self?” to indicate strong or weak capture of self.<br>&gt;&gt;&gt; 	prepare(closure: self.trigger)	//ok, strong self<br>&gt;&gt;&gt; 	prepare(closure: self?.trigger)	//ok, weak self<br>&gt;&gt;&gt; Or if they would like to use unowned, <br>&gt;&gt;&gt; 	prepare(closure: RussianRoulette(self).trigger)	// ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the end, however, closures do occasionally capture non-instance-property scope, which would need to be adapted in the wrapping closure around the call to another method, so the number of no-adapting-needed methods may be quite low.  I expect given current priorities that this wouldn’t make it in to Swift 3.1.  But given the severity of the consequences and the simplicity of the implementation, I would hope it would make it by Swift 4.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Ben Spratling<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list &lt;mailto:listswift-evolution at swift.orghttps&gt;<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:listswift-evolution at swift.orghttps&gt;<br>&gt;&gt;&gt; https &lt;mailto:listswift-evolution at swift.orghttps&gt;://lists.swift.org/mailman/listinfo/swift-evolution &lt;http://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160913/b8abae1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>September 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Going along with the &quot;self.&quot; / &quot;self?.&quot; from my previous message, perhaps &quot;self!.&quot; For unowned?<br></p><p>That said, if there were only an unowned convenience, I would not use it.  I&#39;m not going to have that debate here, since I think the value of &quot;weak&quot; is obvious to most developers.<br></p><p>Sent from my iPad<br></p><p>&gt; On Sep 13, 2016, at 12:38 PM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 13, 2016, at 10:29 AM, Benjamin Spratling via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, then also add an unowned convenience.<br>&gt;&gt; But I’ve never been handed a story from UX that said, “As a user, when ____ I want the app to crash.”<br>&gt;&gt; Using weak, the compiler can tell me when I’ve missed a possible case where it’s nil.<br>&gt; <br>&gt; Honestly, I’d be fine with / prefer only allowing unowned (at all) if it’s @noescape, if that, requiring strong or weak for anything that escapes. That seems to go along with swift’s emphasis on safety. <br>&gt; <br>&gt;&gt; But the point here is to get closure references that don’t create retain cycles.  Obviously, there’s desire for both weak and unowned variants without the syntactic overhead of a full closure.<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 13, 2016, at 12:22 PM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Weak references can have a non-trivial amount of overhead in high-performance code. In some cases you can guarantee that a pointer should never be null - and that if it is, a serious logic error has occcurred and you *should* crash.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I prefer crashing to running in an inconsistent state. Who knows what can happen in the latter case - data corruption? I&#39;d prefer to crash, get a report and fix the bug.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is how I Email now<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 13, 2016 at 11:07 am, &lt;Benjamin Spratling via swift-evolution&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nick, I like where you’re headed with the instance-methods-as-closures idea.  Here’s where I’m headed with it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Closures are too often used to write the contents of what should be another function, producing code similar to the “pyramid of doom” avoided by guard.  I now generally write as little code as possible in a closure, and use it merely to dispatch out to a private function as quickly as possible.  This means I really do want classes to reference their own functions.  I look at closures more as providing the captured scope as the &quot;void* context&quot; that goes along with an old C function reference, as opposed to being the scope in which the code should be written.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I loved the “get a closure to implicit self using nothing but the function name” feature of Swift, but after running over a dead line by spending 1.5 days with 3 other developers trying to find a retain cycle caused by its use, we added it to our list of reasons to not merge code, hereafter referred to as “the list&quot;.  This from a guy who used to write flawless manual retain/release code, back in the day.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Incidentally, we also put “unowned&quot; on &quot;the list&quot;.  We always use “weak” instead.  The bottom line is unowned CAN crash, and weak can’t.  There is no way to know if a call to unowned will crash or not.  So we prefer to write code that can’t crash. (No, we don’t force-unwrap weak optionals, “!” is on &quot;the list”, and we nicknamed it the “Russian Roulette operator”)  So instead of “something like [unowned self] syntax...”, I’m suggesting “something like [weak self] syntax...&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I’d prefer something like “weakself?.functionName” to produce a closure which wraps a weak-self reference and a call to the given method if self isn’t nil.  This seems like a trivial task for the compiler when return types are Void or Optional.  Given the expectations of optional chaining, and the zeroing behavior of any not-owned relationship, I’m not sure it makes sense to demand a non-optional return type for a call to a parent.  So I don’t think such a feature even needs to worry about what if the expected return type isn’t optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d be happy to see any of the following syntaxes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; weakself.functionName<br>&gt;&gt;&gt;&gt; weakself?.functionName<br>&gt;&gt;&gt;&gt; ?functionName<br>&gt;&gt;&gt;&gt; welf.functionName<br>&gt;&gt;&gt;&gt; self?.functionName<br>&gt;&gt;&gt;&gt; weak(self)?.functionName<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obviously, one work around is to declare a protocol, and pass self, letting the receiving class store a weak reference.  But declaring protocols for every single closure reference is a bit tedious.  Literally just the back and forth on naming them is a waste of time.  And there’s the running joke that we’d just tack “able” on the end of the method name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another work around is to create several generic classes which generate closures which weakly capture self and an unapplied method reference, and overloaded functions or operators to provide the correct class.  Unfortunately, this still requires writing “self” explicitly, and also explicitly writing the type of self to obtain an unapplied method reference.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given our experience, I would consider giving a warning when an implicit-self closure goes into an @escaping context.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	class SomeClass {<br>&gt;&gt;&gt;&gt; 	var someFunction:(()-&gt;())?<br>&gt;&gt;&gt;&gt; 	func setup() {<br>&gt;&gt;&gt;&gt; 		prepare(closure: trigger)	//this should probably be a warning<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; 	func prepare(closure:@escaping()-&gt;()) {<br>&gt;&gt;&gt;&gt; 		someFunction = closure<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; 	func trigger() {<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Self is already required when used inside an closure, for exactly this reason.<br>&gt;&gt;&gt;&gt; Perhaps we should require the developer to write explicit “self” or “self?” to indicate strong or weak capture of self.<br>&gt;&gt;&gt;&gt; 	prepare(closure: self.trigger)	//ok, strong self<br>&gt;&gt;&gt;&gt; 	prepare(closure: self?.trigger)	//ok, weak self<br>&gt;&gt;&gt;&gt; Or if they would like to use unowned, <br>&gt;&gt;&gt;&gt; 	prepare(closure: RussianRoulette(self).trigger)	// ;-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the end, however, closures do occasionally capture non-instance-property scope, which would need to be adapted in the wrapping closure around the call to another method, so the number of no-adapting-needed methods may be quite low.  I expect given current priorities that this wouldn’t make it in to Swift 3.1.  But given the severity of the consequences and the simplicity of the implementation, I would hope it would make it by Swift 4.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Ben Spratling<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160913/82e7eca4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 14, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; Honestly, I’d be fine with / prefer only allowing unowned (at all) if it’s @noescape, if that, requiring strong or weak for anything that escapes. That seems to go along with swift’s emphasis on safety. <br>What?!?!! That&#39;s an extraordinary thing to say.<br>I don&#39;t think you understand what autozeroing weak references are for. They are not there so that you can have gaps in your reasoning of your code, or to allow undefined behaviour. They exist so that you can have a non-retaining pointer (I.e. Unowned), where the pointee&#39;s lifetime is independent of the reference. So when the pointee does deallocate at some unknown time, the pointer reverts to nil doesn&#39;t just dangle in to invalid memory.<br>Let&#39;s say I have some reusable functionality, like an input handler for text-processing events with a particular behaviour (maybe it does some validation or something, it&#39;s not important). I can encapsulate that as a class (maybe it can&#39;t be a struct, that&#39;s my business. Maybe it has specialised subclasses or requires identity). Now I have my UIViewController, I create and retain an instance of that class, but the object needs to dispatch events back to the UIVC so it needs a non-strong pointer to its parent.<br>The parent and child have coupled lifetimes. There will never be an orphaned child; and if there is, and it&#39;s handling events and dispatching them nowhere, that&#39;s a serious flaw in the application logic. Of course users don&#39;t want applications to crash, but developers do! When there are failures in the application logic, I want them to be loud and obvious. Otherwise, we might as well remove all preconditions as other runtime assertions as well.<br>Some of the comments here about unowned references are scary; you should always understand your application logic, and use of unowned pointers is completely safe if you do. If you&#39;re using weak references as a shorthand for a lack of understanding of your own code, you have a bigger problem than an esoteric crashing bug.<br>It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works.<br>	<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160914/7f6a31b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 14, 2016 at 12:00:00am</p></header><div class="content"><p>On Tue, Sep 13, 2016 at 10:29 PM, Karl Wagner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Honestly, I’d be fine with / prefer only allowing unowned (at all) if<br>&gt; it’s @noescape, if that, requiring strong or weak for anything that<br>&gt; escapes. That seems to go along with swift’s emphasis on safety.<br>&gt;<br>&gt; What?!?!! That&#39;s an extraordinary thing to say.<br>&gt;<br>&gt; I don&#39;t think you understand what autozeroing weak references are for.<br>&gt; They are *not* there so that you can have gaps in your reasoning of your<br>&gt; code, or to allow undefined behaviour. They exist so that you can have a<br>&gt; non-retaining pointer (I.e. Unowned), where the pointee&#39;s lifetime is<br>&gt; independent of the reference. So when the pointee does deallocate at some<br>&gt; unknown time, the pointer reverts to nil doesn&#39;t just dangle in to invalid<br>&gt; memory.<br>&gt;<br>&gt; Let&#39;s say I have some reusable functionality, like an input handler for<br>&gt; text-processing events with a particular behaviour (maybe it does some<br>&gt; validation or something, it&#39;s not important). I can encapsulate that as a<br>&gt; class (maybe it can&#39;t be a struct, that&#39;s my business. Maybe it has<br>&gt; specialised subclasses or requires identity). Now I have my<br>&gt; UIViewController, I create and retain an instance of that class, but the<br>&gt; object needs to dispatch events back to the UIVC so it needs a non-strong<br>&gt; pointer to its parent.<br>&gt;<br>&gt; The parent and child have coupled lifetimes. There will never be an<br>&gt; orphaned child; and if there is, and it&#39;s handling events and dispatching<br>&gt; them nowhere, that&#39;s a serious flaw in the application logic. Of course<br>&gt; users don&#39;t want applications to crash, but developers do! When there are<br>&gt; failures in the application logic, I want them to be loud and obvious.<br>&gt; Otherwise, we might as well remove all preconditions as other runtime<br>&gt; assertions as well.<br>&gt;<br>&gt; Some of the comments here about unowned references are scary; you should<br>&gt; always understand your application logic, and use of unowned pointers is<br>&gt; completely safe if you do. If you&#39;re using weak references as a shorthand<br>&gt; for a lack of understanding of your own code, you have a bigger problem<br>&gt; than an esoteric crashing bug.<br>&gt;<br>&gt; It&#39;s similar to Linus&#39; argument against using kernel debuggers (<br>&gt; https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at<br>&gt; a level above the source, and being careful, make you a better developer.<br>&gt; There are no features in swift which compensate for a lack of understanding<br>&gt; about how your code works.<br>&gt;<br></p><p>That&#39;s a great explanation. I wish I had more time so that I could search<br>for posts from core team members that can elaborate on this point much<br>better than I could. But the gist of it, as I understand it, is that<br>trapping is safe, while proceeding despite an unexpected flaw in memory<br>handling is unsafe, and Swift chooses safety. This is part of the reasoning<br>behind why, for instance, &quot;lenient&quot; array indexing is on the<br>commonly-rejected proposals list.<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160914/c9f024de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 13, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Sep 13, 2016, at 22:34 , Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works.<br></p><p>Get off my lawn!<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Sorry to hijack the thread, but I was working to fix the fact that we can&#39;t have optional unowned pointers in swift and Jordan said he didn&#39;t think anybody ever asked for it before. It made me worry about the kind of practices swift is encouraging.<br> <br></p><p> <br>The overhead of using weak pointers isn&#39;t massive, but it involves locking and updating global tables (http://stackoverflow.com/questions/23689155/lots-of-overhead-for-weak-property). Unowned pointers don&#39;t have this overhead, and can also help you detect errors because they are fail-deadly.<br> <br> <br> <br> But yeah, I&#39;d like to be able to reference non-owning instance methods.<br> <br></p><p> <br>   This (https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email)  is how I Email now<br> <br> <br> <br> <br></p><p> <br> <br>&gt;  <br>&gt; On Sep 14, 2016 at 7:45 am,  &lt;Rick Mann (mailto:rmann at latencyzero.com)&gt;  wrote:<br>&gt;  <br>&gt;  <br>&gt;  <br>&gt;  <br>&gt; &gt;  On Sep 13, 2016, at 22:34 , Xiaodi Wu via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote: <br>&gt; &gt;  <br>&gt; &gt;  It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works. <br>&gt;<br>&gt; Get off my lawn! <br>&gt;<br>&gt;<br>&gt; -- <br>&gt; Rick Mann <br>&gt; rmann at latencyzero.com (mailto:rmann at latencyzero.com)  <br>&gt;<br>&gt;<br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160914/e85bb8a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>September 14, 2016 at 10:00:00am</p></header><div class="content"><p>How do you figure unowned pointers help you detect errors? Dangling<br>pointers give you no guarantees.<br></p><p>On Wednesday, September 14, 2016, Karl Wagner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry to hijack the thread, but I was working to fix the fact that we<br>&gt; can&#39;t have optional unowned pointers in swift and Jordan said he didn&#39;t<br>&gt; think anybody ever asked for it before. It made me worry about the kind of<br>&gt; practices swift is encouraging.<br>&gt;<br>&gt; The overhead of using weak pointers isn&#39;t massive, but it involves locking<br>&gt; and updating global tables (http://stackoverflow.com/<br>&gt; questions/23689155/lots-of-overhead-for-weak-property). Unowned pointers<br>&gt; don&#39;t have this overhead, and can also help you detect errors because they<br>&gt; are fail-deadly.<br>&gt;<br>&gt; But yeah, I&#39;d like to be able to reference non-owning instance methods.<br>&gt;<br>&gt; This<br>&gt; &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email&gt;<br>&gt; is how I Email now<br>&gt;<br>&gt;<br>&gt; On Sep 14, 2016 at 7:45 am, &lt;Rick Mann<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rmann at latencyzero.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; &gt; On Sep 13, 2016, at 22:34 , Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works.<br>&gt;<br>&gt; Get off my lawn!<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rmann at latencyzero.com&#39;);&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160914/4ef86696/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Unowned pointers aren&#39;t dangling in debug builds; they&#39;re more like zombie-detection, where you get a deterministic trap if you access them after the original instance is strong-released for the last time. I can&#39;t remember if this is enabled in release builds as well; under -Ounchecked they do become unsafe-unretained.<br></p><p>Jordan<br></p><p><br>&gt; On Sep 14, 2016, at 10:51, Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How do you figure unowned pointers help you detect errors? Dangling pointers give you no guarantees.<br>&gt; <br>&gt; On Wednesday, September 14, 2016, Karl Wagner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Sorry to hijack the thread, but I was working to fix the fact that we can&#39;t have optional unowned pointers in swift and Jordan said he didn&#39;t think anybody ever asked for it before. It made me worry about the kind of practices swift is encouraging.<br>&gt; <br>&gt; The overhead of using weak pointers isn&#39;t massive, but it involves locking and updating global tables (http://stackoverflow.com/questions/23689155/lots-of-overhead-for-weak-property &lt;http://stackoverflow.com/questions/23689155/lots-of-overhead-for-weak-property&gt;). Unowned pointers don&#39;t have this overhead, and can also help you detect errors because they are fail-deadly.<br>&gt; <br>&gt; But yeah, I&#39;d like to be able to reference non-owning instance methods.<br>&gt; <br>&gt; This &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email&gt; is how I Email now<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 14, 2016 at 7:45 am, &lt;Rick Mann &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rmann at latencyzero.com&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Sep 13, 2016, at 22:34 , Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;  <br>&gt;&gt; <br>&gt;&gt; &gt; It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3 &lt;https://lwn.net/2000/0914/a/lt-debugger.php3&gt;). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Get off my lawn!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --  <br>&gt;&gt; <br>&gt;&gt; Rick Mann<br>&gt;&gt; <br>&gt;&gt; rmann at latencyzero.com &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;rmann at latencyzero.com&#39;);&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160915/b3703aa0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>Add something like [unowned self] syntax for passing instance methods into closure parameters without creating retain cycles</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>September 15, 2016 at 02:00:00pm</p></header><div class="content"><p>Oh. That&#39;s great. Very useful. Thanks for the info.<br></p><p>On Thursday, September 15, 2016, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Unowned pointers aren&#39;t dangling in debug builds; they&#39;re more like<br>&gt; zombie-detection, where you get a deterministic trap if you access them<br>&gt; after the original instance is strong-released for the last time. I can&#39;t<br>&gt; remember if this is enabled in release builds as well; under -Ounchecked<br>&gt; they do become unsafe-unretained.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Sep 14, 2016, at 10:51, Callionica (Swift) via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; How do you figure unowned pointers help you detect errors? Dangling<br>&gt; pointers give you no guarantees.<br>&gt;<br>&gt; On Wednesday, September 14, 2016, Karl Wagner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Sorry to hijack the thread, but I was working to fix the fact that we<br>&gt;&gt; can&#39;t have optional unowned pointers in swift and Jordan said he didn&#39;t<br>&gt;&gt; think anybody ever asked for it before. It made me worry about the kind of<br>&gt;&gt; practices swift is encouraging.<br>&gt;&gt;<br>&gt;&gt; The overhead of using weak pointers isn&#39;t massive, but it involves<br>&gt;&gt; locking and updating global tables (http://stackoverflow.com/ques<br>&gt;&gt; tions/23689155/lots-of-overhead-for-weak-property). Unowned pointers<br>&gt;&gt; don&#39;t have this overhead, and can also help you detect errors because they<br>&gt;&gt; are fail-deadly.<br>&gt;&gt;<br>&gt;&gt; But yeah, I&#39;d like to be able to reference non-owning instance methods.<br>&gt;&gt;<br>&gt;&gt; This<br>&gt;&gt; &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=how_i_email&gt;<br>&gt;&gt; is how I Email now<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 14, 2016 at 7:45 am, &lt;Rick Mann&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sep 13, 2016, at 22:34 , Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It&#39;s similar to Linus&#39; argument against using kernel debuggers (https://lwn.net/2000/0914/a/lt-debugger.php3). Understanding your code at a level above the source, and being careful, make you a better developer. There are no features in swift which compensate for a lack of understanding about how your code works.<br>&gt;&gt;<br>&gt;&gt; Get off my lawn!<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Rick Mann<br>&gt;&gt; rmann at latencyzero.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160915/2bc8e45a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
