<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0118: Closure Parameter Names and Labels&quot; begins now and runs through July 11. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On 06.07.2016 2:10, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0118: Closure Parameter Names and Labels&quot; begins now and runs through July 11. The proposal is available here:<br> &gt; ..<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Strong +1, more compact labels with clear meaning<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read proposal, read discussion in list<br></p><p>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br></p><p>+1. These look like good improvements to me. (I&#39;m also happy that the map/filter/reduce naming was left out of this proposal)<br></p><p>One thing I was wonder about was the capitalization of UTF8 in the first example. Shouldn&#39;t that be s.withUTF8Buffer(processBytes)instead of s.withUtf8Buffer(processBytes) or am I confusing Swift&#39;s conventions with Cocoa&#39;s?<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Inconsistency at this point in Swifts evolution should be dealt with.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. These proposed labels help the call site read better as a sentence.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Not applicable<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>Quick reading of the proposal. Followed some of the discussion.<br></p><p>- David<br></p><p>&gt; On 6 Jul 2016, at 01:10, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0118: Closure Parameter Names and Labels&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/629b0c85/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  7, 2016 at 09:00:00am</p></header><div class="content"><p>On Jul 5, 2016, at 5:10 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0118: Closure Parameter Names and Labels&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br></p><p>I like the overall thoughtful and generally  succinct results. I participated in the renaming thread and believe this will improve the affected APIs.<br></p><p>My one concern lies with &quot;ManagedBuffer&lt;Header,Element&gt;.create( minimumCapacity: 10,  makingValueWith: makeHeader)&quot;, which should either be &quot;makingHeaderWith&quot; or (better yet) &quot;with&quot;.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1. Cleans things up a bit. I particularly like that the new names tend to be shorter.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Sure, it doesn’t hurt and it tidies things up quite nicely.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so. It removes verbosity but doesn’t lose clarity.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Doesn’t really apply. We’re talking about Swift; this feels closer to what Swift’s own standard library should look like.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the review, participated in the initial review on GitHub and earlier discussions so I was already familiar with it.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  7, 2016 at 04:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md ]<br></p><p>Hi, Dave, Dmitri, Max. Sorry I didn’t make the pre-review commentary thread. I find I’m still not happy with several of these names, although there are many other improvements. Stepping back, I think the Swift API guidelines just don’t do a good job with closure parameters. We should have naming guidelines for strategy closures and for callbacks.<br></p><p><br>lines.split(whereSeparator: isAllWhitespace)<br></p><p>This reads like an English sentence, but it doesn’t have the correct meaning for me. This implies a structure that has a pre-existing “separator&quot;, and checks if that separator matches the predicate, rather than searching for an element that matches the predicate, and splitting on that. I realize that the former reading doesn’t make much sense as a function, but it’s still impeded my understanding more than helping it along.<br></p><p>Alternate suggestions: split(where:), split(separatingWhere:).<br></p><p><br>The sort(by:) family<br></p><p>…seems fine, is slightly confusable with a “sort by key” API, but at least has a different type signature.<br></p><p><br>if roots.contains(where: isPrime) {<br></p><p>I really don’t like this one; it feels like it’s missing a noun. It certainly isn’t a valid English phrase. If we were naming an intersects(_:)-like feature, we might call it `roots.containsAny(of: primes)` or `roots.contains(anyOf: primes)`.<br></p><p>Alternate suggestions: containsAny(where:), contains(anyWhere:)<br></p><p><br>if expected.elementsEqual(actual, by: haveSameValue)<br></p><p>I tend to agree with the pre-review commentary &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22188&gt; that “by:” doesn’t actually fit here. The difference between elementsEqual(_:by:) / starts(with:by:) and the sort(by:) family is that “sort by…” and “order by…” are both things people actually say, but “equal by…” is not. Then again, when they say those things, they’re either talking about a key (“sort by name”) or a general comparison (“sort by compar[ing] names”, &lt;=&gt; rather than &lt;).<br></p><p><br>let sum = measurements.reduce(0, +)<br></p><p>It concerns me that we can’t think of a label for this operation; it implies we can’t think of an English sentence to describe it. “Reduce this collection to a single element by combining using +.” reduce(startingWith:combiningWith:) is pretty unwieldy, though.<br></p><p><br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/5152fd2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  7, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 5:03 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md&gt; ]<br>&gt; <br>&gt; Hi, Dave, Dmitri, Max. Sorry I didn’t make the pre-review commentary thread. I find I’m still not happy with several of these names, although there are many other improvements. Stepping back, I think the Swift API guidelines just don’t do a good job with closure parameters. We should have naming guidelines for strategy closures and for callbacks.<br>&gt; <br>&gt; <br>&gt; lines.split(whereSeparator: isAllWhitespace)<br>&gt; <br>&gt; This reads like an English sentence, but it doesn’t have the correct meaning for me. This implies a structure that has a pre-existing “separator&quot;, and checks if that separator matches the predicate, rather than searching for an element that matches the predicate, and splitting on that. I realize that the former reading doesn’t make much sense as a function, but it’s still impeded my understanding more than helping it along.<br>&gt; <br>&gt; Alternate suggestions: split(where:), split(separatingWhere:).<br></p><p>I think split(where:) is the cleaner and more elegant choice. <br></p><p>(But get ready, I&#39;m about to defend Dave A&#39;s decisions from here forward)<br></p><p>&gt; <br>&gt; <br>&gt; The sort(by:) family<br>&gt; <br>&gt; …seems fine, is slightly confusable with a “sort by key” API, but at least has a different type signature.<br></p><p>The obvious choices are `by`, `where`, and `with` but I like `by`. It tells the <br>story that this is a closure that&#39;s going to do the donkey&#39;s work for the sort.<br></p><p><br>&gt; if roots.contains(where: isPrime) {<br>&gt; <br>&gt; I really don’t like this one; it feels like it’s missing a noun. It certainly isn’t a valid English phrase. If we were naming an intersects(_:)-like feature, we might call it `roots.containsAny(of: primes)` or `roots.contains(anyOf: primes)`.<br></p><p>This isn&#39;t perfect but it&#39;s a lot cleaner than a lot of the alternatives that came up<br>in discussion. I&#39;m happy with this one too. It differentiates contains(_:) from <br>contains(where:) and describes what the param does. I think it&#39;s solid enough<br>to hold its weight in the language.<br></p><p>&gt; Alternate suggestions: containsAny(where:), contains(anyWhere:)<br></p><p>Let me point out that &quot;anywhere&quot; jumps out, taking away from any positives this <br>would add. I get your point, but once you see &quot;anywhere&quot;, you can&#39;t unsee it.<br></p><p>&gt; if expected.elementsEqual(actual, by: haveSameValue)<br></p><p>I&#39;m okay with `by`. I&#39;m okay with `where`. But I think `by` is better in this <br>case because you&#39;re doing something to figure out. <br></p><p>&gt; <br>&gt; I tend to agree with the pre-review commentary &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22188&gt; that “by:” doesn’t actually fit here. The difference between elementsEqual(_:by:) / starts(with:by:) and the sort(by:) family is that “sort by…” and “order by…” are both things people actually say, but “equal by…” is not. Then again, when they say those things, they’re either talking about a key (“sort by name”) or a general comparison (“sort by compar[ing] names”, &lt;=&gt; rather than &lt;).<br></p><p>But you do say &quot;equate by&quot;<br></p><p>&gt; let sum = measurements.reduce(0, +)<br>&gt; <br>&gt; It concerns me that we can’t think of a label for this operation; it implies we can’t think of an English sentence to describe it. “Reduce this collection to a single element by combining using +.” reduce(startingWith:combiningWith:) is pretty unwieldy, though.<br></p><p>This is short, sweet, and beautiful, lending itself to simple operators. When a <br>more complex routine is needed, it&#39;s perfect for trailing closures. I think it&#39;s a<br>great choice.<br></p><p>-- E, really positive about this proposal<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/5224b396/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>on Thu Jul 07 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md ]<br>&gt;<br>&gt; Hi, Dave, Dmitri, Max. Sorry I didn’t make the pre-review commentary<br>&gt; thread. I find I’m still not happy with several of these names,<br>&gt; although there are many other improvements. Stepping back, I think the<br>&gt; Swift API guidelines just don’t do a good job with closure<br>&gt; parameters. We should have naming guidelines for strategy closures and<br>&gt; for callbacks.<br>&gt;<br>&gt; lines.split(whereSeparator: isAllWhitespace)<br>&gt;<br>&gt; This reads like an English sentence, but it doesn’t have the correct<br>&gt; meaning for me. This implies a structure that has a pre-existing<br>&gt; “separator&quot;, and checks if that separator matches the predicate,<br>&gt; rather than searching for an element that matches the predicate, and<br>&gt; splitting on that. I realize that the former reading doesn’t make much<br>&gt; sense as a function, but it’s still impeded my understanding more than<br>&gt; helping it along.<br>&gt;<br>&gt; Alternate suggestions: split(where:), split(separatingWhere:).<br></p><p>Split(where:) fails to imply that there are separators (and that some<br>elements would be omitted from the result), but we considered the second<br>one.  I like the way it reads better, but “whereSeparator” has the<br>advantag of containing the word “separator” that&#39;s used in the<br>predicate-free version.  For me it&#39;s a bit of a toss-up.<br></p><p>&gt; The sort(by:) family<br>&gt;<br>&gt; …seems fine, is slightly confusable with a “sort by key” API, but at<br>&gt; least has a different type signature.<br></p><p>Yes, well, fortunately, Bool is not Comparable, or we would have a<br>problem when we want to introduce that API.<br></p><p>&gt; if roots.contains(where: isPrime) {<br>&gt;<br>&gt; I really don’t like this one; it feels like it’s missing a noun. It<br>&gt; certainly isn’t a valid English phrase. If we were naming an<br>&gt; intersects(_:)-like feature, we might call it `roots.containsAny(of:<br>&gt; primes)` or `roots.contains(anyOf: primes)`.<br></p><p>I agree.  <br>&gt;<br>&gt; Alternate suggestions: containsAny(where:), contains(anyWhere:)<br></p><p>The second one, IMO.<br></p><p>&gt; if expected.elementsEqual(actual, by: haveSameValue)<br>&gt;<br>&gt; I tend to agree with the pre-review commentary<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/22188&gt; that<br>&gt; “by:” doesn’t actually fit here. The difference between<br>&gt; elementsEqual(_:by:) / starts(with:by:) and the sort(by:) family is<br>&gt; that “sort by…” and “order by…” are both things people actually say,<br>&gt; but “equal by…” is not. Then again, when they say those things,<br>&gt; they’re either talking about a key (“sort by name”) or a general<br>&gt; comparison (“sort by compar[ing] names”, &lt;=&gt; rather than &lt;).<br></p><p>  names1.elementsEqual(names2, by: {$0.lowercase == $1.lowercase})<br></p><p><br>reads OK to me.<br></p><p>&gt; let sum = measurements.reduce(0, +)<br>&gt;<br>&gt; It concerns me that we can’t think of a label for this operation; it<br>&gt; implies we can’t think of an English sentence to describe it. “Reduce<br>&gt; this collection to a single element by combining using +.”<br>&gt; reduce(startingWith:combiningWith:) is pretty unwieldy, though.<br></p><p>IMO, if you read the doc comments for reduce, they push pretty strongly<br>toward renaming it to “accumulate,” if you can tolerate the loss of the<br>term-of-art.  That, and the traditional usage-of-art, make me<br>unconcerned that there&#39;s no good label while it&#39;s called “reduce.”<br>FWIW.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 17:57, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jul 07 2016, Jordan Rose &lt;jordan_rose-AT-apple.com &lt;http://at-apple.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; [Proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md ]<br>&gt;&gt; <br>&gt;&gt; Hi, Dave, Dmitri, Max. Sorry I didn’t make the pre-review commentary<br>&gt;&gt; thread. I find I’m still not happy with several of these names,<br>&gt;&gt; although there are many other improvements. Stepping back, I think the<br>&gt;&gt; Swift API guidelines just don’t do a good job with closure<br>&gt;&gt; parameters. We should have naming guidelines for strategy closures and<br>&gt;&gt; for callbacks.<br>&gt;&gt; <br>&gt;&gt; lines.split(whereSeparator: isAllWhitespace)<br>&gt;&gt; <br>&gt;&gt; This reads like an English sentence, but it doesn’t have the correct<br>&gt;&gt; meaning for me. This implies a structure that has a pre-existing<br>&gt;&gt; “separator&quot;, and checks if that separator matches the predicate,<br>&gt;&gt; rather than searching for an element that matches the predicate, and<br>&gt;&gt; splitting on that. I realize that the former reading doesn’t make much<br>&gt;&gt; sense as a function, but it’s still impeded my understanding more than<br>&gt;&gt; helping it along.<br>&gt;&gt; <br>&gt;&gt; Alternate suggestions: split(where:), split(separatingWhere:).<br>&gt; <br>&gt; Split(where:) fails to imply that there are separators (and that some<br>&gt; elements would be omitted from the result), but we considered the second<br>&gt; one.  I like the way it reads better, but “whereSeparator” has the<br>&gt; advantag of containing the word “separator” that&#39;s used in the<br>&gt; predicate-free version.  For me it&#39;s a bit of a toss-up.<br></p><p>Your comments and Erica’s comments have convinced me, or at least lessened my concerns, on all but split(…), but the higher-level point that we need naming guidelines for different kinds of closure parameters still stands.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/c45c7f8c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  8, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Jul 08 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt; This reads like an English sentence, but it doesn’t have the correct<br>&gt;&gt;&gt; meaning for me. This implies a structure that has a pre-existing<br>&gt;&gt;&gt; “separator&quot;, and checks if that separator matches the predicate,<br>&gt;&gt;&gt; rather than searching for an element that matches the predicate, and<br>&gt;&gt;&gt; splitting on that. I realize that the former reading doesn’t make much<br>&gt;&gt;&gt; sense as a function, but it’s still impeded my understanding more than<br>&gt;&gt;&gt; helping it along.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternate suggestions: split(where:), split(separatingWhere:).<br>&gt;&gt; <br>&gt;&gt; Split(where:) fails to imply that there are separators (and that some<br>&gt;&gt; elements would be omitted from the result), but we considered the second<br>&gt;&gt; one.  I like the way it reads better, <br></p><p>Actually I take that back.  It still fails to imply that there are<br>separators and elements may be omitted.<br></p><p>&gt;&gt; but “whereSeparator” has the advantag of containing the word<br>&gt;&gt; “separator” that&#39;s used in the predicate-free version.  For me it&#39;s a<br>&gt;&gt; bit of a toss-up.<br>&gt;<br>&gt; Your comments and Erica’s comments have convinced me, or at least<br>&gt; lessened my concerns, on all but split(…), but the higher-level point<br>&gt; that we need naming guidelines for different kinds of closure<br>&gt; parameters still stands.<br></p><p>Great, please propose some!<br></p><p>My feeling is that we can only discover what these guidelines should be<br>by solving individual naming problems (in groups, as here).<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  8, 2016 at 11:00:00am</p></header><div class="content"><p>On Jul 8, 2016, at 10:56 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 08 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; This reads like an English sentence, but it doesn’t have the correct<br>&gt;&gt;&gt;&gt; meaning for me. This implies a structure that has a pre-existing<br>&gt;&gt;&gt;&gt; “separator&quot;, and checks if that separator matches the predicate,<br>&gt;&gt;&gt;&gt; rather than searching for an element that matches the predicate, and<br>&gt;&gt;&gt;&gt; splitting on that. I realize that the former reading doesn’t make much<br>&gt;&gt;&gt;&gt; sense as a function, but it’s still impeded my understanding more than<br>&gt;&gt;&gt;&gt; helping it along.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternate suggestions: split(where:), split(separatingWhere:).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Split(where:) fails to imply that there are separators (and that some<br>&gt;&gt;&gt; elements would be omitted from the result), but we considered the second<br>&gt;&gt;&gt; one.  I like the way it reads better, <br>&gt; <br>&gt; Actually I take that back.  It still fails to imply that there are<br>&gt; separators and elements may be omitted.<br>&gt; <br>&gt;&gt;&gt; but “whereSeparator” has the advantag of containing the word<br>&gt;&gt;&gt; “separator” that&#39;s used in the predicate-free version.  For me it&#39;s a<br>&gt;&gt;&gt; bit of a toss-up.<br></p><p>split(withLossySeparator:) ??<br></p><p> (I hate this but there&#39;s a point to be made that naming dangerous <br>operations trumps simple names and the other optional external<br>parameter names aren&#39;t exactly trim)<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>In general +1, except maybe the change of to isOrderedBefore: by: in sort-related functions. I fear that the new label makes it less clear that the ordering relation is that of strict precedence. It can be particularly confusing for people used to other APIs.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Well, in the end its an arbitrary decision. Either one works on practice. Personally, I don’t see the issue as being very significant. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes, it follows the spirit of the naming guidelines<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>A glance<br></p><p><br>&gt; On 06 Jul 2016, at 01:10, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0118: Closure Parameter Names and Labels&quot; begins now and runs through July 11. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0118-closure-parameter-names-and-labels.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/bb067164/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0118: Closure Parameter Names and Labels</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>July  9, 2016 at 02:00:00pm</p></header><div class="content"><p>On Tue, Jul 5, 2016, at 04:10 PM, Chris Lattner wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Strong +1. Overall I like all of the changes listed in this proposal, with some commentary below.<br></p><p>&gt; lines.split(whereSeparator: isAllWhitespace)<br></p><p>I think this is ok, but I&#39;d also be fine with split(where:).<br></p><p>&gt; if roots.contains(where: isPrime) {<br></p><p>I strongly prefer this to the alternatives suggested in this thread. Not only is Erica right about &quot;anywhere&quot; being visible in containsAny(where:) or contains(anyWhere:), but those names also just feel unnecessarily cumbersome. Not only that, but using contains(where:) would be more consistent with first(where:) (which is a strongly related function; contains(where:) returns true iff first(where:) returns non-nil).<br></p><p>&gt; let sum = measurements.reduce(0, +)<br></p><p>I&#39;m very happy to see the closure name being removed here. I never thought the name was pulling any weight, since this function is already a term of art rather than being an english sentence.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Other languages don&#39;t typically have external parameter names.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick reading of the proposal and of the thread to date.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
