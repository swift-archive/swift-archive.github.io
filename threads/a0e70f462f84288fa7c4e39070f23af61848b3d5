<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>Draft: Add @noescape and rethrows to ManagedBuffer API</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>February  6, 2016 at 09:00:00pm</p></header><div class="content"><p>I’d like to request feedback on the draft proposal below, about a (hopefully) trivial change to the standard library. <br></p><p>I considered adding it to SE-0012 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md&gt;, which is also about @noescape, but that proposal is about modifying C/Obj-C API, so it’s not a good fit &lt;https://github.com/apple/swift-evolution/pull/122&gt;.<br></p><p>Introduction<br></p><p>stdlib’s ManagedBuffer family of APIs has some public initializers and methods taking closures that are missing the @noescape attribute. The same family has a set of withUnsafeMutablePointer* functions that do not have a rethrows declaration, while all similar methods elsewhere in the standard library allow closures to throw.<br></p><p>I propose to add the missing @noescape attributes and rethrows.<br></p><p>Motivation<br></p><p>- ManagedBuffer seems designed for raw performance. Not having @noescape on the only API that allows access to the buffer’s contents defeats some compiler optimizations, such as omitting unneccessary retain/release calls. This can negate the performance advantage of ManagedBuffer over simpler solutions, like using an Array.<br>- Accepting throwing closures makes these APIs more versatile, and also improves their consistency with other parts of stdlib.<br></p><p>Detailed Design<br></p><p>The following set of APIs would be affected by this proposal:<br></p><p>public class ManagedProtoBuffer&lt;Value, Element&gt; : NonObjectiveCBase {<br>  public final func withUnsafeMutablePointerToValue&lt;R&gt;(body: (UnsafeMutablePointer&lt;Value&gt;) -&gt; R) -&gt; R<br>  public final func withUnsafeMutablePointerToElements&lt;R&gt;(body: (UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>  public final func withUnsafeMutablePointers&lt;R&gt;(body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>}<br></p><p>public class ManagedBuffer&lt;Value, Element&gt; : ManagedProtoBuffer&lt;Value, Element&gt; {<br>  public final class func create(minimumCapacity: Int, initialValue: (ManagedProtoBuffer&lt;Value,Element&gt;) -&gt; Value) -&gt; ManagedBuffer&lt;Value,Element&gt; <br>}<br></p><p>public struct ManagedBufferPointer&lt;Value, Element&gt; : Equatable {<br>  public init(bufferClass: AnyClass, minimumCapacity: Int, initialValue: (buffer: AnyObject, allocatedCount: (AnyObject) -&gt; Int) -&gt; Value)<br>  public func withUnsafeMutablePointerToValue&lt;R&gt;(body: (UnsafeMutablePointer&lt;Value&gt;) -&gt; R) -&gt; R<br>  public func withUnsafeMutablePointerToElements&lt;R&gt;(body: (UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>  public func withUnsafeMutablePointers&lt;R&gt;(body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>}<br></p><p>Here is how they would look after the proposed changes:<br></p><p>public class ManagedProtoBuffer&lt;Value, Element&gt; : NonObjectiveCBase {<br>  public final func withUnsafeMutablePointerToValue&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Value&gt;) throws -&gt; R) rethrows -&gt; R<br>  public final func withUnsafeMutablePointerToElements&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>  public final func withUnsafeMutablePointers&lt;R&gt;(@noescape body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br></p><p>public class ManagedBuffer&lt;Value, Element&gt; : ManagedProtoBuffer&lt;Value, Element&gt; {<br>  public final class func create(minimumCapacity: Int, @noescape initialValue: (ManagedProtoBuffer&lt;Value,Element&gt;) -&gt; Value) -&gt; ManagedBuffer&lt;Value,Element&gt; <br>}<br></p><p>public struct ManagedBufferPointer&lt;Value, Element&gt; : Equatable {<br>  public init(bufferClass: AnyClass, minimumCapacity: Int, @noescape initialValue: (buffer: AnyObject, allocatedCount: (AnyObject) -&gt; Int) -&gt; Value)<br>  public func withUnsafeMutablePointerToValue&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Value&gt;) throws -&gt; R) rethrows -&gt; R<br>  public func withUnsafeMutablePointerToElements&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>  public func withUnsafeMutablePointers&lt;R&gt;(@noescape body: (_: UnsafeMutablePointer&lt;Value&gt;,_: UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>}<br></p><p>A draft implementation is available at https://github.com/apple/swift/compare/master...lorentey:noescape &lt;https://github.com/apple/swift/compare/master...lorentey:noescape&gt;<br></p><p>Impact on Existing Code<br></p><p>Luckily, all modified API is either marked final, or defined in a struct, so I expect no existing code is going to break due to these changes.<br></p><p>-- <br>Károly<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/a0e7b3d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>Draft: Add @noescape and rethrows to ManagedBuffer API</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  7, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>Is there a reason for not marking &#39;ManagedBuffer.create&#39; and &#39;ManagedBufferPointer.init&#39; as rethrows and taking throwing closures?<br>Now that we can have throwing initializers I don&#39;t really see a reason for not allowing throwing closures here...<br></p><p><br>&gt; On 06 Feb 2016, at 21:03, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’d like to request feedback on the draft proposal below, about a (hopefully) trivial change to the standard library. <br>&gt; <br>&gt; I considered adding it to SE-0012 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md&gt;, which is also about @noescape, but that proposal is about modifying C/Obj-C API, so it’s not a good fit &lt;https://github.com/apple/swift-evolution/pull/122&gt;.<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; stdlib’s ManagedBuffer family of APIs has some public initializers and methods taking closures that are missing the @noescape attribute. The same family has a set of withUnsafeMutablePointer* functions that do not have a rethrows declaration, while all similar methods elsewhere in the standard library allow closures to throw.<br>&gt; <br>&gt; I propose to add the missing @noescape attributes and rethrows.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; - ManagedBuffer seems designed for raw performance. Not having @noescape on the only API that allows access to the buffer’s contents defeats some compiler optimizations, such as omitting unneccessary retain/release calls. This can negate the performance advantage of ManagedBuffer over simpler solutions, like using an Array.<br>&gt; - Accepting throwing closures makes these APIs more versatile, and also improves their consistency with other parts of stdlib.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The following set of APIs would be affected by this proposal:<br>&gt; <br>&gt; public class ManagedProtoBuffer&lt;Value, Element&gt; : NonObjectiveCBase {<br>&gt;   public final func withUnsafeMutablePointerToValue&lt;R&gt;(body: (UnsafeMutablePointer&lt;Value&gt;) -&gt; R) -&gt; R<br>&gt;   public final func withUnsafeMutablePointerToElements&lt;R&gt;(body: (UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>&gt;   public final func withUnsafeMutablePointers&lt;R&gt;(body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>&gt; }<br>&gt; <br>&gt; public class ManagedBuffer&lt;Value, Element&gt; : ManagedProtoBuffer&lt;Value, Element&gt; {<br>&gt;   public final class func create(minimumCapacity: Int, initialValue: (ManagedProtoBuffer&lt;Value,Element&gt;) -&gt; Value) -&gt; ManagedBuffer&lt;Value,Element&gt; <br>&gt; }<br>&gt; <br>&gt; public struct ManagedBufferPointer&lt;Value, Element&gt; : Equatable {<br>&gt;   public init(bufferClass: AnyClass, minimumCapacity: Int, initialValue: (buffer: AnyObject, allocatedCount: (AnyObject) -&gt; Int) -&gt; Value)<br>&gt;   public func withUnsafeMutablePointerToValue&lt;R&gt;(body: (UnsafeMutablePointer&lt;Value&gt;) -&gt; R) -&gt; R<br>&gt;   public func withUnsafeMutablePointerToElements&lt;R&gt;(body: (UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>&gt;   public func withUnsafeMutablePointers&lt;R&gt;(body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) -&gt; R) -&gt; R<br>&gt; }<br>&gt; <br>&gt; Here is how they would look after the proposed changes:<br>&gt; <br>&gt; public class ManagedProtoBuffer&lt;Value, Element&gt; : NonObjectiveCBase {<br>&gt;   public final func withUnsafeMutablePointerToValue&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Value&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt;   public final func withUnsafeMutablePointerToElements&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt;   public final func withUnsafeMutablePointers&lt;R&gt;(@noescape body: (_: UnsafeMutablePointer&lt;Value&gt;, _: UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt; <br>&gt; public class ManagedBuffer&lt;Value, Element&gt; : ManagedProtoBuffer&lt;Value, Element&gt; {<br>&gt;   public final class func create(minimumCapacity: Int, @noescape initialValue: (ManagedProtoBuffer&lt;Value,Element&gt;) -&gt; Value) -&gt; ManagedBuffer&lt;Value,Element&gt; <br>&gt; }<br>&gt; <br>&gt; public struct ManagedBufferPointer&lt;Value, Element&gt; : Equatable {<br>&gt;   public init(bufferClass: AnyClass, minimumCapacity: Int, @noescape initialValue: (buffer: AnyObject, allocatedCount: (AnyObject) -&gt; Int) -&gt; Value)<br>&gt;   public func withUnsafeMutablePointerToValue&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Value&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt;   public func withUnsafeMutablePointerToElements&lt;R&gt;(@noescape body: (UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt;   public func withUnsafeMutablePointers&lt;R&gt;(@noescape body: (_: UnsafeMutablePointer&lt;Value&gt;,_: UnsafeMutablePointer&lt;Element&gt;) throws -&gt; R) rethrows -&gt; R<br>&gt; }<br>&gt; <br>&gt; A draft implementation is available at https://github.com/apple/swift/compare/master...lorentey:noescape &lt;https://github.com/apple/swift/compare/master...lorentey:noescape&gt;<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; Luckily, all modified API is either marked final, or defined in a struct, so I expect no existing code is going to break due to these changes.<br>&gt; <br>&gt; -- <br>&gt; Károly<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160207/e4b82309/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
