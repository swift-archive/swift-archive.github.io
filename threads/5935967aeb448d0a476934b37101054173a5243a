<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 28, 2016 at 01:00:00am</p></header><div class="content"><p>Drew Crawford via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt; your class definition?<br>&gt; <br>&gt; What i mean here is simply<br>&gt; <br>&gt; class Foo {<br>&gt; 	///it is undefined behavior to access this variable except from specialQueue<br>&gt;        private var _specialQueueOnly = 0<br>&gt; <br>&gt; 	public var specialQueueOnly: Int {<br>&gt; 		var i: I! = nil<br>&gt; 		dispatch_sync(specialQueue) {<br>&gt; 			i = _specialQueueOnly<br>&gt; 		}<br>&gt; 		return i<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; The lynchpin of this defensive programming technique is that only these<br>&gt; 12 lines of code have any risk of a threading bug, and we can trivially<br>&gt; inspect the 12 lines.  So our safety hangs on two tentpegs:<br>&gt; <br>&gt; 1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler enforcement<br>&gt; against other files trying to access this ivar<br>&gt; 2.  That the file itself is 12 (or other minimal number of) lines and<br>&gt; trivially inspectable.<br>&gt; <br>&gt; Should we violate any of these constraints, we lose our safety.<br></p><p>Allowing extensions within a module to introduce stored properties might be<br>another possible way of enabling this, since you could then factor the<br>private storage and its concurrency-safe accessors into a separate file.<br>Looking further into the future, our concurrency model will hopefully have<br>some mechanism for isolating state, by actors or some other means. <br></p><p>-Joe <br></p><p>&gt; <br>&gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br>&gt; <br>&gt; <br>&gt; Well, that is kind of the point: Objective-C&#39;s access control worked, and<br>&gt; prevented you from knowing about this class.  <br>&gt; <br>&gt; But to provide a more accessible illustration, consider the case where we<br>&gt; have some motivation to hide Foo from the rest of our<br>&gt; framework[/module/target/application/executable/library].  This is more<br>&gt; likely to happen in a UIKit-sized project, where there are hundreds of<br>&gt; public classes, and probably thousands of &quot;internal&quot; ones, and a typical<br>&gt; class has motivation to touch 5 or 6 other classes, of the thousands that may be available.<br>&gt; <br>&gt; In Swift, each internal class is visible to every other class.  But that<br>&gt; is not especially workable at UIKit scale; if every class can potentially<br>&gt; reach every other class we are in for an adventure when one of the<br>&gt; hundred developers on your team decides that some UITableView<br>&gt; implementation detail you&#39;ve never heard of should be accessing some<br>&gt; UILocalNotification detail you&#39;ve also never heard of.  So we need some<br>&gt; kind of &quot;fencing&quot; within a large framework to make good neighbors.<br>&gt; <br>&gt; This is solved very easily: we can group several related classes into one<br>&gt; file, and some of the classes are private.  Many ordinary people today<br>&gt; group related classes into a file as a fencing mechanism even not at<br>&gt; UIKit-scale.  So a file can access all of its own classes, but not all<br>&gt; the classes of other files.  That creates the &quot;fence&quot;, and now your<br>&gt; coworker cannot draw a line between some UITableView secret class and some<br>&gt; UILocalNotification secret class, and your desk will not be dented from<br>&gt; the impact of your forehead.<br>&gt; <br>&gt; The problem now is that while fixing this situation we have broken one of<br>&gt; our safety tentpegs.  We earlier required that Foo.swift be only 12 lines<br>&gt; for thread safety, but now Foo is contained in a larger file so as to<br>&gt; create a fence.  So we can solve one of these problems or the other one,<br>&gt; but never both at the same time.<br>&gt; <br>&gt; &quot;local&quot; effectively resolves this dilemma, because if our<br>&gt; _specialQueueOnly variable is local, then it is not the /file/ which must<br>&gt; be kept to 12 lines, but the /scope/.  So we could group an unlimited<br>&gt; number of classes in Foo.swift, with no loss of confidence for our thread safety.<br>&gt; <br>&gt; A better approach might be to realize that if global scope, target scope,<br>&gt; and file scope do not solve the visibility problem, perhaps yet another<br>&gt; scope will not totally solve the problem either.  I fully expect Apple<br>&gt; will need a &quot;vendor&quot; scope for example (so that UIKit and CoreAnimation,<br>&gt; two public frameworks, can still have private APIs between them), and I<br>&gt; bet there are many more kinds of scopes that have not yet occurred to me.<br>&gt; <br>&gt; Behind that realization lies the Rust system, which divorces visibility<br>&gt; from these arbitrary scopes that we seem to be struggling to fit into. <br>&gt; But that proposal isn&#39;t before us, and this one is.  I prefer going<br>&gt; somewhere to staying here.<br>&gt; <br>&gt; Drew<br>&gt;  <br>&gt; <br>&gt;&gt; On Feb 26, 2016, at 10:34 PM, David Waite<br>&gt;&gt; &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that is<br>&gt;&gt;&gt; only safe for access from one thread, I *need* compiler enforcement.  I<br>&gt;&gt;&gt; *need* a guarantee that this ivar is only accessed through public<br>&gt;&gt;&gt; interface methods that can be audited to be threadsafe.  Simply a<br>&gt;&gt;&gt; doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt;&gt; <br>&gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt; your class definition? I believe you would only get this with this local<br>&gt;&gt; scope proposal if you structured your code such that callback blocks<br>&gt;&gt; were functions outside your type definition.<br>&gt;&gt; <br>&gt;&gt; If you are talking about access or modification of the inner state of a<br>&gt;&gt; class and a manual audit of safety, that audit is of the file and not of<br>&gt;&gt; the type or extension. I’m unsure if your concern is of having to split<br>&gt;&gt; code into multiple files for safety, or that there is not a way to split<br>&gt;&gt; code into multiple files to achieve safety in some particular scenario.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I want<br>&gt;&gt;&gt; to follow &quot;one file per class&quot;.  I can achieve thread safety with<br>&gt;&gt;&gt; &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is<br>&gt;&gt;&gt; UITableViewCellContentView (which is an implementation detail that<br>&gt;&gt;&gt; should be hidden even to most of UIKit) I am now forced to expose that<br>&gt;&gt;&gt; implementation detail to my entire team.<br>&gt;&gt; <br>&gt;&gt;&gt; This places me in the unconscionable situation of choosing between<br>&gt;&gt;&gt; whether I have thread safety or encapsulation, between whether my<br>&gt;&gt;&gt; coworker will accidentally create a threading bug or accidentally use a<br>&gt;&gt;&gt; class they ought not to use and I am unable to appropriately hide.<br>&gt;&gt; <br>&gt;&gt; I’m not quite sure what you mean here - exposing that your class is a<br>&gt;&gt; subclass of UITableViewCellContentView? Or that the rest of your team<br>&gt;&gt; needs to code in different files from your class in order to maintain encapsulation?<br>&gt;&gt; <br>&gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is not documented).<br>&gt;&gt; <br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my<br>&gt;&gt;&gt; position somewhat in response to the growing uncertainty about dropping<br>&gt;&gt;&gt; the NS prefix, which I think exposes some very real problems with visibility in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As that situation has developed, I no longer believe this proposal goes<br>&gt;&gt;&gt; far enough.  But it does go somewhere, and we should not stay where we are.<br>&gt;&gt; <br>&gt;&gt; I don’t understand how an access control proposal pertains to changes in<br>&gt;&gt; the Foundation public API. What is the ideal end state in your mind, and<br>&gt;&gt; in what way is this a step toward that?<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 28, 2016 at 01:00:00am</p></header><div class="content"><p>Allowing extensions within a module to introduce stored properties would be<br>a great addition to the language, but it&#39;s a completely different matter. A<br>language shouldn&#39;t dictate file structure. It may make sense to keep<br>related classes in the same file for easier access rather than having tiny<br>files for every scope. &quot;scoped&quot; is much clearer about intent then<br>&quot;private&quot;. It says that something must be hidden in the scope regardless of<br>where the code is.<br></p><p>On Sat, Feb 27, 2016 at 8:04 PM Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Drew Crawford via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt; &gt;&gt; your class definition?<br>&gt; &gt;<br>&gt; &gt; What i mean here is simply<br>&gt; &gt;<br>&gt; &gt; class Foo {<br>&gt; &gt;       ///it is undefined behavior to access this variable except from<br>&gt; specialQueue<br>&gt; &gt;        private var _specialQueueOnly = 0<br>&gt; &gt;<br>&gt; &gt;       public var specialQueueOnly: Int {<br>&gt; &gt;               var i: I! = nil<br>&gt; &gt;               dispatch_sync(specialQueue) {<br>&gt; &gt;                       i = _specialQueueOnly<br>&gt; &gt;               }<br>&gt; &gt;               return i<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; The lynchpin of this defensive programming technique is that only these<br>&gt; &gt; 12 lines of code have any risk of a threading bug, and we can trivially<br>&gt; &gt; inspect the 12 lines.  So our safety hangs on two tentpegs:<br>&gt; &gt;<br>&gt; &gt; 1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler enforcement<br>&gt; &gt; against other files trying to access this ivar<br>&gt; &gt; 2.  That the file itself is 12 (or other minimal number of) lines and<br>&gt; &gt; trivially inspectable.<br>&gt; &gt;<br>&gt; &gt; Should we violate any of these constraints, we lose our safety.<br>&gt;<br>&gt; Allowing extensions within a module to introduce stored properties might be<br>&gt; another possible way of enabling this, since you could then factor the<br>&gt; private storage and its concurrency-safe accessors into a separate file.<br>&gt; Looking further into the future, our concurrency model will hopefully have<br>&gt; some mechanism for isolating state, by actors or some other means.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is<br>&gt; not documented).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Well, that is kind of the point: Objective-C&#39;s access control worked, and<br>&gt; &gt; prevented you from knowing about this class.<br>&gt; &gt;<br>&gt; &gt; But to provide a more accessible illustration, consider the case where we<br>&gt; &gt; have some motivation to hide Foo from the rest of our<br>&gt; &gt; framework[/module/target/application/executable/library].  This is more<br>&gt; &gt; likely to happen in a UIKit-sized project, where there are hundreds of<br>&gt; &gt; public classes, and probably thousands of &quot;internal&quot; ones, and a typical<br>&gt; &gt; class has motivation to touch 5 or 6 other classes, of the thousands<br>&gt; that may be available.<br>&gt; &gt;<br>&gt; &gt; In Swift, each internal class is visible to every other class.  But that<br>&gt; &gt; is not especially workable at UIKit scale; if every class can potentially<br>&gt; &gt; reach every other class we are in for an adventure when one of the<br>&gt; &gt; hundred developers on your team decides that some UITableView<br>&gt; &gt; implementation detail you&#39;ve never heard of should be accessing some<br>&gt; &gt; UILocalNotification detail you&#39;ve also never heard of.  So we need some<br>&gt; &gt; kind of &quot;fencing&quot; within a large framework to make good neighbors.<br>&gt; &gt;<br>&gt; &gt; This is solved very easily: we can group several related classes into one<br>&gt; &gt; file, and some of the classes are private.  Many ordinary people today<br>&gt; &gt; group related classes into a file as a fencing mechanism even not at<br>&gt; &gt; UIKit-scale.  So a file can access all of its own classes, but not all<br>&gt; &gt; the classes of other files.  That creates the &quot;fence&quot;, and now your<br>&gt; &gt; coworker cannot draw a line between some UITableView secret class and<br>&gt; some<br>&gt; &gt; UILocalNotification secret class, and your desk will not be dented from<br>&gt; &gt; the impact of your forehead.<br>&gt; &gt;<br>&gt; &gt; The problem now is that while fixing this situation we have broken one of<br>&gt; &gt; our safety tentpegs.  We earlier required that Foo.swift be only 12 lines<br>&gt; &gt; for thread safety, but now Foo is contained in a larger file so as to<br>&gt; &gt; create a fence.  So we can solve one of these problems or the other one,<br>&gt; &gt; but never both at the same time.<br>&gt; &gt;<br>&gt; &gt; &quot;local&quot; effectively resolves this dilemma, because if our<br>&gt; &gt; _specialQueueOnly variable is local, then it is not the /file/ which must<br>&gt; &gt; be kept to 12 lines, but the /scope/.  So we could group an unlimited<br>&gt; &gt; number of classes in Foo.swift, with no loss of confidence for our<br>&gt; thread safety.<br>&gt; &gt;<br>&gt; &gt; A better approach might be to realize that if global scope, target scope,<br>&gt; &gt; and file scope do not solve the visibility problem, perhaps yet another<br>&gt; &gt; scope will not totally solve the problem either.  I fully expect Apple<br>&gt; &gt; will need a &quot;vendor&quot; scope for example (so that UIKit and CoreAnimation,<br>&gt; &gt; two public frameworks, can still have private APIs between them), and I<br>&gt; &gt; bet there are many more kinds of scopes that have not yet occurred to me.<br>&gt; &gt;<br>&gt; &gt; Behind that realization lies the Rust system, which divorces visibility<br>&gt; &gt; from these arbitrary scopes that we seem to be struggling to fit into.<br>&gt; &gt; But that proposal isn&#39;t before us, and this one is.  I prefer going<br>&gt; &gt; somewhere to staying here.<br>&gt; &gt;<br>&gt; &gt; Drew<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Feb 26, 2016, at 10:34 PM, David Waite<br>&gt; &gt;&gt; &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that is<br>&gt; &gt;&gt;&gt; only safe for access from one thread, I *need* compiler enforcement.  I<br>&gt; &gt;&gt;&gt; *need* a guarantee that this ivar is only accessed through public<br>&gt; &gt;&gt;&gt; interface methods that can be audited to be threadsafe.  Simply a<br>&gt; &gt;&gt;&gt; doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt; &gt;&gt; your class definition? I believe you would only get this with this local<br>&gt; &gt;&gt; scope proposal if you structured your code such that callback blocks<br>&gt; &gt;&gt; were functions outside your type definition.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you are talking about access or modification of the inner state of a<br>&gt; &gt;&gt; class and a manual audit of safety, that audit is of the file and not of<br>&gt; &gt;&gt; the type or extension. I’m unsure if your concern is of having to split<br>&gt; &gt;&gt; code into multiple files for safety, or that there is not a way to split<br>&gt; &gt;&gt; code into multiple files to achieve safety in some particular scenario.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I want<br>&gt; &gt;&gt;&gt; to follow &quot;one file per class&quot;.  I can achieve thread safety with<br>&gt; &gt;&gt;&gt; &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is<br>&gt; &gt;&gt;&gt; UITableViewCellContentView (which is an implementation detail that<br>&gt; &gt;&gt;&gt; should be hidden even to most of UIKit) I am now forced to expose that<br>&gt; &gt;&gt;&gt; implementation detail to my entire team.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; This places me in the unconscionable situation of choosing between<br>&gt; &gt;&gt;&gt; whether I have thread safety or encapsulation, between whether my<br>&gt; &gt;&gt;&gt; coworker will accidentally create a threading bug or accidentally use a<br>&gt; &gt;&gt;&gt; class they ought not to use and I am unable to appropriately hide.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not quite sure what you mean here - exposing that your class is a<br>&gt; &gt;&gt; subclass of UITableViewCellContentView? Or that the rest of your team<br>&gt; &gt;&gt; needs to code in different files from your class in order to maintain<br>&gt; encapsulation?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it is<br>&gt; not documented).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &lt;snip&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt; &gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt; &gt;&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my<br>&gt; &gt;&gt;&gt; position somewhat in response to the growing uncertainty about dropping<br>&gt; &gt;&gt;&gt; the NS prefix, which I think exposes some very real problems with<br>&gt; visibility in Swift.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; As that situation has developed, I no longer believe this proposal goes<br>&gt; &gt;&gt;&gt; far enough.  But it does go somewhere, and we should not stay where we<br>&gt; are.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don’t understand how an access control proposal pertains to changes in<br>&gt; &gt;&gt; the Foundation public API. What is the ideal end state in your mind, and<br>&gt; &gt;&gt; in what way is this a step toward that?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -DW<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/01f80d0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 29, 2016 at 04:00:00am</p></header><div class="content"><p>On Sat, Feb 27, 2016 at 5:18 PM, Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Allowing extensions within a module to introduce stored properties would<br>&gt; be a great addition to the language, but it&#39;s a completely different<br>&gt; matter. A language shouldn&#39;t dictate file structure. It may make sense to<br>&gt; keep related classes in the same file for easier access rather than having<br>&gt; tiny files for every scope. &quot;scoped&quot; is much clearer about intent then<br>&gt; &quot;private&quot;. It says that something must be hidden in the scope regardless of<br>&gt; where the code is.<br>&gt;<br>&gt;<br>-1.  I don&#39;t agree with this premise; IMHO, a language *should* dictate<br>file structure, and aligning code structure with symbol visibility is a lot<br>better than aligning it with VM classloading (Java) or with the benevolent<br>dictator&#39;s preferences (RoR or Angular).  I&#39;d like to see intended symbol<br>visibility used as a decision-maker for how to break up code into files:<br>this often results in cleaner codebases than if people follow the natural<br>tendency to dump everything in one file and then delimit access by scope.<br>Lots of small files results in fewer edit conflicts, easier navigation<br>through file browsers, and some level of self-documentation through<br>filenames.<br></p><p>I spent several years programming in Java, and I don&#39;t think that the<br>one-public-class-per-file rule was *that* bad.  In the cases where it<br>completely fell down - which were usually things like HashMap, where you<br>needed a helper class, or interfaces &amp; event handlers, where you had a tiny<br>file just needed to define a few methods - Swift&#39;s system is much better.<br>You&#39;d put the helper classes for HashMap in the same file as the main<br>class, where most of the implementation can remain private but any<br>protocols can be explicitly declared public.  You can also put protocols in<br>the same file and mark them public.<br></p><p>I&#39;m unconvinced that Drew&#39;s example wouldn&#39;t be better served by putting<br>the queue in its own file, where the implementation isn&#39;t just private to<br>the compiler, but doesn&#39;t need to be looked at by anyone browsing through<br>the client code.<br></p><p>I do think that it would be handy to have some level of access control<br>between file and framework, for when you want to deliver all of your API to<br>customers as a unit but may have individual subsystems (written by<br>different teams) hiding behind it.  But I&#39;d rather see that solved by<br>letting frameworks depend upon other frameworks and yet still be packaged<br>together as a unit than by introducing another level of access control.<br></p><p><br>&gt; On Sat, Feb 27, 2016 at 8:04 PM Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Drew Crawford via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt; &gt;&gt; your class definition?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What i mean here is simply<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class Foo {<br>&gt;&gt; &gt;       ///it is undefined behavior to access this variable except from<br>&gt;&gt; specialQueue<br>&gt;&gt; &gt;        private var _specialQueueOnly = 0<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       public var specialQueueOnly: Int {<br>&gt;&gt; &gt;               var i: I! = nil<br>&gt;&gt; &gt;               dispatch_sync(specialQueue) {<br>&gt;&gt; &gt;                       i = _specialQueueOnly<br>&gt;&gt; &gt;               }<br>&gt;&gt; &gt;               return i<br>&gt;&gt; &gt;       }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The lynchpin of this defensive programming technique is that only these<br>&gt;&gt; &gt; 12 lines of code have any risk of a threading bug, and we can trivially<br>&gt;&gt; &gt; inspect the 12 lines.  So our safety hangs on two tentpegs:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler<br>&gt;&gt; enforcement<br>&gt;&gt; &gt; against other files trying to access this ivar<br>&gt;&gt; &gt; 2.  That the file itself is 12 (or other minimal number of) lines and<br>&gt;&gt; &gt; trivially inspectable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Should we violate any of these constraints, we lose our safety.<br>&gt;&gt;<br>&gt;&gt; Allowing extensions within a module to introduce stored properties might<br>&gt;&gt; be<br>&gt;&gt; another possible way of enabling this, since you could then factor the<br>&gt;&gt; private storage and its concurrency-safe accessors into a separate file.<br>&gt;&gt; Looking further into the future, our concurrency model will hopefully have<br>&gt;&gt; some mechanism for isolating state, by actors or some other means.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it<br>&gt;&gt; is not documented).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, that is kind of the point: Objective-C&#39;s access control worked,<br>&gt;&gt; and<br>&gt;&gt; &gt; prevented you from knowing about this class.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But to provide a more accessible illustration, consider the case where<br>&gt;&gt; we<br>&gt;&gt; &gt; have some motivation to hide Foo from the rest of our<br>&gt;&gt; &gt; framework[/module/target/application/executable/library].  This is more<br>&gt;&gt; &gt; likely to happen in a UIKit-sized project, where there are hundreds of<br>&gt;&gt; &gt; public classes, and probably thousands of &quot;internal&quot; ones, and a typical<br>&gt;&gt; &gt; class has motivation to touch 5 or 6 other classes, of the thousands<br>&gt;&gt; that may be available.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In Swift, each internal class is visible to every other class.  But that<br>&gt;&gt; &gt; is not especially workable at UIKit scale; if every class can<br>&gt;&gt; potentially<br>&gt;&gt; &gt; reach every other class we are in for an adventure when one of the<br>&gt;&gt; &gt; hundred developers on your team decides that some UITableView<br>&gt;&gt; &gt; implementation detail you&#39;ve never heard of should be accessing some<br>&gt;&gt; &gt; UILocalNotification detail you&#39;ve also never heard of.  So we need some<br>&gt;&gt; &gt; kind of &quot;fencing&quot; within a large framework to make good neighbors.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This is solved very easily: we can group several related classes into<br>&gt;&gt; one<br>&gt;&gt; &gt; file, and some of the classes are private.  Many ordinary people today<br>&gt;&gt; &gt; group related classes into a file as a fencing mechanism even not at<br>&gt;&gt; &gt; UIKit-scale.  So a file can access all of its own classes, but not all<br>&gt;&gt; &gt; the classes of other files.  That creates the &quot;fence&quot;, and now your<br>&gt;&gt; &gt; coworker cannot draw a line between some UITableView secret class and<br>&gt;&gt; some<br>&gt;&gt; &gt; UILocalNotification secret class, and your desk will not be dented from<br>&gt;&gt; &gt; the impact of your forehead.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The problem now is that while fixing this situation we have broken one<br>&gt;&gt; of<br>&gt;&gt; &gt; our safety tentpegs.  We earlier required that Foo.swift be only 12<br>&gt;&gt; lines<br>&gt;&gt; &gt; for thread safety, but now Foo is contained in a larger file so as to<br>&gt;&gt; &gt; create a fence.  So we can solve one of these problems or the other one,<br>&gt;&gt; &gt; but never both at the same time.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &quot;local&quot; effectively resolves this dilemma, because if our<br>&gt;&gt; &gt; _specialQueueOnly variable is local, then it is not the /file/ which<br>&gt;&gt; must<br>&gt;&gt; &gt; be kept to 12 lines, but the /scope/.  So we could group an unlimited<br>&gt;&gt; &gt; number of classes in Foo.swift, with no loss of confidence for our<br>&gt;&gt; thread safety.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; A better approach might be to realize that if global scope, target<br>&gt;&gt; scope,<br>&gt;&gt; &gt; and file scope do not solve the visibility problem, perhaps yet another<br>&gt;&gt; &gt; scope will not totally solve the problem either.  I fully expect Apple<br>&gt;&gt; &gt; will need a &quot;vendor&quot; scope for example (so that UIKit and CoreAnimation,<br>&gt;&gt; &gt; two public frameworks, can still have private APIs between them), and I<br>&gt;&gt; &gt; bet there are many more kinds of scopes that have not yet occurred to<br>&gt;&gt; me.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Behind that realization lies the Rust system, which divorces visibility<br>&gt;&gt; &gt; from these arbitrary scopes that we seem to be struggling to fit into.<br>&gt;&gt; &gt; But that proposal isn&#39;t before us, and this one is.  I prefer going<br>&gt;&gt; &gt; somewhere to staying here.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Drew<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Feb 26, 2016, at 10:34 PM, David Waite<br>&gt;&gt; &gt;&gt; &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that<br>&gt;&gt; is<br>&gt;&gt; &gt;&gt;&gt; only safe for access from one thread, I *need* compiler enforcement.<br>&gt;&gt; I<br>&gt;&gt; &gt;&gt;&gt; *need* a guarantee that this ivar is only accessed through public<br>&gt;&gt; &gt;&gt;&gt; interface methods that can be audited to be threadsafe.  Simply a<br>&gt;&gt; &gt;&gt;&gt; doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt; &gt;&gt; your class definition? I believe you would only get this with this<br>&gt;&gt; local<br>&gt;&gt; &gt;&gt; scope proposal if you structured your code such that callback blocks<br>&gt;&gt; &gt;&gt; were functions outside your type definition.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If you are talking about access or modification of the inner state of a<br>&gt;&gt; &gt;&gt; class and a manual audit of safety, that audit is of the file and not<br>&gt;&gt; of<br>&gt;&gt; &gt;&gt; the type or extension. I’m unsure if your concern is of having to split<br>&gt;&gt; &gt;&gt; code into multiple files for safety, or that there is not a way to<br>&gt;&gt; split<br>&gt;&gt; &gt;&gt; code into multiple files to achieve safety in some particular scenario.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I<br>&gt;&gt; want<br>&gt;&gt; &gt;&gt;&gt; to follow &quot;one file per class&quot;.  I can achieve thread safety with<br>&gt;&gt; &gt;&gt;&gt; &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is<br>&gt;&gt; &gt;&gt;&gt; UITableViewCellContentView (which is an implementation detail that<br>&gt;&gt; &gt;&gt;&gt; should be hidden even to most of UIKit) I am now forced to expose that<br>&gt;&gt; &gt;&gt;&gt; implementation detail to my entire team.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This places me in the unconscionable situation of choosing between<br>&gt;&gt; &gt;&gt;&gt; whether I have thread safety or encapsulation, between whether my<br>&gt;&gt; &gt;&gt;&gt; coworker will accidentally create a threading bug or accidentally use<br>&gt;&gt; a<br>&gt;&gt; &gt;&gt;&gt; class they ought not to use and I am unable to appropriately hide.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’m not quite sure what you mean here - exposing that your class is a<br>&gt;&gt; &gt;&gt; subclass of UITableViewCellContentView? Or that the rest of your team<br>&gt;&gt; &gt;&gt; needs to code in different files from your class in order to maintain<br>&gt;&gt; encapsulation?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it<br>&gt;&gt; is not documented).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &lt;snip&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt; &gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; &gt;&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my<br>&gt;&gt; &gt;&gt;&gt; position somewhat in response to the growing uncertainty about<br>&gt;&gt; dropping<br>&gt;&gt; &gt;&gt;&gt; the NS prefix, which I think exposes some very real problems with<br>&gt;&gt; visibility in Swift.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; As that situation has developed, I no longer believe this proposal<br>&gt;&gt; goes<br>&gt;&gt; &gt;&gt;&gt; far enough.  But it does go somewhere, and we should not stay where<br>&gt;&gt; we are.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I don’t understand how an access control proposal pertains to changes<br>&gt;&gt; in<br>&gt;&gt; &gt;&gt; the Foundation public API. What is the ideal end state in your mind,<br>&gt;&gt; and<br>&gt;&gt; &gt;&gt; in what way is this a step toward that?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -DW<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/6f644675/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0025 Scoped Access Level</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March  1, 2016 at 04:00:00am</p></header><div class="content"><p>Most of the time, restricted access is about internal state or about helper<br>functions that may manipulate state in an unsafe way or make assumptions<br>that generally aren&#39;t true. People writing code don&#39;t think in terms of<br>files; they think in terms of types. &quot;scoped&quot; is a much clearer expression<br>of intent than &quot;file&quot; (called &quot;private&quot; in Swift). Putting the scope into a<br>separate class and applying &quot;file&quot; access level is a way of implementing<br>&quot;scoped&quot;, but it&#39;s an implementation of the intent and not the expression<br>itself. (I purposefully call it &quot;file&quot; in this context because &quot;private&quot;<br>gives the illusion that it means something else.)<br></p><p>It&#39;s called &quot;private&quot; now because it serves as both the &quot;file&quot; level access<br>and as the implementation of what most people are used to calling<br>&quot;private&quot;. It&#39;s a great solution for allowing access to interdependent<br>types, but using the same implementation to express &quot;scoped&quot; lacks clarity<br>and imposes file structure that shouldn&#39;t be necessary for this reason.<br></p><p>On Mon, Feb 29, 2016 at 7:07 AM Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Sat, Feb 27, 2016 at 5:18 PM, Ilya Belenkiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Allowing extensions within a module to introduce stored properties would<br>&gt;&gt; be a great addition to the language, but it&#39;s a completely different<br>&gt;&gt; matter. A language shouldn&#39;t dictate file structure. It may make sense to<br>&gt;&gt; keep related classes in the same file for easier access rather than having<br>&gt;&gt; tiny files for every scope. &quot;scoped&quot; is much clearer about intent then<br>&gt;&gt; &quot;private&quot;. It says that something must be hidden in the scope regardless of<br>&gt;&gt; where the code is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; -1.  I don&#39;t agree with this premise; IMHO, a language *should* dictate<br>&gt; file structure, and aligning code structure with symbol visibility is a lot<br>&gt; better than aligning it with VM classloading (Java) or with the benevolent<br>&gt; dictator&#39;s preferences (RoR or Angular).  I&#39;d like to see intended symbol<br>&gt; visibility used as a decision-maker for how to break up code into files:<br>&gt; this often results in cleaner codebases than if people follow the natural<br>&gt; tendency to dump everything in one file and then delimit access by scope.<br>&gt; Lots of small files results in fewer edit conflicts, easier navigation<br>&gt; through file browsers, and some level of self-documentation through<br>&gt; filenames.<br>&gt;<br>&gt; I spent several years programming in Java, and I don&#39;t think that the<br>&gt; one-public-class-per-file rule was *that* bad.  In the cases where it<br>&gt; completely fell down - which were usually things like HashMap, where you<br>&gt; needed a helper class, or interfaces &amp; event handlers, where you had a tiny<br>&gt; file just needed to define a few methods - Swift&#39;s system is much better.<br>&gt; You&#39;d put the helper classes for HashMap in the same file as the main<br>&gt; class, where most of the implementation can remain private but any<br>&gt; protocols can be explicitly declared public.  You can also put protocols in<br>&gt; the same file and mark them public.<br>&gt;<br>&gt; I&#39;m unconvinced that Drew&#39;s example wouldn&#39;t be better served by putting<br>&gt; the queue in its own file, where the implementation isn&#39;t just private to<br>&gt; the compiler, but doesn&#39;t need to be looked at by anyone browsing through<br>&gt; the client code.<br>&gt;<br>&gt; I do think that it would be handy to have some level of access control<br>&gt; between file and framework, for when you want to deliver all of your API to<br>&gt; customers as a unit but may have individual subsystems (written by<br>&gt; different teams) hiding behind it.  But I&#39;d rather see that solved by<br>&gt; letting frameworks depend upon other frameworks and yet still be packaged<br>&gt; together as a unit than by introducing another level of access control.<br>&gt;<br>&gt;<br>&gt;&gt; On Sat, Feb 27, 2016 at 8:04 PM Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Drew Crawford via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt;&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt;&gt; &gt;&gt; your class definition?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What i mean here is simply<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; class Foo {<br>&gt;&gt;&gt; &gt;       ///it is undefined behavior to access this variable except from<br>&gt;&gt;&gt; specialQueue<br>&gt;&gt;&gt; &gt;        private var _specialQueueOnly = 0<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;       public var specialQueueOnly: Int {<br>&gt;&gt;&gt; &gt;               var i: I! = nil<br>&gt;&gt;&gt; &gt;               dispatch_sync(specialQueue) {<br>&gt;&gt;&gt; &gt;                       i = _specialQueueOnly<br>&gt;&gt;&gt; &gt;               }<br>&gt;&gt;&gt; &gt;               return i<br>&gt;&gt;&gt; &gt;       }<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The lynchpin of this defensive programming technique is that only these<br>&gt;&gt;&gt; &gt; 12 lines of code have any risk of a threading bug, and we can trivially<br>&gt;&gt;&gt; &gt; inspect the 12 lines.  So our safety hangs on two tentpegs:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 1.  That &quot;private&quot; in &quot;private var _specialQueue&quot; is compiler<br>&gt;&gt;&gt; enforcement<br>&gt;&gt;&gt; &gt; against other files trying to access this ivar<br>&gt;&gt;&gt; &gt; 2.  That the file itself is 12 (or other minimal number of) lines and<br>&gt;&gt;&gt; &gt; trivially inspectable.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Should we violate any of these constraints, we lose our safety.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Allowing extensions within a module to introduce stored properties might<br>&gt;&gt;&gt; be<br>&gt;&gt;&gt; another possible way of enabling this, since you could then factor the<br>&gt;&gt;&gt; private storage and its concurrency-safe accessors into a separate file.<br>&gt;&gt;&gt; Looking further into the future, our concurrency model will hopefully<br>&gt;&gt;&gt; have<br>&gt;&gt;&gt; some mechanism for isolating state, by actors or some other means.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it<br>&gt;&gt;&gt; is not documented).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Well, that is kind of the point: Objective-C&#39;s access control worked,<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; &gt; prevented you from knowing about this class.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; But to provide a more accessible illustration, consider the case where<br>&gt;&gt;&gt; we<br>&gt;&gt;&gt; &gt; have some motivation to hide Foo from the rest of our<br>&gt;&gt;&gt; &gt; framework[/module/target/application/executable/library].  This is more<br>&gt;&gt;&gt; &gt; likely to happen in a UIKit-sized project, where there are hundreds of<br>&gt;&gt;&gt; &gt; public classes, and probably thousands of &quot;internal&quot; ones, and a<br>&gt;&gt;&gt; typical<br>&gt;&gt;&gt; &gt; class has motivation to touch 5 or 6 other classes, of the thousands<br>&gt;&gt;&gt; that may be available.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In Swift, each internal class is visible to every other class.  But<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; &gt; is not especially workable at UIKit scale; if every class can<br>&gt;&gt;&gt; potentially<br>&gt;&gt;&gt; &gt; reach every other class we are in for an adventure when one of the<br>&gt;&gt;&gt; &gt; hundred developers on your team decides that some UITableView<br>&gt;&gt;&gt; &gt; implementation detail you&#39;ve never heard of should be accessing some<br>&gt;&gt;&gt; &gt; UILocalNotification detail you&#39;ve also never heard of.  So we need some<br>&gt;&gt;&gt; &gt; kind of &quot;fencing&quot; within a large framework to make good neighbors.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; This is solved very easily: we can group several related classes into<br>&gt;&gt;&gt; one<br>&gt;&gt;&gt; &gt; file, and some of the classes are private.  Many ordinary people today<br>&gt;&gt;&gt; &gt; group related classes into a file as a fencing mechanism even not at<br>&gt;&gt;&gt; &gt; UIKit-scale.  So a file can access all of its own classes, but not all<br>&gt;&gt;&gt; &gt; the classes of other files.  That creates the &quot;fence&quot;, and now your<br>&gt;&gt;&gt; &gt; coworker cannot draw a line between some UITableView secret class and<br>&gt;&gt;&gt; some<br>&gt;&gt;&gt; &gt; UILocalNotification secret class, and your desk will not be dented from<br>&gt;&gt;&gt; &gt; the impact of your forehead.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The problem now is that while fixing this situation we have broken one<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; &gt; our safety tentpegs.  We earlier required that Foo.swift be only 12<br>&gt;&gt;&gt; lines<br>&gt;&gt;&gt; &gt; for thread safety, but now Foo is contained in a larger file so as to<br>&gt;&gt;&gt; &gt; create a fence.  So we can solve one of these problems or the other<br>&gt;&gt;&gt; one,<br>&gt;&gt;&gt; &gt; but never both at the same time.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; &quot;local&quot; effectively resolves this dilemma, because if our<br>&gt;&gt;&gt; &gt; _specialQueueOnly variable is local, then it is not the /file/ which<br>&gt;&gt;&gt; must<br>&gt;&gt;&gt; &gt; be kept to 12 lines, but the /scope/.  So we could group an unlimited<br>&gt;&gt;&gt; &gt; number of classes in Foo.swift, with no loss of confidence for our<br>&gt;&gt;&gt; thread safety.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; A better approach might be to realize that if global scope, target<br>&gt;&gt;&gt; scope,<br>&gt;&gt;&gt; &gt; and file scope do not solve the visibility problem, perhaps yet another<br>&gt;&gt;&gt; &gt; scope will not totally solve the problem either.  I fully expect Apple<br>&gt;&gt;&gt; &gt; will need a &quot;vendor&quot; scope for example (so that UIKit and<br>&gt;&gt;&gt; CoreAnimation,<br>&gt;&gt;&gt; &gt; two public frameworks, can still have private APIs between them), and I<br>&gt;&gt;&gt; &gt; bet there are many more kinds of scopes that have not yet occurred to<br>&gt;&gt;&gt; me.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Behind that realization lies the Rust system, which divorces visibility<br>&gt;&gt;&gt; &gt; from these arbitrary scopes that we seem to be struggling to fit into.<br>&gt;&gt;&gt; &gt; But that proposal isn&#39;t before us, and this one is.  I prefer going<br>&gt;&gt;&gt; &gt; somewhere to staying here.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Drew<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Feb 26, 2016, at 10:34 PM, David Waite<br>&gt;&gt;&gt; &gt;&gt; &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Feb 26, 2016, at 8:44 PM, Drew Crawford via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Threading is one especially pernicious case.  If I have an ivar that<br>&gt;&gt;&gt; is<br>&gt;&gt;&gt; &gt;&gt;&gt; only safe for access from one thread, I *need* compiler<br>&gt;&gt;&gt; enforcement.  I<br>&gt;&gt;&gt; &gt;&gt;&gt; *need* a guarantee that this ivar is only accessed through public<br>&gt;&gt;&gt; &gt;&gt;&gt; interface methods that can be audited to be threadsafe.  Simply a<br>&gt;&gt;&gt; &gt;&gt;&gt; doccomment that says &quot;bad programmer, don&#39;t do it&quot; is not enough.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I’m unsure what you are imagining here - compiler protection of class<br>&gt;&gt;&gt; &gt;&gt; details from within a closure completion handler that is also part of<br>&gt;&gt;&gt; &gt;&gt; your class definition? I believe you would only get this with this<br>&gt;&gt;&gt; local<br>&gt;&gt;&gt; &gt;&gt; scope proposal if you structured your code such that callback blocks<br>&gt;&gt;&gt; &gt;&gt; were functions outside your type definition.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; If you are talking about access or modification of the inner state of<br>&gt;&gt;&gt; a<br>&gt;&gt;&gt; &gt;&gt; class and a manual audit of safety, that audit is of the file and not<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt; &gt;&gt; the type or extension. I’m unsure if your concern is of having to<br>&gt;&gt;&gt; split<br>&gt;&gt;&gt; &gt;&gt; code into multiple files for safety, or that there is not a way to<br>&gt;&gt;&gt; split<br>&gt;&gt;&gt; &gt;&gt; code into multiple files to achieve safety in some particular<br>&gt;&gt;&gt; scenario.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This is not even a matter of &quot;artistic choice&quot; of whether or not I<br>&gt;&gt;&gt; want<br>&gt;&gt;&gt; &gt;&gt;&gt; to follow &quot;one file per class&quot;.  I can achieve thread safety with<br>&gt;&gt;&gt; &gt;&gt;&gt; &quot;private&quot; ivars and &quot;one file per class&quot;, but if my class is<br>&gt;&gt;&gt; &gt;&gt;&gt; UITableViewCellContentView (which is an implementation detail that<br>&gt;&gt;&gt; &gt;&gt;&gt; should be hidden even to most of UIKit) I am now forced to expose<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; &gt;&gt;&gt; implementation detail to my entire team.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This places me in the unconscionable situation of choosing between<br>&gt;&gt;&gt; &gt;&gt;&gt; whether I have thread safety or encapsulation, between whether my<br>&gt;&gt;&gt; &gt;&gt;&gt; coworker will accidentally create a threading bug or accidentally<br>&gt;&gt;&gt; use a<br>&gt;&gt;&gt; &gt;&gt;&gt; class they ought not to use and I am unable to appropriately hide.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I’m not quite sure what you mean here - exposing that your class is a<br>&gt;&gt;&gt; &gt;&gt; subclass of UITableViewCellContentView? Or that the rest of your team<br>&gt;&gt;&gt; &gt;&gt; needs to code in different files from your class in order to maintain<br>&gt;&gt;&gt; encapsulation?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; It may be that I’m unfamiliar with UITableViewCellContentView (as it<br>&gt;&gt;&gt; is not documented).<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; &lt;snip&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; &gt;&gt;&gt; I&#39;ve followed this from the earliest discussions.  I&#39;ve rethought my<br>&gt;&gt;&gt; &gt;&gt;&gt; position somewhat in response to the growing uncertainty about<br>&gt;&gt;&gt; dropping<br>&gt;&gt;&gt; &gt;&gt;&gt; the NS prefix, which I think exposes some very real problems with<br>&gt;&gt;&gt; visibility in Swift.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; As that situation has developed, I no longer believe this proposal<br>&gt;&gt;&gt; goes<br>&gt;&gt;&gt; &gt;&gt;&gt; far enough.  But it does go somewhere, and we should not stay where<br>&gt;&gt;&gt; we are.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I don’t understand how an access control proposal pertains to changes<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt; &gt;&gt; the Foundation public API. What is the ideal end state in your mind,<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; &gt;&gt; in what way is this a step toward that?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -DW<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/b9faa4b8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
