<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I’m interested in taking SR-340 &lt;https://bugs.swift.org/browse/SR-340&gt; issue:<br>&quot;parseSILInstruction is horrible and makes me cry every time I see it. It is a method that is ~1900 lines with a huge switch in it. We should refactor it into a visitor structure. In fact it is large enough that we should consider moving it into its own file if it is possible.&quot;<br></p><p>Here is the first draft of the myl idea, how it could be approached:<br></p><p>1. We will define an abstract method on ValueBase class:<br></p><p>    class ValueBase<br>    {<br>    public:<br>        virtual void parse(class SILParseInstruction*) = 0;<br>    };<br>    <br></p><p>2. Each of the SIL instruction classes will override this method and will provide the following implementation:<br>    <br>    class SILArgument: public ValueBase<br>    {<br>    public:<br>        /*virtual*/void parse(SILParseInstruction*);<br>    };<br>    void SILArgument::parse(SILParseInstruction *i) {<br>        i-&gt;parseInstruction(this);<br>    }<br>    <br>    class PartialApplyInst: public ValueBase<br>    {<br>    public:<br>        /*virtual*/void parse(SILParseInstruction*);<br>    };<br>    void PartialApplyInst::parse(SILParseInstruction *i)<br>    {<br>        i-&gt;parseInstruction(this);<br>    }<br>    <br></p><p>3. We will define an abstract class for the callbacks from each of the SIL instruction classes<br></p><p>    class SILParseInstruction<br>    {<br>    public:<br>        virtual void parseInstruction(SILArgument*) = 0;<br>        virtual void parseInstruction(PartialApplyInst*) = 0;<br>    };<br></p><p>4. SILParser will implement these callbacks with the actual handling operations for each instruction. <br>    <br>    class SILParser: public SILParseInstruction<br>    {<br>    public:<br>        /*virtual*/void parseInstruction(SILArgument *r)<br>        {<br>            // Parse StringLiteralInst instruction<br>        }<br>        /*virtual*/void parseInstruction(PartialApplyInst *b)<br>        {<br>            // Parse PartialApplyInst instruction<br>        }<br>    };<br>    <br>5. The huge switch statement will be replaced with a single call:<br>	Opcode-&gt;parse(this);<br></p><p>What are your thoughts?<br></p><p>Sergey<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/29e2392a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br></p><p>If this were Swift, we could use an extension, but alas. :-)<br></p><p>That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 13, 2016, at 13:27, Sergey Bolshedvorsky via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I’m interested in taking SR-340 &lt;https://bugs.swift.org/browse/SR-340&gt; issue:<br>&gt; &quot;parseSILInstruction is horrible and makes me cry every time I see it. It is a method that is ~1900 lines with a huge switch in it. We should refactor it into a visitor structure. In fact it is large enough that we should consider moving it into its own file if it is possible.&quot;<br>&gt; <br>&gt; Here is the first draft of the myl idea, how it could be approached:<br>&gt; <br>&gt; 1. We will define an abstract method on ValueBase class:<br>&gt; <br>&gt;     class ValueBase<br>&gt;     {<br>&gt;     public:<br>&gt;         virtual void parse(class SILParseInstruction*) = 0;<br>&gt;     };<br>&gt;     <br>&gt; <br>&gt; 2. Each of the SIL instruction classes will override this method and will provide the following implementation:<br>&gt;     <br>&gt;     class SILArgument: public ValueBase<br>&gt;     {<br>&gt;     public:<br>&gt;         /*virtual*/void parse(SILParseInstruction*);<br>&gt;     };<br>&gt;     void SILArgument::parse(SILParseInstruction *i) {<br>&gt;         i-&gt;parseInstruction(this);<br>&gt;     }<br>&gt;     <br>&gt;     class PartialApplyInst: public ValueBase<br>&gt;     {<br>&gt;     public:<br>&gt;         /*virtual*/void parse(SILParseInstruction*);<br>&gt;     };<br>&gt;     void PartialApplyInst::parse(SILParseInstruction *i)<br>&gt;     {<br>&gt;         i-&gt;parseInstruction(this);<br>&gt;     }<br>&gt;     <br>&gt; <br>&gt; 3. We will define an abstract class for the callbacks from each of the SIL instruction classes<br>&gt; <br>&gt;     class SILParseInstruction<br>&gt;     {<br>&gt;     public:<br>&gt;         virtual void parseInstruction(SILArgument*) = 0;<br>&gt;         virtual void parseInstruction(PartialApplyInst*) = 0;<br>&gt;     };<br>&gt; <br>&gt; 4. SILParser will implement these callbacks with the actual handling operations for each instruction. <br>&gt;     <br>&gt;     class SILParser: public SILParseInstruction<br>&gt;     {<br>&gt;     public:<br>&gt;         /*virtual*/void parseInstruction(SILArgument *r)<br>&gt;         {<br>&gt;             // Parse StringLiteralInst instruction<br>&gt;         }<br>&gt;         /*virtual*/void parseInstruction(PartialApplyInst *b)<br>&gt;         {<br>&gt;             // Parse PartialApplyInst instruction<br>&gt;         }<br>&gt;     };<br>&gt;     <br>&gt; 5. The huge switch statement will be replaced with a single call:<br>&gt; 	Opcode-&gt;parse(this);<br>&gt; <br>&gt; What are your thoughts?<br>&gt; <br>&gt; Sergey<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/0439e733/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt; <br>&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt; <br>&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br></p><p>I agree with you completely.<br></p><p>Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser.  Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt; <br>&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt; <br>&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt; <br>&gt; I agree with you completely.<br>&gt; <br>&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser.  Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br></p><p>The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br></p><p>Michael<br></p><p>&gt; <br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 13, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:08 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt;&gt; <br>&gt;&gt; I agree with you completely.<br>&gt;&gt; <br>&gt;&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser. Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br>&gt; <br>&gt; The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br></p><p>Let me rephrase. IIRC the way that this code is written is it first deserializes the value kind. Imagine if we had a visitor that was composed with the parser whose visitor methods would perform the relevant parsing.<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160113/e7c27a9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>January 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Michael,<br></p><p>The simplest way is to keep the switch statement in the parseSILInstruction method and move all logic into parser routines.  Is it right?<br></p><p>bool SILParser::parseSILInstruction(SILBasicBlock *BB) {<br>  // Header<br></p><p>  switch (Opcode) {<br>  case ValueKind::SILArgument: <br>    return handleValueKindSILArgument(Opcode); <br>    break;<br>  case ValueKind::AllocBoxInst: <br>    return handleValueKindAllocBoxInst(Opcode);<br>    break;<br>  case ValueKind::ApplyInst:<br>    return handleValueKindApplyInst(Opcode);<br>    break;<br>  // ...<br>  }<br>}<br></p><p>SILParser::handleValueKindSILArgument(ValueKind Opcode) {<br>  // Handle ValueKind::SILArgument case here<br>}<br></p><p>SILParser::handleValueKindAllocBoxInst(ValueKind Opcode) {<br>  // Handle ValueKind::AllocBoxInst case here<br>}<br></p><p>SILParser::handleValueKindApplyInst(ValueKind Opcode) {<br>  // Handle ValueKind::ApplyInst case here  <br>}<br></p><p>By the way, I’ve noticed that some instructions are getting parsed by parser routines already: parseSILFunctionRef or parseCallInstruction.<br></p><p>Sergey<br></p><p>Sent from my iPhone<br></p><p>&gt; On 14 Jan 2016, at 06:00, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 9:08 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with you completely.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser. Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br>&gt;&gt; <br>&gt;&gt; The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br>&gt; <br>&gt; Let me rephrase. IIRC the way that this code is written is it first deserializes the value kind. Imagine if we had a visitor that was composed with the parser whose visitor methods would perform the relevant parsing.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160114/cfc5a207/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>January 14, 2016 at 11:00:00am</p></header><div class="content"><p>No I mean like this:<br></p><p>1. Add a visitor in SILVisitor.h that just switches on value base.<br>2. Define a composition class with SILParser:<br></p><p>class SILInstructionParser {<br>   SILParser *P;<br></p><p>   ValueBase *visitValueBase() { llvm_unreachable(&quot;Unimplemented method&quot;); }<br>   ValueBase *visitSILArgument.<br>};<br></p><p>...<br></p><p>SILValue SILInstructionParser::visitSILArgument() {<br>  ...<br>}<br></p><p>SILValue SILInstructionParser::visitAllocBoxInst() {<br>   ...<br>}<br></p><p>Michael<br></p><p>&gt; On Jan 14, 2016, at 9:00 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com&gt; wrote:<br>&gt; <br>&gt; Michael,<br>&gt; <br>&gt; The simplest way is to keep the switch statement in the parseSILInstruction method and move all logic into parser routines.  Is it right?<br>&gt; <br>&gt; bool SILParser::parseSILInstruction(SILBasicBlock *BB) {<br>&gt;   // Header<br>&gt; <br>&gt;   switch (Opcode) {<br>&gt;   case ValueKind::SILArgument: <br>&gt;     return handleValueKindSILArgument(Opcode); <br>&gt;     break;<br>&gt;   case ValueKind::AllocBoxInst: <br>&gt;     return handleValueKindAllocBoxInst(Opcode);<br>&gt;     break;<br>&gt;   case ValueKind::ApplyInst:<br>&gt;     return handleValueKindApplyInst(Opcode);<br>&gt;     break;<br>&gt;   // ...<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; SILParser::handleValueKindSILArgument(ValueKind Opcode) {<br>&gt;   // Handle ValueKind::SILArgument case here<br>&gt; }<br>&gt; <br>&gt; SILParser::handleValueKindAllocBoxInst(ValueKind Opcode) {<br>&gt;   // Handle ValueKind::AllocBoxInst case here<br>&gt; }<br>&gt; <br>&gt; SILParser::handleValueKindApplyInst(ValueKind Opcode) {<br>&gt;   // Handle ValueKind::ApplyInst case here  <br>&gt; }<br>&gt; <br>&gt; By the way, I’ve noticed that some instructions are getting parsed by parser routines already: parseSILFunctionRef or parseCallInstruction.<br>&gt; <br>&gt; Sergey<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On 14 Jan 2016, at 06:00, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 13, 2016, at 9:08 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with you completely.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser. Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br>&gt;&gt; <br>&gt;&gt; Let me rephrase. IIRC the way that this code is written is it first deserializes the value kind. Imagine if we had a visitor that was composed with the parser whose visitor methods would perform the relevant parsing.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160114/03150449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c56b98ce889653412aa0f3d6ab6a0263?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>Sergey Bolshedvorsky</string> &lt;sergey at bolshedvorsky.com&gt;<p>January 17, 2016 at 05:00:00pm</p></header><div class="content"><p>After few hours of research I think I have a clear picture what needs to be done. <br></p><p>The switch statement in bool SILParser::parseSILInstruction(SILBasicBlock *BB) will be replaced with few lines of code similar to these:<br></p><p>SILInstructionParser InstructionParser(*this);<br>ResultVal = InstructionParser.visit(Opcode);<br></p><p><br>There is going to be a new class with all visit methods:<br>namespace {<br>  class SILInstructionParser<br>    : public SILVisitor&lt;SILInstructionParser, ValueBase&gt; {<br>    public:<br>      SILParser &amp;P;<br>      <br>      SILInstructionParser(SILParser &amp;P): P(P) {}<br>      <br>//      ValueBase visitSILArgument(ValueBase opcode) {<br>//        llvm_unreachable(&quot;not an instruction&quot;);<br>//      }<br>//<br>//      ValueBase visitSILUndef(ValueBase opcode) {<br>//        llvm_unreachable(&quot;not an instruction&quot;);<br>//      }<br>    };<br>} // end anonymous namespace<br></p><p>And there is going to be a new method on SILVisitor, what will map opcode to the SILInstructionParser methods, something similar to:<br>  ValueRetTy visit(ValueBase *V) {<br>    switch (V-&gt;getKind()) {<br>#define VALUE(CLASS, PARENT)                                \<br>  case ValueKind::CLASS:                                    \<br>    return asImpl().visit##CLASS(static_cast&lt;CLASS*&gt;(V));<br>#include &quot;swift/SIL/SILNodes.def&quot;<br>    }<br>    llvm_unreachable(&quot;Not reachable, all cases handled&quot;);<br>  }<br></p><p>Is there a way how I can run only preprocessor, something similar to -E option for GCC? <br>I’m getting build error with my changes and I would like to see the output for the SILVisitor class.<br></p><p>Sergey<br></p><p><br>&gt; On 14 Jan 2016, at 19:27, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; No I mean like this:<br>&gt; <br>&gt; 1. Add a visitor in SILVisitor.h that just switches on value base.<br>&gt; 2. Define a composition class with SILParser:<br>&gt; <br>&gt; class SILInstructionParser {<br>&gt;    SILParser *P;<br>&gt; <br>&gt;    ValueBase *visitValueBase() { llvm_unreachable(&quot;Unimplemented method&quot;); }<br>&gt;    ValueBase *visitSILArgument.<br>&gt; };<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; SILValue SILInstructionParser::visitSILArgument() {<br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; SILValue SILInstructionParser::visitAllocBoxInst() {<br>&gt;    ...<br>&gt; }<br>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; On Jan 14, 2016, at 9:00 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com &lt;mailto:sergey at bolshedvorsky.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Michael,<br>&gt;&gt; <br>&gt;&gt; The simplest way is to keep the switch statement in the parseSILInstruction method and move all logic into parser routines.  Is it right?<br>&gt;&gt; <br>&gt;&gt; bool SILParser::parseSILInstruction(SILBasicBlock *BB) {<br>&gt;&gt;   // Header<br>&gt;&gt; <br>&gt;&gt;   switch (Opcode) {<br>&gt;&gt;   case ValueKind::SILArgument: <br>&gt;&gt;     return handleValueKindSILArgument(Opcode); <br>&gt;&gt;     break;<br>&gt;&gt;   case ValueKind::AllocBoxInst: <br>&gt;&gt;     return handleValueKindAllocBoxInst(Opcode);<br>&gt;&gt;     break;<br>&gt;&gt;   case ValueKind::ApplyInst:<br>&gt;&gt;     return handleValueKindApplyInst(Opcode);<br>&gt;&gt;     break;<br>&gt;&gt;   // ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; SILParser::handleValueKindSILArgument(ValueKind Opcode) {<br>&gt;&gt;   // Handle ValueKind::SILArgument case here<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; SILParser::handleValueKindAllocBoxInst(ValueKind Opcode) {<br>&gt;&gt;   // Handle ValueKind::AllocBoxInst case here<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; SILParser::handleValueKindApplyInst(ValueKind Opcode) {<br>&gt;&gt;   // Handle ValueKind::ApplyInst case here  <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; By the way, I’ve noticed that some instructions are getting parsed by parser routines already: parseSILFunctionRef or parseCallInstruction.<br>&gt;&gt; <br>&gt;&gt; Sergey<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On 14 Jan 2016, at 06:00, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 13, 2016, at 9:08 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with you completely.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser. Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me rephrase. IIRC the way that this code is written is it first deserializes the value kind. Imagine if we had a visitor that was composed with the parser whose visitor methods would perform the relevant parsing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Michael<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160117/10911b13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Draft Proposal] Refactor SILParser::parseSILInstruction</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 17, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 17, 2016, at 9:02 AM, Sergey Bolshedvorsky via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; After few hours of research I think I have a clear picture what needs to be done. <br>&gt; <br>&gt; The switch statement in bool SILParser::parseSILInstruction(SILBasicBlock *BB) will be replaced with few lines of code similar to these:<br>&gt; <br>&gt; SILInstructionParser InstructionParser(*this);<br>&gt; ResultVal = InstructionParser.visit(Opcode);<br>&gt; <br>&gt; <br>&gt; There is going to be a new class with all visit methods:<br>&gt; namespace {<br>&gt;   class SILInstructionParser<br>&gt;     : public SILVisitor&lt;SILInstructionParser, ValueBase&gt; {<br>&gt;     public:<br>&gt;       SILParser &amp;P;<br>&gt;       <br>&gt;       SILInstructionParser(SILParser &amp;P): P(P) {}<br>&gt;       <br>&gt; //      ValueBase visitSILArgument(ValueBase opcode) {<br>&gt; //        llvm_unreachable(&quot;not an instruction&quot;);<br>&gt; //      }<br>&gt; //<br>&gt; //      ValueBase visitSILUndef(ValueBase opcode) {<br>&gt; //        llvm_unreachable(&quot;not an instruction&quot;);<br>&gt; //      }<br>&gt;     };<br>&gt; } // end anonymous namespace<br>&gt; <br>&gt; And there is going to be a new method on SILVisitor, what will map opcode to the SILInstructionParser methods, something similar to:<br>&gt;   ValueRetTy visit(ValueBase *V) {<br>&gt;     switch (V-&gt;getKind()) {<br>&gt; #define VALUE(CLASS, PARENT)                                \<br>&gt;   case ValueKind::CLASS:                                    \<br>&gt;     return asImpl().visit##CLASS(static_cast&lt;CLASS*&gt;(V));<br>&gt; #include &quot;swift/SIL/SILNodes.def&quot;<br>&gt;     }<br>&gt;     llvm_unreachable(&quot;Not reachable, all cases handled&quot;);<br>&gt;   }<br>&gt; <br>&gt; Is there a way how I can run only preprocessor, something similar to -E option for GCC? <br></p><p>-E should work on any Unix-like C compiler.<br></p><p>Using an x-macro expansion like the above in the SILInstructionParser implementation makes sense; I don’t think there’s any point in adding it to SILVisitor, though.<br></p><p>John.<br></p><p>&gt; I’m getting build error with my changes and I would like to see the output for the SILVisitor class.<br>&gt; <br>&gt; Sergey<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Jan 2016, at 19:27, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; No I mean like this:<br>&gt;&gt; <br>&gt;&gt; 1. Add a visitor in SILVisitor.h that just switches on value base.<br>&gt;&gt; 2. Define a composition class with SILParser:<br>&gt;&gt; <br>&gt;&gt; class SILInstructionParser {<br>&gt;&gt;    SILParser *P;<br>&gt;&gt; <br>&gt;&gt;    ValueBase *visitValueBase() { llvm_unreachable(&quot;Unimplemented method&quot;); }<br>&gt;&gt;    ValueBase *visitSILArgument.<br>&gt;&gt; };<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; SILValue SILInstructionParser::visitSILArgument() {<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; SILValue SILInstructionParser::visitAllocBoxInst() {<br>&gt;&gt;    ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Michael<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 14, 2016, at 9:00 AM, Sergey Bolshedvorsky &lt;sergey at bolshedvorsky.com &lt;mailto:sergey at bolshedvorsky.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Michael,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The simplest way is to keep the switch statement in the parseSILInstruction method and move all logic into parser routines.  Is it right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; bool SILParser::parseSILInstruction(SILBasicBlock *BB) {<br>&gt;&gt;&gt;   // Header<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   switch (Opcode) {<br>&gt;&gt;&gt;   case ValueKind::SILArgument: <br>&gt;&gt;&gt;     return handleValueKindSILArgument(Opcode); <br>&gt;&gt;&gt;     break;<br>&gt;&gt;&gt;   case ValueKind::AllocBoxInst: <br>&gt;&gt;&gt;     return handleValueKindAllocBoxInst(Opcode);<br>&gt;&gt;&gt;     break;<br>&gt;&gt;&gt;   case ValueKind::ApplyInst:<br>&gt;&gt;&gt;     return handleValueKindApplyInst(Opcode);<br>&gt;&gt;&gt;     break;<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SILParser::handleValueKindSILArgument(ValueKind Opcode) {<br>&gt;&gt;&gt;   // Handle ValueKind::SILArgument case here<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SILParser::handleValueKindAllocBoxInst(ValueKind Opcode) {<br>&gt;&gt;&gt;   // Handle ValueKind::AllocBoxInst case here<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SILParser::handleValueKindApplyInst(ValueKind Opcode) {<br>&gt;&gt;&gt;   // Handle ValueKind::ApplyInst case here  <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By the way, I’ve noticed that some instructions are getting parsed by parser routines already: parseSILFunctionRef or parseCallInstruction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sergey<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 14 Jan 2016, at 06:00, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 9:08 PM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:35 PM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 3:25 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hey, Sergey. It definitely makes sense to refactor this, but I don&#39;t think putting methods on SILInstruction is the way to go about it. There&#39;s no reason most clients of SIL need to know anything about parsing; from a separation-of-concerns perspective it belongs in a separate header and very likely a separate component (i.e. not lib/SIL/).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If this were Swift, we could use an extension, but alas. :-)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, I&#39;m not a heavy user of SIL, so someone else from the Swift team with more of a stake should comment.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with you completely.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, the SIL instruction parser does not actually have an instance of an instruction to perform virtual dispatch on.  Nor should we introduce the concept of “wireframe” instructions just for the convenience of the parser. Redundancy between cases here should be addressed with normal redundancy elimination techniques, i.e. macros and templates.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The way to do this is to have a visitor parser that takes in a ValueKind and maps it to the parser routine to use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me rephrase. IIRC the way that this code is written is it first deserializes the value kind. Imagine if we had a visitor that was composed with the parser whose visitor methods would perform the relevant parsing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Michael<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160117/41bff512/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
