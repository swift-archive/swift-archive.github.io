<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: allow delegating from a throwing initializer to a failable initializer</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 09:00:00pm</p></header><div class="content"><p>It is not currently possible to call a failable (optional) initializer from a throwing initializer.  This is unfortunate as many Cocoa initializers are failable and it is desirable to be able to extend Cocoa types with throwing convenience initializers that call a failable (optional) designated initializer.<br></p><p>For example, something similar to the following should be possible:<br></p><p>enum CustomError: ErrorType { case E }<br></p><p>struct S {<br>    let urlString: String<br>}<br></p><p>extension NSURL {<br>    convenience init(s: S) throws {<br>        guard self.init(string: s.urlString)<br>            else { throw CustomError.E }<br>    }<br>}<br></p><p>In the current language, even if the compiler preventing us from calling the failable initializer we would not be able to access the return value in the guard expression.  Furthermore, even if we could an Optional expression would not be valid in a guard condition.  I am interested in ideas for how this should be handled.  Would there be a special case of the guard statement to allow this?  Or should some other mechanism be used to guarantee that we either successfully complete initialization or throw?<br></p><p>As an aside, the term ‘failable initializer’  implies to me any initializer that can fail, whether by returning an optional or by throwing.  I think it would be best if we adopt more precise terminology to refer to ‘optional initializers’ and ‘throwing initializers’.  I welcome any feedback on this idea.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: allow delegating from a throwing initializer to a failable initializer</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 12, 2015, at 7:55 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It is not currently possible to call a failable (optional) initializer from a throwing initializer.  This is unfortunate as many Cocoa initializers are failable and it is desirable to be able to extend Cocoa types with throwing convenience initializers that call a failable (optional) designated initializer.<br>&gt; <br>&gt; For example, something similar to the following should be possible:<br>&gt; <br>&gt; enum CustomError: ErrorType { case E }<br>&gt; <br>&gt; struct S {<br>&gt;    let urlString: String<br>&gt; }<br>&gt; <br>&gt; extension NSURL {<br>&gt;    convenience init(s: S) throws {<br>&gt;        guard self.init(string: s.urlString)<br>&gt;            else { throw CustomError.E }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; In the current language, even if the compiler preventing us from calling the failable initializer we would not be able to access the return value in the guard expression.  Furthermore, even if we could an Optional expression would not be valid in a guard condition.  I am interested in ideas for how this should be handled.  Would there be a special case of the guard statement to allow this?  Or should some other mechanism be used to guarantee that we either successfully complete initialization or throw?<br></p><p>Definitive initialization already ensures things like this; it should be straightforward to check the additional control-flow rules here if we can decide on how to write the check syntactically.<br></p><p>One constraint is that subobject initializers cannot allow “retries” after the delegating call, since user code can&#39;t distinguish semantically between failures that occurred before the instance was fully initialized (which can in principle be retried) and failures which occurred afterwards (which cannot, because the object may have escaped).<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: allow delegating from a throwing initializer to a failable initializer</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 11:43 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 7:55 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; It is not currently possible to call a failable (optional) initializer from a throwing initializer.  This is unfortunate as many Cocoa initializers are failable and it is desirable to be able to extend Cocoa types with throwing convenience initializers that call a failable (optional) designated initializer.<br>&gt;&gt; <br>&gt;&gt; For example, something similar to the following should be possible:<br>&gt;&gt; <br>&gt;&gt; enum CustomError: ErrorType { case E }<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let urlString: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL {<br>&gt;&gt;   convenience init(s: S) throws {<br>&gt;&gt;       guard self.init(string: s.urlString)<br>&gt;&gt;           else { throw CustomError.E }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In the current language, even if the compiler preventing us from calling the failable initializer we would not be able to access the return value in the guard expression. Furthermore, even if we could an Optional expression would not be valid in a guard condition.  I am interested in ideas for how this should be handled.  Would there be a special case of the guard statement to allow this?  Or should some other mechanism be used to guarantee that we either successfully complete initialization or throw?<br>&gt; <br>&gt; Definitive initialization already ensures things like this; it should be straightforward to check the additional control-flow rules here if we can decide on how to write the check syntactically.<br>&gt; <br>&gt; One constraint is that subobject initializers cannot allow “retries” after the delegating call, since user code can&#39;t distinguish semantically between failures that occurred before the instance was fully initialized (which can in principle be retried) and failures which occurred afterwards (which cannot, because the object may have escaped).<br></p><p>Right, the compiler would need to prove that the failure path from self.init returning nil could never lead to a normal return (it has to throw, abort, infinite loop, whatever).<br></p><p>Personally, I consider this an implementation limitation that doesn’t need an evolution proposal.  Someone with a good patch to implement this would be welcome to submit a PR.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
