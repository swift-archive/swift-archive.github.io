<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Lazy flatMap for Optionals</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December  4, 2015 at 10:00:00pm</p></header><div class="content"><p>Currently, several of the methods on SequenceType in the standard library have lazy variants. flatMap, though, (seems) to have a version missing: while there’s a lazy version for nested sequences, there’s no lazy version for sequences of Optionals. Is there maybe a reason for this that I haven’t thought of? At any rate, here’s what I had in mind:<br></p><p>public struct FlatMapOptionalGenerator&lt;G: GeneratorType, Element&gt;: GeneratorType {<br>  private let f: G.Element -&gt; Element?<br>  private var g: G<br>  public mutating func next() -&gt; Element? {<br>    while let x = g.next() {<br>      if let y = f(x) {<br>        return y<br>      }<br>    }<br>    return nil<br>  }<br>}<br></p><p>public struct FlatMapOptionalSequence&lt;S: LazySequenceType, Element&gt;: LazySequenceType {<br>  private let f: S.Generator.Element -&gt; Element?<br>  private let s: S<br>  public func generate() -&gt; FlatMapOptionalGenerator&lt;S.Generator, Element&gt; {<br>    return FlatMapOptionalGenerator(f: f, g: s.generate())<br>  }<br>}<br></p><p>extension LazySequenceType {<br>  public func flatMap&lt;T&gt;(transform: Generator.Element -&gt; T?) -&gt; FlatMapOptionalSequence&lt;Self, T&gt; {<br>    return FlatMapOptionalSequence(f: transform, s: self)<br>  }<br>}<br></p><p>Does this seem like a good idea?<br></p><p>Oisin.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/80612439/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Lazy flatMap for Optionals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  4, 2015 at 11:00:00pm</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney &lt;<br>oisin.kidney at gmail.com&gt; wrote:<br></p><p>&gt; Currently, several of the methods on SequenceType in the standard library<br>&gt; have lazy variants. flatMap, though, (seems) to have a version missing:<br>&gt; while there’s a lazy version for nested sequences, there’s no lazy version<br>&gt; for sequences of Optionals. Is there maybe a reason for this that I<br>&gt; haven’t thought of? At any rate, here’s what I had in mind:<br>&gt;<br>&gt; public struct FlatMapOptionalGenerator&lt;G: GeneratorType, Element&gt;:<br>&gt; GeneratorType {<br>&gt;   private let f: G.Element -&gt; Element?<br>&gt;   private var g: G<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     while let x = g.next() {<br>&gt;       if let y = f(x) {<br>&gt;         return y<br>&gt;       }<br>&gt;     }<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; public struct FlatMapOptionalSequence&lt;S: LazySequenceType, Element&gt;:<br>&gt; LazySequenceType {<br>&gt;   private let f: S.Generator.Element -&gt; Element?<br>&gt;   private let s: S<br>&gt;   public func generate() -&gt; FlatMapOptionalGenerator&lt;S.Generator, Element&gt;<br>&gt; {<br>&gt;     return FlatMapOptionalGenerator(f: f, g: s.generate())<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension LazySequenceType {<br>&gt;   public func flatMap&lt;T&gt;(transform: Generator.Element -&gt; T?) -&gt;<br>&gt; FlatMapOptionalSequence&lt;Self, T&gt; {<br>&gt;     return FlatMapOptionalSequence(f: transform, s: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Does this seem like a good idea?<br>&gt;<br></p><p>Hi Oisin,<br></p><p>This is just an omission.  Please submit a formal proposal as a pull<br>request to the swift-evolution repository.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/81d1765a/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Lazy flatMap for Optionals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  6, 2015 at 01:00:00am</p></header><div class="content"><p>On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney &lt;<br>oisin.kidney at gmail.com&gt; wrote:<br></p><p>&gt; Currently, several of the methods on SequenceType in the standard library<br>&gt; have lazy variants. flatMap, though, (seems) to have a version missing:<br>&gt; while there’s a lazy version for nested sequences, there’s no lazy version<br>&gt; for sequences of Optionals. Is there maybe a reason for this that I<br>&gt; haven’t thought of? At any rate, here’s what I had in mind:<br>&gt;<br>&gt; public struct FlatMapOptionalGenerator&lt;G: GeneratorType, Element&gt;:<br>&gt; GeneratorType {<br>&gt;   private let f: G.Element -&gt; Element?<br>&gt;   private var g: G<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     while let x = g.next() {<br>&gt;       if let y = f(x) {<br>&gt;         return y<br>&gt;       }<br>&gt;     }<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; public struct FlatMapOptionalSequence&lt;S: LazySequenceType, Element&gt;:<br>&gt; LazySequenceType {<br>&gt;   private let f: S.Generator.Element -&gt; Element?<br>&gt;   private let s: S<br>&gt;   public func generate() -&gt; FlatMapOptionalGenerator&lt;S.Generator, Element&gt;<br>&gt; {<br>&gt;     return FlatMapOptionalGenerator(f: f, g: s.generate())<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; extension LazySequenceType {<br>&gt;   public func flatMap&lt;T&gt;(transform: Generator.Element -&gt; T?) -&gt;<br>&gt; FlatMapOptionalSequence&lt;Self, T&gt; {<br>&gt;     return FlatMapOptionalSequence(f: transform, s: self)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>Hi,<br></p><p>Thank you for the proposal.<br></p><p>Defining only one overload would cause the collection-ness of the input to<br>be lost.  Please take a look at the current flatMap() overloads in<br>stdlib/public/core/FlatMap.swift: there&#39;s one in LazySequenceType, another<br>one in LazyCollectionType, and one more in LazyCollectionType with<br>bidirectional indices.<br></p><p>I&#39;m also not a fan of introducing a specialized result type for this<br>operation: given that we need three overloads, this approach would add six<br>more types to the library (three sequences and three generators).  Current<br>flatMap() overloads compose existing types, but they rely on intermediate<br>data structure being a sequence or a collection.  Optional is not a<br>sequence, so that exact approach won&#39;t work here.  Can you think of another<br>way we could combine existing types to express the result of this operation?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/8a2a6b1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Lazy flatMap for Optionals</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>(forgot to cc the mailing list)<br></p><p>You can define it in terms of a map-filter-map chain, like this:<br></p><p>extension LazySequenceType {<br>  <br>  @warn_unused_result<br>  public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?)<br>    -&gt; LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, T?&gt;&gt;, T&gt; {<br>      return self<br>        .map(transform)<br>        .filter { opt in opt != nil }<br>        .map { notNil in notNil! }<br>  }<br>}<br></p><p>The version for LazyCollectionType can be done similarly:<br></p><p>extension LazyCollectionType {<br>  <br>  @warn_unused_result<br>  public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?)<br>    -&gt; LazyMapCollection&lt;LazyFilterCollection&lt;LazyMapCollection&lt;Elements, T?&gt;&gt;, T&gt; {<br>      return self<br>        .map(transform)<br>        .filter { opt in opt != nil }<br>        .map { notNil in notNil! }<br>  }<br>}<br></p><p>There seems to be no performance overhead vs the custom struct version in my (very preliminary) testing.<br></p><p>The version for a LazyCollectionType with a BidirectionalIndexType would rely on a similar LazyFilterCollection, but a BidirectionalFilterCollection doesn’t exist (I think). Is that something that might be included in this proposal?<br></p><p>Oisin.<br></p><p>&gt; On 6 Dec 2015, at 09:11, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 4, 2015 at 2:38 PM, Donnacha Oisín Kidney &lt;oisin.kidney at gmail.com &lt;mailto:oisin.kidney at gmail.com&gt;&gt; wrote:<br>&gt; Currently, several of the methods on SequenceType in the standard library have lazy variants. flatMap, though, (seems) to have a version missing: while there’s a lazy version for nested sequences, there’s no lazy version for sequences of Optionals. Is there maybe a reason for this that I haven’t thought of? At any rate, here’s what I had in mind:<br>&gt; <br>&gt; public struct FlatMapOptionalGenerator&lt;G: GeneratorType, Element&gt;: GeneratorType {<br>&gt;   private let f: G.Element -&gt; Element?<br>&gt;   private var g: G<br>&gt;   public mutating func next() -&gt; Element? {<br>&gt;     while let x = g.next() {<br>&gt;       if let y = f(x) {<br>&gt;         return y<br>&gt;       }<br>&gt;     }<br>&gt;     return nil<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; public struct FlatMapOptionalSequence&lt;S: LazySequenceType, Element&gt;: LazySequenceType {<br>&gt;   private let f: S.Generator.Element -&gt; Element?<br>&gt;   private let s: S<br>&gt;   public func generate() -&gt; FlatMapOptionalGenerator&lt;S.Generator, Element&gt; {<br>&gt;     return FlatMapOptionalGenerator(f: f, g: s.generate())<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; extension LazySequenceType {<br>&gt;   public func flatMap&lt;T&gt;(transform: Generator.Element -&gt; T?) -&gt; FlatMapOptionalSequence&lt;Self, T&gt; {<br>&gt;     return FlatMapOptionalSequence(f: transform, s: self)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Thank you for the proposal.<br>&gt; <br>&gt; Defining only one overload would cause the collection-ness of the input to be lost.  Please take a look at the current flatMap() overloads in stdlib/public/core/FlatMap.swift: there&#39;s one in LazySequenceType, another one in LazyCollectionType, and one more in LazyCollectionType with bidirectional indices.<br>&gt; <br>&gt; I&#39;m also not a fan of introducing a specialized result type for this operation: given that we need three overloads, this approach would add six more types to the library (three sequences and three generators).  Current flatMap() overloads compose existing types, but they rely on intermediate data structure being a sequence or a collection.  Optional is not a sequence, so that exact approach won&#39;t work here.  Can you think of another way we could combine existing types to express the result of this operation?<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/50da7034/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Lazy flatMap for Optionals</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  6, 2015 at 05:00:00pm</p></header><div class="content"><p>On Sun, Dec 6, 2015 at 8:06 AM, Donnacha Oisín Kidney<br>&lt;oisin.kidney at gmail.com&gt; wrote:<br>&gt; (forgot to cc the mailing list)<br>&gt;<br>&gt; You can define it in terms of a map-filter-map chain, like this:<br>&gt;<br>&gt; extension LazySequenceType {<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?)<br>&gt;     -&gt; LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Elements, T?&gt;&gt;, T&gt;<br>&gt; {<br>&gt;       return self<br>&gt;         .map(transform)<br>&gt;         .filter { opt in opt != nil }<br>&gt;         .map { notNil in notNil! }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; The version for LazyCollectionType can be done similarly:<br>&gt;<br>&gt; extension LazyCollectionType {<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   public func flatMap&lt;T&gt;(transform: Elements.Generator.Element -&gt; T?)<br>&gt;     -&gt; LazyMapCollection&lt;LazyFilterCollection&lt;LazyMapCollection&lt;Elements,<br>&gt; T?&gt;&gt;, T&gt; {<br>&gt;       return self<br>&gt;         .map(transform)<br>&gt;         .filter { opt in opt != nil }<br>&gt;         .map { notNil in notNil! }<br>&gt;   }<br>&gt; }<br></p><p>I like this.<br></p><p>&gt; The version for a LazyCollectionType with a BidirectionalIndexType would<br>&gt; rely on a similar LazyFilterCollection, but a BidirectionalFilterCollection<br>&gt; doesn’t exist (I think). Is that something that might be included in this<br>&gt; proposal?<br></p><p>Indeed.  I think that would be a separate proposal.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
