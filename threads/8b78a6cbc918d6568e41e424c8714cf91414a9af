<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Change rules for implicit captures due to nested closure captures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>In Swift code today, when using nested closures, if the inner closure<br>weakly captures an object (e.g. `self`) that isn&#39;t otherwise captured by<br>the outer closure, the outer closure implicitly strongly captures the<br>object. This behavior is unlikely to be what the programmer intended,<br>and results in unwanted object lifetime extension without making it<br>obvious in the code.<br></p><p>In practice, you&#39;ll find this happening in code that looks like<br></p><p>class SomeViewController: UIViewController {    // ...    func<br>foo(url: NSURL) {        let task =<br>NSURLSession.sharedSession().dataTaskWithURL(url) { data, response,<br>error in            let result = // process data<br>dispatch_async(dispatch_get_main_queue()) { [weak self] in<br>self?.handleResult(result)            }        }<br>task.resume()    } }<br></p><p>In here, at first glance it looks like the view controller is being<br>weakly referenced. But in actuality, the view controller is being<br>retained for the duration of the background processing, and is then only<br>converted to a weak reference at the moment where it tries to hop back<br>on to the main thread. So it&#39;s basically the worst of both worlds; the<br>view controller lives far longer than intended, but it goes away right<br>at the moment where it could be useful again. It&#39;s even worse if the<br>programmer expected the view controller&#39;s deinit() to cancel the network<br>task, as that can never happen. The fix for this code is to move the<br>`[weak self]` up to the outer closure, but since the outer closure never<br>actually touches self directly, it&#39;s not immediately obvious that this<br>is required.<br></p><p>My proposal is to change the rules so that whenever a closure captures<br>an object only because a nested closure did so, then the outer closure<br>should capture it using the same ownership semantics (this includes<br>unowned(unsafe), unowned(safe), weak, and strong). If there are multiple<br>nested closures that capture it, then we use the following rules:<br></p><p>* If all nested captures use the same ownership, then the outer capture<br>  uses that ownership.<br>* If any nested capture is strong, the outer capture is strong.<br>* If at least one nested capture is weak, and at least one capture is<br>  unowned or unowned(unsafe), the outer capture is strong. This is<br>  because there&#39;s no (safe) way to convert from weak -&gt; unowned, or from<br>  unowned -&gt; weak, and we should not crash upon the creation of the<br>  nested closure, so the outer capture must be strong.<br>* If at least one nested capture is unowned(unsafe), and at least one<br>  nested capture is unowned(safe), then the outer capture is<br>  unowned(safe).<br></p><p>This can be visualized with the following diagram, where the outer<br>closures uses the right-most node that covers all the children:<br></p><p>.--- weak &lt;-------------------------------.        /<br>\ strong &lt;                                             + no capture<br>\                                           /         &#39;--- unowned(safe)<br>&lt;--- unowned(unsafe) --&#39;<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/8b78a9af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Change rules for implicit captures due to nested closure captures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>Good idea, Kevin. Something like this seems reasonable (though I admit I just skimmed the message). In the mean time, maybe we can add a warning for implicit captures with a different strength?<br></p><p>(I&#39;d also be happy to treat &quot;unowned&quot; + &quot;weak&quot; as &quot;error, be explicit&quot; rather than &quot;strong&quot;.)<br></p><p>There is one case where an explicit capture behaves differently from an implicit one: capturing local variables (as opposed to local constants). There&#39;s an example of this in the Swift Programming Language book, in the reference section: &quot;Capture Lists &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544&gt;&quot;.<br></p><p>Jordan<br></p><p>&gt; On Dec 8, 2015, at 12:44, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In Swift code today, when using nested closures, if the inner closure weakly captures an object (e.g. `self`) that isn&#39;t otherwise captured by the outer closure, the outer closure implicitly strongly captures the object. This behavior is unlikely to be what the programmer intended, and results in unwanted object lifetime extension without making it obvious in the code.<br>&gt;  <br>&gt; In practice, you&#39;ll find this happening in code that looks like<br>&gt;  <br>&gt; class SomeViewController: UIViewController {<br>&gt;     // ...<br>&gt;     func foo(url: NSURL) {<br>&gt;         let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>&gt;             let result = // process data<br>&gt;             dispatch_async(dispatch_get_main_queue()) { [weak self] in<br>&gt;                 self?.handleResult(result)<br>&gt;             }<br>&gt;         }<br>&gt;         task.resume()<br>&gt;     }<br>&gt; }<br>&gt;  <br>&gt; In here, at first glance it looks like the view controller is being weakly referenced. But in actuality, the view controller is being retained for the duration of the background processing, and is then only converted to a weak reference at the moment where it tries to hop back on to the main thread. So it&#39;s basically the worst of both worlds; the view controller lives far longer than intended, but it goes away right at the moment where it could be useful again. It&#39;s even worse if the programmer expected the view controller&#39;s deinit() to cancel the network task, as that can never happen. The fix for this code is to move the `[weak self]` up to the outer closure, but since the outer closure never actually touches self directly, it&#39;s not immediately obvious that this is required.<br>&gt;  <br>&gt; My proposal is to change the rules so that whenever a closure captures an object only because a nested closure did so, then the outer closure should capture it using the same ownership semantics (this includes unowned(unsafe), unowned(safe), weak, and strong). If there are multiple nested closures that capture it, then we use the following rules:<br>&gt;  <br>&gt; * If all nested captures use the same ownership, then the outer capture uses that ownership.<br>&gt; * If any nested capture is strong, the outer capture is strong.<br>&gt; * If at least one nested capture is weak, and at least one capture is unowned or unowned(unsafe), the outer capture is strong. This is because there&#39;s no (safe) way to convert from weak -&gt; unowned, or from unowned -&gt; weak, and we should not crash upon the creation of the nested closure, so the outer capture must be strong.<br>&gt; * If at least one nested capture is unowned(unsafe), and at least one nested capture is unowned(safe), then the outer capture is unowned(safe).<br>&gt;  <br>&gt; This can be visualized with the following diagram, where the outer closures uses the right-most node that covers all the children:<br>&gt;  <br>&gt;          .--- weak &lt;-------------------------------.<br>&gt;         /                                           \<br>&gt; strong &lt;                                             + no capture<br>&gt;         \                                           /<br>&gt;          &#39;--- unowned(safe) &lt;--- unowned(unsafe) --&#39;<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/dd6fb9c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Change rules for implicit captures due to nested closure captures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>On Tue, Dec 8, 2015, at 04:07 PM, Jordan Rose wrote:<br>&gt; Good idea, Kevin. Something like this seems reasonable (though I admit<br>&gt; I just skimmed the message). In the mean time, maybe we can add a<br>&gt; warning for implicit captures with a different strength?<br></p><p>A warning seems like a reasonable starting point. Maybe warn in 2.x, and<br>then switch over to the different capture rules for 3.x? That way we<br>wouldn&#39;t be changing the actual behavior of anyone&#39;s code until 3.x<br>(though I&#39;m willing to bet that nearly all affected cases are<br>unintentional strong captures, but changing variable lifetimes can still<br>have unexpected consequences).<br></p><p>&gt; (I&#39;d also be happy to treat &quot;unowned&quot; + &quot;weak&quot; as &quot;error, be explicit&quot;<br>&gt; rather than &quot;strong&quot;.)<br></p><p>Good idea.<br></p><p>&gt; There is one case where an explicit capture behaves differently from<br>&gt; an implicit one: capturing local variables (as opposed to local<br>&gt; constants). There&#39;s an example of this in the Swift Programming<br>&gt; Language book, in the reference section: &quot;Capture Lists[1]&quot;.<br></p><p>Good point. I was thinking primarily about captures of self, but the<br>rules would apply to other captures too.<br></p><p>I&#39;d actually like us to have some means by which to explicitly list a<br>local variable in a capture list and still retain the capture-by-<br>reference semantics. I&#39;m just not sure what that would look like.<br></p><p>That said, I&#39;m not sure if this will be a problem for anyone. I&#39;m trying<br>to come up with examples of code that will need to add an explicit<br>capture list to preserve current behavior, but that this capture list<br>will break an implicit by-reference capture in a way that matters. And<br>the best I can do is a contrived example that doesn&#39;t provide any<br>explanation for why it wants to maintain current behavior. Specifically,<br>the desired behavior here that breaks is having an outer closure capture<br>the variable by-reference, and then the inner closure constructs the<br>weak reference out of whatever value the variable has at the time the<br>outer closure is invoked:<br></p><p>class Obj: CustomDebugStringConvertible {    var name: String<br>init(name: String) {        self.name = name    }    var<br>debugDescription: String {        return &quot;Obj(name: \(String(reflecting:<br>name)))&quot;    } }<br></p><p>var obj: Obj = Obj(name: &quot;foo&quot;) let f = {    let g = { [weak obj] in<br>print(&quot;g: \(obj)&quot;)    }    g() } obj = Obj(name: &quot;bar&quot;) f()<br></p><p>And even that can recover the existing behavior by just adding a `_ =<br>obj` inside of the outer closure (as opposed to adding a capture list).<br></p><p>I&#39;d be interested to know if anyone can come up with a practical example<br>of code where this will be a problem.<br></p><p>-Kevin Ballard<br></p><p>&gt;&gt; On Dec 8, 2015, at 12:44, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; In Swift code today, when using nested closures, if the inner closure<br>&gt;&gt; weakly captures an object (e.g. `self`) that isn&#39;t otherwise captured<br>&gt;&gt; by the outer closure, the outer closure implicitly strongly captures<br>&gt;&gt; the object. This behavior is unlikely to be what the programmer<br>&gt;&gt; intended, and results in unwanted object lifetime extension without<br>&gt;&gt; making it obvious in the code.<br>&gt;&gt;<br>&gt;&gt; In practice, you&#39;ll find this happening in code that looks like<br>&gt;&gt;<br>&gt;&gt; class SomeViewController: UIViewController {    // ...    func<br>&gt;&gt; foo(url: NSURL) {        let task =<br>&gt;&gt; NSURLSession.sharedSession().dataTaskWithURL(url) { data, response,<br>&gt;&gt; error in            let result = // process data<br>&gt;&gt; dispatch_async(dispatch_get_main_queue()) { [weak self] in<br>&gt;&gt; self?.handleResult(result)            }        }<br>&gt;&gt; task.resume()    } }<br>&gt;&gt;<br>&gt;&gt; In here, at first glance it looks like the view controller is being<br>&gt;&gt; weakly referenced. But in actuality, the view controller is being<br>&gt;&gt; retained for the duration of the background processing, and is then<br>&gt;&gt; only converted to a weak reference at the moment where it tries to<br>&gt;&gt; hop back on to the main thread. So it&#39;s basically the worst of both<br>&gt;&gt; worlds; the view controller lives far longer than intended, but it<br>&gt;&gt; goes away right at the moment where it could be useful again. It&#39;s<br>&gt;&gt; even worse if the programmer expected the view controller&#39;s deinit()<br>&gt;&gt; to cancel the network task, as that can never happen. The fix for<br>&gt;&gt; this code is to move the `[weak self]` up to the outer closure, but<br>&gt;&gt; since the outer closure never actually touches self directly, it&#39;s<br>&gt;&gt; not immediately obvious that this is required.<br>&gt;&gt;<br>&gt;&gt; My proposal is to change the rules so that whenever a closure<br>&gt;&gt; captures an object only because a nested closure did so, then the<br>&gt;&gt; outer closure should capture it using the same ownership semantics<br>&gt;&gt; (this includes unowned(unsafe), unowned(safe), weak, and strong). If<br>&gt;&gt; there are multiple nested closures that capture it, then we use the<br>&gt;&gt; following rules:<br>&gt;&gt;<br>&gt;&gt; * If all nested captures use the same ownership, then the outer<br>&gt;&gt;   capture uses that ownership.<br>&gt;&gt; * If any nested capture is strong, the outer capture is strong.<br>&gt;&gt; * If at least one nested capture is weak, and at least one capture is<br>&gt;&gt;   unowned or unowned(unsafe), the outer capture is strong. This is<br>&gt;&gt;   because there&#39;s no (safe) way to convert from weak -&gt; unowned, or<br>&gt;&gt;   from unowned -&gt; weak, and we should not crash upon the creation of<br>&gt;&gt;   the nested closure, so the outer capture must be strong.<br>&gt;&gt; * If at least one nested capture is unowned(unsafe), and at least one<br>&gt;&gt;   nested capture is unowned(safe), then the outer capture is<br>&gt;&gt;   unowned(safe).<br>&gt;&gt;<br>&gt;&gt; This can be visualized with the following diagram, where the outer<br>&gt;&gt; closures uses the right-most node that covers all the children:<br>&gt;&gt;<br>&gt;&gt; .--- weak &lt;-------------------------------.        /<br>&gt;&gt; \ strong &lt;                                             + no capture<br>&gt;&gt; \                                           /         &#39;---<br>&gt;&gt; unowned(safe) &lt;--- unowned(unsafe) --&#39;<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID544<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/d5b6edbf/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
