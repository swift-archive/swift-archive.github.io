<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Some people opposed to Abstract Classes proposal (including myself) have<br>said that mixins could solve the problem better.<br>So I prepaired a proposal draft to add stored properties to protocols. Here<br>it is:<br>https://gist.github.com/Anton3/f0550922c1be0fc5447c<br></p><p>P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>extend protocols, which I mention in &quot;alternatives&quot;.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/f1f37f5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 27, 2016 at 12:00:00pm</p></header><div class="content"><p>Very interesting alternative!<br></p><p>I think my preferred implementation is to just add these capabilities to protocols directly, as I guess I just don’t see why we need to introduce a separate mixin type. Providing implementation directly within a protocol is definitely something I’d like in general; while extensions can be a nice way to structure complex protocols and types, sometimes simple cases just don’t really need them IMO, so that’d be nice as a general capability, not just for mixins.<br></p><p>&gt; On 27 Feb 2016, at 09:59, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some people opposed to Abstract Classes proposal (including myself) have said that mixins could solve the problem better.<br>&gt; So I prepaired a proposal draft to add stored properties to protocols. Here it is:<br>&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c &lt;https://gist.github.com/Anton3/f0550922c1be0fc5447c&gt;<br>&gt; <br>&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/52ff7176/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>I agree that adding those features to protocols is simpler. I switched the<br>main suggestion and the alternative.<br></p><p>2016-02-27 15:03 GMT+03:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br></p><p>&gt; Very interesting alternative!<br>&gt;<br>&gt; I think my preferred implementation is to just add these capabilities to<br>&gt; protocols directly, as I guess I just don’t see why we need to introduce a<br>&gt; separate mixin type. Providing implementation directly within a protocol is<br>&gt; definitely something I’d like in general; while extensions can be a nice<br>&gt; way to structure complex protocols and types, sometimes simple cases just<br>&gt; don’t really need them IMO, so that’d be nice as a general capability, not<br>&gt; just for mixins.<br>&gt;<br>&gt; On 27 Feb 2016, at 09:59, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt; said that mixins could solve the problem better.<br>&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt; Here it is:<br>&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;<br>&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/cad0802e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 28, 2016 at 08:00:00am</p></header><div class="content"><p>I see many problems with this proposal:<br></p><p>- The proposal doesn&#39;t provide a compelling example to change Swift.<br></p><p>- The proposal doesn&#39;t provide much detail. It glosses over the general concept.<br></p><p>- Protocols define a statement of conformance, not behavior. Adding instance variables and non-default methods is outside the scope of a protocol.<br></p><p>- However, the proposal does describe something closer to a mix-in. Given my experience with Ruby and mix-ins, I really can&#39;t support the notion of mix-ins in Swift. Instance variables defined by a mix-in cause many problems, and hence I don&#39;t see this proposal aligned with the direction of Swift.<br></p><p>-Patrick<br></p><p>Sent from my iPad Pro<br></p><p>&gt; On Feb 27, 2016, at 8:10 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that adding those features to protocols is simpler. I switched the main suggestion and the alternative.<br>&gt; <br>&gt; 2016-02-27 15:03 GMT+03:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; Very interesting alternative!<br>&gt;&gt; <br>&gt;&gt; I think my preferred implementation is to just add these capabilities to protocols directly, as I guess I just don’t see why we need to introduce a separate mixin type. Providing implementation directly within a protocol is definitely something I’d like in general; while extensions can be a nice way to structure complex protocols and types, sometimes simple cases just don’t really need them IMO, so that’d be nice as a general capability, not just for mixins.<br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Feb 2016, at 09:59, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have said that mixins could solve the problem better.<br>&gt;&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols. Here it is:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/f4091c39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 07:00:00pm</p></header><div class="content"><p>I now have 4 votes &quot;for&quot; separating this new entity from protocols.<br>Proposal changed.<br>I tried to solve the aforementioned issues except the last one, which<br>essentially compares mixins to abstract classes.<br>More &quot;bug reports&quot; welcome!<br></p><p>2016-02-28 16:47 GMT+03:00 Patrick R. Gili &lt;gili.patrick.r at gili-labs.com&gt;:<br></p><p>&gt; I see many problems with this proposal:<br>&gt;<br>&gt; - The proposal doesn&#39;t provide a compelling example to change Swift.<br>&gt;<br>&gt; - The proposal doesn&#39;t provide much detail. It glosses over the general<br>&gt; concept.<br>&gt;<br>&gt; - Protocols define a statement of conformance, not behavior. Adding<br>&gt; instance variables and non-default methods is outside the scope of a<br>&gt; protocol.<br>&gt;<br>&gt; - However, the proposal does describe something closer to a mix-in. Given<br>&gt; my experience with Ruby and mix-ins, I really can&#39;t support the notion of<br>&gt; mix-ins in Swift. Instance variables defined by a mix-in cause many<br>&gt; problems, and hence I don&#39;t see this proposal aligned with the direction of<br>&gt; Swift.<br>&gt;<br>&gt; -Patrick<br>&gt;<br>&gt; Sent from my iPad Pro<br>&gt;<br>&gt; On Feb 27, 2016, at 8:10 AM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree that adding those features to protocols is simpler. I switched the<br>&gt; main suggestion and the alternative.<br>&gt;<br>&gt; 2016-02-27 15:03 GMT+03:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt;&gt; Very interesting alternative!<br>&gt;&gt;<br>&gt;&gt; I think my preferred implementation is to just add these capabilities to<br>&gt;&gt; protocols directly, as I guess I just don’t see why we need to introduce a<br>&gt;&gt; separate mixin type. Providing implementation directly within a protocol is<br>&gt;&gt; definitely something I’d like in general; while extensions can be a nice<br>&gt;&gt; way to structure complex protocols and types, sometimes simple cases just<br>&gt;&gt; don’t really need them IMO, so that’d be nice as a general capability, not<br>&gt;&gt; just for mixins.<br>&gt;&gt;<br>&gt;&gt; On 27 Feb 2016, at 09:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt; Here it is:<br>&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;<br>&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/18417bb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 28, 2016 at 12:00:00pm</p></header><div class="content"><p>In the proposal, I would recommend stressing how this both subsumes<br>abstract classes and allows similar functionality on value types.<br></p><p>I would also recommend adding a more realistic mixin example such as<br>logging, where structs and classes want logging functionality but are not<br>or can&#39;t be LoggingObjects. This would show how it gives code reuse without<br>inheritance and how it would be better than abstract classes.<br></p><p>On Sun, Feb 28, 2016 at 11:43 AM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I now have 4 votes &quot;for&quot; separating this new entity from protocols.<br>&gt; Proposal changed.<br>&gt; I tried to solve the aforementioned issues except the last one, which<br>&gt; essentially compares mixins to abstract classes.<br>&gt; More &quot;bug reports&quot; welcome!<br>&gt;<br>&gt; 2016-02-28 16:47 GMT+03:00 Patrick R. Gili &lt;gili.patrick.r at gili-labs.com&gt;:<br>&gt;<br>&gt;&gt; I see many problems with this proposal:<br>&gt;&gt;<br>&gt;&gt; - The proposal doesn&#39;t provide a compelling example to change Swift.<br>&gt;&gt;<br>&gt;&gt; - The proposal doesn&#39;t provide much detail. It glosses over the general<br>&gt;&gt; concept.<br>&gt;&gt;<br>&gt;&gt; - Protocols define a statement of conformance, not behavior. Adding<br>&gt;&gt; instance variables and non-default methods is outside the scope of a<br>&gt;&gt; protocol.<br>&gt;&gt;<br>&gt;&gt; - However, the proposal does describe something closer to a mix-in. Given<br>&gt;&gt; my experience with Ruby and mix-ins, I really can&#39;t support the notion of<br>&gt;&gt; mix-ins in Swift. Instance variables defined by a mix-in cause many<br>&gt;&gt; problems, and hence I don&#39;t see this proposal aligned with the direction of<br>&gt;&gt; Swift.<br>&gt;&gt;<br>&gt;&gt; -Patrick<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad Pro<br>&gt;&gt;<br>&gt;&gt; On Feb 27, 2016, at 8:10 AM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree that adding those features to protocols is simpler. I switched<br>&gt;&gt; the main suggestion and the alternative.<br>&gt;&gt;<br>&gt;&gt; 2016-02-27 15:03 GMT+03:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; Very interesting alternative!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think my preferred implementation is to just add these capabilities to<br>&gt;&gt;&gt; protocols directly, as I guess I just don’t see why we need to introduce a<br>&gt;&gt;&gt; separate mixin type. Providing implementation directly within a protocol is<br>&gt;&gt;&gt; definitely something I’d like in general; while extensions can be a nice<br>&gt;&gt;&gt; way to structure complex protocols and types, sometimes simple cases just<br>&gt;&gt;&gt; don’t really need them IMO, so that’d be nice as a general capability, not<br>&gt;&gt;&gt; just for mixins.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 27 Feb 2016, at 09:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt;&gt; Here it is:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/26d0735a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 28, 2016, at 09:02, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the proposal, I would recommend stressing how this both subsumes abstract classes and allows similar functionality on value types.<br>&gt; <br></p><p>On the subject of ‘subsuming’…  it seems with this proposal we now have three approaches to solving the problem of code reuse/specialization: OOP, POP, and Mixin Oriented Programming (MOP).  The decision about which approach to use makes the learning curve steeper.  Perhaps there is some way to generalize or unify the three approaches, and flatten the learning curve?<br></p><p>In any case, I’m hesitant to add new directions to the language until the current ones have been given the benefit of some more time.<br></p><p>Matt<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&quot;Mixins&quot; is as an extension for POP that adds the ability to mix in stored<br>properties. Deciding by possibilities/power:<br>protocol &lt; class<br>[protocol, mixin] ~= class<br>~= means approximately equals<br></p><p>Classes are still more powerful in that they can be reference counted and<br>can form hierarchies of fully defined types. For all other purposes:<br>[protocol, mixin] = class<br></p><p>So we still have OOP and POP (class and struct), but POP gets enhanced.<br></p><p>&gt; &gt;* On Feb 28, 2016, at 09:02, Trent Nadeau via swift-evolution &lt;swift-evolution at swift.org &lt;http://swift.org&gt;&gt; wrote:<br>&gt; *&gt; &gt;* In the proposal, I would recommend stressing how this both subsumes abstract classes and allows similar functionality on value types.<br>&gt; *&gt;<br>&gt; On the subject of ‘subsuming’…  it seems with this proposal we now have three approaches to solving the problem of code reuse/specialization: OOP, POP, and Mixin Oriented Programming (MOP).  The decision about which approach to use makes the learning curve steeper.  Perhaps there is some way to generalize or unify the three approaches, and flatten the learning curve?<br>&gt;<br>&gt; In any case, I’m hesitant to add new directions to the language until the current ones have been given the benefit of some more time.<br>&gt;<br>&gt; Matt<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/b570e924/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 11:00:00pm</p></header><div class="content"><p>I have rewritten almost the whole proposal in the last 10 hours. I<br>encourage everyone interested to reread it and suggest fixes, improvements,<br>as well as new directions for discussion.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/ad28bc41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>February 28, 2016 at 04:00:00pm</p></header><div class="content"><p>It would be helpful if you include the new draft. Or at least a link to it.<br></p><p>&gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 29, 2016 at 01:00:00am</p></header><div class="content"><p>Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br></p><p>2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br></p><p>&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;<br>&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I<br>&gt; encourage everyone interested to reread it and suggest fixes, improvements,<br>&gt; as well as new directions for discussion.<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/0a4908bd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 28, 2016 at 07:00:00pm</p></header><div class="content"><p>The quoted portion of the proposal below doesn&#39;t make any sense to me.<br>Subclasses can&#39;t be value types. Do you mean the structs could have similar<br>functionality?<br></p><p>Firstly, only classes can inherit from such abstract classes, while it can<br>be easily seen that some subclasses ofCachingSerializable or SignalSender would<br>naturally have value semantics (be structs, in other words).<br></p><p>On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;<br>&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;<br>&gt;&gt; It would be helpful if you include the new draft. Or at least a link to<br>&gt;&gt; it.<br>&gt;&gt;<br>&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I<br>&gt;&gt; encourage everyone interested to reread it and suggest fixes, improvements,<br>&gt;&gt; as well as new directions for discussion.<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/35ad7362/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>February 28, 2016 at 08:00:00pm</p></header><div class="content"><p>I understood him to mean that abstract classes cannot be used for value types, but it would be natural to want that functionality. Mixins would provide that capability for value types as well as classes.<br></p><p>&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me. Subclasses can&#39;t be value types. Do you mean the structs could have similar functionality?<br>&gt; <br>&gt; Firstly, only classes can inherit from such abstract classes, while it can be easily seen that some subclasses ofCachingSerializable or SignalSender would naturally have value semantics (be structs, in other words).<br>&gt; <br>&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt; <br>&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/20fe079f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>February 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Sorry, I understood &quot;that phrase&quot; to mean what I just stated. <br></p><p><br>&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com&gt; wrote:<br>&gt; <br>&gt; I understood him to mean that abstract classes cannot be used for value types, but it would be natural to want that functionality. Mixins would provide that capability for value types as well as classes.<br>&gt; <br>&gt;&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me. Subclasses can&#39;t be value types. Do you mean the structs could have similar functionality?<br>&gt;&gt; <br>&gt;&gt; Firstly, only classes can inherit from such abstract classes, while it can be easily seen that some subclasses ofCachingSerializable or SignalSender would naturally have value semantics (be structs, in other words).<br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/cdcc4e8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 29, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m prepairing to create a pull request, so I moved the proposal from Gist<br>to my fork of swift-evolution.<br>Link to the proposal new and hopefully final home:<br>https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br></p><p>Should I create a pull request right now or wait a bit?<br></p><p>Some details need to be discussed:<br></p><p>1. Do mixins need associated types? Would generics be more appropriate to<br>them?<br></p><p>2. `mixin` vs `mixin protocol`. On one hand, `mixin protocol` does not<br>require a keyword.<br>On the other hand, as stated in a special section, mixins cannot be used<br>everywhere a protocol can. Protocols, mixins, traits, interfaces are all<br>different entities.<br></p><p>3. `mixin` vs `trait`. Please read Wiki or any other source and tell what<br>is a better name.<br></p><p>4. Objective-C interfacing. Do we have to require it now? (I doubt so.) Can<br>we allow mixing-in Swift mixins to Objective-C classes?<br></p><p>5. Are you happy with Initializers section?<br></p><p>6. Can motivation examples be improved?<br></p><p>2016-02-29 4:07 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br></p><p>&gt; Sorry, I understood &quot;that phrase&quot; to mean what I just stated.<br>&gt;<br>&gt;<br>&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com&gt; wrote:<br>&gt;<br>&gt; I understood him to mean that abstract classes cannot be used for value<br>&gt; types, but it would be natural to want that functionality. Mixins would<br>&gt; provide that capability for value types as well as classes.<br>&gt;<br>&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;<br>&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me.<br>&gt; Subclasses can&#39;t be value types. Do you mean the structs could have similar<br>&gt; functionality?<br>&gt;<br>&gt; Firstly, only classes can inherit from such abstract classes, while it can<br>&gt; be easily seen that some subclasses ofCachingSerializable or SignalSender would<br>&gt; naturally have value semantics (be structs, in other words).<br>&gt;<br>&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;<br>&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to<br>&gt;&gt;&gt; it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I<br>&gt;&gt;&gt; encourage everyone interested to reread it and suggest fixes, improvements,<br>&gt;&gt;&gt; as well as new directions for discussion.<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/1264659b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 1:51 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m prepairing to create a pull request, so I moved the proposal from Gist to my fork of swift-evolution.<br>&gt; Link to the proposal new and hopefully final home:<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md &lt;https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md&gt;<br>&gt; <br>&gt; Should I create a pull request right now or wait a bit?<br>&gt; <br>&gt; Some details need to be discussed:<br>&gt; <br>&gt; 1. Do mixins need associated types? Would generics be more appropriate to them?<br>&gt; <br>&gt; 2. `mixin` vs `mixin protocol`. On one hand, `mixin protocol` does not require a keyword.<br>&gt; On the other hand, as stated in a special section, mixins cannot be used everywhere a protocol can. Protocols, mixins, traits, interfaces are all different entities.<br></p><p>Protocols and mixins address different problems. A protocol defines a statement of conformance. A mixin defines code and/or state to share. Why not allow mixins to conform to protocols?<br></p><p>&gt; <br>&gt; 3. `mixin` vs `trait`. Please read Wiki or any other source and tell what is a better name.<br></p><p>Traits typically do not define state. If you want to define state, then you&#39;re working with mixins.<br></p><p>&gt; <br>&gt; 4. Objective-C interfacing. Do we have to require it now? (I doubt so.) Can we allow mixing-in Swift mixins to Objective-C classes?<br></p><p>Why? This is Swift.<br></p><p>&gt; <br>&gt; 5. Are you happy with Initializers section?<br></p><p>IMHO, initializers should only be defined by entities.<br></p><p>&gt; <br>&gt; 6. Can motivation examples be improved?<br></p><p>Yes.<br></p><p>7. Need to address name collisions? I love Ruby, but there are many poorly written mixins out there and they quickly become the bane of a developer&#39;s existence. What if the name of a mixin qualified the names of the methods and state contained by the mixin?<br></p><p>&gt; <br>&gt; 2016-02-29 4:07 GMT+03:00 Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt;:<br>&gt; Sorry, I understood &quot;that phrase&quot; to mean what I just stated. <br>&gt; <br>&gt; <br>&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I understood him to mean that abstract classes cannot be used for value types, but it would be natural to want that functionality. Mixins would provide that capability for value types as well as classes.<br>&gt;&gt; <br>&gt;&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me. Subclasses can&#39;t be value types. Do you mean the structs could have similar functionality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Firstly, only classes can inherit from such abstract classes, while it can be easily seen that some subclasses ofCachingSerializable or SignalSender would naturally have value semantics (be structs, in other words).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c &lt;https://gist.github.com/Anton3/f0550922c1be0fc5447c&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt;:<br>&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Trent Nadeau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/2194b93c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>First, thank you very much for starting this discussion!<br></p><p>I have been thinking of an alternate strategy using traits, partially based on http://web.cecs.pdx.edu/~black/publications/TR_CSE_02-012.pdf &lt;http://web.cecs.pdx.edu/~black/publications/TR_CSE_02-012.pdf&gt; .<br></p><p>In my alternate strategy, you would have trait objects which behave similar to value types. They would expose methods/properties, can conform to protocols, and can also require other properties/methods via delegate protocols. When composed by an outer object, the properties/methods and protocol conformance can be either directly addressed or mapped (via some language syntax or via explicit wrapping functions) to the outer object’s usage contract as new properties/methods/protocol conformance.<br></p><p>The trait objects do not hold state, although the delegate protocols they require for usage can provide said state.<br></p><p>Similar to property behaviors, one could make a naive implementation today via generic wrappers. However, this would require duplicated state to provide the delegate protocols where needed, as well as complexity of use and memory duplication when those implementations are backed by value types. Thus, this feature falls into a similar camp of needing compiler support for optimal memory use/performance. While traits behave as if they are separate objects, they should not be treated as such and fall closer into the realm of macros.<br></p><p>You would not include these traits via the inheritance/implementation mechanism - they would not participate in an object’s superclass hierarchy or protocol conformance. Instead they act closer to ‘let’ properties.<br></p><p>Language syntax would be used to selectively map methods, properties, and full protocol conformance from a trait to the externally accessible interface of a composing object. Likewise, you can map properties/methods/protocol conformance of your object to fulfill the delegate protocol requirements of a trait. Unmapped features of a trait are not visible outside an object.<br></p><p>Conflicts between multiple traits just prevent the mapping syntax. However, you should be able to resolve this by writing your own implementations for the conflicting traits on the composing object.<br></p><p>Finally, as indicated before a trait can require multiple delegate protocols, such as how UITableView has both UI behavior and data delegate interfaces. “Mixin” behavior could come from having an object which has a default implementation of that data protocol, and mapping to a property holding an instance of that object within the composing type.<br></p><p>-DW<br></p><p>&gt; On Feb 29, 2016, at 11:51 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m prepairing to create a pull request, so I moved the proposal from Gist to my fork of swift-evolution.<br>&gt; Link to the proposal new and hopefully final home:<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md &lt;https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md&gt;<br>&gt; <br>&gt; Should I create a pull request right now or wait a bit?<br>&gt; <br>&gt; Some details need to be discussed:<br>&gt; <br>&gt; 1. Do mixins need associated types? Would generics be more appropriate to them?<br>&gt; <br>&gt; 2. `mixin` vs `mixin protocol`. On one hand, `mixin protocol` does not require a keyword.<br>&gt; On the other hand, as stated in a special section, mixins cannot be used everywhere a protocol can. Protocols, mixins, traits, interfaces are all different entities.<br>&gt; <br>&gt; 3. `mixin` vs `trait`. Please read Wiki or any other source and tell what is a better name.<br>&gt; <br>&gt; 4. Objective-C interfacing. Do we have to require it now? (I doubt so.) Can we allow mixing-in Swift mixins to Objective-C classes?<br>&gt; <br>&gt; 5. Are you happy with Initializers section?<br>&gt; <br>&gt; 6. Can motivation examples be improved?<br>&gt; <br>&gt; 2016-02-29 4:07 GMT+03:00 Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt;:<br>&gt; Sorry, I understood &quot;that phrase&quot; to mean what I just stated.<br>&gt; <br>&gt; <br>&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I understood him to mean that abstract classes cannot be used for value types, but it would be natural to want that functionality. Mixins would provide that capability for value types as well as classes.<br>&gt;&gt; <br>&gt;&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com &lt;mailto:tanadeau at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me. Subclasses can&#39;t be value types. Do you mean the structs could have similar functionality?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Firstly, only classes can inherit from such abstract classes, while it can be easily seen that some subclasses ofCachingSerializable or SignalSender would naturally have value semantics (be structs, in other words).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c &lt;https://gist.github.com/Anton3/f0550922c1be0fc5447c&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com &lt;mailto:schristopher at bignerdranch.com&gt;&gt;:<br>&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/595806a9/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/595806a9/attachment.sig&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  1, 2016 at 11:00:00am</p></header><div class="content"><p>In line below.<br></p><p>  -- Howard.<br></p><p>On 1 March 2016 at 05:51, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m prepairing to create a pull request, so I moved the proposal from Gist<br>&gt; to my fork of swift-evolution.<br>&gt; Link to the proposal new and hopefully final home:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br>&gt;<br>&gt; Should I create a pull request right now or wait a bit?<br>&gt;<br>&gt; Some details need to be discussed:<br>&gt;<br>&gt; 1. Do mixins need associated types? Would generics be more appropriate to<br>&gt; them?<br>&gt;<br></p><p>I would prefer generics so that they work seamlessly with structs and<br>classes that use generics without having to use type constraints via where<br>clauses<br></p><p>&gt;<br>&gt; 2. `mixin` vs `mixin protocol`. On one hand, `mixin protocol` does not<br>&gt; require a keyword.<br>&gt; On the other hand, as stated in a special section, mixins cannot be used<br>&gt; everywhere a protocol can. Protocols, mixins, traits, interfaces are all<br>&gt; different entities.<br>&gt;<br></p><p>trait, not trait protocol - see below<br></p><p>&gt;<br>&gt; 3. `mixin` vs `trait`. Please read Wiki or any other source and tell what<br>&gt; is a better name.<br>&gt;<br></p><p>trait since the proposal is very close to &quot;Traits: Composable Units of<br>Behaviour&quot;, by Nathanael Scha ̈rli, Ste ́phane Ducasse, Oscar Nierstrasz,<br>and Andrew P. Black, which is the paper that 1st proposed traits.<br></p><p><br>&gt;<br>&gt; 4. Objective-C interfacing. Do we have to require it now? (I doubt so.)<br>&gt; Can we allow mixing-in Swift mixins to Objective-C classes?<br>&gt;<br></p><p>No protocols are good for that. Keep it simple at 1st, can always be added<br>latter.<br></p><p>&gt;<br>&gt; 5. Are you happy with Initializers section?<br>&gt;<br></p><p>Yes<br></p><p>&gt;<br>&gt; 6. Can motivation examples be improved?<br>&gt;<br></p><p>How about adding implementing CustomStringConvertable and Equatable, e.g.:<br></p><p>mixing Shape: CustomStringConvertable, Equatable {<br></p><p>var center: CGPoint = CGPoint.zero<br></p><p>var bounds: CGSize { get } // Note: not implemented<br></p><p>var description: String { return &quot;Shape(center: x: \(center), bounds:<br>\(bounds))&quot;<br></p><p>}<br></p><p>func ==(lhs: Shape, rhs: Shape) -&gt; Bool {<br></p><p>return lhs.center == rhs.center &amp;&amp; lhs.bounds == rhs.bounds<br></p><p>}<br></p><p><br>mixing Line: CustomStringConvertable, Equatable {<br></p><p>var color = UIColor.blackColor()<br></p><p>var width = 1<br>var description: String { return &quot;Line(color: x: \(color), width: \(width))&quot;<br></p><p>}<br></p><p>func ==(lhs: Line, rhs: Line) -&gt; Bool {<br></p><p>return lhs.color == rhs.color &amp;&amp; lhs.width == rhs.width<br></p><p>}<br></p><p><br>struct Rectangle: Shape, Line {<br></p><p>var size: CGSize<br></p><p>override var bounds: CGSize { return size } // Implements Shape.bounds<br>override var description: String { return &quot;Rectangle(shape: x:<br>\(Shape.super.description), Line: \(Line.super.description))&quot;<br></p><p>}<br></p><p>func ==(lhs: Rectangle, rhs: Rectangle) -&gt; Bool {<br></p><p>return (lhs as Shape) == (rhs as Shape) &amp;&amp; (lhs as Line) == (rhs as Line)<br></p><p>}<br></p><p><br>Extra possible improvement. Add a section about resolving a conflict<br>arising from multiple definitions. My suggestion is to mimic the `A.super`<br>syntax used for calling initializers:<br></p><p> mixin A { var x = 0 }<br></p><p>mixin B { var x = 1 }<br>mixin C : A, B { override var x = A.super.x }  // OK, conflict<br>resolved because x overridden<br></p><p><br>The addition of the `A.super.x` syntax isn&#39;t strictly necessary since you<br>could write `(self as A).x`, but I prefer `A.super.x`.<br></p><p><br>&gt; 2016-02-29 4:07 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;<br>&gt;&gt; Sorry, I understood &quot;that phrase&quot; to mean what I just stated.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I understood him to mean that abstract classes cannot be used for value<br>&gt;&gt; types, but it would be natural to want that functionality. Mixins would<br>&gt;&gt; provide that capability for value types as well as classes.<br>&gt;&gt;<br>&gt;&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me.<br>&gt;&gt; Subclasses can&#39;t be value types. Do you mean the structs could have similar<br>&gt;&gt; functionality?<br>&gt;&gt;<br>&gt;&gt; Firstly, only classes can inherit from such abstract classes, while it<br>&gt;&gt; can be easily seen that some subclasses ofCachingSerializable or<br>&gt;&gt; SignalSender would naturally have value semantics (be structs, in other<br>&gt;&gt; words).<br>&gt;&gt;<br>&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Link to the proposal:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to<br>&gt;&gt;&gt;&gt; it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I<br>&gt;&gt;&gt;&gt; encourage everyone interested to reread it and suggest fixes, improvements,<br>&gt;&gt;&gt;&gt; as well as new directions for discussion.<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/4c328c0b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/698e94ec61aae18a4cae067ad645b3fb?s=50"></div><header><strong>[Draft] Mixins: What present problems do they solve?</strong> from <string>Jeremy W. Sherman</string> &lt;jeremyw.sherman at gmail.com&gt;<p>February 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Before further work on the details of the design, I urge you to focus on the problem to be solved by the proposed changes. I felt strongly that the abstract classes proposal also foundered on this crucial point (https://jeremywsherman.com/blog/2016/02/29/review-se-0026-abstract-classes-and-methods/).<br></p><p>Currently the primary motivation is &quot;fixing drawbacks of abstract classes&quot;. But Swift does not have abstract classes (yet - review is pending), so it does not have any of their drawbacks. This leaves a motivation vacuum.<br></p><p>Mixins have a long (and confused - the early Lisp implementations appear to have been misunderstood, see http://www.dreamsongs.com/Files/Incommensurability.pdf) history. There are plenty of languages now that include them or variations on them. The current proposal does not take advantage of this rich living resource to feature problems solved (and new problems created) by mixins, nor does it situate the design relative to prior art / related literature (choose the more significant term depending on your exposure to either IP law or conference proceedings ;).<br></p><p>When it comes of Lisp mixins (flavors), their runtime behavior was more like the advice features of aspect-oriented programming systems, with code executing before, after, or around a primary method. (The actual way mixin functionality was composed with a primary method was programmer controllable, and CLOS provided several standard combinations out of the box.)<br></p><p>The high-level gist is that mixins sought to provide declarative composition of behavior - &quot;it&#39;s this, with a hint of this, and some of that tossed in to spice up the basic behavior&quot; - vs the procedural composition afforded by inheritance - &quot;and now super.doSomething, just like any other procedure call&quot;. willSet/didSet bear some resemblance to before/after mixins, but are currently rather limited in applicability.<br></p><p>What could we accomplish with before advice on viewDidLoad? Would this solve any thorny problems we have now? Might adding aspect oriented programming features to protocols avoid the sticky issue of stored properties while neatly solving real problems?<br></p><p>I don&#39;t know the answers, but feel a convincing proposal will speak to how it will solve problems, while a truly wondrous proposal will relieve me of burthens I didn&#39;t even know I had been shouldering all this time.<br>--<br>Jeremy W. Sherman<br>http://jeremywsherman.com/<br></p><p>&gt; El 29-02-2016, a las 13:51, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; escribió:<br>&gt; <br>&gt; I&#39;m prepairing to create a pull request, so I moved the proposal from Gist to my fork of swift-evolution.<br>&gt; Link to the proposal new and hopefully final home:<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br>&gt; <br>&gt; Should I create a pull request right now or wait a bit?<br>&gt; <br>&gt; Some details need to be discussed:<br>&gt; <br>&gt; 1. Do mixins need associated types? Would generics be more appropriate to them?<br>&gt; <br>&gt; 2. `mixin` vs `mixin protocol`. On one hand, `mixin protocol` does not require a keyword.<br>&gt; On the other hand, as stated in a special section, mixins cannot be used everywhere a protocol can. Protocols, mixins, traits, interfaces are all different entities.<br>&gt; <br>&gt; 3. `mixin` vs `trait`. Please read Wiki or any other source and tell what is a better name.<br>&gt; <br>&gt; 4. Objective-C interfacing. Do we have to require it now? (I doubt so.) Can we allow mixing-in Swift mixins to Objective-C classes?<br>&gt; <br>&gt; 5. Are you happy with Initializers section?<br>&gt; <br>&gt; 6. Can motivation examples be improved?<br>&gt; <br>&gt; 2016-02-29 4:07 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt; Sorry, I understood &quot;that phrase&quot; to mean what I just stated. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 28, 2016, at 8:03 PM, Step C &lt;schristopher at bignerdranch.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understood him to mean that abstract classes cannot be used for value types, but it would be natural to want that functionality. Mixins would provide that capability for value types as well as classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 28, 2016, at 7:41 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The quoted portion of the proposal below doesn&#39;t make any sense to me. Subclasses can&#39;t be value types. Do you mean the structs could have similar functionality?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Firstly, only classes can inherit from such abstract classes, while it can be easily seen that some subclasses ofCachingSerializable or SignalSender would naturally have value semantics (be structs, in other words).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Feb 28, 2016 at 5:03 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Link to the proposal: https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016-02-29 0:56 GMT+03:00 Step C &lt;schristopher at bignerdranch.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; It would be helpful if you include the new draft. Or at least a link to it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Feb 28, 2016, at 3:30 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have rewritten almost the whole proposal in the last 10 hours. I encourage everyone interested to reread it and suggest fixes, improvements, as well as new directions for discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Trent Nadeau<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/c7384042/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>[Draft] Mixins: What present problems do they solve?</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>February 29, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 20:55, Jeremy W. Sherman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What could we accomplish with before advice on viewDidLoad? Would this solve any thorny problems we have now? Might adding aspect oriented programming features to protocols avoid the sticky issue of stored properties while neatly solving real problems?<br>&gt; <br>&gt; I don&#39;t know the answers, but feel a convincing proposal will speak to how it will solve problems, while a truly wondrous proposal will relieve me of burthens I didn&#39;t even know I had been shouldering all this time.<br></p><p>Nicely put.<br></p><p>-Matt<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 29.02.2016 um 19:51 schrieb Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I&#39;m prepairing to create a pull request, so I moved the proposal from Gist to my fork of swift-evolution.<br>&gt; Link to the proposal new and hopefully final home:<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br></p><p><br>I&#39;m -1 to the proposal as written and will try to explain that.<br></p><p><br>Regarding mixin inheritance:<br></p><p>&gt; Problem of members with same signatures inherited from two different places results in compile error.<br></p><p>This is unfortunate as there exists a simple solution for this problem in statically typed languages (more on that later).<br></p><p>&gt; Diamond problem is solved by keeping only one copy of mixins mixed-in in the final struct/class.<br>&gt; It works as if bodies of all mixins indirectly mixed-in into D were merged directly into D<br></p><p>That is not a good solution but just a workaround. It probably has origins in dynamically typed languages where a proper solution is not possible (see below).<br></p><p><br>Unfortunately the current discussions about Mixins, abstract classes, POP vs. OOP suffer from having forgotten achievements of the past which results in creating differences where none should be.<br>Let&#39;s start with protocol oriented programming (POP). This is a term coined by Dave Abrahams in his great talk at WWDC 2015. The only problem IMO is that POP is nothing new. It is just good old interface oriented programming as has been possible in Java for a long time (the new thing Swift brought to the table is first class value semantics). Actually if you look closely at Dave&#39;s talk is not about POP vs. OOP it is about Multiple Inheritance Done Right (TM) vs. single inheritance (with a smattering of value objects). <br>And protocols in Swift have just the same motivation like interfaces in Java (for the moment disregarding value types): they are classes without state because people thought that the dreaded diamond problem is about state and they thought that if dropping state would make multiple inheritance possible.<br>That&#39;s true to some extent. But actually the diamond problem is not about state. State is only where it surfaces more easily.<br></p><p>Actually the diamond problem is about inheriting a member with the same name (or signature) twice. And that is relevant for protocols as well.<br>And the beauty is that the solution is the same for state as for members. <br>So, what is the problem? It is as follows:<br></p><p><br>GENERAL DIAMOND PROBLEM: When a subclass inherits a member with the same name twice we have to know whether both inherited members have the same semantics.<br></p><p>(A) If both have the same semantics then we only want to use one implementation slot, so we either choose a preferred one from the parents or we implement the method in the subclass and are free to call one or both super implementations or replace their logic with something new. What we do is defined in the subclass.<br>In case of storage we don&#39;t have to do anything, the state is merged automatically (i.e. there will be only one storage slot).<br></p><p>(B) If both have different semantics we want to differentiate between both implementations or storage slots. For that we have to rename one or both in the subclass so they don&#39;t clash anymore. When using an instance of the subclass with a static type of one of its parents the original name is used of course in the type i.e. at the call site but the correct renamed one is used internally. Which one is clear as that is given by the static type used.<br>If a (possibly renamed) member has been abstract it remains abstract unless implemented in the subclass. Of course I can still override a member in the subclass even if it was renamed.<br></p><p>The classical diamond problem will in most cases fall into category (A), i.e. both inherited members have the same semantics and therefore only one storage slot ist used. In some cases we might want to duplicate the storage slot but this implies different semantics, so (B) applies and renaming solves this quite nicely, thereby making the different semantics clear by the now different names.<br></p><p>Addendum: in the diamond case we have to `select` one of both members to be used when accessed through the top type.<br></p><p><br>Bertrand Meyer&#39;s Eiffel demonstrates this solution quite nicely and successfully and that&#39;s why there are no interfaces in Eiffel, just classes. Because interfaces are not needed if classes use multiple inheritance. Just add abstract methods and you are done. No need to introduce new concepts.<br></p><p>See https://www.eiffel.com/values/multiple-inheritance/<br>and https://docs.eiffel.com/book/method/et-inheritance#Multiple_inheritance_and_renaming (for the details)<br></p><p><br>EXAMPLE 1: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br></p><p>class Array {<br>	var count: Int<br>}<br>class List {<br>	var count: Int<br>}<br>class ArrayList : Array renaming count to capacity, List renaming count to size { ... }<br></p><p>// ArrayList exposes the renamed members only under their new name<br>let arrayList: ArrayList = ...<br>arrayList.size // ok, answers the count as inherited from List<br>arrayList.capacity // ok, answers the count as inherited from Array<br>arrayList.count // error: undefined `count`<br></p><p>// The original names must still be accessible from the parent types, e.g. Array<br>let array: Array = arrayList<br>array.count // ok, answers the count as inherited from Array (= arrayList.capacity)<br>array.capacity // error: undefined `capacity`<br></p><p><br>EXAMPLE 2: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br></p><p>class UniversityPerson {<br>	var computerAccount: Account<br>}<br>class Teacher : UniversityPerson { ... }<br>class Student : UniversityPerson { ... }<br>class TeachingAssistant : <br>	Teacher renaming computerAccount to facultyAccount select facultyAccount, <br>	Student renaming computerAccount to studentAccount { <br>	... <br>}<br></p><p>let assistant: TeachingAssistant = ...<br>assistant.facultyAccount // ok<br>assistant.studentAccount // ok<br>assistant.computerAccount // error: undefined `computerAccount`<br></p><p>let teacher: Teacher = assistant<br>teacher.computerAccount // ok (= assistant.facultyAccount)<br></p><p>let student: Student = assistant<br>student.computerAccount // ok (= assistant.studentAccount)<br></p><p>let universityPerson: UniversityPerson = assistant<br>universityPerson.computerAccount // ok (= assistant.facultyAccount, due to `select`)<br></p><p><br></p><p>Dynamically typed languages like Ruby cannot use this solution because it is not possible to map a call being made by using a parent type (Array in the example) to the renamed member implementation (Array.count -&gt; ArrayList.capacity) as there are no types and it would not be clear whether array.count would need to call `capacity` or `size`. So renaming is not a possibility in dynamically typed languages which is why they resort to workarounds.<br></p><p><br>So in essence interfaces or protocols aren&#39;t needed at all if multiple inheritance is done right.<br>Citing from the Eiffel web pages: &quot;Some O-O languages support only the two extremes: fully effective classes, and fully deferred &quot;interfaces&quot;, but not classes with a mix of effective and deferred features. This is an unacceptable limitation, negating the object-oriented method&#39;s support for a seamless, continuous spectrum from the most abstract to the most concrete.&quot;<br></p><p><br>Now we come back to value types in Swift (which are a great thing!). Why do we need protocols for value objects or rather why is inheritance not allowed for them (because if it was and if multiple inheritance was done right no protocols would be needed)?<br>AFAIU and I might be very wrong here, inheritance is not allowed for value types because we want to embed value types within other value types (e.g. arrays but other structs as well) without having to use references.<br>But if a value subtype would have added some state an object of that subtype would require more memory than an object of its parent type which is not possible.<br>The solution is to forbid inheriting state. And what is commonly used for inheritance without state? Right, interfaces, a.k.a. protocols.<br></p><p>Another solution would have been to just forbid inheriting from a class with state. But that ship has sailed a long time ago, I fear, and protocols add another variety of generics into the language feature mix which offers some nice advantages (while having some disadvantages as well, but that is another topic and there are solutions for that as well).<br></p><p><br>TL;DR<br></p><p>It is unfortunate and IMO just for historical reasons that there is a dichotomy between protocols and classes at all instead of having just classes with multiple inheritance done right (and abstract methods).<br></p><p><br>What does that mean for the proposals currently being discussed (Mixins, abstract classes)?<br>- I think we should NOT add mixins with less than full multiple inheritance. <br>- We should extend protocols to support real multiple inheritance with renaming <br>- An open question is whether we should extend protocols to support state and what to do with classes in that case (maybe reduce them to implementation inheritance and having types defined solely by protocols; this would enable classes to use their own namespace different from the namespace of types and get rid of the problem of Collection vs. CollectionImpl or CollectionType vs. Collection).<br></p><p><br>DREAM<br></p><p>In an ideal world we would just have classes with multiple inheritance and abstract methods and would be able to mark classes as value types which would make them have value semantics like current Swift structs. If subclasses of value types introduce additional state they do not conform to their parent but start a new virtual root in the inheritance tree, i.e.<br></p><p>abstract class Vector&lt;N: Number&gt; { <br>	func +(lhs: Self, rhs: Self) -&gt; Self<br>	func *(lhs: N, rhs: Self) -&gt; Self<br>}<br>value class Vec2d&lt;N: Number&gt; : Vector&lt;N&gt; {<br>	var x: N<br>	var y: N<br>}<br>value class Vec3d&lt;N: Number&gt; : Vec2d&lt;N&gt; {<br>	var z: N<br>}<br>var v2: Vec2d&lt;Float&gt; = ...<br>var v3: Vec3d&lt;Float&gt; = ...<br>var v: Vector&lt;Float&gt;<br>v = v2 // ok<br>v = v3 // ok<br>v2 = v3 // type error: Vec3d is not a subtype of Vec2d<br></p><p>For generics I would use both variants that Swift currently supports, i.e. explicit type parameters and associated types, freely combinable.<br>Just dreaming... sigh.<br></p><p><br>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  2, 2016 at 10:00:00am</p></header><div class="content"><p>@Thorsten,<br></p><p>I don&#39;t get why you voted -1, it seems like all you want to add is the<br>ability to rename in case of classes as an alternative to redefine which<br>the proposal currently provides. Why not vote +1 and say expand to include<br>renaming?<br></p><p>Your second point that all you need is a class is also true. The mixing as<br>proposed could subsume structs and protocols. Though not classes because<br>they are passed by reference wagers structs are passed by copy. But again<br>that could be an expansion: expand structs so that they behave like<br>mixing/traits and allow classes to inherit from structs.<br></p><p> -- Howard.<br></p><p>  -- Howard.<br></p><p>On 2 March 2016 at 09:09, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Am 29.02.2016 um 19:51 schrieb Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; I&#39;m prepairing to create a pull request, so I moved the proposal from<br>&gt; Gist to my fork of swift-evolution.<br>&gt; &gt; Link to the proposal new and hopefully final home:<br>&gt; &gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br>&gt;<br>&gt;<br>&gt; I&#39;m -1 to the proposal as written and will try to explain that.<br>&gt;<br>&gt;<br>&gt; Regarding mixin inheritance:<br>&gt;<br>&gt; &gt; Problem of members with same signatures inherited from two different<br>&gt; places results in compile error.<br>&gt;<br>&gt; This is unfortunate as there exists a simple solution for this problem in<br>&gt; statically typed languages (more on that later).<br>&gt;<br>&gt; &gt; Diamond problem is solved by keeping only one copy of mixins mixed-in in<br>&gt; the final struct/class.<br>&gt; &gt; It works as if bodies of all mixins indirectly mixed-in into D were<br>&gt; merged directly into D<br>&gt;<br>&gt; That is not a good solution but just a workaround. It probably has origins<br>&gt; in dynamically typed languages where a proper solution is not possible (see<br>&gt; below).<br>&gt;<br>&gt;<br>&gt; Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt; vs. OOP suffer from having forgotten achievements of the past which results<br>&gt; in creating differences where none should be.<br>&gt; Let&#39;s start with protocol oriented programming (POP). This is a term<br>&gt; coined by Dave Abrahams in his great talk at WWDC 2015. The only problem<br>&gt; IMO is that POP is nothing new. It is just good old interface oriented<br>&gt; programming as has been possible in Java for a long time (the new thing<br>&gt; Swift brought to the table is first class value semantics). Actually if you<br>&gt; look closely at Dave&#39;s talk is not about POP vs. OOP it is about Multiple<br>&gt; Inheritance Done Right (TM) vs. single inheritance (with a smattering of<br>&gt; value objects).<br>&gt; And protocols in Swift have just the same motivation like interfaces in<br>&gt; Java (for the moment disregarding value types): they are classes without<br>&gt; state because people thought that the dreaded diamond problem is about<br>&gt; state and they thought that if dropping state would make multiple<br>&gt; inheritance possible.<br>&gt; That&#39;s true to some extent. But actually the diamond problem is not about<br>&gt; state. State is only where it surfaces more easily.<br>&gt;<br>&gt; Actually the diamond problem is about inheriting a member with the same<br>&gt; name (or signature) twice. And that is relevant for protocols as well.<br>&gt; And the beauty is that the solution is the same for state as for members.<br>&gt; So, what is the problem? It is as follows:<br>&gt;<br>&gt;<br>&gt; GENERAL DIAMOND PROBLEM: When a subclass inherits a member with the same<br>&gt; name twice we have to know whether both inherited members have the same<br>&gt; semantics.<br>&gt;<br>&gt; (A) If both have the same semantics then we only want to use one<br>&gt; implementation slot, so we either choose a preferred one from the parents<br>&gt; or we implement the method in the subclass and are free to call one or both<br>&gt; super implementations or replace their logic with something new. What we do<br>&gt; is defined in the subclass.<br>&gt; In case of storage we don&#39;t have to do anything, the state is merged<br>&gt; automatically (i.e. there will be only one storage slot).<br>&gt;<br>&gt; (B) If both have different semantics we want to differentiate between both<br>&gt; implementations or storage slots. For that we have to rename one or both in<br>&gt; the subclass so they don&#39;t clash anymore. When using an instance of the<br>&gt; subclass with a static type of one of its parents the original name is used<br>&gt; of course in the type i.e. at the call site but the correct renamed one is<br>&gt; used internally. Which one is clear as that is given by the static type<br>&gt; used.<br>&gt; If a (possibly renamed) member has been abstract it remains abstract<br>&gt; unless implemented in the subclass. Of course I can still override a member<br>&gt; in the subclass even if it was renamed.<br>&gt;<br>&gt; The classical diamond problem will in most cases fall into category (A),<br>&gt; i.e. both inherited members have the same semantics and therefore only one<br>&gt; storage slot ist used. In some cases we might want to duplicate the storage<br>&gt; slot but this implies different semantics, so (B) applies and renaming<br>&gt; solves this quite nicely, thereby making the different semantics clear by<br>&gt; the now different names.<br>&gt;<br>&gt; Addendum: in the diamond case we have to `select` one of both members to<br>&gt; be used when accessed through the top type.<br>&gt;<br>&gt;<br>&gt; Bertrand Meyer&#39;s Eiffel demonstrates this solution quite nicely and<br>&gt; successfully and that&#39;s why there are no interfaces in Eiffel, just<br>&gt; classes. Because interfaces are not needed if classes use multiple<br>&gt; inheritance. Just add abstract methods and you are done. No need to<br>&gt; introduce new concepts.<br>&gt;<br>&gt; See https://www.eiffel.com/values/multiple-inheritance/<br>&gt; and<br>&gt; https://docs.eiffel.com/book/method/et-inheritance#Multiple_inheritance_and_renaming<br>&gt; (for the details)<br>&gt;<br>&gt;<br>&gt; EXAMPLE 1: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br>&gt;<br>&gt; class Array {<br>&gt;         var count: Int<br>&gt; }<br>&gt; class List {<br>&gt;         var count: Int<br>&gt; }<br>&gt; class ArrayList : Array renaming count to capacity, List renaming count to<br>&gt; size { ... }<br>&gt;<br>&gt; // ArrayList exposes the renamed members only under their new name<br>&gt; let arrayList: ArrayList = ...<br>&gt; arrayList.size // ok, answers the count as inherited from List<br>&gt; arrayList.capacity // ok, answers the count as inherited from Array<br>&gt; arrayList.count // error: undefined `count`<br>&gt;<br>&gt; // The original names must still be accessible from the parent types, e.g.<br>&gt; Array<br>&gt; let array: Array = arrayList<br>&gt; array.count // ok, answers the count as inherited from Array (=<br>&gt; arrayList.capacity)<br>&gt; array.capacity // error: undefined `capacity`<br>&gt;<br>&gt;<br>&gt; EXAMPLE 2: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br>&gt;<br>&gt; class UniversityPerson {<br>&gt;         var computerAccount: Account<br>&gt; }<br>&gt; class Teacher : UniversityPerson { ... }<br>&gt; class Student : UniversityPerson { ... }<br>&gt; class TeachingAssistant :<br>&gt;         Teacher renaming computerAccount to facultyAccount select<br>&gt; facultyAccount,<br>&gt;         Student renaming computerAccount to studentAccount {<br>&gt;         ...<br>&gt; }<br>&gt;<br>&gt; let assistant: TeachingAssistant = ...<br>&gt; assistant.facultyAccount // ok<br>&gt; assistant.studentAccount // ok<br>&gt; assistant.computerAccount // error: undefined `computerAccount`<br>&gt;<br>&gt; let teacher: Teacher = assistant<br>&gt; teacher.computerAccount // ok (= assistant.facultyAccount)<br>&gt;<br>&gt; let student: Student = assistant<br>&gt; student.computerAccount // ok (= assistant.studentAccount)<br>&gt;<br>&gt; let universityPerson: UniversityPerson = assistant<br>&gt; universityPerson.computerAccount // ok (= assistant.facultyAccount, due to<br>&gt; `select`)<br>&gt;<br>&gt;<br>&gt;<br>&gt; Dynamically typed languages like Ruby cannot use this solution because it<br>&gt; is not possible to map a call being made by using a parent type (Array in<br>&gt; the example) to the renamed member implementation (Array.count -&gt;<br>&gt; ArrayList.capacity) as there are no types and it would not be clear whether<br>&gt; array.count would need to call `capacity` or `size`. So renaming is not a<br>&gt; possibility in dynamically typed languages which is why they resort to<br>&gt; workarounds.<br>&gt;<br>&gt;<br>&gt; So in essence interfaces or protocols aren&#39;t needed at all if multiple<br>&gt; inheritance is done right.<br>&gt; Citing from the Eiffel web pages: &quot;Some O-O languages support only the two<br>&gt; extremes: fully effective classes, and fully deferred &quot;interfaces&quot;, but not<br>&gt; classes with a mix of effective and deferred features. This is an<br>&gt; unacceptable limitation, negating the object-oriented method&#39;s support for<br>&gt; a seamless, continuous spectrum from the most abstract to the most<br>&gt; concrete.&quot;<br>&gt;<br>&gt;<br>&gt; Now we come back to value types in Swift (which are a great thing!). Why<br>&gt; do we need protocols for value objects or rather why is inheritance not<br>&gt; allowed for them (because if it was and if multiple inheritance was done<br>&gt; right no protocols would be needed)?<br>&gt; AFAIU and I might be very wrong here, inheritance is not allowed for value<br>&gt; types because we want to embed value types within other value types (e.g.<br>&gt; arrays but other structs as well) without having to use references.<br>&gt; But if a value subtype would have added some state an object of that<br>&gt; subtype would require more memory than an object of its parent type which<br>&gt; is not possible.<br>&gt; The solution is to forbid inheriting state. And what is commonly used for<br>&gt; inheritance without state? Right, interfaces, a.k.a. protocols.<br>&gt;<br>&gt; Another solution would have been to just forbid inheriting from a class<br>&gt; with state. But that ship has sailed a long time ago, I fear, and protocols<br>&gt; add another variety of generics into the language feature mix which offers<br>&gt; some nice advantages (while having some disadvantages as well, but that is<br>&gt; another topic and there are solutions for that as well).<br>&gt;<br>&gt;<br>&gt; TL;DR<br>&gt;<br>&gt; It is unfortunate and IMO just for historical reasons that there is a<br>&gt; dichotomy between protocols and classes at all instead of having just<br>&gt; classes with multiple inheritance done right (and abstract methods).<br>&gt;<br>&gt;<br>&gt; What does that mean for the proposals currently being discussed (Mixins,<br>&gt; abstract classes)?<br>&gt; - I think we should NOT add mixins with less than full multiple<br>&gt; inheritance.<br>&gt; - We should extend protocols to support real multiple inheritance with<br>&gt; renaming<br>&gt; - An open question is whether we should extend protocols to support state<br>&gt; and what to do with classes in that case (maybe reduce them to<br>&gt; implementation inheritance and having types defined solely by protocols;<br>&gt; this would enable classes to use their own namespace different from the<br>&gt; namespace of types and get rid of the problem of Collection vs.<br>&gt; CollectionImpl or CollectionType vs. Collection).<br>&gt;<br>&gt;<br>&gt; DREAM<br>&gt;<br>&gt; In an ideal world we would just have classes with multiple inheritance and<br>&gt; abstract methods and would be able to mark classes as value types which<br>&gt; would make them have value semantics like current Swift structs. If<br>&gt; subclasses of value types introduce additional state they do not conform to<br>&gt; their parent but start a new virtual root in the inheritance tree, i.e.<br>&gt;<br>&gt; abstract class Vector&lt;N: Number&gt; {<br>&gt;         func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;         func *(lhs: N, rhs: Self) -&gt; Self<br>&gt; }<br>&gt; value class Vec2d&lt;N: Number&gt; : Vector&lt;N&gt; {<br>&gt;         var x: N<br>&gt;         var y: N<br>&gt; }<br>&gt; value class Vec3d&lt;N: Number&gt; : Vec2d&lt;N&gt; {<br>&gt;         var z: N<br>&gt; }<br>&gt; var v2: Vec2d&lt;Float&gt; = ...<br>&gt; var v3: Vec3d&lt;Float&gt; = ...<br>&gt; var v: Vector&lt;Float&gt;<br>&gt; v = v2 // ok<br>&gt; v = v3 // ok<br>&gt; v2 = v3 // type error: Vec3d is not a subtype of Vec2d<br>&gt;<br>&gt; For generics I would use both variants that Swift currently supports, i.e.<br>&gt; explicit type parameters and associated types, freely combinable.<br>&gt; Just dreaming... sigh.<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/e9636c81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/11a8e906b9e22dfebe544e4e218a4be0?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Brian Pratt</string> &lt;brian at pratt.io&gt;<p>March  1, 2016 at 07:00:00pm</p></header><div class="content"><p>I feel like the solution to the Arrow/Enemy problem that best fits with<br>Swift&#39;s current available tools is neither a protocol (which, as you<br>mentioned, doesn&#39;t get rid of the initialization/configuration of the<br>member data) or inheritance (which, as you mentioned, can only have one<br>base type) -- it&#39;s to extract a third type that handles the position and<br>speed of each, and let that be where the `move` functionality operates (or<br>the type that a `move` func operates on).<br></p><p>I think this sort of composition is preferable to inheritance in a lot of<br>ways, and Swift has some built-in tools that can augment it: a robust<br>protocol and extension system, a type constraint system that allows for<br>lots of flexibility at compile-time, etc.<br></p><p>Mixins (and in general, the sharing of code primarily via inheritance) tend<br>to create large objects with lots of responsibilities, and that tends to<br>bloat APIs as you need to either pick extremely specific names to avoid<br>collisions, or worse, keep the cognitive overhead of &quot;shoot, what is this<br>method aliased to again?&quot; in your head all the time. If something *is* both<br>an A and a B, it needs to act like (and speak the same language of) an A or<br>a B *all* of the time.<br></p><p>Beyond this, I think it&#39;s going to be extremely complex managing<br>compile-time type constraints with renames in place. Let&#39;s say I have a<br>class C that inherits from bases A and B, which implement protocol P and Q<br>respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>Qs will have to know about the renaming of conflicts from the combination<br>of A+B? Unless I&#39;m missing something, it feels like this complexity would<br>continue to spread out to all sorts of collaborators, when the current<br>system isolates it much more effectively.<br></p><p>I think protocols and protocol extensions (mixed with lots of composition)<br>is a better scenario than abstract classes or multiple inheritance, and<br>therefore, I&#39;m still a -1 on mixins in Swift (strictly on principle; this<br>proposal actually argues the case very well).<br></p><p><br></p><p> - Brian<br></p><p>On Tue, Mar 1, 2016 at 5:25 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; @Thorsten,<br>&gt;<br>&gt; I don&#39;t get why you voted -1, it seems like all you want to add is the<br>&gt; ability to rename in case of classes as an alternative to redefine which<br>&gt; the proposal currently provides. Why not vote +1 and say expand to include<br>&gt; renaming?<br>&gt;<br>&gt; Your second point that all you need is a class is also true. The mixing as<br>&gt; proposed could subsume structs and protocols. Though not classes because<br>&gt; they are passed by reference wagers structs are passed by copy. But again<br>&gt; that could be an expansion: expand structs so that they behave like<br>&gt; mixing/traits and allow classes to inherit from structs.<br>&gt;<br>&gt;  -- Howard.<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 2 March 2016 at 09:09, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; Am 29.02.2016 um 19:51 schrieb Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m prepairing to create a pull request, so I moved the proposal from<br>&gt;&gt; Gist to my fork of swift-evolution.<br>&gt;&gt; &gt; Link to the proposal new and hopefully final home:<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/mixins/proposals/NNNN-mixins.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m -1 to the proposal as written and will try to explain that.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regarding mixin inheritance:<br>&gt;&gt;<br>&gt;&gt; &gt; Problem of members with same signatures inherited from two different<br>&gt;&gt; places results in compile error.<br>&gt;&gt;<br>&gt;&gt; This is unfortunate as there exists a simple solution for this problem in<br>&gt;&gt; statically typed languages (more on that later).<br>&gt;&gt;<br>&gt;&gt; &gt; Diamond problem is solved by keeping only one copy of mixins mixed-in<br>&gt;&gt; in the final struct/class.<br>&gt;&gt; &gt; It works as if bodies of all mixins indirectly mixed-in into D were<br>&gt;&gt; merged directly into D<br>&gt;&gt;<br>&gt;&gt; That is not a good solution but just a workaround. It probably has<br>&gt;&gt; origins in dynamically typed languages where a proper solution is not<br>&gt;&gt; possible (see below).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Unfortunately the current discussions about Mixins, abstract classes, POP<br>&gt;&gt; vs. OOP suffer from having forgotten achievements of the past which results<br>&gt;&gt; in creating differences where none should be.<br>&gt;&gt; Let&#39;s start with protocol oriented programming (POP). This is a term<br>&gt;&gt; coined by Dave Abrahams in his great talk at WWDC 2015. The only problem<br>&gt;&gt; IMO is that POP is nothing new. It is just good old interface oriented<br>&gt;&gt; programming as has been possible in Java for a long time (the new thing<br>&gt;&gt; Swift brought to the table is first class value semantics). Actually if you<br>&gt;&gt; look closely at Dave&#39;s talk is not about POP vs. OOP it is about Multiple<br>&gt;&gt; Inheritance Done Right (TM) vs. single inheritance (with a smattering of<br>&gt;&gt; value objects).<br>&gt;&gt; And protocols in Swift have just the same motivation like interfaces in<br>&gt;&gt; Java (for the moment disregarding value types): they are classes without<br>&gt;&gt; state because people thought that the dreaded diamond problem is about<br>&gt;&gt; state and they thought that if dropping state would make multiple<br>&gt;&gt; inheritance possible.<br>&gt;&gt; That&#39;s true to some extent. But actually the diamond problem is not about<br>&gt;&gt; state. State is only where it surfaces more easily.<br>&gt;&gt;<br>&gt;&gt; Actually the diamond problem is about inheriting a member with the same<br>&gt;&gt; name (or signature) twice. And that is relevant for protocols as well.<br>&gt;&gt; And the beauty is that the solution is the same for state as for members.<br>&gt;&gt; So, what is the problem? It is as follows:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; GENERAL DIAMOND PROBLEM: When a subclass inherits a member with the same<br>&gt;&gt; name twice we have to know whether both inherited members have the same<br>&gt;&gt; semantics.<br>&gt;&gt;<br>&gt;&gt; (A) If both have the same semantics then we only want to use one<br>&gt;&gt; implementation slot, so we either choose a preferred one from the parents<br>&gt;&gt; or we implement the method in the subclass and are free to call one or both<br>&gt;&gt; super implementations or replace their logic with something new. What we do<br>&gt;&gt; is defined in the subclass.<br>&gt;&gt; In case of storage we don&#39;t have to do anything, the state is merged<br>&gt;&gt; automatically (i.e. there will be only one storage slot).<br>&gt;&gt;<br>&gt;&gt; (B) If both have different semantics we want to differentiate between<br>&gt;&gt; both implementations or storage slots. For that we have to rename one or<br>&gt;&gt; both in the subclass so they don&#39;t clash anymore. When using an instance of<br>&gt;&gt; the subclass with a static type of one of its parents the original name is<br>&gt;&gt; used of course in the type i.e. at the call site but the correct renamed<br>&gt;&gt; one is used internally. Which one is clear as that is given by the static<br>&gt;&gt; type used.<br>&gt;&gt; If a (possibly renamed) member has been abstract it remains abstract<br>&gt;&gt; unless implemented in the subclass. Of course I can still override a member<br>&gt;&gt; in the subclass even if it was renamed.<br>&gt;&gt;<br>&gt;&gt; The classical diamond problem will in most cases fall into category (A),<br>&gt;&gt; i.e. both inherited members have the same semantics and therefore only one<br>&gt;&gt; storage slot ist used. In some cases we might want to duplicate the storage<br>&gt;&gt; slot but this implies different semantics, so (B) applies and renaming<br>&gt;&gt; solves this quite nicely, thereby making the different semantics clear by<br>&gt;&gt; the now different names.<br>&gt;&gt;<br>&gt;&gt; Addendum: in the diamond case we have to `select` one of both members to<br>&gt;&gt; be used when accessed through the top type.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Bertrand Meyer&#39;s Eiffel demonstrates this solution quite nicely and<br>&gt;&gt; successfully and that&#39;s why there are no interfaces in Eiffel, just<br>&gt;&gt; classes. Because interfaces are not needed if classes use multiple<br>&gt;&gt; inheritance. Just add abstract methods and you are done. No need to<br>&gt;&gt; introduce new concepts.<br>&gt;&gt;<br>&gt;&gt; See https://www.eiffel.com/values/multiple-inheritance/<br>&gt;&gt; and<br>&gt;&gt; https://docs.eiffel.com/book/method/et-inheritance#Multiple_inheritance_and_renaming<br>&gt;&gt; (for the details)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; EXAMPLE 1: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br>&gt;&gt;<br>&gt;&gt; class Array {<br>&gt;&gt;         var count: Int<br>&gt;&gt; }<br>&gt;&gt; class List {<br>&gt;&gt;         var count: Int<br>&gt;&gt; }<br>&gt;&gt; class ArrayList : Array renaming count to capacity, List renaming count<br>&gt;&gt; to size { ... }<br>&gt;&gt;<br>&gt;&gt; // ArrayList exposes the renamed members only under their new name<br>&gt;&gt; let arrayList: ArrayList = ...<br>&gt;&gt; arrayList.size // ok, answers the count as inherited from List<br>&gt;&gt; arrayList.capacity // ok, answers the count as inherited from Array<br>&gt;&gt; arrayList.count // error: undefined `count`<br>&gt;&gt;<br>&gt;&gt; // The original names must still be accessible from the parent types,<br>&gt;&gt; e.g. Array<br>&gt;&gt; let array: Array = arrayList<br>&gt;&gt; array.count // ok, answers the count as inherited from Array (=<br>&gt;&gt; arrayList.capacity)<br>&gt;&gt; array.capacity // error: undefined `capacity`<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; EXAMPLE 2: (from the Eiffel webpages, renaming syntax to be bikeshedded)<br>&gt;&gt;<br>&gt;&gt; class UniversityPerson {<br>&gt;&gt;         var computerAccount: Account<br>&gt;&gt; }<br>&gt;&gt; class Teacher : UniversityPerson { ... }<br>&gt;&gt; class Student : UniversityPerson { ... }<br>&gt;&gt; class TeachingAssistant :<br>&gt;&gt;         Teacher renaming computerAccount to facultyAccount select<br>&gt;&gt; facultyAccount,<br>&gt;&gt;         Student renaming computerAccount to studentAccount {<br>&gt;&gt;         ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let assistant: TeachingAssistant = ...<br>&gt;&gt; assistant.facultyAccount // ok<br>&gt;&gt; assistant.studentAccount // ok<br>&gt;&gt; assistant.computerAccount // error: undefined `computerAccount`<br>&gt;&gt;<br>&gt;&gt; let teacher: Teacher = assistant<br>&gt;&gt; teacher.computerAccount // ok (= assistant.facultyAccount)<br>&gt;&gt;<br>&gt;&gt; let student: Student = assistant<br>&gt;&gt; student.computerAccount // ok (= assistant.studentAccount)<br>&gt;&gt;<br>&gt;&gt; let universityPerson: UniversityPerson = assistant<br>&gt;&gt; universityPerson.computerAccount // ok (= assistant.facultyAccount, due<br>&gt;&gt; to `select`)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Dynamically typed languages like Ruby cannot use this solution because it<br>&gt;&gt; is not possible to map a call being made by using a parent type (Array in<br>&gt;&gt; the example) to the renamed member implementation (Array.count -&gt;<br>&gt;&gt; ArrayList.capacity) as there are no types and it would not be clear whether<br>&gt;&gt; array.count would need to call `capacity` or `size`. So renaming is not a<br>&gt;&gt; possibility in dynamically typed languages which is why they resort to<br>&gt;&gt; workarounds.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; So in essence interfaces or protocols aren&#39;t needed at all if multiple<br>&gt;&gt; inheritance is done right.<br>&gt;&gt; Citing from the Eiffel web pages: &quot;Some O-O languages support only the<br>&gt;&gt; two extremes: fully effective classes, and fully deferred &quot;interfaces&quot;, but<br>&gt;&gt; not classes with a mix of effective and deferred features. This is an<br>&gt;&gt; unacceptable limitation, negating the object-oriented method&#39;s support for<br>&gt;&gt; a seamless, continuous spectrum from the most abstract to the most<br>&gt;&gt; concrete.&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Now we come back to value types in Swift (which are a great thing!). Why<br>&gt;&gt; do we need protocols for value objects or rather why is inheritance not<br>&gt;&gt; allowed for them (because if it was and if multiple inheritance was done<br>&gt;&gt; right no protocols would be needed)?<br>&gt;&gt; AFAIU and I might be very wrong here, inheritance is not allowed for<br>&gt;&gt; value types because we want to embed value types within other value types<br>&gt;&gt; (e.g. arrays but other structs as well) without having to use references.<br>&gt;&gt; But if a value subtype would have added some state an object of that<br>&gt;&gt; subtype would require more memory than an object of its parent type which<br>&gt;&gt; is not possible.<br>&gt;&gt; The solution is to forbid inheriting state. And what is commonly used for<br>&gt;&gt; inheritance without state? Right, interfaces, a.k.a. protocols.<br>&gt;&gt;<br>&gt;&gt; Another solution would have been to just forbid inheriting from a class<br>&gt;&gt; with state. But that ship has sailed a long time ago, I fear, and protocols<br>&gt;&gt; add another variety of generics into the language feature mix which offers<br>&gt;&gt; some nice advantages (while having some disadvantages as well, but that is<br>&gt;&gt; another topic and there are solutions for that as well).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; TL;DR<br>&gt;&gt;<br>&gt;&gt; It is unfortunate and IMO just for historical reasons that there is a<br>&gt;&gt; dichotomy between protocols and classes at all instead of having just<br>&gt;&gt; classes with multiple inheritance done right (and abstract methods).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What does that mean for the proposals currently being discussed (Mixins,<br>&gt;&gt; abstract classes)?<br>&gt;&gt; - I think we should NOT add mixins with less than full multiple<br>&gt;&gt; inheritance.<br>&gt;&gt; - We should extend protocols to support real multiple inheritance with<br>&gt;&gt; renaming<br>&gt;&gt; - An open question is whether we should extend protocols to support state<br>&gt;&gt; and what to do with classes in that case (maybe reduce them to<br>&gt;&gt; implementation inheritance and having types defined solely by protocols;<br>&gt;&gt; this would enable classes to use their own namespace different from the<br>&gt;&gt; namespace of types and get rid of the problem of Collection vs.<br>&gt;&gt; CollectionImpl or CollectionType vs. Collection).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; DREAM<br>&gt;&gt;<br>&gt;&gt; In an ideal world we would just have classes with multiple inheritance<br>&gt;&gt; and abstract methods and would be able to mark classes as value types which<br>&gt;&gt; would make them have value semantics like current Swift structs. If<br>&gt;&gt; subclasses of value types introduce additional state they do not conform to<br>&gt;&gt; their parent but start a new virtual root in the inheritance tree, i.e.<br>&gt;&gt;<br>&gt;&gt; abstract class Vector&lt;N: Number&gt; {<br>&gt;&gt;         func +(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;         func *(lhs: N, rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; value class Vec2d&lt;N: Number&gt; : Vector&lt;N&gt; {<br>&gt;&gt;         var x: N<br>&gt;&gt;         var y: N<br>&gt;&gt; }<br>&gt;&gt; value class Vec3d&lt;N: Number&gt; : Vec2d&lt;N&gt; {<br>&gt;&gt;         var z: N<br>&gt;&gt; }<br>&gt;&gt; var v2: Vec2d&lt;Float&gt; = ...<br>&gt;&gt; var v3: Vec3d&lt;Float&gt; = ...<br>&gt;&gt; var v: Vector&lt;Float&gt;<br>&gt;&gt; v = v2 // ok<br>&gt;&gt; v = v3 // ok<br>&gt;&gt; v2 = v3 // type error: Vec3d is not a subtype of Vec2d<br>&gt;&gt;<br>&gt;&gt; For generics I would use both variants that Swift currently supports,<br>&gt;&gt; i.e. explicit type parameters and associated types, freely combinable.<br>&gt;&gt; Just dreaming... sigh.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/4872e5da/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  2, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 02.03.2016 um 02:00 schrieb Brian Pratt &lt;brian at pratt.io&gt;:<br>&gt; <br>&gt; If something *is* both an A and a B, it needs to act like (and speak the same language of) an A or a B *all* of the time.<br></p><p>Yes, that is exactly the point of Eiffel-style-multiple inheritance.<br></p><p>&gt; Beyond this, I think it&#39;s going to be extremely complex managing compile-time type constraints with renames in place. Let&#39;s say I have a class C that inherits from bases A and B, which implement protocol P and Q respectively, and there&#39;s a naming collision. Functions that expect Ps or Qs will have to know about the renaming of conflicts from the combination of A+B?<br></p><p>No, functions that expect Ps or Qs will talk the language of P and Q. They don&#39;t have to know about renaming (that&#39;s the whole point which is only possible in statically typed languages). <br>Functions that expect C will have to know about renaming. They will talk the language of C.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March  2, 2016 at 12:00:00pm</p></header><div class="content"><p>On &quot;traits vs mixins&quot;,<br>I tend to agree with Patrick Gili that probably the most important<br>difference between traits and mixins is that mixins define state. This<br>article agrees:<br>http://matthijshollemans.com/2015/07/22/mixins-and-traits-in-swift-2/<br></p><p>On initializers,<br>Initializers really only make sense on fully defined types. That&#39;s why I<br>disallowed implicit initializer inheritance. But I believe that &quot;helpers&quot;,<br>which know how to initialize their part of state, can be useful.<br></p><p>On mixin conflicts resolving,<br>I agree that this question should be solved not in &quot;future directions&quot;, but<br>within the proposal itself. &quot;Merge members&quot; and &quot;keep copies for both super<br>mixins&quot; are equal alternate options.<br>We need to decide on syntax. I also don&#39;t fully understand how it should<br>work, question below.<br></p><p>A special thanks ot Thorsten Seitz for opening my eyes on problems in Swift<br>type system. I agree with &quot;dream&quot; part completely. But I&#39;m afraid, that<br>already can&#39;t be changed.<br></p><p>New set of questions:<br></p><p>1. Can a mixin contain uninitialized state, unlike fully defined types?<br>Example:<br></p><p>mixin A { var x: Int }<br>struct B: A { init(x: Int) { self.x = x } }<br></p><p>2. What should be syntax for conflict resolution? I will use the following<br>in this post:<br></p><p>var x = A.x<br>func f() = A.f<br></p><p>The intent here should be to use existing Swift constructs.<br></p><p>3. If we decide to keep two copies in a conflict, do we need to rename all<br>members, or can we rename selectively? Example:<br></p><p>mixin A {<br>  var x: Int = 0<br>  func show() { print(x) }<br>}<br>mixin B {<br>  var x: Int = 1<br>  func show() { print(x) }<br>}<br>struct S: A, B {<br>  var y = A.x<br>  var z = B.x<br>  // nothing touching show()<br>}<br>let s = S()<br>s.show()  //=&gt; 0 or 1?<br></p><p>This example could also be formulated for problem A -&gt; (B,C) -&gt; D<br></p><p>4. Should we allow for arbitrary renaming of members in subtypes, not only<br>in conflicts?<br></p><p>5. Should we allow conflicting inherited members until usage or throw an<br>error immediately?<br></p><p>mixin A { var x: Int = 0 }<br>mixin B { var x: Int = 1 }<br>struct C: A, B { func show() { print(A.x); print(B.x) } }<br>let c = C()  // error??<br>C().show()  //=&gt; 01<br>C().x  // error: &quot;x is a conflicting member in C, cannot be called here&quot;<br>C().A.x  // syntax error<br></p><p><br>2016-03-02 8:37 GMT+03:00 Thorsten Seitz &lt;tseitz42 at icloud.com&gt;:<br></p><p>&gt;<br>&gt; &gt; Am 02.03.2016 um 02:00 schrieb Brian Pratt &lt;brian at pratt.io&gt;:<br>&gt; &gt;<br>&gt; &gt; If something *is* both an A and a B, it needs to act like (and speak the<br>&gt; same language of) an A or a B *all* of the time.<br>&gt;<br>&gt; Yes, that is exactly the point of Eiffel-style-multiple inheritance.<br>&gt;<br>&gt; &gt; Beyond this, I think it&#39;s going to be extremely complex managing<br>&gt; compile-time type constraints with renames in place. Let&#39;s say I have a<br>&gt; class C that inherits from bases A and B, which implement protocol P and Q<br>&gt; respectively, and there&#39;s a naming collision. Functions that expect Ps or<br>&gt; Qs will have to know about the renaming of conflicts from the combination<br>&gt; of A+B?<br>&gt;<br>&gt; No, functions that expect Ps or Qs will talk the language of P and Q. They<br>&gt; don&#39;t have to know about renaming (that&#39;s the whole point which is only<br>&gt; possible in statically typed languages).<br>&gt; Functions that expect C will have to know about renaming. They will talk<br>&gt; the language of C.<br>&gt;<br>&gt; -Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/b2e5abb4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 27, 2016 at 03:00:00pm</p></header><div class="content"><p>This is compelling to me.<br></p><p>I haven’t put enough thought into it to make up my mind about it, but a mixin system would solve a problem I’m currently struggling with.<br></p><p>I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m trying to reduce duplication between the codebases. The problem is, there are things that aren’t easy to completely encapsulate into a separate, universal class — things that have bits and pieces in common, but different overall shape.<br></p><p>Perhaps I should encapsulate them anyway, add a level of indirection, inject dependencies… But a mixin is an abstraction that would allow me to extract common parts in an easier way.<br></p><p>— Radek<br></p><p>&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some people opposed to Abstract Classes proposal (including myself) have said that mixins could solve the problem better.<br>&gt; So I prepaired a proposal draft to add stored properties to protocols. Here it is:<br>&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c &lt;https://gist.github.com/Anton3/f0550922c1be0fc5447c&gt;<br>&gt; <br>&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/af2de5b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 27, 2016 at 11:00:00am</p></header><div class="content"><p>One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>retroactively modeled, e.g. by having an extension for that protocol on a<br>type outside of its file of definition. Allowing this would make the size<br>of structs and classes unknowable to the compiler as an extension in<br>another library could change the size of all instances.<br></p><p>That limitation is restrictive enough that having a special type of<br>protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>The compiler could then easily check the intent of the protocol and ensure<br>that a library doesn&#39;t break existing extensions just by adding a stored<br>property. Only mixin protocols would have this capability.<br></p><p>On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is compelling to me.<br>&gt;<br>&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;<br>&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m<br>&gt; trying to reduce duplication between the codebases. The problem is, there<br>&gt; are things that aren’t easy to completely encapsulate into a separate,<br>&gt; universal class — things that have bits and pieces in common, but different<br>&gt; overall shape.<br>&gt;<br>&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt; extract common parts in an easier way.<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt; said that mixins could solve the problem better.<br>&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt; Here it is:<br>&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;<br>&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/8f703237/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>In my current proposal, stored properties of protocols have no abilities<br>beyond that of structs. They cannot be declared in extensions, that&#39;s<br>intentional. Could you give an example where such decoupled definition<br>would be better than multiple mixins, for example?<br></p><p>2016-02-27 19:17 GMT+03:00 Trent Nadeau &lt;tanadeau at gmail.com&gt;:<br></p><p>&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>&gt; retroactively modeled, e.g. by having an extension for that protocol on a<br>&gt; type outside of its file of definition. Allowing this would make the size<br>&gt; of structs and classes unknowable to the compiler as an extension in<br>&gt; another library could change the size of all instances.<br>&gt;<br>&gt; That limitation is restrictive enough that having a special type of<br>&gt; protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>&gt; The compiler could then easily check the intent of the protocol and ensure<br>&gt; that a library doesn&#39;t break existing extensions just by adding a stored<br>&gt; property. Only mixin protocols would have this capability.<br>&gt;<br>&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is compelling to me.<br>&gt;&gt;<br>&gt;&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt;&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;&gt;<br>&gt;&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m<br>&gt;&gt; trying to reduce duplication between the codebases. The problem is, there<br>&gt;&gt; are things that aren’t easy to completely encapsulate into a separate,<br>&gt;&gt; universal class — things that have bits and pieces in common, but different<br>&gt;&gt; overall shape.<br>&gt;&gt;<br>&gt;&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt;&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt;&gt; extract common parts in an easier way.<br>&gt;&gt;<br>&gt;&gt; — Radek<br>&gt;&gt;<br>&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt; Here it is:<br>&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;<br>&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/af6d0658/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>February 27, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t mean stored properties declared in extensions. I&#39;m talking about<br>conforming to a &quot;mixin&quot; protocol via an extension in another file. For<br>example:<br></p><p>// Foo.swift<br>struct Blah {<br>    var x : Int<br>}<br></p><p>// Mixins.swift<br>protocol MyMixin {<br>    var y : Double // mixin having a stored property<br>}<br></p><p>// Bar.swift<br>extension Blah : MyMixin {} // this changes the size of all instances of<br>Blah in the program<br></p><p>On Sat, Feb 27, 2016 at 11:26 AM, Антон Жилин &lt;antonyzhilin at gmail.com&gt;<br>wrote:<br></p><p>&gt; In my current proposal, stored properties of protocols have no abilities<br>&gt; beyond that of structs. They cannot be declared in extensions, that&#39;s<br>&gt; intentional. Could you give an example where such decoupled definition<br>&gt; would be better than multiple mixins, for example?<br>&gt;<br>&gt; 2016-02-27 19:17 GMT+03:00 Trent Nadeau &lt;tanadeau at gmail.com&gt;:<br>&gt;<br>&gt;&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>&gt;&gt; retroactively modeled, e.g. by having an extension for that protocol on a<br>&gt;&gt; type outside of its file of definition. Allowing this would make the size<br>&gt;&gt; of structs and classes unknowable to the compiler as an extension in<br>&gt;&gt; another library could change the size of all instances.<br>&gt;&gt;<br>&gt;&gt; That limitation is restrictive enough that having a special type of<br>&gt;&gt; protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>&gt;&gt; The compiler could then easily check the intent of the protocol and ensure<br>&gt;&gt; that a library doesn&#39;t break existing extensions just by adding a stored<br>&gt;&gt; property. Only mixin protocols would have this capability.<br>&gt;&gt;<br>&gt;&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This is compelling to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt;&gt;&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m<br>&gt;&gt;&gt; trying to reduce duplication between the codebases. The problem is, there<br>&gt;&gt;&gt; are things that aren’t easy to completely encapsulate into a separate,<br>&gt;&gt;&gt; universal class — things that have bits and pieces in common, but different<br>&gt;&gt;&gt; overall shape.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt;&gt;&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt;&gt;&gt; extract common parts in an easier way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt;&gt; Here it is:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/4d890ac7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Ah, I see now. The proposal started with `mixin` keyword being primary and<br>extending `protocol` in alternatives. Then I swapped then. Maybe I should<br>swap them again :P<br></p><p>I tend to agree with your argumentation.<br>Currently proposed methods in protocol extensions act as default methods<br>(no class inheritance support, if you are aware of that issue), but in<br>protocol body - as function methods. If we add `mixin protocol`s, then<br>behaviour of that methods will be consistent.<br>And do we need associated types (read generics) for mixins?<br></p><p>I also had a proposal for separating protocols and interfaces, but it got<br>turned down because of proposal for existentials, which I have not heard of<br>for long. Here it is:<br>https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br></p><p>If both proposals got accepted, we would have protocols, interfaces and<br>mixins. Protocols would have associated types, interfaces - dynamism,<br>mixins - state.<br></p><p>2016-02-27 19:32 GMT+03:00 Trent Nadeau &lt;tanadeau at gmail.com&gt;:<br></p><p>&gt; I don&#39;t mean stored properties declared in extensions. I&#39;m talking about<br>&gt; conforming to a &quot;mixin&quot; protocol via an extension in another file. For<br>&gt; example:<br>&gt;<br>&gt; // Foo.swift<br>&gt; struct Blah {<br>&gt;     var x : Int<br>&gt; }<br>&gt;<br>&gt; // Mixins.swift<br>&gt; protocol MyMixin {<br>&gt;     var y : Double // mixin having a stored property<br>&gt; }<br>&gt;<br>&gt; // Bar.swift<br>&gt; extension Blah : MyMixin {} // this changes the size of all instances of<br>&gt; Blah in the program<br>&gt;<br>&gt; On Sat, Feb 27, 2016 at 11:26 AM, Антон Жилин &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; In my current proposal, stored properties of protocols have no abilities<br>&gt;&gt; beyond that of structs. They cannot be declared in extensions, that&#39;s<br>&gt;&gt; intentional. Could you give an example where such decoupled definition<br>&gt;&gt; would be better than multiple mixins, for example?<br>&gt;&gt;<br>&gt;&gt; 2016-02-27 19:17 GMT+03:00 Trent Nadeau &lt;tanadeau at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>&gt;&gt;&gt; retroactively modeled, e.g. by having an extension for that protocol on a<br>&gt;&gt;&gt; type outside of its file of definition. Allowing this would make the size<br>&gt;&gt;&gt; of structs and classes unknowable to the compiler as an extension in<br>&gt;&gt;&gt; another library could change the size of all instances.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That limitation is restrictive enough that having a special type of<br>&gt;&gt;&gt; protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>&gt;&gt;&gt; The compiler could then easily check the intent of the protocol and ensure<br>&gt;&gt;&gt; that a library doesn&#39;t break existing extensions just by adding a stored<br>&gt;&gt;&gt; property. Only mixin protocols would have this capability.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is compelling to me.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt;&gt;&gt;&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and<br>&gt;&gt;&gt;&gt; I’m trying to reduce duplication between the codebases. The problem is,<br>&gt;&gt;&gt;&gt; there are things that aren’t easy to completely encapsulate into a<br>&gt;&gt;&gt;&gt; separate, universal class — things that have bits and pieces in common, but<br>&gt;&gt;&gt;&gt; different overall shape.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt;&gt;&gt;&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt;&gt;&gt;&gt; extract common parts in an easier way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Some people opposed to Abstract Classes proposal (including myself)<br>&gt;&gt;&gt;&gt; have said that mixins could solve the problem better.<br>&gt;&gt;&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt;&gt;&gt; Here it is:<br>&gt;&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt;&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Trent Nadeau<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/4a7a25ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 27, 2016 at 05:00:00pm</p></header><div class="content"><p>Makes sense to me, and mixins are different enough conceptually from most protocols that having a separate keyword (or, more practically, a modifier keyword, like `mixin protocol`) might be desirable anyway.<br></p><p>The fact that protocols already come in two flavors — those that can act as types, and those that have associated types and therefore can only be used as generic constraints — sometimes feels confusing to me. Adding a third kind without any differentiation might not be a good idea.<br></p><p>— Radek<br></p><p>&gt; On 27 Feb 2016, at 17:17, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be retroactively modeled, e.g. by having an extension for that protocol on a type outside of its file of definition. Allowing this would make the size of structs and classes unknowable to the compiler as an extension in another library could change the size of all instances.<br>&gt; <br>&gt; That limitation is restrictive enough that having a special type of protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial. The compiler could then easily check the intent of the protocol and ensure that a library doesn&#39;t break existing extensions just by adding a stored property. Only mixin protocols would have this capability. <br>&gt; <br>&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This is compelling to me.<br>&gt; <br>&gt; I haven’t put enough thought into it to make up my mind about it, but a mixin system would solve a problem I’m currently struggling with.<br>&gt; <br>&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m trying to reduce duplication between the codebases. The problem is, there are things that aren’t easy to completely encapsulate into a separate, universal class — things that have bits and pieces in common, but different overall shape.<br>&gt; <br>&gt; Perhaps I should encapsulate them anyway, add a level of indirection, inject dependencies… But a mixin is an abstraction that would allow me to extract common parts in an easier way.<br>&gt; <br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have said that mixins could solve the problem better.<br>&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols. Here it is:<br>&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c &lt;https://gist.github.com/Anton3/f0550922c1be0fc5447c&gt;<br>&gt;&gt; <br>&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Trent Nadeau<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/21dea6c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>February 27, 2016 at 04:00:00pm</p></header><div class="content"><p>I think the easier solution is to allow for a default implementation to be<br>written for a protocol inside of the protocol itself.<br></p><p>*___________________________________*<br></p><p>*James⎥Head of Trolls*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Sat, Feb 27, 2016 at 4:26 PM, Radosław Pietruszewski &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Makes sense to me, and mixins are different enough conceptually from most<br>&gt; protocols that having a separate keyword (or, more practically, a modifier<br>&gt; keyword, like `mixin protocol`) might be desirable anyway.<br>&gt;<br>&gt; The fact that protocols already come in two flavors — those that can act<br>&gt; as types, and those that have associated types and therefore can only be<br>&gt; used as generic constraints — sometimes feels confusing to me. Adding a<br>&gt; third kind without any differentiation might not be a good idea.<br>&gt;<br>&gt; — Radek<br>&gt;<br>&gt; On 27 Feb 2016, at 17:17, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;<br>&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>&gt; retroactively modeled, e.g. by having an extension for that protocol on a<br>&gt; type outside of its file of definition. Allowing this would make the size<br>&gt; of structs and classes unknowable to the compiler as an extension in<br>&gt; another library could change the size of all instances.<br>&gt;<br>&gt; That limitation is restrictive enough that having a special type of<br>&gt; protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>&gt; The compiler could then easily check the intent of the protocol and ensure<br>&gt; that a library doesn&#39;t break existing extensions just by adding a stored<br>&gt; property. Only mixin protocols would have this capability.<br>&gt;<br>&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is compelling to me.<br>&gt;&gt;<br>&gt;&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt;&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;&gt;<br>&gt;&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m<br>&gt;&gt; trying to reduce duplication between the codebases. The problem is, there<br>&gt;&gt; are things that aren’t easy to completely encapsulate into a separate,<br>&gt;&gt; universal class — things that have bits and pieces in common, but different<br>&gt;&gt; overall shape.<br>&gt;&gt;<br>&gt;&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt;&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt;&gt; extract common parts in an easier way.<br>&gt;&gt;<br>&gt;&gt; — Radek<br>&gt;&gt;<br>&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt; Here it is:<br>&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;<br>&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Trent Nadeau<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/d8a9ebf8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>James,<br>I think you misunderstood the proposal. The main goal is to allow protocols<br>define non-computed properties.<br>Functions inside protocol body will work different than functions in the<br>extension, more like functions in classes.<br></p><p>2016-02-27 19:27 GMT+03:00 James Campbell &lt;james at supmenow.com&gt;:<br></p><p>&gt; I think the easier solution is to allow for a default implementation to be<br>&gt; written for a protocol inside of the protocol itself.<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥Head of Trolls*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt;<br>&gt; On Sat, Feb 27, 2016 at 4:26 PM, Radosław Pietruszewski &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Makes sense to me, and mixins are different enough conceptually from most<br>&gt;&gt; protocols that having a separate keyword (or, more practically, a modifier<br>&gt;&gt; keyword, like `mixin protocol`) might be desirable anyway.<br>&gt;&gt;<br>&gt;&gt; The fact that protocols already come in two flavors — those that can act<br>&gt;&gt; as types, and those that have associated types and therefore can only be<br>&gt;&gt; used as generic constraints — sometimes feels confusing to me. Adding a<br>&gt;&gt; third kind without any differentiation might not be a good idea.<br>&gt;&gt;<br>&gt;&gt; — Radek<br>&gt;&gt;<br>&gt;&gt; On 27 Feb 2016, at 17:17, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; One limitation for &quot;mixin&quot; protocols would be that they can&#39;t be<br>&gt;&gt; retroactively modeled, e.g. by having an extension for that protocol on a<br>&gt;&gt; type outside of its file of definition. Allowing this would make the size<br>&gt;&gt; of structs and classes unknowable to the compiler as an extension in<br>&gt;&gt; another library could change the size of all instances.<br>&gt;&gt;<br>&gt;&gt; That limitation is restrictive enough that having a special type of<br>&gt;&gt; protocol and an associated keyword (&quot;mixin&quot;) would probably be beneficial.<br>&gt;&gt; The compiler could then easily check the intent of the protocol and ensure<br>&gt;&gt; that a library doesn&#39;t break existing extensions just by adding a stored<br>&gt;&gt; property. Only mixin protocols would have this capability.<br>&gt;&gt;<br>&gt;&gt; On Sat, Feb 27, 2016 at 9:00 AM, Radosław Pietruszewski &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This is compelling to me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t put enough thought into it to make up my mind about it, but a<br>&gt;&gt;&gt; mixin system would solve a problem I’m currently struggling with.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’ve been working on cleaning up the codebase of my iOS/Mac app, and I’m<br>&gt;&gt;&gt; trying to reduce duplication between the codebases. The problem is, there<br>&gt;&gt;&gt; are things that aren’t easy to completely encapsulate into a separate,<br>&gt;&gt;&gt; universal class — things that have bits and pieces in common, but different<br>&gt;&gt;&gt; overall shape.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps I should encapsulate them anyway, add a level of indirection,<br>&gt;&gt;&gt; inject dependencies… But a mixin is an abstraction that would allow me to<br>&gt;&gt;&gt; extract common parts in an easier way.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; — Radek<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 27 Feb 2016, at 10:59, Антон Жилин via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt;&gt; Here it is:<br>&gt;&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Trent Nadeau<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/199e9679/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>February 28, 2016 at 12:00:00am</p></header><div class="content"><p>You are not alone, discursions like start a long time ago on Swift 1.1 on<br>the old forum.<br></p><p>I also have here on my desktop some proposals involving storage properties<br>in protocols.<br></p><p>The idea appears to be simple, but is hard to get a good design.<br></p><p>Properties on Default Protocol Implementations<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2996&gt;<br></p><p>Some quotes that can help here:<br></p><p>-- Douglas Gregor  -- &quot;<br>Default implementations of functions don’t require per-instance state,<br>while adding a stored property via a protocol extension does. Let’s step<br>back to a simpler problem: stored properties in (non-protocol) extensions.<br></p><p>In the existing language, one can only introduce stored properties in the<br>primary definition of the type. That’s because, when we create an instance<br>of that type, we need to know how much storage to allocate for that<br>instance. So, right now, we don’t even allow, e.g.,<br></p><p>struct MyStruct { }<br>extension MyStruct { var storage: Int = 0 } // error: extensions may not<br>contain stored properties<br></p><p>class MyClass { }<br>extension MyClass { var storage: Int = 0 } // error: extensions may not<br>contain stored properties<br></p><p>because, in the worst case, we don’t know about the storage required for<br>the “storage” property until after we’ve allocated some instances of<br>MyStruct or MyClass, and we can’t simply go back and resize those instances<br>when we learn about the “storage” property. The “worst case” here could<br>come about with shared libraries: put the MyStruct/MyClass primary<br>definitions into an app, then put the extensions into a separate shared<br>library. The app creates some MyStruct and MyClass instances, then loads<br>the shared library, and now we have a problem: those instances have no<br>storage for “storage.”<br></p><p>We could relax the requirement to allow extensions in the same module as<br>the primary definition of that type to introduce stored properties, because<br>they’re compiled along with the primary type definition anyway. This<br>doesn’t solve out-of-module extensions, of course.<br></p><p>We could embed a pointer into each instance that points off to the stored<br>properties for that instance. The pointer would refer to some<br>lazily-allocated memory on the heap with that extra storage. However, this<br>would either bloat every data structure by a pointer (including “Int”!) or<br>have to be opt-in, neither of which are great. I don’t think there is any<br>reasonable implementation for out-of-module stored properties in extensions<br>of value types (struct/enum).<br></p><p>For classes, where we have object identity, we could have a side table<br>containing the stored properties (keyed on the object’s address). This is<br>how Objective-C’s associated objects work, and it’s a reasonable module for<br>out-of-module stored properties in extensions of classes.<br></p><p>Getting back to stored properties in protocol extensions, the general<br>feature isn’t implementable without having some mechanism for out-of-module<br>stored properties in extensions of structs and enums, so you can limit it<br>in a few ways:<br></p><p>* Only allow them on class-bound protocols, where there is a reasonable<br>implementation model<br></p><p>* Allow them as default implementations within a protocol (not an extension<br>of a protocol!); a type can conform to that protocol either by providing<br>its own implementation of that property or somewhere where it is reasonable<br>for the default implementation to inject a stored property into that<br>context (e.g., on the primary type, within the same module as the primary<br>type, or on a class).<br></p><p>Either handles the example brought up in the discussion of abstract base<br>classes.<br></p><p>- Doug<br>&quot;<br></p><p>-- Chris Lattner  -- &quot;<br></p><p>Hi Doug,<br></p><p>Have you considered this similar-but-different approach?<br></p><p>- Allow extensions on classes (only) within the same module/resilience<br>domain as the class to add stored<br>properties. This would keep them inline in the instance.<br>- Allow protocols to have stored property declarations, introducing a<br>new “protocol with storage”<br>(PwS) concept.<br>- Classes can directly conform to a PwS in its definition, or within<br>an extension inside the same<br>module/resilience domain.<br></p><p>Just this would give many of the benefits of a full mix-in programming<br>model.  People could define these<br>protocols, and their local implementation of the type can benefit from<br>them.  It doesn’t support<br>retroactive mixin’ing, but that is probably a good thing.  I’m<br>assuming that we don’t want to allow<br>adding state to structs within a resilience domain, just because I<br>don’t think that is actually a good<br>thing to add to the programming model (other reasonable people will<br>surely disagree).<br></p><p>This base model could then be extended:<br>- Structs could conform to a PwS in their definition, but not an<br>extension.  We could optionally require the<br>struct to redeclare the properties to improve readability of the<br>struct, but it wouldn’t be required<br>from an implementation perspective.<br>- Classes could conform to a PwS across resilience boundaries, but<br>wouldn’t get the state: they’d have<br>to implement the storage requirement with a computed property.<br>- We could introduce an “associated objects” property behavior that<br>makes providing the computed<br>property very straight-forward, using the out of band implementation<br>approach of ObjC.<br></p><p>The advantages of this approach I see are:<br></p><p>1) implementable, always a bonus.<br>2) keeps predictable performance.  You don’t get out “associated<br>objects” overhead unexpectedly.<br>All state is always stored inline.<br>3) retroactive mixins are possible, but explicit.<br></p><p>The primary downside of this approach is that it introduces yet<br>another weird protocol variant with<br>limitations and behaviors, making the model more complicated.<br></p><p>-Chris<br></p><p>&quot;<br></p><p>Some of the challenges I&#39;m having to write my proposal is to find a model<br>that does not make the language much complex and still bring a direct<br>benefit.<br></p><p>Em sáb, 27 de fev de 2016 às 06:59, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>escreveu:<br></p><p>&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt; said that mixins could solve the problem better.<br>&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt; Here it is:<br>&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;<br>&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/7324e77c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 28, 2016 at 10:00:00am</p></header><div class="content"><p>Thank you, I probably didn&#39;t care about the subject at that time, until<br>abstract classes proposal got serious.<br>I currently suggest that mixins can only be included directly at type<br>definition.<br>I don&#39;t think we will lose too much. Extending these possibilities might<br>follow the proposal *if* it gets accepted.<br></p><p>2016-02-28 3:47 GMT+03:00 Wallacy &lt;wallacyf at gmail.com&gt;:<br></p><p>&gt; You are not alone, discursions like start a long time ago on Swift 1.1 on<br>&gt; the old forum.<br>&gt;<br>&gt; I also have here on my desktop some proposals involving storage properties<br>&gt; in protocols.<br>&gt;<br>&gt; The idea appears to be simple, but is hard to get a good design.<br>&gt;<br>&gt; Properties on Default Protocol Implementations<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2996&gt;<br>&gt;<br>&gt; Some quotes that can help here:<br>&gt;<br>&gt; -- Douglas Gregor  -- &quot;<br>&gt; Default implementations of functions don’t require per-instance state,<br>&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;<br>&gt; In the existing language, one can only introduce stored properties in the<br>&gt; primary definition of the type. That’s because, when we create an instance<br>&gt; of that type, we need to know how much storage to allocate for that<br>&gt; instance. So, right now, we don’t even allow, e.g.,<br>&gt;<br>&gt; struct MyStruct { }<br>&gt; extension MyStruct { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; class MyClass { }<br>&gt; extension MyClass { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; because, in the worst case, we don’t know about the storage required for<br>&gt; the “storage” property until after we’ve allocated some instances of<br>&gt; MyStruct or MyClass, and we can’t simply go back and resize those instances<br>&gt; when we learn about the “storage” property. The “worst case” here could<br>&gt; come about with shared libraries: put the MyStruct/MyClass primary<br>&gt; definitions into an app, then put the extensions into a separate shared<br>&gt; library. The app creates some MyStruct and MyClass instances, then loads<br>&gt; the shared library, and now we have a problem: those instances have no<br>&gt; storage for “storage.”<br>&gt;<br>&gt; We could relax the requirement to allow extensions in the same module as<br>&gt; the primary definition of that type to introduce stored properties, because<br>&gt; they’re compiled along with the primary type definition anyway. This<br>&gt; doesn’t solve out-of-module extensions, of course.<br>&gt;<br>&gt; We could embed a pointer into each instance that points off to the stored<br>&gt; properties for that instance. The pointer would refer to some<br>&gt; lazily-allocated memory on the heap with that extra storage. However, this<br>&gt; would either bloat every data structure by a pointer (including “Int”!) or<br>&gt; have to be opt-in, neither of which are great. I don’t think there is any<br>&gt; reasonable implementation for out-of-module stored properties in extensions<br>&gt; of value types (struct/enum).<br>&gt;<br>&gt; For classes, where we have object identity, we could have a side table<br>&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt; out-of-module stored properties in extensions of classes.<br>&gt;<br>&gt; Getting back to stored properties in protocol extensions, the general<br>&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt; stored properties in extensions of structs and enums, so you can limit it<br>&gt; in a few ways:<br>&gt;<br>&gt; * Only allow them on class-bound protocols, where there is a reasonable<br>&gt; implementation model<br>&gt;<br>&gt; * Allow them as default implementations within a protocol (not an<br>&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt; providing its own implementation of that property or somewhere where it is<br>&gt; reasonable for the default implementation to inject a stored property into<br>&gt; that context (e.g., on the primary type, within the same module as the<br>&gt; primary type, or on a class).<br>&gt;<br>&gt; Either handles the example brought up in the discussion of abstract base<br>&gt; classes.<br>&gt;<br>&gt; - Doug<br>&gt; &quot;<br>&gt;<br>&gt; -- Chris Lattner  -- &quot;<br>&gt;<br>&gt; Hi Doug,<br>&gt;<br>&gt; Have you considered this similar-but-different approach?<br>&gt;<br>&gt; - Allow extensions on classes (only) within the same module/resilience domain as the class to add stored<br>&gt; properties. This would keep them inline in the instance.<br>&gt; - Allow protocols to have stored property declarations, introducing a new “protocol with storage”<br>&gt; (PwS) concept.<br>&gt; - Classes can directly conform to a PwS in its definition, or within an extension inside the same<br>&gt; module/resilience domain.<br>&gt;<br>&gt; Just this would give many of the benefits of a full mix-in programming model.  People could define these<br>&gt; protocols, and their local implementation of the type can benefit from them.  It doesn’t support<br>&gt; retroactive mixin’ing, but that is probably a good thing.  I’m assuming that we don’t want to allow<br>&gt; adding state to structs within a resilience domain, just because I don’t think that is actually a good<br>&gt; thing to add to the programming model (other reasonable people will surely disagree).<br>&gt;<br>&gt; This base model could then be extended:<br>&gt; - Structs could conform to a PwS in their definition, but not an extension.  We could optionally require the<br>&gt; struct to redeclare the properties to improve readability of the struct, but it wouldn’t be required<br>&gt; from an implementation perspective.<br>&gt; - Classes could conform to a PwS across resilience boundaries, but wouldn’t get the state: they’d have<br>&gt; to implement the storage requirement with a computed property.<br>&gt; - We could introduce an “associated objects” property behavior that makes providing the computed<br>&gt; property very straight-forward, using the out of band implementation approach of ObjC.<br>&gt;<br>&gt; The advantages of this approach I see are:<br>&gt;<br>&gt; 1) implementable, always a bonus.<br>&gt; 2) keeps predictable performance.  You don’t get out “associated objects” overhead unexpectedly.<br>&gt; All state is always stored inline.<br>&gt; 3) retroactive mixins are possible, but explicit.<br>&gt;<br>&gt; The primary downside of this approach is that it introduces yet another weird protocol variant with<br>&gt; limitations and behaviors, making the model more complicated.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &quot;<br>&gt;<br>&gt; Some of the challenges I&#39;m having to write my proposal is to find a model<br>&gt; that does not make the language much complex and still bring a direct<br>&gt; benefit.<br>&gt;<br>&gt; Em sáb, 27 de fev de 2016 às 06:59, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; escreveu:<br>&gt;<br>&gt;&gt; Some people opposed to Abstract Classes proposal (including myself) have<br>&gt;&gt; said that mixins could solve the problem better.<br>&gt;&gt; So I prepaired a proposal draft to add stored properties to protocols.<br>&gt;&gt; Here it is:<br>&gt;&gt; https://gist.github.com/Anton3/f0550922c1be0fc5447c<br>&gt;&gt;<br>&gt;&gt; P.S. I added a `mixin` keyword in the beginning, but we can opt to just<br>&gt;&gt; extend protocols, which I mention in &quot;alternatives&quot;.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/6185c9fa/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March  2, 2016 at 10:00:00am</p></header><div class="content"><p>+1 (but *see below*)<br></p><p>Example:<br></p><p>&gt; My custom Swift notification system currently has two problems that<br>&gt; would be solved by mixins:<br>&gt;<br>&gt; 1. Anyone conforming to StdEmitterType has to provide “public var<br>&gt;    _listeners = EventStorage()&quot;, which is obvious non-ideal (I have an<br>&gt;    Xcode snippet for that).<br>&gt;<br>&gt; 2. I have EmitterType protocol that defines the publish/subscribe<br>&gt;    contract, and StdEmitterType protocol that provides a standard<br>&gt;    implementation of the publish/subscribe methods using a stored<br>&gt;    _listeners property (provided by the conforming class/struct as<br>&gt;    described in #1). The distinction between EmitterType and<br>&gt;    StdEmitterType is confusing when both are called protocols, because<br>&gt;    StdEmitterType is really a mixin. Calling EmitterType a protocol<br>&gt;    and StdEmitterType a mixin would clear up the confusion.*<br>*<br></p><p>Because of reason #2, I&#39;m strongly in support of using a separate<br>keyword.<br></p><p><br>*I do feel*, however, that maybe this isn&#39;t a single problem, but<br>instead *two orthogonal problems* that could have separate solutions:<br></p><p>1) *Go-style embedding*, where a struct&#39;s members become the members of<br>   its containing struct/class<br></p><p>2) an *“implicit delegate”* facility that allows a struct (you may call<br>   it a “mixin”) to access the self of its container, and to impose<br>   requirements on the container (funcs/vars that the container has to<br>   implement)<br></p><p>#1 is useful without #2 — the logging example doesn&#39;t need anything from<br>#it container, it just wants to add a variable<br></p><p>#2 is useful without #1 — I have other mixin-like examples that benefit<br>#from being included (a) in multiple copies, and/or (b) non-anonymously<br>#(with a meaningful name), and/or (c) privately.<br></p><p><br>*Examples of #2 without #1:*<br></p><p>— I have an activity system in my app that tracks the progress and<br>completion of a tree of long-running operations (think a Make-like build<br>process, or an IDE-style code analysis consisting of multiple steps<br>operating on multiple files). The relevant state management and<br>notification logic is encapsulated as ProcessorImpl mixin-like class<br>that tightly binds to its host via an initialization method:<br></p><p>public func initializeWithHost&lt;Host: EmitterType&gt;(host: Host, performs<br>performMethod: (Host) -&gt; (Request, OperationContext) -&gt; Promise&lt;Void&gt;)<br></p><p>...some classes perform multiple kinds of processing, so they end up<br>creating multiple ProcessorImpl&#39;s; and even for those classes that use<br>only one instance, it is helpful to give it a name (private let<br>analysisState = ProcessorImpl()) and to keep it private (it is manually<br>published via a separate property that has a protocol type)<br></p><p>— my current Delayed class that implements something similar to<br>performSelector:afterDelay: / cancelPerformSelector in Objective-C, or<br>to function throttling/unbouncing in JavaScript. It has to be a class,<br>because it contains mutable state that is modified from within<br>dispatch_async. Would be great for it to instead be a mixin that would<br>use the “self” of its container, without creating a separate object.<br></p><p><br>Thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/a2a54c63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>March  1, 2016 at 09:00:00pm</p></header><div class="content"><p>Increasingly I am finding that in almost all cases composition provides a better alternative to inheritance. In the case of sharable logic, that logic is better provided as its own complete class with something like the delegate pattern or callbacks if extensibility is required. This encourages small classes with limited responsibility that can be easily/independently tested. <br></p><p>So with that in mind, the problem I see with this proposal is that it introduces syntactical and conceptual complexity to the language - in particular providing a mechanism to resolve cases of the diamond problem, ordering of init/deinit etc is going to make the usage non-trival - without having a substantive benefit outside of what can be achieved more robustly with the existing constructs - such as protocols - the language provides.<br></p><p>For the examples for mixins presented so far, I’d be interested in understanding why they couldn’t be solved with the existing language and design patterns.<br></p><p>-Simon<br></p><p><br>&gt; On 1 Mar 2016, at 8:15 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 (but see below)<br>&gt;  <br>&gt; Example:<br>&gt;  <br>&gt; My custom Swift notification system currently has two problems that would be solved by mixins:<br>&gt;  <br>&gt; 1. Anyone conforming to StdEmitterType has to provide “public var _listeners = EventStorage()&quot;, which is obvious non-ideal (I have an Xcode snippet for that).<br>&gt;  <br>&gt; 2. I have EmitterType protocol that defines the publish/subscribe contract, and StdEmitterType protocol that provides a standard implementation of the publish/subscribe methods using a stored _listeners property (provided by the conforming class/struct as described in #1). The distinction between EmitterType and StdEmitterType is confusing when both are called protocols, because StdEmitterType is really a mixin. Calling EmitterType a protocol and StdEmitterType a mixin would clear up the confusion.<br>&gt;  <br>&gt; Because of reason #2, I&#39;m strongly in support of using a separate keyword.<br>&gt;  <br>&gt;  <br>&gt; I do feel, however, that maybe this isn&#39;t a single problem, but instead two orthogonal problems that could have separate solutions:<br>&gt;  <br>&gt; 1) Go-style embedding, where a struct&#39;s members become the members of its containing struct/class<br>&gt;  <br>&gt; 2) an “implicit delegate” facility that allows a struct (you may call it a “mixin”) to access the self of its container, and to impose requirements on the container (funcs/vars that the container has to implement)<br>&gt;  <br>&gt; #1 is useful without #2 — the logging example doesn&#39;t need anything from it container, it just wants to add a variable<br>&gt;  <br>&gt; #2 is useful without #1 — I have other mixin-like examples that benefit from being included (a) in multiple copies, and/or (b) non-anonymously (with a meaningful name), and/or (c) privately.<br>&gt;  <br>&gt;  <br>&gt; Examples of #2 without #1:<br>&gt;  <br>&gt; — I have an activity system in my app that tracks the progress and completion of a tree of long-running operations (think a Make-like build process, or an IDE-style code analysis consisting of multiple steps operating on multiple files). The relevant state management and notification logic is encapsulated as ProcessorImpl mixin-like class that tightly binds to its host via an initialization method:<br>&gt;  <br>&gt;        public func initializeWithHost&lt;Host: EmitterType&gt;(host: Host, performs performMethod: (Host) -&gt; (Request, OperationContext) -&gt; Promise&lt;Void&gt;)<br>&gt;  <br>&gt;    ...some classes perform multiple kinds of processing, so they end up creating multiple ProcessorImpl&#39;s; and even for those classes that use only one instance, it is helpful to give it a name (private let analysisState = ProcessorImpl()) and to keep it private (it is manually published via a separate property that has a protocol type)<br>&gt;  <br>&gt; — my current Delayed class that implements something similar to performSelector:afterDelay: / cancelPerformSelector in Objective-C, or to function throttling/unbouncing in JavaScript. It has to be a class, because it contains mutable state that is modified from within dispatch_async. Would be great for it to instead be a mixin that would use the “self” of its container, without creating a separate object.<br>&gt;  <br>&gt;  <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/3d6b7a3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  2, 2016 at 06:00:00am</p></header><div class="content"><p>While delegates and callbacks have their place I think inheritance has its place as well. The former are inherently dynamic (pluggable) even if my design might be static and not allow plugging in different functionality at runtime. In addition the delegate needs memory in the base class which is not the case with inheritance.<br></p><p>Regarding testability: if we had real multiple inheritance then testing would be as easy as you can put the logic in its own class instead of a subclass and create the subclass by inheriting from the base class and the logic class. That means you can test the logic class in isolation just like you can do with delegates. Combining functionality like this is called the cake pattern in Scaka.<br></p><p>-Thorsten <br></p><p>&gt; Am 02.03.2016 um 06:24 schrieb Simon Pilkington via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Increasingly I am finding that in almost all cases composition provides a better alternative to inheritance. In the case of sharable logic, that logic is better provided as its own complete class with something like the delegate pattern or callbacks if extensibility is required. This encourages small classes with limited responsibility that can be easily/independently tested. <br>&gt; <br>&gt; So with that in mind, the problem I see with this proposal is that it introduces syntactical and conceptual complexity to the language - in particular providing a mechanism to resolve cases of the diamond problem, ordering of init/deinit etc is going to make the usage non-trival - without having a substantive benefit outside of what can be achieved more robustly with the existing constructs - such as protocols - the language provides.<br>&gt; <br>&gt; For the examples for mixins presented so far, I’d be interested in understanding why they couldn’t be solved with the existing language and design patterns.<br>&gt; <br>&gt; -Simon<br>&gt; <br>&gt; <br>&gt;&gt; On 1 Mar 2016, at 8:15 PM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 (but see below)<br>&gt;&gt;  <br>&gt;&gt; Example:<br>&gt;&gt;  <br>&gt;&gt; My custom Swift notification system currently has two problems that would be solved by mixins:<br>&gt;&gt;  <br>&gt;&gt; 1. Anyone conforming to StdEmitterType has to provide “public var _listeners = EventStorage()&quot;, which is obvious non-ideal (I have an Xcode snippet for that).<br>&gt;&gt;  <br>&gt;&gt; 2. I have EmitterType protocol that defines the publish/subscribe contract, and StdEmitterType protocol that provides a standard implementation of the publish/subscribe methods using a stored _listeners property (provided by the conforming class/struct as described in #1). The distinction between EmitterType and StdEmitterType is confusing when both are called protocols, because StdEmitterType is really a mixin. Calling EmitterType a protocol and StdEmitterType a mixin would clear up the confusion.<br>&gt;&gt;  <br>&gt;&gt; Because of reason #2, I&#39;m strongly in support of using a separate keyword.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; I do feel, however, that maybe this isn&#39;t a single problem, but instead two orthogonal problems that could have separate solutions:<br>&gt;&gt;  <br>&gt;&gt; 1) Go-style embedding, where a struct&#39;s members become the members of its containing struct/class<br>&gt;&gt;  <br>&gt;&gt; 2) an “implicit delegate” facility that allows a struct (you may call it a “mixin”) to access the self of its container, and to impose requirements on the container (funcs/vars that the container has to implement)<br>&gt;&gt;  <br>&gt;&gt; #1 is useful without #2 — the logging example doesn&#39;t need anything from it container, it just wants to add a variable<br>&gt;&gt;  <br>&gt;&gt; #2 is useful without #1 — I have other mixin-like examples that benefit from being included (a) in multiple copies, and/or (b) non-anonymously (with a meaningful name), and/or (c) privately.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; Examples of #2 without #1:<br>&gt;&gt;  <br>&gt;&gt; — I have an activity system in my app that tracks the progress and completion of a tree of long-running operations (think a Make-like build process, or an IDE-style code analysis consisting of multiple steps operating on multiple files). The relevant state management and notification logic is encapsulated as ProcessorImpl mixin-like class that tightly binds to its host via an initialization method:<br>&gt;&gt;  <br>&gt;&gt;        public func initializeWithHost&lt;Host: EmitterType&gt;(host: Host, performs performMethod: (Host) -&gt; (Request, OperationContext) -&gt; Promise&lt;Void&gt;)<br>&gt;&gt;  <br>&gt;&gt;    ...some classes perform multiple kinds of processing, so they end up creating multiple ProcessorImpl&#39;s; and even for those classes that use only one instance, it is helpful to give it a name (private let analysisState = ProcessorImpl()) and to keep it private (it is manually published via a separate property that has a protocol type)<br>&gt;&gt;  <br>&gt;&gt; — my current Delayed class that implements something similar to performSelector:afterDelay: / cancelPerformSelector in Objective-C, or to function throttling/unbouncing in JavaScript. It has to be a class, because it contains mutable state that is modified from within dispatch_async. Would be great for it to instead be a mixin that would use the “self” of its container, without creating a separate object.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; Thoughts?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/a9401ab1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
