<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/175ad9e0827a836bfb3d1d06fe3182ec?s=50"></div><header><strong>Protocol extension code executed instead of class code</strong> from <string>Diego S치nchez</string> &lt;diego.sanchezr at gmail.com&gt;<p>February 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Consider the following code<br></p><p>protocol MyProtocol {<br>    func doSomething()<br>}<br></p><p>extension MyProtocol {<br>    func doSomething() {<br>        print(&quot;default impl&quot;)<br>    }<br>}<br></p><p>class A: MyProtocol {}<br></p><p>class B: A {<br>    func doSomething() {<br>        print(&quot;B impl&quot;)<br>    }<br>}<br></p><p>let a: MyProtocol = A()<br>a.doSomething() // Prints &quot;default impl&quot;<br>let b: MyProtocol = B()<br>b.doSomething() // Prints &quot;default impl&quot; instead of &quot;B impl&quot;!<br></p><p>Now let&#39;s override doSomething in A...<br></p><p>class A: MyProtocol {<br>    func doSomething() {<br>        print(&quot;A impl&quot;)<br>    }<br>}<br></p><p>class B: A {<br>     override func doSomething() {<br>        print(&quot;B impl&quot;)<br>    }<br>}<br></p><p>let a: MyProtocol = A()<br>a.doSomething() // Now it prints &quot;A impl&quot;<br>let b: MyProtocol = B()<br>b.doSomething() // Now it prints &quot;B impl&quot;<br></p><p>That&#39;s clearly inconsistent. I would expect to print &quot;B impl&quot; in the first<br>case; or maybe always &quot;default impl&quot; (I highly prefer the first option)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160220/be83b16b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Protocol extension code executed instead of class code</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 20, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 20, 2016, at 4:41 AM, Diego S치nchez via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Consider the following code<br>&gt; <br>&gt; protocol MyProtocol {<br>&gt;     func doSomething()<br>&gt; }<br>&gt; <br>&gt; extension MyProtocol {<br>&gt;     func doSomething() {<br>&gt;         print(&quot;default impl&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class A: MyProtocol {}<br>&gt; <br>&gt; class B: A {<br>&gt;     func doSomething() {<br>&gt;         print(&quot;B impl&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a: MyProtocol = A()<br>&gt; a.doSomething() // Prints &quot;default impl&quot;<br>&gt; let b: MyProtocol = B()<br>&gt; b.doSomething() // Prints &quot;default impl&quot; instead of &quot;B impl&quot;!<br>&gt; <br>&gt; Now let&#39;s override doSomething in A...<br>&gt; <br>&gt; class A: MyProtocol {<br>&gt;     func doSomething() {<br>&gt;         print(&quot;A impl&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class B: A {<br>&gt;      override func doSomething() {<br>&gt;         print(&quot;B impl&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a: MyProtocol = A()<br>&gt; a.doSomething() // Now it prints &quot;A impl&quot;<br>&gt; let b: MyProtocol = B()<br>&gt; b.doSomething() // Now it prints &quot;B impl&quot;<br>&gt; <br>&gt; That&#39;s clearly inconsistent. I would expect to print &quot;B impl&quot; in the first case; or maybe always &quot;default impl&quot; (I highly prefer the first option)<br></p><p>If you don&#39;t say &#39;override&#39;, you&#39;re not overriding anything, but defining a logically independent method. In the first example, `doSomething` isn&#39;t really a member of `A`, so it&#39;s not overrideable by subclasses, and the declaration of `B.doSomething` just shadows the protocol extension implementation instead of overriding it. This is admittedly weird, so we do have some proposals floating to improve things by implicitly mirroring protocol methods as class methods when a class conforms to a protocol.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/175ad9e0827a836bfb3d1d06fe3182ec?s=50"></div><header><strong>Protocol extension code executed instead of class code</strong> from <string>Diego S치nchez</string> &lt;diego.sanchezr at gmail.com&gt;<p>February 21, 2016 at 01:00:00am</p></header><div class="content"><p>That would be great, thanks for the heads up!<br></p><p>2016-02-20 23:22 GMT+00:00 Joe Groff &lt;jgroff at apple.com&gt;:<br></p><p>&gt;<br>&gt; &gt; On Feb 20, 2016, at 4:41 AM, Diego S치nchez via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Consider the following code<br>&gt; &gt;<br>&gt; &gt; protocol MyProtocol {<br>&gt; &gt;     func doSomething()<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension MyProtocol {<br>&gt; &gt;     func doSomething() {<br>&gt; &gt;         print(&quot;default impl&quot;)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class A: MyProtocol {}<br>&gt; &gt;<br>&gt; &gt; class B: A {<br>&gt; &gt;     func doSomething() {<br>&gt; &gt;         print(&quot;B impl&quot;)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; let a: MyProtocol = A()<br>&gt; &gt; a.doSomething() // Prints &quot;default impl&quot;<br>&gt; &gt; let b: MyProtocol = B()<br>&gt; &gt; b.doSomething() // Prints &quot;default impl&quot; instead of &quot;B impl&quot;!<br>&gt; &gt;<br>&gt; &gt; Now let&#39;s override doSomething in A...<br>&gt; &gt;<br>&gt; &gt; class A: MyProtocol {<br>&gt; &gt;     func doSomething() {<br>&gt; &gt;         print(&quot;A impl&quot;)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class B: A {<br>&gt; &gt;      override func doSomething() {<br>&gt; &gt;         print(&quot;B impl&quot;)<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; let a: MyProtocol = A()<br>&gt; &gt; a.doSomething() // Now it prints &quot;A impl&quot;<br>&gt; &gt; let b: MyProtocol = B()<br>&gt; &gt; b.doSomething() // Now it prints &quot;B impl&quot;<br>&gt; &gt;<br>&gt; &gt; That&#39;s clearly inconsistent. I would expect to print &quot;B impl&quot; in the<br>&gt; first case; or maybe always &quot;default impl&quot; (I highly prefer the first<br>&gt; option)<br>&gt;<br>&gt; If you don&#39;t say &#39;override&#39;, you&#39;re not overriding anything, but defining<br>&gt; a logically independent method. In the first example, `doSomething` isn&#39;t<br>&gt; really a member of `A`, so it&#39;s not overrideable by subclasses, and the<br>&gt; declaration of `B.doSomething` just shadows the protocol extension<br>&gt; implementation instead of overriding it. This is admittedly weird, so we do<br>&gt; have some proposals floating to improve things by implicitly mirroring<br>&gt; protocol methods as class methods when a class conforms to a protocol.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160221/479bb31f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
