<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 01:00:00am</p></header><div class="content"><p>https://github.com/Anton3/swift-evolution/blob/master/proposals/NNNN-rename-mirror.md<br>Rename Mirror<br></p><p>   - Proposal: SE-NNNN &lt;http://NNNN-filename.md&gt;<br>   - Author: Anton Zhilin &lt;https://github.com/Anton3&gt;, Adrian Zubarev<br>   &lt;https://github.com/DevAndArtist&gt;<br>   - Status: *Awaiting review*<br>   - Review manager: TBD<br></p><p>Introduction<br></p><p>Rename Mirror to DebugRepresentation and CustomReflectable to<br>CustomDebugRepresentable.<br>Motivation<br></p><p>Name of Mirror does not reflect (no pun) what it is intended to do, i.e.<br>providing full featured reflection, which we want to see in Swift 4. Other<br>than that, it is only intended to serve for debugging purposes, e.g.<br>building trees for selected objects. Some evidence to that:<br></p><p>   - Mirror.DisplayStyle contains optional and set as special cases, but<br>   does not contain function<br>   - Mirror collects all information possible at initialization, while for<br>   true reflection we want laziness<br>   - Mirror allows customization. For example, Array&lt;T&gt; is represented with<br>   a field for each of its elements. Do we want this for “true” reflection we<br>   want to add in the future?<br></p><p>Proposed solution<br></p><p>   - Rename struct Mirror to DebugRepresentation<br>   - Rename protocol CustomReflectable to CustomDebugRepresentable<br>   - Rename property customMirror to customDebugRepresentation<br>   - Hope that one day we will get a real Mirror with full reflection<br>   capabilities<br></p><p>Impact on existing code<br></p><p>This is a breaking change; easy automated migration possible.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/358fc934/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 03:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 3:25 PM, Anton Zhilin via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/NNNN-rename-mirror.md<br>&gt;<br>&gt; Rename Mirror<br>&gt;<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Anton Zhilin, Adrian Zubarev<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Rename Mirror to DebugRepresentation and CustomReflectable to<br>&gt; CustomDebugRepresentable.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Name of Mirror does not reflect (no pun) what it is intended to do, i.e.<br>&gt; providing full featured reflection, which we want to see in Swift 4. Other<br>&gt; than that, it is only intended to serve for debugging purposes, e.g.<br>&gt; building trees for selected objects. Some evidence to that:<br>&gt;<br>&gt; Mirror.DisplayStyle contains optional and set as special cases, but does not<br>&gt; contain function<br>&gt; Mirror collects all information possible at initialization, while for true<br>&gt; reflection we want laziness<br>&gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a<br>&gt; field for each of its elements. Do we want this for “true” reflection we<br>&gt; want to add in the future?<br></p><p>Why can&#39;t we add these features to Mirror in future?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 02:00:00am</p></header><div class="content"><p>2016-07-22 1:34 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt;<br>&gt; &gt; Mirror.DisplayStyle contains optional and set as special cases, but does<br>&gt; not<br>&gt; &gt; contain function<br>&gt; &gt; Mirror collects all information possible at initialization, while for<br>&gt; true<br>&gt; &gt; reflection we want laziness<br>&gt; &gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a<br>&gt; &gt; field for each of its elements. Do we want this for “true” reflection we<br>&gt; &gt; want to add in the future?<br>&gt;<br>&gt; Why can&#39;t we add these features to Mirror in future?<br></p><p><br>Reflection in some other languages works as follows: we have a type (let&#39;s<br>name it &#39;Reflection&#39;). Each instance of it contains ID of one type and can,<br>for example, retrieve an array of its static or normal methods.<br>&#39;Mirror&#39;, on the other hand, serves as a container for information about a<br>single instance. Moreover, types can completely customize contents of their<br>&#39;Mirror&#39;s. This is incompatible with laziness and with how reflection<br>should work, based on experience from other languages.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a2f0b77a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 4:06 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; 2016-07-22 1:34 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt; &gt; Mirror.DisplayStyle contains optional and set as special cases, but does<br>&gt;&gt; &gt; not<br>&gt;&gt; &gt; contain function<br>&gt;&gt; &gt; Mirror collects all information possible at initialization, while for<br>&gt;&gt; &gt; true<br>&gt;&gt; &gt; reflection we want laziness<br>&gt;&gt; &gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a<br>&gt;&gt; &gt; field for each of its elements. Do we want this for “true” reflection we<br>&gt;&gt; &gt; want to add in the future?<br>&gt;&gt;<br>&gt;&gt; Why can&#39;t we add these features to Mirror in future?<br>&gt;<br>&gt;<br>&gt; Reflection in some other languages works as follows: we have a type (let&#39;s<br>&gt; name it &#39;Reflection&#39;). Each instance of it contains ID of one type and can,<br>&gt; for example, retrieve an array of its static or normal methods.<br></p><p>I understand.  But we don&#39;t know how reflection will work in Swift, we<br>haven&#39;t designed it yet.  You are assuming it will work like it does<br>in other languages, which will not necessarily be the case.<br></p><p>&gt; Moreover, types can completely customize contents of their<br>&gt; &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection should<br>&gt; work, based on experience from other languages.<br></p><p>That is actually viewed as a weakness of reflection in other<br>languages.  Allowing reflection to access other types&#39; internal data<br>and APIs creates barriers for optimization, and facilitates creating<br>binary compatibility problems when apps include code that uses<br>reflection to poke at internal data of library types.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>I agree with Dmitri. I would rather see a proper design for reflection<br>(similar to Completing Generics) before we start making any changes to the<br>existing machinery.<br></p><p>Best,<br>Austin<br></p><p>On Thu, Jul 21, 2016 at 4:39 PM, Dmitri Gribenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Thu, Jul 21, 2016 at 4:06 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; 2016-07-22 1:34 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Mirror.DisplayStyle contains optional and set as special cases, but<br>&gt; does<br>&gt; &gt;&gt; &gt; not<br>&gt; &gt;&gt; &gt; contain function<br>&gt; &gt;&gt; &gt; Mirror collects all information possible at initialization, while for<br>&gt; &gt;&gt; &gt; true<br>&gt; &gt;&gt; &gt; reflection we want laziness<br>&gt; &gt;&gt; &gt; Mirror allows customization. For example, Array&lt;T&gt; is represented<br>&gt; with a<br>&gt; &gt;&gt; &gt; field for each of its elements. Do we want this for “true” reflection<br>&gt; we<br>&gt; &gt;&gt; &gt; want to add in the future?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why can&#39;t we add these features to Mirror in future?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Reflection in some other languages works as follows: we have a type<br>&gt; (let&#39;s<br>&gt; &gt; name it &#39;Reflection&#39;). Each instance of it contains ID of one type and<br>&gt; can,<br>&gt; &gt; for example, retrieve an array of its static or normal methods.<br>&gt;<br>&gt; I understand.  But we don&#39;t know how reflection will work in Swift, we<br>&gt; haven&#39;t designed it yet.  You are assuming it will work like it does<br>&gt; in other languages, which will not necessarily be the case.<br>&gt;<br>&gt; &gt; Moreover, types can completely customize contents of their<br>&gt; &gt; &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection<br>&gt; should<br>&gt; &gt; work, based on experience from other languages.<br>&gt;<br>&gt; That is actually viewed as a weakness of reflection in other<br>&gt; languages.  Allowing reflection to access other types&#39; internal data<br>&gt; and APIs creates barriers for optimization, and facilitates creating<br>&gt; binary compatibility problems when apps include code that uses<br>&gt; reflection to poke at internal data of library types.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/15c46251/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 02:00:00am</p></header><div class="content"><p>2016-07-22 2:39 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br></p><p>&gt; On Thu, Jul 21, 2016 at 4:06 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt; Moreover, types can completely customize contents of their<br>&gt; &gt; &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection<br>&gt; should<br>&gt; &gt; work, based on experience from other languages.<br>&gt;<br>&gt; That is actually viewed as a weakness of reflection in other<br>&gt; languages.  Allowing reflection to access other types&#39; internal data<br>&gt; and APIs creates barriers for optimization, and facilitates creating<br>&gt; binary compatibility problems when apps include code that uses<br>&gt; reflection to poke at internal data of library types.<br></p><p><br>I talked about Swift here. Types can completely customize contents of their<br>Mirrors in Swift. A type, which pretends to be used for reflection, can&#39;t<br>afford that.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/a063de25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 21, 2016 at 05:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 4:49 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; 2016-07-22 2:39 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt;&gt;<br>&gt;&gt; On Thu, Jul 21, 2016 at 4:06 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt; Moreover, types can completely customize contents of their<br>&gt;&gt; &gt; &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection<br>&gt;&gt; &gt; should<br>&gt;&gt; &gt; work, based on experience from other languages.<br>&gt;&gt;<br>&gt;&gt; That is actually viewed as a weakness of reflection in other<br>&gt;&gt; languages.  Allowing reflection to access other types&#39; internal data<br>&gt;&gt; and APIs creates barriers for optimization, and facilitates creating<br>&gt;&gt; binary compatibility problems when apps include code that uses<br>&gt;&gt; reflection to poke at internal data of library types.<br>&gt;<br>&gt;<br>&gt; I talked about Swift here.<br></p><p>I am also talking about Swift.  If we build a reflection mechanism<br>that would allow third party code to poke at Array or Dictionary<br>implementation details (or any other type for that matter), we would<br>be exposing us to the same pitfalls as other languages have now.  I<br>would be opposed to doing that.<br></p><p>&gt; Types can completely customize contents of their<br>&gt; Mirrors in Swift.<br></p><p>This is desirable, for implementation hiding reasons.  Nobody should<br>be able to observe implementation details of Array, Dictionary, or any<br>other library types through programmatic mechanisms.<br></p><p>&gt; A type, which pretends to be used for reflection, can&#39;t<br>&gt; afford that.<br></p><p>Why not?<br></p><p>You see, we (as a community) don&#39;t have a shared long-term vision<br>about what &quot;reflection&quot; means.  Establishing that agreement would be<br>the prerequisite to starting any formal proposal process.<br>Speculatively making changes based on hypothetical designs that were<br>not discussed yet will not bring us to a better place.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July 22, 2016 at 04:00:00am</p></header><div class="content"><p>Somehow I did not send a copy to evolution the first time:<br></p><p>I have to agree. Stopping the discussion on this until after Swift 3.<br></p><p>And response from Dmitri:<br></p><p>Thanks!<br></p><p>Just wanted to be clear -- I am not against reflection.  And I am<br>concerned whether the current design of Mirror will work for the<br>long-term full-featured reflection implementation, but only because we<br>don&#39;t know what will be the shape of reflection in Swift.  For<br>example, would we be able to call arbitrary public functions on a type<br>by name?  If yes, how would that be implemented -- both in the API,<br>and on the low level, how would actual function call and argument<br>passing work?  How much extra metadata and thunks would the compiler<br>need to emit?  Would an average app or framework want that bloat?<br>Remember that we don&#39;t have a JIT, so we can&#39;t say &quot;we will do what<br>Java (or any other mainstream language with reflection) does&quot;, because<br>we can&#39;t.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/9ef5dbd4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>I also don&#39;t think this is a worthy change. Mirror can be extended or<br>even changed in the future to become a true reflection base class. No<br>benefits added and breaking code are to me a reason to not go forward<br>with this.<br></p><p>L<br></p><p><br>On 21 July 2016 at 22:05, Anton Zhilin via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Somehow I did not send a copy to evolution the first time:<br>&gt;<br>&gt; I have to agree. Stopping the discussion on this until after Swift 3.<br>&gt;<br>&gt; And response from Dmitri:<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Just wanted to be clear -- I am not against reflection.  And I am<br>&gt; concerned whether the current design of Mirror will work for the<br>&gt; long-term full-featured reflection implementation, but only because we<br>&gt; don&#39;t know what will be the shape of reflection in Swift.  For<br>&gt; example, would we be able to call arbitrary public functions on a type<br>&gt; by name?  If yes, how would that be implemented -- both in the API,<br>&gt; and on the low level, how would actual function call and argument<br>&gt; passing work?  How much extra metadata and thunks would the compiler<br>&gt; need to emit?  Would an average app or framework want that bloat?<br>&gt; Remember that we don&#39;t have a JIT, so we can&#39;t say &quot;we will do what<br>&gt; Java (or any other mainstream language with reflection) does&quot;, because<br>&gt; we can&#39;t.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>August  1, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 22.07.2016 um 01:06 schrieb Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; 2016-07-22 1:34 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; &gt; Mirror.DisplayStyle contains optional and set as special cases, but does not<br>&gt;&gt; &gt; contain function<br>&gt;&gt; &gt; Mirror collects all information possible at initialization, while for true<br>&gt;&gt; &gt; reflection we want laziness<br>&gt;&gt; &gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a<br>&gt;&gt; &gt; field for each of its elements. Do we want this for “true” reflection we<br>&gt;&gt; &gt; want to add in the future?<br>&gt;&gt; <br>&gt;&gt; Why can&#39;t we add these features to Mirror in future?<br>&gt; <br>&gt; Reflection in some other languages works as follows: we have a type (let&#39;s name it &#39;Reflection&#39;). Each instance of it contains ID of one type and can, for example, retrieve an array of its static or normal methods.<br>&gt; &#39;Mirror&#39;, on the other hand, serves as a container for information about a single instance. Moreover, types can completely customize contents of their &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection should work, based on experience from other languages.<br></p><p>Actually mirror based reflection has a couple of advantages like decoupling the reflection API from the normal API and being able to provide different mirrors for different purposes. See the paper of Gilad Bracha who used mirror based reflection in Newspeak and introduced it for Dart:<br></p><p>http://stackoverflow.com/questions/12132264/what-is-the-difference-between-mirror-based-reflection-and-traditional-reflection<br></p><p>http://bracha.org/mirrors.pdf<br></p><p>Abstract of the paper: &quot;We identify three design principles for reflection and metaprogramming facilities in object oriented programming languages.  Encapsulation: meta-level facilities must encapsulate their implementation. Stratification: meta-level facilities must be separated from base-level functionality.  Ontological correspondence: the ontology of meta-level facilities should correspond to the ontology of the language they manipulate. Traditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective APIs built around the concept of mirrors are characterized by adherence to these three principles.&quot;<br></p><p>-Thorsten <br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160801/41aad7a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 4:06 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2016-07-22 1:34 GMT+03:00 Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;:<br>&gt; &gt; Mirror.DisplayStyle contains optional and set as special cases, but does not<br>&gt; &gt; contain function<br>&gt; &gt; Mirror collects all information possible at initialization, while for true<br>&gt; &gt; reflection we want laziness<br>&gt; &gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a<br>&gt; &gt; field for each of its elements. Do we want this for “true” reflection we<br>&gt; &gt; want to add in the future?<br>&gt; <br>&gt; Why can&#39;t we add these features to Mirror in future?<br>&gt; <br>&gt; Reflection in some other languages works as follows: we have a type (let&#39;s name it &#39;Reflection&#39;). Each instance of it contains ID of one type and can, for example, retrieve an array of its static or normal methods.<br>&gt; &#39;Mirror&#39;, on the other hand, serves as a container for information about a single instance. Moreover, types can completely customize contents of their &#39;Mirror&#39;s. This is incompatible with laziness and with how reflection should work, based on experience from other languages.<br></p><p>I think pointing a Mirror at a metatype value could be a good a mechanism for getting information about the type&#39;s stored properties and other members.<br></p><p>FWIW Mirrors are inspired by a feature of the same name in the Self language, which made reflection somewhat more principled than the disorganized APIs you see in Java and C#. Perhaps the latter are not a good model to follow here :-)<br></p><p>Slava<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/ade24032/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Pitch] Rename Mirror</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>August 11, 2016 at 01:00:00am</p></header><div class="content"><p>2016-08-11 0:40 GMT+03:00 Slava Pestov &lt;spestov at apple.com&gt;:<br>&gt;<br>&gt; I think pointing a Mirror at a metatype value could be a good a mechanism<br>&gt; for getting information about the type&#39;s stored properties and other<br>&gt; members.<br>&gt;<br>&gt; FWIW Mirrors are inspired by a feature of the same name in the Self<br>&gt; language, which made reflection somewhat more principled than the<br>&gt; disorganized APIs you see in Java and C#. Perhaps the latter are not a good<br>&gt; model to follow here :-)<br>&gt;<br></p><p>Swift and Self lie in different families of languages.<br>In Self (and Smalltalk, and ObjC), types don&#39;t really matter: one can<br>modify methods, which some object has, independently of all other objects.<br>Because of this dynamism, reflection of types has little value in these<br>languages.<br></p><p>On the other hand, in Swift (and C++, and Java) types do matter. It is<br>useful to get, for example, a Method, and be sure that you can call it on<br>all instances of matching type.<br>I think that Swift should favor types and not instances, as it<br>unfortunately does today.<br></p><p>This is how I imagine reflection API. We have a type ID and can request<br>different information about it. For example:  func getMethod(name: String)<br>-&gt; Method?<br>Most importantly, we should be able to get IDs of other related types, and<br>related type IDs of theirs, and so on, without collecting excessive data.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160811/b380610b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
