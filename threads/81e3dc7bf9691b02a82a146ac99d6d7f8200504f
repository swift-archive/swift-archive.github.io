<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Improve Number Type</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  6, 2016 at 11:00:00pm</p></header><div class="content"><p>There is a number of deficiencies with Swift and Numbers. Especially when<br>trying to be clever with generics.<br></p><p>- The API exposes built in types like`BuiltIn.Word` as the return type of<br>some APIs but there is no way to use said types.<br>- We have a Float and a Float80. Float and Doubles can&#39;t be initialised<br>(via init) with anything but Integer values but Float80 can be initialized<br>with both Floating Point and Integer<br>- We have a SignedNumberType but no UnsignedNumberType, All the floating<br>points use this protocol, so shouldn&#39;t this be NumberType ?<br>- SignedIntegerType and UnsignedIntegerType have a way of generically<br>constructing an Int as long as you cast it to the Maximum Int or UInt. But<br>there is no such thing for Floating Point Numbers.<br>- We have Float80 and a typealised Float32 and Float64. Why couldn&#39;t  have<br>triple as an extra type name, as having one true type with a number is<br>confusing ?<br>- If all number types could be initilized with all number types, then a lot<br>of the constructors could be in the NumberType protocol.<br></p><p>Just in general it was hard to extend integers and floating point types.<br>For example in my code I wanted to pass a struct that contained a value to<br>any Floating Point or Integer and it would convert.<br></p><p>This is what I had to do, which is far too much and even sure I&#39;m not<br>convinced it will work in every condition.<br></p><p>*protocol Box: CustomStringConvertible, CustomDebugStringConvertible {*<br></p><p><br></p><p>*    typealias BoxType = Any*<br></p><p><br></p><p>*    var value: BoxType { get set }*<br></p><p><br></p><p>*    init()*<br></p><p>*    init(_ value: BoxType)*<br></p><p>*}*<br></p><p><br>*protocol AngleType: Box {*<br></p><p>*    typealias BoxType = Double*<br></p><p>*}*<br></p><p>*//Mark:- Box - FloatingPointType Conversion*<br></p><p><br>*extension SignedIntegerType {*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Float80&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Double&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Float&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int8&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int16&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int32&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int64&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt8&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt16&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt32&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt64&gt;(_ value: T) {*<br></p><p>*        self.init(IntMax(value.value))*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension UnsignedIntegerType {*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Float80&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Double&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Float&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int8&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int16&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int32&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int64&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt8&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt16&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt32&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt64&gt;(_ value: T) {*<br></p><p>*        self.init(UIntMax(value.value))*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension Float*<br></p><p>*{*<br></p><p>*    init&lt;T: Box where T.BoxType == Float&gt;(_ value: T)*<br></p><p>*    {*<br></p><p>*        self.value = value.value.value*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension Double*<br></p><p>*{*<br></p><p>*    init&lt;T: Box where T.BoxType == Double&gt;(_ value: T)*<br></p><p>*    {*<br></p><p>*        self.value = value.value.value*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension Float80*<br></p><p>*{*<br></p><p>*    init&lt;T: Box where T.BoxType == Float80&gt;(_ value: T)*<br></p><p>*    {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension FloatingPointType {*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int8&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int16&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int32&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int64&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt8&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt16&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt32&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == UInt64&gt;(_ value: T) {*<br></p><p>*        self.init(value.value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p>-- <br>ï£¿ Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/81e3504f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Improve Number Type</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 3:32 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a number of deficiencies with Swift and Numbers. Especially when trying to be clever with generics.<br>&gt; <br>&gt; - The API exposes built in types like`BuiltIn.Word` as the return type of some APIs but there is no way to use said types.<br>&gt; - We have a Float and a Float80. Float and Doubles can&#39;t be initialised (via init) with anything but Integer values but Float80 can be initialized with both Floating Point and Integer<br>&gt; - We have a SignedNumberType but no UnsignedNumberType, All the floating points use this protocol, so shouldn&#39;t this be NumberType ?<br>&gt; - SignedIntegerType and UnsignedIntegerType have a way of generically constructing an Int as long as you cast it to the Maximum Int or UInt. But there is no such thing for Floating Point Numbers.<br>&gt; - We have Float80 and a typealised Float32 and Float64. Why couldn&#39;t  have triple as an extra type name, as having one true type with a number is confusing ? <br>&gt; - If all number types could be initilized with all number types, then a lot of the constructors could be in the NumberType protocol.<br></p><p>Weâre currently working on improving most of these things.  You can see some of our work in progress here:<br>https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb<br>https://github.com/apple/swift/blob/master/test/Prototypes/FloatingPoint.swift<br></p><p><br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Rename Number Type Bitwise Operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>While weâre (sorta) on the topic, is there any chance the bitwise operators (â&amp;â, â|â, and &quot;^&quot;) could be renamed to &quot;.&amp;â, &quot;.|â, and &quot;.^â? Or maybe only defined for some sort of Bitfield&lt;T&gt; wrapper type? â^â already has a numeric meaning (3^2 = 9), and â|â and â&amp;â are a convenient custom operators (theyâre easy to recognize and I think are the only two single-character vclid operators that doesnât require obscure keystrokes to type and donât already have a fairly obvious meaning).<br></p><p>(Mostly Iâm interested in â|â and â^â, but itâd be weird and confusing to treat â&amp;â specially.)<br></p><p><br></p><p>&gt; On Jan 6, 2016, at 15:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 3:32 PM, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There is a number of deficiencies with Swift and Numbers. Especially when trying to be clever with generics.<br>&gt;&gt; <br>&gt;&gt; - The API exposes built in types like`BuiltIn.Word` as the return type of some APIs but there is no way to use said types.<br>&gt;&gt; - We have a Float and a Float80. Float and Doubles can&#39;t be initialised (via init) with anything but Integer values but Float80 can be initialized with both Floating Point and Integer<br>&gt;&gt; - We have a SignedNumberType but no UnsignedNumberType, All the floating points use this protocol, so shouldn&#39;t this be NumberType ?<br>&gt;&gt; - SignedIntegerType and UnsignedIntegerType have a way of generically constructing an Int as long as you cast it to the Maximum Int or UInt. But there is no such thing for Floating Point Numbers.<br>&gt;&gt; - We have Float80 and a typealised Float32 and Float64. Why couldn&#39;t  have triple as an extra type name, as having one true type with a number is confusing ? <br>&gt;&gt; - If all number types could be initilized with all number types, then a lot of the constructors could be in the NumberType protocol.<br>&gt; <br>&gt; Weâre currently working on improving most of these things.  You can see some of our work in progress here:<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Integers.swift.gyb<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/FloatingPoint.swift<br>&gt; <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Rename Number Type Bitwise Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 8:42 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While weâre (sorta) on the topic, is there any chance the bitwise operators (â&amp;â, â|â, and &quot;^&quot;) could be renamed to &quot;.&amp;â, &quot;.|â, and &quot;.^â? Or maybe only defined for some sort of Bitfield&lt;T&gt; wrapper type? â^â already has a numeric meaning (3^2 = 9), and â|â and â&amp;â are a convenient custom operators (theyâre easy to recognize and I think are the only two single-character vclid operators that doesnât require obscure keystrokes to type and donât already have a fairly obvious meaning).<br></p><p>Almost certainly no.  The bar for diverging for the C family precedent on this is very high.  Saying that you want to rename (e.g.) ^ to .^ so that you can repurpose ^ for some other thing is extremely unlikely to happen.<br></p><p>If you are really interested in exponentiation, ** is a better path to follow.  However, even that has a number of problems that the numerics folks will jump onto :-)<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
