<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Re: Database API/Framework</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October 26, 2016 at 02:00:00am</p></header><div class="content"><p>(Sorry for the fake threading; I read this thread in the web archive and wanted to chime in.)<br></p><p>Helge Heß: <br></p><p>&gt; &gt; 4. Coming from a diverse backend/server background, I’ve seen different lang+environments handle sql interfaces differently. Most have left it up to third party frameworks/ecosystems (ruby/node/python) but some like Golang provide at least a default SQL interface that driver authors can adapt to. I’m starting to lean towards the latter of the two but I’m by no means and expert on anything :). This probably needs more community engagement/proposal.<br>&gt; <br>&gt; <br>&gt; IMHO that sounds more like something the higher level frameworks (ORMs) should be concerned about (as they will define what they want to map from and how, and probably in pretty different ways). But maybe not. Personally I’d like to avoid something like JDBC as it provides little value at extra overhead.<br>&gt; <br>&gt; As an example: if I have received a DispatchData from the socket containing a PG row values, I don’t want to first convert that to a JDBC or EOAdaptor record-Dictionary&lt;Key,Any&gt;&gt; which is then mapped to a Customer.purchaseStatus enum. I would rather like to pass up that DispatchData to the highest level and only have it converted at the very last point and only if necessary - sometimes an ORM, but other times it may be just directly streamed into a different format, say JSON (in such cases you can often accomplish zero-copy).<br>&gt; <br>&gt; &gt; My hope is we can start writing some of the drivers in pure Swift and help all those frameworks/libs get better too.<br>&gt; <br>&gt; <br>&gt; Not sure a generic ‘driver&#39; interface will help a lot here. I think you help most by providing a SwiftPQ library which can then be integrated by the ORMs/frameworks in a way which fits best.<br></p><p>I think Perl has a good model we might want to pay attention to. Perl has a largely database-independent library called DBI (Database Interface) which basically just standardizes the interfaces to connect to databases, run queries, iterate through results, examine schemas, and so on. A system of plug-ins, called DBDs (Database Drivers), handle each individual database. Applications can either use DBI directly or through a library that functions as an ORM. (Most of these higher-level libraries are called DBI Extensions (DBIx), though this is just a convention.)<br></p><p>		Drivers		Interface		Extension/Client<br>	DBD::MySQL	-+			+- DBIx::Class<br>	DBD::PG		-+----- DBI -----	+- DBIx::DataModel<br>	DBD::Oracle	-+			+- Direct use<br></p><p>DBI doesn&#39;t abstract away *all* differences between databases. But it gets most of them, and in practice, it&#39;s not very difficult to switch from one database to another, or use different databases in development and production. It saves individual ORMs from needing to individually implement different database backends, and facilitates sharing of code for features like connection pooling. If the interest is there, this can support a wide and varied ecosystem: Perl&#39;s CPAN module repository includes 103 DBD modules and 473 DBIx modules.<br></p><p>In Swift, we may also be able to use it to encourage good database practices. The control Swift offers over string literals and interpolation could be leveraged to encourage use of prepared statements and good escaping (or rather, use of parameterized queries instead of escaping). Imagine if, when you wrote something like this, it was perfectly safe:<br></p><p>	let userID = …<br>	for row in try connection.query(&quot;SELECT * FROM posts WHERE user_id = \(userID)&quot;) {<br>		// `query`&#39;s parameter is actually a `SQLStatement`, so the string literal is actually a SQL statement literal.<br>		…<br>	}<br></p><p>Because `userID` would be an `Int`—that is, a type expected to contain data—it would be automatically passed as a parameter so there were no escaping issues. If you used a type for a table, column, or fragment of a statement, on the other hand, it would be handled appropriately:<br></p><p>	let userID = …<br>	let sortColumnName = …<br>	let ascending = …<br>	<br>	let postsTable = try! SQLTable(&quot;posts&quot;, in: connection)<br>	let sortColumn = try SQLColumn(named: sortColumnName, in: postsTable)<br>	let sortDirection: SQLFragment = ascending ? &quot;ASC&quot; : &quot;DESC&quot;<br>	<br>	for row in try connection.query(&quot;SELECT * FROM \(postsTable) WHERE user_id = \(userID) ORDER BY \(sortColumn) \(sortDirection)&quot;) {<br>		// In the above, the SQLTable, SQLColumn, and SQLStatementFragment are inserted without escaping,<br>		// while the non-database-specific userID is passed as a parameter.<br>		…<br>	}<br></p><p>This is cool stuff that the dynamic languages don&#39;t offer, but you probably don&#39;t want to write it for each individual database driver. You want to write it once, either at the database-independent interface layer or as a layer above it. To do that, you need to funnel all database use through a single chokepoint. In other words, you need something like DBI.<br></p><p>I&#39;m not saying we should adopt DBI exactly as it is—Swift would demand a very different design. But I think we should consider using a similar architecture. It has a lot of advantages over forcing high-level frameworks to talk directly to low-level databases.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d23c2d6c1ccb724044f09d449772ff2?s=50"></div><header><strong>Database API/Framework</strong> from <string>Helge Heß</string> &lt;me at helgehess.eu&gt;<p>October 26, 2016 at 12:00:00pm</p></header><div class="content"><p>On 26 Oct 2016, at 11:34, Brent Royal-Gordon via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; I&#39;m not saying we should adopt DBI exactly as it is—Swift would demand a very different design. But I think we should consider using a similar architecture. It has a lot of advantages over forcing high-level frameworks to talk directly to low-level databases.<br></p><p>This is essentially the original message of the request, the desire to have a JDBC. Maybe people really want to have that :-) I guess a few protocols for simple use cases do not hurt, but I would advise against over designing this.<br></p><p>IMHO it doesn’t make that much sense since todays databases are so different. If you are a PostgreSQL user, you quite likely want to make use of its features (be it JSON columns, FTS, custom types, row permissions, table inheritance, etc).<br>Even pooling has very different requirements based on the setup of the database (e.g. in PG connections are pretty expensive, in others not at all, and SQLite doesn’t even have them). Let alone transactions and how they behave.<br>Presumably a HL framework has to have specific support to account for dealing with such differences, it can’t just rely on ‘JDBC&#39;.<br></p><p>Personally I’m more interested in comprehensive interaction modules for the respective databases that can be used by all HL projects than in an API trying to bundle everything into a set of basic protocols. It is the HL project presenting a consistent API to the enduser (be it a full ORM or something more low level [e.g. I would rather stream batches of tuples coming from the database than building an EOF/CoreData like object graph]).<br></p><p><br>But I’m quite interested to see what proposals are coming in :-)<br></p><p>hh<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
