<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/29ecaf0e7e9314d299cb486e3f05016f?s=50"></div><header><strong>Swift and Threads</strong> from <string>Gerriet M. Denkmann</string> &lt;gerriet at mdenkmann.de&gt;<p>September 13, 2016 at 11:00:00am</p></header><div class="content"><p>This function works flawlessly in Release build:<br></p><p>func markAndTell( talk: Bool, number: Int)<br>{<br>	let nbrOfThreads = 8<br>	let step = 2<br>	let itemsPerThread = number * step<br>	let bitLimit = nbrOfThreads * itemsPerThread<br>	var bitfield = [Bool](count: bitLimit, repeatedValue: false)<br></p><p>	let queue = dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_HIGH, 0 );<br>	dispatch_apply( Int(nbrOfThreads), queue,<br>		{ ( idx: size_t) -&gt; Void in<br>			<br>			let startIndex = itemsPerThread * Int(idx)<br>			let endIndex = min( startIndex + itemsPerThread, bitLimit )<br>			if talk { print(&quot;Thread[\(idx)] does \(startIndex) ..&lt; \(endIndex)&quot;)}<br>			<br>			var currIndex = startIndex<br>			while( currIndex &lt; endIndex )<br>			{<br>				bitfield[currIndex] = true	//	this might crash<br>				currIndex += step<br>			}<br>		}<br>	)<br>}<br></p><p>But it does not work in Debug builds.<br></p><p>“does not work” means: for !talk and any number &gt; 0 or: talk and number ≥ 110:<br></p><p>malloc: *** error for object 0x101007808: incorrect checksum for freed object <br>- object was probably modified after being freed. *** set a breakpoint in malloc_error_break to debug<br></p><p>Or:<br>fatal error: UnsafeMutablePointer.initializeFrom non-following overlapping range<br></p><p>Or:<br>just plain wrong data in bitfield.<br></p><p>So: is the code ok and the compiler broken in Debug mode?<br>Or is the code fundamentally wrong and that it works in Release is just a fluke?<br>If so: how could it be fixed?<br></p><p>Btw.: no problems with bitfield malloced into some UnsafeMutablePointer&lt;UInt8&gt;.<br></p><p>Gerriet.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Swift and Threads</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 13, 2016 at 08:00:00am</p></header><div class="content"><p>On 13 Sep 2016, at 05:03, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; Or is the code fundamentally wrong …?<br></p><p>This one.<br></p><p>You’re accessing a mutable value (`bitfield`) from multiple threads.  Swift does not support that, even in situations like this where you’re sure that the items are preallocated and that the threads are accessing non-overlapping values.<br></p><p>As to how you fix this, it kinda depends on your final use for the array.  If you’re OK with the results being split into per-thread chunks, you can have each thread work on its own chunk and then pass the results back to the ‘main’ thread when it’s done.  OTOH, if you need your results in one big array, things get tricky.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/29ecaf0e7e9314d299cb486e3f05016f?s=50"></div><header><strong>Swift and Threads</strong> from <string>Gerriet M. Denkmann</string> &lt;gerriet at mdenkmann.de&gt;<p>September 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 13 Sep 2016, at 14:49, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 13 Sep 2016, at 05:03, Gerriet M. Denkmann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Or is the code fundamentally wrong …?<br>&gt; <br>&gt; This one.<br>&gt; <br>&gt; You’re accessing a mutable value (`bitfield`) from multiple threads.  Swift does not support that, even in situations like this where you’re sure that the items are preallocated and that the threads are accessing non-overlapping values.<br>&gt; <br>&gt; As to how you fix this, it kinda depends on your final use for the array.  If you’re OK with the results being split into per-thread chunks, you can have each thread work on its own chunk and then pass the results back to the ‘main’ thread when it’s done.  OTOH, if you need your results in one big array, things get tricky.<br></p><p>Stephen J. Butler just suggested a solution (on CocoaDev) which works and is fast and uses no additional memory.<br></p><p>Here it is:<br></p><p>let nbrOfThreads = 8<br>let step = 2<br>let itemsPerThread = number * step<br>let bitLimit = nbrOfThreads * itemsPerThread<br>var bitfield = [Bool](count: bitLimit, repeatedValue: false)<br></p><p>let queue = dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_HIGH, 0 );<br></p><p>bitfield.withUnsafeMutableBufferPointer { (inout bitfieldBuffer : UnsafeMutableBufferPointer&lt;Bool&gt;) -&gt; () in<br>    dispatch_apply( Int(nbrOfThreads), queue ) { ( idx: size_t) -&gt; Void in<br>        let startIndex = itemsPerThread * Int(idx)<br>        let endIndex = min( startIndex + itemsPerThread, bitLimit )<br>        if talk { print(&quot;Thread[\(idx)] does \(startIndex) ..&lt; \(endIndex)&quot;) }<br></p><p>        var currIndex = startIndex<br>        while( currIndex &lt; endIndex )<br>        {<br>            bitfieldBuffer[currIndex] = true<br>            currIndex += step<br>        }<br>    }<br>}<br></p><p>I hope that this is really thread-safe (testing it, I have no problems so far).<br></p><p>Kind regards,<br></p><p>Gerriet.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
