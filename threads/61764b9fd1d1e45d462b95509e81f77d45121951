<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi Swift-devs,<br>I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br></p><p>Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br></p><p>Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br></p><p>Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>	<br>Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br></p><p>So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br></p><p>Thanks for your feedback!<br>Xi<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/61761951/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecb50a99bf3b4cc0249312945dce7115?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Ben Langmuir</string> &lt;blangmuir at apple.com&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Swift-devs,<br>&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt; <br>&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt; <br>&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt; <br>&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt; 	<br>&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt; <br>&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt; <br>&gt; Thanks for your feedback!<br>&gt; Xi<br>&gt; <br></p><p>-1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br></p><p>My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br></p><p>[1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>[1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br></p><p><br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/30138800/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>July  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:19 PM, Ben Langmuir &lt;blangmuir at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Swift-devs,<br>&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt; <br>&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt; <br>&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt; <br>&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt; 	<br>&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt; <br>&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback!<br>&gt;&gt; Xi<br>&gt;&gt; <br>&gt; <br>&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt; <br>&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt; <br>&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt; <br></p><p>oh, good example! The code examples I came up with are those where labels are not very informative, like:<br></p><p>  q.async(execute: {})<br>  q.after(when: DispatchTime.now(), execute: {})<br></p><p>Probably, the warning/fixit should be opt-out/in, like an attribute @trailing_closure_prefered on the function decl, thoughts?<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/f8e06b65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>July  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 5:39 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 5:19 PM, Ben Langmuir &lt;blangmuir at apple.com &lt;mailto:blangmuir at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your feedback!<br>&gt;&gt;&gt; Xi<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt;&gt; <br>&gt;&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt;&gt; <br>&gt;&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt;&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt;&gt; <br>&gt; <br>&gt; oh, good example! The code examples I came up with are those where labels are not very informative, like:<br>&gt; <br>&gt;   q.async(execute: {})<br>&gt;   q.after(when: DispatchTime.now(), execute: {})<br>&gt; <br>&gt; Probably, the warning/fixit should be opt-out/in, like an attribute @trailing_closure_prefered on the function decl, thoughts?<br>&gt; <br>&gt; <br></p><p>Another benefit of adding such attribute is to govern code completion UI the way to expand a closure placeholder. Currently, we expand<br>closure unequivocally to trailing closures, even for lexicographicallyPrecedes(isOrderedBefore:)<br></p><p><br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/b50b34e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 7:42 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 5:39 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 5:19 PM, Ben Langmuir &lt;blangmuir at apple.com &lt;mailto:blangmuir at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br></p><p><br>I prefer trailing closures for -&gt; Void signatures and in-line closures for anything (notably sequences and collections) that is likely to be iterated through or chained functionally. I also prefer inline closures for items that have multiple states for callback (completion handlers, error handlers, etc, where there is going to be a test of some kind -- we don&#39;t have a Result type but if we did, it would fall here -- and contains error/value pairs) and trailing closures for no-state-will-execute such as GCD.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/06c0d9b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecb50a99bf3b4cc0249312945dce7115?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Ben Langmuir</string> &lt;blangmuir at apple.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 7:57 PM, Erica Sadun via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 7:42 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 5:39 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 5:19 PM, Ben Langmuir &lt;blangmuir at apple.com &lt;mailto:blangmuir at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt; <br>&gt; <br>&gt; I prefer trailing closures for -&gt; Void signatures and in-line closures for anything (notably sequences and collections) that is likely to be iterated through or chained functionally.<br></p><p>I’m not sure if this matches your personal preferences, but your example made me realize the decision can also easily be context-dependent.  I would probably write a single map with a trailing closure,<br></p><p>[0, 1, 2, 3].map {<br>  // code<br>}<br></p><p>But a chain without trailing closures.<br></p><p>[0, 1, 2, 3].map({ /* code */ }).filter({ /* code */})<br></p><p>&gt; I also prefer inline closures for items that have multiple states for callback (completion handlers, error handlers, etc, where there is going to be a test of some kind -- we don&#39;t have a Result type but if we did, it would fall here -- and contains error/value pairs) and trailing closures for no-state-will-execute such as GCD.<br></p><p>And these callbacks are a place I really like to use trailing closures, which reinforces to me that we shouldn’t try to force one style or the other.<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160706/639eb844/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 17:19, Ben Langmuir via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Swift-devs,<br>&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt; <br>&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt; <br>&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt; <br>&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt; 	<br>&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt; <br>&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback!<br>&gt;&gt; Xi<br>&gt;&gt; <br>&gt; <br>&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt; <br>&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt; <br>&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br></p><p>I strongly agree with Ben. This is a style choice and highly context-dependent. We should not warn about it or produce a fix-it unless specifically requested, and we don’t have any place for such requests today.<br></p><p>(Motivation: Another case where I prefer not using a trailing closure is when there are other closure arguments in the call.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/3da22101/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>July  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 8:31 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 17:19, Ben Langmuir via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your feedback!<br>&gt;&gt;&gt; Xi<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt;&gt; <br>&gt;&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt;&gt; <br>&gt;&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt;&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt; <br>&gt; I strongly agree with Ben. This is a style choice and highly context-dependent. We should not warn about it or produce a fix-it unless specifically requested, and we don’t have any place for such requests today.<br>&gt; <br>&gt; (Motivation: Another case where I prefer not using a trailing closure is when there are other closure arguments in the call.)<br>&gt; <br></p><p>I agree with you if by “context-sensitive”, you mean “function-signature-sensitive”; and we can solve that by adding a new attribute on function decls to categorize a function into either “trailing closure preferred” or “inline closure preferred”.<br>“lexicographicallyPrecedes” is a good example of the later while &quot;DispatchQueue.async(execute:)” is of the former. Any other contexts in your mind?<br>Xi<br></p><p>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160705/bad711ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 5, 2016, at 21:29, Xi Ge &lt;xi_ge at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 8:31 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 17:19, Ben Langmuir via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt;&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for your feedback!<br>&gt;&gt;&gt;&gt; Xi<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt;&gt;&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt;&gt; <br>&gt;&gt; I strongly agree with Ben. This is a style choice and highly context-dependent. We should not warn about it or produce a fix-it unless specifically requested, and we don’t have any place for such requests today.<br>&gt;&gt; <br>&gt;&gt; (Motivation: Another case where I prefer not using a trailing closure is when there are other closure arguments in the call.)<br>&gt;&gt; <br>&gt; <br>&gt; I agree with you if by “context-sensitive”, you mean “function-signature-sensitive”; and we can solve that by adding a new attribute on function decls to categorize a function into either “trailing closure preferred” or “inline closure preferred”.<br>&gt; “lexicographicallyPrecedes” is a good example of the later while &quot;DispatchQueue.async(execute:)” is of the former. Any other contexts in your mind?<br></p><p>For once I don’t think that this is something that makes sense for the API author to control. It should always be legal to replace a named closure with an anonymous closure without any other changes.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160706/15e9454f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3cc60df2d77f658efe8b66631a58b2fd?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Xi Ge</string> &lt;xi_ge at apple.com&gt;<p>July  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 9:39 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 5, 2016, at 21:29, Xi Ge &lt;xi_ge at apple.com &lt;mailto:xi_ge at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 8:31 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 17:19, Ben Langmuir via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt;&gt;&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for your feedback!<br>&gt;&gt;&gt;&gt;&gt; Xi<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt;&gt;&gt;&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly agree with Ben. This is a style choice and highly context-dependent. We should not warn about it or produce a fix-it unless specifically requested, and we don’t have any place for such requests today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Motivation: Another case where I prefer not using a trailing closure is when there are other closure arguments in the call.)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree with you if by “context-sensitive”, you mean “function-signature-sensitive”; and we can solve that by adding a new attribute on function decls to categorize a function into either “trailing closure preferred” or “inline closure preferred”.<br>&gt;&gt; “lexicographicallyPrecedes” is a good example of the later while &quot;DispatchQueue.async(execute:)” is of the former. Any other contexts in your mind?<br>&gt; <br>&gt; For once I don’t think that this is something that makes sense for the API author to control. It should always be legal to replace a named closure with an anonymous closure without any other changes.<br>&gt; <br></p><p>Isn’t trailing closure more amenable to completion blocks/callbacks than predicates like “isOrderedBefore”. Aren’t API authors the best people to tell the role of the closure?<br>Xi<br></p><p>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160706/908dcc51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Fixit for trailing closures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 10:31, Xi Ge &lt;xi_ge at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 6, 2016, at 9:39 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 5, 2016, at 21:29, Xi Ge &lt;xi_ge at apple.com &lt;mailto:xi_ge at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 5, 2016, at 8:31 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 5, 2016, at 17:19, Ben Langmuir via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 5, 2016, at 4:34 PM, Xi Ge via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Swift-devs,<br>&gt;&gt;&gt;&gt;&gt;&gt; I have tried to add a fixit to help developers using trailing closures more, motivated by my observation during WWDC that some developers <br>&gt;&gt;&gt;&gt;&gt;&gt; do not even realize that we have such a feature. In my opinion, trailing closures are more concise, and once you get used to it, more readable; <br>&gt;&gt;&gt;&gt;&gt;&gt; therefore users should adopt trailing closures whenever doing so introduces no ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Fixits can enhance the discoverability of trailing closures by identifying misuses and by transforming users’ code automatically. However, adding the fixit introduces new issues:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Issue 1: The fixit has to be associated with a warning. Adding the warning means we declare wars against convertible non-trailing closures, which is a valid syntax choice by users.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Issue 2: Ambiguity checking should be exhaustive. We have several known situations when non-trailing closures cannot be convert to trailing closures, including:<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; Trailing closures are followed by other brackets, e.g., “if foo({}) {}” cannot be converted to “if foo {} {}”.<br>&gt;&gt;&gt;&gt;&gt;&gt; Removing the label of the last closure causes ambiguous function references, e.g. “foo(v: {})” cannot be converted to “foo {}” when “foo(v1: {})” also exists.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So Swift-devs, is the warning worth adding? If yes, are there other situations of ambiguity that are not covered?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for your feedback!<br>&gt;&gt;&gt;&gt;&gt;&gt; Xi<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1, this feels like a really good tool to have in a code-linter, but not something that we should put in the compiler and prescribe to all our users.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My biggest concern is that it’s not always obvious what the closure is used for.  The argument label can help with this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [1].lexicographicallyPrecedes([0]) { &lt;#code#&gt; }<br>&gt;&gt;&gt;&gt;&gt; [1].lexicographicallyPrecedes([0], isOrderedBefore: { &lt;#code#&gt; })<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I strongly agree with Ben. This is a style choice and highly context-dependent. We should not warn about it or produce a fix-it unless specifically requested, and we don’t have any place for such requests today.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Motivation: Another case where I prefer not using a trailing closure is when there are other closure arguments in the call.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with you if by “context-sensitive”, you mean “function-signature-sensitive”; and we can solve that by adding a new attribute on function decls to categorize a function into either “trailing closure preferred” or “inline closure preferred”.<br>&gt;&gt;&gt; “lexicographicallyPrecedes” is a good example of the later while &quot;DispatchQueue.async(execute:)” is of the former. Any other contexts in your mind?<br>&gt;&gt; <br>&gt;&gt; For once I don’t think that this is something that makes sense for the API author to control. It should always be legal to replace a named closure with an anonymous closure without any other changes.<br>&gt;&gt; <br>&gt; <br>&gt; Isn’t trailing closure more amenable to completion blocks/callbacks than predicates like “isOrderedBefore”. Aren’t API authors the best people to tell the role of the closure?<br></p><p>I don&#39;t think that&#39;s a rule that&#39;s universally agreed on. I use trailing closures for pretty much everything except when there are multiple closure arguments. Erica and others use them for imperative code only. Some people don&#39;t use them at all, maybe because they want to preserve the argument label.<br></p><p>We could try to enforce a universal style here, but that&#39;s a direction we need to consciously decide to go in; it&#39;s not just clean-up of our existing model. Additionally, we&#39;d then have to come up with an importer rule for deciding which closures are trailing in imported APIs, and allow API owners to control that.<br></p><p>I do see that it&#39;s not out of line for API authors to be able to control this, but I think we should actually design such a thing properly, and we can do that at any time as long as it&#39;s just warnings or a separate style checker.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160706/c2646460/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
