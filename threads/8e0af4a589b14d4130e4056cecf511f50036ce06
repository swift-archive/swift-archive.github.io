<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  2, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon May 02 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Open issue: Class types and inheritance<br>&gt;<br>&gt; While this approach works well for value types, these static operators may not<br>&gt; work as expected for class types when inheritance is involved, and more work may<br>&gt; be needed here.<br>&gt;<br>&gt; We can currently model the behavior we&#39;d like to achieve by using a named eq<br>&gt; method instead of the operator itself. (Note that we are not proposing that the<br>&gt; function be named eq in the final design; this was done simply to perform the<br>&gt; experiment with today&#39;s compiler.) Then we implement both the new method and the<br>&gt; current == operator and compare their behaviors. For example:<br>&gt;<br>&gt; protocol ProposedEquatable {<br>&gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; class Base: ProposedEquatable, Equatable {<br>&gt;   static func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Base.eq&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }<br>&gt; func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt;   print(&quot;==(Base, Base)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt;<br>&gt; class Subclass: Base {<br>&gt;   static func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }<br>&gt; func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt;<br>&gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt;   return T.eq(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; let x = Subclass()<br>&gt; let y = Subclass()<br>&gt; let z = y as Base<br>&gt;<br>&gt; eq(x, y)  // prints &quot;Base.eq&quot;<br>&gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt;<br>&gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt;<br>&gt; The result of eq(x, y) was a bit surprising, since the generic argument T is<br>&gt; bound to Subclass and there should be no dynamic dispatch at play there. (Is the<br>&gt; issue that since Base is the class explicitly conforming to ProposedEquatable,<br>&gt; this is locking in Self being bound as Base, causing that overload to be found<br>&gt; in the compiler&#39;s search? Or is this a bug?)<br>&gt;<br>&gt; An attempt was also made to fix this using dynamic dispatch, by implementing eq<br>&gt; as a class method instead of astatic method:<br>&gt;<br>&gt; protocol ProposedEquatable {<br>&gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; class Base: ProposedEquatable, Equatable {<br>&gt;   class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Base.eq&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }<br>&gt; func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt;   print(&quot;==(Base, Base)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt;<br>&gt; class Subclass: Base {<br>&gt;   override class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Base, Base)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt;   class func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt;     return true<br>&gt;   }<br>&gt; }<br>&gt; func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt;   return true<br>&gt; }<br>&gt;<br>&gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt;   return T.eq(lhs, rhs)<br>&gt; }<br>&gt;<br>&gt; let x = Subclass()<br>&gt; let y = Subclass()<br>&gt; let z = y as Base<br>&gt;<br>&gt; eq(x, y)  // prints &quot;Subclass.eq(Base, Base)&quot;<br>&gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt;<br>&gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt;<br>&gt; This helped slightly, since at least it resulting in a method on the expected<br>&gt; subclass being called, but this still means that anyone implementing this<br>&gt; operator on subclasses would have to do some casting, and it&#39;s awkward that<br>&gt; subclasses would be expected to write its operator in terms of the conforming<br>&gt; base class.<br>&gt;<br>&gt; It should also be noted (code not provided here) that using instance methods<br>&gt; does not solve this problem, presumably for the same dispatch-related reasons<br>&gt; that the class methods called the version with Base arguments.<br></p><p>Do we not have essentially all the same problems with classes, even with<br>today&#39;s Equatable?  If not, what are the differences?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] Improving operator requirements in protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>May  2, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, May 2, 2016 at 1:25 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Mon May 02 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; Open issue: Class types and inheritance<br>&gt; &gt;<br>&gt; &gt; While this approach works well for value types, these static operators<br>&gt; may not<br>&gt; &gt; work as expected for class types when inheritance is involved, and more<br>&gt; work may<br>&gt; &gt; be needed here.<br>&gt; &gt;<br>&gt; &gt; We can currently model the behavior we&#39;d like to achieve by using a<br>&gt; named eq<br>&gt; &gt; method instead of the operator itself. (Note that we are not proposing<br>&gt; that the<br>&gt; &gt; function be named eq in the final design; this was done simply to<br>&gt; perform the<br>&gt; &gt; experiment with today&#39;s compiler.) Then we implement both the new method<br>&gt; and the<br>&gt; &gt; current == operator and compare their behaviors. For example:<br>&gt; &gt;<br>&gt; &gt; protocol ProposedEquatable {<br>&gt; &gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Base: ProposedEquatable, Equatable {<br>&gt; &gt;   static func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt; &gt;     print(&quot;Base.eq&quot;)<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt; &gt;   print(&quot;==(Base, Base)&quot;)<br>&gt; &gt;   return true<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Subclass: Base {<br>&gt; &gt;   static func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt; &gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt; &gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt; &gt;   return true<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt; &gt;   return T.eq(lhs, rhs)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; let x = Subclass()<br>&gt; &gt; let y = Subclass()<br>&gt; &gt; let z = y as Base<br>&gt; &gt;<br>&gt; &gt; eq(x, y)  // prints &quot;Base.eq&quot;<br>&gt; &gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt; &gt;<br>&gt; &gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; &gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt; &gt;<br>&gt; &gt; The result of eq(x, y) was a bit surprising, since the generic argument<br>&gt; T is<br>&gt; &gt; bound to Subclass and there should be no dynamic dispatch at play there.<br>&gt; (Is the<br>&gt; &gt; issue that since Base is the class explicitly conforming to<br>&gt; ProposedEquatable,<br>&gt; &gt; this is locking in Self being bound as Base, causing that overload to be<br>&gt; found<br>&gt; &gt; in the compiler&#39;s search? Or is this a bug?)<br>&gt; &gt;<br>&gt; &gt; An attempt was also made to fix this using dynamic dispatch, by<br>&gt; implementing eq<br>&gt; &gt; as a class method instead of astatic method:<br>&gt; &gt;<br>&gt; &gt; protocol ProposedEquatable {<br>&gt; &gt;   static func eq(lhs: Self, _ rhs: Self) -&gt; Bool<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Base: ProposedEquatable, Equatable {<br>&gt; &gt;   class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt; &gt;     print(&quot;Base.eq&quot;)<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; func ==(lhs: Base, rhs: Base) -&gt; Bool {<br>&gt; &gt;   print(&quot;==(Base, Base)&quot;)<br>&gt; &gt;   return true<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class Subclass: Base {<br>&gt; &gt;   override class func eq(lhs: Base, _ rhs: Base) -&gt; Bool {<br>&gt; &gt;     print(&quot;Subclass.eq(Base, Base)&quot;)<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt;   class func eq(lhs: Subclass, _ rhs: Subclass) -&gt; Bool {<br>&gt; &gt;     print(&quot;Subclass.eq(Subclass, Subclass)&quot;)<br>&gt; &gt;     return true<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt; func ==(lhs: Subclass, rhs: Subclass) -&gt; Bool {<br>&gt; &gt;   print(&quot;==(Subclass, Subclass)&quot;)<br>&gt; &gt;   return true<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; func eq&lt;T: ProposedEquatable&gt;(lhs: T, _ rhs: T) -&gt; Bool {<br>&gt; &gt;   return T.eq(lhs, rhs)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; let x = Subclass()<br>&gt; &gt; let y = Subclass()<br>&gt; &gt; let z = y as Base<br>&gt; &gt;<br>&gt; &gt; eq(x, y)  // prints &quot;Subclass.eq(Base, Base)&quot;<br>&gt; &gt; eq(x, z)  // prints &quot;Base.eq&quot;<br>&gt; &gt;<br>&gt; &gt; x == y    // prints &quot;==(Subclass, Subclass)&quot;<br>&gt; &gt; x == z    // prints &quot;==(Base, Base)&quot;<br>&gt; &gt;<br>&gt; &gt; This helped slightly, since at least it resulting in a method on the<br>&gt; expected<br>&gt; &gt; subclass being called, but this still means that anyone implementing this<br>&gt; &gt; operator on subclasses would have to do some casting, and it&#39;s awkward<br>&gt; that<br>&gt; &gt; subclasses would be expected to write its operator in terms of the<br>&gt; conforming<br>&gt; &gt; base class.<br>&gt; &gt;<br>&gt; &gt; It should also be noted (code not provided here) that using instance<br>&gt; methods<br>&gt; &gt; does not solve this problem, presumably for the same dispatch-related<br>&gt; reasons<br>&gt; &gt; that the class methods called the version with Base arguments.<br>&gt;<br>&gt; Do we not have essentially all the same problems with classes, even with<br>&gt; today&#39;s Equatable?  If not, what are the differences?<br>&gt;<br></p><p>We do have some problems today, such as above where using `==` on a `(Base,<br>Subclass as Base)` pair ends up calling `==(Base, Base)` because we lack<br>multiple dispatch. What surprised me though was that the `eq` call between<br>two `Subclass` instances passed to the trampoline operator ended up calling<br>`Base.eq`. I would have expected `Subclass.eq` to be called there since the<br>generic argument `T` was bound to `Subclass`. Today, a non-generic<br>`==(Subclass, Subclass)` operator *does* do the right thing.<br></p><p>I mainly called it out because the problems we have with `==` today are<br>slightly different than the problems encountered when testing out the new<br>model. If the decision is &quot;operators with Self constraints are<br>fundamentally hard with classes and we don&#39;t necessarily expect them to<br>work consistently&quot;, then that&#39;s fine, but I wanted to make sure it wasn&#39;t a<br>hole in the proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160502/99667c67/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
